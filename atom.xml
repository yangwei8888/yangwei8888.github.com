<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[yosita]]></title>
  <subtitle><![CDATA[ѧ��]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-12-15T06:25:19.563Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[terry]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[01Getting Started-基本设置]]></title>
    <link href="http://yoursite.com/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/01Getting%20Started/Basic%20Setup/"/>
    <id>http://yoursite.com/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/01Getting Started/Basic Setup/</id>
    <published>2015-12-26T15:00:00.000Z</published>
    <updated>2015-12-15T06:25:19.563Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>翻译：<a href="https://github.com/Creolophus" target="_blank" rel="external">Creolophus</a></p>
<p>校正：<a href="https://github.com/Evilcome" target="_blank" rel="external">Evilcome</a> <a href="https://github.com/dabing1022" target="_blank" rel="external">ChildhoodAndy</a></p>
</blockquote>
<h1 id="基本设置">基本设置</h1><hr>
<p>本页包含内容：</p>
<ul>
<li><a href="#setting_up_your_swift_environment">建立你的 Swift 环境</a></li>
<li><a href="#understanding_the_swift_import_process">理解 Swift 导入过程</a></li>
</ul>
<blockquote>
<p>重要事项</p>
<p>这是一个正在研发的API或技术的概要文件，苹果公司提供这些信息主要是为了帮助你通过苹果产品使用这些技术或者编程接口而做好计划，该信息有可能会在未来发生改变，本文当中提到的软件应该以最终发布的操作系统测试和最终文档为准，未来有可能会提供新版本的文档信息。</p>
</blockquote>
<p>Swift 被设计用来无缝兼容 Cocoa 和 Objective-C 。在 Swift 中，你可以使用 Objective-C 的 API（包括系统框架和你自定义的代码），你也可以在 Objective-C中 使用 Swift 的 API。这种兼容性使 Swift 变成了一个简单、方便并且强大的工具集成到你的 Cocoa 应用开发工作流程中。</p>
<p>这篇指南包括了三个有关兼容性的重要方面方便你更好地利用来开发 Cocoa 应用：</p>
<ul>
<li><strong>互用性</strong> 使你将 Swift 和 Objective-C 相接合，允许在 Objective-C 中使用 Swift 的 Class 并且当你在写 Swift 代码时利用熟悉的 Cocoa Class、Pattern、Practice。</li>
<li><strong>混合和匹配</strong> 允许你创建结合了 Swift 和 Objective-C 文件的混合语言应用，他们能跟彼此进行通信。</li>
<li><strong>迁移</strong> 由于以上两点，从已经存在的 Objective-C 代码迁移到 Swift 是非常简单的，使得用最新的 Swift 特性代替你的 Objective-C 应用部分内容成为了可能。</li>
</ul>
<p>在你开始学习这些特性前，你需要对如何建立 Swift 环境来访问 Cocoa 系统框架有个大体了解。</p>
<p><a name="setting_up_your_swift_environment"></a></p>
<p>##建立你的 Swift 环境</p>
<p>为了开始体验在 Swift 中访问 Cocoa 框架，使用 Xcode 的一个模板来创建一个基于 Swift 应用。</p>
<p>###在 Xcode 中创建一个 Swift 项目</p>
<p>1.选择 File &gt; New &gt; Project &gt; (iOS or OS X) &gt; Application &gt; your <em>template of choice</em>。</p>
<p>2.点击 Language 弹出菜单并选择 Swift。</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/Art/newproject_2x.png" alt="image"></p>
<p>Swift 项目的结构几乎和 Objective-C 项目一模一样，只有一个重要的区别：Swift 没有头文件。在实现和接口之间没有显示的划分，所以一个特定类中的所有信息都存储在单独的<code>.swift</code>文件中。</p>
<p>现在开始，你可以开始体验在<code>app delegate</code>中写 Swift 代码，或者你可以通过选择 File &gt; New &gt; File &gt; (iOS or OS X) &gt; Other &gt; Swift来创建一个 Swift 类。</p>
<p><a name="understanding_the_swift_import_process"></a></p>
<p>##理解 Swift 导入过程</p>
<p>在你建立 Xcode 项目后，你可以在 Swift 里导入任意用 Objective-C 来工作的 Cocoa 平台框架。</p>
<p>任意 Objective-C 的框架（或 C 类库）将作为一个<em>module</em>，能直接导入到 Swift 中。这些包括了所有 Objective-C 系统框架-比如 Foundation、UIKit 和 SpriteKit，就像系统支持公共 C 类库。举个例子，想导入 Foundation，只要简单地添加 import 语句到你写的 Swift 文件的顶部。</p>
<blockquote>
<p>SWIFT</p>
<p><code>import Foundation</code></p>
</blockquote>
<p>这个 import 导入了所有 Foundation 的 API，包括<code>NSDate</code>，<code>NSURL</code>，<code>NSMutableData</code>，并且他们的所有方法、属性和类别都可以在 Swift 中直接使用。</p>
<p>导入过程是非常简洁的。Objective-C 框架在头文件中申明 API。在 Swift 中，那些头文件被编译成 Objective-C 的 module，接着被导入到 Swift 作为 Swift 的 API。导入决定了 Objective-C 的 Function，Class，Method 和 Type 如何在 Swift 中出现。对于 Function 和 Method，这个过程影响他们的参数和返回值。导入过程可以做下面这些事情：</p>
<ul>
<li>重映射确定的 Objective-C 类型到 Swift 中的同等类型，就像 id 到<code>AnyObject</code></li>
<li>重映射确定的 Objective-C 核心类型到 Swift 中的替代类型， 就像<code>NSString</code>到<code>String</code></li>
<li>重映射确定的 Objective-C 概念到 Swift 中相匹配的概念，如<code>pointers</code>到<code>optionals</code></li>
</ul>
<p>在互用性章节，你将会了解到更多关于这些映射如何在你的 Swift 代码进行取舍。<br>导入 Swift 的模型到 Objective-C 和从 Objective-C 导入 Swift 是非常相似的。Swift 申明它的 API，比如一个框架作为 Swift modules。同时这些 Swift modules 会生成 Objective-C 的头文件。这些头文件可以映射回 Objective-C 的 API 中。一些 Swift 的 API 不映射回 Objective-C 因为他们取舍了语言特性发现这些在 Objective-C 中不可用。关于在 Objective-C 中使用 Swift 的更多特性，请参看<a href="https://github.com/CocoaChina-editors/Welcome-to-Swift/blob/master/Using%20Swift%20with%20Cocoa%20and%20Objective-C/03Mix%20and%20Match/Swift%20and%20Objective-C%20in%20the%20Same%20Project.md" target="_blank" rel="external">在同一项目中使用 Swift 和 Objective-C</a>。</p>
<blockquote>
<p>注意</p>
<p>你不能直接把 C++ 代码导入 Swift。解决办法是为 C++ 代码创建一个 Objective-C 或者 C 的封装。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>翻译：<a href="https://github.com/Creolophus" target="_blank" rel="external">Creolophus</a></p>
<p>校正：<a href="https://github.c]]>
    </summary>
    
      <category term="Using Swift with Cocoa and Objective-C" scheme="http://yoursite.com/tags/Using-Swift-with-Cocoa-and-Objective-C/"/>
    
      <category term="swift-cn" scheme="http://yoursite.com/categories/swift-cn/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[02Interoperability-01与 Objective-C 的 API 交互]]></title>
    <link href="http://yoursite.com/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/01Interacting%20with%20Objective-C%20APIs/"/>
    <id>http://yoursite.com/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/01Interacting with Objective-C APIs/</id>
    <published>2015-12-26T14:00:10.000Z</published>
    <updated>2015-12-15T06:25:35.153Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>翻译：<a href="https://github.com/Creolophus" target="_blank" rel="external">Creolophus</a></p>
<p>校正：<a href="https://github.com/Evilcome" target="_blank" rel="external">Evilcome</a> <a href="https://github.com/dabing1022" target="_blank" rel="external">ChildhoodAndy</a></p>
</blockquote>
<p>#与 Objective-C 的 API 交互</p>
<hr>
<p>本页包含内容：</p>
<ul>
<li><a href="#initialization">初始化</a></li>
<li><a href="#failable_initialization">可失败初始化</a></li>
<li><a href="#accessing_properties">访问属性</a></li>
<li><a href="#working_with_methods">方法</a></li>
<li><a href="#id_compatibility">id 兼容性（id Compatibility）</a></li>
<li><a href="#Nullability_and_Optionals">空值和可选值</a></li>
<li><a href="#extensions">扩展（Extensions）</a></li>
<li><a href="#closures">闭包（Closures）</a></li>
<li><a href="#object_comparison">比较对象</a></li>
<li><a href="#swift_type_compatibility">Swift 类型兼容性</a></li>
<li><a href="#Requiring_Dynamic_Dispatch">动态分发</a></li>
<li><a href="#Lightweight_Generics">轻量级泛型</a></li>
<li><a href="#objective_c_selectors">Objective-C 选择器（Selectors）</a></li>
</ul>
<p><strong>互用性</strong>是让 Swift 和 Objective-C 相接合的一种特性，使你能够在一种语言编写的文件中使用另一种语言。当你准备开始把 Swift 融入到你的开发流程中时，你应该懂得如何利用互用性来重新定义并提高你写 Cocoa 应用的方案。</p>
<p>互用性很重要的一点就是允许你在写 Swift 代码时使用 Objective-C 的 API 接口。当你导入一个 Objective-C 框架后，你可以使用原生的 Swift 语法实例化它的 Class 并且与之交互。</p>
<p><a name="initialization"></a></p>
<p>##初始化</p>
<p>为了使用 Swift 实例化 Objective-C 的 Class，你应该使用 Swift 语法调用它的一个初始化器。当 Objective-C 的<code>init</code>方法变化到 Swift，他们用 Swift 初始化语法呈现。“init”前缀被截断当作一个关键字，用来表明该方法是初始化方法。那些以“initWith”开头的<code>init</code>方法，“With”也会被去除。从“init”或者“initWith”中分离出来的这部分方法名首字母变成小写，并且被当做是第一个参数的参数名。其余的每一部分方法名依次变为参数名。这些方法名都在圆括号中被调用。</p>
<p>举个例子，你在使用 Objective-C 时会这样做：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UITableView *myTableView = [[UITableView alloc] &#10;initWithFrame:CGRectZero style:UITableViewStyleGrouped];</span><br></pre></td></tr></table></figure>
<p>在 Swift 中，你应该这样做：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myTableView: <span class="type">UITableView</span> = <span class="type">UITableView</span>(frame: <span class="type">CGRectZero</span>, style: .<span class="type">Grouped</span>)</span><br></pre></td></tr></table></figure>
<p>你不需要调用<code>alloc</code>，Swift 能够正确的为你处理。注意，当使用 Swift 风格的初始化函数的时候，“init”不会出现。</p>
<p>你可以在初始化时显式的声明对象的类型，也可以忽略它，Swift 能够正确判断对象的类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myTextField = <span class="type">UITextField</span>(frame: <span class="type">CGRect</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">200.0</span>, <span class="number">40.0</span>))</span><br></pre></td></tr></table></figure>
<p>这里的<code>UITableView</code>和<code>UITextField</code>对象和你在 Objective-C 中使用的具有相同的功能。你可以用一样的方式使用他们，包括访问属性或者调用各自的类中的方法。</p>
<p>为了统一和简易，Objective-C 的工厂方法也在 Swift 中映射为方便的初始化方法。这种映射能够让他们使用同样简洁明了的初始化方法。例如，在 Objective-C 中你可能会像下面这样调用一个工厂方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIColor *color = [UIColor colorWithRed:0.5 green:0.0 blue:0.5 alpha:1.0];</span><br></pre></td></tr></table></figure>
<p>在 Swift 中，你应该这样做：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> color = <span class="type">UIColor</span>(red: <span class="number">0.5</span>, green: <span class="number">0.0</span>, blue: <span class="number">0.5</span>, alpha: <span class="number">1.0</span>)</span><br></pre></td></tr></table></figure>
<p><a name="failable_initialization"></a></p>
<p>##可失败初始化</p>
<p>在 Objective-C 中，构造器会直接返回他们初始化的对象。为了通知调用者初始化失败，Objective-C 构造器会返回<code>nil</code>。在 Swift 中，这种模式被内置到语言特性中，被称为<em>可失败初始化</em>。在 iOS 和 OSX 系统框架中许多 Objective-C 构造器会被检查是否会初始化失败。如果初始化不会失败，这些 Objective-C 构造器便会以<code>init(...)</code>被导入，如果初始化可能会失败，则会以<code>init?(...)</code>被导入。在我们自己的 Objective-C 类以及未被检查的框架类中，构造器会以<code>init!(...)</code>被导入。例如，当图片文件在指定路径中不存在时，<code>UIImage(contentsOfFile:)</code>构造器初始化<code>UIImage</code>对象便会失败。如果初始化成功，我们可以用可选值绑定来对可失败初始化的结果进行解包。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> image = <span class="type">UIImage</span>(contentsOfFile: <span class="string">"MyImage.png"</span>) &#123;</span><br><span class="line">    <span class="comment">// loaded the image successfully</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// could not load the image</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="accessing_properties"></a></p>
<p>##访问属性</p>
<p>在 Swift 中访问和设置 Objective-C 对象的属性时，使用点语法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myTextField.textColor = <span class="type">UIColor</span>.darkGrayColor()</span><br><span class="line">myTextField.text = <span class="string">"Hello world"</span></span><br></pre></td></tr></table></figure>
<p>当 get 或 set 属性时，直接使用属性名称，不需要附加圆括号。注意，<code>darkGrayColor</code>后面附加了一对圆括号，这是因为<code>darkGrayColor</code>是<code>UIColor</code>的一个类方法，不是一个属性。</p>
<p>在 Objective-C 中，一个有返回值的无参数方法可以被作为一个隐式的访问函数，并且可以与访问器使用同样的方法调用。但在 Swift 中不再能够这样做了，只有在 Objective-C 中 使用<code>@property</code>关键字声明的属性才会被作为属性引入。方法被导入和调用见<a href="#working_with_methods">方法</a>描述。</p>
<p><a name="working_with_methods"></a></p>
<p>##方法</p>
<p>在 Swift 中调用 Objective-C 方法时，使用点语法。</p>
<p>当 Objective-C 方法转换到 Swift 时，Objective-C 的<code>selector</code>的第一部分将会成为方法名并出现在圆括号的前面，而第一个参数将直接在括号中出现，并且没有参数名，而剩下的参数名与参数则一一对应的填入圆括号中。选择器的所有部分在调用时都是必需的。</p>
<p>举个例子，你在使用 Objective-C 时会这样做：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[myTableView insertSubview:mySubview atIndex:2];</span><br></pre></td></tr></table></figure>
<p>在 Swift 中，你应该这样做：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myTableView.insertSubview(mySubview, atIndex: <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>如果你调用一个无参方法，仍必须在方法名后面加上一对圆括号</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myTableView.layoutIfNeeded()</span><br></pre></td></tr></table></figure>
<p><a name="id_compatibility"></a></p>
<p>##id 兼容性（id Compatibility）</p>
<p>Swift 包含一个叫做<code>AnyObject</code>的协议类型，表示任意类型的对象，就像 Objective-C 中的<code>id</code>一样。<code>AnyObject</code>协议允许你编写类型安全的 Swift 代码同时维持无类型对象的灵活性。因为<code>AnyObject</code>协议保证了这种安全，Swift 将<code>id</code>对象导入为<code>AnyObject</code>。</p>
<p>举个例子，跟<code>id</code>一样，你可以为<code>AnyObject</code>类型的对象分配任何其它类型的对象，你也同样可以为它重新分配其它类型的对象。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject: <span class="type">AnyObject</span> = <span class="type">UITableViewCell</span>()</span><br><span class="line">myObject = <span class="type">NSDate</span>()</span><br></pre></td></tr></table></figure>
<p>你也可以在调用 Objective-C 方法或者访问属性时不将它转换为具体类的类型。这包括了 Objective-C 中标记为<code>@objc</code>的方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> futureDate = myObject.dateByAddingTimeInterval(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">let</span> timeSinceNow = myObject.timeIntervalSinceNow</span><br></pre></td></tr></table></figure>
<p>然而，由于直到运行时才知道<code>AnyObject</code>的对象类型，所以有可能在不经意间写出不安全代码。另外，与 Objective-C 不同的是，如果你调的用方法或者访问的属性<code>AnyObject</code>对象没有声明，将会报运行时错误。比如下面的代码在运行时将会报出一个<code>unrecognized selector error</code>错误：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myObject.characterAtIndex(<span class="number">5</span>)</span><br><span class="line"><span class="comment">// crash, myObject does't respond to that method</span></span><br></pre></td></tr></table></figure>
<p>但是，你可以通过 Swift 的可选值特性来排除这个 Objective-C 中常见的错误，当你用<code>AnyObject</code>对象调用一个 Objective-C 方法时，这次调用将会变成一次隐式展开可选值的行为。你可以通过可选值特性来决定<code>AnyObject</code>类型的对象是否调用该方法，同样的，你可以把这种特性应用在属性上。</p>
<blockquote>
<p>注</p>
<p>通过<code>AnyObject</code>访问的属性永远返回一个可选值。</p>
</blockquote>
<p>举个例子，在下面的代码中，第一和第二行代码将不会被执行因为<code>length</code>属性和<code>characterAtIndex:</code>方法不存在于 NSDate 对象中。<code>myLength</code>常量会被推测成可选的<code>Int</code>类型并且被赋值为<code>nil</code>。同样你可以使用<code>if-let</code>声明来有条件的展开这个方法的返回值，从而判断对象是否能执行这个方法。就像第三行做的一样。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myLength = myObject.length?</span><br><span class="line"><span class="keyword">let</span> myChar = myObject.characterAtIndex?(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> fifthCharacter = myObject.characterAtIndex(<span class="number">5</span>) &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"Found <span class="subst">\(fifthCharacter)</span> at index 5"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 Swift 中的强制类型转换，从<code>AnyObject</code>类型的对象转换成明确的类型并不会保证成功，所以它会返回一个可选的值。而你需通过检查该值的类型来确认转换是否成功。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="keyword">let</span> userDefaults = <span class="type">NSUserDefaults</span>.standardUserDefaults()</span><br><span class="line"><span class="keyword">let</span> lastRefreshDate: <span class="type">AnyObject</span>? = userDefaults.objectForKey(<span class="string">"LastRefreshDate"</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> date = lastRefreshDate <span class="keyword">as</span>? <span class="type">NSDate</span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"<span class="subst">\(date.timeIntervalSinceReferenceDate)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，如果你能确定这个对象的类型（并且确定不是<code>nil</code>），你可以添加<code>as</code>操作符强制调用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myDate = lastRefreshDate <span class="keyword">as</span> <span class="type">NSDate</span></span><br><span class="line"><span class="keyword">let</span> timeInterval = myDate.timeIntervalSinceReferenceDate</span><br></pre></td></tr></table></figure>
<p><a name="Nullability_and_Optionals"></a></p>
<h2 id="空值和可选值">空值和可选值</h2><p>在 Objective-C 中，对象的引用可以是值为<code>NULL</code>的原始指针（在 Objective-C 中的简称为<code>nil</code>）。而在Swift中，所有的值–包括结构体与对象的引用–都被保证为非空。作为替代，你将这个可以为空的值包装为optional type。当你需要宣告值为空时，你需要使用<code>nil</code>。你可以在<a href="https://github.com/CocoaChina-editors/Welcome-to-Swift/blob/master/The%20Swift%20Programming%20Language/02Language%20Guide/01The%20Basics.md#optionals" target="_blank" rel="external">Optionals</a>中了解更多。</p>
<p>Objective-C 能够使用空值标记来设定一个参数类型，属性类型或者返回值类型是否可以为 NULL 或者 为 nil 值。单独的类型声明可以使用<code>__nullable</code>和<code>__nonnull</code>标注，空值的范围性的声明可以使用<code>NS_ASSUME_NONNULL_BEGIN</code>和<code>NS_ASSUME_NONNULL_END</code>宏。如果一个类型没有任何的空值标注信息，Swift 就不能分辨出可选值和非可选值类型，并且将作为隐式的解包可选值导入。</p>
<ul>
<li>以<code>__nonnull</code>或者范围宏标注声明的空值类型，被作为非空可选值<code>non-optional</code>导入到 Swift。</li>
<li>以<code>__nullable</code>标注声明的空值类型，被作为可选值导入到 Swift。</li>
<li>没有以空值标注声明的类型被作为隐式的解包可选值导入到 Swift。</li>
</ul>
<p>例如，考虑如下的 Objective-C 声明：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nullable) id  nullableProperty;&#10;@property (nonnull) id nonNullProperty;&#10;@property id unannotatedProperty;&#10; &#10;NS_ASSUME_NONNULL_BEGIN&#10;- (id)returnsNonNullValue;&#10;- (void)takesNonNullParameter:(id)value;&#10;NS_ASSUME_NONNULL_END&#10; &#10;- (nullable id)returnsNullableValue;&#10;- (void)takesNullableParameter:(nullable id)value;&#10; &#10;- (id)returnsUnannotatedValue;&#10;- (void)takesUnannotatedParameter:(id)value;</span><br></pre></td></tr></table></figure>
<p>下面是他们如何被导入 Swift 中的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nullableProperty: <span class="type">AnyObject</span>?</span><br><span class="line"><span class="keyword">var</span> nonNullProperty: <span class="type">AnyObject</span></span><br><span class="line"><span class="keyword">var</span> unannotatedProperty: <span class="type">AnyObject</span>!</span><br><span class="line"> </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">returnsNonNullValue</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesNonNullParameter</span><span class="params">(value: AnyObject)</span></span></span><br><span class="line"> </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">returnsNullableValue</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span>?</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesNullableParameter</span><span class="params">(value: AnyObject?)</span></span></span><br><span class="line"> </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">returnsUnannotatedValue</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span>!</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesUnannotatedParameter</span><span class="params">(value: AnyObject!)</span></span></span><br></pre></td></tr></table></figure>
<p>大多数 Objective-C 的系统框架，包括 Foundation，都已经提供了可空的注解，允许你使用惯用和类型安全的方式与值打交道。</p>
<p><a name="extensions"></a></p>
<p>##扩展（Extensions）</p>
<p>Swift 的扩展和 Objective-C 的类别（Category）相似。扩展为原有的类，结构和枚举丰富了功能，包括在 Objective-C 中定义过的。你可以为系统的框架或者你自己的类型增加扩展，只需要导入合适的模块并且保证你在 Objective-C 中使用的类、结构或枚举拥有相同的名字。</p>
<p>举个例子，你可以扩展<code>UIBezierPath</code>类来为它增加一个等边三角形，这个方法只需提供三角形的边长与起点。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIBezierPath</span> </span>&#123;</span><br><span class="line">    convenience <span class="keyword">init</span>(triangleSideLength: <span class="type">Float</span>, origin: <span class="type">CGPoint</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">let</span> squareRoot = <span class="type">Float</span>(sqrt(<span class="number">3</span>))</span><br><span class="line">        <span class="keyword">let</span> altitude = (squareRoot * triangleSideLength) / <span class="number">2</span></span><br><span class="line">        moveToPoint(origin)</span><br><span class="line">        addLineToPoint(<span class="type">CGPoint</span>(triangleSideLength, origin.x))</span><br><span class="line">        addLineToPoint(<span class="type">CGPoint</span>(triangleSideLength / <span class="number">2</span>, altitude))</span><br><span class="line">        closePath()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以使用扩展来增加属性（包括类的属性与静态属性）。然而，这些属性必须是通过计算才能获取的，扩展不会为类，结构体，枚举添加存储属性。下面这个例子为<code>CGRect</code>类增加了一个叫<code>area</code>的属性。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CGRect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">CGFloat</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> width * height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> rect = <span class="type">CGRect</span>(x: <span class="number">0.0</span>, y: <span class="number">0.0</span>, width: <span class="number">10.0</span>, height: <span class="number">50.0</span>)</span><br><span class="line"><span class="keyword">let</span> area = rect.area</span><br><span class="line"><span class="comment">// area: CGFloat = 500.0</span></span><br></pre></td></tr></table></figure>
<p>你同样可以使用扩展来为类添加协议而无需增加它的子类。如果这个协议是在 Swift 中被定义的，你可以添加 comformance 到它的结构或枚举中无论它们在 Objective-C 或在 Swift 中被定义。</p>
<p>你不能使用扩展来覆盖 Objective-C 类型中存在的方法与属性。</p>
<p><a name="closures"></a></p>
<p>##闭包（Closures）</p>
<p>Objective-C 中的<code>blocks</code>会被自动导入为 Swift 中的闭包。例如，下面是一个 Objective-C 中的 block 变量：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void (^completionBlock)(NSData *, NSError *) = ^(NSData *data, NSError *error) &#123;/* ... */&#125;</span><br></pre></td></tr></table></figure>
<p>而它在 Swift 中的形式为</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> completionBlock: (<span class="type">NSData</span>, <span class="type">NSError</span>) -&gt; <span class="type">Void</span> = &#123;data, error <span class="keyword">in</span> <span class="comment">/* ... */</span>&#125;</span><br></pre></td></tr></table></figure>
<p>Swift 的闭包与 Objective-C 中的 blocks 能够和睦相处，所以你可以把一个 Swift 闭包传递给一个把 block 作为参数的 Objective-C 函数。Swift 闭包与函数具有互通的类型，所以你甚至可以传递 Swift 函数的名字。</p>
<p>闭包与 blocks 语义上相通但是在一个地方不同：变量是可以直接改变的，而不是像 block 那样会拷贝变量。换句话说，Swift 中变量的默认行为与 Objective-C 中 __block 变量一致。</p>
<p><a name="object_comparison"></a></p>
<p>##比较对象</p>
<p>当比较两个 Swift 中的对象时，可以使用两种方式。第一种，使用（==），判断两个对象内容是否相同。第二种，使用(===)，判断常量或者变量是否为同一个对象的实例。</p>
<p>Swift 与 Objective-C 一般使用 == 与 === 操作符来做比较。Swift 的 == 操作符为源自 NSObject 的对象提供了默认的实现。在实现 == 操作符时，Swift 调用 NSObject 定义的 isEqual: 方法。</p>
<p>NSObject 类仅仅做了身份的比较，所以你需要在你自己的类中重新实现 isEqual: 方法。因为你可以直接传递 Swift 对象给 Objective-C 的 API，你也应该为这些对象实现自定义的 isEqual: 方法，如果你希望比较两个对象的内容是否相同而不是仅仅比较他们是不是由相同的对象派生。</p>
<p>作为实现比较函数的一部分，确保根据<a href="//https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/DevPedia-CocoaCore/ObjectComparison.html#//apple_ref/doc/uid/TP40008195-CH37">Object comparison</a>实现对象的<code>hash</code>属性。更进一步的说，如果你希望你的类能够作为字典中的键，也需要遵从<code>Hashable</code>协议以及实现<code>hashValues</code>属性。</p>
<p><a name="swift_type_compatibility"></a></p>
<h2 id="Swift_类型兼容性">Swift 类型兼容性</h2><p>当你在 Swift 中创建了一个继承自 Objective-C 类的子类时，该类以及该类的成员-属性，方法，下标和构造器，便会在 Objective-C 中自动可用。在某些情况下，你需要更细粒度的控制如何将 Swift API 暴漏给 Objective-C。如果你的 Swift 类没有继承自 Objective-C 的类，又或者你想更改暴漏给 Objective-C 代码的接口符号名称，你便可以使用<code>@objc</code>属性。如果你正在使用如键值观察的 API 来动态替换方法的实现，也可以通过使用<code>dynamic</code>修饰符来获得对 Objective-C 运行时被自动派发的成员的访问。</p>
<h3 id="在_Objective-C_中暴漏_Swift_接口">在 Objective-C 中暴漏 Swift 接口</h3><p>当你定义一个继承自<code>NSObject</code>类或者其他 Objective-C 类的 Swift 子类时，该类便会自动兼容 Objective-C。Swift 编译器已经为你做好了这部分所需要的工作。</p>
<p>所有的步骤都由 Swift 编译器自动完成，如果你从未在 Objective-C 代码中导入 Swift 类，你也不需要担心类型适配问题。另外一种情况，如果你的 Swift 类并不继承于 Objective-C 类而你希望能在 Objective-C 的代码中使用它，你可以使用下面描述的<code>@objc</code>属性。</p>
<p><code>@objc</code>可以让你的 Swift API 在 Objective-C 中使用。换句话说，你可以通过在任何 Swift 方法、类、属性前添加<code>@objc</code>，来使得他们可以在 Objective-C 代码中使用。如果你的类继承自 Objective-C，编译器会自动帮助你完成这一步。编译器还会在所有的变量、方法、属性前加 @objc，如果这个类自己前面加上了<code>@objc</code>关键字。当你使用<code>@IBOutlet</code>，<code>@IBAction</code>，或者是<code>@NSManaged</code>属性时，<code>@objc</code>也会自动加在前面。这个关键字也可以用在 Objetive-C 中的 target-action 设计模式中，例如，<code>NSTimer</code>或者<code>UIButton</code>。</p>
<p>当你在 Objective-C 中使用 Swift API，编译器通常会对语句做直接的翻译。例如，Swift API <code>func playSong(name: String)</code>会被解释为<code>- (void)playSong:(NSString *)name</code>。然而，有一个例外：当在 Objective-C 中使用 Swift 的初始化函数，编译器会在方法前添加“initWith”并且将原初始化函数的第一个参数首字母大写。例如，这个 Swift 初始化函数<code>init (songName: String, artist: String</code>将被翻译为<code>- (instancetype)initWithSongName:(NSString *)songName artist:(NSString *)artist</code>。</p>
<p>Swift 同时也提供了一个<code>@objc</code>关键字的变体，通过它你可以自定义在 Objective-C 中转换的函数名。例如，如果你的 Swift 类的名字包含 Objective-C 中不支持的字符，你就可以为 Objective-C 提供一个可供替代的名字。如果你要为 Swift 函数提供一个 Objective-C 名字，记得为带参数的函数添加（:）</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="preprocessor">@objc</span>(<span class="type">Squirrel</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> Белка </span>&#123;</span><br><span class="line">    <span class="preprocessor">@objc</span>(initWithName:)</span><br><span class="line">    <span class="keyword">init</span> (имя: <span class="type">String</span>) &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">    <span class="preprocessor">@objc</span>(hideNuts:inTree:)</span><br><span class="line">    <span class="func"><span class="keyword">func</span> прячьОрехи<span class="params">(Int, вДереве: Дерево)</span></span> &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你在 Swift 类中使用<code>@objc(&lt;#name#&gt;)</code>关键字，这个类可以不需要命名空间即可在 Objective-C 中使用。这个关键字在你迁徙 Objecive-C 代码到 Swift 时同样也非常有用。由于归档过的对象存贮了类的名字，你应该使用<code>@objc(&lt;#name#&gt;)</code>来声明与旧的归档过的类相同的名字，这样旧的类才能被新的 Swift 类解档。</p>
<p><a name="Requiring_Dynamic_Dispatch"></a></p>
<h2 id="请求动态分配">请求动态分配</h2><p>@objc 属性将你的 Swift API 暴露给了 Objective-C 运行时，但是它并不能保证一个属性，方法，下标，或构造器的动态调度。通过绕过 Objective-C 运行时，Swift 编译器可能仍然 devirtualize 或内联成员访问来优化代码的性能。当你用动态修改符标记一个成员声明时，对该成员的访问始终是动态调度。由于标有动态修改声明使用 Objective-C 运行时来调度，它们被隐式的用 @objc 属性标记。</p>
<p>动态分配的需求很少是必要的。但是，当你要在运行时替换一个 API 的实现时你必须使用动态修改。例如，你可以使用 Objective-C 运行时方法<code>method_exchangeImplementations</code>函数来替换 app 正在运行时某个方法的实现。如果 Swift 编译器内联了方法的实现或者 devirtualized 对它的访问，新的实现将不会被使用。</p>
<p><a name="Lightweight_Generics"></a></p>
<h2 id="轻量级泛型">轻量级泛型</h2><p>使用轻量级泛型参数的 Objective-C 声明类型，如<code>NSArray</code>，<code>NSSet</code>以及<code>NSDictionary</code>，在被导入到 Swift 时会附带上他们内容保存的类型。</p>
<p>例如，考虑下面的 Objective-C 属性声明：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property NSArray&#60;NSDate *&#62;* dates;&#10;@property NSSet&#60;NSString *&#62;* words;&#10;@property NSDictionary&#60;KeyType: NSURL *, NSData *&#62;* cachedData;</span><br></pre></td></tr></table></figure>
<p>下面是 Swift 导入后：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dates: [<span class="type">NSDate</span>]</span><br><span class="line"><span class="keyword">var</span> words: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;</span><br><span class="line"><span class="keyword">var</span> cachedData: [<span class="type">NSURL</span>: <span class="type">NSData</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>除了 Foundation 中的集合类， Objective-C 的轻量级泛型会被 Swift 忽略掉。任何其他使用轻量级泛型的类型在导入到 Swift 中时会被视为无参数化。</p>
</blockquote>
<p><a name="objective_c_selectors"></a></p>
<h2 id="Objective-C_选择器">Objective-C 选择器</h2><p>Objective-C 选择器是一种指向 Objective-C 方法名的类型。在 Swift 里，Objective-C 的选择器被<code>Selector</code>结构体替代。你可以通过字符串创建一个选择器，比如<code>let mySelector: Selector = &quot;tappedButton:&quot;</code>。因为字符串字面量能够自动被转换为选择器，所以你可以把字符串字面量直接传递给任何能够接受选择器的方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> myButton = <span class="type">UIButton</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">100</span>, height: <span class="number">50</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>?(nibName nibNameOrNil: <span class="type">String</span>?, bundle nibBundleOrNil: <span class="type">NSBundle</span>?) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: nibNameOrNil, bundle: nibBundleOrNil)</span><br><span class="line">        myButton.addTarget(<span class="keyword">self</span>, action: <span class="string">"tappedButton:"</span>, forControlEvents: .<span class="type">TouchUpInside</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">tappedButton</span><span class="params">(sender: UIButton!)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"tapped button"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    required <span class="keyword">init</span>?(coder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: coder)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p><code>performSelector:</code>方法和相关的调用选择器的方法没有导入到 Swift 中因为它们本质上是不安全的。</p>
</blockquote>
<p>如果你的 Swift 类继承自 Objective-C 的类，你的所有方法都可以用作 Objective-C 的选择器。反之，如果你的 Swift 类不是继承自 Objective-C，你需要在想要使用的选择器前面加上<code>@objc</code>属性前缀，详情请看<a href="#swift_type_compatibility">Swift 类型兼容性</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>翻译：<a href="https://github.com/Creolophus" target="_blank" rel="external">Creolophus</a></p>
<p>校正：<a href="https://github.c]]>
    </summary>
    
      <category term="Using Swift with Cocoa and Objective-C" scheme="http://yoursite.com/tags/Using-Swift-with-Cocoa-and-Objective-C/"/>
    
      <category term="swift-cn" scheme="http://yoursite.com/categories/swift-cn/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[02Interoperability-02特性编写Swift类]]></title>
    <link href="http://yoursite.com/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/02Writing%20Swift%20Classes%20with%20Objective-C%20Behavior/"/>
    <id>http://yoursite.com/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/02Writing Swift Classes with Objective-C Behavior/</id>
    <published>2015-12-26T14:00:09.000Z</published>
    <updated>2015-12-15T06:25:43.422Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>翻译：<a href="https://github.com/halinuya" target="_blank" rel="external">halinuya</a></p>
<p>校对：<a href="https://github.com/song-buaa" target="_blank" rel="external">song-buaa</a> <a href="https://github.com/MonicaZhou" target="_blank" rel="external">MonicaZhou</a> <a href="https://github.com/dabing1022" target="_blank" rel="external">ChildhoodAndy</a></p>
</blockquote>
<h1 id="使用Objective-C特性编写Swift类">使用Objective-C特性编写Swift类</h1><hr>
<p>本节包括内容：</p>
<ul>
<li><a href="#inheriting_from_objective-c_classes">继承Objective-C的类（Inheriting from Objective-C Classes）</a></li>
<li><a href="#adopting_protocols">采用协议（Adopting Protocols）</a></li>
<li><a href="#writing_initializers_and_deinitializers">编写构造器和析构器（Writing Initializers and Deinitializers）</a></li>
<li><a href="#integrating_with_interface_builder">集成Interface Builder（Integrating with Interface Builder）</a></li>
<li><a href="#specifying_property_attributes">指明属性特性（Specifying Property Attributes）</a></li>
<li><a href="#implementing_core_data_managed_object_subclasses">实现Core Data Managed Object子类（Implementing Core Data Managed Object Subclasses）</a></li>
<li><a href="#using_swift_class_names_with_objective_c_apis">使用带Objective-C API的Swift类名</a></li>
</ul>
<p>互用性（互操作性）使开发者可以定义融合了 Objective-C 语言特性的Swift类。编写 Swift 类时，不仅可以继承 Objective-C 语言编写的父类，采用 Objective-C 的协议，还可以利用 Objective-C 的一些其它功能。这意味着，开发者可以基于 Objective-C 中已有的熟悉、可靠的类、方法和框架来创建 Swift 类，并结合 Swift 提供的现代化和更有效的语言特点对其进行优化。</p>
<p><a name="inheriting_from_objective-c_classes"></a></p>
<h2 id="继承Objective-C的类">继承Objective-C的类</h2><p>在 Swift 中，开发者可以定义一个子类，该子类继承自使用 Objective-C 编写的类。创建该子类的方法是，在 Swift 的类名后面加上一个冒号（:），冒号后面跟上 Objective-C 的类名。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySwiftViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 定义类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开发者能够从 Objective-C 的父类中继承所有的功能。如果开发者要覆盖父类中的方法，不要忘记使用<code>override</code>关键字。</p>
<h3 id="NSCoding协议">NSCoding协议</h3><p><code>NSCoding</code>协议要求符合的类型实现所需的构造器<code>init(coder:)</code>。直接采用<code>NSCoding</code>协议的类必须实现这个方法。采用<code>NSCoding</code>协议的类的子类，这些类有一个或者多个自定义的构造器或者不带初始化值的属性，也必须实现这个方法。Xcode提供了以下占位实现来提醒：</p>
<pre><code>required init(coder aDecoder: NSCoder) {
<span class="code">    fatalError("init(coder:) has not been implemented")</span>
}
<span class="xml"><span class="comment"><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">对那些从 Storyboards 里加载的对象，或者用 NSUserDefaults 或 NSKeyedArchiver 类归档到磁盘的对象，你必须提供一个完整的初始化程序的实现。然而，当类型以此种方式无法实例化的时候，你可能并不需要实现构造器。</span><br><span class="line"></span><br><span class="line">&lt;a name=<span class="string">"adopting_protocols"</span>&gt;&lt;/a&gt;</span><br><span class="line"><span class="comment">## 采用协议</span></span><br><span class="line"></span><br><span class="line">在 Swift 中，开发者可以采用 Objective-C 中定义好的协议。和 Swift 协议一样，所有 Objective-C 协议都写在一个用逗号隔开的列表中，跟在所在类的父类名后面（如果它有父类的话）。</span><br><span class="line"></span><br><span class="line">`<span class="javascript"></span>``<span class="javascript">swift</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySwiftViewController</span>: <span class="title">UIViewController</span>, <span class="title">UITableViewDelegate</span>, <span class="title">UITableViewDataSource</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 定义类</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></span></span>

Objective-C 协议与 Swift 协议使用上是一致的。如果开发者想在 Swift 代码中引用 <span class="code">`UITableViewDelegate`</span>协议，可以直接使用<span class="code">`UITableViewDelegate`</span>（跟在 Objective-C 中引用<span class="code">`id&lt;UITableViewDelegate&gt;`</span>是等价的）。

因为在 Swift 中，类和协议的命名空间是统一的，Objective-C 里的 NSObject 协议被重新映射到 Swift 里的 NSObjectProtocol。

<span class="xml"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">name</span>=<span class="value">"writing_initializers_and_deinitializers"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="title">a</span>&gt;</span></span>
<span class="header">## 编写构造器和析构器</span>

Swift 的编译器确保在初始化时，构造器不允许类里有任何未初始化的属性，这样做能够增加代码的安全性和可预测性。另外，与 Objective-C 语言不同，Swift 不提供单独的内存分配方法供开发者调用。当你使用原生的 Swift 初始化方法时（即使是和 Objective-C 类协作），Swift 会将 Objective-C 的初始化方法转换为 Swift 的初始化方法。关于如何实现开发者自定义构造器的更多信息，请查看[<span class="link_label">构造器</span>](<span class="link_url">https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18</span>)。

当开发者希望在类被释放前，执行额外的清理工作时，需要执行一个析构过程来代替<span class="code">`dealloc`</span>方法。在实例被释放前，Swift 会自动调用析构器来执行析构过程。Swift 调用完子类的析构器后，会自动调用父类的析构器。当开发者使用 Objective-C 类或者是继承自 Objective-C 类的 Swift 类时，Swift 也会自动为开发者调用这个类的父类里的<span class="code">`dealloc`</span>方法。关于如何实现开发者自定义析构器的更多信息，请查看[析构器]https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift<span class="emphasis">_Programming_</span>Language/Deinitialization.html#//apple_ref/doc/uid/TP40014097-CH19)。

<span class="xml"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">name</span>=<span class="value">"integrating_with_interface_builder"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="title">a</span>&gt;</span></span>
<span class="header">## 集成Interface Builder</span>

Swift 编译器包含一些属性，使得开发者的 Swift 类集成了 Interface Builder 里的一些特色功能。和 Objective-C 里一样，你能在 Swift 里面使用 outlets，actions 和实时渲染（live rendering）。

<span class="header">### 使用Outlets和Action</span>

使用 Outlets 和 Action 可以连接源代码和 Interface Builder 的 UI 对象。在Swift里面使用 Outlets 和 Action，需要在属性和方法声明前插入<span class="code">`@IBOutlet`</span>或者<span class="code">`@IBAction`</span>关键字。声明一个 Outlet 集合同样是用<span class="code">`@IBOutlet`</span>属性，即为类型指定一个数组。

当开发者在 Swift 里面声明了一个 Outlet 时，Swift 编译器会自动将该类型转换为弱（weak）、隐式（implicitly）、未包装（unwrapped）的 optional（Objective-C 里面对应指针类型）数据类型，并为它分配一个初始化的空值<span class="code">`nil`</span>。实际上，编译器使用<span class="code">`@IBOutlet weak var name: Type! = nil`</span>来代替 <span class="code">`@IBOutlet var name: Type`</span>。编译器将该类型转换成了弱（weak）、隐式（implicitly）、未包装（unwrapped）的 optional 类型，因此开发者就不需要在构造器中为该类型分配一个初始值了。当开发者从故事板（storyboard）或者<span class="code">`xib`</span>文件里面初始化对象 class 后，定义好的 Outlet 和这些对象连接在一起了，所以，这些 Outlet 是隐式的，未包装的。由于创建的 outlets 一般都是弱关系，因此默认 outlets 是弱类型。

例如，下面的 Swift 代码声明了一个拥有 Outlet、Outlet 集合和 Action 的类：

<span class="xml"><span class="comment"><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="preprocessor">@IBOutlet</span> <span class="keyword">var</span> button: <span class="type">UIButton</span></span><br><span class="line"></span><br><span class="line">	<span class="preprocessor">@IBOutlet</span> <span class="keyword">var</span> textFields: <span class="type">UITextField</span>[]</span><br><span class="line"></span><br><span class="line">	<span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">buttonTapped</span><span class="params">(AnyObject)</span></span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"button tapped!"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></span></span>

在<span class="code">`buttonTapped`</span>方法中，消息发送者的信息没有被使用，因此可以省略该方法的参数名。

<span class="header">### 实时渲染（live rendering）</span>
开发者可以在 Interface Builder 中用<span class="code">`@IBDesignable`</span>和<span class="code">`@IBInspectable`</span>来创建生动、可交互的自定义视图（view）。开发者继承<span class="code">`UIView`</span>或者<span class="code">`NSView`</span>来自定义一个视图（view）时，可以在类声明前添加<span class="code">`@IBDesignable`</span>属性。当你在 Interface Builder 里添加了自定义的视图后（在监视器面板的自定义视图类中进行设置），Interface Builder 将在画布上渲染你自定义的视图。


&gt;注意：只能针对框架里对象进行实时渲染

你也可以将<span class="code">`@IBInspectable`</span>属性添加到和用户定义的运行时属性兼容的类型属性里。这样，当开发者将自定义的视图添加到 Interface Builder 里后，就可以在监视器面板中编辑这些属性。

<span class="xml"><span class="comment"><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">@IBDesignable</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCustomView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">	<span class="preprocessor">@IBInspectable</span> <span class="keyword">var</span> textColor: <span class="type">UIColor</span></span><br><span class="line">	<span class="preprocessor">@IBInspectable</span> <span class="keyword">var</span> iconHeight: <span class="type">CGFloat</span></span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></span></span>

<span class="xml"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">name</span>=<span class="value">"specifying_property_attributes"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="title">a</span>&gt;</span></span>
<span class="header">## 指明属性特性</span>

在 Objective-C 中，属性通常都有一组特性（Attributes）说明来指明该属性的一些附加信息。在 Swift 中，开发者可以通过不同的方法来指明属性的这些特性。

<span class="header">### 强类型和弱类型</span>

Swift 里属性默认都是强类型的。使用<span class="code">`weak`</span>关键字修饰一个属性，能指明其对象存储时是一个弱引用。该关键字仅能修饰 optional 对象类型。更多的信息，请查阅[<span class="link_label">特性</span>](<span class="link_url">https://github.com/CocoaChina-editors/Welcome-to-Swift/blob/master/The%20Swift%20Programming%20Language/02Language%20Guide/09Classes%20and%20Structures.md</span>)。

<span class="header">### 读／写和只读</span>

在 Swift 中，没有<span class="code">`readwrite`</span>和<span class="code">`readonly`</span>特性。当声明一个存储型属性时，使用<span class="code">`let`</span>修饰其为只读；使用<span class="code">`var`</span>修饰其为可读／写。当声明一个计算型属性时，为其提供一个 getter 方法，使其成为只读的；提供 getter 方法和 setter 方法，使其成为可读／写的。更多信息，请查阅[<span class="link_label">属性</span>](<span class="link_url">https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13</span>)。

<span class="header">### 拷贝</span>

在 Swift 中，Objective-C 的<span class="code">`copy`</span>特性被转换为<span class="code">`@NSCopying`</span>属性。这一类的属性必须遵守 <span class="code">`NSCopying`</span>协议。更多信息，请查阅[<span class="link_label">特性</span>](<span class="link_url">https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13</span>)。

<span class="xml"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">name</span>=<span class="value">"implementing_core_data_managed_object_subclasses"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="title">a</span>&gt;</span></span>
<span class="header">## 实现Core Data Managed Object子类</span>

Core Data 提供了基本存储和实现<span class="code">`NSManagedObject`</span>子类的一组属性。在与Core Data 模型中管理对象子类相关的特性或者关系的每个属性定义之前，将<span class="code">`@NSmanaged`</span>特性加入。与 Objective-C 里面的 <span class="code">`@dynamic`</span>特性类似，<span class="code">`@NSManaged`</span>特性告知 Swift 编译器，这个属性的存储和实现将在运行时完成。但是，与<span class="code">`@dynamic`</span>不同的是，<span class="code">`@NSManaged`</span>特性仅在 Core Data 支持中可用。

Swift 类被命名空间化---他们局限于被编译的模块中（最典型的是Target）。
为了使用带 Core Data 模型的<span class="code">`NSManagedObject`</span>类的 Swift 子类，在模型实体监视器的类区域里，用模块名字作为类名的前缀。

![](https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/Art/coredatanamespace_2x.png)

<span class="xml"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">name</span>=<span class="value">"using_swift_class_names_with_objective_c_apis"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="title">a</span>&gt;</span></span>
<span class="header">## 使用带Objective-C API的Swift类名</span>

Swift 类的命名基于他们被编译的模块，即使是使用来自 Objective-C 的代码。和 Objective-C 不同的是，所有的类都是全局命名空间的一部分，必须没有相同的名字，Swift 类可以基于他们存在的模块来消除歧义。比如，被称为 MyFramework 框架中的被叫做DataManager 的 Swift 类的全限定名就是 MyFramework.DataManager。一个 Swift 应用目标就是模块本身，所以，在一个叫 MyGreatApp 的应用里，叫 Observer 的 Swift 类的全限定名是 MyGreatApp.Observer。

为了保存在 Objective-C 代码里使用的 Swift 类，Swift类用他们的全限定名暴漏给 Objective-C 运行时。因此，当你使用那些对 Swift 类的字符串代表起作用的 API，必须包含类的全限定名。比如，当你创建一个基于文档的 Mac 应用，要在应用的 Info.plist 里提供 NSDocument 子类的名字。Swift里，你必须使用文档子类的全名，包括从你的应用或者框架里派生出来的模块名字。
<span class="code">    下面的例子中，`NSClassFromString`方法用于检索一个来自字符串代表的类的引用。为了检索 Swift 类，需要使用全限定名，包括应用的名字。</span>

<span class="code">```</span>    swift
let myPersonClass:AnyClass(NSClassFromString("MyGreatApp.Person"))
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>翻译：<a href="https://github.com/halinuya" target="_blank" rel="external">halinuya</a></p>
<p>校对：<a href="https://github.com/s]]>
    </summary>
    
      <category term="Using Swift with Cocoa and Objective-C" scheme="http://yoursite.com/tags/Using-Swift-with-Cocoa-and-Objective-C/"/>
    
      <category term="swift-cn" scheme="http://yoursite.com/categories/swift-cn/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[02Interoperability-03与 Cocoa 数据类型共舞]]></title>
    <link href="http://yoursite.com/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/03Working%20with%20Cocoa%20Data%20Types/"/>
    <id>http://yoursite.com/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/03Working with Cocoa Data Types/</id>
    <published>2015-12-26T14:00:08.000Z</published>
    <updated>2015-12-15T06:25:48.585Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>翻译：<a href="https://github.com/wongzigii" target="_blank" rel="external">wongzigii</a>、<a href="https://github.com/SemperIdem" target="_blank" rel="external">星夜暮晨</a></p>
<p>校对：<a href="https://github.com/dabing1022" target="_blank" rel="external">ChildhoodAndy</a></p>
</blockquote>
<h2 id="#与_Cocoa_数据类型共舞">#与 Cocoa 数据类型共舞</h2><p>本节内容包括：</p>
<ul>
<li><a href="#strings">字符串（Strings）</a></li>
<li><a href="#numbers">数值（Numbers）</a></li>
<li><a href="#collection_classes">集合类（Collection Classes）</a></li>
<li><a href="#errors">错误（Errors）</a></li>
<li><a href="#foundation_data_types">Foundation数据类型（Foundation Data Types）</a></li>
<li><a href="#foundation_functions">Foundation函数（Foundation Functions）</a></li>
<li><a href="#core_foundation">Core Foundation</a></li>
</ul>
<p>作为对 Objective-C 互用性（互操作性）的一部分，Swift提供快捷高效的方式来处理 Cocoa 数据类型。</p>
<p>Swift 会自动将一些 Objective-C 类型转换为 Swift 类型，以及将 Swift 类型转换为 Objective-C 类型。在 Objective-C 和 Swift 中也有一些具有互用性的数据类型。那些可转换的数据类型或者具有互用性的数据类型被称为<em>bridged</em>数据类型。举个例子，在 Swift 中，我们可以将一个<code>Array</code>值传递给一个要求为<code>NSArray</code>对象的方法。我们也可以转换一个 bridged 类型和它的副本。当我们使用<code>as</code>转换 bridged 类型或者那些由常量和变量所提供的类型时，Swift 会桥接它们的数据类型。</p>
<p>Swift 也提供一种简单便捷的覆盖方法来连接 Foundation 的数据类型，在后面的 Swift 语言中，我们能在它的句法中感受到自然和统一。</p>
<p><a name="strings"></a></p>
<p>##字符串</p>
<p>Swift会在<code>String</code>类型和<code>NSString</code>类型中自动转换。这意味着在可以使用<code>NSString</code>对象的地方，我们可以使用一个属于 Swift 的<code>String</code>类型代替它，这样做会同时拥有它们数据类型的特点，比如说<code>String</code>类型的字符串插值，基于Swift设计的API，以及<code>NSString</code>类的多种功能。因此，我们几乎不必再在我们的代码中使用<code>NSString</code>类。事实上，当 Swift 接入 Objective-C API 时，它将把所有<code>NSString</code>类型替换为<code>String</code>类型。当我们在我们的Objective-C代码中使用 Swift 类时，接入的API会将所有<code>String</code>类型替换成<code>NSString</code>类型。</p>
<p>为了允许字符串转换，只需导入Foundation框架。举个例子，我们在 Swift的一个字符串中可以访问<code>capitalizedString</code>，这是<code>NSString</code>类的一个属性，然后 Swift 会自动将<code>String</code>转换为一个<code>NSString</code>对象来访问这个属性。这个属性甚至会返回一个 Swift的<code>String</code>类型，因为它在导入的时候被替换了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">let</span> greeting = <span class="string">"hello, world!"</span></span><br><span class="line"><span class="keyword">let</span> capitalizedGreeting = greeting.capitalizedString</span><br><span class="line"><span class="comment">// capitalizedGreeting: String = Hello, World!</span></span><br></pre></td></tr></table></figure>
<p>如果我们确实需要用到一个<code>NSString</code>对象，我们可以用一个 Swift 的<code>String</code>值并转换它。<code>String</code>类型总是可以从一个<code>NSString</code>对象转换为一个Swift的<code>String</code>的值，因此，再没有必要去使用一个可选的类型转换器(<code>as?</code>)。我们也可以在一个字符串中通过定义常量和变量来创建一个<code>NSString</code>对象。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">let</span> myString: <span class="type">NSString</span> = <span class="string">"123"</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> integerValue = <span class="type">Int</span>(myString <span class="keyword">as</span> <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(myString)</span> is the integer <span class="subst">\(integerValue)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// prints "123 is the integer 123"</span></span><br></pre></td></tr></table></figure>
<p>###本地化<br>在Objective-C中，常用<code>NSLocalizedString</code>类的宏来定位一个字符串。这集合的宏包括<code>NSLocalizedString</code>，<code>NSLocalizedStringFromTable</code>，<code>NSLocalizedStringFromTableInBundle</code>，和<code>NSLocalizedStringWithDefaultValue</code>。而在Swift中，只用一个函数就可以实现跟整个<code>NSLocalizedString</code>集一样的功能，即<code>NSLocalizedString(key:tableName:bundle:value:comment:)</code>。这个<code>NSLocalizedString</code>函数分别为<code>tableName</code>，<code>bundle</code>和<code>value</code>参数提供了一个默认值。我们可以用它来替换宏。</p>
<p><a name="numbers"></a></p>
<p>##数值</p>
<p>Swift会自动将已确定的数值类型<code>Int</code>和<code>Float</code>转换为<code>NSNumber</code>。这样的转换允许我们基于其中一种类型创建一个<code>NSNumber</code>：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let <span class="keyword">n</span> = 42</span><br><span class="line">let <span class="keyword">m</span>: NSNumber = <span class="keyword">n</span></span><br></pre></td></tr></table></figure>
<p>我们也能传递一个<code>Int</code>类型的值，比如传递给一个要求为<code>NSNumber</code>类型的参数。同时需要注意的是，<code>NSNumber</code>可以包含多种不同的类型，因此我们不能把它传递给单一的一个<code>Int</code>值。</p>
<p>下面所列出的类型都会自动转换为<code>NSNumber</code>：</p>
<ul>
<li><code>Int</code></li>
<li><code>UInt</code></li>
<li><code>Float</code></li>
<li><code>Double</code></li>
<li><code>Bool</code></li>
</ul>
<p><a name="collection_classes"></a></p>
<p>##集合类</p>
<p>Swift 会自动将<code>NSArray</code>、<code>NSSet</code>和<code>NSDictionary</code>类转换为Swift里等价的类：<code>Array</code>、<code>Set</code>和<code>Dictionary</code>。这意味着我们将受益于Swift强大的算法和得天独厚的语法来处理集合–可互相转换的 Foundation 和 Swift 集合类型。</p>
<p>###数组(Arrays)</p>
<p>Swift 会在<code>Array</code>类型和<code>NSArray</code>类型中自动转换。当我们从一个 Swift 数组转换成一个<code>NSArray</code>对象后，转换后的结果则是一个<code>[ObjectType]</code>类型的数组。如果<code>NSArray</code>对象没有指明一个确切的参数类型，那么它将会转换成<code>[AnyObject]</code>类型的Swift数组。</p>
<p>比如说，我们看到以下Objective-C声明：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSDate</span> *&gt;* dates;</span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">NSDate</span> *&gt; *)datesBeforeDate:(<span class="built_in">NSDate</span> *)date;</span><br><span class="line">- (<span class="keyword">void</span>)addDatesParsedFromTimestamps:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)timestamps;</span><br></pre></td></tr></table></figure>
<p>那么，转换为Swift，则是这样子的：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dates: [<span class="type">NSDate</span>]</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">datesBeforeDate</span><span class="params">(date: NSDate)</span></span> -&gt; [<span class="type">NSDate</span>]</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">addDatesParsedFromTimestamps</span><span class="params">(timestamps: [String])</span></span></span><br></pre></td></tr></table></figure></p>
<p>如果某个对象是 Objective-C 或者 Swift 类的实例，或者这个对象可以转换成另一种类型，那么这个对象则属于<code>AnyObject</code>类型的对象。我们可以将任一<code>NSArray</code>对象转换成一个 Swift 数组，因为所有 Objective-C 的对象都是<code>AnyObject</code>类型的。正因如此，Swift 的编译器会在接入 Objective-C APIs 的时候将<code>NSArray</code>类替换成<code>AnyObject[]</code>。</p>
<p>当我们将一个<code>NSArray</code>对象转换成一个 Swift 数组后，我们也可以将数组强制类型转换成一个特定的类型。与从<code>NSArray</code>类转换到<code>AnyObject[]</code>不同的是，从<code>AnyObject</code>类型的对象转换成明确的类型并不会保证成功。由于直到运行时编译器才知道<code>AnyObject</code>的对象能否被强制转换为特定的类型，因此，从<code>AnyObject[]</code>转换为<code>SomeType[]</code>会返回一个 optional 的值。举个例子，如果我们知道一个Swift数组只包含<code>UIView</code>类的实例(或者一个<code>UIView</code>类的子类)，我们可以将<code>AnyObject</code>类型的数组元素强制转换为<code>UIView</code>对象。如果Swift数组中的元素在运行时不是<code>UIView</code>类型的对象，那么转换则会返回<code>nil</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> swiftyArray = foundationArray <span class="keyword">as</span> <span class="type">AnyObject</span>[]</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> downcastedSwiftArray = swiftArray <span class="keyword">as</span>? <span class="type">UIView</span>[] &#123;</span><br><span class="line">    <span class="comment">// downcastedSwiftArray contains only UIView objects</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以在for循环中将NSArray对象定向地强制转换为特定类型的Swift数组:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> aView: <span class="type">UIView</span>! <span class="keyword">in</span> foundationArray &#123;</span><br><span class="line">     <span class="comment">// aView is of type UIView</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这种转换是强制转换，如果转换不成功则会在运行时产生错误信息。</p>
</blockquote>
<p>当我们从 Swift 数组转换为<code>NSArray</code>对象时，Swift 数组里的元素必须是属于<code>AnyObject</code>的。例如，一个<code>Int[]</code>类型的 Swift 数组包含<code>Int</code>结构的元素。<code>Int</code>类型并不是一个类的实例，但由于<code>Int</code>类型转换成了<code>NSNumber</code>类，<code>Int</code>类型属于<code>AnyObject</code>类型的。因此，我们可以将一个<code>Int[]</code>类型的Swift数组转换为<code>NSArray</code>对象。如果 Swift 数组里的一个元素不属于<code>AnyObject</code>类型，那么在运行时就会产生错误。</p>
<p>我们也可以从 Swift 数组中创建一个<code>NSArray</code>对象。当我们将一个常量或变量定义为一个<code>NSArray</code>对象并分配一个数组给它作为实例变量时，Swift 将会创建 <code>NSArray</code>对象，而不是 Swift 数组。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> schoolSupplies: <span class="type">NSArray</span> = [<span class="string">"Pencil"</span>, <span class="string">"Eraser"</span>, <span class="string">"Notebkko"</span>]</span><br><span class="line"><span class="comment">// schoolSupplies is an NSArray object containing NSString objects</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，Swift 数组包含包含三个<code>String</code>字符串。由于从<code>String</code>类型转换为<code>NSString</code>类，数组字面量被转换成一个<code>NSArray</code>对象，并成功分配给<code>schoolSupplies</code>变量。</p>
<p>当我们在 Objective-C 代码中使用 Swift 类或者协议时，接入的API会将全部所有类型的Swift数组代替为<code>NSArray</code>。若我们将一个<code>NSArray</code>对象传递给Swift的API并要求数组元素为一个新的类型，运行时就会产生错误。如果 Swift API 返回一个不能被转换为<code>NSArray</code>类型的 Swift 数组，错误也会随之产生。</p>
<p>###集合(Sets)</p>
<p>除了数组以外，Swift还会自动在<code>Set</code>类型和<code>NSSet</code>类之间进行转换。当我们将一个带有参数类型的<code>NSSet</code>对象转换为Swift集合之后，得到的结果是<code>Set&lt;ObjectType&gt;</code>类型的集合。而如果<code>NSSet</code>对象没有指明其参数类型，那么它将会转换为<code>Set&lt;AnyObject&gt;</code>类型的Swift集合。</p>
<p>比如说，我们看到以下Objective-C声明：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt;* words;</span><br><span class="line">- (<span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt; *)wordsMatchingPredicate:(<span class="built_in">NSPredicate</span> *)predicate;</span><br><span class="line">- (<span class="keyword">void</span>)removeWords:(<span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt; *)words;</span><br></pre></td></tr></table></figure>
<p>那么，转换为Swift，则是这个样子的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> words: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">wordsMatchingPredicate</span><span class="params">(predicate: NSPredicate)</span></span> -&gt; <span class="type">Set</span>&lt;<span class="type">String</span>&gt;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">removeWords</span><span class="params">(words: Set&lt;String&gt;)</span></span></span><br></pre></td></tr></table></figure>
<p>我们能够将所有<code>NSSet</code>对象转换为Swift集合，因为所有的Objective-C对象都可以被转换为<code>AnyObject</code>。所有的<code>NSSet</code>对象都能够转换为Swift对象，因此Swift编译器将会在导入Objective-C API的时候，将所有的<code>NSSet</code>类转换为<code>Set&lt;AnyObject&gt;</code>。同理，当我们在Objective-C中使用Swift类或者协议的时候，导入器将会将Swift集合重新映射为Objective-C兼容的类型：<code>NSSet</code>对象。</p>
<p>当我们将<code>NSSet</code>对象转换为Swift集合后，还可以将集合下转为其他指定类型。就如同Swift数组的下转一样，Swift集合的下转不确保一定成功。对<code>Set&lt;AnyObject&gt;</code>下转为指定类型的结果需要使用<code>as?</code>操作符，以确保其是可选值。</p>
<p>我们仍然可以直接从Swift数组字面量中直接创建一个<code>NSSet</code>对象，它同样遵循上面提到的转换规则。当我们明确地将某个常量或者变量定义为<code>NSSet</code>对象，并且使用一个数组字面量来赋值的时候，Swift将会创建一个<code>NSSet</code>对象，而不是Swift集合。</p>
<p>###字典(Dictionaries)</p>
<p>Swift同样可以在<code>Dictionary</code>和<code>NSDictionary</code>类当中自动转换。当我们将带有参数类型的<code>NSDictionary</code>对象转换为Swift字典之后，得到的结果是一个<code>[ObjectType]</code>类型的字典。如果<code>NSDictionary</code>对象没有指明参数类型，那么它将会被转换为<code>[NSObject:AnyObject]</code>类型的Swift字典。</p>
<p>比如说，我们看到以下Objective-C声明：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSURL</span> *, <span class="built_in">NSData</span> *&gt;* cachedData;</span><br><span class="line">- (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSURL</span> *, <span class="built_in">NSNumber</span> *&gt; *)fileSizesForURLsWithSuffix:(<span class="built_in">NSString</span> *)suffix;</span><br><span class="line">- (<span class="keyword">void</span>)setCacheExpirations:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSURL</span> *, <span class="built_in">NSDate</span> *&gt; *)expirations;</span><br></pre></td></tr></table></figure>
<p>那么，转换为Swift，则是这个样子的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cachedData: [<span class="type">NSURL</span>: <span class="type">NSData</span>]</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">fileSizesForURLsWithSuffix</span><span class="params">(suffix: String)</span></span> -&gt; [<span class="type">NSURL</span>: <span class="type">NSNumber</span>]</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">setCacheExpirations</span><span class="params">(expirations: [NSURL: NSDate])</span></span></span><br></pre></td></tr></table></figure>
<p>我们能够将所有的<code>NSDictionary</code>对象转换为Swift字典，因为所有的Objective-C对象都兼容<code>AnyObject</code>。重申一下，某个对象能够“兼容”<code>AnyObject</code>，指的是其是Objective-C的一个实例，或者是Swift的类，亦或者是能够转换为这两者之一的东西。所有的<code>NSDictionary</code>对象都能够转换为Swift字典，因此Swift编译器会在导入Objective-C API的时候，将所有的<code>NSDictionary</code>类替换成<code>[NSObject: AnyObject]</code>。同理，当我们在Objective-C中使用Swift类或者协议的时候，导入器将会将Swift字典重新映射为Objective-C兼容的类型：<code>NSDictionary</code>对象。</p>
<p>当我们将<code>NSDictionary</code>对象转换为Swift字典后，还可以将字典<em>下转</em>为其他指定类型。就如同Swift数组的下转一样，Swift字典的下转不确保一定成功。对<code>[NSObject: AnyObject]</code>下转为指定类型的结果需要使用<code>as?</code>操作符，以确保其是可选值。</p>
<p>当我们进行反向转换，也就是将Swift字典转换为<code>NSDictionary</code>对象的过程中，其键值都必须是某个类的实例，或者能够被转换为某个类的实例。</p>
<p>我们仍然可以直接从Swift数组字面量中直接创建一个<code>NSDictionary</code>对象，它同样遵循上面提到的转换规则。当我们明确地将某个常量或者变量定义为<code>NSDictionary</code>对象，并且使用一个数组字面量来赋值的时候，Swift将会创建一个<code>NSDictionary</code>对象，而不是Swift字典。</p>
<p><a name="errors"></a></p>
<p>##错误</p>
<p>Swift能够自动在<code>ErrorType</code>类型和<code>NSError</code>类之间转换，会发生错误的Objective-C方法等价于Swift中的<code>throw</code>方法，而会发生错误的Swift方法通过Objecitive-C错误约定，也等价于产生错误的Objective-C方法。</p>
<p>实现<code>ErrorType</code>协议，并且使用<code>@objc</code>特性声明的Swift枚举类型，会产生一个<code>NS_ENUM</code>声明和一个<code>NSString</code>常量，以能够在产生的头文件中设定对应的错误范围。比如说，有以下Swift枚举声明代码：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@objc</span> public <span class="class"><span class="keyword">enum</span> <span class="title">CustomError</span>: <span class="title">Int</span>, <span class="title">ErrorType</span> &#123;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="constant">A</span>, <span class="constant">B</span>, <span class="constant">C</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，在相应的生成头文件中的Objectivive-C声明就是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Project-Swift.h</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">SWIFT_ENUM</span><span class="params">(NSInteger, CustomError)</span> </span>&#123;</span><br><span class="line">  CustomErrorA = <span class="number">0</span>,</span><br><span class="line">  CustomErrorB = <span class="number">1</span>,</span><br><span class="line">  CustomErrorC = <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> NSString * <span class="keyword">const</span> CustomErrorDomain = @<span class="string">"Project.CustomError"</span>;</span><br></pre></td></tr></table></figure>
<p>关于更多Swift和Objective-C API中错误处理的相关信息，请参阅<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-ID10" target="_blank" rel="external">Error Handling</a>。</p>
<p><a name="foundation_data_types"></a></p>
<p>##Foundation数据类型<br>Swift 也提供一种简单便捷的覆盖方法来连接定义在 Foundation 框架中的数据类型。在<code>CGSize</code>和<code>CGPoint</code>中使用覆盖方法，我们就能在它的句法中感受到Swift语言的自然和统一。比如，我们可以使用如下语法创建一个<code>CGSize</code>类型的结构:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> size = <span class="type">CGSize</span>(width: <span class="number">20</span>, height: <span class="number">40</span>)</span><br></pre></td></tr></table></figure>
<p>覆盖方法也允许我们以一种自然的方式调用 Foundation 的结构函数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rect = <span class="type">CGRect</span>(x: <span class="number">50</span>, y: <span class="number">50</span>, width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line"><span class="keyword">let</span> width = rect.width    <span class="comment">// equivalent of CGRectGetWidth(rect)</span></span><br><span class="line"><span class="keyword">let</span> maxX = rect.maxY      <span class="comment">// equivalent of CGRectGetMaxY(rect)</span></span><br></pre></td></tr></table></figure>
<p>Swift可以将<code>NSUInteger</code>和<code>NSInteger</code>转换为<code>Int</code>类型。这些类型都会在 Foundation APIs 中变为<code>Int</code>类型。在 Swift 中<code>Int</code>常被尽可能地用以连贯性，同时当我们要求一个无符号整数类型时，<code>UInt</code>类型总是可使用的。</p>
<p><a name="foundation_functions"></a></p>
<p>##Foundation函数</p>
<p>在 Swift 中，<code>NSLog</code>可在系统控制台输出信息。我们可以像在 Objective-C 中使用过的语法格式那样使用此函数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSLog</span>(<span class="string">"%.7f"</span>, pi)</span><br><span class="line"><span class="comment">// Logs "3.1415927" to the console</span></span><br></pre></td></tr></table></figure>
<p>同时，Swift 也提供像<code>print(_:)</code>这样的输出函数。多亏于 Swift 的字符插值机制才让这些函数简单，粗暴，高效。这些函数不会在系统控制台输出信息，但在需要调用的时候却是可用的。</p>
<p>Swift 中不再存在<code>NSAssert</code>函数，取而代之的是<code>assert</code>函数。</p>
<p><a name="core_foundation"></a></p>
<p>##Core Foundation</p>
<p>Swift中的 Core Foundation 类型是一个成熟的类。当出现内存管理注释时，Swift 会自动地管理 Core Foundation 对象的内存，这其中包括我们实例化了的 Core Foundation 对象。在 Swift 中，我们可以自由变换 Fundation 和 Core Foundation 类型。如果我们想先转换为桥接 Foundation 类型时，那么也可以桥接一些 toll-free bridged Core Foundation 类型到 Swift 标准库类型。</p>
<p>###重映射类型(Remapped Types)</p>
<p>当 Swift 导入 Core Foundation 类型时，编译器会重映射导入的类型名字。编译器会从每个类型名字的末端移除 <em>Ref</em>，这是因为所有的 Swift 类都属于引用类型，因此后缀是多余的。</p>
<p>Core Foundation 中的<code>CFTypeRef</code>类型会对<code>Anyobject</code>类型重映射。所以我们以前使用的<code>CFTypeRef</code>，现在该换成<code>AnyObject</code>了。</p>
<p>###内存管理对象(Memory Managed Objects)</p>
<p>在 Swift 中，从 annotated APIs 返回的 Core Foundation 对象能够自动进行内存管理–我们不再需要调用自身的<code>CFRetain</code>，<code>CFRelease</code>，或者<code>CFAutorelease</code>函数。</p>
<p>如果我们从自身的C函数和 Objective-C 方法中返回一个 Core Foundation 对象，我们需要用<code>CF_RETURNS_RETAINED</code>或者<code>CF_RETURNS_NOT_RETAINED</code>注释这个对象。我们同样可以使用<code>CF_IMPLICIT_BRIDGING_ENABLED</code>和<code>CF_IMPLICIT_BRIDGING_DISABLED</code>宏命令来封装C函数声明，这些函数遵循Core Foundation的管理规定、命名规定，以便能够根据命名退导出内存管理机制能。</p>
<p>如果我们只调用那些不会间接返回 Core Foundation 对象的 annotated APIs，那么现在我们可以跳过本节的剩余部分了。否则，下面我们继续学习非托管的 Core Foundation 对象。</p>
<p>###非托管对象(Unmanaged Objects)</p>
<p>当 Swift 导入 unannotated 的APIs时，编译器将不会自动地对返回的 Core Foundation 对象进行内存管理托管。Swift 将这些返回的 Core Foundation 对象封闭在一个<code>Unmanaged&lt;T&gt;</code>结构中。那些间接返回 Core Foundation 的对象也是非托管的。举个例子，这里有一个 unannotated 的 C 函数:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CFStringRef</span> <span class="type">StringByAddingTwoStrings</span>(<span class="type">CFStringRef</span> string1, <span class="type">CFStringRef</span> string2)</span><br></pre></td></tr></table></figure>
<p>这里说明了Swift是怎么导入的:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">StringByAddingTwoStrings</span><span class="params">(CFString!, CFString!)</span></span> -&gt; <span class="type">Unmanaged</span>&lt;<span class="type">CFString</span>&gt;!</span><br></pre></td></tr></table></figure>
<p>假设我们从 unannotated APIs 接收了非托管的对象，在使用它之前，我们必须将它转换为能够内存管理的对象。在这方面，Swift 可以帮我们进行内存管理而不用自己动手。同时，<code>Unmanaged&lt;T&gt;</code>结构也提供了两个方法来把一个非托管对象转换为一个可内存管理的对象–<code>takeUnretainedValue()</code>方法和<code>takeRetainedValue()</code>方法。这两个方法会返回原始的，非封闭的对象类型。我们可以根据我们实际调用的APIs返回的unretained或retained的对象，来选择哪一方法更合适。</p>
<p>比如，假设这里有一个 C 函数，这个函数在返回值前不会释放<code>CFString</code>对象。在使用这个对象前，我们使用<code>takeUnretainedValue()</code>函数，以将它转换为一个能够内存管理托管的对象。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> memoryManagedResult = <span class="type">StringByAddingTwoStrings</span>(str1, str2).takeUnretainedValue()</span><br><span class="line"><span class="comment">// memoryManagedResult is a memory managed CFString</span></span><br></pre></td></tr></table></figure>
<p>我们也可以在一个非托管的对象中使用<code>retain()</code>，<code>release()</code>和<code>autorelease()</code>方法，但是这种做法并不值得推荐。</p>
<p>要了解更多信息，请参考<a href="https://developer.apple.com/library/prerelease/ios/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/CFMemoryMgmt.html#//apple_ref/doc/uid/10000127i" target="_blank" rel="external">Memory Management Programming Guide for Core Foundation</a>中的<a href="https://developer.apple.com/library/prerelease/ios/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148" target="_blank" rel="external">Memory Management Programming Guide for Core Foundation</a>一节。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>翻译：<a href="https://github.com/wongzigii" target="_blank" rel="external">wongzigii</a>、<a href="https://github.com/SemperIde]]>
    </summary>
    
      <category term="Using Swift with Cocoa and Objective-C" scheme="http://yoursite.com/tags/Using-Swift-with-Cocoa-and-Objective-C/"/>
    
      <category term="swift-cn" scheme="http://yoursite.com/categories/swift-cn/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[02Interoperability-04采用Cocoa设计模式]]></title>
    <link href="http://yoursite.com/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/04Adopting%20Cocoa%20Design%20Patterns/"/>
    <id>http://yoursite.com/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/04Adopting Cocoa Design Patterns/</id>
    <published>2015-12-26T14:00:07.000Z</published>
    <updated>2015-12-15T06:28:52.845Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>翻译：<a href="https://github.com/JaceFu" target="_blank" rel="external">JaceFu</a> <a href="https://github.com/dabing1022" target="_blank" rel="external">ChildhoodAndy</a></p>
<p>校正：<a href="https://github.com/LunaticM" target="_blank" rel="external">LunaticM</a> <a href="https://github.com/dabing1022" target="_blank" rel="external">ChildhoodAndy</a></p>
</blockquote>
<h2 id="#采用Cocoa设计模式">#采用Cocoa设计模式</h2><p>本页包含内容：</p>
<ul>
<li><a href="#Delegation">委托（Delegation）</a></li>
<li><a href="#error_handling">错误处理（Error Handling）</a></li>
<li><a href="#Key-Value_Observing">键值观察（Key-Value Observing）</a></li>
<li><a href="#Target_Action">Target-Action模式（Target-Action）</a></li>
<li><a href="#Introspection">类型匹配与统一规范（Introspection）</a></li>
<li><a href="#API_Availability">API 可用性</a></li>
</ul>
<p>使用 Cocoa 现有的一些设计模式，是帮助开发者开发一款拥有合理设计思路、稳定的性能、良好的可扩展性应用的有效方法之一。这些模式都依赖于在 Objective-C 中定义的类。因为 Swift 与 Objective-C 的互用性，所以你依然可以在 Swift 代码中使用这些设计模式。在一些情况下，你甚至可以使用 Swift 语言的特性扩展或简化这些 Cocoa 设计模式，使这些设计模式更强大、更易于使用。</p>
<p><a name="Delegation"></a></p>
<h2 id="委托">委托</h2><p>在 Swift 和 Objective-C 中，委托通常由一个定义交互方法和遵循规范的委托属性的协议表示。与 Objective-C 相比，当你在 Swift 中继承一个委托时，虽然继承模式不变，但是内部的实现已经改变了。就像在 Objective-C 中，在你向委托发送消息之前，不管它是不是 <code>nil</code> 你都会去查看，如果定义的方法是非必须实现的方法，不管委托有没有实现这个方法，你也都会去查看。而在 Swift 中，通过保持类型安全的特性，可以有效的消除这些繁琐、不必要的行为问题。</p>
<p>下面列出的代码可以说明这个过程：</p>
<ol>
<li>检查 <code>myDelegate</code> 不为 <code>nil</code>。</li>
<li>检查 <code>myDelegate</code> 是否实现了继承的 <code>window:willUseFullScreenContentSize:</code> 方法。</li>
<li>如果<code>myDelegate</code> 不为 <code>nil</code> 并且实现了 <code>window:willUseFullScreenContentSize:</code> 方法，那么调用该方法，将该方法的返回值分配给名为 <code>fullScreenSize</code> 的属性。</li>
<li>将该方法的返回值输出在控制台。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @inteface MyObject : NSObject</span></span><br><span class="line"><span class="comment">// @property (nonatomic, weak) id&lt;NSWindowDelegate&gt; delegate;</span></span><br><span class="line"><span class="comment">// @end</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> fullScreenSize = myDelegate?.window?(myWindow, willUseFullScreenContentSize: mySize) &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="type">NSStringFromSize</span>(fullScreenSize))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>在一个完全使用 Swift 编写的 app 中，在定义 <code>delegate</code> 属性时，它作为一个不定值的 <code>NSWindowDelegate</code> 对象，并将初始值设为 <code>nil</code>。</p>
</blockquote>
<h2 id="错误处理">错误处理</h2><p>在 Cocoa 中，产生错误的方法将<code>NSError</code>指针参数作为最后一个参数，当错误产生时，该参数会被<code>NSError</code>对象填充。Swift 自动的将 Objective-C 中产生错误的方法转换为 Swift 的原生错误处理功能。</p>
<blockquote>
<p>注意</p>
<p>产生错误的方法，例如代理方法或者采用一个<code>NSError</code>对象作为参数的完成处理函数，不会被 Swift 处理为<code>throw</code>的方法。</p>
</blockquote>
<p>例如，考虑下面的来自于<code>NSFileManager</code>的 Objective-C 方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)removeItemAtURL:(NSURL *)URL&#10;                  error:(NSError **)error;</span><br></pre></td></tr></table></figure>
<p>在 Swift 中，它会被这样的导入：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">removeItemAtURL</span><span class="params">(URL: NSURL)</span></span> throws</span><br></pre></td></tr></table></figure>
<p>注意到<code>removeItemAtURL(_:)</code>方法被 Swift 导入时，返回值类型为 Void，没有错误参数，而是一个<code>throws</code>声明。</p>
<p>如果 Objective-C 方法的最后一个非闭包参数是<code>NSError **</code>类型，Swift 则会将之替换为<code>throws</code>关键字，以表明该方法可以抛出一个错误。如果 Objective-C 方法的错误参数也是它的第一个参数，Swift 则会尝试通过删除选择器的第一部分中的<code>AndReturnError</code>后缀来进一步简化方法的名称，如果存在的话。如果另一种方法是用所得选择器声明的，那么该方法名将不可改变。</p>
<p>如果产生错误的 Objective-C 的方法返回一个用来表示方法调用成功或失败的<code>BOOL</code>值，Swift 会把函数的返回值转换为<code>Void</code>。同样的，如果产生错误的 Objective-C 方法返回一个<code>nil</code>值来表明方法调用的失败，Swift 会把函数的返回值转换为非可选值类型。</p>
<p>否则，如果没有约定可以推断，该方法保持不变。</p>
<h3 id="捕获和处理错误">捕获和处理错误</h3><p>在 Objective-C 中，错误处理是可选的，意味着方法产生的错误会被忽略除非你提供了一个错误指针。在 Swift 中，调用一个会抛出错误的方法要求显示的进行错误处理。</p>
<p>下面是如何在 Objective-C 中处理调用方法产生的错误：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSFileManager *fileManager = [NSFileManager defaultManager];&#10;NSURL *URL = [NSURL fileURLWithPath:@&#34;/path/to/file&#34;];&#10;NSError *error = nil;&#10;BOOL success = [fileManager removeItemAtURL:URL error:&#38;error];&#10;if (!success &#38;&#38; error) &#123;&#10;    NSLog(@&#34;Error: %@&#34;, error.domain);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>下面是 Swift 中等同的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fileManager = <span class="type">NSFileManager</span>.defaultManager()</span><br><span class="line"><span class="keyword">let</span> <span class="type">URL</span> = <span class="type">NSURL</span>.fileURLWithPath(<span class="string">"/path/to/file"</span>)</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    try fileManager.removeItemAtURL(<span class="type">URL</span>)</span><br><span class="line">&#125; catch <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">NSError</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Error: <span class="subst">\(error.domain)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="抛出错误">抛出错误</h3><p>如果一个错误出现在了 Objective-C 方法中，那么该错误被用来填充方法的错误指针参数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// an error occurred</span></span><br><span class="line"><span class="keyword">if</span> (errorPtr) &#123;</span><br><span class="line">   *errorPtr = [<span class="type">NSError</span> errorWithDomain:<span class="type">NSURLErrorDomain</span></span><br><span class="line">                                   code:<span class="type">NSURLErrorCannotOpenFile</span></span><br><span class="line">                               userInfo:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个错误出现在了 Swift 方法中，那么该错误便会被抛出，并且会自动的传递给调用者：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// an error occurred</span></span><br><span class="line">throw <span class="type">NSError</span>(domain: <span class="type">NSURLErrorDomain</span>, code: <span class="type">NSURLErrorCannotOpenFile</span>, userInfo: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>如果 Objective-C 代码调用 Swift 方法抛出了错误，那么该错误会被自动的传递给桥接的 Objective-C 方法的错误指针参数。</p>
<p>例如，考虑<code>NSDocument</code>中的<code>readFromFileWrapper(_:ofType:)</code>方法。在 Objective-C 中，这个方法的最后一个参数是<code>NSError **</code>。当在 Swift 的<code>NSDocument</code>的子类中重写该方法时，该方法会用<code>throws</code>替代错误指针参数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerializedDocument</span>: <span class="title">NSDocument</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">ErrorDomain</span> = <span class="string">"com.example.error.serialized-document"</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> representedObject: [<span class="type">String</span>: <span class="type">AnyObject</span>] = [:]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">readFromFileWrapper</span><span class="params">(fileWrapper: NSFileWrapper, ofType typeName: String)</span></span> throws &#123;</span><br><span class="line">        guard <span class="keyword">let</span> data = fileWrapper.regularFileContents <span class="keyword">else</span> &#123;</span><br><span class="line">            throw <span class="type">NSError</span>(domain: <span class="type">NSURLErrorDomain</span>, code: <span class="type">NSURLErrorCannotOpenFile</span>, userInfo: <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> <span class="type">JSON</span> <span class="keyword">as</span> [<span class="type">String</span>: <span class="type">AnyObject</span>] = try <span class="type">NSJSONSerialization</span>.<span class="type">JSONObjectWithData</span>(data, options: []) &#123;</span><br><span class="line">            <span class="keyword">self</span>.representedObject = <span class="type">JSON</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            throw <span class="type">NSError</span>(domain: <span class="type">SerializedDocument</span>.<span class="type">ErrorDomain</span>, code: -<span class="number">1</span>, userInfo: <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果方法不能够使用常规的文件的内容来创建一个对象，则会抛出一个<code>NSError</code>对象。如果方法是从 Swift 代码中调用的，那么该错误会被传递到它的调用域。如果该方法是在 Objective-C 代码中被调用，错误将会传递到错误指针参数里。</p>
<p>在 Objective-C 中，错误处理是可选的，意味着方法产生的错误会被忽略除非你提供了一个错误指针。在 Swift 中，调用一个会抛出错误的方法要求显式的进行错误处理。</p>
<blockquote>
<p>注意</p>
<p>尽管 Swift 的错误处理类似 Objective-C 的异常处理，但它是完全独立的功能。如果一个 Objective-C 方法抛出了一个运行时异常，Swift 则会触发一个运行时错误。没有办法直接在 Swift 中恢复来自 Objective-C 的异常。任何在 Objective-C 代码中的异常处理行为必须用 Swift 来实现。</p>
</blockquote>
<p><a name="Key-Value_Observing"></a></p>
<p>##键值观察</p>
<p>键值观察是一种机制，该机制允许对象获得其他对象的特定属性的变化的通知。只要你的类继承自 NSObject 类，你便可在 Swift 类里使用键值观察。你可以在 Swift 中使用下面三步来实现键值观察：</p>
<ol>
<li>为你想要观察的属性添加动态修改符。关于<code>dynamic</code>更多信息，请见<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID57" target="_blank" rel="external">Requiring Dynamic Dispatch</a></li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObjectToObserve</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    dynamic <span class="keyword">var</span> myDate = <span class="type">NSDate</span>()</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">updateDate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        myDate = <span class="type">NSDate</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>创建一个全局上下文变量。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">var</span> myContext = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ol>
<li>为键-路径增加一个观察者，重写<code>observeValueForKeyPath:ofObject:change:context:</code>函数，并且在<code>deinit</code>中移除观察者。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObserver</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> objectToObserve = <span class="type">MyObjectToObserve</span>()</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        objectToObserve.addObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"myDate"</span>, options: .<span class="type">New</span>, context: &amp;myContext)</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">observeValueForKeyPath</span><span class="params">(keyPath: String?, ofObject object: AnyObject?, change: [NSObject : AnyObject]?, context: UnsafeMutablePointer&lt;Void&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> context == &amp;myContext &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> newValue = change?[<span class="type">NSKeyValueChangeNewKey</span>] &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Date changed: <span class="subst">\(newValue)</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.observeValueForKeyPath(keyPath, ofObject: object, change: change, context: context)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        objectToObserve.removeObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"myDate"</span>, context: &amp;myContext)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="Target_Action"></a></p>
<p>##Target-Action模式（Target-Action）##<br>当有特定事件发生，需要一个对象向另一个对象发送消息时，我们通常采用 Cocoa 的 Target-Action 设计模式。Swift 和 Objective-C 中的 Target-Action 模型基本类似。在 Swift 中，你可以使用 <code>Selector</code> 类型达到 Objective-C 中 selectors 的效果。请在 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID59" target="_blank" rel="external">Objective-C Selectors</a> 中查看在 Swift 中使用 Target-Action 设计模式的示例。</p>
<p><a name="Introspection"></a></p>
<p>##类型匹配与统一规范（Introspection）##<br>在 Objective-C 中，你可以使用 <code>isKindOfClass:</code> 方法检查某个对象是否是指定类型，可以使用 <code>conformsToProtocol:</code> 方法检查某个对象是否遵循特定协议的规范。在 Swift 中，你可以使用 <code>is</code> 运算符完成上述的功能，或者也可以使用 <code>as?</code> 向下匹配指定类型。</p>
<p>你可以使用 <code>is</code> 运算符检查一个实例是否是指定的子类。如果该实例是指定的子类，那么 <code>is</code> 运算结果为 <code>true</code>，反之为 <code>false</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> object <span class="keyword">is</span> <span class="type">UIButton</span> &#123;</span><br><span class="line">    <span class="comment">// object is of type UIButton</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// object is not of type UIButton</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以使用 <code>as?</code> 运算符尝试向下匹配子类型，<code>as?</code> 运算符返回不定值，结合 <code>if-let</code> 语句使用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> button = object <span class="keyword">as</span>? <span class="type">UIButton</span> &#123;</span><br><span class="line">    <span class="comment">// object is successfully cast to type UIButton and bound to button</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// object could not be cast to type UIButton</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请在 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TypeCasting.html#//apple_ref/doc/uid/TP40014097-CH22" target="_blank" rel="external">Type Casting</a> 中查看更多信息。</p>
<p>检查匹配协议的语法与检查匹配类的语法是一样的，下面是使用 <code>as?</code> 检查匹配协议的示例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> dataSource = object <span class="keyword">as</span>? <span class="type">UITableViewDataSource</span> &#123;</span><br><span class="line">    <span class="comment">// object conforms to UITableViewDataSource and is bound to dataSource</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// object not conform to UITableViewDataSource</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，当做完匹配之后，<code>dataSource</code> 会转换为  <code>UITableViewDataSource</code> 类型，所以你只能访问和调用<code>UITableViewDataSource</code> 协议定义的属性和方法。当你想进行其他操作时，必须将其转换为其他的类型。<br><br>可以在 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25" target="_blank" rel="external">Protocols</a> 查看更多相关信息。</p>
<p><a name="API_Availability"></a></p>
<h2 id="API_可用性">API 可用性</h2><p>一些类和方法并不是在你的应用所有平台的所有版本都可用。为了确保你的应用功能上能够适应差异，你需要检查这些 API 的可用性。</p>
<p>在 Objective-C 中，我们使用<code>respondsToSelector:</code>和<code>instancesRespondToSelector:</code>方法来检查一个类或者实例方法是否可用。如果没有检查，调用方法则会抛出<code>NSInvalidArgumentException</code>“unrecognized selector sent to instance”异常。例如，<code>requestWhenInUseAuthorization</code>方法只在 iOS8.0 和 OS X 10.10 中对<code>CLLocationManager</code>实例可用。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if ([CLLocationManager instancesRespondToSelector:@selector(requestWhenInUseAuthorization)]) &#123;&#10;  // &#26041;&#27861;&#21487;&#29992;&#10;&#125; else &#123;&#10;  // &#26041;&#27861;&#19981;&#21487;&#29992;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在 Swift 中，尝试着调用一个目标平台版本不支持的方法将会报出编译时错误。</p>
<p>下面是上一个例子，采用 Swift 编写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> locationManager = <span class="type">CLLocationManager</span>()</span><br><span class="line">locationManager.requestWhenInUseAuthorization()</span><br><span class="line"><span class="comment">// error: only available on iOS 8.0 or newer</span></span><br></pre></td></tr></table></figure>
<p>如果应用的目标低于 ios8.0 或者 OSX10.10，<code>requestWhenInUseAuthorization()</code>方法则不可用，所以编译器会报告错误。</p>
<p>Swift 代码可以使用 API 可用性来作为运行时的条件判断。可用性检查可以使用在一个控制流语句的条件中，例如<code>if</code>,<code>guard</code>或者<code>while</code>语句。</p>
<p>拿前面的例子举例，你可以使用<code>if</code>语句来检查可用性，只有当方法在运行时可用时方可调用<code>requestWhenInUseAuthorization()</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> locationManager = <span class="type">CLLocationManager</span>()</span><br><span class="line"><span class="keyword">if</span> #available(iOS <span class="number">8.0</span>, <span class="type">OSX</span> <span class="number">10.10</span>, *) &#123;</span><br><span class="line">    locationManager.requestWhenInUseAuthorization()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者，你可以使用<code>guard</code>语句来检查可用性，除非当前的目标符合规定要求，否则将会退出作用域。这种方法简化了处理不同平台功能的逻辑。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> locationManager = <span class="type">CLLocationManager</span>()</span><br><span class="line">guard #available(iOS <span class="number">8.0</span>, <span class="type">OSX</span> <span class="number">10.10</span>, *) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">locationManager.requestWhenInUseAuthorization()</span><br></pre></td></tr></table></figure>
<p>每个平台参数包括下面列出的平台名称，后面跟着相应的版本号。最后一个参数是一个星号（*），是用来处理未来潜在的平台。</p>
<p>平台名称：</p>
<ul>
<li>iOS</li>
<li>iOSApplicationExtension</li>
<li>OSX</li>
<li>OSXApplicationExtension</li>
<li>watchOS</li>
</ul>
<p>所有的 Cocoa API 都提供有可用性信息，所以你可以很自信的编写应用所针对的平台的代码。</p>
<p>你可以通过 @available 属性来标注声明从而简化你的 API 的可用性检查。@available 属性使用和 #available 同样的语法来做运行时检查，参数都以逗号隔开平台版本需求。</p>
<p>例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@available(iOS <span class="number">8.0</span>, <span class="type">OSX</span> <span class="number">10.10</span>, *)</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">useShinyNewFeature</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>使用 @available 属性标记的方法可以安全的使用满足特定平台需求的可用 API 而不用显式的做可用性检查。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>翻译：<a href="https://github.com/JaceFu" target="_blank" rel="external">JaceFu</a> <a href="https://github.com/dabing1022" tar]]>
    </summary>
    
      <category term="Using Swift with Cocoa and Objective-C" scheme="http://yoursite.com/tags/Using-Swift-with-Cocoa-and-Objective-C/"/>
    
      <category term="swift-cn" scheme="http://yoursite.com/categories/swift-cn/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[02Interoperability-05与 C 的 API 交互]]></title>
    <link href="http://yoursite.com/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/05Interacting%20with%20C%20APIs/"/>
    <id>http://yoursite.com/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/05Interacting with C APIs/</id>
    <published>2015-12-26T14:00:06.000Z</published>
    <updated>2015-12-15T06:28:59.906Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>翻译：<a href="https://github.com/shockinglee" target="_blank" rel="external">shockinglee</a></p>
<p>校对：<a href="https://github.com/shanyimin" target="_blank" rel="external">shanyimin</a> <a href="https://github.com/dabing1022" target="_blank" rel="external">ChildhoodAndy</a> <a href="https://github.com/Phenmod" target="_blank" rel="external">Phenmod</a></p>
</blockquote>
<h1 id="与_C_的_API_交互">与 C 的 API 交互</h1><hr>
<p>本节包含内容：</p>
<ul>
<li><a href="#primitive_types">基本数据类型（Primitive Types）</a></li>
<li><a href="#enumerations">枚举（Enumerations）</a></li>
<li><a href="#pointer">指针（Pointer）</a></li>
<li><a href="#global_constants">全局常量（Global Constants）</a></li>
<li><a href="#preprocessor_directives">预处理指令（Preprocessor Directives）</a></li>
</ul>
<p>作为与Objective-C语言的互用性的一部分，Swift也对一些C语言的类型和特性保持了兼容性。如果你的代码有需要，Swift也提供了一些方式来使用常见的C结构和模式。</p>
<h2 id="基本数据类型">基本数据类型</h2><p>Swift提供了一些与C语言基本类型如<code>char</code>,<code>int</code>,<code>float</code>和<code>double</code>等的对应类型。然而，这些类型和Swift核心基本类型之间不能进行隐式转换，如Int。因此，只有你的代码明确要求时才使用这些类型，其它任何可能的情况下都应该使用Int。</p>
<table>
<thead>
<tr>
<th>C 类型</th>
<th>Swift 类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>bool</td>
<td>CBool</td>
</tr>
<tr>
<td>char, signed char</td>
<td>CChar</td>
</tr>
<tr>
<td>unsigned char</td>
<td>CUnsignedChar</td>
</tr>
<tr>
<td>short</td>
<td>CShort</td>
</tr>
<tr>
<td>unsigned short</td>
<td>CUnsignedShort</td>
</tr>
<tr>
<td>int</td>
<td>CInt</td>
</tr>
<tr>
<td>unsigned int</td>
<td>CUnsignedInt</td>
</tr>
<tr>
<td>long</td>
<td>CLong</td>
</tr>
<tr>
<td>unsigned long</td>
<td>CUnsignedLong</td>
</tr>
<tr>
<td>long long</td>
<td>CLongLong</td>
</tr>
<tr>
<td>unsigned long long</td>
<td>CUnsignedLongLong</td>
</tr>
<tr>
<td>wchar_t</td>
<td>CWideChar</td>
</tr>
<tr>
<td>char16_t</td>
<td>CChar16</td>
</tr>
<tr>
<td>char32_t</td>
<td>CChar32</td>
</tr>
<tr>
<td>float</td>
<td>CFloat</td>
</tr>
<tr>
<td>double</td>
<td>CDouble</td>
</tr>
</tbody>
</table>
<h2 id="枚举">枚举</h2><p>任何用宏<code>NS_ENUM</code>来声明的C风格的枚举，都会被Swfit导入为一个Swfit枚举类型。无论枚举值是在系统框架还是在自己的代码中定义的，当它们导入到Swift时，它们的前缀名将被截掉。</p>
<p>例如，看这个Objective-C枚举的声明：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Objective-C</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UITableViewCellStyle</span>) &#123;</span><br><span class="line">    <span class="built_in">UITableViewCellStyleDefault</span>,</span><br><span class="line">    <span class="built_in">UITableViewCellStyleValue1</span>,</span><br><span class="line">    <span class="built_in">UITableViewCellStyleValue2</span>,</span><br><span class="line">    <span class="built_in">UITableViewCellStyleSubtitle</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在Swift中，会被导入为这样：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//Swift</span><br><span class="line"><span class="keyword">enum</span> UITableViewCellStyle: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">Default</span></span><br><span class="line">    <span class="keyword">case</span> Value1</span><br><span class="line">    <span class="keyword">case</span> Value2</span><br><span class="line">    <span class="keyword">case</span> Subtitle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你需要使用一个枚举值时，使用以点（.）开头的枚举名称：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="keyword">let</span> cellStyle: UITableViewCellStyle = .<span class="built_in">Default</span></span><br></pre></td></tr></table></figure>
<h2 id="选项集">选项集</h2><p>对使用宏<code>NS_OPTIONS</code>声明的C风格的枚举，Swift会把它导入为一个Swfit选项集类型。选项集像枚举一样，会把前缀截掉，只剩下选项值名称。</p>
<p>例如，看这个Objective-C选项的声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Objective-C</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NS_OPTIONS</span><span class="params">(NSUInteger, NSJSONReadingOptions)</span> </span>&#123;</span><br><span class="line">	NSJSONReadingMutableContainers = (<span class="number">1U</span>L &lt;&lt; <span class="number">0</span>),</span><br><span class="line">	NSJSONReadingMutableLeaves = (<span class="number">1U</span>L &lt;&lt; <span class="number">1</span>),</span><br><span class="line">	NSJSONReadingAllowFragments = (<span class="number">1U</span>L &lt;&lt; <span class="number">2</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在Swift中，它被导入为这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NSJSONReadingOptions</span> : <span class="title">OptionSetType</span> </span>&#123;</span><br><span class="line">	<span class="keyword">init</span>(rawValue: <span class="type">UInt</span>)</span><br><span class="line">   </span><br><span class="line">   	<span class="keyword">static</span> <span class="keyword">var</span> <span class="type">MutableContainers</span>: <span class="type">NSJSONReadingOptions</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">   	<span class="keyword">static</span> <span class="keyword">var</span> <span class="type">MutableLeaves</span>: <span class="type">NSJSONReadingOptions</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">   	<span class="keyword">static</span> <span class="keyword">var</span> <span class="type">AllowFragments</span>: <span class="type">NSJSONReadingOptions</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在Objective-C中，一个选项集是整数值的一个位掩码。你可以使用按位或操作符（<code>|</code>）来组合选项值，使用按位与操作符（<code>&amp;</code>）以检测选项值。创建一个选项集，可以使用常量值或者表达式。一个空的选项集使用常数<code>0</code>来表示。</p>
<p>在Swift中，选项集使用一个遵循<code>OptionSetType</code>协议的结构体来表示，其中每个选项值都是一个静态变量。选项集类似于Swift的集合类型<code>Set</code>，你可以用<code>insert(_:)</code>或者<code>unionInPlace(_:)</code>方法来添加选项值，用<code>remove(_:)</code>或者<code>subtractInPlace(_:)</code>方法来删除选项值，用<code>contains(_:)</code>方法来检测选项值。创建一个选项集的值可以使用一个数组字面量，里面的选项值像枚举一样都用点（<code>.</code>）开头。创建一个空的选项集可以使用一个空的数组字面量，也可以调用默认初始化函数。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line">let options: NSDataBase64EncodingOptions = [</span><br><span class="line">	<span class="class">.Encoding76CharacterLineLength</span>,</span><br><span class="line">   	<span class="class">.EncodingEndLineWithLineFeed</span></span><br><span class="line">   ]</span><br><span class="line">let string = data.<span class="function"><span class="title">base64EncodedStringWithOptions</span><span class="params">(options)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="共用体">共用体</h2><p>Swift仅部分支持C的共用体（union）类型。在导入混有C的共用体或者位段（bitfields）的类型时，例如Foundation的<code>NSDecimal</code>类型，Swift不能存取不支持的字段。但是，参数和/或返回值为这些类型的C和Objective-C的API是能够在Swift中使用的。</p>
<h2 id="指针">指针</h2><p>Swift尽可能避免让您直接访问指针。然而，当您需要直接操作内存的时候，Swift也为您提供了多种指针类型。下面的表使用<code>Type</code>作为类型名称的占位符。</p>
<p>对于返回类型，变量和参数，使用如下形式：</p>
<table>
<thead>
<tr>
<th>C 句法</th>
<th>Swift 句法</th>
</tr>
</thead>
<tbody>
<tr>
<td>const Type *</td>
<td>UnsafePointer\<type\></type\></td>
</tr>
<tr>
<td>Type *</td>
<td>UnsafeMutablePointer\<type\></type\></td>
</tr>
</tbody>
</table>
<p>对于类（class）类型，使用如下形式：</p>
<table>
<thead>
<tr>
<th>C 句法</th>
<th>Swift 句法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Type <em> const </em></td>
<td>UnsafePointer\<type\></type\></td>
</tr>
<tr>
<td>Type <em> __strong </em></td>
<td>UnsafeMutablePointer\<type\></type\></td>
</tr>
<tr>
<td>Type **</td>
<td>AutoreleasingUnsafeMutablePointer\<type\></type\></td>
</tr>
</tbody>
</table>
<h3 id="常量指针">常量指针</h3><p>当一个函数被声明为接受<code>UnsafePointer&lt;Type&gt;</code>参数时，这个函数可以接受下列任何一个类型作为参数：</p>
<ul>
<li><code>nil</code>，作为空指针传入；</li>
<li>一个<code>UnsafePointer&lt;Type&gt;</code>，<code>UnsafeMutablePointer&lt;Type&gt;</code>， 或者<code>AutoreleasingUnsafeMutablePointer&lt;Type&gt;</code>的值，在必要情况下会转换成<code>UnsafePointer&lt;Type&gt;</code>的值；</li>
<li>一个<code>String</code>类型的值，如果<code>Type</code>是<code>Int8</code>或者<code>UInt8</code>的话。该字符串会自动在一个缓冲区内被转换为UTF8，该缓冲区在本次调用期间有效；</li>
<li>一个左值操作数为<code>Type</code>类型的输入输出（inout）表达式，传入的是这个左值的内存地址；</li>
<li>一个<code>[Type]</code>值，传入该数组的起始指针，并且它的生命周期将在本次调用期间被延长。</li>
</ul>
<p>如果您这样定义了一个函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesAPointer</span><span class="params">(x: UnsafePointer&lt;Float&gt;)</span></span> &#123; <span class="comment">/*...*/</span> &#125;</span><br></pre></td></tr></table></figure>
<p>那么您可以使用以下任何一种方式来调用这个函数：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//Swift</span></span><br><span class="line">   <span class="tag">var</span> x: Float = <span class="number">0.0</span></span><br><span class="line"><span class="tag">var</span> <span class="tag">p</span>: UnsafePointer&lt;Float&gt; = nil</span><br><span class="line"><span class="function"><span class="title">takesAPointer</span><span class="params">(nil)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAPointer</span><span class="params">(p)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAPointer</span><span class="params">(&amp;x)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAPointer</span><span class="params">([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>])</span></span></span><br></pre></td></tr></table></figure>
<p>如果函数被声明为使用一个<code>UnsafePointer&lt;Void&gt;</code>参数，那么这个函数接受任何<code>Type</code>的<code>UnsafePointer&lt;Type&gt;</code>类型的操作数。<br>￼<br>如果您这样定义了一个函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesAVoidPointer</span><span class="params">(x: UnsafePointer&lt;Void&gt;)</span></span>  &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>那么您可以使用以下任何一种方式来调用这个函数：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//Swift</span></span><br><span class="line">   <span class="tag">var</span> x: Float = <span class="number">0.0</span>, y: Int = <span class="number">0</span></span><br><span class="line"><span class="tag">var</span> <span class="tag">p</span>: UnsafePointer&lt;Float&gt; = nil, <span class="tag">q</span>: UnsafePointer&lt;Int&gt; = nil</span><br><span class="line"><span class="function"><span class="title">takesAVoidPointer</span><span class="params">(nil)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAVoidPointer</span><span class="params">(p)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAVoidPointer</span><span class="params">(q)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAVoidPointer</span><span class="params">(&amp;x)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAVoidPointer</span><span class="params">(&amp;y)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAVoidPointer</span><span class="params">([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>] as [Float])</span></span></span><br><span class="line">let intArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="function"><span class="title">takesAVoidPointer</span><span class="params">(intArray)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="可变指针">可变指针</h3><p>当一个方法被声明为接受<code>UnsafeMutablePointer&lt;Type&gt;</code>参数时，这个函数可以接受下列任何一个类型作为参数：</p>
<ul>
<li><code>nil</code>，作为空指针传入；</li>
<li>一个<code>UnsafeMutablePointer&lt;Type&gt;</code>类型的值；</li>
<li>一个输入输出（inout）表达式，其左值操作数是<code>Type</code>类型的，且被存储起来了。传入的是这个左值的内存地址；</li>
<li>一个输入输出的<code>[Type]</code>类型的值，传入的是该数组的起始指针，并且它的生命周期将在本次调用期间被延长。</li>
</ul>
<p>如果您这样定义了一个函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesAMutablePointer</span><span class="params">(x: UnsafeMutablePointer&lt;Float&gt;)</span></span> &#123; <span class="comment">/*...*/</span> &#125;</span><br></pre></td></tr></table></figure>
<p>那么您可以使用以下任何一种方式来调用这个函数：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//Swift</span></span><br><span class="line">   <span class="tag">var</span> x: Float = <span class="number">0.0</span></span><br><span class="line"><span class="tag">var</span> <span class="tag">p</span>: UnsafeMutablePointer&lt;Float&gt; = nil</span><br><span class="line"><span class="tag">var</span> <span class="tag">a</span>: [Float] = [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>]</span><br><span class="line"><span class="function"><span class="title">takesAMutablePointer</span><span class="params">(nil)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAMutablePointer</span><span class="params">(p)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAMutablePointer</span><span class="params">(&amp;x)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAMutablePointer</span><span class="params">(&amp;a)</span></span></span><br></pre></td></tr></table></figure>
<p>如果函数被声明使用一个<code>UnsafeMutablePointer&lt;Void&gt;</code>参数，那么这个函数接受任何<code>Type</code>的<code>UnsafeMutablePointer&lt;Type&gt;</code>类型的操作数。</p>
<p>如果您这样定义了一个函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesAMutableVoidPointer</span><span class="params">(x: UnsafeMutablePointer&lt;Void&gt;)</span></span>  &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>那么您可以使用以下任何一种方式来调用这个函数：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//Swift</span></span><br><span class="line">   <span class="tag">var</span> x: Float = <span class="number">0.0</span>, y: Int = <span class="number">0</span></span><br><span class="line"><span class="tag">var</span> <span class="tag">p</span>: UnsafeMutablePointer&lt;Float&gt; = nil, <span class="tag">q</span>: UnsafeMutablePointer&lt;Int&gt; = nil</span><br><span class="line"><span class="tag">var</span> <span class="tag">a</span>: [Float] = [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>], <span class="tag">b</span>: [Int] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="function"><span class="title">takesAMutableVoidPointer</span><span class="params">(nil)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAMutableVoidPointer</span><span class="params">(p)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAMutableVoidPointer</span><span class="params">(q)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAMutableVoidPointer</span><span class="params">(&amp;x)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAMutableVoidPointer</span><span class="params">(&amp;y)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAMutableVoidPointer</span><span class="params">(&amp;a)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAMutableVoidPointer</span><span class="params">(&amp;b)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="自动释放指针">自动释放指针</h3><p>当一个函数被声明为接受<code>AutoreleasingUnsafeMutablePointer&lt;Type&gt;</code>参数时，这个函数可以接受下列任何一个类型作为参数：</p>
<ul>
<li><code>nil</code>，作为空指针传入；</li>
<li>一个<code>AutoreleasingUnsafeMutablePointer&lt;Type&gt;</code>类型的值；</li>
<li>一个输入输出（inout）表达式，其操作数首先被拷贝到一个无拥有者的缓冲区，传递给被调用函数的就是这个缓冲区的地址。在调用返回时，缓冲区中的值被加载、保存、并重新复制给操作数。</li>
</ul>
<p>注意，这个列表中没有包含数组。</p>
<p>如果您这样定义了一个函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesAnAutoreleasingPointer</span><span class="params">(x: AutoreleasingUnsafeMutablePointer&lt;NSDate?&gt;)</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>那么您可以使用以下任何一种方式来调用这个函数：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//Swift</span></span><br><span class="line">   <span class="keyword">var</span> x: NSDate? = <span class="keyword">nil</span></span><br><span class="line"><span class="keyword">var</span> p: AutoreleasingUnsafeMutablePointer&lt;NSDate?&gt; = <span class="keyword">nil</span></span><br><span class="line">takesAnAutoreleasingPointer(<span class="keyword">nil</span>)</span><br><span class="line">takesAnAutoreleasingPointer(p)</span><br><span class="line">takesAnAutoreleasingPointer(&amp;x)</span><br></pre></td></tr></table></figure>
<p>被指针指向的类型并不会被桥接。例如，<code>NSString **</code>转换到Swift后，是<code>AutoreleasingUnsafeMutablePointer&lt;NSString?&gt;</code>，而不是<code>AutoreleasingUnsafeMutablePointer&lt;String?&gt;</code>。</p>
<h3 id="函数指针">函数指针</h3><p>C语言的函数指针通过调用约定，以闭包的形式被引入Swift中，表示形式为<code>@convention(c)</code>。例如，一个类型为<code>int (*)(void)</code>的C语言函数指针，会转换为Swift的<code>@convention(c) () -&gt; Int32</code>。</p>
<p>在调用一个以函数指针为参数的函数时，给它传的值可以是一个顶层的Swift函数，也可以是个闭包字面量，或者<code>nil</code>。只有符合C语言函数指针调用约定的Swift函数，才能用来给函数指针类型的形参传值。例如，Core Foundation的<code>CFArrayCreateMutable(_:_:_:)</code>函数，它有个参数的类型为<code>CFArrayCallBacks</code>结构体。这个<code>CFArrayCallBacks</code>结构体就是用一些函数指针进行初始化的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">customCopyDescription</span><span class="params">(p: UnsafePointer&lt;Void&gt;)</span></span> -&gt; <span class="type">Unmanaged</span>&lt;<span class="type">CFString</span>&gt;! &#123;</span><br><span class="line">   	<span class="comment">// return an Unmanaged&lt;CFString&gt;! value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> callbacks = <span class="type">CFArrayCallBacks</span>(</span><br><span class="line">   	version: <span class="number">0</span> <span class="keyword">as</span> <span class="type">CFIndex</span>,</span><br><span class="line">   	retain: <span class="literal">nil</span>,</span><br><span class="line">   	release: <span class="literal">nil</span>,</span><br><span class="line">   	copyDescription: customCopyDescription,</span><br><span class="line">   	<span class="built_in">equal</span>: &#123; (p1, p2) -&gt; <span class="type">Boolean</span> <span class="keyword">in</span></span><br><span class="line">       	<span class="comment">// return Boolean value</span></span><br><span class="line">   	&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mutableArray = <span class="type">CFArrayCreateMutable</span>(<span class="literal">nil</span>, <span class="number">0</span>, callbacks)</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，在<code>CFArrayCallBacks</code>初始化时，传给<code>retain</code>和<code>release</code>作参数的是<code>nil</code>，传给<code>copyDescription</code>作参数的是函数<code>customCopyDescription</code>，传给<code>equal</code>作参数的是一个闭包字面量。</p>
<h2 id="全局常量">全局常量</h2><p>在C和Objective-C语言源文件中定义的全局常量会自动地被Swift编译引进并做为Swift的全局常量。</p>
<h2 id="预处理指令">预处理指令</h2><p>Swift编译器不包含预处理器。取而代之的是，它充分利用了编译时属性，生成配置，和语言特性来完成相同的功能。因此，Swift没有引进预处理指令。</p>
<h3 id="简单宏">简单宏</h3><p>在C和Objective-C中，通常使用<code>#define</code>指令来定义一个简单的常数，在Swift，您可以使用全局常量来代替。例如：定义一个常数的<code>#define FADE_ANIMATION_DURATION 0.35</code>，在Swift使用<code>let FADE_ANIMATION_DURATION = 0.35</code>来表述会更好一些。由于简单的用于定义常量的宏会被直接被映射成Swift全局量，Swift编译器会自动引进在C或Objective-C源文件中定义的简单宏。</p>
<h3 id="复杂宏">复杂宏</h3><p>在C和Objective-C中使用的复杂宏在Swift中没有相对应的东西。复杂宏是那些不用来定义常量的宏，包含了括号的函数式宏。您在C和Objective-C使用复杂的宏以避免类型检查的限制或避免重新键入大量的样板代码。然而，宏也会造成debug和重构起来更困难。在Swift中你可以使用函数和泛型来达到同样的效果，而没有任何的委屈折中。因此，在C和Objective-C源文件中定义的复杂宏在Swift是不能使用的。</p>
<h3 id="生成配置">生成配置</h3><p>Swift代码使用和C、Objective-C代码不同的方式进行条件编译。Swift代码可以根据生成配置的组合进行条件编译。生成配置包括<code>true</code>和<code>false</code>字面值，命令行标志，和下表中的平台测试函数。您可以使用<code>-D &lt;＃Flag＃&gt;</code>指定命令行标志。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>有效参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>os()</td>
<td>OSX，iOS，watchOS</td>
</tr>
<tr>
<td>arch()</td>
<td>x86_64，arm，arm64，i386</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意：生成配置<code>arch(arm)</code>不会为64位ARM设备返回<code>true</code>，生成配置<code>arch(i386)</code>在为32位iOS模拟器编译代码时会返回<code>true</code>。</p>
</blockquote>
<p>一个简单的条件编译可以像下面这段代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">if</span> build configuration</span></span><br><span class="line">  statements</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">  statements</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>由零个或多个有效的Swift语句组成的<em>statements</em>，可以包括表达式，普通语句和控制流语句。可以使用<code>&amp;&amp;</code>和<code>||</code>操作符往一个条件编译语句上添加新的编译条件，使用<code>!</code>操作符来否定某条件，使用<code>#elseif</code>来添加编译块：</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">if</span> build configuration &amp;&amp; !build configuration</span></span><br><span class="line">  statements<span class="preprocessor"></span><br><span class="line">#<span class="keyword">elseif</span> build configuration</span></span><br><span class="line">  statements<span class="preprocessor"></span><br><span class="line">#<span class="keyword">else</span></span></span><br><span class="line">  statements<span class="preprocessor"></span><br><span class="line">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>与C语言编译器的条件编译不同的是，Swift条件编译的语句必须是独立完整、语法有效的代码块。这是因为所有的Swift代码都会做语法检查，而不管会不会被编译。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>翻译：<a href="https://github.com/shockinglee" target="_blank" rel="external">shockinglee</a></p>
<p>校对：<a href="https://github]]>
    </summary>
    
      <category term="Using Swift with Cocoa and Objective-C" scheme="http://yoursite.com/tags/Using-Swift-with-Cocoa-and-Objective-C/"/>
    
      <category term="swift-cn" scheme="http://yoursite.com/categories/swift-cn/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[03Mix and Match-01Mix and Match 概述（Mix and Match Overview]]></title>
    <link href="http://yoursite.com/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/03Mix%20and%20Match/Swift%20and%20Objective-C%20in%20the%20Same%20Project/"/>
    <id>http://yoursite.com/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/03Mix and Match/Swift and Objective-C in the Same Project/</id>
    <published>2015-12-26T14:00:05.000Z</published>
    <updated>2015-12-15T06:32:54.916Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>翻译：<a href="https://github.com/haolloyin" target="_blank" rel="external">haolloyin</a></p>
<p>校对：<a href="https://github.com/dabing1022" target="_blank" rel="external">ChildhoodAndy</a></p>
</blockquote>
<h1 id="在同个工程中使用_Swift_和_Objective-C">在同个工程中使用 Swift 和 Objective-C</h1><hr>
<p>本节包含内容：</p>
<ul>
<li><a href="#mix_and_match_overview">Mix and Match 概述（Mix and Match Overview）</a></li>
<li><a href="#importing_code_from_within_the_same_app_target">在同个应用的 target 中导入（Importing Code from Within the Same App Target）</a></li>
<li><a href="#importing_code_from_within_the_same_framework_target">在同个 Framework 的 target 中导入（Importing Code from Within the Same Framework Target）</a></li>
<li><a href="#importing_external_frameworks">导入外部 framework（Importing External Frameworks）</a></li>
<li><a href="#using_swift_from_objective-c">在 Objective-C 中使用 Swift（Using Swift from Objective-C）</a></li>
<li><a href="#overriding_swift_names_for_Objective">为 Objective-C 接口重写 Swift 名称</a></li>
<li><a href="#naming_your_product_module">Product 模块命名（Naming Your Product Module）</a></li>
<li><a href="#troubleshooting_tips_and_reminders">问题解决提示（Troubleshooting Tips and Reminders）</a></li>
</ul>
<p>Swift 与 Objective-C 的兼容能力使你可以在同一个工程中同时使用两种语言。你可以用这种叫做 <code>mix and match</code> 的特性来开发基于混合语言的应用，可以用 Swift 的最新特性实现应用的一部分功能，并无缝地并入已有的 Objective-C 的代码中。</p>
<p><a name="mix_and_match_overview"></a></p>
<h2 id="Mix_and_Match_概述">Mix and Match 概述</h2><p>Objective-C 和 Swift 文件可以在一个工程中并存，不管这个工程原本是基于 Objective-C 还是 Swift。你可以直接往现有工程中简单地添加另一种语言的源文件。这种自然的工作流使得创建混合语言的应用或框架 target，与用单独一种语言时一样简单。</p>
<p>混合语言的工作流程只有一点点区别，这取决于你是在写应用还是写框架。下面描述了普通的用两种语言在一个 target 中导入模型的情况，后续章节会有更多细节。</p>
<p><img src="http://7xp6cn.com1.z0.glb.clouddn.com/DAG_2x.png" alt="DAG_2x.png"></p>
<p><a name="importing_code_from_within_the_same_app_target"></a></p>
<h2 id="在同个应用的_target_中导入">在同个应用的 target 中导入</h2><p>如果你在写混合语言的应用，可能需要用 Swift 代码访问 Objective-C 代码，或者反之。下面的流程描述了在非框架 target 中的应用。</p>
<h3 id="将_Objective-C_导入_Swift">将 Objective-C 导入 Swift</h3><p>在一个应用的 target 中导入一些 Objective-C 文件供 Swift 代码使用时，你需要依赖于 Objective-C 的桥接头文件（<code>bridging header</code>）来暴露给 Swift。当你添加 Swift 文件到现有的 Objective-C 应用（或反之）时，Xcode 会自动创建这些头文件。</p>
<p><img src="http://7xp6cn.com1.z0.glb.clouddn.com/bridgingheader_2x.png" alt="bridgingheader_2x.png"></p>
<p>如果你同意，Xcode 会在源文件创建的同时生成头文件，并用 product 的模块名加上 <code>-Bridging-Header.h</code> 命名。关于 product 的模块名，详见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_85" target="_blank" rel="external">Naming Your Product Module</a>。</p>
<p>你应该编辑这个头文件来对 Swift 暴露出 Objective-C 代码。</p>
<h4 id="在同一_target_中将_Objective-C_代码导入到_Swift_中">在同一 target 中将 Objective-C 代码导入到 Swift 中</h4><ol>
<li>在 Objective-C 桥接头文件中，<code>import</code>任何你想暴露给 Swift 的头文件，例如：</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &#34;XYZCustomCell.h&#34;&#10;#import &#34;XYZCustomView.h&#34;&#10;#import &#34;XYZCustomViewController.h&#34;</span><br></pre></td></tr></table></figure>
<ol>
<li>确保在 <code>Build Settings</code> 中 Objective-C 桥接头文件的 <code>build setting</code> 是基于 Swfit 编译器，即 <code>Code Generation</code> 含有头文件的路径。这个路径必须是头文件自身的路径，而不是它所在的目录。</li>
</ol>
<p>这个路径应该是你工程的相对路径，类似 <code>Info.plist</code> 在 <code>Build Settings</code> 中指定的路径。在大多数情况下，你不需要修改这个设置。</p>
<p>在这个桥接头文件中列出的所有 public 的 Objective-C 头文件都会对 Swift 可见。之后当前 target 的所有 Swift 文件都可以使用这些头文件中的方法，不需要任何 import 语句。用 Swift 语法使用这些 Objective-C 代码，就像使用系统自带的 Swift 类一样。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myCell = <span class="type">XYZCustomCell</span>()</span><br><span class="line">myCell.subtitle = <span class="string">"A custom cell"</span></span><br></pre></td></tr></table></figure>
<h3 id="将_Swift_导入到_Objective-C">将 Swift 导入到 Objective-C</h3><p>当你在将 Swift 代码导入到 Objective-C 中时，你依赖于 Xcode 生成的头文件来将这些文件暴漏给 Objective-C。这个自动生成的文件是一个 Objective-C 头文件，它包含了你的 target 中所有 Swift 代码中定义的接口。可以把这个 Objective-C 头文件看作 Swift 代码的 <code>umbrella header</code>。头文件名称以 product 模块名加 <code>-Swift.h</code> 来命名。（关于 product 的模块名，详见<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_85" target="_blank" rel="external">Naming Your Product Module</a>）。</p>
<p>默认情况下，生成的头文件包含了标记有<code>public</code>修饰符的 Swift 声明接口。它还包含那些打上，如果您的应用程序的目标有一个Objective-C的桥接头内部修改。标有private修饰符声明不会出现在所生成的报头。私人声明没有接触到Objective-C的，除非它们被明确标有@IBAction，@IBOutlet，或@objc为好。如果您的应用程序的目标是编译测试启用，单元测试目标可以访问任何声明与内部修饰，仿佛他们与公众修饰符通过预先@testable的产品模块导入语句声明。</p>
<p>你不需要做任何事情来生成这个头文件，只需要将它导入到你的 Objective-C 代码来使用它。注意这个头文件中的 Swift 接口包含了它所使用到的所有 Objective-C 类型。如果你在 Swift 代码中使用你自己的 Objective-C 类型，确保先将对应的 Objective-C 头文件导入到你的 Swift 代码中，然后才将 Swift 自动生成的头文件导入到 Objective-C .m 源文件中来访问 Swift 代码。</p>
<h5 id="在同一_target_中将_Swift_代码导入到_Objective-C_中">在同一 target 中将 Swift 代码导入到 Objective-C 中</h5><ul>
<li>在相同 target 的 Objective-C .m 源文件中，用下面的语法来导入Swift 代码：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &#34;ProductModuleName-Swift.h&#34;</span><br></pre></td></tr></table></figure>
<p>target 中任何 Swift 文件将会对 Objective-C .m 源文件可见，包括这个 import 语句。关于在 Objective-C 代码中使用 Swift 代码，详见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_84" target="_blank" rel="external">Using Swift from Objective-C</a>。</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">导入到 Swift</th>
<th style="text-align:center">导入到 Objective-C</th>
</tr>
</thead>
<tbody>
<tr>
<td>Swift 代码</td>
<td style="text-align:center">不需要import语句</td>
<td style="text-align:center">#import “ProductModuleName-Swift.h”</td>
</tr>
<tr>
<td>Objective-C 代码</td>
<td style="text-align:center">不需要import语句；需要 Objective-C bridging头文件</td>
<td style="text-align:center">#import “Header.h”</td>
</tr>
</tbody>
</table>
<p><a name="importing_code_from_within_the_same_framework_target"></a></p>
<h2 id="在同个_Framework_的_target_中导入">在同个 Framework 的 target 中导入</h2><p>如果你在写一个混合语言的框架，可能会从 Swift 代码访问 Objective-C 代码，或者反之。</p>
<h3 id="将_Objective-C_导入_Swift-1">将 Objective-C 导入 Swift</h3><p>要将一些 Objective-C 文件导入到同个框架 target 的 Swift 代码中去，你需要将这些文件导入到 Objective-C 的 <code>umbrella header</code> 来供框架使用。</p>
<h5 id="在同一_framework_中将_Objective-C_代码导入到_Swift_中">在同一 framework 中将 Objective-C 代码导入到 Swift 中</h5><p>确保将框架 target 的 <code>Build Settings &gt; Packaging &gt; Defines Module</code> 设置为 <code>Yes</code>。然后在你的 <code>umbrella header</code> 头文件中导入你想暴露给 Swift 访问的 Objective-C 头文件，例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &#60;XYZ/XYZCustomCell.h&#62;&#10;#import &#60;XYZ/XYZCustomView.h&#62;&#10;#import &#60;XYZ/XYZCustomViewController.h&#62;</span><br></pre></td></tr></table></figure>
<p>Swift 将会看到所有你在 <code>umbrella header</code> 中公开暴露出来的头文件，框架 target 中的所有 Swift 文件都可以访问你 Objective-C 文件的内容，不需要任何 import 语句。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myCell = <span class="type">XYZCustomCell</span>()</span><br><span class="line">myCell.subtitle = <span class="string">"A custom cell"</span></span><br></pre></td></tr></table></figure>
<h3 id="将_Swift_导入_Objective-C">将 Swift 导入 Objective-C</h3><p>要将一些 Swift 文件导入到同个框架的 target 的 Objective-C 代码去，你不需要导入任何东西到 <code>umbrella header</code> 文件，而是将 Xcode 为你的 Swift 代码自动生成的头文件导入到你的 Obj .m 源文件去，以便在 Objective-C 代码中访问 Swift 代码。</p>
<h5 id="在同一_framework_中将_Swift_代码导入到_Objective-C_中">在同一 framework 中将 Swift 代码导入到 Objective-C 中</h5><p>确保将框架 target 的 <code>Build Settings &gt; Packaging</code> 中的 <code>Defines Module</code> 设置为 <code>Yes</code>。用下面的语法将 Swift 代码导入到同个框架 target 下的 Objective-C .m 源文件去。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// OBJECTIVE-C&#10;#import &#60;ProductName/ProductModuleName-Swift.h&#62;</span><br></pre></td></tr></table></figure>
<p>这个 import 语句所包含的 Swift 文件都可以被同个框架 target 下的 Objective-C .m 源文件访问。关于在 Objective-C 代码中使用 Swift 代码，详见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_84" target="_blank" rel="external">Using Swift from Objective-C</a>。</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">导入到 Swift</th>
<th style="text-align:center">导入到 Objective-C</th>
</tr>
</thead>
<tbody>
<tr>
<td>Swift 代码</td>
<td style="text-align:center">不需要import语句</td>
<td style="text-align:center">#import “ProductName/ProductModuleName-Swift.h”</td>
</tr>
<tr>
<td>Objective-C 代码</td>
<td style="text-align:center">不需要import语句；需要 Objective-C umbrella头文件</td>
<td style="text-align:center">#import “Header.h”</td>
</tr>
</tbody>
</table>
<p><a name="importing_external_frameworks"></a></p>
<h2 id="导入外部_Framework">导入外部 Framework</h2><p>你可以导入外部框架，不管这个框架是纯 Objective-C，纯 Swift，还是混合语言的。import 外部框架的流程都是一样的，不管这个框架是用一种语言写的，还是包含两种语言。当你导入外部框架时，确保 <code>Build Setting &gt; Pakaging &gt; Defines Module</code> 设置为 <code>Yes</code>。</p>
<p>用下面的语法将框架导入到不同 target 的 Swift 文件中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> FrameworkName</span><br></pre></td></tr></table></figure>
<p>用下面的语法将框架导入到不同 target 的 Objective-C .m 文件中：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import FrameworkName;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">导入到 Swift</th>
<th style="text-align:center">导入到 Objective-C</th>
</tr>
</thead>
<tbody>
<tr>
<td>任意语言框架</td>
<td style="text-align:center">import FrameworkName</td>
<td style="text-align:center">@import FrameworkName;</td>
</tr>
</tbody>
</table>
<p><a name="using_swift_from_objective-c"></a></p>
<h2 id="在_Objective-C_中使用_Swift">在 Objective-C 中使用 Swift</h2><p>当你将 Swift 代码导入 Objective-C 之后，便可用常规的 Objective-C 语法来使用 Swift 类。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MySwiftClass *swiftObject = [[MySwiftClass alloc] init];&#10;[swiftObject swiftMethod];</span><br></pre></td></tr></table></figure>
<p>Swift 的类或协议必须用 <code>@objc</code>属性来标记，以便在 Objective-C 中可访问。这个 属性告诉编译器这块 Swift 代码可以从 Objective-C 代码中访问。如果你的 Swift 类是 Objective-C 类的子类，编译器会自动为你添加 <code>@objc</code>。详见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID53" target="_blank" rel="external">Swift Type Compatibility</a>。</p>
<p>你可以访问在 Swift 类或协议中使用用<code>@objc</code>属性标记的任何对象，只要该对象与 Objective-C 兼容。不包括以下 Swift 独有的特性：</p>
<ul>
<li><p>范型（Generics）</p>
</li>
<li><p>元组（Tuples）</p>
</li>
<li><p>Swift 中定义的枚举不包括<code>Int</code>原始值类型（Enumerations defined in Swift without Int raw value type）</p>
</li>
<li><p>Swift 中定义的结构体（Structures defined in Swift）   </p>
</li>
<li><p>Swift 中定义的顶层函数（Top-level functions defined in Swift）</p>
</li>
<li><p>Swift 中定义的全局变量（Global variables defined in Swift）</p>
</li>
<li><p>Swift 中定义的类型别名（Typealiases defined in Swift）</p>
</li>
<li><p>Swift风格可变参数（Swift-style variadics）</p>
</li>
<li><p>嵌套类型（Nested types）</p>
</li>
<li><p>柯里化函数（Curried functions）</p>
</li>
</ul>
<p>例如，使用范型类型作为参数，或者返回元组的方法将不能在 Objective-C 中使用。</p>
<blockquote>
<p>注意<br>你不能在 Objective-C 继承一个 Swift 类。</p>
</blockquote>
<h3 id="在_Objective-C_头文件中引用_Swift_类">在 Objective-C 头文件中引用 Swift 类</h3><p>这样前向声明 Swift 类：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// OBJECTIVE-C&#10;// MyObjective-CClass.h&#10;&#10;@class MySwiftClass;&#10;&#10;@interface MyObjective-CClass : NSObject&#10;- (MySwiftClass *)returnSwiftObject;&#10;/* ... */&#10;@end</span><br></pre></td></tr></table></figure>
<p><a name="overriding_swift_names_for_Objective-C_interfaces"></a></p>
<h2 id="为_Objective-C_接口重写_Swift_名称">为 Objective-C 接口重写 Swift 名称</h2><p>Swift 编译器自动的将 Objective-C 代码作为常规 Swift 代码导入。它将 Objective-C 的类工厂方法作为 Swift 构造器导入，以及将 Objective-C 的枚举类型名称截断处理。</p>
<p>在你的代码中也许存在不能够被自动处理的边界情况。如果你需要更改导入到 Swift 中的 Objective-C 方法，枚举，或者可选 set 值，你可以使用<code>NS_SWIFT_NAME</code>宏来自定义导入的声明。</p>
<h3 id="类工厂方法">类工厂方法</h3><p>如果 Swift 编译器无法识别类工厂方法，你可以使用<code>NS_SWIFT_NAME</code>宏，来正确导入构造器的 Swift 签名。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)recordWithRPM:(NSUInteger)RPM NS_SWIFT_NAME(init(RPM:));</span><br></pre></td></tr></table></figure>
<p>如果 Swift 编译器错误的将一个方法识别为类工厂方法，你可以使用<code>NS_SWIFT_NAME</code>宏，来正确导入构造器的 Swift 签名。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(id)recordWithQuality:(double)quality NS_SWIFT_NAME(record(quality:));</span><br></pre></td></tr></table></figure>
<h3 id="枚举">枚举</h3><p>默认情况下，Swift 将枚举值的名称前缀做截断来导入枚举。如果要自定义枚举值的名称，你可以使用<code>NS_SWIFT_NAME</code>宏来传递 Swift 枚举值名称。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, ABCRecordSide) &#123;&#10;  ABCRecordSideA,&#10;  ABCRecordSideB NS_SWIFT_NAME(&#34;FlipSide&#34;),&#10;&#125;;</span><br></pre></td></tr></table></figure>
<p><a name="naming_your_product_module"></a></p>
<h2 id="Product_模块命名">Product 模块命名</h2><p>Xcode 为 Swift 代码生成的头文件的名称，以及 Xcode 创建的 Objective-C 桥接头文件名称，都是从你的 product 模块名生成的。默认你的 product 模块名和 product 名一样。然而，如果你的 product 名有特殊字符（nonalphanumeric，非数字、字母的字符），例如点号，那么它们会被下划线（<code>_</code>）替换之后作为你的 product 模块名。如果 product 名以数字开头，那么第一个数字会用下划线替换掉。</p>
<p>你可以给 product 模块名提供一个自定义的名称，Xcode 会用这个名称来命名桥接的和自动生成的头文件。你只需要在修改在 <code>build setting</code> 中的 <code>Product Module Name</code> 即可。</p>
<p><a name="troubleshooting_tips_and_reminders"></a></p>
<h2 id="问题解决提示">问题解决提示</h2><ul>
<li>把 Swift 和 Objective-C 文件看作相同的代码集合，并注意命名冲突。</li>
<li>如果你使用了框架，确保在<code>Packaging</code>下的<code>Defines Module</code>编译设置被设置为 <code>Yes</code>。</li>
<li>如果你使用了 Objective-C 桥接头文件，确保 Swift 编译器中 Objective-C 桥接头文件的编译设置<code>Code Generation</code>有一个与项目相关的头文件的路径。这个路径必须是头文件自身的路径，而不是它所在的目录。</li>
<li>Xcode 使用你的工程模块名，而不是以<code>target</code>的名称来命名 Objective-C 桥接头文件以及为 Swift 代码 自动生成的头文件。详见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-ID138" target="_blank" rel="external">Naming Your Product Module</a>。</li>
<li>为了在 Objective-C 中可用， Swift 类必须是 Objective-C 类的子类，或者用 <code>@objc</code> 标记。</li>
<li>当你将 Swift 导入到 Objective-C 中时，记住 Objective-C 不会将 Swift 独有的特性转化成 Objective-C 对应的特性。详见列表 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-ID136" target="_blank" rel="external">Using Swift from Objective-C</a>。</li>
<li>如果你在 Swift 代码中使用你自己的 Objective-C 类型，确保先将对应的 Objective-C 头文件导入到你的 Swift 代码中，然后才将 Swift 自动生成的头文件导入到 Objective-C .m 源文件中来访问 Swift 代码。</li>
<li>用<code>private</code>修饰符标记的 Swift 声明不会出现在自动生成的头文件中。私有声明不会暴漏给 Objective-C，除非它们被明确标记有<code>@IBAction</code>，<code>@IBOutlet</code>或者<code>@objc</code>等。</li>
<li>对于应用 targets 而言，如果有 Objective-C 桥接头文件时，被<code>internal</code>修饰符标记的声明会出现在自动产生的头文件中。</li>
<li>对于框架 targets 而言，只有被<code>public</code>修饰符标记的声明才会出现在自动生成的头文件中。你仍然可以在框架中的 Objective-C 部分使用被<code>internal</code>修饰符标记的 Swift 方法和属性，只要它们声明所在的类继承自 Objective-C 类。关于访问级别修饰符的更多信息，请查看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097" target="_blank" rel="external">The Swift Programming Language</a>中的<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html#//apple_ref/doc/uid/TP40014097-CH41" target="_blank" rel="external">访问控制(Access Control)</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>翻译：<a href="https://github.com/haolloyin" target="_blank" rel="external">haolloyin</a></p>
<p>校对：<a href="https://github.com]]>
    </summary>
    
      <category term="Using Swift with Cocoa and Objective-C" scheme="http://yoursite.com/tags/Using-Swift-with-Cocoa-and-Objective-C/"/>
    
      <category term="swift-cn" scheme="http://yoursite.com/categories/swift-cn/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[04Migration-01为你的Objective-c代码做好迁移准备]]></title>
    <link href="http://yoursite.com/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/04Migration/Migrating%20Your%20Objective-C%20Code%20to%20Swift/"/>
    <id>http://yoursite.com/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/04Migration/Migrating Your Objective-C Code to Swift/</id>
    <published>2015-12-26T14:00:04.000Z</published>
    <updated>2015-12-15T06:29:16.810Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>翻译：<a href="https://github.com/xudeheng" target="_blank" rel="external">xudeheng</a></p>
<p>校对：<a href="http://github.com/dabing1022" target="_blank" rel="external">ChildhoodAndy</a></p>
</blockquote>
<h1 id="将_Objective-C_代码迁移到_Swift">将 Objective-C 代码迁移到 Swift</h1><hr>
<p>本节内容包括：</p>
<ul>
<li><a href="#preparing_your_objective-c_code_for_migration">为你的Objective-c代码做好迁移准备<br>（Preparing Your Objective-C Code for Migration）</a></li>
<li><a href="#the_migration_process">迁移过程（The Migration Process）</a></li>
<li><a href="#troubleshooting_tips_and_reminders">问题解决提示（Troubleshooting Tips and Reminders）</a></li>
</ul>
<p>迁移工作提供了一个重新审视现有 Objective-C 应用程序的机会，并通过 替换部分Swift 代码来更好的优化应用程序的架构，逻辑以及性能。换句话说，所谓增量app迁移，就是让你使用之前的工具-mix and match 来提升相互之间的可操作性。当要选择哪些特性和功能来用 Swift，哪些依然用 Objective-C 实现时，Mix-and-match让这一切变得简单。Swift 和 Objective-C 的互用性又使得将这些功能集成到 Objective-C 变得并不困难。通过这些工具可以开放 Swift 的扩展功能并集成到现有的 Objective-C 项目中而完全不必立刻使用 Swift 重写整个项目。</p>
<p><a name="preparing_your_objective-c_code_for_migration"></a></p>
<h2 id="为你的Objective-C代码做好迁移准备">为你的Objective-C代码做好迁移准备</h2><p>在开始迁移你的代码之前，请确保你的 Objective-C 和 Swift 代码间有着最佳兼容性。这意味着整理并使用 Objective-C 的现代化特性来优化你的现有项目。为了和 Swift 进行更容易的无缝交互，你的现有代码需要遵循现代编码实践。在开始前，有个简短的适配练习列表，参看<a href="https://developer.apple.com/library/prerelease/ios/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html#//apple_ref/doc/uid/TP40014150" target="_blank" rel="external">Adopting Mordern Objective-C</a>。</p>
<p><a name="the_migration_process"></a></p>
<h2 id="迁移过程">迁移过程</h2><p>最有效迁移代码的方式是基于逐个文件，即一次完成一个类。由于你不能在 Objective-C 中继承 Swift类， 最好选择一个没有子类的（译者：从类的继承角度来看，应该先从类族树的叶子节点开始，自底向上的进行迁移操作）。你就可以用单个<code>.swift</code>文件来代替对应的<code>.m</code>和<code>.h</code>文件了。你所有的实现代码和接口将直接放进单个 Swift 文件。你不用再创建头文件了；Xcode 会在你需要引用的时候自动生成头文件。(译者：当然这是在xcode内部机制完成的了，对开发者是透明的)</p>
<h3 id="准备工作">准备工作</h3><ul>
<li>在 Xcode 中:File&gt;New&gt;File&gt;(iOS 或者 OS X) &gt; Other &gt; Swift 为对应的 Objective-C<code>.m</code> 和<code>.h</code>文件创建一个 Swift 类。</li>
<li>导入相关系统框架。</li>
<li>如果你希望在 Swift 文件中访问 Objective-C 代码的话，可以填入一个 Objective-C 桥接头。具体的操作步骤，请看 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_77" target="_blank" rel="external">Importing Code from Within the Same App Target</a>。</li>
<li>为使你的 Swift 类能在 Objective-C 中访问使用，可以继承 Objective-C 类，或者标记上<code>@objc</code>属性。为类指定特殊的名称，以在 Objective-C 中使用，标记上<code>@objc(#name#)</code>, <code>&lt;#name#&gt;</code>就是在 Objective-C 中引用的 Swift 类名。 更多信息，请看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-XID_36" target="_blank" rel="external">Swift Type Compatibility</a>。</li>
</ul>
<h3 id="开始工作">开始工作</h3><ul>
<li>你可以通过继承 Objective-C 类，适配 Objective-C 协议，或者更多的方式，来让 Swift 类集成  Objective-C 行为。更多信息，请看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WritingSwiftClassesWithObjective-CBehavior.html#//apple_ref/doc/uid/TP40014216-CH5-XID_54" target="_blank" rel="external">Writing Swift Classes with Objective-C Behavior</a></li>
<li>当你使用 Objective-C APIs 的时候，你需要知道 Swift 是怎样来翻译某些 Objective-C 特性的。更多信息，请看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-XID_26" target="_blank" rel="external">Interacting with Objective-C APIs</a></li>
<li>当用 Swift 编写用到 Cocoa 框架的代码时，记住某些类型是被桥接的，意味着你可以使用某些 Swift 类型来替代 Objective-C 类型。更多信息，请看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-XID_40" target="_blank" rel="external">Working with Cocoa Data Types</a></li>
<li>当你在 Swift 中运用 Cocoa设计模式得时候，请看 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-XID_5" target="_blank" rel="external">Adopting Cocoa Design Patterns</a>获取更多的通用设计模式的转换信息。</li>
<li>对于打算将项目从 Objective-C 转换到 Swfit 的人，请看 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13" target="_blank" rel="external">Properties</a>。</li>
<li>在必要的时候，请为 Swift 的属性或方法，通过<code>@objc(&lt;#name#&gt;)</code>属性来提供 Objective-C 名称，就像这样：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> enabled: <span class="type">Bool</span> &#123;</span><br><span class="line">	<span class="preprocessor">@objc</span>(isEnabled) <span class="keyword">get</span> &#123;</span><br><span class="line">		<span class="comment">/* ... */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>分别用<code>func</code>和<code>class func</code>来表示 instance(-) 和 class(+) 方法。</li>
<li>声明简单的宏来作为常量，将复杂的宏转换为函数。</li>
</ul>
<h3 id="大功告成">大功告成</h3><ul>
<li>在你的 Objective-C 代码中更新 import 语句为 #import “模块名-Swift.h”，可参阅<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_77" target="_blank" rel="external">Importing Code from Within the Same App Target</a>中曾有提到。</li>
<li>在Target 的成员选择框中去掉勾选框来移除原始的 Objective-C<code>.m</code>文件.不要立刻删除<code>.m</code>和<code>.h</code>文件，以备解决问题用。</li>
<li>如果你给 Swift 类起了一个不同的名字，请使用 Swift 类名代替 Objective-C 名。</li>
</ul>
<p><a name="troubleshooting_tips_and_reminders"></a></p>
<h2 id="问题解决提示">问题解决提示</h2><p>尽管对于不同的项目，迁移的经历是不尽相同的，无论怎样，都有一些通用的步骤和工具能帮你解决代码迁移时碰到的问题：</p>
<ul>
<li>记住：你不能在 Objective-C 中继承 Swift 类。因此，被你迁移的类不能有任何的 Objective-C 子类存在于你的应用中。</li>
<li>当你迁移一个类到 Swift 的时候，你必须从 target 中移除相关的<code>.m</code>文件，以避免编译时提示出现重复的符号等编译错误。</li>
<li>为了在 Objective-C 中可以访问并使用，Swift 类必须是一个 Objective-C 类的子类，或者被标记为<code>@objc</code>。</li>
<li>当你在 Objective-C 中使用 Swift 代码的时候，记住 Objective-C 不能理解那些 Swift 的某些特性，请看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_84" target="_blank" rel="external">Using Swift from Objective-C</a>。</li>
<li>可以通过<code>Commond + 单击</code>一个 Swift 类名来查看它生成的头文件。</li>
<li>可以通过<code>Option + 单击</code>一个符号来查看更详细的信息，比如它的类型，属性以及文档注释等。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>翻译：<a href="https://github.com/xudeheng" target="_blank" rel="external">xudeheng</a></p>
<p>校对：<a href="http://github.com/da]]>
    </summary>
    
      <category term="Using Swift with Cocoa and Objective-C" scheme="http://yoursite.com/tags/Using-Swift-with-Cocoa-and-Objective-C/"/>
    
      <category term="swift-cn" scheme="http://yoursite.com/categories/swift-cn/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[05Revision History-Document Revision History]]></title>
    <link href="http://yoursite.com/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/05Revision%20History/Document%20Revision%20History/"/>
    <id>http://yoursite.com/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/05Revision History/Document Revision History/</id>
    <published>2015-12-26T14:00:03.000Z</published>
    <updated>2015-12-15T06:26:27.773Z</updated>
    <content type="html"><![CDATA[<h1 id="文档修订历史">文档修订历史</h1><p>该表格描述了 Using Swift with Cocoa and Objective-C 一书的改动。</p>
<table class="graybox" border="0" cellspacing="0" cellpadding="5"><br><thead><br>    <tr><br>        <th scope="col" width="100">日期</th><br>       <th scope="col">变更记录</th><br>    </tr><br></thead><br><tbody><br>    <tr><br>    <td scope="row">2015-06-08</td><br>    <td><ul class="list-bullet"><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID35" target="_blank" rel="external"> Interacting with Objective-C APIs </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WritingSwiftClassesWithObjective-CBehavior.html#//apple_ref/doc/uid/TP40014216-CH5-ID152" target="_blank" rel="external"> NSCoding </a>部分。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID61" target="_blank" rel="external"> Working with Cocoa Data Types </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID83" target="_blank" rel="external"> Memory Managed Objects </a>部分。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID61" target="_blank" rel="external"> Working with Cocoa Data Types </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID151" target="_blank" rel="external"> Sets </a>部分。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216-CH2-ID2" target="_blank" rel="external"> Setting Up Your Swift Environment </a>中补充说明有关由命令行建立的可执行文件的 Swift target 系统要求。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID35" target="_blank" rel="external"> Interacting with Objective-C APIs </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID45" target="_blank" rel="external"> Nullability and Optionals </a>部分。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID35" target="_blank" rel="external"> Interacting with Objective-C APIs </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-ID170" target="_blank" rel="external"> Unions </a>部分。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID35" target="_blank" rel="external"> Interacting with Objective-C APIs </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-ID169" target="_blank" rel="external"> Option Sets </a>部分。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-ID6" target="_blank" rel="external"> Adopting Cocoa Design Patterns </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-ID160" target="_blank" rel="external"> API Availability </a>部分。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID35" target="_blank" rel="external"> Interacting with Objective-C APIs </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-ID162" target="_blank" rel="external"> Overriding Swift Names for Objective-C Interfaces </a>部分。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-ID6" target="_blank" rel="external"> Adopting Cocoa Design Patterns </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-ID10" target="_blank" rel="external"> Error Handling </a>部分。<br>        </p></li><br>        <li><p><br>        更新<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-ID122" target="_blank" rel="external"> Swift and Objective-C in the Same Project </a>章节中关于 @testable 注解的信息。<br>        </p></li><br>        <li><p><br>        更新<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-ID148" target="_blank" rel="external"> Function Pointers </a>章节中关于将 Swift 函数和闭包与 C 函数指针桥接的信息。<br>        </p></li><br>        <li><p><br>        更新<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-ID146" target="_blank" rel="external"> Constant Pointers </a>章节中关于将 Swift String 值与 C 指针桥接的信息。<br>        </p></li><br>        <li><p><br>        更新<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID55" target="_blank" rel="external"> Exposing Swift Interfaces in Objective-C </a>章节中关于在 Swift 中使用 @objc 来标注枚举的信息。<br>        </p></li><br>        <li><p><br>        更新<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID69" target="_blank" rel="external"> Collection Classes </a>章节，讨论 Swift 对 Objective-C 集合类的参数化桥接。<br>        </p></li><br>        </ul><br>    </td><br>  </tr><br><br>      <tr><br>    <td scope="row">2015-02-23</td><br>    <td><ul class="list-bullet"><br>        <li><p><br>        更新<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID61" target="_blank" rel="external"> Working with Cocoa Data Types </a>章节，在 Swift 1.2 中使用 as! 操作符和桥接语义。<br>        </p></li><br>        </ul><br>    </td><br>   </tr><br><br>    <tr><br>    <td scope="row">2015-01-18</td><br>    <td><ul class="list-bullet"><br>        <li><p><br>        修复了 UIBezierPath 例子以正确的创建一个三角形<br>        </p></li><br>        </ul><br>    </td><br>   </tr><br><br>    <tr><br>    <td scope="row">2015-01-18</td><br>    <td><ul class="list-bullet"><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID35" target="_blank" rel="external"> Interacting with Objective-C APIs </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID145" target="_blank" rel="external"> Failable Initialization </a>部分。<br><br>        </p></li><br>        </ul><br>    </td><br>   </tr><br><br>       <tr><br>    <td scope="row">2014-09-02</td><br>    <td><ul class="list-bullet"><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WritingSwiftClassesWithObjective-CBehavior.html#//apple_ref/doc/uid/TP40014216-CH5-ID86" target="_blank" rel="external"> Writing Swift Classes with Objective-C Behavior </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WritingSwiftClassesWithObjective-CBehavior.html#//apple_ref/doc/uid/TP40014216-CH5-ID107" target="_blank" rel="external"> Using Swift Class Names with Objective-C APIs </a>部分。<br>        </p></li><br>        <li><p><br>        纠正<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WritingSwiftClassesWithObjective-CBehavior.html#//apple_ref/doc/uid/TP40014216-CH5-ID98" target="_blank" rel="external"> Live Rendering </a>只对编译在框架中的 designable 类生效的陈述。这个限制已经不再存在。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-ID12" target="_blank" rel="external"> Key-Value Observing </a>中添加对 deinit 的实现以及以往代码中对 super 的调用。<br>        </p></li><br>        </ul><br>    </td><br>   </tr><br></tbody><br></table>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="文档修订历史">文档修订历史</h1><p>该表格描述了 Using Swift with Cocoa and Objective-C 一书的改动。</p>
<table class="graybox" border="0" cellspacing="0" cel]]>
    </summary>
    
      <category term="Using Swift with Cocoa and Objective-C" scheme="http://yoursite.com/tags/Using-Swift-with-Cocoa-and-Objective-C/"/>
    
      <category term="swift-cn" scheme="http://yoursite.com/categories/swift-cn/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Summary]]></title>
    <link href="http://yoursite.com/2015/12/26/swift-cn/SUMMARY/"/>
    <id>http://yoursite.com/2015/12/26/swift-cn/SUMMARY/</id>
    <published>2015-12-26T04:00:00.000Z</published>
    <updated>2015-12-15T05:52:12.821Z</updated>
    <content type="html"><![CDATA[<h1 id="Summary">Summary</h1><ul>
<li><a href="/2015/12/25/swift-cn/chapter1/chapter1/">欢迎使用 Swift</a><ul>
<li><a href="/2015/12/25/swift-cn/chapter1/01_swift/">关于 Swift</a></li>
<li><a href="/2015/12/25/swift-cn/chapter1/02_a_swift_tour/">Swift 初见</a></li>
<li><a href="/2015/12/25/swift-cn/chapter1/03_revision_history/">Swift 版本历史记录</a></li>
<li><a href="v1.0/">Swift 1.0 发布内容</a></li>
</ul>
</li>
<li><a href="/2015/12/25/swift-cn/chapter2/chapter2/">Swift 教程</a><ul>
<li><a href="/2015/12/25/swift-cn/chapter2/01_The_Basics/">基础部分</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/02_Basic_Operators/">基本运算符</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/03_Strings_and_Characters/">字符串和字符</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/04_Collection_Types/">集合类型</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/05_Control_Flow/">控制流</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/06_Functions/">函数</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/07_Closures/">闭包</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/08_Enumerations/">枚举</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/09_Classes_and_Structures/">类和结构体</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/10_Properties/">属性</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/11_Methods/">方法</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/12_Subscripts/">下标脚本</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/13_Inheritance/">继承</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/14_Initialization/">构造过程</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/15_Deinitialization/">析构过程</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/16_Automatic_Reference_Counting/">自动引用计数</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/17_Optional_Chaining/">可选链</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/18_Error_Handling/">错误处理</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/19_Type_Casting/">类型转换</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/20_Nested_Types/">嵌套类型</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/21_Extensions/">扩展</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/22_Protocols/">协议</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/23_Generics/">泛型</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/24_Access_Control/">访问控制</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/25_Advanced_Operators/">高级运算符</a></li>
</ul>
</li>
<li>语言参考<ul>
<li><a href="/2015/12/25/swift-cn/chapter3/01_About_the_Language_Reference/">关于语言参考</a></li>
<li><a href="/2015/12/25/swift-cn/chapter3/02_Lexical_Structure/">词法结构</a></li>
<li><a href="/2015/12/25/swift-cn/chapter3/03_Types/">类型</a></li>
<li><a href="/2015/12/25/swift-cn/chapter3/04_Expressions/">表达式</a></li>
<li><a href="/2015/12/25/swift-cn/chapter3/10_Statements/">语句</a></li>
<li><a href="/2015/12/25/swift-cn/chapter3/05_Declarations/">声明</a></li>
<li><a href="/2015/12/25/swift-cn/chapter3/06_Attributes/">特性</a></li>
<li><a href="/2015/12/25/swift-cn/chapter3/07_Patterns/">模式</a></li>
<li><a href="/2015/12/25/swift-cn/chapter3/08_Generic_Parameters_and_Arguments/">泛型参数</a></li>
<li><a href="/2015/12/25/swift-cn/chapter3/09_Summary_of_the_Grammar/">语法总结</a></li>
</ul>
</li>
<li>苹果官方Blog官方翻译<ul>
<li><a href="/2015/12/25/swift-cn/chapter4/01_Access_Control/">Access Control 权限控制的黑与白</a></li>
<li><a href="/2015/12/25/swift-cn/chapter4/02_Type_Custom/">造个类型不是梦-白话Swift类型创建</a></li>
<li><a href="/2015/12/25/swift-cn/chapter4/03_Ballons/">WWDC里面的那个“大炮打气球”</a></li>
<li><a href="/2015/12/25/swift-cn/chapter4/04_Interacting_with_C_Pointers/">Swift与C语言指针友好合作</a></li>
<li><a href="/2015/12/25/swift-cn/chapter4/05_Value_and_Reference_Types/">引用类型和值类型的恩怨</a></li>
<li><a href="/2015/12/25/swift-cn/chapter4/06_Access_Control_and_Protected/">访问控制和Protected</a></li>
<li><a href="/2015/12/25/swift-cn/chapter4/07_Optional_Case_Study/">可选类型完美解决占位问题</a></li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Summary">Summary</h1><ul>
<li><a href="/2015/12/25/swift-cn/chapter1/chapter1/">欢迎使用 Swift</a><ul>
<li><a href="/2015/12/25/swift-cn]]>
    </summary>
    
      <category term="swift-cn/" scheme="http://yoursite.com/tags/swift-cn/"/>
    
      <category term="swift-cn/" scheme="http://yoursite.com/categories/swift-cn/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第一章-01关于 Swift（About Swift）]]></title>
    <link href="http://yoursite.com/2015/12/25/swift-cn/chapter1/01_swift/"/>
    <id>http://yoursite.com/2015/12/25/swift-cn/chapter1/01_swift/</id>
    <published>2015-12-25T15:00:00.000Z</published>
    <updated>2015-12-15T05:41:41.011Z</updated>
    <content type="html"><![CDATA[<h1 id="关于_Swift（About_Swift）">关于 Swift（About Swift）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a><br>校对：<a href="https://github.com/yeahdongcn" target="_blank" rel="external">yeahdongcn</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/xtymichael" target="_blank" rel="external">xtymichael</a></p>
</blockquote>
<p>Swift 是一种新的编程语言，用于编写 iOS，OS X 和 watchOS应用程序。Swift 结合了 C 和 Objective-C 的优点并且不受 C 兼容性的限制。Swift 采用安全的编程模式并添加了很多新特性，这将使编程更简单，更灵活，也更有趣。Swift 是基于成熟而且倍受喜爱的 Cocoa 和 Cocoa Touch 框架，它的降临将重新定义软件开发。</p>
<p>Swift 的开发从很久之前就开始了。为了给 Swift 打好基础，苹果公司改进了编译器，调试器和框架结构。我们使用自动引用计数（Automatic Reference Counting, ARC）来简化内存管理。我们在 Foundation 和 Cocoa 的基础上构建框架栈使其完全现代化和标准化。<br>Objective-C 本身支持块、集合语法和模块，所以框架可以轻松支持现代编程语言技术。正是得益于这些基础工作，我们现在才能发布这样一个用于未来苹果软件开发的新语言。</p>
<p>Objective-C 开发者对 Swift 并不会感到陌生。它采用了 Objective-C 的命名参数以及动态对象模型，可以无缝对接到现有的 Cocoa 框架，并且可以兼容 Objective-C 代码。在此基础之上，Swift 还有许多新特性并且支持过程式编程和面向对象编程。</p>
<p>Swift 对于初学者来说也很友好。它是第一个既满足工业标准又像脚本语言一样充满表现力和趣味的脚本语言。它支持代码预览，这个革命性的特性可以允许程序员在不编译和运行应用程序的前提下运行 Swift 代码并实时查看结果。</p>
<p>Swift 将现代编程语言的精华和苹果工程师文化的智慧结合了起来。编译器对性能进行了优化，编程语言对开发进行了优化，两者互不干扰，鱼与熊掌兼得。Swift 既可以用于开发 “hello, world” 这样的小程序，也可以用于开发一套完整的操作系统。所有的这些特性让 Swift 对于开发者和苹果来说都是一项值得的投资。</p>
<p>Swift 是编写 iOS，OS X 和 watchOS应用的极佳手段，并将伴随着新的特性和功能持续演进。我们对 Swift 充满信心，你还在等什么！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="关于_Swift（About_Swift）">关于 Swift（About Swift）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/numbbbbb" target="_blank]]>
    </summary>
    
      <category term="swift-cn" scheme="http://yoursite.com/tags/swift-cn/"/>
    
      <category term="swift-cn" scheme="http://yoursite.com/categories/swift-cn/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第一章-欢迎使用 Swift]]></title>
    <link href="http://yoursite.com/2015/12/25/swift-cn/chapter1/chapter1/"/>
    <id>http://yoursite.com/2015/12/25/swift-cn/chapter1/chapter1/</id>
    <published>2015-12-25T12:00:00.000Z</published>
    <updated>2015-12-15T05:42:19.651Z</updated>
    <content type="html"><![CDATA[<h1 id="欢迎使用_Swift">欢迎使用 Swift</h1><p>在本章中您将了解 Swift 的特性和开发历史，并对 Swift 有一个初步的了解。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="欢迎使用_Swift">欢迎使用 Swift</h1><p>在本章中您将了解 Swift 的特性和开发历史，并对 Swift 有一个初步的了解。</p>
]]>
    </summary>
    
      <category term="swift-cn" scheme="http://yoursite.com/tags/swift-cn/"/>
    
      <category term="swift-cn" scheme="http://yoursite.com/categories/swift-cn/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第二章-01基础部分（The Basics）]]></title>
    <link href="http://yoursite.com/2015/12/25/swift-cn/chapter2/01_The_Basics/"/>
    <id>http://yoursite.com/2015/12/25/swift-cn/chapter2/01_The_Basics/</id>
    <published>2015-12-25T04:00:26.000Z</published>
    <updated>2015-12-15T05:45:03.913Z</updated>
    <content type="html"><![CDATA[<h1 id="基础部分（The_Basics）">基础部分（The Basics）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>, <a href="https://github.com/lyuka" target="_blank" rel="external">lyuka</a>, <a href="https://github.com/JaySurplus" target="_blank" rel="external">JaySurplus</a><br>校对：<a href="https://github.com/lslxdx" target="_blank" rel="external">lslxdx</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/xtymichael" target="_blank" rel="external">xtymichael</a></p>
<p>2.1<br>翻译：<a href="https://github.com/futantan" target="_blank" rel="external">Prayer</a><br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#constants_and_variables">常量和变量</a></li>
<li><a href="#declaring">声明常量和变量</a></li>
<li><a href="#type_annotations">类型标注</a></li>
<li><a href="#naming">常量和变量的命名</a></li>
<li><a href="#printing">输出常量和变量</a></li>
<li><a href="#comments">注释</a></li>
<li><a href="#semicolons">分号</a></li>
<li><a href="#integers">整数</a></li>
<li><a href="#integer_bounds">整数范围</a></li>
<li><a href="#Int">Int</a></li>
<li><a href="#UInt">UInt</a></li>
<li><a href="#floating-point_numbers">浮点数</a></li>
<li><a href="#type_safety_and_type_inference">类型安全和类型推断</a></li>
<li><a href="#numeric_literals">数值型字面量</a></li>
<li><a href="#numeric_type_conversion">数值型类型转换</a></li>
<li><a href="#integer_conversion">整数转换</a></li>
<li><a href="#integer_and_floating_point_conversion">数整数和浮点数转换</a></li>
<li><a href="#type_aliases">类型别名</a></li>
<li><a href="#booleans">布尔值</a></li>
<li><a href="#tuples">元组</a></li>
<li><a href="#optionals">可选</a></li>
<li><a href="#nil">nil</a></li>
<li><a href="#if">if 语句以及强制解析</a></li>
<li><a href="#optional_binding">可选绑定</a></li>
<li><a href="#implicityly_unwrapped_optionals">隐式解析可选类型</a></li>
<li><a href="#error_handling">错误处理</a></li>
<li><a href="#assertions">断言</a></li>
</ul>
<p>Swift 是一门开发 iOS, OS X 和 watchOS 应用的新语言。然而，如果你有 C 或者 Objective-C 开发经验的话，你会发现 Swift 的很多内容都是你熟悉的。</p>
<p>Swift 包含了 C 和 Objective-C 上所有基础数据类型，<code>Int</code>表示整型值；<code>Double</code>和<code>Float</code>表示浮点型值；<code>Bool</code>是布尔型值；<code>String</code>是文本型数据。Swift 还提供了三个基本的集合类型，<code>Array</code>，<code>Set</code>和<code>Dictionary</code>，详见<a href="04_Collection_Types.html">集合类型</a>。</p>
<p>就像 C 语言一样，Swift 使用变量来进行存储并通过变量名来关联值。在 Swift 中，广泛的使用着值不可变的变量，它们就是常量，而且比 C 语言的常量更强大。在 Swift 中，如果你要处理的值不需要改变，那使用常量可以让你的代码更加安全并且更清晰地表达你的意图。</p>
<p>除了我们熟悉的类型，Swift 还增加了 Objective-C 中没有的高阶数据类型比如元组（Tuple）。元组可以让你创建或者传递一组数据，比如作为函数的返回值时，你可以用一个元组可以返回多个值。</p>
<p>Swift 还增加了可选（Optional）类型，用于处理值缺失的情况。可选表示“那儿有一个值，并且它等于 x ”或者“那儿没有值”。可选有点像在 Objective-C 中使用<code>nil</code>，但是它可以用在任何类型上，不仅仅是类。可选类型比 Objective-C 中的<code>nil</code>指针更加安全也更具表现力，它是 Swift 许多强大特性的重要组成部分。</p>
<p>Swift 是一门类型安全的语言，可选类型就是一个很好的例子。Swift 可以让你清楚地知道值的类型。如果你的代码期望得到一个<code>String</code>，类型安全会阻止你不小心传入一个<code>Int</code>。你可以在开发阶段尽早发现并修正错误。</p>
<p><a name="constants_and_variables"></a></p>
<h2 id="常量和变量">常量和变量</h2><p>常量和变量把一个名字（比如<code>maximumNumberOfLoginAttempts</code>或者<code>welcomeMessage</code>）和一个指定类型的值（比如数字<code>10</code>或者字符串<code>&quot;Hello&quot;</code>）关联起来。常量的值一旦设定就不能改变，而变量的值可以随意更改。</p>
<p><a name="declaring"></a></p>
<h3 id="声明常量和变量">声明常量和变量</h3><p>常量和变量必须在使用前声明，用<code>let</code>来声明常量，用<code>var</code>来声明变量。下面的例子展示了如何用常量和变量来记录用户尝试登录的次数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> maximumNumberOfLoginAttempts = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> currentLoginAttempt = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这两行代码可以被理解为：</p>
<p>“声明一个名字是<code>maximumNumberOfLoginAttempts</code>的新常量，并给它一个值<code>10</code>。然后，声明一个名字是<code>currentLoginAttempt</code>的变量并将它的值初始化为<code>0</code>。”</p>
<p>在这个例子中，允许的最大尝试登录次数被声明为一个常量，因为这个值不会改变。当前尝试登录次数被声明为一个变量，因为每次尝试登录失败的时候都需要增加这个值。</p>
<p>你可以在一行中声明多个常量或者多个变量，用逗号隔开：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span>, z = <span class="number">0.0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>如果你的代码中有不需要改变的值，请使用<code>let</code>关键字将它声明为常量。只将需要改变的值声明为变量。</p>
</blockquote>
<p><a name="type_annotations"></a></p>
<h3 id="类型标注">类型标注</h3><p>当你声明常量或者变量的时候可以加上类型标注（type annotation），说明常量或者变量中要存储的值的类型。如果要添加类型标注，需要在常量或者变量名后面加上一个冒号和空格，然后加上类型名称。</p>
<p>这个例子给<code>welcomeMessage</code>变量添加了类型标注，表示这个变量可以存储<code>String</code>类型的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> welcomeMessage: <span class="type">String</span></span><br></pre></td></tr></table></figure>
<p>声明中的冒号代表着“是…类型”，所以这行代码可以被理解为：</p>
<p>“声明一个类型为<code>String</code>，名字为<code>welcomeMessage</code>的变量。”</p>
<p>“类型为<code>String</code>”的意思是“可以存储任意<code>String</code>类型的值。”</p>
<p><code>welcomeMessage</code>变量现在可以被设置成任意字符串：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">welcomeMessage = <span class="string">"Hello"</span></span><br></pre></td></tr></table></figure>
<p>你可以在一行中定义多个同样类型的变量，用逗号分割，并在最后一个变量名之后添加类型标注：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> red, green, blue: <span class="type">Double</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>一般来说你很少需要写类型标注。如果你在声明常量或者变量的时候赋了一个初始值，Swift可以推断出这个常量或者变量的类型，请参考<a href="#type_safety_and_type_inference">类型安全和类型推断</a>。在上面的例子中，没有给<code>welcomeMessage</code>赋初始值，所以变量<code>welcomeMessage</code>的类型是通过一个类型标注指定的，而不是通过初始值推断的。</p>
</blockquote>
<p><a name="naming"></a></p>
<h3 id="常量和变量的命名">常量和变量的命名</h3><p>你可以用任何你喜欢的字符作为常量和变量名，包括 Unicode 字符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> π = <span class="number">3.14159</span></span><br><span class="line"><span class="keyword">let</span> 你好 = <span class="string">"你好世界"</span></span><br><span class="line"><span class="keyword">let</span> 🐶🐮 = <span class="string">"dogcow"</span></span><br></pre></td></tr></table></figure>
<p>常量与变量名不能包含数学符号，箭头，保留的（或者非法的）Unicode 码位，连线与制表符。也不能以数字开头，但是可以在常量与变量名的其他地方包含数字。</p>
<p>一旦你将常量或者变量声明为确定的类型，你就不能使用相同的名字再次进行声明，或者改变其存储的值的类型。同时，你也不能将常量与变量进行互转。</p>
<blockquote>
<p>注意：<br>如果你需要使用与Swift保留关键字相同的名称作为常量或者变量名，你可以使用反引号（`）将关键字包围的方式将其作为名字使用。无论如何，你应当避免使用关键字作为常量或变量名，除非你别无选择。</p>
</blockquote>
<p>你可以更改现有的变量值为其他同类型的值，在下面的例子中，<code>friendlyWelcome</code>的值从<code>&quot;Hello!&quot;</code>改为了<code>&quot;Bonjour!&quot;</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> friendlyWelcome = <span class="string">"Hello!"</span></span><br><span class="line">friendlyWelcome = <span class="string">"Bonjour!"</span></span><br><span class="line"><span class="comment">// friendlyWelcome 现在是 "Bonjour!"</span></span><br></pre></td></tr></table></figure>
<p>与变量不同，常量的值一旦被确定就不能更改了。尝试这样做会导致编译时报错：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> languageName = <span class="string">"Swift"</span></span><br><span class="line">languageName = <span class="string">"Swift++"</span></span><br><span class="line"><span class="comment">// 这会报编译时错误 - languageName 不可改变</span></span><br></pre></td></tr></table></figure>
<p><a name="printing"></a></p>
<h3 id="输出常量和变量">输出常量和变量</h3><p>你可以用<code>print(_:separator:terminator:)</code>函数来输出当前常量或变量的值:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(friendlyWelcome)</span><br><span class="line"><span class="comment">// 输出 "Bonjour!"</span></span><br></pre></td></tr></table></figure>
<p><code>print(_:separator:terminator:)</code>是一个用来输出一个或多个值到适当输出区的全局函数。如果你用 Xcode，<code>print(_:separator:terminator:)</code>将会输出内容到“console”面板上。<code>separator</code>和<code>terminator</code>参数具有默认值，因此你调用这个函数的时候可以忽略它们。默认情况下，该函数通过添加换行符来结束当前行。如果不想换行，可以传递一个空字符串给<code>terminator</code>参数–例如，<code>print(someValue, terminator:&quot;&quot;)</code>。关于参数默认值的更多信息，请参考<a href="./06_Functions.html#default_parameter_values">默认参数值</a>。</p>
<p>Swift 用字符串插值（string interpolation）的方式把常量名或者变量名当做占位符加入到长字符串中，Swift 会用当前常量或变量的值替换这些占位符。将常量或变量名放入圆括号中，并在开括号前使用反斜杠将其转义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"The current value of friendlyWelcome is <span class="subst">\(friendlyWelcome)</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "The current value of friendlyWelcome is Bonjour!</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>字符串插值所有可用的选项，请参考<a href="./03_Strings_and_Characters.html#string_interpolation">字符串插值</a>。</p>
</blockquote>
<p><a name="comments"></a></p>
<h2 id="注释">注释</h2><p>请将你的代码中的非执行文本注释成提示或者笔记以方便你将来阅读。Swift 的编译器将会在编译代码时自动忽略掉注释部分。</p>
<p>Swift 中的注释与 C 语言的注释非常相似。单行注释以双正斜杠（<code>//</code>）作为起始标记:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个注释</span></span><br></pre></td></tr></table></figure>
<p>你也可以进行多行注释，其起始标记为单个正斜杠后跟随一个星号（<code>/*</code>），终止标记为一个星号后跟随单个正斜杠（<code>*/</code>）:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这是一个,</span><br><span class="line">多行注释 */</span></span><br></pre></td></tr></table></figure>
<p>与 C 语言多行注释不同，Swift 的多行注释可以嵌套在其它的多行注释之中。你可以先生成一个多行注释块，然后在这个注释块之中再嵌套成第二个多行注释。终止注释时先插入第二个注释块的终止标记，然后再插入第一个注释块的终止标记：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这是第一个多行注释的开头</span><br><span class="line"><span class="comment">/* 这是第二个被嵌套的多行注释 */</span></span><br><span class="line">这是第一个多行注释的结尾 */</span></span><br></pre></td></tr></table></figure>
<p>通过运用嵌套多行注释，你可以快速方便的注释掉一大段代码，即使这段代码之中已经含有了多行注释块。</p>
<p><a name="semicolons"></a></p>
<h2 id="分号">分号</h2><p>与其他大部分编程语言不同，Swift 并不强制要求你在每条语句的结尾处使用分号（<code>;</code>），当然，你也可以按照你自己的习惯添加分号。有一种情况下必须要用分号，即你打算在同一行内写多条独立的语句：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cat = <span class="string">"🐱"</span>; <span class="built_in">print</span>(cat)</span><br><span class="line"><span class="comment">// 输出 "🐱"</span></span><br></pre></td></tr></table></figure>
<p><a name="integers"></a></p>
<h2 id="整数">整数</h2><p>整数就是没有小数部分的数字，比如<code>42</code>和<code>-23</code>。整数可以是<code>有符号</code>（正、负、零）或者<code>无符号</code>（正、零）。</p>
<p>Swift 提供了8，16，32和64位的有符号和无符号整数类型。这些整数类型和 C 语言的命名方式很像，比如8位无符号整数类型是<code>UInt8</code>，32位有符号整数类型是<code>Int32</code>。就像 Swift 的其他类型一样，整数类型采用大写命名法。</p>
<p><a name="integer_bounds"></a></p>
<h3 id="整数范围">整数范围</h3><p>你可以访问不同整数类型的<code>min</code>和<code>max</code>属性来获取对应类型的最小值和最大值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> minValue = <span class="type">UInt8</span>.<span class="built_in">min</span>  <span class="comment">// minValue 为 0，是 UInt8 类型</span></span><br><span class="line"><span class="keyword">let</span> maxValue = <span class="type">UInt8</span>.<span class="built_in">max</span>  <span class="comment">// maxValue 为 255，是 UInt8 类型</span></span><br></pre></td></tr></table></figure>
<p><code>min</code>和<code>max</code>所传回值的类型，正是其所对的整数类型(如上例UInt8, 所传回的类型是UInt8)，可用在表达式中相同类型值旁。</p>
<p><a name="Int"></a></p>
<h3 id="Int">Int</h3><p>一般来说，你不需要专门指定整数的长度。Swift 提供了一个特殊的整数类型<code>Int</code>，长度与当前平台的原生字长相同：</p>
<ul>
<li>在32位平台上，<code>Int</code>和<code>Int32</code>长度相同。</li>
<li>在64位平台上，<code>Int</code>和<code>Int64</code>长度相同。</li>
</ul>
<p>除非你需要特定长度的整数，一般来说使用<code>Int</code>就够了。这可以提高代码一致性和可复用性。即使是在32位平台上，<code>Int</code>可以存储的整数范围也可以达到<code>-2,147,483,648</code>~<code>2,147,483,647</code>，大多数时候这已经足够大了。</p>
<p><a name="UInt"></a></p>
<h3 id="UInt">UInt</h3><p>Swift 也提供了一个特殊的无符号类型<code>UInt</code>，长度与当前平台的原生字长相同：</p>
<ul>
<li>在32位平台上，<code>UInt</code>和<code>UInt32</code>长度相同。</li>
<li>在64位平台上，<code>UInt</code>和<code>UInt64</code>长度相同。</li>
</ul>
<blockquote>
<p>注意：<br>尽量不要使用<code>UInt</code>，除非你真的需要存储一个和当前平台原生字长相同的无符号整数。除了这种情况，最好使用<code>Int</code>，即使你要存储的值已知是非负的。统一使用<code>Int</code>可以提高代码的可复用性，避免不同类型数字之间的转换，并且匹配数字的类型推断，请参考<a href="#type_safety_and_type_inference">类型安全和类型推断</a>。</p>
</blockquote>
<p><a name="floating-point_numbers"></a></p>
<h2 id="浮点数">浮点数</h2><p>浮点数是有小数部分的数字，比如<code>3.14159</code>，<code>0.1</code>和<code>-273.15</code>。</p>
<p>浮点类型比整数类型表示的范围更大，可以存储比<code>Int</code>类型更大或者更小的数字。Swift 提供了两种有符号浮点数类型：</p>
<ul>
<li><code>Double</code>表示64位浮点数。当你需要存储很大或者很高精度的浮点数时请使用此类型。</li>
<li><code>Float</code>表示32位浮点数。精度要求不高的话可以使用此类型。</li>
</ul>
<blockquote>
<p>注意：<br><code>Double</code>精确度很高，至少有15位数字，而<code>Float</code>最少只有6位数字。选择哪个类型取决于你的代码需要处理的值的范围。</p>
</blockquote>
<p><a name="type_safety_and_type_inference"></a></p>
<h2 id="类型安全和类型推断">类型安全和类型推断</h2><p>Swift 是一个<em>类型安全（type safe）</em>的语言。类型安全的语言可以让你清楚地知道代码要处理的值的类型。如果你的代码需要一个<code>String</code>，你绝对不可能不小心传进去一个<code>Int</code>。</p>
<p>由于 Swift 是类型安全的，所以它会在编译你的代码时进行<em>类型检查（type checks）</em>，并把不匹配的类型标记为错误。这可以让你在开发的时候尽早发现并修复错误。</p>
<p>当你要处理不同类型的值时，类型检查可以帮你避免错误。然而，这并不是说你每次声明常量和变量的时候都需要显式指定类型。如果你没有显式指定类型，Swift 会使用<em>类型推断（type inference）</em>来选择合适的类型。有了类型推断，编译器可以在编译代码的时候自动推断出表达式的类型。原理很简单，只要检查你赋的值即可。</p>
<p>因为有类型推断，和 C 或者 Objective-C 比起来 Swift 很少需要声明类型。常量和变量虽然需要明确类型，但是大部分工作并不需要你自己来完成。</p>
<p>当你声明常量或者变量并赋初值的时候类型推断非常有用。当你在声明常量或者变量的时候赋给它们一个字面量（literal value 或 literal）即可触发类型推断。（字面量就是会直接出现在你代码中的值，比如<code>42</code>和<code>3.14159</code>。）</p>
<p>例如，如果你给一个新常量赋值<code>42</code>并且没有标明类型，Swift 可以推断出常量类型是<code>Int</code>，因为你给它赋的初始值看起来像一个整数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> meaningOfLife = <span class="number">42</span></span><br><span class="line"><span class="comment">// meaningOfLife 会被推测为 Int 类型</span></span><br></pre></td></tr></table></figure>
<p>同理，如果你没有给浮点字面量标明类型，Swift 会推断你想要的是<code>Double</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pi = <span class="number">3.14159</span></span><br><span class="line"><span class="comment">// pi 会被推测为 Double 类型</span></span><br></pre></td></tr></table></figure>
<p>当推断浮点数的类型时，Swift 总是会选择<code>Double</code>而不是<code>Float</code>。</p>
<p>如果表达式中同时出现了整数和浮点数，会被推断为<code>Double</code>类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherPi = <span class="number">3</span> + <span class="number">0.14159</span></span><br><span class="line"><span class="comment">// anotherPi 会被推测为 Double 类型</span></span><br></pre></td></tr></table></figure>
<p>原始值<code>3</code>没有显式声明类型，而表达式中出现了一个浮点字面量，所以表达式会被推断为<code>Double</code>类型。</p>
<p><a name="numeric_literals"></a></p>
<h2 id="数值型字面量">数值型字面量</h2><p>整数字面量可以被写作：</p>
<ul>
<li>一个<em>十进制</em>数，没有前缀</li>
<li>一个<em>二进制</em>数，前缀是<code>0b</code></li>
<li>一个<em>八进制</em>数，前缀是<code>0o</code></li>
<li>一个<em>十六进制</em>数，前缀是<code>0x</code></li>
</ul>
<p>下面的所有整数字面量的十进制值都是<code>17</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decimalInteger = <span class="number">17</span></span><br><span class="line"><span class="keyword">let</span> binaryInteger = <span class="number">0b10001</span>       <span class="comment">// 二进制的17</span></span><br><span class="line"><span class="keyword">let</span> octalInteger = <span class="number">0o21</span>           <span class="comment">// 八进制的17</span></span><br><span class="line"><span class="keyword">let</span> hexadecimalInteger = <span class="number">0x11</span>     <span class="comment">// 十六进制的17</span></span><br></pre></td></tr></table></figure>
<p>浮点字面量可以是十进制（没有前缀）或者是十六进制（前缀是<code>0x</code>）。小数点两边必须有至少一个十进制数字（或者是十六进制的数字）。浮点字面量还有一个可选的指数（exponent，在十进制浮点数中通过大写或者小写的<code>e</code>来指定，在十六进制浮点数中通过大写或者小写的<code>p</code>来指定。</p>
<p>如果一个十进制数的指数为<code>exp</code>，那这个数相当于基数和10^exp的乘积：</p>
<ul>
<li><code>1.25e2</code> 表示 1.25 × 10^2，等于 <code>125.0</code>。</li>
<li><code>1.25e-2</code> 表示 1.25 × 10^-2，等于 <code>0.0125</code>。</li>
</ul>
<p>如果一个十六进制数的指数为<code>exp</code>，那这个数相当于基数和2^exp的乘积：</p>
<ul>
<li><code>0xFp2</code> 表示 15 × 2^2，等于 <code>60.0</code>。</li>
<li><code>0xFp-2</code> 表示 15 × 2^-2，等于 <code>3.75</code>。</li>
</ul>
<p>下面的这些浮点字面量都等于十进制的<code>12.1875</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decimalDouble = <span class="number">12.1875</span></span><br><span class="line"><span class="keyword">let</span> exponentDouble = <span class="number">1.21875e1</span></span><br><span class="line"><span class="keyword">let</span> hexadecimalDouble = <span class="number">0xC.3p0</span></span><br></pre></td></tr></table></figure>
<p>数值类字面量可以包括额外的格式来增强可读性。整数和浮点数都可以添加额外的零并且包含下划线，并不会影响字面量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> paddedDouble = <span class="number">000123.456</span></span><br><span class="line"><span class="keyword">let</span> oneMillion = <span class="number">1_000_000</span></span><br><span class="line"><span class="keyword">let</span> justOverOneMillion = <span class="number">1_000_000.000_000_1</span></span><br></pre></td></tr></table></figure>
<p><a name="numeric_type_conversion"></a></p>
<h2 id="数值型类型转换">数值型类型转换</h2><p>通常来讲，即使代码中的整数常量和变量已知非负，也请使用<code>Int</code>类型。总是使用默认的整数类型可以保证你的整数常量和变量可以直接被复用并且可以匹配整数类字面量的类型推断。</p>
<p>只有在必要的时候才使用其他整数类型，比如要处理外部的长度明确的数据或者为了优化性能、内存占用等等。使用显式指定长度的类型可以及时发现值溢出并且可以暗示正在处理特殊数据。</p>
<p><a name="integer_conversion"></a></p>
<h3 id="整数转换">整数转换</h3><p>不同整数类型的变量和常量可以存储不同范围的数字。<code>Int8</code>类型的常量或者变量可以存储的数字范围是<code>-128</code>~<code>127</code>，而<code>UInt8</code>类型的常量或者变量能存储的数字范围是<code>0</code>~<code>255</code>。如果数字超出了常量或者变量可存储的范围，编译的时候会报错：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cannotBeNegative: <span class="type">UInt8</span> = -<span class="number">1</span></span><br><span class="line"><span class="comment">// UInt8 类型不能存储负数，所以会报错</span></span><br><span class="line"><span class="keyword">let</span> tooBig: <span class="type">Int8</span> = <span class="type">Int8</span>.<span class="built_in">max</span> + <span class="number">1</span></span><br><span class="line"><span class="comment">// Int8 类型不能存储超过最大值的数，所以会报错</span></span><br></pre></td></tr></table></figure>
<p>由于每种整数类型都可以存储不同范围的值，所以你必须根据不同情况选择性使用数值型类型转换。这种选择性使用的方式，可以预防隐式转换的错误并让你的代码中的类型转换意图变得清晰。</p>
<p>要将一种数字类型转换成另一种，你要用当前值来初始化一个期望类型的新数字，这个数字的类型就是你的目标类型。在下面的例子中，常量<code>twoThousand</code>是<code>UInt16</code>类型，然而常量<code>one</code>是<code>UInt8</code>类型。它们不能直接相加，因为它们类型不同。所以要调用<code>UInt16(one)</code>来创建一个新的<code>UInt16</code>数字并用<code>one</code>的值来初始化，然后使用这个新数字来计算：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> twoThousand: <span class="type">UInt16</span> = <span class="number">2_000</span></span><br><span class="line"><span class="keyword">let</span> one: <span class="type">UInt8</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> twoThousandAndOne = twoThousand + <span class="type">UInt16</span>(one)</span><br></pre></td></tr></table></figure>
<p>现在两个数字的类型都是<code>UInt16</code>，可以进行相加。目标常量<code>twoThousandAndOne</code>的类型被推断为<code>UInt16</code>，因为它是两个<code>UInt16</code>值的和。</p>
<p><code>SomeType(ofInitialValue)</code>是调用 Swift 构造器并传入一个初始值的默认方法。在语言内部，<code>UInt16</code>有一个构造器，可以接受一个<code>UInt8</code>类型的值，所以这个构造器可以用现有的<code>UInt8</code>来创建一个新的<code>UInt16</code>。注意，你并不能传入任意类型的值，只能传入<code>UInt16</code>内部有对应构造器的值。不过你可以扩展现有的类型来让它可以接收其他类型的值（包括自定义类型），请参考<a href="./20_Extensions.html">扩展</a>。</p>
<p><a name="integer_and_floating_point_conversion"></a></p>
<h3 id="整数和浮点数转换">整数和浮点数转换</h3><p>整数和浮点数的转换必须显式指定类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> three = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> pointOneFourOneFiveNine = <span class="number">0.14159</span></span><br><span class="line"><span class="keyword">let</span> pi = <span class="type">Double</span>(three) + pointOneFourOneFiveNine</span><br><span class="line"><span class="comment">// pi 等于 3.14159，所以被推测为 Double 类型</span></span><br></pre></td></tr></table></figure>
<p>这个例子中，常量<code>three</code>的值被用来创建一个<code>Double</code>类型的值，所以加号两边的数类型须相同。如果不进行转换，两者无法相加。</p>
<p>浮点数到整数的反向转换同样行，整数类型可以用<code>Double</code>或者<code>Float</code>类型来初始化：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> integerPi = <span class="type">Int</span>(pi)</span><br><span class="line"><span class="comment">// integerPi 等于 3，所以被推测为 Int 类型</span></span><br></pre></td></tr></table></figure>
<p>当用这种方式来初始化一个新的整数值时，浮点值会被截断。也就是说<code>4.75</code>会变成<code>4</code>，<code>-3.9</code>会变成<code>-3</code>。</p>
<blockquote>
<p>注意：<br>结合数字类常量和变量不同于结合数字类字面量。字面量<code>3</code>可以直接和字面量<code>0.14159</code>相加，因为数字字面量本身没有明确的类型。它们的类型只在编译器需要求值的时候被推测。</p>
</blockquote>
<p><a name="type_aliases"></a></p>
<h2 id="类型别名">类型别名</h2><p>类型别名（type aliases）就是给现有类型定义另一个名字。你可以使用<code>typealias</code>关键字来定义类型别名。</p>
<p>当你想要给现有类型起一个更有意义的名字时，类型别名非常有用。假设你正在处理特定长度的外部资源的数据：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">AudioSample</span> = <span class="type">UInt16</span></span><br></pre></td></tr></table></figure>
<p>定义了一个类型别名之后，你可以在任何使用原始名的地方使用别名：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxAmplitudeFound = <span class="type">AudioSample</span>.<span class="built_in">min</span></span><br><span class="line"><span class="comment">// maxAmplitudeFound 现在是 0</span></span><br></pre></td></tr></table></figure>
<p>本例中，<code>AudioSample</code>被定义为<code>UInt16</code>的一个别名。因为它是别名，<code>AudioSample.min</code>实际上是<code>UInt16.min</code>，所以会给<code>maxAmplitudeFound</code>赋一个初值<code>0</code>。</p>
<p><a name="booleans"></a></p>
<h2 id="布尔值">布尔值</h2><p>Swift 有一个基本的布尔（Boolean）类型，叫做<code>Bool</code>。布尔值指逻辑上的值，因为它们只能是真或者假。Swift 有两个布尔常量，<code>true</code>和<code>false</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> orangesAreOrange = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> turnipsAreDelicious = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p><code>orangesAreOrange</code>和<code>turnipsAreDelicious</code>的类型会被推断为<code>Bool</code>，因为它们的初值是布尔字面量。就像之前提到的<code>Int</code>和<code>Double</code>一样，如果你创建变量的时候给它们赋值<code>true</code>或者<code>false</code>，那你不需要将常量或者变量声明为<code>Bool</code>类型。初始化常量或者变量的时候如果所赋的值类型已知，就可以触发类型推断，这让 Swift 代码更加简洁并且可读性更高。</p>
<p>当你编写条件语句比如<code>if</code>语句的时候，布尔值非常有用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> turnipsAreDelicious &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Mmm, tasty turnips!"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Eww, turnips are horrible."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "Eww, turnips are horrible."</span></span><br></pre></td></tr></table></figure>
<p>条件语句，例如<code>if</code>，请参考<a href="./05_Control_Flow.html">控制流</a>。</p>
<p>如果你在需要使用<code>Bool</code>类型的地方使用了非布尔值，Swift 的类型安全机制会报错。下面的例子会报告一个编译时错误：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> i &#123;</span><br><span class="line">    <span class="comment">// 这个例子不会通过编译，会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，下面的例子是合法的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> i == <span class="number">1</span> &#123;</span><br><span class="line">    <span class="comment">// 这个例子会编译成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>i == 1</code>的比较结果是<code>Bool</code>类型，所以第二个例子可以通过类型检查。类似<code>i == 1</code>这样的比较，请参考<a href="./05_Control_Flow.html">基本操作符</a>。</p>
<p>和 Swift 中的其他类型安全的例子一样，这个方法可以避免错误并保证这块代码的意图总是清晰的。</p>
<p><a name="tuples"></a></p>
<h2 id="元组">元组</h2><p><em>元组（tuples）</em>把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。</p>
<p>下面这个例子中，<code>(404, &quot;Not Found&quot;)</code>是一个描述 <em>HTTP 状态码（HTTP status code）</em>的元组。HTTP 状态码是当你请求网页的时候 web 服务器返回的一个特殊值。如果你请求的网页不存在就会返回一个<code>404 Not Found</code>状态码。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> http404Error = (<span class="number">404</span>, <span class="string">"Not Found"</span>)</span><br><span class="line"><span class="comment">// http404Error 的类型是 (Int, String)，值是 (404, "Not Found")</span></span><br></pre></td></tr></table></figure>
<p><code>(404, &quot;Not Found&quot;)</code>元组把一个<code>Int</code>值和一个<code>String</code>值组合起来表示 HTTP 状态码的两个部分：一个数字和一个人类可读的描述。这个元组可以被描述为“一个类型为<code>(Int, String)</code>的元组”。</p>
<p>你可以把任意顺序的类型组合成一个元组，这个元组可以包含所有类型。只要你想，你可以创建一个类型为<code>(Int, Int, Int)</code>或者<code>(String, Bool)</code>或者其他任何你想要的组合的元组。</p>
<p>你可以将一个元组的内容分解（decompose）成单独的常量和变量，然后你就可以正常使用它们了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (statusCode, statusMessage) = http404Error</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The status code is <span class="subst">\(statusCode)</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "The status code is 404"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The status message is <span class="subst">\(statusMessage)</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "The status message is Not Found"</span></span><br></pre></td></tr></table></figure>
<p>如果你只需要一部分元组值，分解的时候可以把要忽略的部分用下划线（<code>_</code>）标记：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (justTheStatusCode, <span class="number">_</span>) = http404Error</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The status code is <span class="subst">\(justTheStatusCode)</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "The status code is 404"</span></span><br></pre></td></tr></table></figure>
<p>此外，你还可以通过下标来访问元组中的单个元素，下标从零开始：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"The status code is <span class="subst">\(http404Error.<span class="number">0</span>)</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "The status code is 404"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The status message is <span class="subst">\(http404Error.<span class="number">1</span>)</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "The status message is Not Found"</span></span><br></pre></td></tr></table></figure>
<p>你可以在定义元组的时候给单个元素命名：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> http200Status = (statusCode: <span class="number">200</span>, description: <span class="string">"OK"</span>)</span><br></pre></td></tr></table></figure>
<p>给元组中的元素命名后，你可以通过名字来获取这些元素的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"The status code is <span class="subst">\(http200Status.statusCode)</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "The status code is 200"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The status message is <span class="subst">\(http200Status.description)</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "The status message is OK"</span></span><br></pre></td></tr></table></figure>
<p>作为函数返回值时，元组非常有用。一个用来获取网页的函数可能会返回一个<code>(Int, String)</code>元组来描述是否获取成功。和只能返回一个类型的值比较起来，一个包含两个不同类型值的元组可以让函数的返回信息更有用。请参考<a href="./06_Functions.html#Function_Parameters_and_Return_Values">函数参数与返回值</a>。</p>
<blockquote>
<p>注意：<br>元组在临时组织值的时候很有用，但是并不适合创建复杂的数据结构。如果你的数据结构并不是临时使用，请使用类或者结构体而不是元组。请参考<a href="./09_Classes_and_Structures.html">类和结构体</a>。</p>
</blockquote>
<p><a name="optionals"></a></p>
<h2 id="可选类型">可选类型</h2><p>使用<em>可选类型（optionals）</em>来处理值可能缺失的情况。可选类型表示：</p>
<ul>
<li>有值，等于 x</li>
</ul>
<p>或者</p>
<ul>
<li>没有值</li>
</ul>
<blockquote>
<p>注意：<br>C 和 Objective-C 中并没有可选类型这个概念。最接近的是 Objective-C 中的一个特性，一个方法要不返回一个对象要不返回<code>nil</code>，<code>nil</code>表示“缺少一个合法的对象”。然而，这只对对象起作用——对于结构体，基本的 C 类型或者枚举类型不起作用。对于这些类型，Objective-C 方法一般会返回一个特殊值（比如<code>NSNotFound</code>）来暗示值缺失。这种方法假设方法的调用者知道并记得对特殊值进行判断。然而，Swift 的可选类型可以让你暗示<em>任意类型</em>的值缺失，并不需要一个特殊值。</p>
</blockquote>
<p>来看一个例子。Swift 的<code>String</code>类型有一种构造器，作用是将一个<code>String</code>值转换成一个<code>Int</code>值。然而，并不是所有的字符串都可以转换成一个整数。字符串<code>&quot;123&quot;</code>可以被转换成数字<code>123</code>，但是字符串<code>&quot;hello, world&quot;</code>不行。</p>
<p>下面的例子使用这种构造器来尝试将一个<code>String</code>转换成<code>Int</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> possibleNumber = <span class="string">"123"</span></span><br><span class="line"><span class="keyword">let</span> convertedNumber = <span class="type">Int</span>(possibleNumber)</span><br><span class="line"><span class="comment">// convertedNumber 被推测为类型 "Int?"， 或者类型 "optional Int"</span></span><br></pre></td></tr></table></figure>
<p>因为该构造器可能会失败，所以它返回一个<em>可选类型</em>（optional）<code>Int</code>，而不是一个<code>Int</code>。一个可选的<code>Int</code>被写作<code>Int?</code>而不是<code>Int</code>。问号暗示包含的值是可选类型，也就是说可能包含<code>Int</code>值也可能<em>不包含值</em>。（不能包含其他任何值比如<code>Bool</code>值或者<code>String</code>值。只能是<code>Int</code>或者什么都没有。）</p>
<p><a name="nil"></a></p>
<h3 id="nil">nil</h3><p>你可以给可选变量赋值为<code>nil</code>来表示它没有值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serverResponseCode: <span class="type">Int</span>? = <span class="number">404</span></span><br><span class="line"><span class="comment">// serverResponseCode 包含一个可选的 Int 值 404</span></span><br><span class="line">serverResponseCode = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// serverResponseCode 现在不包含值</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br><code>nil</code>不能用于非可选的常量和变量。如果你的代码中有常量或者变量需要处理值缺失的情况，请把它们声明成对应的可选类型。</p>
</blockquote>
<p>如果你声明一个可选常量或者变量但是没有赋值，它们会自动被设置为<code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> surveyAnswer: <span class="type">String</span>?</span><br><span class="line"><span class="comment">// surveyAnswer 被自动设置为 nil</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>Swift 的<code>nil</code>和 Objective-C 中的<code>nil</code>并不一样。在 Objective-C 中，<code>nil</code>是一个指向不存在对象的指针。在 Swift 中，<code>nil</code>不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设置为<code>nil</code>，不只是对象类型。</p>
</blockquote>
<p><a name="if"></a></p>
<h3 id="if_语句以及强制解析">if 语句以及强制解析</h3><p>你可以使用<code>if</code>语句和<code>nil</code>比较来判断一个可选值是否包含值。你可以使用“相等”(<code>==</code>)或“不等”(<code>!=</code>)来执行比较。</p>
<p>如果可选类型有值，它将不等于<code>nil</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> convertedNumber != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"convertedNumber contains some integer value."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "convertedNumber contains some integer value."</span></span><br></pre></td></tr></table></figure>
<p>当你确定可选类型确实包含值之后，你可以在可选的名字后面加一个感叹号（<code>!</code>）来获取值。这个惊叹号表示“我知道这个可选有值，请使用它。”这被称为可选值的<em>强制解析（forced unwrapping）</em>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> convertedNumber != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"convertedNumber has an integer value of <span class="subst">\(convertedNumber!)</span>."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "convertedNumber has an integer value of 123."</span></span><br></pre></td></tr></table></figure>
<p>更多关于<code>if</code>语句的内容，请参考<a href="05_Control_Flow.html">控制流</a>。</p>
<blockquote>
<p>注意：<br>使用<code>!</code>来获取一个不存在的可选值会导致运行时错误。使用<code>!</code>来强制解析值之前，一定要确定可选包含一个非<code>nil</code>的值。</p>
</blockquote>
<p><a name="optional_binding"></a></p>
<h3 id="可选绑定">可选绑定</h3><p>使用<em>可选绑定（optional binding）</em>来判断可选类型是否包含值，如果包含就把值赋给一个临时常量或者变量。可选绑定可以用在<code>if</code>和<code>while</code>语句中，这条语句不仅可以用来判断可选类型中是否有值，同时可以将可选类型中的值赋给一个常量或者变量。<code>if</code>和<code>while</code>语句，请参考<a href="./05_Control_Flow.html">控制流</a>。</p>
<p>像下面这样在<code>if</code>语句中写一个可选绑定：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> constantName = someOptional &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以像上面这样使用可选绑定来重写<code>possibleNumber</code>这个<a href="./01_The_Basics.html#optionals">例子</a>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> actualNumber = <span class="type">Int</span>(possibleNumber) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\'<span class="subst">\(possibleNumber)</span>\' has an integer value of <span class="subst">\(actualNumber)</span>"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\'<span class="subst">\(possibleNumber)</span>\' could not be converted to an integer"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "'123' has an integer value of 123"</span></span><br></pre></td></tr></table></figure>
<p>这段代码可以被理解为：</p>
<p>“如果<code>Int(possibleNumber)</code>返回的可选<code>Int</code>包含一个值，创建一个叫做<code>actualNumber</code>的新常量并将可选包含的值赋给它。”</p>
<p>如果转换成功，<code>actualNumber</code>常量可以在<code>if</code>语句的第一个分支中使用。它已经被可选类型<em>包含的</em>值初始化过，所以不需要再使用<code>!</code>后缀来获取它的值。在这个例子中，<code>actualNumber</code>只被用来输出转换结果。</p>
<p>你可以在可选绑定中使用常量和变量。如果你想在<code>if</code>语句的第一个分支中操作<code>actualNumber</code>的值，你可以改成<code>if var actualNumber</code>，这样可选类型包含的值就会被赋给一个变量而非常量。</p>
<p>你可以包含多个可选绑定在<code>if</code>语句中，并使用<code>where</code>子句做布尔值判断。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstNumber = <span class="type">Int</span>(<span class="string">"4"</span>), secondNumber = <span class="type">Int</span>(<span class="string">"42"</span>) <span class="keyword">where</span> firstNumber &lt; secondNumber &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(firstNumber)</span> &lt; <span class="subst">\(secondNumber)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// prints "4 &lt; 42"</span></span><br></pre></td></tr></table></figure>
<p><a name="implicityly_unwrapped_optionals"></a></p>
<h3 id="隐式解析可选类型">隐式解析可选类型</h3><p>如上所述，可选类型暗示了常量或者变量可以“没有值”。可选可以通过<code>if</code>语句来判断是否有值，如果有值的话可以通过可选绑定来解析值。</p>
<p>有时候在程序架构中，第一次被赋值之后，可以确定一个可选类型<em>总会</em>有值。在这种情况下，每次都要判断和解析可选值是非常低效的，因为可以确定它总会有值。</p>
<p>这种类型的可选状态被定义为隐式解析可选类型（implicitly unwrapped optionals）。把想要用作可选的类型的后面的问号（<code>String?</code>）改成感叹号（<code>String!</code>）来声明一个隐式解析可选类型。</p>
<p>当可选类型被第一次赋值之后就可以确定之后一直有值的时候，隐式解析可选类型非常有用。隐式解析可选类型主要被用在 Swift 中类的构造过程中，请参考<a href="./16_Automatic_Reference_Counting.html#unowned_references_and_implicitly_unwrapped_optional_properties">无主引用以及隐式解析可选属性</a>。</p>
<p>一个隐式解析可选类型其实就是一个普通的可选类型，但是可以被当做非可选类型来使用，并不需要每次都使用解析来获取可选值。下面的例子展示了可选类型<code>String</code>和隐式解析可选类型<code>String</code>之间的区别：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> possibleString: <span class="type">String</span>? = <span class="string">"An optional string."</span></span><br><span class="line"><span class="keyword">let</span> forcedString: <span class="type">String</span> = possibleString! <span class="comment">// 需要惊叹号来获取值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> assumedString: <span class="type">String</span>! = <span class="string">"An implicitly unwrapped optional string."</span></span><br><span class="line"><span class="keyword">let</span> implicitString: <span class="type">String</span> = assumedString  <span class="comment">// 不需要感叹号</span></span><br></pre></td></tr></table></figure>
<p>你可以把隐式解析可选类型当做一个可以自动解析的可选类型。你要做的只是声明的时候把感叹号放到类型的结尾，而不是每次取值的可选名字的结尾。</p>
<blockquote>
<p>注意：<br>如果你在隐式解析可选类型没有值的时候尝试取值，会触发运行时错误。和你在没有值的普通可选类型后面加一个惊叹号一样。</p>
</blockquote>
<p>你仍然可以把隐式解析可选类型当做普通可选类型来判断它是否包含值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> assumedString != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(assumedString)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "An implicitly unwrapped optional string."</span></span><br></pre></td></tr></table></figure>
<p>你也可以在可选绑定中使用隐式解析可选类型来检查并解析它的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> definiteString = assumedString &#123;</span><br><span class="line">    <span class="built_in">print</span>(definiteString)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "An implicitly unwrapped optional string."</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>如果一个变量之后可能变成<code>nil</code>的话请不要使用隐式解析可选类型。如果你需要在变量的生命周期中判断是否是<code>nil</code>的话，请使用普通可选类型。</p>
</blockquote>
<p><a name="error_handling"></a></p>
<h2 id="错误处理">错误处理</h2><p>你可以使用<em>错误处理（error handling）</em>来应对程序执行中可能会遇到的错误条件。</p>
<p>相对于可选中运用值的存在与缺失来表达函数的成功与失败，错误处理可以推断失败的原因，并传播至程序的其他部分。</p>
<p>当一个函数遇到错误条件，它能报错。调用函数的地方能抛出错误消息并合理处理。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">canThrowAnError</span><span class="params">()</span></span> throws &#123;</span><br><span class="line">    <span class="comment">// 这个函数有可能抛出错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个函数可以通过在声明中添加<code>throws</code>关键词来抛出错误消息。当你的函数能抛出错误消息时, 你应该在表达式中前置<code>try</code>关键词。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    try canThrowAnError()</span><br><span class="line">    <span class="comment">// 没有错误消息抛出</span></span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    <span class="comment">// 有一个错误消息抛出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个<code>do</code>语句创建了一个新的包含作用域,使得错误能被传播到一个或多个<code>catch</code>从句。</p>
<p>这里有一个错误处理如何用来应对不同错误条件的例子。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">makeASandwich</span><span class="params">()</span></span> throws &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    try makeASandwich()</span><br><span class="line">    eatASandwich()</span><br><span class="line">&#125; catch <span class="type">Error</span>.<span class="type">OutOfCleanDishes</span> &#123;</span><br><span class="line">    washDishes()</span><br><span class="line">&#125; catch <span class="type">Error</span>.<span class="type">MissingIngredients</span>(<span class="keyword">let</span> ingredients) &#123;</span><br><span class="line">    buyGroceries(ingredients)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此例中，<code>makeASandwich()</code>（做一个三明治）函数会抛出一个错误消息如果没有干净的盘子或者某个原料缺失。因为<code>makeASandwich()</code>抛出错误，函数调用被包裹在<code>try</code>表达式中。将函数包裹在一个<code>do</code>语句中,任何被抛出的错误会被传播到提供的<code>catch</code>从句中。</p>
<p>如果没有错误被抛出, <code>eatASandwich()</code>函数会被调用。如果一个匹配<code>Error.OutOfCleanDishes</code>的错误被抛出,<code>washDishes</code>函数会被调用。如果一个匹配<code>Error.MissingIngredients</code>的错误被抛出，<code>buyGroceries(_:)</code>函数会随着被<code>catch</code>所捕捉到的关联值<code>[String]</code>被调用。</p>
<p>抛出，捕捉，以及传播错误会在<a href="./18_Error_Handling.html">错误处理</a>章节详细说明。</p>
<p><a name="assertions"></a></p>
<h2 id="断言">断言</h2><p>可选类型可以让你判断值是否存在，你可以在代码中优雅地处理值缺失的情况。然而，在某些情况下，如果值缺失或者值并不满足特定的条件，你的代码可能没办法继续执行。这时，你可以在你的代码中触发一个<em>断言（assertion）</em>来结束代码运行并通过调试来找到值缺失的原因。</p>
<h3 id="使用断言进行调试">使用断言进行调试</h3><p>断言会在运行时判断一个逻辑条件是否为<code>true</code>。从字面意思来说，断言“断言”一个条件是否为真。你可以使用断言来保证在运行其他代码之前，某些重要的条件已经被满足。如果条件判断为<code>true</code>，代码运行会继续进行；如果条件判断为<code>false</code>，代码执行结束，你的应用被终止。</p>
<p>如果你的代码在调试环境下触发了一个断言，比如你在 Xcode 中构建并运行一个应用，你可以清楚地看到不合法的状态发生在哪里并检查断言被触发时你的应用的状态。此外，断言允许你附加一条调试信息。</p>
<p>你可以使用全局<code>assert(_:_file:line:)</code>函数来写一个断言。向这个函数传入一个结果为<code>true</code>或者<code>false</code>的表达式以及一条信息，当表达式的结果为<code>false</code>的时候这条信息会被显示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = -<span class="number">3</span></span><br><span class="line"><span class="built_in">assert</span>(age &gt;= <span class="number">0</span>, <span class="string">"A person's age cannot be less than zero"</span>)</span><br><span class="line"><span class="comment">// 因为 age &lt; 0，所以断言会触发</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，只有<code>age &gt;= 0</code>为<code>true</code>的时候，即<code>age</code>的值非负的时候，代码才会继续执行。如果<code>age</code>的值是负数，就像代码中那样，<code>age &gt;= 0</code>为<code>false</code>，断言被触发，终止应用。</p>
<p>如果不需要断言信息，可以省略，就像这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span>(age &gt;= <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>当代码使用优化编译的时候，断言将会被禁用，例如在 Xcode 中，使用默认的 target Release 配置选项来 build 时，断言会被禁用。</p>
</blockquote>
<h3 id="何时使用断言">何时使用断言</h3><p>当条件可能为假时使用断言，但是最终一定要<em>保证</em>条件为真，这样你的代码才能继续运行。断言的适用情景：</p>
<ul>
<li>整数类型的下标索引被传入一个自定义下标脚本实现，但是下标索引值可能太小或者太大。</li>
<li>需要给函数传入一个值，但是非法的值可能导致函数不能正常执行。</li>
<li>一个可选值现在是<code>nil</code>，但是后面的代码运行需要一个非<code>nil</code>值。</li>
</ul>
<p>请参考<a href="./12_Subscripts.html">下标脚本</a>和<a href="./06_Functions.html">函数</a>。</p>
<blockquote>
<p>注意：<br>断言可能导致你的应用终止运行，所以你应当仔细设计你的代码来让非法条件不会出现。然而，在你的应用发布之前，有时候非法条件可能出现，这时使用断言可以快速发现问题。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="基础部分（The_Basics）">基础部分（The Basics）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/numbbbbb" target="_blank" rel="ext]]>
    </summary>
    
      <category term="swift-cn" scheme="http://yoursite.com/tags/swift-cn/"/>
    
      <category term="swift-cn" scheme="http://yoursite.com/categories/swift-cn/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第二章-02基本运算符（Basic Operators）]]></title>
    <link href="http://yoursite.com/2015/12/25/swift-cn/chapter2/02_Basic_Operators/"/>
    <id>http://yoursite.com/2015/12/25/swift-cn/chapter2/02_Basic_Operators/</id>
    <published>2015-12-25T04:00:25.000Z</published>
    <updated>2015-12-15T05:44:55.701Z</updated>
    <content type="html"><![CDATA[<h1 id="基本运算符（Basic_Operators）">基本运算符（Basic Operators）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/xielingwang" target="_blank" rel="external">XieLingWang</a><br>校对：<a href="https://github.com/Evilcome" target="_blank" rel="external">EvilCome</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/AlanMelody" target="_blank" rel="external">JackAlan</a></p>
<p>2.1<br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#terminology">术语</a></li>
<li><a href="#assignment_operator">赋值运算符</a></li>
<li><a href="#arithmetic_operators">算术运算符</a></li>
<li><a href="#compound_assignment_operators">组合赋值运算符（Compound Assignment Operators）</a></li>
<li><a href="#comparison_operators">比较运算符</a></li>
<li><a href="#ternary_conditional_operator">三目运算符（Ternary Conditional Operator）</a></li>
<li><a href="#nil_coalescing_operator">空合运算符</a></li>
<li><a href="#range_operators">区间运算符</a></li>
<li><a href="#logical_operators">逻辑运算符</a></li>
</ul>
<p>运算符是检查、改变、合并值的特殊符号或短语。例如，加号<code>+</code>将两个数相加（如<code>let i = 1 + 2</code>）。更复杂的运算例子包括逻辑与运算符<code>&amp;&amp;</code>（如<code>if enteredDoorCode &amp;&amp; passedRetinaScan</code>），或让 i 值加1的便捷自增运算符<code>++i</code>等。</p>
<p>Swift 支持大部分标准 C 语言的运算符，且改进许多特性来减少常规编码错误。如：赋值符（<code>=</code>）不返回值，以防止把想要判断相等运算符（<code>==</code>）的地方写成赋值符导致的错误。算术运算符（<code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>%</code>等）会检测并不允许值溢出，以此来避免保存变量时由于变量大于或小于其类型所能承载的范围时导致的异常结果。当然允许你使用 Swift 的溢出运算符来实现溢出。详情参见<a href="../chapter2/25_Advanced_Operators.html#overflow_operators">溢出运算符</a>。</p>
<p>区别于 C 语言，在 Swift 中你可以对浮点数进行取余运算（<code>%</code>），Swift 还提供了 C 语言没有的表达两数之间的值的区间运算符（<code>a..&lt;b</code>和<code>a...b</code>），这方便我们表达一个区间内的数值。</p>
<p>本章节只描述了 Swift 中的基本运算符，<a href="../chapter2/25_Advanced_Operators.html">高级运算符</a>包含了高级运算符，及如何自定义运算符，及如何进行自定义类型的运算符重载。</p>
<p><a name="terminology"></a></p>
<h2 id="术语">术语</h2><p>运算符有一元、二元和三元运算符。</p>
<ul>
<li>一元运算符对单一操作对象操作（如<code>-a</code>）。一元运算符分前置运算符和后置运算符，前置运算符需紧跟在操作对象之前（如<code>!b</code>），后置运算符需紧跟在操作对象之后（如<code>i++</code>）。</li>
<li>二元运算符操作两个操作对象（如<code>2 + 3</code>），是中置的，因为它们出现在两个操作对象之间。</li>
<li>三元运算符操作三个操作对象，和 C 语言一样，Swift 只有一个三元运算符，就是三目运算符（<code>a ? b : c</code>）。</li>
</ul>
<p>受运算符影响的值叫操作数，在表达式<code>1 + 2</code>中，加号<code>+</code>是二元运算符，它的两个操作数是值<code>1</code>和<code>2</code>。</p>
<p><a name="assignment_operator"></a></p>
<h2 id="赋值运算符">赋值运算符</h2><p>赋值运算（<code>a = b</code>），表示用<code>b</code>的值来初始化或更新<code>a</code>的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">5</span></span><br><span class="line">a = b</span><br><span class="line"><span class="comment">// a 现在等于 10</span></span><br></pre></td></tr></table></figure>
<p>如果赋值的右边是一个多元组，它的元素可以马上被分解成多个常量或变量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (x, y) = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 现在 x 等于 1, y 等于 2</span></span><br></pre></td></tr></table></figure>
<p>与 C 语言和 Objective-C 不同，Swift 的赋值操作并不返回任何值。所以以下代码是错误的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x = y &#123;</span><br><span class="line">	<span class="comment">// 此句错误, 因为 x = y 并不返回任何值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个特性使你无法把（<code>==</code>）错写成（<code>=</code>），由于<code>if x = y</code>是错误代码，Swift帮你避免此类错误的的发生。</p>
<p><a name="arithmetic_operators"></a></p>
<h2 id="算术运算符">算术运算符</h2><p>Swift 中所有数值类型都支持了基本的四则算术运算：</p>
<ul>
<li>加法（<code>+</code>）</li>
<li>减法（<code>-</code>）</li>
<li>乘法（<code>*</code>）</li>
<li>除法（<code>/</code>）</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">2</span>       <span class="comment">// 等于 3</span></span><br><span class="line"><span class="number">5</span> - <span class="number">3</span>       <span class="comment">// 等于 2</span></span><br><span class="line"><span class="number">2</span> * <span class="number">3</span>       <span class="comment">// 等于 6</span></span><br><span class="line"><span class="number">10.0</span> / <span class="number">2.5</span>  <span class="comment">// 等于 4.0</span></span><br></pre></td></tr></table></figure>
<p>与 C 语言和 Objective-C 不同的是，Swift 默认情况下不允许在数值运算中出现溢出情况。但是你可以使用 Swift 的溢出运算符来实现溢出运算（如<code>a &amp;+ b</code>）。详情参见<a href="../chapter2/25_Advanced_Operators.html#overflow_operators">溢出运算符</a>。</p>
<p>加法运算符也可用于<code>String</code>的拼接：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"hello, "</span> + <span class="string">"world"</span>  <span class="comment">// 等于 "hello, world"</span></span><br></pre></td></tr></table></figure>
<h3 id="求余运算符">求余运算符</h3><p>求余运算（<code>a % b</code>）是计算<code>b</code>的多少倍刚刚好可以容入<code>a</code>，返回多出来的那部分（余数）。</p>
<blockquote>
<p>注意：<br>求余运算（<code>%</code>）在其他语言也叫取模运算。然而严格说来，我们看该运算符对负数的操作结果，”求余”比”取模”更合适些。</p>
</blockquote>
<p>我们来谈谈取余是怎么回事，计算<code>9 % 4</code>，你先计算出<code>4</code>的多少倍会刚好可以容入<code>9</code>中：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/remainderInteger_2x.png" alt="Art/remainderInteger_2x.png" title="Art/remainderInteger_2x.png"></p>
<p>2倍，非常好，那余数是1（用橙色标出）</p>
<p>在 Swift 中可以表达为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span> % <span class="number">4</span>    <span class="comment">// 等于 1</span></span><br></pre></td></tr></table></figure>
<p>为了得到<code>a % b</code>的结果，<code>%</code>计算了以下等式，并输出<code>余数</code>作为结果：</p>
<pre><code><span class="tag">a</span> = (<span class="tag">b</span> × 倍数) + 余数
</code></pre><p>当<code>倍数</code>取最大值的时候，就会刚好可以容入<code>a</code>中。</p>
<p>把<code>9</code>和<code>4</code>代入等式中，我们得<code>1</code>：</p>
<pre><code><span class="number">9</span> = (<span class="number">4</span> × <span class="number">2</span>) + <span class="number">1</span>
</code></pre><p>同样的方法，我们来计算 <code>-9 % 4</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">9</span> % <span class="number">4</span>   <span class="comment">// 等于 -1</span></span><br></pre></td></tr></table></figure>
<p>把<code>-9</code>和<code>4</code>代入等式，<code>-2</code>是取到的最大整数：</p>
<pre><code>-<span class="number">9</span> = (<span class="number">4</span> × -<span class="number">2</span>) + -<span class="number">1</span>
</code></pre><p>余数是<code>-1</code>。</p>
<p>在对负数<code>b</code>求余时，<code>b</code>的符号会被忽略。这意味着 <code>a % b</code> 和 <code>a % -b</code>的结果是相同的。</p>
<h3 id="浮点数求余计算">浮点数求余计算</h3><p>不同于 C 语言和 Objective-C，Swift 中是可以对浮点数进行求余的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span> % <span class="number">2.5</span>   <span class="comment">// 等于 0.5</span></span><br></pre></td></tr></table></figure>
<p>这个例子中，<code>8</code>除于<code>2.5</code>等于<code>3</code>余<code>0.5</code>，所以结果是一个<code>Double</code>值<code>0.5</code>。</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/remainderFloat_2x.png" alt="Art/remainderFloat_2x.png" title="Art/remainderFloat_2x.png"></p>
<h3 id="自增和自减运算">自增和自减运算</h3><p>和 C 语言一样，Swift 也提供了对变量本身加1或减1的自增（<code>++</code>）和自减（<code>--</code>）的缩略算符。其操作对象可以是整形和浮点型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">++i      <span class="comment">// 现在 i = 1</span></span><br></pre></td></tr></table></figure>
<p>每调用一次<code>++i</code>，<code>i</code>的值就会加1。实际上，<code>++i</code>是<code>i = i + 1</code>的简写，而<code>--i</code>是<code>i = i - 1</code>的简写。</p>
<p><code>++</code>和<code>--</code>既可以用作前置运算又可以用作后置运算。<code>++i</code>，<code>i++</code>，<code>--i</code>和<code>i--</code>都是有效的写法。</p>
<p>我们需要注意的是这些运算符即可修改了<code>i</code>的值也可以返回<code>i</code>的值。如果你只想修改<code>i</code>的值，那你就可以忽略这个返回值。但如果你想使用返回值，你就需要留意前置和后置操作的返回值是不同的，她们遵循以下原则：</p>
<ul>
<li>当<code>++</code>前置的时候，先自増再返回。</li>
<li>当<code>++</code>后置的时候，先返回再自增。</li>
</ul>
<p>例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> b = ++a <span class="comment">// a 和 b 现在都是 1</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = a++ <span class="comment">// a 现在 2, 但 c 是 a 自增前的值 1</span></span><br></pre></td></tr></table></figure>
<p>上述例子，<code>let b = ++a</code>先把<code>a</code>加1了再返回<code>a</code>的值。所以<code>a</code>和<code>b</code>都是新值<code>1</code>。</p>
<p>而<code>let c = a++</code>，是先返回了<code>a</code>的值，然后<code>a</code>才加1。所以<code>c</code>得到了<code>a</code>的旧值1，而<code>a</code>加1后变成2。</p>
<p>除非你需要使用<code>i++</code>的特性，不然推荐你使用<code>++i</code>和<code>--i</code>，因为先修改后返回这样的行为更符合我们的逻辑。</p>
<h3 id="一元负号运算符">一元负号运算符</h3><p>数值的正负号可以使用前缀<code>-</code>（即一元负号）来切换：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> three = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> minusThree = -three       <span class="comment">// minusThree 等于 -3</span></span><br><span class="line"><span class="keyword">let</span> plusThree = -minusThree   <span class="comment">// plusThree 等于 3, 或 "负负3"</span></span><br></pre></td></tr></table></figure>
<p>一元负号（<code>-</code>）写在操作数之前，中间没有空格。</p>
<h3 id="一元正号运算符">一元正号运算符</h3><p>一元正号（<code>+</code>）不做任何改变地返回操作数的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> minusSix = -<span class="number">6</span></span><br><span class="line"><span class="keyword">let</span> alsoMinusSix = +minusSix  <span class="comment">// alsoMinusSix 等于 -6</span></span><br></pre></td></tr></table></figure>
<p>虽然一元<code>+</code>什么都不会改变，但当你在使用一元负号来表达负数时，你可以使用一元正号来表达正数，如此你的代码会具有对称美。</p>
<p><a name="compound_assignment_operators"></a></p>
<h2 id="组合赋值运算符（Compound_Assignment_Operators）">组合赋值运算符（Compound Assignment Operators）</h2><p>如同 C 语言，Swift 也提供把其他运算符和赋值运算（<code>=</code>）组合的组合赋值运算符，组合加运算（<code>+=</code>）是其中一个例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">a += <span class="number">2</span> <span class="comment">// a 现在是 3</span></span><br></pre></td></tr></table></figure>
<p>表达式<code>a += 2</code>是<code>a = a + 2</code>的简写，一个组合加运算就是把加法运算和赋值运算组合成进一个运算符里，同时完成两个运算任务。</p>
<blockquote>
<p>注意：<br>复合赋值运算没有返回值，<code>let b = a += 2</code>这类代码是错误。这不同于上面提到的自增和自减运算符。</p>
</blockquote>
<p>在<a href="../chapter3/04_Expressions.html">表达式</a>章节里有复合运算符的完整列表。<br>‌<br><a name="comparison_operators"></a></p>
<h2 id="比较运算符">比较运算符</h2><p>所有标准 C 语言中的比较运算都可以在 Swift 中使用：</p>
<ul>
<li>等于（<code>a == b</code>）</li>
<li>不等于（<code>a != b</code>）</li>
<li>大于（<code>a &gt; b</code>）</li>
<li>小于（<code>a &lt; b</code>）</li>
<li>大于等于（<code>a &gt;= b</code>）</li>
<li>小于等于（<code>a &lt;= b</code>）</li>
</ul>
<blockquote>
<p>注意：<br>Swift 也提供恒等<code>===</code>和不恒等<code>!==</code>这两个比较符来判断两个对象是否引用同一个对象实例。更多细节在<a href="../chapter2/09_Classes_and_Structures.html">类与结构</a>。</p>
</blockquote>
<p>每个比较运算都返回了一个标识表达式是否成立的布尔值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> == <span class="number">1</span>   <span class="comment">// true, 因为 1 等于 1</span></span><br><span class="line"><span class="number">2</span> != <span class="number">1</span>   <span class="comment">// true, 因为 2 不等于 1</span></span><br><span class="line"><span class="number">2</span> &gt; <span class="number">1</span>    <span class="comment">// true, 因为 2 大于 1</span></span><br><span class="line"><span class="number">1</span> &lt; <span class="number">2</span>    <span class="comment">// true, 因为 1 小于2</span></span><br><span class="line"><span class="number">1</span> &gt;= <span class="number">1</span>   <span class="comment">// true, 因为 1 大于等于 1</span></span><br><span class="line"><span class="number">2</span> &lt;= <span class="number">1</span>   <span class="comment">// false, 因为 2 并不小于等于 1</span></span><br></pre></td></tr></table></figure>
<p>比较运算多用于条件语句，如<code>if</code>条件：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">"world"</span></span><br><span class="line"><span class="keyword">if</span> name == <span class="string">"world"</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"hello, world"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"I'm sorry <span class="subst">\(name)</span>, but I don't recognize you"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "hello, world", 因为 `name` 就是等于 "world"</span></span><br></pre></td></tr></table></figure>
<p>关于<code>if</code>语句，请看<a href="../chapter2/05_Control_Flow.html">控制流</a>。</p>
<p><a name="ternary_conditional_operator"></a></p>
<h2 id="三目运算符(Ternary_Conditional_Operator)">三目运算符(Ternary Conditional Operator)</h2><p>三目运算符的特殊在于它是有三个操作数的运算符，它的原型是 <code>问题 ? 答案1 : 答案2</code>。它简洁地表达根据<code>问题</code>成立与否作出二选一的操作。如果<code>问题</code>成立，返回<code>答案1</code>的结果; 如果不成立，返回<code>答案2</code>的结果。</p>
<p>三目运算符是以下代码的缩写形式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> question &#123;</span><br><span class="line">	answer1</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	answer2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有个计算表格行高的例子。如果有表头，那行高应比内容高度要高出50点；如果没有表头，只需高出20点：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> contentHeight = <span class="number">40</span></span><br><span class="line"><span class="keyword">let</span> hasHeader = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> rowHeight = contentHeight + (hasHeader ? <span class="number">50</span> : <span class="number">20</span>)</span><br><span class="line"><span class="comment">// rowHeight 现在是 90</span></span><br></pre></td></tr></table></figure>
<p>上面的写法比下面的代码更简洁：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> contentHeight = <span class="number">40</span></span><br><span class="line"><span class="keyword">let</span> hasHeader = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> rowHeight = contentHeight</span><br><span class="line"><span class="keyword">if</span> hasHeader &#123;</span><br><span class="line">	rowHeight = rowHeight + <span class="number">50</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	rowHeight = rowHeight + <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// rowHeight 现在是 90</span></span><br></pre></td></tr></table></figure>
<p>第一段代码例子使用了三目运算，所以一行代码就能让我们得到正确答案。这比第二段代码简洁得多，无需将<code>rowHeight</code>定义成变量，因为它的值无需在<code>if</code>语句中改变。</p>
<p>三目运算提供有效率且便捷的方式来表达二选一的选择。需要注意的事，过度使用三目运算符会使简洁的代码变的难懂。我们应避免在一个组合语句中使用多个三目运算符。</p>
<p><a name="nil_coalescing_operator"></a></p>
<h2 id="空合运算符(Nil_Coalescing_Operator)">空合运算符(Nil Coalescing Operator)</h2><p>空合运算符(<code>a ?? b</code>)将对可选类型<code>a</code>进行空判断，如果<code>a</code>包含一个值就进行解封，否则就返回一个默认值<code>b</code>.这个运算符有两个条件:</p>
<ul>
<li>表达式<code>a</code>必须是Optional类型</li>
<li>默认值<code>b</code>的类型必须要和<code>a</code>存储值的类型保持一致</li>
</ul>
<p>空合运算符是对以下代码的简短表达方法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a != <span class="literal">nil</span> ? a! : b</span><br></pre></td></tr></table></figure>
<p>上述代码使用了三目运算符。当可选类型<code>a</code>的值不为空时，进行强制解封(<code>a!</code>)访问<code>a</code>中值，反之当<code>a</code>中值为空时，返回默认值b。无疑空合运算符(<code>??</code>)提供了一种更为优雅的方式去封装条件判断和解封两种行为，显得简洁以及更具可读性。</p>
<blockquote>
<p>注意：<br>如果<code>a</code>为非空值(<code>non-nil</code>),那么值<code>b</code>将不会被估值。这也就是所谓的短路求值。</p>
</blockquote>
<p>下文例子采用空合运算符，实现了在默认颜色名和可选自定义颜色名之间抉择：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> defaultColorName = <span class="string">"red"</span></span><br><span class="line"><span class="keyword">var</span> userDefinedColorName: <span class="type">String</span>?   <span class="comment">//默认值为 nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colorNameToUse = userDefinedColorName ?? defaultColorName</span><br><span class="line"><span class="comment">// userDefinedColorName 的值为空，所以 colorNameToUse 的值为 "red"</span></span><br></pre></td></tr></table></figure>
<p><code>userDefinedColorName</code>变量被定义为一个可选<code>String</code>类型，默认值为<code>nil</code>。由于<code>userDefinedColorName</code>是一个可选类型，我们可以使用空合运算符去判断其值。在上一个例子中，通过空合运算符为一个名为<code>colorNameToUse</code>的变量赋予一个字符串类型初始值。<br>由于<code>userDefinedColorName</code>值为空，因此表达式<code>userDefinedColorName ?? defaultColorName</code>返回<code>defaultColorName</code>的值，即<code>red</code>。</p>
<p>另一种情况，分配一个非空值(<code>non-nil</code>)给<code>userDefinedColorName</code>，再次执行空合运算，运算结果为封包在<code>userDefaultColorName</code>中的值，而非默认值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userDefinedColorName = <span class="string">"green"</span></span><br><span class="line">colorNameToUse = userDefinedColorName ?? defaultColorName</span><br><span class="line"><span class="comment">// userDefinedColorName 非空，因此 colorNameToUse 的值为 "green"</span></span><br></pre></td></tr></table></figure>
<p><a name="range_operators"></a></p>
<h2 id="区间运算符">区间运算符</h2><p>Swift 提供了两个方便表达一个区间的值的运算符。</p>
<h3 id="闭区间运算符">闭区间运算符</h3><p>闭区间运算符（<code>a...b</code>）定义一个包含从<code>a</code>到<code>b</code>(包括<code>a</code>和<code>b</code>)的所有值的区间，<code>b</code>必须大于等于<code>a</code>。<br>‌<br>闭区间运算符在迭代一个区间的所有值时是非常有用的，如在<code>for-in</code>循环中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span>...<span class="number">5</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"<span class="subst">\(index)</span> * 5 = <span class="subst">\(index * <span class="number">5</span>)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 * 5 = 5</span></span><br><span class="line"><span class="comment">// 2 * 5 = 10</span></span><br><span class="line"><span class="comment">// 3 * 5 = 15</span></span><br><span class="line"><span class="comment">// 4 * 5 = 20</span></span><br><span class="line"><span class="comment">// 5 * 5 = 25</span></span><br></pre></td></tr></table></figure>
<p>关于<code>for-in</code>，请看<a href="../chapter2/05_Control_Flow.html">控制流</a>。</p>
<h3 id="半开区间运算符">半开区间运算符</h3><p>半开区间（<code>a..&lt;b</code>）定义一个从<code>a</code>到<code>b</code>但不包括<code>b</code>的区间。<br>之所以称为半开区间，是因为该区间包含第一个值而不包括最后的值。</p>
<p>半开区间的实用性在于当你使用一个从0开始的列表(如数组)时，非常方便地从0数到列表的长度。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [<span class="string">"Anna"</span>, <span class="string">"Alex"</span>, <span class="string">"Brian"</span>, <span class="string">"Jack"</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="built_in">count</span> = names.<span class="built_in">count</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="built_in">count</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"第 <span class="subst">\(i + <span class="number">1</span>)</span> 个人叫 <span class="subst">\(names[i])</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第 1 个人叫 Anna</span></span><br><span class="line"><span class="comment">// 第 2 个人叫 Alex</span></span><br><span class="line"><span class="comment">// 第 3 个人叫 Brian</span></span><br><span class="line"><span class="comment">// 第 4 个人叫 Jack</span></span><br></pre></td></tr></table></figure>
<p>数组有4个元素，但<code>0..&lt;count</code>只数到3(最后一个元素的下标)，因为它是半开区间。关于数组，请查阅<a href="../chapter2/04_Collection_Types.html#arrays">数组</a>。</p>
<p><a name="logical_operators"></a></p>
<h2 id="逻辑运算">逻辑运算</h2><p>逻辑运算的操作对象是逻辑布尔值。Swift 支持基于 C 语言的三个标准逻辑运算。</p>
<ul>
<li>逻辑非（<code>!a</code>）</li>
<li>逻辑与（<code>a &amp;&amp; b</code>）</li>
<li>逻辑或（<code>a || b</code>）</li>
</ul>
<h3 id="逻辑非">逻辑非</h3><p>逻辑非运算（<code>!a</code>）对一个布尔值取反，使得<code>true</code>变<code>false</code>，<code>false</code>变<code>true</code>。</p>
<p>它是一个前置运算符，需紧跟在操作数之前，且不加空格。读作<code>非 a</code>，例子如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> allowedEntry = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> !allowedEntry &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"ACCESS DENIED"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "ACCESS DENIED"</span></span><br></pre></td></tr></table></figure>
<p><code>if !allowedEntry</code>语句可以读作“如果非 allowedEntry。”，接下一行代码只有在“非 allowedEntry”为<code>true</code>，即<code>allowEntry</code>为<code>false</code>时被执行。</p>
<p>在示例代码中，小心地选择布尔常量或变量有助于代码的可读性，并且避免使用双重逻辑非运算，或混乱的逻辑语句。</p>
<h3 id="逻辑与">逻辑与</h3><p>逻辑与（<code>a &amp;&amp; b</code>）表达了只有<code>a</code>和<code>b</code>的值都为<code>true</code>时，整个表达式的值才会是<code>true</code>。</p>
<p>只要任意一个值为<code>false</code>，整个表达式的值就为<code>false</code>。事实上，如果第一个值为<code>false</code>，那么是不去计算第二个值的，因为它已经不可能影响整个表达式的结果了。这被称做“短路计算（short-circuit evaluation）”。</p>
<p>以下例子，只有两个<code>Bool</code>值都为<code>true</code>的时候才允许进入：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> enteredDoorCode = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> passedRetinaScan = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> enteredDoorCode &amp;&amp; passedRetinaScan &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Welcome!"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"ACCESS DENIED"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "ACCESS DENIED"</span></span><br></pre></td></tr></table></figure>
<h3 id="逻辑或">逻辑或</h3><p>逻辑或（<code>a || b</code>）是一个由两个连续的<code>|</code>组成的中置运算符。它表示了两个逻辑表达式的其中一个为<code>true</code>，整个表达式就为<code>true</code>。</p>
<p>同逻辑与运算类似，逻辑或也是“短路计算”的，当左端的表达式为<code>true</code>时，将不计算右边的表达式了，因为它不可能改变整个表达式的值了。</p>
<p>以下示例代码中，第一个布尔值（<code>hasDoorKey</code>）为<code>false</code>，但第二个值（<code>knowsOverridePassword</code>）为<code>true</code>，所以整个表达是<code>true</code>，于是允许进入：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hasDoorKey = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> knowsOverridePassword = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> hasDoorKey || knowsOverridePassword &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Welcome!"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"ACCESS DENIED"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "Welcome!"</span></span><br></pre></td></tr></table></figure>
<h3 id="逻辑运算符组合计算">逻辑运算符组合计算</h3><p>我们可以组合多个逻辑运算来表达一个复合逻辑：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> enteredDoorCode &amp;&amp; passedRetinaScan || hasDoorKey || knowsOverridePassword &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Welcome!"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"ACCESS DENIED"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "Welcome!"</span></span><br></pre></td></tr></table></figure>
<p>这个例子使用了含多个<code>&amp;&amp;</code>和<code>||</code>的复合逻辑。但无论怎样，<code>&amp;&amp;</code>和<code>||</code>始终只能操作两个值。所以这实际是三个简单逻辑连续操作的结果。我们来解读一下：</p>
<p>如果我们输入了正确的密码并通过了视网膜扫描，或者我们有一把有效的钥匙，又或者我们知道紧急情况下重置的密码，我们就能把门打开进入。</p>
<p>前两种情况，我们都不满足，所以前两个简单逻辑的结果是<code>false</code>，但是我们是知道紧急情况下重置的密码的，所以整个复杂表达式的值还是<code>true</code>。</p>
<blockquote>
<p>注意：<br>Swift 逻辑操作符<code>&amp;&amp;</code>和<code>||</code>是左结合的，这意味着拥有多元逻辑操作符的复合表达式优先计算最左边的子表达式。</p>
</blockquote>
<h3 id="使用括号来明确优先级">使用括号来明确优先级</h3><p>为了一个复杂表达式更容易读懂，在合适的地方使用括号来明确优先级是很有效的，虽然它并非必要的。在上个关于门的权限的例子中，我们给第一个部分加个括号，使它看起来逻辑更明确：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (enteredDoorCode &amp;&amp; passedRetinaScan) || hasDoorKey || knowsOverridePassword &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Welcome!"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"ACCESS DENIED"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "Welcome!"</span></span><br></pre></td></tr></table></figure>
<p>这括号使得前两个值被看成整个逻辑表达中独立的一个部分。虽然有括号和没括号的输出结果是一样的，但对于读代码的人来说有括号的代码更清晰。可读性比简洁性更重要，请在可以让你代码变清晰的地方加个括号吧！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="基本运算符（Basic_Operators）">基本运算符（Basic Operators）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/xielingwang" target="_]]>
    </summary>
    
      <category term="swift-cn" scheme="http://yoursite.com/tags/swift-cn/"/>
    
      <category term="swift-cn" scheme="http://yoursite.com/categories/swift-cn/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第二章-03字符串和字符（Strings and Characters）]]></title>
    <link href="http://yoursite.com/2015/12/25/swift-cn/chapter2/03_Strings_and_Characters/"/>
    <id>http://yoursite.com/2015/12/25/swift-cn/chapter2/03_Strings_and_Characters/</id>
    <published>2015-12-25T04:00:24.000Z</published>
    <updated>2015-12-15T05:44:49.486Z</updated>
    <content type="html"><![CDATA[<h1 id="字符串和字符（Strings_and_Characters）">字符串和字符（Strings and Characters）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/wh1100717" target="_blank" rel="external">wh1100717</a><br>校对：<a href="https://github.com/Hawstein" target="_blank" rel="external">Hawstein</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/DianQK" target="_blank" rel="external">DianQK</a></p>
<p>2.1<br>翻译：<a href="https://github.com/DianQK" target="_blank" rel="external">DianQK</a><br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#string_literals">字符串字面量</a></li>
<li><a href="#initializing_an_empty_string">初始化空字符串</a></li>
<li><a href="#string_mutability">字符串可变性</a></li>
<li><a href="#strings_are_value_types">字符串是值类型</a></li>
<li><a href="#working_with_characters">使用字符</a></li>
<li><a href="#concatenating_strings_and_characters">连接字符串和字符</a></li>
<li><a href="#string_interpolation">字符串插值</a></li>
<li><a href="#unicode">Unicode</a></li>
<li><a href="#counting_characters">计算字符数量</a></li>
<li><a href="#accessing_and_modifying_a_string">访问和修改字符串</a></li>
<li><a href="#comparing_strings">比较字符串</a></li>
<li><a href="#unicode_representations_of_strings">字符串的 Unicode 表示形式</a></li>
</ul>
<p><code>String</code>是例如”hello, world”，”albatross”这样的有序的<code>Character</code>（字符）类型的值的集合。通过<code>String</code>类型来表示。<br>一个<code>String</code>的内容可以用变量的方式读取，它包括一个<code>Character</code>值的集合。<br>创建和操作字符串的语法与 C 语言中字符串操作相似，轻量并且易读。<br>字符串连接操作只需要简单地通过<code>+</code>符号将两个字符串相连即可。与 Swift 中其他值一样，能否更改字符串的值，取决于其被定义为常量还是变量。你也可以在字符串内插过程中使用字符串插入常量、变量、字面量表达成更长的字符串，这样可以很容易的创建自定义的字符串值，进行展示、存储以及打印。<br>尽管语法简易，但<code>String</code>类型是一种快速、现代化的字符串实现。<br>每一个字符串都是由编码无关的 Unicode 字符组成，并支持访问字符的多种 Unicode 表示形式（representations）。</p>
<blockquote>
<p>注意：<br>Swift 的<code>String</code>类型与 Foundation <code>NSString</code>类进行了无缝桥接。就像 <a href="./19_Type_Casting.html#anyobject"><code>AnyObject</code>类型</a> 中提到的一样，在使用 Cocoa 中的 Foundation 框架时，您可以将创建的任何字符串的值转换成<code>NSString</code>，并调用任意的<code>NSString</code> API。您也可以在任意要求传入<code>NSString</code>实例作为参数的 API 中用<code>String</code>类型的值代替。<br>更多关于在 Foundation 和 Cocoa 中使用<code>String</code>的信息请查看 <em><a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216" target="_blank" rel="external">Using Swift with Cocoa and Objective-C (Swift 2.1)</a></em>。</p>
</blockquote>
<p><a name="string_literals"></a></p>
<h2 id="字符串字面量（String_Literals）">字符串字面量（String Literals）</h2><p>您可以在您的代码中包含一段预定义的字符串值作为字符串字面量。字符串字面量是由双引号 (<code>&quot;&quot;</code>) 包裹着的具有固定顺序的文本字符集。<br>字符串字面量可以用于为常量和变量提供初始值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someString = <span class="string">"Some string literal value"</span></span><br></pre></td></tr></table></figure>
<p>注意<code>someString</code>常量通过字符串字面量进行初始化，Swift 会推断该常量为<code>String</code>类型。</p>
<blockquote>
<p>注意：<br>更多关于在字符串字面量中使用特殊字符的信息，请查看 <a href="#special_characters_in_string_literals">字符串字面量的特殊字符</a> 。</p>
</blockquote>
<p><a name="initializing_an_empty_string"></a></p>
<h2 id="初始化空字符串_(Initializing_an_Empty_String)">初始化空字符串 (Initializing an Empty String)</h2><p>要创建一个空字符串作为初始值，可以将空的字符串字面量赋值给变量，也可以初始化一个新的<code>String</code>实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emptyString = <span class="string">""</span>               <span class="comment">// 空字符串字面量</span></span><br><span class="line"><span class="keyword">var</span> anotherEmptyString = <span class="type">String</span>()  <span class="comment">// 初始化方法</span></span><br><span class="line"><span class="comment">// 两个字符串均为空并等价。</span></span><br></pre></td></tr></table></figure>
<p>您可以通过检查其<code>Boolean</code>类型的<code>isEmpty</code>属性来判断该字符串是否为空：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> emptyString.isEmpty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Nothing to see here"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印输出："Nothing to see here"</span></span><br></pre></td></tr></table></figure>
<p><a name="string_mutability"></a></p>
<h2 id="字符串可变性_(String_Mutability)">字符串可变性 (String Mutability)</h2><p>您可以通过将一个特定字符串分配给一个变量来对其进行修改，或者分配给一个常量来保证其不会被修改：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> variableString = <span class="string">"Horse"</span></span><br><span class="line">variableString += <span class="string">" and carriage"</span></span><br><span class="line"><span class="comment">// variableString 现在为 "Horse and carriage"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> constantString = <span class="string">"Highlander"</span></span><br><span class="line">constantString += <span class="string">" and another Highlander"</span></span><br><span class="line"><span class="comment">// 这会报告一个编译错误 (compile-time error) - 常量字符串不可以被修改。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>在 Objective-C 和 Cocoa 中，您需要通过选择两个不同的类(<code>NSString</code>和<code>NSMutableString</code>)来指定字符串是否可以被修改。</p>
</blockquote>
<p><a name="strings_are_value_types"></a></p>
<h2 id="字符串是值类型（Strings_Are_Value_Types）">字符串是值类型（Strings Are Value Types）</h2><p>Swift 的<code>String</code>类型是值类型。<br>如果您创建了一个新的字符串，那么当其进行常量、变量赋值操作，或在函数/方法中传递时，会进行值拷贝。<br>任何情况下，都会对已有字符串值创建新副本，并对该新副本进行传递或赋值操作。<br>值类型在 <a href="./09_Classes_and_Structures.html#structures_and_enumerations_are_value_types">结构体和枚举是值类型</a> 中进行了详细描述。</p>
<p>Swift 默认字符串拷贝的方式保证了在函数/方法中传递的是字符串的值。<br>很明显无论该值来自于哪里，都是您独自拥有的。<br>您可以确信传递的字符串不会被修改，除非你自己去修改它。</p>
<p>在实际编译时，Swift 编译器会优化字符串的使用，使实际的复制只发生在绝对必要的情况下，这意味着您将字符串作为值类型的同时可以获得极高的性能。</p>
<p><a name="working_with_characters"></a></p>
<h2 id="使用字符（Working_with_Characters）">使用字符（Working with Characters）</h2><p>您可通过<code>for-in</code>循环来遍历字符串中的<code>characters</code>属性来获取每一个字符的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> character <span class="keyword">in</span> <span class="string">"Dog!🐶"</span>.characters &#123;</span><br><span class="line">    <span class="built_in">print</span>(character)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// D</span></span><br><span class="line"><span class="comment">// o</span></span><br><span class="line"><span class="comment">// g</span></span><br><span class="line"><span class="comment">// !</span></span><br><span class="line"><span class="comment">// 🐶</span></span><br></pre></td></tr></table></figure>
<p><code>for-in</code>循环在 <a href="./05_Control_Flow.html#for_loops">For 循环</a> 中进行了详细描述。</p>
<p>另外，通过标明一个<code>Character</code>类型并用字符字面量进行赋值，可以建立一个独立的字符常量或变量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> exclamationMark: <span class="type">Character</span> = <span class="string">"!"</span></span><br></pre></td></tr></table></figure>
<p>字符串可以通过传递一个值类型为<code>Character</code>的数组作为自变量来初始化：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> catCharacters: [<span class="type">Character</span>] = [<span class="string">"C"</span>, <span class="string">"a"</span>, <span class="string">"t"</span>, <span class="string">"!"</span>, <span class="string">"🐱"</span>]</span><br><span class="line"><span class="keyword">let</span> catString = <span class="type">String</span>(catCharacters)</span><br><span class="line"><span class="built_in">print</span>(catString)</span><br><span class="line"><span class="comment">// 打印输出："Cat!🐱"</span></span><br></pre></td></tr></table></figure>
<p><a name="concatenating_strings_and_characters"></a></p>
<h2 id="连接字符串和字符_(Concatenating_Strings_and_Characters)">连接字符串和字符 (Concatenating Strings and Characters)</h2><p>字符串可以通过加法运算符（<code>+</code>）相加在一起（或称“连接”）创建一个新的字符串：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> string1 = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">let</span> string2 = <span class="string">" there"</span></span><br><span class="line"><span class="keyword">var</span> welcome = string1 + string2</span><br><span class="line"><span class="comment">// welcome 现在等于 "hello there"</span></span><br></pre></td></tr></table></figure>
<p>您也可以通过加法赋值运算符 (<code>+=</code>) 将一个字符串添加到一个已经存在字符串变量上：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instruction = <span class="string">"look over"</span></span><br><span class="line">instruction += string2</span><br><span class="line"><span class="comment">// instruction 现在等于 "look over there"</span></span><br></pre></td></tr></table></figure>
<p>您可以用<code>append()</code>方法将一个字符附加到一个字符串变量的尾部：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> exclamationMark: <span class="type">Character</span> = <span class="string">"!"</span></span><br><span class="line">welcome.append(exclamationMark)</span><br><span class="line"><span class="comment">// welcome 现在等于 "hello there!"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>您不能将一个字符串或者字符添加到一个已经存在的字符变量上，因为字符变量只能包含一个字符。</p>
</blockquote>
<p><a name="string_interpolation"></a></p>
<h2 id="字符串插值_(String_Interpolation)">字符串插值 (String Interpolation)</h2><p>字符串插值是一种构建新字符串的方式，可以在其中包含常量、变量、字面量和表达式。<br>您插入的字符串字面量的每一项都在以反斜线为前缀的圆括号中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> multiplier = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> message = <span class="string">"<span class="subst">\(multiplier)</span> times 2.5 is <span class="subst">\(Double(multiplier)</span> * 2.5)"</span></span><br><span class="line"><span class="comment">// message is "3 times 2.5 is 7.5"</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>multiplier</code>作为<code>\(multiplier)</code>被插入到一个字符串常量量中。<br>当创建字符串执行插值计算时此占位符会被替换为<code>multiplier</code>实际的值。</p>
<p><code>multiplier</code>的值也作为字符串中后面表达式的一部分。<br>该表达式计算<code>Double(multiplier) * 2.5</code>的值并将结果 (<code>7.5</code>) 插入到字符串中。<br>在这个例子中，表达式写为<code>\(Double(multiplier) * 2.5)</code>并包含在字符串字面量中。</p>
<blockquote>
<p>注意：<br>插值字符串中写在括号中的表达式不能包含非转义反斜杠 (<code>\</code>)，并且不能包含回车或换行符。不过，插值字符串可以包含其他字面量。</p>
</blockquote>
<p><a name="unicode"></a></p>
<h2 id="Unicode">Unicode</h2><p>Unicode 是一个国际标准，用于文本的编码和表示。<br>它使您可以用标准格式表示来自任意语言几乎所有的字符，并能够对文本文件或网页这样的外部资源中的字符进行读写操作。<br>Swift 的<code>String</code>和<code>Character</code>类型是完全兼容 Unicode 标准的。</p>
<p><a name="unicode_scalars"></a></p>
<h3 id="Unicode_标量（Unicode_Scalars）">Unicode 标量（Unicode Scalars）</h3><p>Swift 的<code>String</code>类型是基于 <em>Unicode 标量</em> 建立的。<br>Unicode 标量是对应字符或者修饰符的唯一的21位数字，例如<code>U+0061</code>表示小写的拉丁字母(<code>LATIN SMALL LETTER A</code>)(“<code>a</code>“)，<code>U+1F425</code>表示小鸡表情(<code>FRONT-FACING BABY CHICK</code>) (“<code>🐥</code>“)。</p>
<blockquote>
<p>注意：<br>Unicode <em>码位(code poing)</em> 的范围是<code>U+0000</code>到<code>U+D7FF</code>或者<code>U+E000</code>到<code>U+10FFFF</code>。Unicode 标量不包括 Unicode <em>代理项(surrogate pair)</em> 码位，其码位范围是<code>U+D800</code>到<code>U+DFFF</code>。</p>
</blockquote>
<p>注意不是所有的21位 Unicode 标量都代表一个字符，因为有一些标量是留作未来分配的。已经代表一个典型字符的标量都有自己的名字，例如上面例子中的<code>LATIN SMALL LETTER A</code>和<code>FRONT-FACING BABY CHICK</code>。</p>
<p><a name="special_characters_in_string_literals"></a></p>
<h3 id="字符串字面量的特殊字符_(Special_Characters_in_String_Literals)">字符串字面量的特殊字符 (Special Characters in String Literals)</h3><p>字符串字面量可以包含以下特殊字符：</p>
<ul>
<li>转义字符<code>\0</code>(空字符)、<code>\\</code>(反斜线)、<code>\t</code>(水平制表符)、<code>\n</code>(换行符)、<code>\r</code>(回车符)、<code>\&quot;</code>(双引号)、<code>\&#39;</code>(单引号)。</li>
<li>Unicode 标量，写成<code>\u{n}</code>(u为小写)，其中<code>n</code>为任意一到八位十六进制数且可用的 Unicode 位码。</li>
</ul>
<p>下面的代码为各种特殊字符的使用示例。<br><code>wiseWords</code>常量包含了两个双引号。<br><code>dollarSign</code>、<code>blackHeart</code>和<code>sparklingHeart</code>常量演示了三种不同格式的 Unicode 标量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wiseWords = <span class="string">"\"Imagination is more important than knowledge\" - Einstein"</span></span><br><span class="line"><span class="comment">// "Imageination is more important than knowledge" - Enistein</span></span><br><span class="line"><span class="keyword">let</span> dollarSign = <span class="string">"\u&#123;24&#125;"</span>             <span class="comment">// $, Unicode 标量 U+0024</span></span><br><span class="line"><span class="keyword">let</span> blackHeart = <span class="string">"\u&#123;2665&#125;"</span>           <span class="comment">// ♥, Unicode 标量 U+2665</span></span><br><span class="line"><span class="keyword">let</span> sparklingHeart = <span class="string">"\u&#123;1F496&#125;"</span>      <span class="comment">// 💖, Unicode 标量 U+1F496</span></span><br></pre></td></tr></table></figure>
<p><a name="extended_grapheme_clusters"></a></p>
<h3 id="可扩展的字形群集(Extended_Grapheme_Clusters)">可扩展的字形群集(Extended Grapheme Clusters)</h3><p>每一个 Swift 的<code>Character</code>类型代表一个可扩展的字形群。<br>一个可扩展的字形群是一个或多个可生成人类可读的字符 Unicode 标量的有序排列。<br>举个例子，字母<code>é</code>可以用单一的 Unicode 标量<code>é</code>(<code>LATIN SMALL LETTER E WITH ACUTE</code>, 或者<code>U+00E9</code>)来表示。然而一个标准的字母<code>e</code>(<code>LATIN SMALL LETTER E</code>或者<code>U+0065</code>) 加上一个急促重音(<code>COMBINING ACTUE ACCENT</code>)的标量(<code>U+0301</code>)，这样一对标量就表示了同样的字母<code>é</code>。<br>这个急促重音的标量形象的将<code>e</code>转换成了<code>é</code>。</p>
<p>在这两种情况中，字母<code>é</code>代表了一个单一的 Swift 的<code>Character</code>值，同时代表了一个可扩展的字形群。<br>在第一种情况，这个字形群包含一个单一标量；而在第二种情况，它是包含两个标量的字形群：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> eAcute: <span class="type">Character</span> = <span class="string">"\u&#123;E9&#125;"</span>                         <span class="comment">// é</span></span><br><span class="line"><span class="keyword">let</span> combinedEAcute: <span class="type">Character</span> = <span class="string">"\u&#123;65&#125;\u&#123;301&#125;"</span>          <span class="comment">// e 后面加上  ́</span></span><br><span class="line"><span class="comment">// eAcute 是 é, combinedEAcute 是 é</span></span><br></pre></td></tr></table></figure>
<p>可扩展的字符群集是一个灵活的方法，用许多复杂的脚本字符表示单一的<code>Character</code>值。<br>例如，来自朝鲜语字母表的韩语音节能表示为组合或分解的有序排列。<br>在 Swift 都会表示为同一个单一的<code>Character</code>值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> precomposed: <span class="type">Character</span> = <span class="string">"\u&#123;D55C&#125;"</span>                  <span class="comment">// 한</span></span><br><span class="line"><span class="keyword">let</span> decomposed: <span class="type">Character</span> = <span class="string">"\u&#123;1112&#125;\u&#123;1161&#125;\u&#123;11AB&#125;"</span>   <span class="comment">// ᄒ, ᅡ, ᆫ</span></span><br><span class="line"><span class="comment">// precomposed 是 한, decomposed 是 한</span></span><br></pre></td></tr></table></figure>
<p>可拓展的字符群集可以使包围记号(例如<code>COMBINING ENCLOSING CIRCLE</code>或者<code>U+20DD</code>)的标量包围其他 Unicode 标量，作为一个单一的<code>Character</code>值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> enclosedEAcute: <span class="type">Character</span> = <span class="string">"\u&#123;E9&#125;\u&#123;20DD&#125;"</span></span><br><span class="line"><span class="comment">// enclosedEAcute 是 é⃝</span></span><br></pre></td></tr></table></figure>
<p>局部的指示符号的 Unicode 标量可以组合成一个单一的<code>Character</code>值，例如<code>REGIONAL INDICATOR SYMBOL LETTER U</code>(<code>U+1F1FA</code>)和<code>REGIONAL INDICATOR SYMBOL LETTER S</code>(<code>U+1F1F8</code>)：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regionalIndicatorForUS: <span class="type">Character</span> = <span class="string">"\u&#123;1F1FA&#125;\u&#123;1F1F8&#125;"</span></span><br><span class="line"><span class="comment">// regionalIndicatorForUS 是 🇺🇸</span></span><br></pre></td></tr></table></figure>
<p><a name="counting_characters"></a></p>
<h2 id="计算字符数量_(Counting_Characters)">计算字符数量 (Counting Characters)</h2><p>如果想要获得一个字符串中<code>Character</code>值的数量，可以使用字符串的<code>characters</code>属性的<code>count</code>属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unusualMenagerie = <span class="string">"Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"unusualMenagerie has <span class="subst">\(unusualMenagerie.characters.<span class="built_in">count</span>)</span> characters"</span>)</span><br><span class="line"><span class="comment">// 打印输出 "unusualMenagerie has 40 characters"</span></span><br></pre></td></tr></table></figure>
<p>注意在 Swift 中，使用可拓展的字符群集作为<code>Character</code>值来连接或改变字符串时，并不一定会更改字符串的字符数量。</p>
<p>例如，如果你用四个字符的单词<code>cafe</code>初始化一个新的字符串，然后添加一个<code>COMBINING ACTUE ACCENT</code>(<code>U+0301</code>)作为字符串的结尾。最终这个字符串的字符数量仍然是<code>4</code>，因为第四个字符是<code>é</code>，而不是<code>e</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> word = <span class="string">"cafe"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"the number of characters in <span class="subst">\(word)</span> is <span class="subst">\(word.characters.<span class="built_in">count</span>)</span>"</span>)</span><br><span class="line"><span class="comment">// 打印输出 "the number of characters in cafe is 4"</span></span><br><span class="line"></span><br><span class="line">word += <span class="string">"\u&#123;301&#125;"</span>    <span class="comment">// COMBINING ACUTE ACCENT, U+0301</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"the number of characters in <span class="subst">\(word)</span> is <span class="subst">\(word.characters.<span class="built_in">count</span>)</span>"</span>)</span><br><span class="line"><span class="comment">// 打印输出 "the number of characters in café is 4"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>可扩展的字符群集可以组成一个或者多个 Unicode 标量。这意味着不同的字符以及相同字符的不同表示方式可能需要不同数量的内存空间来存储。所以 Swift 中的字符在一个字符串中并不一定占用相同的内存空间数量。因此在没有获取字符串的可扩展的字符群的范围时候，就不能计算出字符串的字符数量。如果您正在处理一个长字符串，需要注意<code>characters</code>属性必须遍历全部的 Unicode 标量，来确定字符串的字符数量。</p>
<p>另外需要注意的是通过<code>characters</code>属性返回的字符数量并不总是与包含相同字符的<code>NSString</code>的<code>length</code>属性相同。<code>NSString</code>的<code>length</code>属性是利用 UTF-16 表示的十六位代码单元数字，而不是 Unicode 可扩展的字符群集。作为佐证，当一个<code>NSString</code>的<code>length</code>属性被一个Swift的<code>String</code>值访问时，实际上是调用了<code>utf16Count</code>。</p>
</blockquote>
<p><a name="accessing_and_modifying_a_string"></a></p>
<h2 id="访问和修改字符串_(Accessing_and_Modifying_a_String)">访问和修改字符串 (Accessing and Modifying a String)</h2><p>你可以通字符串的属性和方法来访问和读取它，当然也可以用下标语法完成。</p>
<p><a name="string_indices"></a></p>
<h3 id="字符串索引_(String_Indices)">字符串索引 (String Indices)</h3><p>每一个<code>String</code>值都有一个关联的索引(<em>index</em>)类型，<code>String.Index</code>，它对应着字符串中的每一个<code>Character</code>的位置。</p>
<p>前面提到，不同的字符可能会占用不同数量的内存空间，所以要知道<code>Character</code>的确定位置，就必须从<code>String</code>开头遍历每一个 Unicode 标量直到结尾。因此，Swift 的字符串不能用整数(integer)做索引。</p>
<p>使用<code>startIndex</code>属性可以获取一个<code>String</code>的第一个<code>Character</code>的索引。使用<code>endIndex</code>属性可以获取最后一个<code>Character</code>的后一个位置的索引。因此，<code>endIndex</code>属性不能作为一个字符串的有效下标。如果<code>String</code>是空串，<code>startIndex</code>和<code>endIndex</code>是相等的。</p>
<p>通过调用<code>String.Index</code>的<code>predecessor()</code>方法，可以立即得到前面一个索引，调用<code>successor()</code>方法可以立即得到后面一个索引。任何一个<code>String</code>的索引都可以通过锁链作用的这些方法来获取另一个索引，也可以调用<code>advancedBy(_:)</code>方法来获取。但如果尝试获取出界的字符串索引，就会抛出一个运行时错误。</p>
<p>你可以使用下标语法来访问<code>String</code>特定索引的<code>Character</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting = <span class="string">"Guten Tag!"</span></span><br><span class="line">greeting[greeting.startIndex]</span><br><span class="line"><span class="comment">// G</span></span><br><span class="line">greeting[greeting.endIndex.predecessor()]</span><br><span class="line"><span class="comment">// !</span></span><br><span class="line">greeting[greeting.startIndex.successor()]</span><br><span class="line"><span class="comment">// u</span></span><br><span class="line"><span class="keyword">let</span> index = greeting.startIndex.advancedBy(<span class="number">7</span>)</span><br><span class="line">greeting[index]</span><br><span class="line"><span class="comment">// a</span></span><br></pre></td></tr></table></figure>
<p>试图获取越界索引对应的<code>Character</code>，将引发一个运行时错误。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">greeting[greeting.endIndex] <span class="comment">// error</span></span><br><span class="line">greeting.endIndex.successor() <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<p>使用<code>characters</code>属性的<code>indices</code>属性会创建一个包含全部索引的范围(<code>Range</code>)，用来在一个字符串中访问单个字符。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> greeting.characters.<span class="built_in">indices</span> &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"<span class="subst">\(greeting[index])</span> "</span>, terminator: <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印输出 "G u t e n   T a g !"</span></span><br></pre></td></tr></table></figure>
<p><a name="inserting_and_removing"></a></p>
<h3 id="插入和删除_(Inserting_and_Removing)">插入和删除 (Inserting and Removing)</h3><p>调用<code>insert(_:atIndex:)</code>方法可以在一个字符串的指定索引插入一个字符。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> welcome = <span class="string">"hello"</span></span><br><span class="line">welcome.insert(<span class="string">"!"</span>, atIndex: welcome.endIndex)</span><br><span class="line"><span class="comment">// welcome now 现在等于 "hello!"</span></span><br></pre></td></tr></table></figure>
<p>调用<code>insertContentsOf(_:at:)</code>方法可以在一个字符串的指定索引插入一个字符串。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">welcome.insertContentsOf(<span class="string">" there"</span>.characters, at: welcome.endIndex.predecessor())</span><br><span class="line"><span class="comment">// welcome 现在等于 "hello there!"</span></span><br></pre></td></tr></table></figure>
<p>调用<code>removeAtIndex(_:)</code>方法可以在一个字符串的指定索引删除一个字符。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">welcome.removeAtIndex(welcome.endIndex.predecessor())</span><br><span class="line"><span class="comment">// welcome 现在等于 "hello there"</span></span><br></pre></td></tr></table></figure>
<p>调用<code>removeRange(_:)</code>方法可以在一个字符串的指定索引删除一个子字符串。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> range = welcome.endIndex.advancedBy(-<span class="number">6</span>)..&lt;welcome.endIndex</span><br><span class="line">welcome.removeRange(range)</span><br><span class="line"><span class="comment">// welcome 现在等于 "hello"</span></span><br></pre></td></tr></table></figure>
<p><a name="comparing_strings"></a></p>
<h2 id="比较字符串_(Comparing_Strings)">比较字符串 (Comparing Strings)</h2><p>Swift 提供了三种方式来比较文本值：字符串字符相等、前缀相等和后缀相等。</p>
<p><a name="string_and_character_equality"></a></p>
<h3 id="字符串/字符相等_(String_and_Character_Equality)">字符串/字符相等 (String and Character Equality)</h3><p>字符串/字符可以用等于操作符(<code>==</code>)和不等于操作符(<code>!=</code>)，详细描述在<a href="./02_Basic_Operators.html#comparison_operators">比较运算符</a>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> quotation = <span class="string">"We're a lot alike, you and I."</span></span><br><span class="line"><span class="keyword">let</span> sameQuotation = <span class="string">"We're a lot alike, you and I."</span></span><br><span class="line"><span class="keyword">if</span> quotation == sameQuotation &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"These two strings are considered equal"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印输出 "These two strings are considered equal"</span></span><br></pre></td></tr></table></figure>
<p>如果两个字符串（或者两个字符）的可扩展的字形群集是标准相等的，那就认为它们是相等的。在这个情况下，即使可扩展的字形群集是有不同的 Unicode 标量构成的，只要它们有同样的语言意义和外观，就认为它们标准相等。</p>
<p>例如，<code>LATIN SMALL LETTER E WITH ACUTE</code>(<code>U+00E9</code>)就是标准相等于<code>LATIN SMALL LETTER E</code>(<code>U+0065</code>)后面加上<code>COMBINING ACUTE ACCENT</code>(<code>U+0301</code>)。这两个字符群集都是表示字符<code>é</code>的有效方式，所以它们被认为是标准相等的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// "Voulez-vous un café?" 使用 LATIN SMALL LETTER E WITH ACUTE</span></span><br><span class="line"><span class="keyword">let</span> eAcuteQuestion = <span class="string">"Voulez-vous un caf\u&#123;E9&#125;?"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// "Voulez-vous un café?" 使用 LATIN SMALL LETTER E and COMBINING ACUTE ACCENT</span></span><br><span class="line"><span class="keyword">let</span> combinedEAcuteQuestion = <span class="string">"Voulez-vous un caf\u&#123;65&#125;\u&#123;301&#125;?"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> eAcuteQuestion == combinedEAcuteQuestion &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"These two strings are considered equal"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印输出 "These two strings are considered equal"</span></span><br></pre></td></tr></table></figure>
<p>相反，英语中的<code>LATIN CAPITAL LETTER A</code>(<code>U+0041</code>，或者<code>A</code>)不等于俄语中的<code>CYRILLIC CAPITAL LETTER A</code>(<code>U+0410</code>，或者<code>A</code>)。两个字符看着是一样的，但却有不同的语言意义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> latinCapitalLetterA: <span class="type">Character</span> = <span class="string">"\u&#123;41&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cyrillicCapitalLetterA: <span class="type">Character</span> = <span class="string">"\u&#123;0410&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> latinCapitalLetterA != cyrillicCapitalLetterA &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"These two characters are not equivalent"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "These two characters are not equivalent"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>在 Swift 中，字符串和字符并不区分区域。</p>
</blockquote>
<p><a name="prefix_and_suffix_equality"></a></p>
<h3 id="前缀/后缀相等_(Prefix_and_Suffix_Equality)">前缀/后缀相等 (Prefix and Suffix Equality)</h3><p>通过调用字符串的<code>hasPrefix(_:)</code>/<code>hasSuffix(_:)</code>方法来检查字符串是否拥有特定前缀/后缀，两个方法均接收一个<code>String</code>类型的参数，并返回一个布尔值。</p>
<p>下面的例子以一个字符串数组表示莎士比亚话剧《罗密欧与朱丽叶》中前两场的场景位置：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> romeoAndJuliet = [</span><br><span class="line">    <span class="string">"Act 1 Scene 1: Verona, A public place"</span>,</span><br><span class="line">    <span class="string">"Act 1 Scene 2: Capulet's mansion"</span>,</span><br><span class="line">    <span class="string">"Act 1 Scene 3: A room in Capulet's mansion"</span>,</span><br><span class="line">    <span class="string">"Act 1 Scene 4: A street outside Capulet's mansion"</span>,</span><br><span class="line">    <span class="string">"Act 1 Scene 5: The Great Hall in Capulet's mansion"</span>,</span><br><span class="line">    <span class="string">"Act 2 Scene 1: Outside Capulet's mansion"</span>,</span><br><span class="line">    <span class="string">"Act 2 Scene 2: Capulet's orchard"</span>,</span><br><span class="line">    <span class="string">"Act 2 Scene 3: Outside Friar Lawrence's cell"</span>,</span><br><span class="line">    <span class="string">"Act 2 Scene 4: A street in Verona"</span>,</span><br><span class="line">    <span class="string">"Act 2 Scene 5: Capulet's mansion"</span>,</span><br><span class="line">    <span class="string">"Act 2 Scene 6: Friar Lawrence's cell"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>您可以调用<code>hasPrefix(_:)</code>方法来计算话剧中第一幕的场景数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> act1SceneCount = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> scene <span class="keyword">in</span> romeoAndJuliet &#123;</span><br><span class="line">    <span class="keyword">if</span> scene.hasPrefix(<span class="string">"Act 1 "</span>) &#123;</span><br><span class="line">        ++act1SceneCount</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"There are <span class="subst">\(act1SceneCount)</span> scenes in Act 1"</span>)</span><br><span class="line"><span class="comment">// 打印输出 "There are 5 scenes in Act 1"</span></span><br></pre></td></tr></table></figure>
<p>相似地，您可以用<code>hasSuffix(_:)</code>方法来计算发生在不同地方的场景数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mansionCount = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> cellCount = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> scene <span class="keyword">in</span> romeoAndJuliet &#123;</span><br><span class="line">    <span class="keyword">if</span> scene.hasSuffix(<span class="string">"Capulet's mansion"</span>) &#123;</span><br><span class="line">        ++mansionCount</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> scene.hasSuffix(<span class="string">"Friar Lawrence's cell"</span>) &#123;</span><br><span class="line">        ++cellCount</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(mansionCount)</span> mansion scenes; <span class="subst">\(cellCount)</span> cell scenes"</span>)</span><br><span class="line"><span class="comment">// 打印输出 "6 mansion scenes; 2 cell scenes"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br><code>hasPrefix(_:)</code>和<code>hasSuffix(_:)</code>方法都是在每个字符串中逐字符比较其可扩展的字符群集是否标准相等，详细描述在<a href="#string_and_character_equality">字符串/字符相等</a>。</p>
</blockquote>
<p><a name="unicode_representations_of_strings"></a></p>
<h2 id="字符串的_Unicode_表示形式（Unicode_Representations_of_Strings）">字符串的 Unicode 表示形式（Unicode Representations of Strings）</h2><p>当一个 Unicode 字符串被写进文本文件或者其他储存时，字符串中的 Unicode 标量会用 Unicode 定义的几种编码格式编码。每一个字符串中的小块编码都被称为代码单元。这些包括 UTF-8 编码格式（编码字符串为8位的代码单元）， UTF-16 编码格式（编码字符串位16位的代码单元），以及 UTF-32 编码格式（编码字符串32位的代码单元）。</p>
<p>Swift 提供了几种不同的方式来访问字符串的 Unicode 表示形式。<br>您可以利用<code>for-in</code>来对字符串进行遍历，从而以 Unicode 可扩展的字符群集的方式访问每一个<code>Character</code>值。<br>该过程在 <a href="#working_with_characters">使用字符</a> 中进行了描述。</p>
<p>另外，能够以其他三种 Unicode 兼容的方式访问字符串的值：</p>
<ul>
<li>UTF-8 代码单元集合 (利用字符串的<code>utf8</code>属性进行访问)</li>
<li>UTF-16 代码单元集合 (利用字符串的<code>utf16</code>属性进行访问)</li>
<li>21位的 Unicode 标量值集合，也就是字符串的 UTF-32 编码格式 (利用字符串的<code>unicodeScalars</code>属性进行访问)</li>
</ul>
<p>下面由<code>D``o``g``‼</code>(<code>DOUBLE EXCLAMATION MARK</code>, Unicode 标量 <code>U+203C</code>)和<code>�</code>(<code>DOG FACE</code>，Unicode 标量为<code>U+1F436</code>)组成的字符串中的每一个字符代表着一种不同的表示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dogString = <span class="string">"Dog‼🐶"</span></span><br></pre></td></tr></table></figure>
<p><a name="UTF-8_representation"></a></p>
<h3 id="UTF-8_表示">UTF-8 表示</h3><p>您可以通过遍历<code>String</code>的<code>utf8</code>属性来访问它的<code>UTF-8</code>表示。<br>其为<code>String.UTF8View</code>类型的属性，<code>UTF8View</code>是无符号8位 (<code>UInt8</code>) 值的集合，每一个<code>UInt8</code>值都是一个字符的 UTF-8 表示：</p>
<table style="text-align:center"><br> <tr height="77"><br>  <td>Character</td><br>  <td>D<br>U+0044</td><br>  <td>o<br>U+006F</td><br>  <td>g<br>U+0067</td><br>  <td colspan="3">‼<br>U+203C</td><br>  <td colspan="4">🐶<br>U+1F436</td><br> </tr><br> <tr height="77"><br>  <td height="77">UTF-8<br>Code Unit</td><br>  <td>68</td><br>  <td>111</td><br>  <td>103</td><br>  <td>226</td><br>  <td>128</td><br>  <td>188</td><br>  <td>240</td><br>  <td>159</td><br>  <td>144</td><br>  <td>182</td><br> </tr><br> <tr><br>  <td height="77">Position</td><br>  <td>0</td><br>  <td>1</td><br>  <td>2</td><br>  <td>3</td><br>  <td>4</td><br>  <td>5</td><br>  <td>6</td><br>  <td>7</td><br>  <td>8</td><br>  <td>9</td><br> </tr><br></table>


<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> codeUnit <span class="keyword">in</span> dogString.utf8 &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(codeUnit)</span> "</span>, terminator: <span class="string">""</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">""</span>)</span><br><span class="line"><span class="comment">// 68 111 103 226 128 188 240 159 144 182</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，前三个10进制<code>codeUnit</code>值 (<code>68</code>, <code>111</code>, <code>103</code>) 代表了字符<code>D</code>、<code>o</code>和 <code>g</code>，它们的 UTF-8 表示与 ASCII 表示相同。<br>接下来的三个10进制<code>codeUnit</code>值 (<code>226</code>, <code>128</code>, <code>188</code>) 是<code>DOUBLE EXCLAMATION MARK</code>的3字节 UTF-8 表示。<br>最后的四个<code>codeUnit</code>值 (<code>240</code>, <code>159</code>, <code>144</code>, <code>182</code>) 是<code>DOG FACE</code>的4字节 UTF-8 表示。</p>
<p><a name="UTF-16_representation"></a></p>
<h3 id="UTF-16_表示">UTF-16 表示</h3><p>您可以通过遍历<code>String</code>的<code>utf16</code>属性来访问它的<code>UTF-16</code>表示。<br>其为<code>String.UTF16View</code>类型的属性，<code>UTF16View</code>是无符号16位 (<code>UInt16</code>) 值的集合，每一个<code>UInt16</code>都是一个字符的 UTF-16 表示：</p>
<table style="text-align:center"><br> <tr height="77"><br>  <td>Character</td><br>  <td>D<br>U+0044</td><br>  <td>o<br>U+006F</td><br>  <td>g<br>U+0067</td><br>  <td>‼<br>U+203C</td><br>  <td colspan="2">🐶<br>U+1F436</td><br> </tr><br> <tr height="77"><br>  <td height="77">UTF-16<br>Code Unit</td><br>  <td>68</td><br>  <td>111</td><br>  <td>103</td><br>  <td>8252</td><br>  <td>55357</td><br>  <td>56374</td><br> </tr><br> <tr><br>  <td height="77">Position</td><br>  <td>0</td><br>  <td>1</td><br>  <td>2</td><br>  <td>3</td><br>  <td>4</td><br>  <td>5</td><br> </tr><br></table>


<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> codeUnit <span class="keyword">in</span> dogString.utf16 &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(codeUnit)</span> "</span>, terminator: <span class="string">""</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">""</span>)</span><br><span class="line"><span class="comment">// 68 111 103 8252 55357 56374</span></span><br></pre></td></tr></table></figure>
<p>同样，前三个<code>codeUnit</code>值 (<code>68</code>, <code>111</code>, <code>103</code>) 代表了字符<code>D</code>、<code>o</code>和<code>g</code>，它们的 UTF-16 代码单元和 UTF-8 完全相同（因为这些 Unicode 标量表示 ASCII 字符）。</p>
<p>第四个<code>codeUnit</code>值 (<code>8252</code>) 是一个等于十六进制<code>203C</code>的的十进制值。这个代表了<code>DOUBLE EXCLAMATION MARK</code>字符的 Unicode 标量值<code>U+203C</code>。这个字符在 UTF-16 中可以用一个代码单元表示。</p>
<p>第五和第六个<code>codeUnit</code>值 (<code>55357</code>和<code>56374</code>) 是<code>DOG FACE</code>字符的 UTF-16 表示。<br>第一个值为<code>U+D83D</code>(十进制值为<code>55357</code>)，第二个值为<code>U+DC36</code>(十进制值为<code>56374</code>)。</p>
<p><a name="unicode_scalars_representation"></a></p>
<h3 id="Unicode_标量表示_(Unicode_Scalars_Representation)">Unicode 标量表示 (Unicode Scalars Representation)</h3><p>您可以通过遍历<code>String</code>值的<code>unicodeScalars</code>属性来访问它的 Unicode 标量表示。<br>其为<code>UnicodeScalarView</code>类型的属性，<code>UnicodeScalarView</code>是<code>UnicodeScalar</code>的集合。<br><code>UnicodeScalar</code>是21位的 Unicode 代码点。</p>
<p>每一个<code>UnicodeScalar</code>拥有一个<code>value</code>属性，可以返回对应的21位数值，用<code>UInt32</code>来表示：</p>
<table style="text-align:center"><br> <tr height="77"><br>  <td>Character</td><br>  <td>D<br>U+0044</td><br>  <td>o<br>U+006F</td><br>  <td>g<br>U+0067</td><br>  <td>‼<br>U+203C</td><br>  <td>🐶<br>U+1F436</td><br> </tr><br> <tr height="77"><br>  <td height="77">UTF-16<br>Code Unit</td><br>  <td>68</td><br>  <td>111</td><br>  <td>103</td><br>  <td>8252</td><br>  <td>128054</td><br> </tr><br> <tr><br>  <td height="77">Position</td><br>  <td>0</td><br>  <td>1</td><br>  <td>2</td><br>  <td>3</td><br>  <td>4</td><br> </tr><br></table>


<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> scalar <span class="keyword">in</span> dogString.unicodeScalars &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(scalar.value)</span> "</span>, terminator: <span class="string">""</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">""</span>)</span><br><span class="line"><span class="comment">// 68 111 103 8252 128054</span></span><br></pre></td></tr></table></figure>
<p>前三个<code>UnicodeScalar</code>值(<code>68</code>, <code>111</code>, <code>103</code>)的<code>value</code>属性仍然代表字符<code>D</code>、<code>o</code>和<code>g</code>。<br>第四个<code>codeUnit</code>值(<code>8252</code>)仍然是一个等于十六进制<code>203C</code>的十进制值。这个代表了<code>DOUBLE EXCLAMATION MARK</code>字符的 Unicode 标量<code>U+203C</code>。</p>
<p>第五个<code>UnicodeScalar</code>值的<code>value</code>属性，<code>128054</code>，是一个十六进制<code>1F436</code>的十进制表示。其等同于<code>DOG FACE</code>的 Unicode 标量<code>U+1F436</code>。</p>
<p>作为查询它们的<code>value</code>属性的一种替代方法，每个<code>UnicodeScalar</code>值也可以用来构建一个新的<code>String</code>值，比如在字符串插值中使用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> scalar <span class="keyword">in</span> dogString.unicodeScalars &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(scalar)</span> "</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// D</span></span><br><span class="line"><span class="comment">// o</span></span><br><span class="line"><span class="comment">// g</span></span><br><span class="line"><span class="comment">// ‼</span></span><br><span class="line"><span class="comment">// 🐶</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="字符串和字符（Strings_and_Characters）">字符串和字符（Strings and Characters）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/wh1100]]>
    </summary>
    
      <category term="swift-cn" scheme="http://yoursite.com/tags/swift-cn/"/>
    
      <category term="swift-cn" scheme="http://yoursite.com/categories/swift-cn/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第二章-04集合类型 (Collection Types)]]></title>
    <link href="http://yoursite.com/2015/12/25/swift-cn/chapter2/04_Collection_Types/"/>
    <id>http://yoursite.com/2015/12/25/swift-cn/chapter2/04_Collection_Types/</id>
    <published>2015-12-25T04:00:23.000Z</published>
    <updated>2015-12-15T05:44:44.975Z</updated>
    <content type="html"><![CDATA[<h1 id="集合类型_(Collection_Types)">集合类型 (Collection Types)</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/zqp" target="_blank" rel="external">zqp</a><br>校对：<a href="https://github.com/shinyzhu" target="_blank" rel="external">shinyzhu</a>, <a href="https://github.com/stanzhai" target="_blank" rel="external">stanzhai</a>, <a href="https://github.com/feiin" target="_blank" rel="external">feiin</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/AlanMelody" target="_blank" rel="external">JackAlan</a></p>
<p>2.1<br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#mutability_of_collections">集合的可变性（Mutability of Collections）</a></li>
<li><a href="#arrays">数组（Arrays）</a></li>
<li><a href="#sets">集合（Sets）</a></li>
<li><a href="#dictionaries">字典（Dictionaries）</a></li>
</ul>
<p>Swift 语言提供<code>Arrays</code>、<code>Sets</code>和<code>Dictionaries</code>三种基本的集合类型用来存储集合数据。数组（Arrays）是有序数据的集。集合（Sets）是无序无重复数据的集。字典（Dictionaries）是无序的键值对的集。</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/CollectionTypes_intro_2x.png" alt=""></p>
<p>Swift 语言中的<code>Arrays</code>、<code>Sets</code>和<code>Dictionaries</code>中存储的数据值类型必须明确。这意味着我们不能把不正确的数据类型插入其中。同时这也说明我们完全可以对取回值的类型非常自信。</p>
<blockquote>
<p>注意：<br>Swift 的<code>Arrays</code>、<code>Sets</code>和<code>Dictionaries</code>类型被实现为<em>泛型集合</em>。更多关于泛型类型和集合，参见 <a href="./23_Generics.html">泛型</a>章节。</p>
</blockquote>
<p><a name="mutability_of_collections"></a></p>
<h2 id="集合的可变性">集合的可变性</h2><p>如果创建一个<code>Arrays</code>、<code>Sets</code>或<code>Dictionaries</code>并且把它分配成一个变量，这个集合将会是<em>可变的</em>。这意味着我们可以在创建之后添加更多或移除已存在的数据项，或者改变集合中的数据项。如果我们把<code>Arrays</code>、<code>Sets</code>或<code>Dictionaries</code>分配成常量，那么它就是<em>不可变的</em>，它的大小和内容都不能被改变。</p>
<blockquote>
<p>注意：<br>在我们不需要改变集合的时候创建不可变集合是很好的实践。如此 Swift 编译器可以优化我们创建的集合。</p>
</blockquote>
<p><a name="arrays"></a></p>
<h2 id="数组(Arrays)">数组(Arrays)</h2><p>数组使用有序列表存储同一类型的多个值。相同的值可以多次出现在一个数组的不同位置中。</p>
<blockquote>
<p>注意:<br> Swift 的<code>Array</code>类型被桥接到<code>Foundation</code>中的<code>NSArray</code>类。<br> 更多关于在<code>Foundation</code>和<code>Cocoa</code>中使用<code>Array</code>的信息，参见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216" target="_blank" rel="external"><em>Using Swift with Cocoa and Obejective-C</em></a> 一书。</p>
</blockquote>
<p><a name="array_type_shorthand_syntax"></a></p>
<h3 id="数组的简单语法">数组的简单语法</h3><p>写 Swift 数组应该遵循像<code>Array&lt;Element&gt;</code>这样的形式，其中<code>Element</code>是这个数组中唯一允许存在的数据类型。我们也可以使用像<code>[Element]</code>这样的简单语法。尽管两种形式在功能上是一样的，但是推荐较短的那种，而且在本文中都会使用这种形式来使用数组。</p>
<p><a name="creating_an_empty_array"></a></p>
<h3 id="创建一个空数组">创建一个空数组</h3><p>我们可以使用构造语法来创建一个由特定数据类型构成的空数组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someInts = [<span class="type">Int</span>]()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"someInts is of type [Int] with <span class="subst">\(someInts.<span class="built_in">count</span>)</span> items."</span>)</span><br><span class="line"><span class="comment">// 打印 "someInts is of type [Int] with 0 items."</span></span><br></pre></td></tr></table></figure>
<p>注意，通过构造函数的类型，<code>someInts</code>的值类型被推断为<code>[Int]</code>。</p>
<p>或者，如果代码上下文中已经提供了类型信息，例如一个函数参数或者一个已经定义好类型的常量或者变量，我们可以使用空数组语句创建一个空数组，它的写法很简单：<code>[]</code>（一对空方括号）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">someInts.append(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// someInts 现在包含一个 Int 值</span></span><br><span class="line">someInts = []</span><br><span class="line"><span class="comment">// someInts 现在是空数组，但是仍然是 [Int] 类型的。</span></span><br></pre></td></tr></table></figure>
<p><a name="creating_an_array_with_a_default_value"></a></p>
<h3 id="创建一个带有默认值的数组">创建一个带有默认值的数组</h3><p>Swift 中的<code>Array</code>类型还提供一个可以创建特定大小并且所有数据都被默认的构造方法。我们可以把准备加入新数组的数据项数量（<code>count</code>）和适当类型的初始值（<code>repeatedValue</code>）传入数组构造函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> threeDoubles = [<span class="type">Double</span>](<span class="built_in">count</span>: <span class="number">3</span>, repeatedValue:<span class="number">0.0</span>)</span><br><span class="line"><span class="comment">// threeDoubles 是一种 [Double] 数组，等价于 [0.0, 0.0, 0.0]</span></span><br></pre></td></tr></table></figure>
<p><a name="creating_an_array_by_adding_two_arrays_together"></a></p>
<h3 id="通过两个数组相加创建一个数组">通过两个数组相加创建一个数组</h3><p>我们可以使用加法操作符（<code>+</code>）来组合两种已存在的相同类型数组。新数组的数据类型会被从两个数组的数据类型中推断出来：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anotherThreeDoubles = <span class="type">Array</span>(<span class="built_in">count</span>: <span class="number">3</span>, repeatedValue: <span class="number">2.5</span>)</span><br><span class="line"><span class="comment">// anotherThreeDoubles 被推断为 [Double]，等价于 [2.5, 2.5, 2.5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sixDoubles = threeDoubles + anotherThreeDoubles</span><br><span class="line"><span class="comment">// sixDoubles 被推断为 [Double]，等价于 [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]</span></span><br></pre></td></tr></table></figure>
<p><a name="creating_an_array_with_an_array_literals"></a></p>
<h3 id="用字面量构造数组">用字面量构造数组</h3><p>我们可以使用字面量来进行数组构造，这是一种用一个或者多个数值构造数组的简单方法。字面量是一系列由逗号分割并由方括号包含的数值：</p>
<p><code>[value 1, value 2, value 3]</code>。</p>
<p>下面这个例子创建了一个叫做<code>shoppingList</code>并且存储<code>String</code>的数组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shoppingList: [<span class="type">String</span>] = [<span class="string">"Eggs"</span>, <span class="string">"Milk"</span>]</span><br><span class="line"><span class="comment">// shoppingList 已经被构造并且拥有两个初始项。</span></span><br></pre></td></tr></table></figure>
<p><code>shoppingList</code>变量被声明为“字符串值类型的数组“，记作<code>[String]</code>。 因为这个数组被规定只有<code>String</code>一种数据结构，所以只有<code>String</code>类型可以在其中被存取。 在这里，<code>shoppinglist</code>数组由两个<code>String</code>值（<code>&quot;Eggs&quot;</code> 和<code>&quot;Milk&quot;</code>）构造，并且由字面量定义。</p>
<blockquote>
<p>注意：<br><code>Shoppinglist</code>数组被声明为变量（<code>var</code>关键字创建）而不是常量（<code>let</code>创建）是因为以后可能会有更多的数据项被插入其中。</p>
</blockquote>
<p>在这个例子中，字面量仅仅包含两个<code>String</code>值。匹配了该数组的变量声明（只能包含<code>String</code>的数组），所以这个字面量的分配过程可以作为用两个初始项来构造<code>shoppinglist</code>的一种方式。</p>
<p>由于 Swift 的类型推断机制，当我们用字面量构造只拥有相同类型值数组的时候，我们不必把数组的类型定义清楚。 <code>shoppinglist</code>的构造也可以这样写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shoppingList = [<span class="string">"Eggs"</span>, <span class="string">"Milk"</span>]</span><br></pre></td></tr></table></figure>
<p>因为所有字面量中的值都是相同的类型，Swift 可以推断出<code>[String]</code>是<code>shoppinglist</code>中变量的正确类型。</p>
<p><a name="accessing_and_modifying_an_array"></a></p>
<h3 id="访问和修改数组">访问和修改数组</h3><p>我们可以通过数组的方法和属性来访问和修改数组，或者使用下标语法。</p>
<p>可以使用数组的只读属性<code>count</code>来获取数组中的数据项数量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"The shopping list contains <span class="subst">\(shoppingList.<span class="built_in">count</span>)</span> items."</span>)</span><br><span class="line"><span class="comment">// 输出 "The shopping list contains 2 items."（这个数组有2个项）</span></span><br></pre></td></tr></table></figure>
<p>使用布尔值属性<code>isEmpty</code>作为检查<code>count</code>属性的值是否为 0 的捷径：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> shoppingList.isEmpty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The shopping list is empty."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The shopping list is not empty."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "The shopping list is not empty."（shoppinglist 不是空的）</span></span><br></pre></td></tr></table></figure>
<p>也可以使用<code>append(_:)</code>方法在数组后面添加新的数据项：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shoppingList.append(<span class="string">"Flour"</span>)</span><br><span class="line"><span class="comment">// shoppingList 现在有3个数据项，有人在摊煎饼</span></span><br></pre></td></tr></table></figure>
<p>除此之外，使用加法赋值运算符（<code>+=</code>）也可以直接在数组后面添加一个或多个拥有相同类型的数据项：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shoppingList += [<span class="string">"Baking Powder"</span>]</span><br><span class="line"><span class="comment">// shoppingList 现在有四项了</span></span><br><span class="line">shoppingList += [<span class="string">"Chocolate Spread"</span>, <span class="string">"Cheese"</span>, <span class="string">"Butter"</span>]</span><br><span class="line"><span class="comment">// shoppingList 现在有七项了</span></span><br></pre></td></tr></table></figure>
<p>可以直接使用下标语法来获取数组中的数据项，把我们需要的数据项的索引值放在直接放在数组名称的方括号中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstItem = shoppingList[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 第一项是 "Eggs"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>第一项在数组中的索引值是<code>0</code>而不是<code>1</code>。 Swift 中的数组索引总是从零开始。</p>
</blockquote>
<p>我们也可以用下标来改变某个已有索引值对应的数据值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shoppingList[<span class="number">0</span>] = <span class="string">"Six eggs"</span></span><br><span class="line"><span class="comment">// 其中的第一项现在是 "Six eggs" 而不是 "Eggs"</span></span><br></pre></td></tr></table></figure>
<p>还可以利用下标来一次改变一系列数据值，即使新数据和原有数据的数量是不一样的。下面的例子把<code>&quot;Chocolate Spread&quot;</code>，<code>&quot;Cheese&quot;</code>，和<code>&quot;Butter&quot;</code>替换为<code>&quot;Bananas&quot;</code>和 <code>&quot;Apples&quot;</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shoppingList[<span class="number">4</span>...<span class="number">6</span>] = [<span class="string">"Bananas"</span>, <span class="string">"Apples"</span>]</span><br><span class="line"><span class="comment">// shoppingList 现在有6项</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>不可以用下标访问的形式去在数组尾部添加新项。</p>
</blockquote>
<p>调用数组的<code>insert(_:atIndex:)</code>方法来在某个具体索引值之前添加数据项：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shoppingList.insert(<span class="string">"Maple Syrup"</span>, atIndex: <span class="number">0</span>)</span><br><span class="line"><span class="comment">// shoppingList 现在有7项</span></span><br><span class="line"><span class="comment">// "Maple Syrup" 现在是这个列表中的第一项</span></span><br></pre></td></tr></table></figure>
<p>这次<code>insert(_:atIndex:)</code>方法调用把值为<code>&quot;Maple Syrup&quot;</code>的新数据项插入列表的最开始位置，并且使用<code>0</code>作为索引值。</p>
<p>类似的我们可以使用<code>removeAtIndex(_:)</code>方法来移除数组中的某一项。这个方法把数组在特定索引值中存储的数据项移除并且返回这个被移除的数据项（我们不需要的时候就可以无视它）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mapleSyrup = shoppingList.removeAtIndex(<span class="number">0</span>)</span><br><span class="line"><span class="comment">// 索引值为0的数据项被移除</span></span><br><span class="line"><span class="comment">// shoppingList 现在只有6项，而且不包括 Maple Syrup</span></span><br><span class="line"><span class="comment">// mapleSyrup 常量的值等于被移除数据项的值 "Maple Syrup"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>如果我们试着对索引越界的数据进行检索或者设置新值的操作，会引发一个运行期错误。我们可以使用索引值和数组的<code>count</code>属性进行比较来在使用某个索引之前先检验是否有效。除了当<code>count</code>等于 0 时（说明这是个空数组），最大索引值一直是<code>count - 1</code>，因为数组都是零起索引。</p>
</blockquote>
<p>数据项被移除后数组中的空出项会被自动填补，所以现在索引值为<code>0</code>的数据项的值再次等于<code>&quot;Six eggs&quot;</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firstItem = shoppingList[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// firstItem 现在等于 "Six eggs"</span></span><br></pre></td></tr></table></figure>
<p>如果我们只想把数组中的最后一项移除，可以使用<code>removeLast()</code>方法而不是<code>removeAtIndex(_:)</code>方法来避免我们需要获取数组的<code>count</code>属性。就像后者一样，前者也会返回被移除的数据项：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> apples = shoppingList.removeLast()</span><br><span class="line"><span class="comment">// 数组的最后一项被移除了</span></span><br><span class="line"><span class="comment">// shoppingList 现在只有5项，不包括 cheese</span></span><br><span class="line"><span class="comment">// apples 常量的值现在等于 "Apples" 字符串</span></span><br></pre></td></tr></table></figure>
<p><a name="iterating_over_an_array"></a></p>
<h3 id="数组的遍历">数组的遍历</h3><p>我们可以使用<code>for-in</code>循环来遍历所有数组中的数据项：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> shoppingList &#123;</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Six eggs</span></span><br><span class="line"><span class="comment">// Milk</span></span><br><span class="line"><span class="comment">// Flour</span></span><br><span class="line"><span class="comment">// Baking Powder</span></span><br><span class="line"><span class="comment">// Bananas</span></span><br></pre></td></tr></table></figure>
<p>如果我们同时需要每个数据项的值和索引值，可以使用<code>enumerate()</code>方法来进行数组遍历。<code>enumerate()</code>返回一个由每一个数据项索引值和数据值组成的元组。我们可以把这个元组分解成临时常量或者变量来进行遍历：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (index, value) <span class="keyword">in</span> shoppingList.<span class="built_in">enumerate</span>() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Item <span class="subst">\(String(index + <span class="number">1</span>)</span>): <span class="subst">\(value)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Item 1: Six eggs</span></span><br><span class="line"><span class="comment">// Item 2: Milk</span></span><br><span class="line"><span class="comment">// Item 3: Flour</span></span><br><span class="line"><span class="comment">// Item 4: Baking Powder</span></span><br><span class="line"><span class="comment">// Item 5: Bananas</span></span><br></pre></td></tr></table></figure>
<p>更多关于<code>for-in</code>循环的介绍请参见<a href="05_Control_Flow.html#for_loops">for 循环</a>。</p>
<p><a name="sets"></a></p>
<h2 id="集合（Sets）">集合（Sets）</h2><p><em>集合(Set)</em>用来存储相同类型并且没有确定顺序的值。当集合元素顺序不重要时或者希望确保每个元素只出现一次时可以使用集合而不是数组。</p>
<blockquote>
<p>注意：<br>Swift的<code>Set</code>类型被桥接到<code>Foundation</code>中的<code>NSSet</code>类。<br>关于使用<code>Foundation</code>和<code>Cocoa</code>中<code>Set</code>的知识，请看 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216" target="_blank" rel="external"><em>Using Swift with Cocoa and Objective-C</em></a>。</p>
</blockquote>
<p><a name="hash_values_for_set_types"></a></p>
<h4 id="集合类型的哈希值">集合类型的哈希值</h4><p>一个类型为了存储在集合中，该类型必须是可哈希化的–也就是说，该类型必须提供一个方法来计算它的哈希值。一个哈希值是<code>Int</code>类型的，相等的对象哈希值必须相同，比如<code>a==b</code>,因此必须<code>a.hashValue == b.hashValue</code>。</p>
<p>Swift 的所有基本类型(比如<code>String</code>,<code>Int</code>,<code>Double</code>和<code>Bool</code>)默认都是可哈希化的，可以作为集合的值的类型或者字典的键的类型。没有关联值的枚举成员值(在<a href="./08_Enumerations.html">枚举</a>有讲述)默认也是可哈希化的。</p>
<blockquote>
<p>注意：<br>你可以使用你自定义的类型作为集合的值的类型或者是字典的键的类型，但你需要使你的自定义类型符合 Swift 标准库中的<code>Hashable</code>协议。符合<code>Hashable</code>协议的类型需要提供一个类型为<code>Int</code>的可读属性<code>hashValue</code>。由类型的<code>hashValue</code>属性返回的值不需要在同一程序的不同执行周期或者不同程序之间保持相同。  </p>
<p>因为<code>Hashable</code>协议符合<code>Equatable</code>协议，所以符合该协议的类型也必须提供一个”是否相等”运算符(<code>==</code>)的实现。这个<code>Equatable</code>协议要求任何符合<code>==</code>实现的实例间都是一种相等的关系。也就是说，对于<code>a,b,c</code>三个值来说，<code>==</code>的实现必须满足下面三种情况：</p>
<ul>
<li><code>a == a</code>(自反性)</li>
<li><code>a == b</code>意味着<code>b == a</code>(对称性)</li>
<li><code>a == b &amp;&amp; b == c</code>意味着<code>a == c</code>(传递性)</li>
</ul>
</blockquote>
<p>关于符合协议的更多信息，请看<a href="./22_Protocols.html">协议</a>。</p>
<p><a name="set_type_syntax"></a></p>
<h3 id="集合类型语法">集合类型语法</h3><p>Swift 中的<code>Set</code>类型被写为<code>Set&lt;Element&gt;</code>，这里的<code>Element</code>表示<code>Set</code>中允许存储的类型，和数组不同的是，集合没有等价的简化形式。</p>
<p><a name="creating_and_initalizing_an_empty_set"></a></p>
<h3 id="创建和构造一个空的集合">创建和构造一个空的集合</h3><p>你可以通过构造器语法创建一个特定类型的空集合：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> letters = <span class="type">Set</span>&lt;<span class="type">Character</span>&gt;()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"letters is of type Set&lt;Character&gt; with <span class="subst">\(letters.<span class="built_in">count</span>)</span> items."</span>)</span><br><span class="line"><span class="comment">// 打印 "letters is of type Set&lt;Character&gt; with 0 items."</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>通过构造器，这里的<code>letters</code>变量的类型被推断为<code>Set&lt;Character&gt;</code>。</p>
</blockquote>
<p>此外，如果上下文提供了类型信息，比如作为函数的参数或者已知类型的变量或常量，我们可以通过一个空的数组字面量创建一个空的<code>Set</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">letters.insert(<span class="string">"a"</span>)</span><br><span class="line"><span class="comment">// letters 现在含有1个 Character 类型的值</span></span><br><span class="line">letters = []</span><br><span class="line"><span class="comment">// letters 现在是一个空的 Set, 但是它依然是 Set&lt;Character&gt; 类型</span></span><br></pre></td></tr></table></figure>
<p><a name="creating_a_set_with_an_array_literal"></a></p>
<h3 id="用数组字面量创建集合">用数组字面量创建集合</h3><p>你可以使用数组字面量来构造集合，并且可以使用简化形式写一个或者多个值作为集合元素。</p>
<p>下面的例子创建一个称之为<code>favoriteGenres</code>的集合来存储<code>String</code>类型的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> favoriteGenres: <span class="type">Set</span>&lt;<span class="type">String</span>&gt; = [<span class="string">"Rock"</span>, <span class="string">"Classical"</span>, <span class="string">"Hip hop"</span>]</span><br><span class="line"><span class="comment">// favoriteGenres 被构造成含有三个初始值的集合</span></span><br></pre></td></tr></table></figure>
<p>这个<code>favoriteGenres</code>变量被声明为“一个<code>String</code>值的集合”，写为<code>Set&lt;String&gt;</code>。由于这个特定的集合含有指定<code>String</code>类型的值，所以它只允许存储<code>String</code>类型值。这里的<code>favoriteGenres</code>变量有三个<code>String</code>类型的初始值(<code>&quot;Rock&quot;</code>，<code>&quot;Classical&quot;</code>和<code>&quot;Hip hop&quot;</code>)，并以数组字面量的方式出现。</p>
<blockquote>
<p>注意：<br><code>favoriteGenres</code>被声明为一个变量(拥有<code>var</code>标示符)而不是一个常量(拥有<code>let</code>标示符),因为它里面的元素将会在下面的例子中被增加或者移除。</p>
</blockquote>
<p>一个<code>Set</code>类型不能从数组字面量中被单独推断出来，因此<code>Set</code>类型必须显式声明。然而，由于 Swift 的类型推断功能，如果你想使用一个数组字面量构造一个<code>Set</code>并且该数组字面量中的所有元素类型相同，那么你无须写出<code>Set</code>的具体类型。<code>favoriteGenres</code>的构造形式可以采用简化的方式代替：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> favoriteGenres: <span class="type">Set</span> = [<span class="string">"Rock"</span>, <span class="string">"Classical"</span>, <span class="string">"Hip hop"</span>]</span><br></pre></td></tr></table></figure>
<p>由于数组字面量中的所有元素类型相同，Swift 可以推断出<code>Set&lt;String&gt;</code>作为<code>favoriteGenres</code>变量的正确类型。</p>
<p><a name="accesing_and_modifying_a_set"></a></p>
<h3 id="访问和修改一个集合">访问和修改一个集合</h3><p>你可以通过<code>Set</code>的属性和方法来访问和修改一个<code>Set</code>。</p>
<p>为了找出一个<code>Set</code>中元素的数量，可以使用其只读属性<code>count</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"I have <span class="subst">\(favoriteGenres.<span class="built_in">count</span>)</span> favorite music genres."</span>)</span><br><span class="line"><span class="comment">// 打印 "I have 3 favorite music genres."</span></span><br></pre></td></tr></table></figure>
<p>使用布尔属性<code>isEmpty</code>作为一个缩写形式去检查<code>count</code>属性是否为<code>0</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> favoriteGenres.isEmpty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"As far as music goes, I'm not picky."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I have particular music preferences."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "I have particular music preferences."</span></span><br></pre></td></tr></table></figure>
<p>你可以通过调用<code>Set</code>的<code>insert(_:)</code>方法来添加一个新元素：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">favoriteGenres.insert(<span class="string">"Jazz"</span>)</span><br><span class="line"><span class="comment">// favoriteGenres 现在包含4个元素</span></span><br></pre></td></tr></table></figure>
<p>你可以通过调用<code>Set</code>的<code>remove(_:)</code>方法去删除一个元素，如果该值是该<code>Set</code>的一个元素则删除该元素并且返回被删除的元素值，否则如果该<code>Set</code>不包含该值，则返回<code>nil</code>。另外，<code>Set</code>中的所有元素可以通过它的<code>removeAll()</code>方法删除。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> removedGenre = favoriteGenres.remove(<span class="string">"Rock"</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(removedGenre)</span>? I'm over it."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I never much cared for that."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "Rock? I'm over it."</span></span><br></pre></td></tr></table></figure>
<p>使用<code>contains(_:)</code>方法去检查<code>Set</code>中是否包含一个特定的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> favoriteGenres.<span class="built_in">contains</span>(<span class="string">"Funk"</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I get up on the good foot."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"It's too funky in here."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "It's too funky in here."</span></span><br></pre></td></tr></table></figure>
<p><a name="iterating_over_a_set"></a></p>
<h3 id="遍历一个集合">遍历一个集合</h3><p>你可以在一个<code>for-in</code>循环中遍历一个<code>Set</code>中的所有值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> genre <span class="keyword">in</span> favoriteGenres &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(genre)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Classical</span></span><br><span class="line"><span class="comment">// Jazz</span></span><br><span class="line"><span class="comment">// Hip hop</span></span><br></pre></td></tr></table></figure>
<p>更多关于<code>for-in</code>循环的信息，参见<a href="./05_Control_Flow.html#for_loops">For 循环</a>。</p>
<p>Swift 的<code>Set</code>类型没有确定的顺序，为了按照特定顺序来遍历一个<code>Set</code>中的值可以使用<code>sort()</code>方法，它将根据提供的序列返回一个有序集合.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> genre <span class="keyword">in</span> favoriteGenres.<span class="built_in">sort</span>() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(genre)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// prints "Classical"</span></span><br><span class="line"><span class="comment">// prints "Hip hop"</span></span><br><span class="line"><span class="comment">// prints "Jazz</span></span><br></pre></td></tr></table></figure>
<p><a name="performing_set_operations"></a></p>
<h3 id="集合操作">集合操作</h3><p>你可以高效地完成<code>Set</code>的一些基本操作，比如把两个集合组合到一起，判断两个集合共有元素，或者判断两个集合是否全包含，部分包含或者不相交。</p>
<p><a name="fundamental_set_operations"></a></p>
<h4 id="基本集合操作">基本集合操作</h4><p>下面的插图描述了两个集合-<code>a</code>和<code>b</code>-以及通过阴影部分的区域显示集合各种操作的结果。</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/setVennDiagram_2x.png" alt=""></p>
<ul>
<li>使用<code>intersect(_:)</code>方法根据两个集合中都包含的值创建的一个新的集合。</li>
<li>使用<code>exclusiveOr(_:)</code>方法根据在一个集合中但不在两个集合中的值创建一个新的集合。</li>
<li>使用<code>union(_:)</code>方法根据两个集合的值创建一个新的集合。</li>
<li>使用<code>subtract(_:)</code>方法根据不在该集合中的值创建一个新的集合。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oddDigits: <span class="type">Set</span> = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">let</span> evenDigits: <span class="type">Set</span> = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"><span class="keyword">let</span> singleDigitPrimeNumbers: <span class="type">Set</span> = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">oddDigits.union(evenDigits).<span class="built_in">sort</span>()</span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line">oddDigits.intersect(evenDigits).<span class="built_in">sort</span>()</span><br><span class="line"><span class="comment">// []</span></span><br><span class="line">oddDigits.subtract(singleDigitPrimeNumbers).<span class="built_in">sort</span>()</span><br><span class="line"><span class="comment">// [1, 9]</span></span><br><span class="line">oddDigits.exclusiveOr(singleDigitPrimeNumbers).<span class="built_in">sort</span>()</span><br><span class="line"><span class="comment">// [1, 2, 9]</span></span><br></pre></td></tr></table></figure>
<p><a name="set_membership_and_equality"></a></p>
<h4 id="集合成员关系和相等">集合成员关系和相等</h4><p>下面的插图描述了三个集合-<code>a</code>,<code>b</code>和<code>c</code>,以及通过重叠区域表述集合间共享的元素。集合<code>a</code>是集合<code>b</code>的父集合，因为<code>a</code>包含了<code>b</code>中所有的元素，相反的，集合<code>b</code>是集合<code>a</code>的子集合，因为属于<code>b</code>的元素也被<code>a</code>包含。集合<code>b</code>和集合<code>c</code>彼此不关联，因为它们之间没有共同的元素。</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/setEulerDiagram_2x.png" alt=""></p>
<ul>
<li>使用“是否相等”运算符(<code>==</code>)来判断两个集合是否包含全部相同的值。</li>
<li>使用<code>isSubsetOf(_:)</code>方法来判断一个集合中的值是否也被包含在另外一个集合中。</li>
<li>使用<code>isSupersetOf(_:)</code>方法来判断一个集合中包含另一个集合中所有的值。</li>
<li>使用<code>isStrictSubsetOf(_:)</code>或者<code>isStrictSupersetOf(_:)</code>方法来判断一个集合是否是另外一个集合的子集合或者父集合并且两个集合并不相等。</li>
<li>使用<code>isDisjointWith(_:)</code>方法来判断两个集合是否不含有相同的值。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> houseAnimals: <span class="type">Set</span> = [<span class="string">"🐶"</span>, <span class="string">"🐱"</span>]</span><br><span class="line"><span class="keyword">let</span> farmAnimals: <span class="type">Set</span> = [<span class="string">"🐮"</span>, <span class="string">"🐔"</span>, <span class="string">"🐑"</span>, <span class="string">"🐶"</span>, <span class="string">"🐱"</span>]</span><br><span class="line"><span class="keyword">let</span> cityAnimals: <span class="type">Set</span> = [<span class="string">"🐦"</span>, <span class="string">"🐭"</span>]</span><br><span class="line"></span><br><span class="line">houseAnimals.isSubsetOf(farmAnimals)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">farmAnimals.isSupersetOf(houseAnimals)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">farmAnimals.isDisjointWith(cityAnimals)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><a name="dictionaries"></a></p>
<h2 id="字典">字典</h2><p><em>字典</em>是一种存储多个相同类型的值的容器。每个值（value）都关联唯一的键（key），键作为字典中的这个值数据的标识符。和数组中的数据项不同，字典中的数据项并没有具体顺序。我们在需要通过标识符（键）访问数据的时候使用字典，这种方法很大程度上和我们在现实世界中使用字典查字义的方法一样。</p>
<blockquote>
<p>注意：<br>Swift 的<code>Dictionary</code>类型被桥接到<code>Foundation</code>的<code>NSDictionary</code>类。<br>更多关于在<code>Foundation</code>和<code>Cocoa</code>中使用<code>Dictionary</code>类型的信息，参见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216" target="_blank" rel="external"><em>Using Swift with Cocoa and Objective-C (Swift 2.1)</em></a> 一书。</p>
</blockquote>
<p><a name="dictionary_type_shorthand_syntax"></a></p>
<h2 id="字典类型快捷语法">字典类型快捷语法</h2><p>Swift 的字典使用<code>Dictionary&lt;Key, Value&gt;</code>定义，其中<code>Key</code>是字典中键的数据类型，<code>Value</code>是字典中对应于这些键所存储值的数据类型。</p>
<blockquote>
<p>注意：<br>一个字典的<code>Key</code>类型必须遵循<code>Hashable</code>协议，就像<code>Set</code>的值类型。</p>
</blockquote>
<p>我们也可以用<code>[Key: Value]</code>这样快捷的形式去创建一个字典类型。虽然这两种形式功能上相同，但是后者是首选，并且这本指导书涉及到字典类型时通篇采用后者。</p>
<p><a name="creating_an_empty_dictionary"></a></p>
<h3 id="创建一个空字典">创建一个空字典</h3><p>我们可以像数组一样使用构造语法创建一个拥有确定类型的空字典：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> namesOfIntegers = [<span class="type">Int</span>: <span class="type">String</span>]()</span><br><span class="line"><span class="comment">// namesOfIntegers 是一个空的 [Int: String] 字典</span></span><br></pre></td></tr></table></figure>
<p>这个例子创建了一个<code>[Int: String]</code>类型的空字典来储存整数的英语命名。它的键是<code>Int</code>型，值是<code>String</code>型。</p>
<p>如果上下文已经提供了类型信息，我们可以使用空字典字面量来创建一个空字典，记作<code>[:]</code>（中括号中放一个冒号）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">namesOfIntegers[<span class="number">16</span>] = <span class="string">"sixteen"</span></span><br><span class="line"><span class="comment">// namesOfIntegers 现在包含一个键值对</span></span><br><span class="line">namesOfIntegers = [:]</span><br><span class="line"><span class="comment">// namesOfIntegers 又成为了一个 [Int: String] 类型的空字典</span></span><br></pre></td></tr></table></figure>
<p><a name="creating_a_dictionary_with_a_dictionary_literal"></a></p>
<h2 id="用字典字面量创建字典">用字典字面量创建字典</h2><p>我们可以使用字典字面量来构造字典，这和我们刚才介绍过的数组字面量拥有相似语法。字典字面量是一种将一个或多个键值对写作<code>Dictionary</code>集合的快捷途径。</p>
<p>一个键值对是一个<code>key</code>和一个<code>value</code>的结合体。在字典字面量中，每一个键值对的键和值都由冒号分割。这些键值对构成一个列表，其中这些键值对由方括号包含、由逗号分割：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[key <span class="number">1</span>: value <span class="number">1</span>, key <span class="number">2</span>: value <span class="number">2</span>, key <span class="number">3</span>: value <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>下面的例子创建了一个存储国际机场名称的字典。在这个字典中键是三个字母的国际航空运输相关代码，值是机场名称：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> airports: [<span class="type">String</span>: <span class="type">String</span>] = [<span class="string">"YYZ"</span>: <span class="string">"Toronto Pearson"</span>, <span class="string">"DUB"</span>: <span class="string">"Dublin"</span>]</span><br></pre></td></tr></table></figure>
<p><code>airports</code>字典被声明为一种<code>[String: String]</code>类型，这意味着这个字典的键和值都是<code>String</code>类型。</p>
<blockquote>
<p>注意：<br><code>airports</code>字典被声明为变量（用<code>var</code>关键字）而不是常量（<code>let</code>关键字）因为后来更多的机场信息会被添加到这个示例字典中。</p>
</blockquote>
<p><code>airports</code>字典使用字典字面量初始化，包含两个键值对。第一对的键是<code>YYZ</code>，值是<code>Toronto Pearson</code>。第二对的键是<code>DUB</code>，值是<code>Dublin</code>。</p>
<p>这个字典语句包含了两个<code>String: String</code>类型的键值对。它们对应<code>airports</code>变量声明的类型（一个只有<code>String</code>键和<code>String</code>值的字典）所以这个字典字面量的任务是构造拥有两个初始数据项的<code>airport</code>字典。</p>
<p>和数组一样，我们在用字典字面量构造字典时，如果它的键和值都有各自一致的类型，那么就不必写出字典的类型。<br><code>airports</code>字典也可以用这种简短方式定义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> airports = [<span class="string">"YYZ"</span>: <span class="string">"Toronto Pearson"</span>, <span class="string">"DUB"</span>: <span class="string">"Dublin"</span>]</span><br></pre></td></tr></table></figure>
<p>因为这个语句中所有的键和值都各自拥有相同的数据类型，Swift 可以推断出<code>Dictionary&lt;String, String&gt;</code>是<code>airports</code>字典的正确类型。</p>
<p><a name="accessing_and_modifying_a_dictionary"></a></p>
<h3 id="访问和修改字典">访问和修改字典</h3><p>我们可以通过字典的方法和属性来访问和修改字典，或者通过使用下标语法。</p>
<p>和数组一样，我们可以通过字典的只读属性<code>count</code>来获取某个字典的数据项数量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"The dictionary of airports contains <span class="subst">\(airports.<span class="built_in">count</span>)</span> items."</span>)</span><br><span class="line"><span class="comment">// 打印 "The dictionary of airports contains 2 items."（这个字典有两个数据项）</span></span><br></pre></td></tr></table></figure>
<p>使用布尔属性<code>isEmpty</code>来快捷地检查字典的<code>count</code>属性是否等于0：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> airports.isEmpty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The airports dictionary is empty."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The airports dictionary is not empty."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "The airports dictionary is not empty."</span></span><br></pre></td></tr></table></figure>
<p>我们也可以在字典中使用下标语法来添加新的数据项。可以使用一个恰当类型的键作为下标索引，并且分配恰当类型的新值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">airports[<span class="string">"LHR"</span>] = <span class="string">"London"</span></span><br><span class="line"><span class="comment">// airports 字典现在有三个数据项</span></span><br></pre></td></tr></table></figure>
<p>我们也可以使用下标语法来改变特定键对应的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">airports[<span class="string">"LHR"</span>] = <span class="string">"London Heathrow"</span></span><br><span class="line"><span class="comment">// "LHR"对应的值 被改为 "London Heathrow</span></span><br></pre></td></tr></table></figure>
<p>作为另一种下标方法，字典的<code>updateValue(_:forKey:)</code>方法可以设置或者更新特定键对应的值。就像上面所示的下标示例，<code>updateValue(_:forKey:)</code>方法在这个键不存在对应值的时候会设置新值或者在存在时更新已存在的值。和上面的下标方法不同的，<code>updateValue(_:forKey:)</code>这个方法返回更新值之前的原值。这样使得我们可以检查更新是否成功。</p>
<p><code>updateValue(_:forKey:)</code>方法会返回对应值的类型的可选值。举例来说：对于存储<code>String</code>值的字典，这个函数会返回一个<code>String?</code>或者“可选 <code>String</code>”类型的值。</p>
<p>如果有值存在于更新前，则这个可选值包含了旧值，否则它将会是<code>nil</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> oldValue = airports.updateValue(<span class="string">"Dublin Airport"</span>, forKey: <span class="string">"DUB"</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The old value for DUB was <span class="subst">\(oldValue)</span>."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "The old value for DUB was Dublin."</span></span><br></pre></td></tr></table></figure>
<p>我们也可以使用下标语法来在字典中检索特定键对应的值。因为有可能请求的键没有对应的值存在，字典的下标访问会返回对应值的类型的可选值。如果这个字典包含请求键所对应的值，下标会返回一个包含这个存在值的可选值，否则将返回<code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> airportName = airports[<span class="string">"DUB"</span>] &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The name of the airport is <span class="subst">\(airportName)</span>."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"That airport is not in the airports dictionary."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "The name of the airport is Dublin Airport."</span></span><br></pre></td></tr></table></figure>
<p>我们还可以使用下标语法来通过给某个键的对应值赋值为<code>nil</code>来从字典里移除一个键值对：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">airports[<span class="string">"APL"</span>] = <span class="string">"Apple Internation"</span></span><br><span class="line"><span class="comment">// "Apple Internation" 不是真的 APL 机场, 删除它</span></span><br><span class="line">airports[<span class="string">"APL"</span>] = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// APL 现在被移除了</span></span><br></pre></td></tr></table></figure>
<p>此外，<code>removeValueForKey(_:)</code>方法也可以用来在字典中移除键值对。这个方法在键值对存在的情况下会移除该键值对并且返回被移除的值或者在没有值的情况下返回<code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> removedValue = airports.removeValueForKey(<span class="string">"DUB"</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The removed airport's name is <span class="subst">\(removedValue)</span>."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The airports dictionary does not contain a value for DUB."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// prints "The removed airport's name is Dublin Airport."</span></span><br></pre></td></tr></table></figure>
<p><a name="iterating_over_a_dictionary"></a></p>
<h3 id="字典遍历">字典遍历</h3><p>我们可以使用<code>for-in</code>循环来遍历某个字典中的键值对。每一个字典中的数据项都以<code>(key, value)</code>元组形式返回，并且我们可以使用临时常量或者变量来分解这些元组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (airportCode, airportName) <span class="keyword">in</span> airports &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(airportCode)</span>: <span class="subst">\(airportName)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// YYZ: Toronto Pearson</span></span><br><span class="line"><span class="comment">// LHR: London Heathrow</span></span><br></pre></td></tr></table></figure>
<p>更多关于<code>for-in</code>循环的信息，参见<a href="./05_Control_Flow.html#for_loops">For 循环</a>。</p>
<p>通过访问<code>keys</code>或者<code>values</code>属性，我们也可以遍历字典的键或者值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> airportCode <span class="keyword">in</span> airports.keys &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Airport code: <span class="subst">\(airportCode)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Airport code: YYZ</span></span><br><span class="line"><span class="comment">// Airport code: LHR</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> airportName <span class="keyword">in</span> airports.values &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Airport name: <span class="subst">\(airportName)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Airport name: Toronto Pearson</span></span><br><span class="line"><span class="comment">// Airport name: London Heathrow</span></span><br></pre></td></tr></table></figure>
<p>如果我们只是需要使用某个字典的键集合或者值集合来作为某个接受<code>Array</code>实例的 API 的参数，可以直接使用<code>keys</code>或者<code>values</code>属性构造一个新数组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> airportCodes = [<span class="type">String</span>](airports.keys)</span><br><span class="line"><span class="comment">// airportCodes 是 ["YYZ", "LHR"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> airportNames = [<span class="type">String</span>](airports.values)</span><br><span class="line"><span class="comment">// airportNames 是 ["Toronto Pearson", "London Heathrow"]</span></span><br></pre></td></tr></table></figure>
<p>Swift 的字典类型是无序集合类型。为了以特定的顺序遍历字典的键或值，可以对字典的<code>keys</code>或<code>values</code>属性使用<code>sort()</code>方法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="集合类型_(Collection_Types)">集合类型 (Collection Types)</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/zqp" target="_blank"]]>
    </summary>
    
      <category term="swift-cn" scheme="http://yoursite.com/tags/swift-cn/"/>
    
      <category term="swift-cn" scheme="http://yoursite.com/categories/swift-cn/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第二章-05控制流（Control Flow）]]></title>
    <link href="http://yoursite.com/2015/12/25/swift-cn/chapter2/05_Control_Flow/"/>
    <id>http://yoursite.com/2015/12/25/swift-cn/chapter2/05_Control_Flow/</id>
    <published>2015-12-25T04:00:22.000Z</published>
    <updated>2015-12-15T05:44:40.326Z</updated>
    <content type="html"><![CDATA[<h1 id="控制流（Control_Flow）">控制流（Control Flow）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/vclwei" target="_blank" rel="external">vclwei</a>, <a href="https://github.com/coverxit" target="_blank" rel="external">coverxit</a>, <a href="https://github.com/NicePiao" target="_blank" rel="external">NicePiao</a><br>校对：<a href="https://github.com/coverxit" target="_blank" rel="external">coverxit</a>, <a href="https://github.com/stanzhai" target="_blank" rel="external">stanzhai</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/AlanMelody" target="_blank" rel="external">JackAlan</a></p>
<p>2.1<br>翻译：<a href="https://github.com/futantan" target="_blank" rel="external">Prayer</a><br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#for_loops">For 循环</a></li>
<li><a href="#while_loops">While 循环</a></li>
<li><a href="#conditional_statement">条件语句</a></li>
<li><a href="#control_transfer_statements">控制转移语句（Control Transfer Statements）</a></li>
<li><a href="#early_exit">提前退出</a></li>
<li><a href="#checking_api_availability">检测API可用性</a></li>
</ul>
<p>Swift 提供了类似 C 语言的流程控制结构，包括可以多次执行任务的<code>for</code>和<code>while</code>循环，基于特定条件选择执行不同代码分支的<code>if</code>、<code>guard</code>和<code>switch</code>语句，还有控制流程跳转到其他代码的<code>break</code>和<code>continue</code>语句。</p>
<p>除了 C 语言里面传统的 for 循环，Swift 还增加了<code>for-in</code>循环，用来更简单地遍历数组（array），字典（dictionary），区间（range），字符串（string）和其他序列类型。</p>
<p>Swift 的<code>switch</code>语句比 C 语言中更加强大。在 C 语言中，如果某个 case 不小心漏写了<code>break</code>，这个 case 就会贯穿至下一个 case，Swift 无需写<code>break</code>，所以不会发生这种贯穿的情况。case 还可以匹配更多的类型模式，包括区间匹配（range matching），元组（tuple）和特定类型的描述。<code>switch</code>的 case 语句中匹配的值可以是由 case 体内部临时的常量或者变量决定，也可以由<code>where</code>分句描述更复杂的匹配条件。</p>
<p><a name="for_loops"></a></p>
<h2 id="For_循环">For 循环</h2><p>Swift 提供两种<code>for</code>循环形式以来按照指定的次数多次执行一系列语句：</p>
<ul>
<li><code>for-in</code>循环对一个集合里面的每个元素执行一系列语句。</li>
<li>for 循环，用来重复执行一系列语句直到达成特定条件达成，一般通过在每次循环完成后增加计数器的值来实现。</li>
</ul>
<p><a name="for_in"></a></p>
<h3 id="For-In">For-In</h3><p>你可以使用<code>for-in</code>循环来遍历一个集合里面的所有元素，例如由数字表示的区间、数组中的元素、字符串中的字符。</p>
<p>下面的例子用来输出乘 5 乘法表前面一部分内容：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span>...<span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(index)</span> times 5 is <span class="subst">\(index * <span class="number">5</span>)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 times 5 is 5</span></span><br><span class="line"><span class="comment">// 2 times 5 is 10</span></span><br><span class="line"><span class="comment">// 3 times 5 is 15</span></span><br><span class="line"><span class="comment">// 4 times 5 is 20</span></span><br><span class="line"><span class="comment">// 5 times 5 is 25</span></span><br></pre></td></tr></table></figure>
<p>例子中用来进行遍历的元素是一组使用闭区间操作符（<code>...</code>）表示的从<code>1</code>到<code>5</code>的数字。<code>index</code>被赋值为闭区间中的第一个数字（<code>1</code>），然后循环中的语句被执行一次。在本例中，这个循环只包含一个语句，用来输出当前<code>index</code>值所对应的乘 5 乘法表结果。该语句执行后，<code>index</code>的值被更新为闭区间中的第二个数字（<code>2</code>），之后<code>print(_:separator:terminator:)</code>函数会再执行一次。整个过程会进行到闭区间结尾为止。</p>
<p>上面的例子中，<code>index</code>是一个每次循环遍历开始时被自动赋值的常量。这种情况下，<code>index</code>在使用前不需要声明，只需要将它包含在循环的声明中，就可以对其进行隐式声明，而无需使用<code>let</code>关键字声明。</p>
<p>如果你不需要知道区间序列内每一项的值，你可以使用下划线（<code>_</code>）替代变量名来忽略对值的访问：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> base = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> power = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> answer = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>...power &#123;</span><br><span class="line">    answer *= base</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(base)</span> to the power of <span class="subst">\(power)</span> is <span class="subst">\(answer)</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "3 to the power of 10 is 59049"</span></span><br></pre></td></tr></table></figure>
<p>这个例子计算 base 这个数的 power 次幂（本例中，是<code>3</code>的<code>10</code>次幂），从<code>1</code>（<code>3</code>的<code>0</code>次幂）开始做<code>3</code>的乘法， 进行<code>10</code>次，使用<code>1</code>到<code>10</code>的闭区间循环。这个计算并不需要知道每一次循环中计数器具体的值，只需要执行了正确的循环次数即可。下划线符号<code>_</code>（替代循环中的变量）能够忽略具体的值，并且不提供循环遍历时对值的访问。</p>
<p>使用<code>for-in</code>遍历一个数组所有元素：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [<span class="string">"Anna"</span>, <span class="string">"Alex"</span>, <span class="string">"Brian"</span>, <span class="string">"Jack"</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello, <span class="subst">\(name)</span>!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Hello, Anna!</span></span><br><span class="line"><span class="comment">// Hello, Alex!</span></span><br><span class="line"><span class="comment">// Hello, Brian!</span></span><br><span class="line"><span class="comment">// Hello, Jack!</span></span><br></pre></td></tr></table></figure>
<p>你也可以通过遍历一个字典来访问它的键值对。遍历字典时，字典的每项元素会以<code>(key, value)</code>元组的形式返回，你可以在<code>for-in</code>循环中使用显式的常量名称来解读<code>(key, value)</code>元组。下面的例子中，字典的键（key）解读为常量<code>animalName</code>，字典的值会被解读为常量<code>legCount</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numberOfLegs = [<span class="string">"spider"</span>: <span class="number">8</span>, <span class="string">"ant"</span>: <span class="number">6</span>, <span class="string">"cat"</span>: <span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> (animalName, legCount) <span class="keyword">in</span> numberOfLegs &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(animalName)</span>s have <span class="subst">\(legCount)</span> legs"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ants have 6 legs</span></span><br><span class="line"><span class="comment">// cats have 4 legs</span></span><br><span class="line"><span class="comment">// spiders have 8 legs</span></span><br></pre></td></tr></table></figure>
<p>字典元素的遍历顺序和插入顺序可能不同，字典的内容在内部是无序的，所以遍历元素时不能保证顺序。关于数组和字典，详情参见<a href="./04_Collection_Types.html">集合类型</a>。</p>
<p><a name="for"></a></p>
<h3 id="For">For</h3><p>除了<code>for-in</code>循环，Swift 提供使用条件判断和递增方法的标准 C 样式<code>for</code>循环:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">var</span> index = <span class="number">0</span>; index &lt; <span class="number">3</span>; ++index &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"index is <span class="subst">\(index)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index is 0</span></span><br><span class="line"><span class="comment">// index is 1</span></span><br><span class="line"><span class="comment">// index is 2</span></span><br></pre></td></tr></table></figure>
<p>下面是一般情况下这种循环方式的格式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> initialization; condition; increment &#123;</span><br><span class="line">	statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和 C 语言中一样，分号将循环的定义分为 3 个部分，不同的是，Swift 不需要使用圆括号将“initialization; condition; increment”包括起来。</p>
<p>这个循环执行流程如下：</p>
<ol>
<li>循环首次启动时，<em>初始化表达式（ initialization expression ）</em>被调用一次，用来初始化循环所需的所有常量和变量。</li>
<li><em>条件表达式（condition expression）</em>被调用，如果表达式调用结果为<code>false</code>，循环结束，继续执行<code>for</code>循环关闭大括号（<code>}</code>）之后的代码。如果表达式调用结果为<code>true</code>，则会执行大括号内部的代码。</li>
<li>执行所有语句之后，执行<em>递增表达式（increment expression）</em>。通常会增加或减少计数器的值，或者根据语句输出来修改某一个初始化的变量。当递增表达式运行完成后，重复执行第 2 步，条件表达式会再次执行。</li>
</ol>
<p>在初始化表达式中声明的常量和变量（比如<code>var index = 0</code>）只在<code>for</code>循环的生命周期里有效。如果想在循环结束后访问<code>index</code>的值，你必须要在循环生命周期开始前声明<code>index</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> index: <span class="type">Int</span></span><br><span class="line"><span class="keyword">for</span> index = <span class="number">0</span>; index &lt; <span class="number">3</span>; ++index &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"index is <span class="subst">\(index)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index is 0</span></span><br><span class="line"><span class="comment">// index is 1</span></span><br><span class="line"><span class="comment">// index is 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The loop statements were executed <span class="subst">\(index)</span> times"</span>)</span><br><span class="line"><span class="comment">// 输出 "The loop statements were executed 3 times</span></span><br></pre></td></tr></table></figure>
<p>注意<code>index</code>在循环结束后最终的值是<code>3</code>而不是<code>2</code>。最后一次调用递增表达式<code>++index</code>会将<code>index</code>设置为<code>3</code>，从而导致<code>index &lt; 3</code>条件为<code>false</code>，并终止循环。</p>
<p><a name="while_loops"></a></p>
<h2 id="While_循环">While 循环</h2><p><code>while</code>循环运行一系列语句直到条件变成<code>false</code>。这类循环适合使用在第一次迭代前迭代次数未知的情况下。Swift 提供两种<code>while</code>循环形式：</p>
<ul>
<li><code>while</code>循环，每次在循环开始时计算条件是否符合；</li>
<li><code>repeat-while</code>循环，每次在循环结束时计算条件是否符合。</li>
</ul>
<p><a name="while"></a></p>
<p>###While</p>
<p><code>while</code>循环从计算单一条件开始。如果条件为<code>true</code>，会重复运行一系列语句，直到条件变为<code>false</code>。</p>
<p>下面是一般情况下 <code>while</code> 循环格式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> condition &#123;  </span><br><span class="line">	statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的例子来玩一个叫做蛇和梯子的小游戏，也叫做滑道和梯子：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/snakesAndLadders_2x.png" alt="image"></p>
<p>游戏的规则如下：</p>
<ul>
<li>游戏盘面包括 25 个方格，游戏目标是达到或者超过第 25 个方格；</li>
<li>每一轮，你通过掷一个 6 边的骰子来确定你移动方块的步数，移动的路线由上图中横向的虚线所示；</li>
<li>如果在某轮结束，你移动到了梯子的底部，可以顺着梯子爬上去；</li>
<li>如果在某轮结束，你移动到了蛇的头部，你会顺着蛇的身体滑下去。</li>
</ul>
<p>游戏盘面可以使用一个<code>Int</code>数组来表达。数组的长度由一个<code>finalSquare</code>常量储存，用来初始化数组和检测最终胜利条件。游戏盘面由 26 个 <code>Int</code> 0 值初始化，而不是 25 个（由<code>0</code>到<code>25</code>，一共 26 个）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> finalSquare = <span class="number">25</span></span><br><span class="line"><span class="keyword">var</span> board = [<span class="type">Int</span>](<span class="built_in">count</span>: finalSquare + <span class="number">1</span>, repeatedValue: <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>一些方块被设置成有蛇或者梯子的指定值。梯子底部的方块是一个正值，使你可以向上移动，蛇头处的方块是一个负值，会让你向下移动：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">board[<span class="number">03</span>] = +<span class="number">08</span>; board[<span class="number">06</span>] = +<span class="number">11</span>; board[<span class="number">09</span>] = +<span class="number">09</span>; board[<span class="number">10</span>] = +<span class="number">02</span></span><br><span class="line">board[<span class="number">14</span>] = -<span class="number">10</span>; board[<span class="number">19</span>] = -<span class="number">11</span>; board[<span class="number">22</span>] = -<span class="number">02</span>; board[<span class="number">24</span>] = -<span class="number">08</span></span><br></pre></td></tr></table></figure>
<p>3 号方块是梯子的底部，会让你向上移动到 11 号方格，我们使用<code>board[03]</code>等于<code>+08</code>（来表示<code>11</code>和<code>3</code>之间的差值）。使用一元加运算符（<code>+i</code>）是为了和一元减运算符（<code>-i</code>）对称，为了让盘面代码整齐，小于 10 的数字都使用 0 补齐（这些风格上的调整都不是必须的，只是为了让代码看起来更加整洁）。</p>
<p>玩家由左下角编号为 0 的方格开始游戏。一般来说玩家第一次掷骰子后才会进入游戏盘面：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> square = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> diceRoll = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> square &lt; finalSquare &#123;</span><br><span class="line">    <span class="comment">// 掷骰子</span></span><br><span class="line">    <span class="keyword">if</span> ++diceRoll == <span class="number">7</span> &#123; diceRoll = <span class="number">1</span> &#125;</span><br><span class="line">    <span class="comment">// 根据点数移动</span></span><br><span class="line">    square += diceRoll</span><br><span class="line">    <span class="keyword">if</span> square &lt; board.<span class="built_in">count</span> &#123;</span><br><span class="line">        <span class="comment">// 如果玩家还在棋盘上，顺着梯子爬上去或者顺着蛇滑下去</span></span><br><span class="line">        square += board[square]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Game over!"</span>)</span><br></pre></td></tr></table></figure>
<p>本例中使用了最简单的方法来模拟掷骰子。 <code>diceRoll</code>的值并不是一个随机数，而是以<code>0</code>为初始值，之后每一次<code>while</code>循环，<code>diceRoll</code>的值使用前置自增操作符(<code>++i</code>)来自增 1 ，然后检测是否超出了最大值。<code>++diceRoll</code>调用完成<em>后</em>，返回值等于<code>diceRoll</code>自增后的值。任何时候如果<code>diceRoll</code>的值等于7时，就超过了骰子的最大值，会被重置为<code>1</code>。所以<code>diceRoll</code>的取值顺序会一直是<code>1</code>，<code>2</code>，<code>3</code>，<code>4</code>，<code>5</code>，<code>6</code>，<code>1</code>，<code>2</code>。</p>
<p>掷完骰子后，玩家向前移动<code>diceRoll</code>个方格，如果玩家移动超过了第 25 个方格，这个时候游戏结束，相应地，代码会在<code>square</code>增加<code>board[square]</code>的值向前或向后移动（遇到了梯子或者蛇）之前，检测<code>square</code>的值是否小于<code>board</code>的<code>count</code>属性。</p>
<p>如果没有这个检测（<code>square &lt; board.count</code>），<code>board[square]</code>可能会越界访问<code>board</code>数组，导致错误。例如如果<code>square</code>等于<code>26</code>， 代码会去尝试访问<code>board[26]</code>，超过数组的长度。</p>
<p>当本轮<code>while</code>循环运行完毕，会再检测循环条件是否需要再运行一次循环。如果玩家移动到或者超过第 25 个方格，循环条件结果为<code>false</code>，此时游戏结束。</p>
<p><code>while</code> 循环比较适合本例中的这种情况，因为在 <code>while</code> 循环开始时，我们并不知道游戏的长度或者循环的次数，只有在达成指定条件时循环才会结束。</p>
<p><a name="repeat_while"></a></p>
<p>###Repeat-While</p>
<p><code>while</code>循环的另外一种形式是<code>repeat-while</code>，它和<code>while</code>的区别是在判断循环条件之前，先执行一次循环的代码块，然后重复循环直到条件为<code>false</code>。</p>
<blockquote>
<p>注意：<br>Swift语言的<code>repeat-while</code>循环合其他语言中的<code>do-while</code>循环是类似的。</p>
</blockquote>
<p>下面是一般情况下 <code>repeat-while</code>循环的格式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">repeat &#123;</span><br><span class="line">	statements</span><br><span class="line">&#125; <span class="keyword">while</span> condition</span><br></pre></td></tr></table></figure>
<p>还是蛇和梯子的游戏，使用<code>repeat-while</code>循环来替代<code>while</code>循环。<code>finalSquare</code>、<code>board</code>、<code>square</code>和<code>diceRoll</code>的值初始化同<code>while</code>循环一样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> finalSquare = <span class="number">25</span></span><br><span class="line"><span class="keyword">var</span> board = [<span class="type">Int</span>](<span class="built_in">count</span>: finalSquare + <span class="number">1</span>, repeatedValue: <span class="number">0</span>)</span><br><span class="line">board[<span class="number">03</span>] = +<span class="number">08</span>; board[<span class="number">06</span>] = +<span class="number">11</span>; board[<span class="number">09</span>] = +<span class="number">09</span>; board[<span class="number">10</span>] = +<span class="number">02</span></span><br><span class="line">board[<span class="number">14</span>] = -<span class="number">10</span>; board[<span class="number">19</span>] = -<span class="number">11</span>; board[<span class="number">22</span>] = -<span class="number">02</span>; board[<span class="number">24</span>] = -<span class="number">08</span></span><br><span class="line"><span class="keyword">var</span> square = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> diceRoll = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><code>repeat-while</code>的循环版本，循环中<em>第一步</em>就需要去检测是否在梯子或者蛇的方块上。没有梯子会让玩家直接上到第 25 个方格，所以玩家不会通过梯子直接赢得游戏。这样在循环开始时先检测是否踩在梯子或者蛇上是安全的。</p>
<p>游戏开始时，玩家在第 0 个方格上，<code>board[0]</code>一直等于 0， 不会有什么影响：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">repeat &#123;</span><br><span class="line">    <span class="comment">// 顺着梯子爬上去或者顺着蛇滑下去</span></span><br><span class="line">    square += board[square]</span><br><span class="line">    <span class="comment">// 掷骰子</span></span><br><span class="line">    <span class="keyword">if</span> ++diceRoll == <span class="number">7</span> &#123; diceRoll = <span class="number">1</span> &#125;</span><br><span class="line">    <span class="comment">// 根据点数移动</span></span><br><span class="line">    square += diceRoll</span><br><span class="line">&#125; <span class="keyword">while</span> square &lt; finalSquare</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Game over!"</span>)</span><br></pre></td></tr></table></figure>
<p>检测完玩家是否踩在梯子或者蛇上之后，开始掷骰子，然后玩家向前移动<code>diceRoll</code>个方格，本轮循环结束。</p>
<p>循环条件（<code>while square &lt; finalSquare</code>）和<code>while</code>方式相同，但是只会在循环结束后进行计算。在这个游戏中，<code>repeat-while</code>表现得比<code>while</code>循环更好。<code>repeat-while</code>方式会在条件判断<code>square</code>没有超出后直接运行<code>square += board[square]</code>，这种方式可以去掉<code>while</code>版本中的数组越界判断。</p>
<p><a name="conditional_statement"></a></p>
<h2 id="条件语句">条件语句</h2><p>根据特定的条件执行特定的代码通常是十分有用的，例如：当错误发生时，你可能想运行额外的代码；或者，当输入的值太大或太小时，向用户显示一条消息等。要实现这些功能，你就需要使用<em>条件语句</em>。</p>
<p>Swift 提供两种类型的条件语句：<code>if</code>语句和<code>switch</code>语句。通常，当条件较为简单且可能的情况很少时，使用<code>if</code>语句。而<code>switch</code>语句更适用于条件较复杂、可能情况较多且需要用到模式匹配（pattern-matching）的情境。</p>
<p><a name="if"></a></p>
<h3 id="If">If</h3><p><code>if</code>语句最简单的形式就是只包含一个条件，当且仅当该条件为<code>true</code>时，才执行相关代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> temperatureInFahrenheit = <span class="number">30</span></span><br><span class="line"><span class="keyword">if</span> temperatureInFahrenheit &lt;= <span class="number">32</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"It's very cold. Consider wearing a scarf."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "It's very cold. Consider wearing a scarf."</span></span><br></pre></td></tr></table></figure>
<p>上面的例子会判断温度是否小于等于 32 华氏度（水的冰点）。如果是，则打印一条消息；否则，不打印任何消息，继续执行<code>if</code>块后面的代码。</p>
<p>当然，<code>if</code>语句允许二选一，也就是当条件为<code>false</code>时，执行 <em>else 语句</em>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">temperatureInFahrenheit = <span class="number">40</span></span><br><span class="line"><span class="keyword">if</span> temperatureInFahrenheit &lt;= <span class="number">32</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"It's very cold. Consider wearing a scarf."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"It's not that cold. Wear a t-shirt."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "It's not that cold. Wear a t-shirt."</span></span><br></pre></td></tr></table></figure>
<p>显然，这两条分支中总有一条会被执行。由于温度已升至 40 华氏度，不算太冷，没必要再围围巾——因此，<code>else</code>分支就被触发了。</p>
<p>你可以把多个<code>if</code>语句链接在一起，像下面这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">temperatureInFahrenheit = <span class="number">90</span></span><br><span class="line"><span class="keyword">if</span> temperatureInFahrenheit &lt;= <span class="number">32</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"It's very cold. Consider wearing a scarf."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> temperatureInFahrenheit &gt;= <span class="number">86</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"It's really warm. Don't forget to wear sunscreen."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"It's not that cold. Wear a t-shirt."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "It's really warm. Don't forget to wear sunscreen."</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，额外的<code>if</code>语句用于判断是不是特别热。而最后的<code>else</code>语句被保留了下来，用于打印既不冷也不热时的消息。</p>
<p>实际上，最后的<code>else</code>语句是可选的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">temperatureInFahrenheit = <span class="number">72</span></span><br><span class="line"><span class="keyword">if</span> temperatureInFahrenheit &lt;= <span class="number">32</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"It's very cold. Consider wearing a scarf."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> temperatureInFahrenheit &gt;= <span class="number">86</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"It's really warm. Don't forget to wear sunscreen."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，由于既不冷也不热，所以不会触发<code>if</code>或<code>else if</code>分支，也就不会打印任何消息。</p>
<p><a name="switch"></a></p>
<h3 id="Switch">Switch</h3><p><code>switch</code>语句会尝试把某个值与若干个模式（pattern）进行匹配。根据第一个匹配成功的模式，<code>switch</code>语句会执行对应的代码。当有可能的情况较多时，通常用<code>switch</code>语句替换<code>if</code>语句。</p>
<p><code>switch</code>语句最简单的形式就是把某个值与一个或若干个相同类型的值作比较：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> some value to consider &#123;</span><br><span class="line"><span class="keyword">case</span> value <span class="number">1</span>:</span><br><span class="line">    respond to value <span class="number">1</span></span><br><span class="line"><span class="keyword">case</span> value <span class="number">2</span>, value <span class="number">3</span>:</span><br><span class="line">    respond to value <span class="number">2</span> or <span class="number">3</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    otherwise, <span class="keyword">do</span> something <span class="keyword">else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>switch</code>语句都由<em>多个 case</em> 构成。为了匹配某些更特定的值，Swift 提供了几种更复杂的匹配模式，这些模式将在本节的稍后部分提到。</p>
<p>每一个 case 都是代码执行的一条分支，这与<code>if</code>语句类似。与之不同的是，<code>switch</code>语句会决定哪一条分支应该被执行。</p>
<p><code>switch</code>语句必须是完备的。这就是说，每一个可能的值都必须至少有一个 case 分支与之对应。在某些不可能涵盖所有值的情况下，你可以使用默认（<code>default</code>）分支满足该要求，这个默认分支必须在<code>switch</code>语句的最后面。</p>
<p>下面的例子使用<code>switch</code>语句来匹配一个名为<code>someCharacter</code>的小写字符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someCharacter: <span class="type">Character</span> = <span class="string">"e"</span></span><br><span class="line"><span class="keyword">switch</span> someCharacter &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"a"</span>, <span class="string">"e"</span>, <span class="string">"i"</span>, <span class="string">"o"</span>, <span class="string">"u"</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(someCharacter)</span> is a vowel"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"f"</span>, <span class="string">"g"</span>, <span class="string">"h"</span>, <span class="string">"j"</span>, <span class="string">"k"</span>, <span class="string">"l"</span>, <span class="string">"m"</span>,</span><br><span class="line"><span class="string">"n"</span>, <span class="string">"p"</span>, <span class="string">"q"</span>, <span class="string">"r"</span>, <span class="string">"s"</span>, <span class="string">"t"</span>, <span class="string">"v"</span>, <span class="string">"w"</span>, <span class="string">"x"</span>, <span class="string">"y"</span>, <span class="string">"z"</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(someCharacter)</span> is a consonant"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(someCharacter)</span> is not a vowel or a consonant"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "e is a vowel"</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，第一个 case 分支用于匹配五个元音，第二个 case 分支用于匹配所有的辅音。</p>
<p>由于为其它可能的字符写 case 分支没有实际的意义，因此在这个例子中使用了默认分支来处理剩下的既不是元音也不是辅音的字符——这就保证了<code>switch</code>语句的完备性。</p>
<p><a name="no_implicit_fallthrough"></a></p>
<h4 id="不存在隐式的贯穿（No_Implicit_Fallthrough）">不存在隐式的贯穿（No Implicit Fallthrough）</h4><p>与 C 语言和 Objective-C 中的<code>switch</code>语句不同，在 Swift 中，当匹配的 case 分支中的代码执行完毕后，程序会终止<code>switch</code>语句，而不会继续执行下一个 case 分支。这也就是说，不需要在 case 分支中显式地使用<code>break</code>语句。这使得<code>switch</code>语句更安全、更易用，也避免了因忘记写<code>break</code>语句而产生的错误。</p>
<blockquote>
<p>注意：<br>虽然在Swift中<code>break</code>不是必须的，但你依然可以在 case 分支中的代码执行完毕前使用<code>break</code>跳出，详情请参见<a href="#break_in_a_switch_statement">Switch 语句中的 break</a>。</p>
</blockquote>
<p>每一个 case 分支都<em>必须</em>包含至少一条语句。像下面这样书写代码是无效的，因为第一个 case 分支是空的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherCharacter: <span class="type">Character</span> = <span class="string">"a"</span></span><br><span class="line"><span class="keyword">switch</span> anotherCharacter &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"a"</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">"A"</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The letter A"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Not the letter A"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// this will report a compile-time error</span></span><br></pre></td></tr></table></figure>
<p>不像 C 语言里的<code>switch</code>语句，在 Swift 中，<code>switch</code>语句不会同时匹配<code>&quot;a&quot;</code>和<code>&quot;A&quot;</code>。相反的，上面的代码会引起编译期错误：<code>case &quot;a&quot;: does not contain any executable statements</code>——这就避免了意外地从一个 case 分支贯穿到另外一个，使得代码更安全、也更直观。</p>
<p>一个 case 也可以包含多个模式，用逗号把它们分开（如果太长了也可以分行写）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> some value to consider &#123;</span><br><span class="line"><span class="keyword">case</span> value <span class="number">1</span>, value <span class="number">2</span>:</span><br><span class="line">	statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>如果想要贯穿至特定的 case 分支中，请使用<code>fallthrough</code>语句，详情请参考<a href="#fallthrough">贯穿（Fallthrough）</a>。</p>
</blockquote>
<p><a name="interval_matching"></a></p>
<h4 id="区间匹配">区间匹配</h4><p>case 分支的模式也可以是一个值的区间。下面的例子展示了如何使用区间匹配来输出任意数字对应的自然语言格式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> approximateCount = <span class="number">62</span></span><br><span class="line"><span class="keyword">let</span> countedThings = <span class="string">"moons orbiting Saturn"</span></span><br><span class="line"><span class="keyword">var</span> naturalCount: <span class="type">String</span></span><br><span class="line"><span class="keyword">switch</span> approximateCount &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    naturalCount = <span class="string">"no"</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>..&lt;<span class="number">5</span>:</span><br><span class="line">    naturalCount = <span class="string">"a few"</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>..&lt;<span class="number">12</span>:</span><br><span class="line">    naturalCount = <span class="string">"several"</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">12</span>..&lt;<span class="number">100</span>:</span><br><span class="line">    naturalCount = <span class="string">"dozens of"</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">100</span>..&lt;<span class="number">1000</span>:</span><br><span class="line">    naturalCount = <span class="string">"hundreds of"</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    naturalCount = <span class="string">"many"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"There are <span class="subst">\(naturalCount)</span> <span class="subst">\(countedThings)</span>."</span>)</span><br><span class="line"><span class="comment">// 输出 "There are dozens of moons orbiting Saturn."</span></span><br></pre></td></tr></table></figure>
<p>在上例中，<code>approximateCount</code>在一个<code>switch</code>声明中被估值。每一个<code>case</code>都与之进行比较。因为<code>approximateCount</code>落在了12到100的区间，所以<code>naturalCount</code>等于<code>&quot;dozens of&quot;</code>值，并且此后这段执行跳出了<code>switch</code>声明。</p>
<blockquote>
<p>注意：<br>闭区间操作符(<code>...</code>)以及半开区间操作符(<code>..&lt;</code>)功能被重载去返回<code>IntervalType</code>或<code>Range</code>。一个区间可以决定他是否包含特定的元素，就像当匹配一个<code>switch</code>声明的<code>case</code>一样。区间是一个连续值的集合，可以用<code>for-in</code>语句遍历它。</p>
</blockquote>
<p><a name="tuples"></a></p>
<h4 id="元组（Tuple）">元组（Tuple）</h4><p>我们可以使用元组在同一个<code>switch</code>语句中测试多个值。元组中的元素可以是值，也可以是区间。另外，使用下划线（<code>_</code>）来匹配所有可能的值。</p>
<p>下面的例子展示了如何使用一个<code>(Int, Int)</code>类型的元组来分类下图中的点(x, y)：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> somePoint = (<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">switch</span> somePoint &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"(0, 0) is at the origin"</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="number">_</span>, <span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"(<span class="subst">\(somePoint.<span class="number">0</span>)</span>, 0) is on the x-axis"</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="number">_</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"(0, <span class="subst">\(somePoint.<span class="number">1</span>)</span>) is on the y-axis"</span>)</span><br><span class="line"><span class="keyword">case</span> (-<span class="number">2</span>...<span class="number">2</span>, -<span class="number">2</span>...<span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"(<span class="subst">\(somePoint.<span class="number">0</span>)</span>, <span class="subst">\(somePoint.<span class="number">1</span>)</span>) is inside the box"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"(<span class="subst">\(somePoint.<span class="number">0</span>)</span>, <span class="subst">\(somePoint.<span class="number">1</span>)</span>) is outside of the box"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "(1, 1) is inside the box"</span></span><br></pre></td></tr></table></figure>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/coordinateGraphSimple_2x.png" alt="image"></p>
<p>在上面的例子中，<code>switch</code>语句会判断某个点是否是原点(0, 0)，是否在红色的x轴上，是否在黄色y轴上，是否在一个以原点为中心的4x4的矩形里，或者在这个矩形外面。</p>
<p>不像 C 语言，Swift 允许多个 case 匹配同一个值。实际上，在这个例子中，点(0, 0)可以匹配所有<em>四个 case</em>。但是，如果存在多个匹配，那么只会执行第一个被匹配到的 case 分支。考虑点(0, 0)会首先匹配<code>case (0, 0)</code>，因此剩下的能够匹配(0, 0)的 case 分支都会被忽视掉。</p>
<p><a name="value_bindings"></a></p>
<h4 id="值绑定（Value_Bindings）">值绑定（Value Bindings）</h4><p>case 分支的模式允许将匹配的值绑定到一个临时的常量或变量，这些常量或变量在该 case 分支里就可以被引用了——这种行为被称为<em>值绑定</em>（value binding）。</p>
<p>下面的例子展示了如何在一个<code>(Int, Int)</code>类型的元组中使用值绑定来分类下图中的点(x, y)：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherPoint = (<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">switch</span> anotherPoint &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="keyword">let</span> x, <span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"on the x-axis with an x value of <span class="subst">\(x)</span>"</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="keyword">let</span> y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"on the y-axis with a y value of <span class="subst">\(y)</span>"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"somewhere else at (<span class="subst">\(x)</span>, <span class="subst">\(y)</span>)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "on the x-axis with an x value of 2"</span></span><br></pre></td></tr></table></figure>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/coordinateGraphMedium_2x.png" alt="image"></p>
<p>在上面的例子中，<code>switch</code>语句会判断某个点是否在红色的x轴上，是否在黄色y轴上，或者不在坐标轴上。</p>
<p>这三个 case 都声明了常量<code>x</code>和<code>y</code>的占位符，用于临时获取元组<code>anotherPoint</code>的一个或两个值。第一个 case ——<code>case (let x, 0)</code>将匹配一个纵坐标为<code>0</code>的点，并把这个点的横坐标赋给临时的常量<code>x</code>。类似的，第二个 case ——<code>case (0, let y)</code>将匹配一个横坐标为<code>0</code>的点，并把这个点的纵坐标赋给临时的常量<code>y</code>。</p>
<p>一旦声明了这些临时的常量，它们就可以在其对应的 case 分支里引用。在这个例子中，它们用于简化<code>print(_:separator:terminator:)</code>的书写。</p>
<p>请注意，这个<code>switch</code>语句不包含默认分支。这是因为最后一个 case ——<code>case let(x, y)</code>声明了一个可以匹配余下所有值的元组。这使得<code>switch</code>语句已经完备了，因此不需要再书写默认分支。</p>
<p>在上面的例子中，<code>x</code>和<code>y</code>是常量，这是因为没有必要在其对应的 case 分支中修改它们的值。然而，它们也可以是变量——程序将会创建临时变量，并用相应的值初始化它。修改这些变量只会影响其对应的 case 分支。</p>
<p><a name="where"></a></p>
<h4 id="Where">Where</h4><p>case 分支的模式可以使用<code>where</code>语句来判断额外的条件。</p>
<p>下面的例子把下图中的点(x, y)进行了分类：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> yetAnotherPoint = (<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line"><span class="keyword">switch</span> yetAnotherPoint &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">where</span> x == y:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"(<span class="subst">\(x)</span>, <span class="subst">\(y)</span>) is on the line x == y"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">where</span> x == -y:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"(<span class="subst">\(x)</span>, <span class="subst">\(y)</span>) is on the line x == -y"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"(<span class="subst">\(x)</span>, <span class="subst">\(y)</span>) is just some arbitrary point"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "(1, -1) is on the line x == -y"</span></span><br></pre></td></tr></table></figure>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/coordinateGraphComplex_2x.png" alt="image"></p>
<p>在上面的例子中，<code>switch</code>语句会判断某个点是否在绿色的对角线<code>x == y</code>上，是否在紫色的对角线<code>x == -y</code>上，或者不在对角线上。</p>
<p>这三个 case 都声明了常量<code>x</code>和<code>y</code>的占位符，用于临时获取元组<code>yetAnotherPoint</code>的两个值。这些常量被用作<code>where</code>语句的一部分，从而创建一个动态的过滤器(filter)。当且仅当<code>where</code>语句的条件为<code>true</code>时，匹配到的 case 分支才会被执行。</p>
<p>就像是值绑定中的例子，由于最后一个 case 分支匹配了余下所有可能的值，<code>switch</code>语句就已经完备了，因此不需要再书写默认分支。</p>
<p><a name="control_transfer_statements"></a></p>
<h2 id="控制转移语句（Control_Transfer_Statements）">控制转移语句（Control Transfer Statements）</h2><p>控制转移语句改变你代码的执行顺序，通过它你可以实现代码的跳转。Swift 有五种控制转移语句：</p>
<ul>
<li><code>continue</code></li>
<li><code>break</code></li>
<li><code>fallthrough</code></li>
<li><code>return</code></li>
<li><code>throw</code></li>
</ul>
<p>我们将会在下面讨论<code>continue</code>、<code>break</code>和<code>fallthrough</code>语句。<code>return</code>语句将会在<a href="./06_Functions.html">函数</a>章节讨论，<code>throw</code>语句会在<a href="./18_Error_Handling.html#throwing_errors">错误抛出</a>章节讨论。</p>
<p><a name="continue"></a></p>
<h3 id="Continue">Continue</h3><p><code>continue</code>语句告诉一个循环体立刻停止本次循环迭代，重新开始下次循环迭代。就好像在说“本次循环迭代我已经执行完了”，但是并不会离开整个循环体。</p>
<blockquote>
<p>注意：<br>在一个带有条件和递增的for循环体中，调用<code>continue</code>语句后，迭代增量仍然会被计算求值。循环体继续像往常一样工作，仅仅只是循环体中的执行代码会被跳过。</p>
</blockquote>
<p>下面的例子把一个小写字符串中的元音字母和空格字符移除，生成了一个含义模糊的短句：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> puzzleInput = <span class="string">"great minds think alike"</span></span><br><span class="line"><span class="keyword">var</span> puzzleOutput = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> character <span class="keyword">in</span> puzzleInput.characters &#123;</span><br><span class="line">    <span class="keyword">switch</span> character &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"a"</span>, <span class="string">"e"</span>, <span class="string">"i"</span>, <span class="string">"o"</span>, <span class="string">"u"</span>, <span class="string">" "</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        puzzleOutput.append(character)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(puzzleOutput)</span><br><span class="line"><span class="comment">// 输出 "grtmndsthnklk"</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，只要匹配到元音字母或者空格字符，就调用<code>continue</code>语句，使本次循环迭代结束，从新开始下次循环迭代。这种行为使<code>switch</code>匹配到元音字母和空格字符时不做处理，而不是让每一个匹配到的字符都被打印。</p>
<p><a name="break"></a></p>
<h3 id="Break">Break</h3><p><code>break</code>语句会立刻结束整个控制流的执行。当你想要更早的结束一个<code>switch</code>代码块或者一个循环体时，你都可以使用<code>break</code>语句。</p>
<p><a name="break_in_a_loop_statement"></a></p>
<h4 id="循环语句中的_break">循环语句中的 break</h4><p>当在一个循环体中使用<code>break</code>时，会立刻中断该循环体的执行，然后跳转到表示循环体结束的大括号(<code>}</code>)后的第一行代码。不会再有本次循环迭代的代码被执行，也不会再有下次的循环迭代产生。</p>
<p><a name="break_in_a_switch_statement"></a></p>
<h4 id="Switch_语句中的_break">Switch 语句中的 break</h4><p>当在一个<code>switch</code>代码块中使用<code>break</code>时，会立即中断该<code>switch</code>代码块的执行，并且跳转到表示<code>switch</code>代码块结束的大括号(<code>}</code>)后的第一行代码。</p>
<p>这种特性可以被用来匹配或者忽略一个或多个分支。因为 Swift 的<code>switch</code>需要包含所有的分支而且不允许有为空的分支，有时为了使你的意图更明显，需要特意匹配或者忽略某个分支。那么当你想忽略某个分支时，可以在该分支内写上<code>break</code>语句。当那个分支被匹配到时，分支内的<code>break</code>语句立即结束<code>switch</code>代码块。</p>
<blockquote>
<p>注意：<br>当一个<code>switch</code>分支仅仅包含注释时，会被报编译时错误。注释不是代码语句而且也不能让<code>switch</code>分支达到被忽略的效果。你总是可以使用<code>break</code>来忽略某个分支。</p>
</blockquote>
<p>下面的例子通过<code>switch</code>来判断一个<code>Character</code>值是否代表下面四种语言之一。为了简洁，多个值被包含在了同一个分支情况中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numberSymbol: <span class="type">Character</span> = <span class="string">"三"</span>  <span class="comment">// 简体中文里的数字 3</span></span><br><span class="line"><span class="keyword">var</span> possibleIntegerValue: <span class="type">Int</span>?</span><br><span class="line"><span class="keyword">switch</span> numberSymbol &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"1"</span>, <span class="string">"١"</span>, <span class="string">"一"</span>, <span class="string">"๑"</span>:</span><br><span class="line">    possibleIntegerValue = <span class="number">1</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"2"</span>, <span class="string">"٢"</span>, <span class="string">"二"</span>, <span class="string">"๒"</span>:</span><br><span class="line">    possibleIntegerValue = <span class="number">2</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"3"</span>, <span class="string">"٣"</span>, <span class="string">"三"</span>, <span class="string">"๓"</span>:</span><br><span class="line">    possibleIntegerValue = <span class="number">3</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"4"</span>, <span class="string">"٤"</span>, <span class="string">"四"</span>, <span class="string">"๔"</span>:</span><br><span class="line">    possibleIntegerValue = <span class="number">4</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> integerValue = possibleIntegerValue &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The integer value of <span class="subst">\(numberSymbol)</span> is <span class="subst">\(integerValue)</span>."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"An integer value could not be found for <span class="subst">\(numberSymbol)</span>."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "The integer value of 三 is 3."</span></span><br></pre></td></tr></table></figure>
<p>这个例子检查<code>numberSymbol</code>是否是拉丁，阿拉伯，中文或者泰语中的<code>1</code>到<code>4</code>之一。如果被匹配到，该<code>switch</code>分支语句给<code>Int?</code>类型变量<code>possibleIntegerValue</code>设置一个整数值。</p>
<p>当<code>switch</code>代码块执行完后，接下来的代码通过使用可选绑定来判断<code>possibleIntegerValue</code>是否曾经被设置过值。因为是可选类型的缘故，<code>possibleIntegerValue</code>有一个隐式的初始值<code>nil</code>，所以仅仅当<code>possibleIntegerValue</code>曾被<code>switch</code>代码块的前四个分支中的某个设置过一个值时，可选的绑定将会被判定为成功。</p>
<p>在上面的例子中，想要把<code>Character</code>所有的的可能性都枚举出来是不现实的，所以使用<code>default</code>分支来包含所有上面没有匹配到字符的情况。由于这个<code>default</code>分支不需要执行任何动作，所以它只写了一条<code>break</code>语句。一旦落入到<code>default</code>分支中后，<code>break</code>语句就完成了该分支的所有代码操作，代码继续向下，开始执行<code>if let</code>语句。</p>
<p><a name="fallthrough"></a></p>
<h3 id="贯穿（Fallthrough）">贯穿（Fallthrough）</h3><p>Swift 中的<code>switch</code>不会从上一个 case 分支落入到下一个 case 分支中。相反，只要第一个匹配到的 case 分支完成了它需要执行的语句，整个<code>switch</code>代码块完成了它的执行。相比之下，C 语言要求你显式地插入<code>break</code>语句到每个<code>switch</code>分支的末尾来阻止自动落入到下一个 case 分支中。Swift 的这种避免默认落入到下一个分支中的特性意味着它的<code>switch</code> 功能要比 C 语言的更加清晰和可预测，可以避免无意识地执行多个 case 分支从而引发的错误。</p>
<p>如果你确实需要 C 风格的贯穿的特性，你可以在每个需要该特性的 case 分支中使用<code>fallthrough</code>关键字。下面的例子使用<code>fallthrough</code>来创建一个数字的描述语句。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> integerToDescribe = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> description = <span class="string">"The number <span class="subst">\(integerToDescribe)</span> is"</span></span><br><span class="line"><span class="keyword">switch</span> integerToDescribe &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>:</span><br><span class="line">    description += <span class="string">" a prime number, and also"</span></span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    description += <span class="string">" an integer."</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(description)</span><br><span class="line"><span class="comment">// 输出 "The number 5 is a prime number, and also an integer."</span></span><br></pre></td></tr></table></figure>
<p>这个例子定义了一个<code>String</code>类型的变量<code>description</code>并且给它设置了一个初始值。函数使用<code>switch</code>逻辑来判断<code>integerToDescribe</code>变量的值。当<code>integerToDescribe</code>的值属于列表中的质数之一时，该函数添加一段文字在<code>description</code>后，来表明这个是数字是一个质数。然后它使用<code>fallthrough</code>关键字来“贯穿”到<code>default</code>分支中。<code>default</code>分支添加一段额外的文字在<code>description</code>的最后，至此<code>switch</code>代码块执行完了。</p>
<p>如果<code>integerToDescribe</code>的值不属于列表中的任何质数，那么它不会匹配到第一个<code>switch</code>分支。而这里没有其他特别的分支情况，所以<code>integerToDescribe</code>匹配到包含所有的<code>default</code>分支中。</p>
<p>当<code>switch</code>代码块执行完后，使用<code>print(_:separator:terminator:)</code>函数打印该数字的描述。在这个例子中，数字<code>5</code>被准确的识别为了一个质数。</p>
<blockquote>
<p>注意：<br><code>fallthrough</code>关键字不会检查它下一个将会落入执行的 case 中的匹配条件。<code>fallthrough</code>简单地使代码执行继续连接到下一个 case 中的执行代码，这和 C 语言标准中的<code>switch</code>语句特性是一样的。</p>
</blockquote>
<p><a name="labeled_statements"></a></p>
<h3 id="带标签的语句">带标签的语句</h3><p>在 Swift 中，你可以在循环体和<code>switch</code>代码块中嵌套循环体和<code>switch</code>代码块来创造复杂的控制流结构。然而，循环体和<code>switch</code>代码块两者都可以使用<code>break</code>语句来提前结束整个方法体。因此，显式地指明<code>break</code>语句想要终止的是哪个循环体或者<code>switch</code>代码块，会很有用。类似地，如果你有许多嵌套的循环体，显式指明<code>continue</code>语句想要影响哪一个循环体也会非常有用。</p>
<p>为了实现这个目的，你可以使用标签来标记一个循环体或者<code>switch</code>代码块，当使用<code>break</code>或者<code>continue</code>时，带上这个标签，可以控制该标签代表对象的中断或者执行。</p>
<p>产生一个带标签的语句是通过在该语句的关键词的同一行前面放置一个标签，并且该标签后面还需带着一个冒号。下面是一个<code>while</code>循环体的语法，同样的规则适用于所有的循环体和<code>switch</code>代码块。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">label name: <span class="keyword">while</span> condition &#123;</span><br><span class="line">	statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的例子是在一个带有标签的<code>while</code>循环体中调用<code>break</code>和<code>continue</code>语句，该循环体是前面章节中<em>蛇和梯子</em>的改编版本。这次，游戏增加了一条额外的规则：</p>
<ul>
<li>为了获胜，你必须<em>刚好</em>落在第 25 个方块中。</li>
</ul>
<p>如果某次掷骰子使你的移动超出第 25 个方块，你必须重新掷骰子，直到你掷出的骰子数刚好使你能落在第 25 个方块中。</p>
<p>游戏的棋盘和之前一样：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/snakesAndLadders_2x.png" alt="image"></p>
<p><code>finalSquare</code>、<code>board</code>、<code>square</code>和<code>diceRoll</code>值被和之前一样的方式初始化：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> finalSquare = <span class="number">25</span></span><br><span class="line"><span class="keyword">var</span> board = [<span class="type">Int</span>](<span class="built_in">count</span>: finalSquare + <span class="number">1</span>, repeatedValue: <span class="number">0</span>)</span><br><span class="line">board[<span class="number">03</span>] = +<span class="number">08</span>; board[<span class="number">06</span>] = +<span class="number">11</span>; board[<span class="number">09</span>] = +<span class="number">09</span>; board[<span class="number">10</span>] = +<span class="number">02</span></span><br><span class="line">board[<span class="number">14</span>] = -<span class="number">10</span>; board[<span class="number">19</span>] = -<span class="number">11</span>; board[<span class="number">22</span>] = -<span class="number">02</span>; board[<span class="number">24</span>] = -<span class="number">08</span></span><br><span class="line"><span class="keyword">var</span> square = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> diceRoll = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这个版本的游戏使用<code>while</code>循环体和<code>switch</code>方法块来实现游戏的逻辑。<code>while</code>循环体有一个标签名<code>gameLoop</code>，来表明它是蛇与梯子的主循环。</p>
<p>该<code>while</code>循环体的条件判断语句是<code>while square !=finalSquare</code>，这表明你必须刚好落在方格25中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">gameLoop: <span class="keyword">while</span> square != finalSquare &#123;</span><br><span class="line">    <span class="keyword">if</span> ++diceRoll == <span class="number">7</span> &#123; diceRoll = <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">switch</span> square + diceRoll &#123;</span><br><span class="line">    <span class="keyword">case</span> finalSquare:</span><br><span class="line">        <span class="comment">// 到达最后一个方块，游戏结束</span></span><br><span class="line">        <span class="keyword">break</span> gameLoop</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> newSquare <span class="keyword">where</span> newSquare &gt; finalSquare:</span><br><span class="line">        <span class="comment">// 超出最后一个方块，再掷一次骰子</span></span><br><span class="line">        <span class="keyword">continue</span> gameLoop</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 本次移动有效</span></span><br><span class="line">        square += diceRoll</span><br><span class="line">        square += board[square]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Game over!"</span>)</span><br></pre></td></tr></table></figure>
<p>每次循环迭代开始时掷骰子。与之前玩家掷完骰子就立即移动不同，这里使用了<code>switch</code>来考虑每次移动可能产生的结果，从而决定玩家本次是否能够移动。</p>
<ul>
<li>如果骰子数刚好使玩家移动到最终的方格里，游戏结束。<code>break gameLoop</code>语句跳转控制去执行<code>while</code>循环体后的第一行代码，游戏结束。</li>
<li>如果骰子数将会使玩家的移动超出最后的方格，那么这种移动是不合法的，玩家需要重新掷骰子。<code>continue gameLoop</code>语句结束本次<code>while</code>循环的迭代，开始下一次循环迭代。</li>
<li>在剩余的所有情况中，骰子数产生的都是合法的移动。玩家向前移动骰子数个方格，然后游戏逻辑再处理玩家当前是否处于蛇头或者梯子的底部。本次循环迭代结束，控制跳转到<code>while</code>循环体的条件判断语句处，再决定是否能够继续执行下次循环迭代。</li>
</ul>
<blockquote>
<p>注意：<br>如果上述的<code>break</code>语句没有使用<code>gameLoop</code>标签，那么它将会中断<code>switch</code>代码块而不是<code>while</code>循环体。使用<code>gameLoop</code>标签清晰的表明了<code>break</code>想要中断的是哪个代码块。<br>同时请注意，当调用<code>continue gameLoop</code>去跳转到下一次循环迭代时，这里使用<code>gameLoop</code>标签并不是严格必须的。因为在这个游戏中，只有一个循环体，所以<code>continue</code>语句会影响到哪个循环体是没有歧义的。然而，<code>continue</code>语句使用<code>gameLoop</code>标签也是没有危害的。这样做符合标签的使用规则，同时参照旁边的<code>break gameLoop</code>，能够使游戏的逻辑更加清晰和易于理解。</p>
</blockquote>
<p><a name="early_exit"></a></p>
<h2 id="提前退出">提前退出</h2><p>像<code>if</code>语句一样，<code>guard</code>的执行取决于一个表达式的布尔值。我们可以使用<code>guard</code>语句来要求条件必须为真时，以执行<code>guard</code>语句后的代码。不同于<code>if</code>语句，一个<code>guard</code>语句总是有一个<code>else</code>分句，如果条件不为真则执行<code>else</code>分句中的代码。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(person: [String: String])</span></span> &#123;</span><br><span class="line">	guard <span class="keyword">let</span> name = person[<span class="string">"name"</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Hello <span class="subst">\(name)</span>"</span>)</span><br><span class="line"></span><br><span class="line">	guard <span class="keyword">let</span> location = person[<span class="string">"location"</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"I hope the weather is nice near you."</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"I hope the weather is nice in <span class="subst">\(location)</span>."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet([<span class="string">"name"</span>: <span class="string">"John"</span>])</span><br><span class="line"><span class="comment">// prints "Hello John!"</span></span><br><span class="line"><span class="comment">// prints "I hope the weather is nice near you."</span></span><br><span class="line">greet([<span class="string">"name"</span>: <span class="string">"Jane"</span>, <span class="string">"location"</span>: <span class="string">"Cupertino"</span>])</span><br><span class="line"><span class="comment">// prints "Hello Jane!"</span></span><br><span class="line"><span class="comment">// prints "I hope the weather is nice in Cupertino."</span></span><br></pre></td></tr></table></figure>
<p>如果<code>guard</code>语句的条件被满足，则在保护语句的封闭大括号结束后继续执行代码。任何使用了可选绑定作为条件的一部分并被分配了值的变量或常量对于剩下的保护语句出现的代码段是可用的。</p>
<p>如果条件不被满足，在<code>else</code>分支上的代码就会被执行。这个分支必须转移控制以退出<code>guard</code>语句出现的代码段。它可以用控制转移语句如<code>return</code>,<code>break</code>,<code>continue</code>或者<code>throw</code>做这件事，或者调用一个不返回的方法或函数，例如<code>fatalError()</code>。</p>
<p>相比于可以实现同样功能的<code>if</code>语句，按需使用<code>guard</code>语句会提升我们代码的可靠性。<br>它可以使你的代码连贯的被执行而不需要将它包在<code>else</code>块中，它可以使你处理违反要求的代码使其接近要求。</p>
<p><a name="checking_api_availability"></a></p>
<h2 id="检测_API_可用性">检测 API 可用性</h2><p>Swift 有检查 API 可用性的内置支持，这可以确保我们不会不小心地使用对于当前部署目标不可用的 API。</p>
<p>编译器使用 SDK 中的可用信息来验证我们的代码中使用的所有 API 在项目指定的部署目标上是否可用。如果我们尝试使用一个不可用的 API，Swift 会在编译期报错。</p>
<p>我们使用一个可用性条件在一个<code>if</code>或<code>guard</code>语句中去有条件的执行一段代码，这取决于我们想要使用的 API 是否在运行时是可用的。编译器使用从可用性条件语句中获取的信息去验证在代码块中调用的 API 是否都可用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> #available(iOS <span class="number">9</span>, <span class="type">OSX</span> <span class="number">10.10</span>, *) &#123;</span><br><span class="line">    <span class="comment">// 在 iOS 使用 iOS 9 的 API, 在 OS X 使用 OS X v10.10 的 API</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 使用先前版本的 iOS 和 OS X 的 API</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上可用性条件指定了在 iOS 系统上，<code>if</code>段的代码仅会在 iOS 9 及更高版本的系统上执行；在 OS X，仅会在 OS X v10.10 及更高版本的系统上执行。最后一个参数，<code>*</code>，是必须写的，用于处理未来潜在的平台。</p>
<p>在它的一般形式中，可用性条件获取了一系列平台名字和版本。平台名字可以是<code>iOS</code>，<code>OSX</code>或<code>watchOS</code>。除了特定的主板本号像 iOS 8，我们可以指定较小的版本号像 iOS 8.3 以及 OS X v10.10.3。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> #available(platform name version, ..., *) &#123;</span><br><span class="line">	statements to execute <span class="keyword">if</span> the <span class="type">APIs</span> are available</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fallback statements to execute <span class="keyword">if</span> the <span class="type">APIs</span> are unavailable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="控制流（Control_Flow）">控制流（Control Flow）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/vclwei" target="_blank" rel="ext]]>
    </summary>
    
      <category term="swift-cn" scheme="http://yoursite.com/tags/swift-cn/"/>
    
      <category term="swift-cn" scheme="http://yoursite.com/categories/swift-cn/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第二章-06函数（Functions）]]></title>
    <link href="http://yoursite.com/2015/12/25/swift-cn/chapter2/06_Functions/"/>
    <id>http://yoursite.com/2015/12/25/swift-cn/chapter2/06_Functions/</id>
    <published>2015-12-25T04:00:21.000Z</published>
    <updated>2015-12-15T05:44:35.621Z</updated>
    <content type="html"><![CDATA[<h1 id="函数（Functions）">函数（Functions）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/honghaoz" target="_blank" rel="external">honghaoz</a><br>校对：<a href="https://github.com/LunaticM" target="_blank" rel="external">LunaticM</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/dreamkidd" target="_blank" rel="external">dreamkidd</a></p>
<p>2.1<br>翻译：<a href="https://github.com/DianQK" target="_blank" rel="external">DianQK</a><br>定稿：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#Defining_and_Calling_Functions">函数定义与调用（Defining and Calling Functions）</a></li>
<li><a href="#Function_Parameters_and_Return_Values">函数参数与返回值（Function Parameters and Return Values）</a></li>
<li><a href="#Function_Parameter_Names">函数参数名称（Function Parameter Names）</a></li>
<li><a href="#Function_Types">函数类型（Function Types）</a></li>
<li><a href="#Nested_Functions">嵌套函数（Nested Functions）</a></li>
</ul>
<p><em>函数</em>是用来完成特定任务的独立的代码块。你给一个函数起一个合适的名字，用来标识函数做什么，并且当函数需要执行的时候，这个名字会被用于“调用”函数。</p>
<p>Swift 统一的函数语法足够灵活，可以用来表示任何函数，包括从最简单的没有参数名字的 C 风格函数，到复杂的带局部和外部参数名的 Objective-C 风格函数。参数可以提供默认值，以简化函数调用。参数也可以既当做传入参数，也当做传出参数，也就是说，一旦函数执行结束，传入的参数值可以被修改。</p>
<p>在 Swift 中，每个函数都有一种类型，包括函数的参数值类型和返回值类型。你可以把函数类型当做任何其他普通变量类型一样处理，这样就可以更简单地把函数当做别的函数的参数，也可以从其他函数中返回函数。函数的定义可以写在在其他函数定义中，这样可以在嵌套函数范围内实现功能封装。</p>
<p><a name="Defining_and_Calling_Functions"></a></p>
<h2 id="函数的定义与调用（Defining_and_Calling_Functions）">函数的定义与调用（Defining and Calling Functions）</h2><p>当你定义一个函数时，你可以定义一个或多个有名字和类型的值，作为函数的输入（称为<em>参数，parameters</em>），也可以定义某种类型的值作为函数执行结束的输出（称为<em>返回类型，return type</em>）。</p>
<p>每个函数有个<em>函数名</em>，用来描述函数执行的任务。要使用一个函数时，你用函数名“调用”，并传给它匹配的输入值（称作<em>实参，arguments</em>）。一个函数的实参必须与函数参数表里参数的顺序一致。</p>
<p>在下面例子中的函数叫做<code>&quot;sayHello(_:)&quot;</code>，之所以叫这个名字,是因为这个函数用一个人的名字当做输入，并返回给这个人的问候语。为了完成这个任务，你定义一个输入参数-一个叫做 <code>personName</code> 的 <code>String</code> 值，和一个包含给这个人问候语的 <code>String</code> 类型的返回值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(personName: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> greeting = <span class="string">"Hello, "</span> + personName + <span class="string">"!"</span></span><br><span class="line">    <span class="keyword">return</span> greeting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的这些信息汇总起来成为函数的<em>定义</em>，并以 <code>func</code> 作为前缀。指定函数返回类型时，用返回箭头 <code>-&gt;</code>（一个连字符后跟一个右尖括号）后跟返回类型的名称的方式来表示。</p>
<p>该定义描述了函数做什么，它期望接收什么和执行结束时它返回的结果是什么类型。这样的定义使得函数可以在别的地方以一种清晰的方式被调用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(sayHello(<span class="string">"Anna"</span>))</span><br><span class="line"><span class="comment">// prints "Hello, Anna!"</span></span><br><span class="line"><span class="built_in">print</span>(sayHello(<span class="string">"Brian"</span>))</span><br><span class="line"><span class="comment">// prints "Hello, Brian!"</span></span><br></pre></td></tr></table></figure>
<p>调用 <code>sayHello(_:)</code> 函数时，在圆括号中传给它一个 <code>String</code> 类型的实参，例如 <code>sayHello(&quot;Anna&quot;)</code>。因为这个函数返回一个 <code>String</code> 类型的值，<code>sayHello</code> 可以被包含在 <code>print(_:separator:terminator:)</code> 的调用中，用来输出这个函数的返回值，正如上面所示。</p>
<p>在 <code>sayHello(_:)</code> 的函数体中，先定义了一个新的名为 <code>greeting</code> 的 <code>String</code> 常量，同时赋值了给 <code>personName</code> 的一个简单问候消息。然后用 <code>return</code> 关键字把这个问候返回出去。一旦 <code>return greeting</code> 被调用，该函数结束它的执行并返回 <code>greeting</code> 的当前值。</p>
<p>你可以用不同的输入值多次调用 <code>sayHello(_:)</code>。上面的例子展示的是用<code>&quot;Anna&quot;</code>和<code>&quot;Brian&quot;</code>调用的结果，该函数分别返回了不同的结果。</p>
<p>为了简化这个函数的定义，可以将问候消息的创建和返回写成一句：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">sayHelloAgain</span><span class="params">(personName: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello again, "</span> + personName + <span class="string">"!"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(sayHelloAgain(<span class="string">"Anna"</span>))</span><br><span class="line"><span class="comment">// prints "Hello again, Anna!"</span></span><br></pre></td></tr></table></figure>
<p><a name="Function_Parameters_and_Return_Values"></a></p>
<h2 id="函数参数与返回值（Function_Parameters_and_Return_Values）">函数参数与返回值（Function Parameters and Return Values）</h2><p>函数参数与返回值在 Swift 中极为灵活。你可以定义任何类型的函数，包括从只带一个未名参数的简单函数到复杂的带有表达性参数名和不同参数选项的复杂函数。</p>
<h3 id="无参函数（Functions_Without_Parameters）">无参函数（Functions Without Parameters）</h3><p>函数可以没有参数。下面这个函数就是一个无参函数，当被调用时，它返回固定的 <code>String</code> 消息：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">sayHelloWorld</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello, world"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(sayHelloWorld())</span><br><span class="line"><span class="comment">// prints "hello, world"</span></span><br></pre></td></tr></table></figure>
<p>尽管这个函数没有参数，但是定义中在函数名后还是需要一对圆括号。当被调用时，也需要在函数名后写一对圆括号。</p>
<h3 id="多参数函数_(Functions_With_Multiple_Parameters)">多参数函数 (Functions With Multiple Parameters)</h3><p>函数可以有多种输入参数，这些参数被包含在函数的括号之中，以逗号分隔。</p>
<p>这个函数取得一个人的名字和是否被招呼作为输入，并对那个人返回适当的问候语:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(personName: String, alreadyGreeted: Bool)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> alreadyGreeted &#123;</span><br><span class="line">        <span class="keyword">return</span> sayHelloAgain(personName)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sayHello(personName)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(sayHello(<span class="string">"Tim"</span>, alreadyGreeted: <span class="literal">true</span>))</span><br><span class="line"><span class="comment">// prints "Hello again, Tim!"</span></span><br></pre></td></tr></table></figure>
<p>你通过在括号内传递一个<code>String</code>参数值和一个标识为<code>alreadyGreeted</code>的<code>Bool</code>值，使用逗号分隔来调用<code>sayHello(_:alreadyGreeted:)</code>函数。</p>
<p>当调用超过一个参数的函数时，第一个参数后的参数根据其对应的参数名称标记，函数参数命名在<a href="#Function_Parameter_Names">函数参数名称（Function Parameter Names）</a>有更详细的描述。</p>
<p><a name="functions_without_return_values"></a></p>
<h3 id="无返回值函数（Functions_Without_Return_Values）">无返回值函数（Functions Without Return Values）</h3><p>函数可以没有返回值。下面是 <code>sayHello(_:)</code> 函数的另一个版本，叫 <code>sayGoodbye(_:)</code>，这个函数直接输出 <code>String</code> 值，而不是返回它：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">sayGoodbye</span><span class="params">(personName: String)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Goodbye, <span class="subst">\(personName)</span>!"</span>)</span><br><span class="line">&#125;</span><br><span class="line">sayGoodbye(<span class="string">"Dave"</span>)</span><br><span class="line"><span class="comment">// prints "Goodbye, Dave!"</span></span><br></pre></td></tr></table></figure>
<p>因为这个函数不需要返回值，所以这个函数的定义中没有返回箭头（-&gt;）和返回类型。</p>
<blockquote>
<p>注意<br>严格上来说，虽然没有返回值被定义，<code>sayGoodbye(_:)</code> 函数依然返回了值。没有定义返回类型的函数会返回特殊的值，叫 <code>Void</code>。它其实是一个空的元组（tuple），没有任何元素，可以写成<code>()</code>。</p>
</blockquote>
<p>被调用时，一个函数的返回值可以被忽略：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">printAndCount</span><span class="params">(stringToPrint: String)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(stringToPrint)</span><br><span class="line">    <span class="keyword">return</span> stringToPrint.characters.<span class="built_in">count</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">printWithoutCounting</span><span class="params">(stringToPrint: String)</span></span> &#123;</span><br><span class="line">    printAndCount(stringToPrint)</span><br><span class="line">&#125;</span><br><span class="line">printAndCount(<span class="string">"hello, world"</span>)</span><br><span class="line"><span class="comment">// prints "hello, world" and returns a value of 12</span></span><br><span class="line">printWithoutCounting(<span class="string">"hello, world"</span>)</span><br><span class="line"><span class="comment">// prints "hello, world" but does not return a value</span></span><br></pre></td></tr></table></figure>
<p>第一个函数 <code>printAndCount(_:)</code>，输出一个字符串并返回 <code>Int</code> 类型的字符数。第二个函数 <code>printWithoutCounting</code>调用了第一个函数，但是忽略了它的返回值。当第二个函数被调用时，消息依然会由第一个函数输出，但是返回值不会被用到。</p>
<blockquote>
<p>注意<br>返回值可以被忽略，但定义了有返回值的函数必须返回一个值，如果在函数定义底部没有返回任何值，将导致编译错误（compile-time error）。</p>
</blockquote>
<p><a name="functions_with_multiple_return_values"></a></p>
<h3 id="多重返回值函数（Functions_with_Multiple_Return_Values）">多重返回值函数（Functions with Multiple Return Values）</h3><p>你可以用元组（tuple）类型让多个值作为一个复合值从函数中返回。</p>
<p>下面的这个例子中，定义了一个名为<code>minMax(_:)</code>的函数，作用是在一个<code>Int</code>数组中找出最小值与最大值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">minMax</span><span class="params">(array: [Int])</span></span> -&gt; (<span class="built_in">min</span>: <span class="type">Int</span>, <span class="built_in">max</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> currentMin = array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> currentMax = array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> array[<span class="number">1</span>..&lt;array.<span class="built_in">count</span>] &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; currentMin &#123;</span><br><span class="line">            currentMin = value</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value &gt; currentMax &#123;</span><br><span class="line">            currentMax = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (currentMin, currentMax)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>minMax(_:)</code>函数返回一个包含两个<code>Int</code>值的元组，这些值被标记为<code>min</code>和<code>max</code>，以便查询函数的返回值时可以通过名字访问它们。</p>
<p><code>minMax(_:)</code>的函数体中，在开始的时候设置两个工作变量<code>currentMin</code>和<code>currentMax</code>的值为数组中的第一个数。然后函数会遍历数组中剩余的值并检查该值是否比<code>currentMin</code>和<code>currentMax</code>更小或更大。最后数组中的最小值与最大值作为一个包含两个<code>Int</code>值的元组返回。</p>
<p>因为元组的成员值已被命名，因此可以通过点语法来检索找到的最小值与最大值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bounds = minMax([<span class="number">8</span>, -<span class="number">6</span>, <span class="number">2</span>, <span class="number">109</span>, <span class="number">3</span>, <span class="number">71</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"min is <span class="subst">\(bounds.<span class="built_in">min</span>)</span> and max is <span class="subst">\(bounds.<span class="built_in">max</span>)</span>"</span>)</span><br><span class="line"><span class="comment">// prints "min is -6 and max is 109"</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，元组的成员不需要在元组从函数中返回时命名，因为它们的名字已经在函数返回类型中指定了。</p>
<p><a name="optional_tuple_return_types"></a></p>
<p>###可选元组返回类型(Optional Tuple Return Types)</p>
<p>如果函数返回的元组类型有可能整个元组都“没有值”，你可以使用<em>可选的（Optional）</em> 元组返回类型反映整个元组可以是<code>nil</code>的事实。你可以通过在元组类型的右括号后放置一个问号来定义一个可选元组，例如<code>(Int, Int)?</code>或<code>(String, Int, Bool)?</code></p>
<blockquote>
<p>注意<br>可选元组类型如<code>(Int, Int)?</code>与元组包含可选类型如<code>(Int?, Int?)</code>是不同的.可选的元组类型，整个元组是可选的，而不只是元组中的每个元素值。</p>
</blockquote>
<p>前面的<code>minMax(_:)</code>函数返回了一个包含两个<code>Int</code>值的元组。但是函数不会对传入的数组执行任何安全检查，如果<code>array</code>参数是一个空数组，如上定义的<code>minMax(_:)</code>在试图访问<code>array[0]</code>时会触发一个运行时错误。</p>
<p>为了安全地处理这个“空数组”问题，将<code>minMax(_:)</code>函数改写为使用可选元组返回类型，并且当数组为空时返回<code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">minMax</span><span class="params">(array: [Int])</span></span> -&gt; (<span class="built_in">min</span>: <span class="type">Int</span>, <span class="built_in">max</span>: <span class="type">Int</span>)? &#123;</span><br><span class="line">    <span class="keyword">if</span> array.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> currentMin = array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> currentMax = array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> array[<span class="number">1</span>..&lt;array.<span class="built_in">count</span>] &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; currentMin &#123;</span><br><span class="line">            currentMin = value</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value &gt; currentMax &#123;</span><br><span class="line">            currentMax = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (currentMin, currentMax)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以使用可选绑定来检查<code>minMax(_:)</code>函数返回的是一个实际的元组值还是<code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> bounds = minMax([<span class="number">8</span>, -<span class="number">6</span>, <span class="number">2</span>, <span class="number">109</span>, <span class="number">3</span>, <span class="number">71</span>]) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"min is <span class="subst">\(bounds.<span class="built_in">min</span>)</span> and max is <span class="subst">\(bounds.<span class="built_in">max</span>)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// prints "min is -6 and max is 109"</span></span><br></pre></td></tr></table></figure>
<p><a name="Function_Parameter_Names"></a></p>
<h2 id="函数参数名称（Function_Parameter_Names）">函数参数名称（Function Parameter Names）</h2><p>函数参数都有一个<em>外部参数名（external parameter name）</em>和一个<em>局部参数名（local parameter name）</em>。外部参数名用于在函数调用时标注传递给函数的参数，局部参数名在函数的实现内部使用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">(firstParameterName: Int, secondParameterName: Int)</span></span> &#123;</span><br><span class="line">    <span class="comment">// function body goes here</span></span><br><span class="line">    <span class="comment">// firstParameterName and secondParameterName refer to</span></span><br><span class="line">    <span class="comment">// the argument values for the first and second parameters</span></span><br><span class="line">&#125;</span><br><span class="line">someFunction(<span class="number">1</span>, secondParameterName: <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>一般情况下，第一个参数省略其外部参数名，第二个以及随后的参数使用其局部参数名作为外部参数名。所有参数必须有独一无二的局部参数名。尽管多个参数可以有相同的外部参数名，但不同的外部参数名能让你的代码更有可读性。</p>
<p><a name="specifying_external_parameter_names"></a></p>
<h3 id="指定外部参数名（Specifying_External_Parameter_Names）">指定外部参数名（Specifying External Parameter Names）</h3><p>你可以在局部参数名前指定外部参数名，中间以空格分隔：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">(externalParameterName localParameterName: Int)</span></span> &#123;</span><br><span class="line">    <span class="comment">// function body goes here, and can use localParameterName</span></span><br><span class="line">    <span class="comment">// to refer to the argument value for that parameter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>如果你提供了外部参数名，那么函数在被调用时，必须使用外部参数名。</p>
</blockquote>
<p>这个版本的<code>sayHello(_:)</code>函数，接收两个人的名字，会同时返回对他俩的问候：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(to person: String, and anotherPerson: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello <span class="subst">\(person)</span> and <span class="subst">\(anotherPerson)</span>!"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(sayHello(to: <span class="string">"Bill"</span>, and: <span class="string">"Ted"</span>))</span><br><span class="line"><span class="comment">// prints "Hello Bill and Ted!"</span></span><br></pre></td></tr></table></figure>
<p>为每个参数指定外部参数名后，在你调用<code>sayHello(to:and:)</code>函数时两个外部参数名都必须写出来。</p>
<p>使用外部函数名可以使函数以一种更富有表达性的类似句子的方式调用，并使函数体意图清晰，更具可读性。</p>
<h3 id="忽略外部参数名（Omitting_External_Parameter_Names）">忽略外部参数名（Omitting External Parameter Names）</h3><p>如果你不想为第二个及后续的参数设置外部参数名，用一个下划线（<code>_</code>）代替一个明确的参数名。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">(firstParameterName: Int, <span class="number">_</span> secondParameterName: Int)</span></span> &#123;</span><br><span class="line">    <span class="comment">// function body goes here</span></span><br><span class="line">    <span class="comment">// firstParameterName and secondParameterName refer to</span></span><br><span class="line">    <span class="comment">// the argument values for the first and second parameters</span></span><br><span class="line">&#125;</span><br><span class="line">someFunction(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>因为第一个参数默认忽略其外部参数名称，显式地写下划线是多余的。</p>
</blockquote>
<p><a name="default_parameter_values"></a></p>
<h3 id="默认参数值（Default_Parameter_Values）">默认参数值（Default Parameter Values）</h3><p>你可以在函数体中为每个参数定义<code>默认值（Deafult Values）</code>。当默认值被定义后，调用这个函数时可以忽略这个参数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">(parameterWithDefault: Int = <span class="number">12</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// function body goes here</span></span><br><span class="line">    <span class="comment">// if no arguments are passed to the function call,</span></span><br><span class="line">    <span class="comment">// value of parameterWithDefault is 12</span></span><br><span class="line">&#125;</span><br><span class="line">someFunction(<span class="number">6</span>) <span class="comment">// parameterWithDefault is 6</span></span><br><span class="line">someFunction() <span class="comment">// parameterWithDefault is 12</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>将带有默认值的参数放在函数参数列表的最后。这样可以保证在函数调用时，非默认参数的顺序是一致的，同时使得相同的函数在不同情况下调用时显得更为清晰。</p>
</blockquote>
<p><a name="variadic_parameters"></a></p>
<h3 id="可变参数（Variadic_Parameters）">可变参数（Variadic Parameters）</h3><p>一个<code>可变参数（variadic parameter）</code>可以接受零个或多个值。函数调用时，你可以用可变参数来指定函数参数可以被传入不确定数量的输入值。通过在变量类型名后面加入<code>（...）</code>的方式来定义可变参数。</p>
<p>可变参数的传入值在函数体中变为此类型的一个数组。例如，一个叫做 <code>numbers</code> 的 <code>Double...</code> 型可变参数，在函数体内可以当做一个叫 <code>numbers</code> 的 <code>[Double]</code> 型的数组常量。</p>
<p>下面的这个函数用来计算一组任意长度数字的<code>算术平均数（arithmetic mean）</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">arithmeticMean</span><span class="params">(numbers: Double...)</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> total: <span class="type">Double</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        total += number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total / <span class="type">Double</span>(numbers.<span class="built_in">count</span>)</span><br><span class="line">&#125;</span><br><span class="line">arithmeticMean(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// returns 3.0, which is the arithmetic mean of these five numbers</span></span><br><span class="line">arithmeticMean(<span class="number">3</span>, <span class="number">8.25</span>, <span class="number">18.75</span>)</span><br><span class="line"><span class="comment">// returns 10.0, which is the arithmetic mean of these three numbers</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>一个函数最多只能有一个可变参数。</p>
</blockquote>
<p>如果函数有一个或多个带默认值的参数，而且还有一个可变参数，那么把可变参数放在参数表的最后。</p>
<p><a name="constant_and_variable_parameters"></a></p>
<h3 id="常量参数和变量参数（Constant_and_Variable_Parameters）">常量参数和变量参数（Constant and Variable Parameters）</h3><p>函数参数默认是常量。试图在函数体中更改参数值将会导致编译错误。这意味着你不能错误地更改参数值。</p>
<p>但是，有时候，如果函数中有传入参数的变量值副本将是很有用的。你可以通过指定一个或多个参数为变量参数，从而避免自己在函数中定义新的变量。变量参数不是常量，你可以在函数中把它当做新的可修改副本来使用。</p>
<p>通过在参数名前加关键字 <code>var</code> 来定义变量参数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">alignRight</span><span class="params">(<span class="keyword">var</span> string: String, totalLength: Int, pad: Character)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> amountToPad = totalLength - string.characters.<span class="built_in">count</span></span><br><span class="line">    <span class="keyword">if</span> amountToPad &lt; <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> string</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> padString = <span class="type">String</span>(pad)</span><br><span class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>...amountToPad &#123;</span><br><span class="line">        string = padString + string</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> string</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> originalString = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">let</span> paddedString = alignRight(originalString, totalLength: <span class="number">10</span>, pad: <span class="string">"-"</span>)</span><br><span class="line"><span class="comment">// paddedString is equal to "-----hello"</span></span><br><span class="line"><span class="comment">// originalString is still equal to "hello"</span></span><br></pre></td></tr></table></figure>
<p>这个例子中定义了一个叫做 <code>alignRight(_:totalLength:pad:)</code> 的新函数，用来将输入的字符串对齐到更长的输出字符串的右边缘。左侧空余的地方用指定的填充字符填充。这个例子中，字符串<code>&quot;hello&quot;</code>被转换成了<code>&quot;-----hello&quot;</code>。</p>
<p><code>alignRight(_:totalLength:pad:)</code> 函数将输入参数 <code>string</code> 定义为变量参数。这意味着 <code>string</code> 现在可以作为一个局部变量，被传入的字符串值初始化，并且可以在函数体中进行操作。</p>
<p>函数首先计算出有多少字符需要被添加到<code>string</code>的左边，从而将其在整个字符串中右对齐。这个值存储在一个称为<code>amountToPad</code>的本地常量。如果不需要填充（也就是说，如果<code>amountToPad</code>小于1），该函数简单地返回没有任何填充的输入值<code>string</code>。</p>
<p>否则，该函数用<code>pad</code>字符创建一个叫做<code>padString</code>的临时<code>String</code>常量，并将<code>amountToPad</code>个 <code>padString</code>添加到现有字符串的左边。（一个<code>String</code>值不能被添加到一个<code>Character</code>值上，所以<code>padString</code>常量用于确保<code>+</code>操作符两侧都是<code>String</code>值）。</p>
<blockquote>
<p>注意<br>对变量参数所进行的修改在函数调用结束后便消失了，并且对于函数体外是不可见的。变量参数仅仅存在于函数调用的生命周期中。</p>
</blockquote>
<p><a name="in_out_parameters"></a></p>
<h3 id="输入输出参数（In-Out_Parameters）">输入输出参数（In-Out Parameters）</h3><p>变量参数，正如上面所述，仅仅能在函数体内被更改。如果你想要一个函数可以修改参数的值，并且想要在这些修改在函数调用结束后仍然存在，那么就应该把这个参数定义为输入输出参数（In-Out Parameters）。</p>
<p>定义一个输入输出参数时，在参数定义前加 <code>inout</code> 关键字。一个输入输出参数有传入函数的值，这个值被函数修改，然后被传出函数，替换原来的值。想获取更多的关于输入输出参数的细节和相关的编译器优化，请查看<a href="../chapter3/05_Declarations.html#function_declaration">输入输出参数</a>一节。</p>
<!--上面的链接对应的内容没有更新翻译-->
<p>你只能传递变量给输入输出参数。你不能传入常量或者字面量（literal value），因为这些量是不能被修改的。当传入的参数作为输入输出参数时，需要在参数名前加<code>&amp;</code>符，表示这个值可以被函数修改。</p>
<blockquote>
<p>注意<br>输入输出参数不能有默认值，而且可变参数不能用 <code>inout</code> 标记。如果你用 <code>inout</code> 标记一个参数，这个参数不能被 <code>var</code> 或者 <code>let</code> 标记。</p>
</blockquote>
<p>下面是例子，<code>swapTwoInts(_:_:)</code> 函数，有两个分别叫做 <code>a</code> 和 <code>b</code> 的输入输出参数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">swapTwoInts</span><span class="params">(<span class="keyword">inout</span> a: Int, <span class="keyword">inout</span> <span class="number">_</span> b: Int)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA = a</span><br><span class="line">    a = b</span><br><span class="line">    b = temporaryA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 <code>swapTwoInts(_:_:)</code> 函数简单地交换 <code>a</code> 与 <code>b</code> 的值。该函数先将 <code>a</code> 的值存到一个临时常量 <code>temporaryA</code> 中，然后将 <code>b</code> 的值赋给 <code>a</code>，最后将 <code>temporaryA</code> 赋值给 <code>b</code>。</p>
<p>你可以用两个 <code>Int</code> 型的变量来调用 <code>swapTwoInts(_:_:)</code>。需要注意的是，<code>someInt</code> 和 <code>anotherInt</code> 在传入 <code>swapTwoInts(_:_:)</code> 函数前，都加了 <code>&amp;</code> 的前缀：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someInt = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> anotherInt = <span class="number">107</span></span><br><span class="line">swapTwoInts(&amp;someInt, &amp;anotherInt)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"someInt is now <span class="subst">\(someInt)</span>, and anotherInt is now <span class="subst">\(anotherInt)</span>"</span>)</span><br><span class="line"><span class="comment">// prints "someInt is now 107, and anotherInt is now 3"</span></span><br></pre></td></tr></table></figure>
<p>从上面这个例子中，我们可以看到 <code>someInt</code> 和 <code>anotherInt</code> 的原始值在 <code>swapTwoInts(_:_:)</code> 函数中被修改，尽管它们的定义在函数体外。</p>
<blockquote>
<p>注意<br>输入输出参数和返回值是不一样的。上面的 <code>swapTwoInts</code> 函数并没有定义任何返回值，但仍然修改了 <code>someInt</code> 和 <code>anotherInt</code> 的值。输入输出参数是函数对函数体外产生影响的另一种方式。</p>
</blockquote>
<p><a name="Function_Types"></a></p>
<h2 id="函数类型（Function_Types）">函数类型（Function Types）</h2><p>每个函数都有种特定的函数类型，由函数的参数类型和返回类型组成。</p>
<p>例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">addTwoInts</span><span class="params">(a: Int, <span class="number">_</span> b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">multiplyTwoInts</span><span class="params">(a: Int, <span class="number">_</span> b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中定义了两个简单的数学函数：<code>addTwoInts</code> 和 <code>multiplyTwoInts</code>。这两个函数都接受两个 <code>Int</code> 值， 返回一个<code>Int</code>值。</p>
<p>这两个函数的类型是 <code>(Int, Int) -&gt; Int</code>，可以解读为“这个函数类型有两个 <code>Int</code> 型的参数并返回一个 <code>Int</code> 型的值。”。</p>
<p>下面是另一个例子，一个没有参数，也没有返回值的函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">printHelloWorld</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"hello, world"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的类型是：<code>() -&gt; void</code>，或者叫“没有参数，并返回 <code>Void</code> 类型的函数”。</p>
<p><a name="using_function_types"></a></p>
<h3 id="使用函数类型（Using_Function_Types）">使用函数类型（Using Function Types）</h3><p>在 Swift 中，使用函数类型就像使用其他类型一样。例如，你可以定义一个类型为函数的常量或变量，并将适当的函数赋值给它：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mathFunction: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span> = addTwoInts</span><br></pre></td></tr></table></figure>
<p>这个可以解读为：</p>
<p>“定义一个叫做 <code>mathFunction</code> 的变量，类型是‘一个有两个 <code>Int</code> 型的参数并返回一个 <code>Int</code> 型的值的函数’，并让这个新变量指向 <code>addTwoInts</code> 函数”。</p>
<p><code>addTwoInts</code> 和 <code>mathFunction</code> 有同样的类型，所以这个赋值过程在 Swift 类型检查中是允许的。</p>
<p>现在，你可以用 <code>mathFunction</code> 来调用被赋值的函数了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Result: <span class="subst">\(mathFunction(<span class="number">2</span>, <span class="number">3</span>)</span>)"</span>)</span><br><span class="line"><span class="comment">// prints "Result: 5"</span></span><br></pre></td></tr></table></figure>
<p>有相同匹配类型的不同函数可以被赋值给同一个变量，就像非函数类型的变量一样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mathFunction = multiplyTwoInts</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Result: <span class="subst">\(mathFunction(<span class="number">2</span>, <span class="number">3</span>)</span>)"</span>)</span><br><span class="line"><span class="comment">// prints "Result: 6"</span></span><br></pre></td></tr></table></figure>
<p>就像其他类型一样，当赋值一个函数给常量或变量时，你可以让 Swift 来推断其函数类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherMathFunction = addTwoInts</span><br><span class="line"><span class="comment">// anotherMathFunction is inferred to be of type (Int, Int) -&gt; Int</span></span><br></pre></td></tr></table></figure>
<p><a name="function_types_as_parameter_types"></a></p>
<h3 id="函数类型作为参数类型（Function_Types_as_Parameter_Types）">函数类型作为参数类型（Function Types as Parameter Types）</h3><p>你可以用<code>(Int, Int) -&gt; Int</code>这样的函数类型作为另一个函数的参数类型。这样你可以将函数的一部分实现留给函数的调用者来提供。</p>
<p>下面是另一个例子，正如上面的函数一样，同样是输出某种数学运算结果：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">printMathResult</span><span class="params">(mathFunction: <span class="params">(Int, Int)</span></span></span> -&gt; <span class="type">Int</span>, <span class="number">_</span> a: <span class="type">Int</span>, <span class="number">_</span> b: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Result: <span class="subst">\(mathFunction(a, b)</span>)"</span>)</span><br><span class="line">&#125;</span><br><span class="line">printMathResult(addTwoInts, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// prints "Result: 8"</span></span><br></pre></td></tr></table></figure>
<p>这个例子定义了 <code>printMathResult(_:_:_:)</code> 函数，它有三个参数：第一个参数叫 <code>mathFunction</code>，类型是<code>(Int, Int) -&gt; Int</code>，你可以传入任何这种类型的函数；第二个和第三个参数叫 <code>a</code> 和 <code>b</code>，它们的类型都是 <code>Int</code>，这两个值作为已给出的函数的输入值。</p>
<p>当 <code>printMathResult(_:_:_:)</code> 被调用时，它被传入 <code>addTwoInts</code> 函数和整数<code>3</code>和<code>5</code>。它用传入<code>3</code>和<code>5</code>调用 <code>addTwoInts</code>，并输出结果：<code>8</code>。</p>
<p><code>printMathResult(_:_:_:)</code> 函数的作用就是输出另一个适当类型的数学函数的调用结果。它不关心传入函数是如何实现的，它只关心这个传入的函数类型是正确的。这使得 <code>printMathResult(_:_:_:)</code> 能以一种类型安全（type-safe）的方式将一部分功能转给调用者实现。</p>
<p><a name="function_types_as_return_types"></a></p>
<h3 id="函数类型作为返回类型（Function_Types_as_Return_Types）">函数类型作为返回类型（Function Types as Return Types）</h3><p>你可以用函数类型作为另一个函数的返回类型。你需要做的是在返回箭头（<code>-&gt;</code>）后写一个完整的函数类型。</p>
<p>下面的这个例子中定义了两个简单函数，分别是 <code>stepForward</code> 和<code>stepBackward</code>。<code>stepForward</code> 函数返回一个比输入值大一的值。<code>stepBackward</code> 函数返回一个比输入值小一的值。这两个函数的类型都是 <code>(Int) -&gt; Int</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">stepForward</span><span class="params">(input: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> input + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">stepBackward</span><span class="params">(input: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> input - <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面这个叫做 <code>chooseStepFunction(_:)</code> 的函数，它的返回类型是 <code>(Int) -&gt; Int</code> 类型的函数。<code>chooseStepFunction(_:)</code> 根据布尔值 <code>backwards</code> 来返回 <code>stepForward(_:)</code> 函数或 <code>stepBackward(_:)</code> 函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">chooseStepFunction</span><span class="params">(backwards: Bool)</span></span> -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> backwards ? stepBackward : stepForward</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你现在可以用 <code>chooseStepFunction(_:)</code> 来获得两个函数其中的一个：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> currentValue = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> moveNearerToZero = chooseStepFunction(currentValue &gt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// moveNearerToZero now refers to the stepBackward() function</span></span><br></pre></td></tr></table></figure>
<p>上面这个例子中计算出从 <code>currentValue</code> 逐渐接近到<code>0</code>是需要向正数走还是向负数走。<code>currentValue</code> 的初始值是<code>3</code>，这意味着 <code>currentValue &gt; 0</code> 是真的（<code>true</code>），这将使得 <code>chooseStepFunction(_:)</code> 返回 <code>stepBackward(_:)</code> 函数。一个指向返回的函数的引用保存在了 <code>moveNearerToZero</code> 常量中。</p>
<p>现在，<code>moveNearerToZero</code> 指向了正确的函数，它可以被用来数到<code>0</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Counting to zero:"</span>)</span><br><span class="line"><span class="comment">// Counting to zero:</span></span><br><span class="line"><span class="keyword">while</span> currentValue != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(currentValue)</span>... "</span>)</span><br><span class="line">    currentValue = moveNearerToZero(currentValue)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"zero!"</span>)</span><br><span class="line"><span class="comment">// 3...</span></span><br><span class="line"><span class="comment">// 2...</span></span><br><span class="line"><span class="comment">// 1...</span></span><br><span class="line"><span class="comment">// zero!</span></span><br></pre></td></tr></table></figure>
<p><a name="Nested_Functions"></a></p>
<h2 id="嵌套函数（Nested_Functions）">嵌套函数（Nested Functions）</h2><p>这章中你所见到的所有函数都叫全局函数（global functions），它们定义在全局域中。你也可以把函数定义在别的函数体中，称作嵌套函数（nested functions）。</p>
<p>默认情况下，嵌套函数是对外界不可见的，但是可以被它们的外围函数（enclosing function）调用。一个外围函数也可以返回它的某一个嵌套函数，使得这个函数可以在其他域中被使用。</p>
<p>你可以用返回嵌套函数的方式重写 <code>chooseStepFunction(_:)</code> 函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">chooseStepFunction</span><span class="params">(backwards: Bool)</span></span> -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">stepForward</span><span class="params">(input: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> input + <span class="number">1</span> &#125;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">stepBackward</span><span class="params">(input: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> input - <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> backwards ? stepBackward : stepForward</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> currentValue = -<span class="number">4</span></span><br><span class="line"><span class="keyword">let</span> moveNearerToZero = chooseStepFunction(currentValue &gt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// moveNearerToZero now refers to the nested stepForward() function</span></span><br><span class="line"><span class="keyword">while</span> currentValue != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(currentValue)</span>... "</span>)</span><br><span class="line">    currentValue = moveNearerToZero(currentValue)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"zero!"</span>)</span><br><span class="line"><span class="comment">// -4...</span></span><br><span class="line"><span class="comment">// -3...</span></span><br><span class="line"><span class="comment">// -2...</span></span><br><span class="line"><span class="comment">// -1...</span></span><br><span class="line"><span class="comment">// zero!</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="函数（Functions）">函数（Functions）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/honghaoz" target="_blank" rel="external"]]>
    </summary>
    
      <category term="swift-cn" scheme="http://yoursite.com/tags/swift-cn/"/>
    
      <category term="swift-cn" scheme="http://yoursite.com/categories/swift-cn/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第二章-07闭包（Closures）]]></title>
    <link href="http://yoursite.com/2015/12/25/swift-cn/chapter2/07_Closures/"/>
    <id>http://yoursite.com/2015/12/25/swift-cn/chapter2/07_Closures/</id>
    <published>2015-12-25T04:00:20.000Z</published>
    <updated>2015-12-15T05:44:31.780Z</updated>
    <content type="html"><![CDATA[<h1 id="闭包（Closures）">闭包（Closures）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/wh1100717" target="_blank" rel="external">wh1100717</a><br>校对：<a href="https://github.com/lyuka" target="_blank" rel="external">lyuka</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/100mango" target="_blank" rel="external">100mango</a></p>
<p>2.1<br>翻译：<a href="https://github.com/100mango" target="_blank" rel="external">100mango</a>, <a href="https://github.com/magicdict" target="_blank" rel="external">magicdict</a><br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#closure_expressions">闭包表达式（Closure Expressions）</a></li>
<li><a href="#trailing_closures">尾随闭包（Trailing Closures）</a></li>
<li><a href="#capturing_values">值捕获（Capturing Values）</a></li>
<li><a href="#closures_are_reference_types">闭包是引用类型（Closures Are Reference Types）</a></li>
<li><a href="#nonescaping_closures">非逃逸闭包(Nonescaping Closures) </a></li>
<li><a href="#autoclosures">自动闭包（Autoclosures）</a></li>
</ul>
<p>闭包是自包含的函数代码块，可以在代码中被传递和使用。Swift 中的闭包与 C 和 Objective-C 中的代码块（blocks）以及其他一些编程语言中的匿名函数比较相似。</p>
<p>闭包可以捕获和存储其所在上下文中任意常量和变量的引用。这就是所谓的闭合并包裹着这些常量和变量，俗称闭包。Swift 会为您管理在捕获过程中涉及到的所有内存操作。</p>
<blockquote>
<p>注意<br>如果您不熟悉捕获（capturing）这个概念也不用担心，您可以在<a href="#capturing_values">值捕获</a>章节对其进行详细了解。</p>
</blockquote>
<p>在<a href="./06_Functions.html">函数</a>章节中介绍的全局和嵌套函数实际上也是特殊的闭包，闭包采取如下三种形式之一：</p>
<ul>
<li>全局函数是一个有名字但不会捕获任何值的闭包</li>
<li>嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包</li>
<li>闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包</li>
</ul>
<p>Swift 的闭包表达式拥有简洁的风格，并鼓励在常见场景中进行语法优化，主要优化如下：</p>
<ul>
<li>利用上下文推断参数和返回值类型</li>
<li>隐式返回单表达式闭包，即单表达式闭包可以省略<code>return</code>关键字</li>
<li>参数名称缩写</li>
<li>尾随（Trailing）闭包语法</li>
</ul>
<p><a name="closure_expressions"></a></p>
<h2 id="闭包表达式（Closure_Expressions）">闭包表达式（Closure Expressions）</h2><p><a href="./06_Functions.html#nested_function">嵌套函数</a>是一个在较复杂函数中方便进行命名和定义自包含代码模块的方式。当然，有时候撰写小巧的没有完整定义和命名的类函数结构也是很有用处的，尤其是在您处理一些函数并需要将另外一些函数作为该函数的参数时。</p>
<p>闭包表达式是一种利用简洁语法构建内联闭包的方式。闭包表达式提供了一些语法优化，使得撰写闭包变得简单明了。下面闭包表达式的例子通过使用几次迭代展示了<code>sort(_:)</code>方法定义和语法优化的方式。每一次迭代都用更简洁的方式描述了相同的功能。</p>
<p><a name="the_sorted_function"></a></p>
<h3 id="sort_方法（The_Sort_Method）">sort 方法（The Sort Method）</h3><p>Swift 标准库提供了名为<code>sort</code>的方法，会根据您提供的用于排序的闭包函数将已知类型数组中的值进行排序。一旦排序完成，<code>sort(_:)</code>方法会返回一个与原数组大小相同,包含同类型元素且元素已正确排序的新数组。原数组不会被<code>sort(_:)</code>方法修改。</p>
<p>下面的闭包表达式示例使用<code>sort(_:)</code>方法对一个<code>String</code>类型的数组进行字母逆序排序.以下是初始数组值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [<span class="string">"Chris"</span>, <span class="string">"Alex"</span>, <span class="string">"Ewa"</span>, <span class="string">"Barry"</span>, <span class="string">"Daniella"</span>]</span><br></pre></td></tr></table></figure>
<p><code>sort(_:)</code>方法接受一个闭包，该闭包函数需要传入与数组元素类型相同的两个值，并返回一个布尔类型值来表明当排序结束后传入的第一个参数排在第二个参数前面还是后面。如果第一个参数值出现在第二个参数值前面，排序闭包函数需要返回<code>true</code>，反之返回<code>false</code>。</p>
<p>该例子对一个<code>String</code>类型的数组进行排序，因此排序闭包函数类型需为<code>(String, String) -&gt; Bool</code>。</p>
<p>提供排序闭包函数的一种方式是撰写一个符合其类型要求的普通函数，并将其作为<code>sort(_:)</code>方法的参数传入：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">backwards</span><span class="params">(s1: String, s2: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s1 &gt; s2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> reversed = names.<span class="built_in">sort</span>(backwards)</span><br><span class="line"><span class="comment">// reversed 为 ["Ewa", "Daniella", "Chris", "Barry", "Alex"]</span></span><br></pre></td></tr></table></figure>
<p>如果第一个字符串（<code>s1</code>）大于第二个字符串（<code>s2</code>），<code>backwards(_:_:)</code>函数返回<code>true</code>，表示在新的数组中<code>s1</code>应该出现在<code>s2</code>前。对于字符串中的字符来说，“大于”表示“按照字母顺序较晚出现”。这意味着字母<code>&quot;B&quot;</code>大于字母<code>&quot;A&quot;</code>，字符串<code>&quot;Tom&quot;</code>大于字符串<code>&quot;Tim&quot;</code>。该闭包将进行字母逆序排序，<code>&quot;Barry&quot;</code>将会排在<code>&quot;Alex&quot;</code>之前。</p>
<p>然而，这是一个相当冗长的方式，本质上只是写了一个单表达式函数 (<code>a &gt; b</code>)。在下面的例子中，利用闭合表达式语法可以更好地构造一个内联排序闭包。</p>
<p><a name="closure_expression_syntax"></a></p>
<h3 id="闭包表达式语法（Closure_Expression_Syntax）">闭包表达式语法（Closure Expression Syntax）</h3><p>闭包表达式语法有如下一般形式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; (parameters) -&gt; returnType <span class="keyword">in</span></span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>闭包表达式语法可以使用常量、变量和<code>inout</code>类型作为参数，不能提供默认值。也可以在参数列表的最后使用可变参数。元组也可以作为参数和返回值。</p>
<p>下面的例子展示了之前<code>backwards(_:_:)</code>函数对应的闭包表达式版本的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reversed = names.<span class="built_in">sort</span>(&#123; (s1: <span class="type">String</span>, s2: <span class="type">String</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> s1 &gt; s2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>需要注意的是内联闭包参数和返回值类型声明与<code>backwards(_:_:)</code>函数类型声明相同。在这两种方式中，都写成了<code>(s1: String, s2: String) -&gt; Bool</code>。然而在内联闭包表达式中，函数和返回值类型都写在大括号内，而不是大括号外。</p>
<p>闭包的函数体部分由关键字<code>in</code>引入。该关键字表示闭包的参数和返回值类型定义已经完成，闭包函数体即将开始。</p>
<p>由于这个闭包的函数体部分如此短，以至于可以将其改写成一行代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversed = names.<span class="built_in">sort</span>( &#123; (s1: <span class="type">String</span>, s2: <span class="type">String</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span> <span class="keyword">return</span> s1 &gt; s2 &#125; )</span><br></pre></td></tr></table></figure>
<p>该例中<code>sort(_:)</code>方法的整体调用保持不变，一对圆括号仍然包裹住了方法的整个参数。然而，参数现在变成了内联闭包。</p>
<p><a name="inferring_type_from_context"></a></p>
<h3 id="根据上下文推断类型（Inferring_Type_From_Context）">根据上下文推断类型（Inferring Type From Context）</h3><p>因为排序闭包函数是作为<code>sort(_:)</code>方法的参数传入的，Swift 可以推断其参数和返回值的类型。<code>sort(_:)</code>方法被一个字符串数组调用，因此其参数必须是<code>(String, String) -&gt; Bool</code>类型的函数。这意味着<code>(String, String)</code>和<code>Bool</code>类型并不需要作为闭包表达式定义的一部分。因为所有的类型都可以被正确推断，返回箭头（<code>-&gt;</code>）和围绕在参数周围的括号也可以被省略：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversed = names.<span class="built_in">sort</span>( &#123; s1, s2 <span class="keyword">in</span> <span class="keyword">return</span> s1 &gt; s2 &#125; )</span><br></pre></td></tr></table></figure>
<p>实际上任何情况下，通过内联闭包表达式构造的闭包作为参数传递给函数或方法时，都可以推断出闭包的参数和返回值类型。<br>这意味着闭包作为函数或者方法的参数时，您几乎不需要利用完整格式构造内联闭包。</p>
<p>尽管如此，您仍然可以明确写出有着完整格式的闭包。如果完整格式的闭包能够提高代码的可读性，则可以采用完整格式的闭包。而在<code>sort(_:)</code>方法这个例子里，闭包的目的就是排序。由于这个闭包是为了处理字符串数组的排序，因此读者能够推测出这个闭包是用于字符串处理的。</p>
<p><a name="implicit_returns_from_single_expression_closures"></a></p>
<h3 id="单表达式闭包隐式返回（Implicit_Return_From_Single-Expression_Clossures）">单表达式闭包隐式返回（Implicit Return From Single-Expression Clossures）</h3><p>单行表达式闭包可以通过省略<code>return</code>关键字来隐式返回单行表达式的结果，如上版本的例子可以改写为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversed = names.<span class="built_in">sort</span>( &#123; s1, s2 <span class="keyword">in</span> s1 &gt; s2 &#125; )</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>sort(_:)</code>方法的第二个参数函数类型明确了闭包必须返回一个<code>Bool</code>类型值。因为闭包函数体只包含了一个单一表达式（<code>s1 &gt; s2</code>），该表达式返回<code>Bool</code>类型值，因此这里没有歧义，<code>return</code>关键字可以省略。</p>
<p><a name="shorthand_argument_names"></a></p>
<h3 id="参数名称缩写（Shorthand_Argument_Names）">参数名称缩写（Shorthand Argument Names）</h3><p>Swift 自动为内联闭包提供了参数名称缩写功能，您可以直接通过<code>$0</code>，<code>$1</code>，<code>$2</code>来顺序调用闭包的参数，以此类推。</p>
<p>如果您在闭包表达式中使用参数名称缩写，您可以在闭包参数列表中省略对其的定义，并且对应参数名称缩写的类型会通过函数类型进行推断。<code>in</code>关键字也同样可以被省略，因为此时闭包表达式完全由闭包函数体构成：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversed = names.<span class="built_in">sort</span>( &#123; $<span class="number">0</span> &gt; $<span class="number">1</span> &#125; )</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>$0</code>和<code>$1</code>表示闭包中第一个和第二个<code>String</code>类型的参数。</p>
<p><a name="operator_functions"></a></p>
<h3 id="运算符函数（Operator_Functions）">运算符函数（Operator Functions）</h3><p>实际上还有一种更简短的方式来撰写上面例子中的闭包表达式。Swift 的<code>String</code>类型定义了关于大于号（<code>&gt;</code>）的字符串实现，其作为一个函数接受两个<code>String</code>类型的参数并返回<code>Bool</code>类型的值。而这正好与<code>sort(_:)</code>方法的第二个参数需要的函数类型相符合。因此，您可以简单地传递一个大于号，Swift 可以自动推断出您想使用大于号的字符串函数实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversed = names.<span class="built_in">sort</span>(&gt;)</span><br></pre></td></tr></table></figure>
<p>更多关于运算符表达式的内容请查看<a href="./25_Advanced_Operators.html#operator_functions">运算符函数</a>。</p>
<p><a name="trailing_closures"></a></p>
<h2 id="尾随闭包（Trailing_Closures）">尾随闭包（Trailing Closures）</h2><p>如果您需要将一个很长的闭包表达式作为最后一个参数传递给函数，可以使用<em>尾随闭包</em>来增强函数的可读性。尾随闭包是一个书写在函数括号之后的闭包表达式，函数支持将其作为最后一个参数调用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">someFunctionThatTakesAClosure</span><span class="params">(closure: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="comment">// 函数体部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是不使用尾随闭包进行函数调用</span></span><br><span class="line">someFunctionThatTakesAClosure(&#123;</span><br><span class="line">    <span class="comment">// 闭包主体部分</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是使用尾随闭包进行函数调用</span></span><br><span class="line">someFunctionThatTakesAClosure() &#123;</span><br><span class="line">    <span class="comment">// 闭包主体部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<a href="#closure_expression_syntax">闭包表达式语法</a>一节中作为<code>sort(_:)</code>方法参数的字符串排序闭包可以改写为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversed = names.<span class="built_in">sort</span>() &#123; $<span class="number">0</span> &gt; $<span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>
<p>如果函数只需要闭包表达式一个参数，当您使用尾随闭包时，您甚至可以把<code>()</code>省略掉：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversed = names.<span class="built_in">sort</span> &#123; $<span class="number">0</span> &gt; $<span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>
<p>当闭包非常长以至于不能在一行中进行书写时，尾随闭包变得非常有用。举例来说，Swift 的<code>Array</code>类型有一个<code>map(_:)</code>方法，其获取一个闭包表达式作为其唯一参数。该闭包函数会为数组中的每一个元素调用一次，并返回该元素所映射的值。具体的映射方式和返回值类型由闭包来指定。</p>
<p>当提供给数组的闭包应用于每个数组元素后，<code>map(_:)</code>方法将返回一个新的数组，数组中包含了与原数组中的元素一一对应的映射后的值。</p>
<p>下例介绍了如何在<code>map(_:)</code>方法中使用尾随闭包将<code>Int</code>类型数组<code>[16, 58, 510]</code>转换为包含对应<code>String</code>类型的值的数组<code>[&quot;OneSix&quot;, &quot;FiveEight&quot;, &quot;FiveOneZero&quot;]</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> digitNames = [</span><br><span class="line">    <span class="number">0</span>: <span class="string">"Zero"</span>, <span class="number">1</span>: <span class="string">"One"</span>, <span class="number">2</span>: <span class="string">"Two"</span>,   <span class="number">3</span>: <span class="string">"Three"</span>, <span class="number">4</span>: <span class="string">"Four"</span>,</span><br><span class="line">    <span class="number">5</span>: <span class="string">"Five"</span>, <span class="number">6</span>: <span class="string">"Six"</span>, <span class="number">7</span>: <span class="string">"Seven"</span>, <span class="number">8</span>: <span class="string">"Eight"</span>, <span class="number">9</span>: <span class="string">"Nine"</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">16</span>, <span class="number">58</span>, <span class="number">510</span>]</span><br></pre></td></tr></table></figure>
<p>如上代码创建了一个数字位和它们英文版本名字相映射的字典。同时还定义了一个准备转换为字符串数组的整型数组。</p>
<p>您现在可以通过传递一个尾随闭包给<code>numbers</code>的<code>map(_:)</code>方法来创建对应的字符串版本数组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> strings = numbers.<span class="built_in">map</span> &#123;</span><br><span class="line">    (<span class="keyword">var</span> number) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">var</span> output = <span class="string">""</span></span><br><span class="line">    <span class="keyword">while</span> number &gt; <span class="number">0</span> &#123;</span><br><span class="line">        output = digitNames[number % <span class="number">10</span>]! + output</span><br><span class="line">        number /= <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// strings 常量被推断为字符串类型数组，即 [String]</span></span><br><span class="line"><span class="comment">// 其值为 ["OneSix", "FiveEight", "FiveOneZero"]</span></span><br></pre></td></tr></table></figure>
<p><code>map(_:)</code>为数组中每一个元素调用了闭包表达式。您不需要指定闭包的输入参数<code>number</code>的类型，因为可以通过要映射的数组类型进行推断。</p>
<p>在该例中，闭包<code>number</code>参数被声明为一个变量参数（变量的具体描述请参看<a href="./06_Functions.html#constant_and_variable_parameters">常量参数和变量参数</a>），因此可以在闭包函数体内对其进行修改，而不用再定义一个新的局部变量并将<code>number</code>的值赋值给它。闭包表达式指定了返回类型为<code>String</code>，以表明存储映射值的新数组类型为<code>String</code>。</p>
<p>闭包表达式在每次被调用的时候创建了一个叫做<code>output</code>的字符串并返回。其使用求余运算符（<code>number % 10</code>）计算最后一位数字并利用<code>digitNames</code>字典获取所映射的字符串。</p>
<blockquote>
<p>注意<br>字典<code>digitNames</code>下标后跟着一个叹号（<code>!</code>），因为字典下标返回一个可选值（optional value），表明该键不存在时会查找失败。在上例中，由于可以确定<code>number % 10</code>总是<code>digitNames</code>字典的有效下标，因此叹号可以用于强制解包 (force-unwrap) 存储在下标的可选类型的返回值中的<code>String</code>类型的值。</p>
</blockquote>
<p>从<code>digitNames</code>字典中获取的字符串被添加到<code>output</code>的前部，逆序建立了一个字符串版本的数字。（在表达式<code>number % 10</code>中，如果<code>number</code>为<code>16</code>，则返回<code>6</code>，<code>58</code>返回<code>8</code>，<code>510</code>返回<code>0</code>。）</p>
<p><code>number</code>变量之后除以<code>10</code>。因为其是整数，在计算过程中未除尽部分被忽略。因此<code>16</code>变成了<code>1</code>，<code>58</code>变成了<code>5</code>，<code>510</code>变成了<code>51</code>。</p>
<p>整个过程重复进行，直到<code>number /= 10</code>为<code>0</code>，这时闭包会将字符串<code>output</code>返回，而<code>map(_:)</code>方法则会将字符串添加到所映射的数组中。</p>
<p>在上面的例子中，通过尾随闭包语法，优雅地在函数后封装了闭包的具体功能，而不再需要将整个闭包包裹在<code>map(_:)</code>方法的括号内。</p>
<p><a name="capturing_values"></a></p>
<h2 id="捕获值（Capturing_Values）">捕获值（Capturing Values）</h2><p>闭包可以在其被定义的上下文中<em>捕获</em>常量或变量。即使定义这些常量和变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。</p>
<p>Swift 中，可以捕获值的闭包的最简单形式是嵌套函数，也就是定义在其他函数的函数体内的函数。嵌套函数可以捕获其外部函数所有的参数以及定义的常量和变量。</p>
<p>举个例子，这有一个叫做<code>makeIncrementor</code>的函数，其包含了一个叫做<code>incrementor</code>的嵌套函数。嵌套函数<code>incrementor()</code>从上下文中捕获了两个值，<code>runningTotal</code>和<code>amount</code>。捕获这些值之后，<code>makeIncrementor</code>将<code>incrementor</code>作为闭包返回。每次调用<code>incrementor</code>时，其会以<code>amount</code>作为增量增加<code>runningTotal</code>的值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">makeIncrementor</span><span class="params">(forIncrement amount: Int)</span></span> -&gt; () -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> runningTotal = <span class="number">0</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">incrementor</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        runningTotal += amount</span><br><span class="line">        <span class="keyword">return</span> runningTotal</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> incrementor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>makeIncrementor</code>返回类型为<code>() -&gt; Int</code>。这意味着其返回的是一个函数，而不是一个简单类型的值。该函数在每次调用时不接受参数，只返回一个<code>Int</code>类型的值。关于函数返回其他函数的内容，请查看<a href="./06_Functions.html#function_types_as_return_types">函数类型作为返回类型</a>。</p>
<p><code>makeIncrementer(forIncrement:)</code>函数定义了一个初始值为<code>0</code>的整型变量<code>runningTotal</code>，用来存储当前跑步总数。该值通过<code>incrementor</code>返回。</p>
<p><code>makeIncrementer(forIncrement:)</code>有一个<code>Int</code>类型的参数，其外部参数名为<code>forIncrement</code>，内部参数名为<code>amount</code>，该参数表示每次<code>incrementor</code>被调用时<code>runningTotal</code>将要增加的量。</p>
<p>嵌套函数<code>incrementor</code>用来执行实际的增加操作。该函数简单地使<code>runningTotal</code>增加<code>amount</code>，并将其返回。</p>
<p>如果我们单独看这个函数，会发现看上去不同寻常：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">incrementor</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    runningTotal += amount</span><br><span class="line">    <span class="keyword">return</span> runningTotal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>incrementer()</code>函数并没有任何参数，但是在函数体内访问了<code>runningTotal</code>和<code>amount</code>变量。这是因为它从外围函数捕获了<code>runningTotal</code>和<code>amount</code>变量的引用。捕获引用保证了<code>runningTotal</code>和<code>amount</code>变量在调用完<code>makeIncrementer</code>后不会消失，并且保证了在下一次执行<code>incrementer</code>函数时，<code>runningTotal</code>依旧存在。</p>
<blockquote>
<p>注意<br>为了优化，如果一个值是不可变的，Swift 可能会改为捕获并保存一份对值的拷贝。<br>Swift 也会负责被捕获变量的所有内存管理工作，包括释放不再需要的变量。</p>
</blockquote>
<p>下面是一个使用<code>makeIncrementor</code>的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> incrementByTen = makeIncrementor(forIncrement: <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>该例子定义了一个叫做<code>incrementByTen</code>的常量，该常量指向一个每次调用会将<code>runningTotal</code>变量增加<code>10</code>的<code>incrementor</code>函数。调用这个函数多次可以得到以下结果：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">incrementByTen()</span><br><span class="line"><span class="comment">// 返回的值为10</span></span><br><span class="line">incrementByTen()</span><br><span class="line"><span class="comment">// 返回的值为20</span></span><br><span class="line">incrementByTen()</span><br><span class="line"><span class="comment">// 返回的值为30</span></span><br></pre></td></tr></table></figure>
<p>如果您创建了另一个<code>incrementor</code>，它会有属于它自己的一个全新、独立的<code>runningTotal</code>变量的引用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> incrementBySeven = makeIncrementor(forIncrement: <span class="number">7</span>)</span><br><span class="line">incrementBySeven()</span><br><span class="line"><span class="comment">// 返回的值为7</span></span><br></pre></td></tr></table></figure>
<p>再次调用原来的<code>incrementByTen</code>会在原来的变量<code>runningTotal</code>上继续增加值，该变量和<code>incrementBySeven</code>中捕获的变量没有任何联系：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">incrementByTen()</span><br><span class="line"><span class="comment">// 返回的值为40</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>如果您将闭包赋值给一个类实例的属性，并且该闭包通过访问该实例或其成员而捕获了该实例，您将创建一个在闭包和该实例间的循环强引用。Swift 使用捕获列表来打破这种循环强引用。更多信息，请参考<a href="./16_Automatic_Reference_Counting.html#strong_reference_cycles_for_closures">闭包引起的循环强引用</a>。</p>
</blockquote>
<p><a name="closures_are_reference_types"></a></p>
<h2 id="闭包是引用类型（Closures_Are_Reference_Types）">闭包是引用类型（Closures Are Reference Types）</h2><p>上面的例子中，<code>incrementBySeven</code>和<code>incrementByTen</code>是常量，但是这些常量指向的闭包仍然可以增加其捕获的变量的值。这是因为函数和闭包都是<em>引用类型</em>。</p>
<p>无论您将函数或闭包赋值给一个常量还是变量，您实际上都是将常量或变量的值设置为对应函数或闭包的引用。上面的例子中，指向闭包的引用<code>incrementByTen</code>是一个常量，而并非闭包内容本身。</p>
<p>这也意味着如果您将闭包赋值给了两个不同的常量或变量，两个值都会指向同一个闭包：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> alsoIncrementByTen = incrementByTen</span><br><span class="line">alsoIncrementByTen()</span><br><span class="line"><span class="comment">// 返回的值为50</span></span><br></pre></td></tr></table></figure>
<p><a name="nonescaping_closures"></a></p>
<h2 id="非逃逸闭包(Nonescaping_Closures)">非逃逸闭包(Nonescaping Closures)</h2><p>当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行，我们称该闭包从函数中<em>逃逸</em>。当你定义接受闭包作为参数的函数时，你可以在参数名之前标注<code>@noescape</code>，用来指明这个闭包是不允许“逃逸”出这个函数的。将闭包标注<code>@noescape</code>能使编译器知道这个闭包的生命周期（译者注：闭包只能在函数体中被执行，不能脱离函数体执行，所以编译器明确知道运行时的上下文），从而可以进行一些比较激进的优化。   </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">someFunctionWithNoescapeClosure</span><span class="params">(@noescape closure: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    closure()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举个例子，<code>sort(_:)</code>方法接受一个用来进行元素比较的闭包作为参数。这个参数被标注了<code>@noescape</code>，因为它确保自己在排序结束之后就没用了。</p>
<p>一种能使闭包“逃逸”出函数的方法是，将这个闭包保存在一个函数外部定义的变量中。举个例子，很多启动异步操作的函数接受一个闭包参数作为 completion handler。这类函数会在异步操作开始之后立刻返回，但是闭包直到异步操作结束后才会被调用。在这种情况下，闭包需要“逃逸”出函数，因为闭包需要在函数返回之后被调用。例如： </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> completionHandlers: [() -&gt; <span class="type">Void</span>] = []</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">someFunctionWithEscapingClosure</span><span class="params">(completionHandler: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    completionHandlers.append(completionHandler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>someFunctionWithEscapingClosure(_:)</code>函数接受一个闭包作为参数，该闭包被添加到一个函数外定义的数组中。如果你试图将这个参数标注为<code>@noescape</code>，你将会获得一个编译错误。</p>
<p>将闭包标注为<code>@noescape</code>使你能在闭包中隐式地引用<code>self</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">        someFunctionWithEscapingClosure &#123; <span class="keyword">self</span>.x = <span class="number">100</span> &#125;</span><br><span class="line">        someFunctionWithNoescapeClosure &#123; x = <span class="number">200</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> instance = <span class="type">SomeClass</span>()</span><br><span class="line">instance.doSomething()</span><br><span class="line"><span class="built_in">print</span>(instance.x)</span><br><span class="line"><span class="comment">// prints "200"</span></span><br><span class="line"> </span><br><span class="line">completionHandlers.first?()</span><br><span class="line"><span class="built_in">print</span>(instance.x)</span><br><span class="line"><span class="comment">// prints "100"</span></span><br></pre></td></tr></table></figure>
<p><a name="autoclosures"></a></p>
<h2 id="自动闭包（Autoclosures）">自动闭包（Autoclosures）</h2><p><em>自动闭包</em>是一种自动创建的闭包，用于包装传递给函数作为参数的表达式。这种闭包不接受任何参数，当它被调用的时候，会返回被包装在其中的表达式的值。这种便利语法让你能够用一个普通的表达式来代替显式的闭包，从而省略闭包的花括号。</p>
<p>我们经常会调用一个接受闭包作为参数的函数，但是很少实现那样的函数。举个例子来说，<code>assert(condition:message:file:line:)</code>函数接受闭包作为它的<code>condition</code>参数和<code>message</code>参数；它的<code>condition</code>参数仅会在 debug 模式下被求值，它的<code>message</code>参数仅当<code>condition</code>参数为<code>false</code>时被计算求值。</p>
<p>自动闭包让你能够延迟求值，因为代码段不会被执行直到你调用这个闭包。延迟求值对于那些有副作用（Side Effect）和代价昂贵的代码来说是很有益处的，因为你能控制代码什么时候执行。下面的代码展示了闭包如何延时求值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> customersInLine = [<span class="string">"Chris"</span>, <span class="string">"Alex"</span>, <span class="string">"Ewa"</span>, <span class="string">"Barry"</span>, <span class="string">"Daniella"</span>]</span><br><span class="line"><span class="built_in">print</span>(customersInLine.<span class="built_in">count</span>)</span><br><span class="line"><span class="comment">// prints "5"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> customerProvider = &#123; customersInLine.removeAtIndex(<span class="number">0</span>) &#125;</span><br><span class="line"><span class="built_in">print</span>(customersInLine.<span class="built_in">count</span>)</span><br><span class="line"><span class="comment">// prints "5"</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Now serving <span class="subst">\(customerProvider()</span>)!"</span>)</span><br><span class="line"><span class="comment">// prints "Now serving Chris!"</span></span><br><span class="line"><span class="built_in">print</span>(customersInLine.<span class="built_in">count</span>)</span><br><span class="line"><span class="comment">// prints "4"</span></span><br></pre></td></tr></table></figure>
<p>尽管在闭包的代码中，<code>customersInLine</code>的第一个元素被移除了，不过在闭包被调用之前，这个元素是不会被移除的。如果这个闭包永远不被调用，那么在闭包里面的表达式将永远不会执行，那意味着列表中的元素永远不会被移除。请注意，<code>customerProvider</code>的类型不是<code>String</code>，而是<code>() -&gt; String</code>，一个没有参数且返回值为<code>String</code>的函数。</p>
<p>将闭包作为参数传递给函数时，你能获得同样的延时求值行为。    </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// customersInLine is ["Alex", "Ewa", "Barry", "Daniella"]</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">serveCustomer</span><span class="params">(customerProvider: <span class="params">()</span></span></span> -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Now serving <span class="subst">\(customerProvider()</span>)!"</span>)</span><br><span class="line">&#125;</span><br><span class="line">serveCustomer( &#123; customersInLine.removeAtIndex(<span class="number">0</span>) &#125; )</span><br><span class="line"><span class="comment">// prints "Now serving Alex!"</span></span><br></pre></td></tr></table></figure>
<p><code>serveCustomer(_:)</code>接受一个返回顾客名字的显式的闭包。下面这个版本的<code>serveCustomer(_:)</code>完成了相同的操作，不过它并没有接受一个显式的闭包，而是通过将参数标记为<code>@autoclosure</code>来接收一个自动闭包。现在你可以将该函数当做接受<code>String</code>类型参数的函数来调用。<code>customerProvider</code>参数将自动转化为一个闭包，因为该参数被标记了<code>@autoclosure</code>特性。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// customersInLine is ["Ewa", "Barry", "Daniella"]</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">serveCustomer</span><span class="params">(@autoclosure customerProvider: <span class="params">()</span></span></span> -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Now serving <span class="subst">\(customerProvider()</span>)!"</span>)</span><br><span class="line">&#125;</span><br><span class="line">serveCustomer(customersInLine.removeAtIndex(<span class="number">0</span>))</span><br><span class="line"><span class="comment">// prints "Now serving Ewa!"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>过度使用<code>autoclosures</code>会让你的代码变得难以理解。上下文和函数名应该能够清晰地表明求值是被延迟执行的。</p>
</blockquote>
<p><code>@autoclosure</code>特性暗含了<code>@noescape</code>特性，这个特性在<a href="#nonescaping_closures">非逃逸闭包</a>一节中有描述。如果你想让这个闭包可以“逃逸”，则应该使用<code>@autoclosure(escaping)</code>特性.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// customersInLine is ["Barry", "Daniella"]</span></span><br><span class="line"><span class="keyword">var</span> customerProviders: [() -&gt; <span class="type">String</span>] = []</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">collectCustomerProviders</span><span class="params">(@autoclosure<span class="params">(escaping)</span></span></span> customerProvider: () -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    customerProviders.append(customerProvider)</span><br><span class="line">&#125;</span><br><span class="line">collectCustomerProviders(customersInLine.removeAtIndex(<span class="number">0</span>))</span><br><span class="line">collectCustomerProviders(customersInLine.removeAtIndex(<span class="number">0</span>))</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Collected <span class="subst">\(customerProviders.<span class="built_in">count</span>)</span> closures."</span>)</span><br><span class="line"><span class="comment">// prints "Collected 2 closures."</span></span><br><span class="line"><span class="keyword">for</span> customerProvider <span class="keyword">in</span> customerProviders &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Now serving <span class="subst">\(customerProvider()</span>)!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// prints "Now serving Barry!"</span></span><br><span class="line"><span class="comment">// prints "Now serving Daniella!"</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，<code>collectCustomerProviders(_:)</code>函数并没有调用传入的<code>customerProvider</code>闭包，而是将闭包追加到了<code>customerProviders</code>数组中。这个数组定义在函数作用域范围外，这意味着数组内的闭包将会在函数返回之后被调用。因此，<code>customerProvider</code>参数必须允许“逃逸”出函数作用域。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="闭包（Closures）">闭包（Closures）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/wh1100717" target="_blank" rel="external">]]>
    </summary>
    
      <category term="swift-cn" scheme="http://yoursite.com/tags/swift-cn/"/>
    
      <category term="swift-cn" scheme="http://yoursite.com/categories/swift-cn/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第二章-08枚举（Enumerations）]]></title>
    <link href="http://yoursite.com/2015/12/25/swift-cn/chapter2/08_Enumerations/"/>
    <id>http://yoursite.com/2015/12/25/swift-cn/chapter2/08_Enumerations/</id>
    <published>2015-12-25T04:00:19.000Z</published>
    <updated>2015-12-15T05:44:27.040Z</updated>
    <content type="html"><![CDATA[<h1 id="枚举（Enumerations）">枚举（Enumerations）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/yankuangshi" target="_blank" rel="external">yankuangshi</a><br>校对：<a href="https://github.com/shinyzhu" target="_blank" rel="external">shinyzhu</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/futantan" target="_blank" rel="external">futantan</a></p>
<p>2.1<br>翻译：<a href="https://github.com/Channe" target="_blank" rel="external">Channe</a><br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a></p>
</blockquote>
<p>本页内容包含：</p>
<ul>
<li><a href="#enumeration_syntax">枚举语法（Enumeration Syntax）</a></li>
<li><a href="#matching_enumeration_values_with_a_switch_statement">使用 Switch 语句匹配枚举值（Matching Enumeration Values with a Switch Statement）</a></li>
<li><a href="#associated_values">关联值（Associated Values）</a></li>
<li><a href="#raw_values">原始值（Raw Values）</a></li>
<li><a href="#recursive_enumerations">递归枚举（Recursive Enumerations）</a></li>
</ul>
<p><em>枚举</em>为一组相关的值定义了一个共同的类型，使你可以在你的代码中以类型安全的方式来使用这些值。</p>
<p>如果你熟悉 C 语言，你会知道在 C 语言中，枚举会为一组整型值分配相关联的名称。Swift 中的枚举更加灵活，不必给每一个枚举成员提供一个值。如果给枚举成员提供一个值（称为“原始”值），则该值的类型可以是字符串，字符，或是一个整型值或浮点数。</p>
<p>此外，枚举成员可以指定任意类型的关联值存储到枚举成员中，就像其他语言中的联合体（unions）和变体（variants）。每一个枚举成员都可以有适当类型的关联值。</p>
<p>在 Swift 中，枚举类型是一等（first-class）类型。它们采用了很多在传统上只被类（class）所支持的特性，例如计算型属性（computed properties），用于提供枚举值的附加信息，实例方法（instance methods），用于提供和枚举值相关联的功能。枚举也可以定义构造函数（initializers）来提供一个初始值；可以在原始实现的基础上扩展它们的功能；还可以遵守协议（protocols）来提供标准的功能。</p>
<p>欲了解更多相关信息，请参见<a href="./10_Properties.html">属性（Properties）</a>，<a href="./11_Methods.html">方法（Methods）</a>，<a href="./14_Initialization.html">构造过程（Initialization）</a>，<a href="./21_Extensions.html">扩展（Extensions）</a>和<a href="./22_Protocols.html">协议（Protocols）</a>。</p>
<p><a name="enumeration_syntax"></a></p>
<h2 id="枚举语法">枚举语法</h2><p>使用<code>enum</code>关键词来创建枚举并且把它们的整个定义放在一对大括号内：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SomeEnumeration</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 枚举定义放在这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是用枚举表示指南针四个方向的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CompassPoint</span> </span>&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">North</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">South</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">East</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">West</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举中定义的值（如 <code>North</code>，<code>South</code>，<code>East</code>和<code>West</code>）是这个枚举的<em>成员值</em>（或<em>成员</em>）。你使用<code>case</code>关键字来定义一个新的枚举成员值。</p>
<blockquote>
<p>注意<br>与 C 和 Objective-C 不同，Swift 的枚举成员在被创建时不会被赋予一个默认的整型值。在上面的<code>CompassPoint</code>例子中，<code>North</code>，<code>South</code>，<code>East</code>和<code>West</code>不会被隐式地赋值为<code>0</code>，<code>1</code>，<code>2</code>和<code>3</code>。相反，这些枚举成员本身就是完备的值，这些值的类型是已经明确定义好的<code>CompassPoint</code>类型。</p>
</blockquote>
<p>多个成员值可以出现在同一行上，用逗号隔开：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Planet</span> </span>&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Mercury</span>, <span class="type">Venus</span>, <span class="type">Earth</span>, <span class="type">Mars</span>, <span class="type">Jupiter</span>, <span class="type">Saturn</span>, <span class="type">Uranus</span>, <span class="type">Neptune</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个枚举定义了一个全新的类型。像 Swift 中其他类型一样，它们的名字（例如<code>CompassPoint</code>和<code>Planet</code>）应该以一个大写字母开头。给枚举类型起一个单数名字而不是复数名字，以便于读起来更加容易理解：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> directionToHead = <span class="type">CompassPoint</span>.<span class="type">West</span></span><br></pre></td></tr></table></figure>
<p><code>directionToHead</code>的类型可以在它被<code>CompassPoint</code>的某个值初始化时推断出来。一旦<code>directionToHead</code>被声明为<code>CompassPoint</code>类型，你可以使用更简短的点语法将其设置为另一个<code>CompassPoint</code>的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">directionToHead = .<span class="type">East</span></span><br></pre></td></tr></table></figure>
<p>当<code>directionToHead</code>的类型已知时，再次为其赋值可以省略枚举类型名。在使用具有显式类型的枚举值时，这种写法让代码具有更好的可读性。</p>
<p><a name="matching_enumeration_values_with_a_switch_statement"></a></p>
<h2 id="使用_Switch_语句匹配枚举值">使用 Switch 语句匹配枚举值</h2><p>你可以使用<code>switch</code>语句匹配单个枚举值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">directionToHead = .<span class="type">South</span></span><br><span class="line"><span class="keyword">switch</span> directionToHead &#123;</span><br><span class="line">	<span class="keyword">case</span> .<span class="type">North</span>:</span><br><span class="line">	    <span class="built_in">print</span>(<span class="string">"Lots of planets have a north"</span>)</span><br><span class="line">	<span class="keyword">case</span> .<span class="type">South</span>:</span><br><span class="line">	    <span class="built_in">print</span>(<span class="string">"Watch out for penguins"</span>)</span><br><span class="line">	<span class="keyword">case</span> .<span class="type">East</span>:</span><br><span class="line">	    <span class="built_in">print</span>(<span class="string">"Where the sun rises"</span>)</span><br><span class="line">	<span class="keyword">case</span> .<span class="type">West</span>:</span><br><span class="line">	    <span class="built_in">print</span>(<span class="string">"Where the skies are blue"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "Watch out for penguins”</span></span><br></pre></td></tr></table></figure>
<p>你可以这样理解这段代码：</p>
<p>“判断<code>directionToHead</code>的值。当它等于<code>.North</code>，打印<code>“Lots of planets have a north”</code>。当它等于<code>.South</code>，打印<code>“Watch out for penguins”</code>。”</p>
<p>……以此类推。</p>
<p>正如在<a href="./05_Control_Flow.html">控制流（Control Flow）</a>中介绍的那样，在判断一个枚举类型的值时，<code>switch</code>语句必须穷举所有情况。如果忽略了<code>.West</code>这种情况，上面那段代码将无法通过编译，因为它没有考虑到<code>CompassPoint</code>的全部成员。强制穷举确保了枚举成员不会被意外遗漏。</p>
<p>当不需要匹配每个枚举成员的时候，你可以提供一个<code>default</code>分支来涵盖所有未明确处理的枚举成员：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> somePlanet = <span class="type">Planet</span>.<span class="type">Earth</span></span><br><span class="line"><span class="keyword">switch</span> somePlanet &#123;</span><br><span class="line"><span class="keyword">case</span> .<span class="type">Earth</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Mostly harmless"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Not a safe place for humans"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "Mostly harmless”</span></span><br></pre></td></tr></table></figure>
<p><a name="associated_values"></a></p>
<h2 id="关联值（Associated_Values）">关联值（Associated Values）</h2><p>上一小节的例子演示了如何定义和分类枚举的成员。你可以为<code>Planet.Earth</code>设置一个常量或者变量，并在赋值之后查看这个值。然而，有时候能够把其他类型的<em>关联值</em>和成员值一起存储起来会很有用。这能让你连同成员值一起存储额外的自定义信息，并且你每次在代码中使用该枚举成员时，还可以修改这个关联值。</p>
<p>你可以定义 Swift 枚举来存储任意类型的关联值，如果需要的话，每个枚举成员的关联值类型可以各不相同。枚举的这种特性跟其他语言中的可识别联合（discriminated unions），标签联合（tagged unions），或者变体（variants）相似。</p>
<p>例如，假设一个库存跟踪系统需要利用两种不同类型的条形码来跟踪商品。有些商品上标有使用<code>0</code>到<code>9</code>的数字的 UPC-A 格式的一维条形码。每一个条形码都有一个代表“数字系统”的数字，该数字后接五位代表“厂商代码”的数字，接下来是五位代表“产品代码”的数字。最后一个数字是“检查”位，用来验证代码是否被正确扫描：</p>
<p><img width="252" height="120" alt="" src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/barcode_UPC_2x.png"></p>
<p>其他商品上标有 QR 码格式的二维码，它可以使用任何 ISO 8859-1 字符，并且可以编码一个最多拥有 2,953 个字符的字符串：</p>
<p><img width="169" height="169" alt="" src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/barcode_QR_2x.png"></p>
<p>这便于库存跟踪系统用包含四个整型值的元组存储 UPC-A 码，以及用任意长度的字符串储存 QR 码。</p>
<p>在 Swift 中，使用如下方式定义表示两种商品条形码的枚举：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Barcode</span> </span>&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">UPCA</span>(<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="type">QRCode</span>(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码可以这么理解：</p>
<p>“定义一个名为<code>Barcode</code>的枚举类型，它的一个成员值是具有<code>(Int，Int，Int，Int)</code>类型关联值的<code>UPCA</code>，另一个成员值是具有<code>String</code>类型关联值的<code>QRCode</code>。”</p>
<p>这个定义不提供任何<code>Int</code>或<code>String</code>类型的关联值，它只是定义了，当<code>Barcode</code>常量和变量等于<code>Barcode.UPCA</code>或<code>Barcode.QRCode</code>时，可以存储的关联值的类型。</p>
<p>然后可以使用任意一种条形码类型创建新的条形码，例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> productBarcode = <span class="type">Barcode</span>.<span class="type">UPCA</span>(<span class="number">8</span>, <span class="number">85909</span>, <span class="number">51226</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>上面的例子创建了一个名为<code>productBarcode</code>的变量，并将<code>Barcode.UPCA</code>赋值给它，关联的元组值为<code>(8, 85909, 51226, 3)</code>。</p>
<p>同一个商品可以被分配一个不同类型的条形码，例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">productBarcode = .<span class="type">QRCode</span>(<span class="string">"ABCDEFGHIJKLMNOP"</span>)</span><br></pre></td></tr></table></figure>
<p>这时，原始的<code>Barcode.UPCA</code>和其整数关联值被新的<code>Barcode.QRCode</code>和其字符串关联值所替代。<code>Barcode</code>类型的常量和变量可以存储一个<code>.UPCA</code>或者一个<code>.QRCode</code>（连同它们的关联值），但是在同一时间只能存储这两个值中的一个。</p>
<p>像先前那样，可以使用一个 switch 语句来检查不同的条形码类型。然而，这一次，关联值可以被提取出来作为 switch 语句的一部分。你可以在<code>switch</code>的 case 分支代码中提取每个关联值作为一个常量（用<code>let</code>前缀）或者作为一个变量（用<code>var</code>前缀）来使用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> productBarcode &#123;</span><br><span class="line"><span class="keyword">case</span> .<span class="type">UPCA</span>(<span class="keyword">let</span> numberSystem, <span class="keyword">let</span> manufacturer, <span class="keyword">let</span> product, <span class="keyword">let</span> check):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"UPC-A: <span class="subst">\(numberSystem)</span>, <span class="subst">\(manufacturer)</span>, <span class="subst">\(product)</span>, <span class="subst">\(check)</span>."</span>)</span><br><span class="line"><span class="keyword">case</span> .<span class="type">QRCode</span>(<span class="keyword">let</span> productCode):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"QR code: <span class="subst">\(productCode)</span>."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "QR code: ABCDEFGHIJKLMNOP."</span></span><br></pre></td></tr></table></figure>
<p>如果一个枚举成员的所有关联值都被提取为常量，或者都被提取为变量，为了简洁，你可以只在成员名称前标注一个<code>let</code>或者<code>var</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> productBarcode &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">UPCA</span>(numberSystem, manufacturer, product, check):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"UPC-A: <span class="subst">\(numberSystem)</span>, <span class="subst">\(manufacturer)</span>, <span class="subst">\(product)</span>, <span class="subst">\(check)</span>."</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">QRCode</span>(productCode):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"QR code: <span class="subst">\(productCode)</span>."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "QR code: ABCDEFGHIJKLMNOP."</span></span><br></pre></td></tr></table></figure>
<p><a name="raw_values"></a></p>
<h2 id="原始值（Raw_Values）">原始值（Raw Values）</h2><p>在<a href="#associated_values">关联值</a>小节的条形码例子中，演示了如何声明存储不同类型关联值的枚举成员。作为关联值的替代选择，枚举成员可以被默认值（称为<em>原始值</em>）预填充，这些原始值的类型必须相同。</p>
<p>这是一个使用 ASCII 码作为原始值的枚举：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ASCIIControlCharacter</span>: <span class="title">Character</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Tab</span> = <span class="string">"\t"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">LineFeed</span> = <span class="string">"\n"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">CarriageReturn</span> = <span class="string">"\r"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举类型<code>ASCIIControlCharacter</code>的原始值类型被定义为<code>Character</code>，并设置了一些比较常见的 ASCII 控制字符。<code>Character</code>的描述详见<a href="./03_Strings_and_Characters.html">字符串和字符</a>部分。</p>
<p>原始值可以是字符串，字符，或者任意整型值或浮点型值。每个原始值在枚举声明中必须是唯一的。</p>
<blockquote>
<p>注意<br>原始值和关联值是不同的。原始值是在定义枚举时被预先填充的值，像上述三个 ASCII 码。对于一个特定的枚举成员，它的原始值始终不变。关联值是创建一个基于枚举成员的常量或变量时才设置的值，枚举成员的关联值可以变化。</p>
</blockquote>
<p><a name="implicitly_assigned_raw_values"></a></p>
<h3 id="原始值的隐式赋值（Implicitly_Assigned_Raw_Values）">原始值的隐式赋值（Implicitly Assigned Raw Values）</h3><p>在使用原始值为整数或者字符串类型的枚举时，不需要显式地为每一个枚举成员设置原始值，Swift 将会自动为你赋值。</p>
<p>例如，当使用整数作为原始值时，隐式赋值的值依次递增<code>1</code>。如果第一个枚举成员没有设置原始值，其原始值将为<code>0</code>。</p>
<p>下面的枚举是对之前<code>Planet</code>这个枚举的一个细化，利用整型的原始值来表示每个行星在太阳系中的顺序：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Planet</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Mercury</span> = <span class="number">1</span>, <span class="type">Venus</span>, <span class="type">Earth</span>, <span class="type">Mars</span>, <span class="type">Jupiter</span>, <span class="type">Saturn</span>, <span class="type">Uranus</span>, <span class="type">Neptune</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>Plant.Mercury</code>的显式原始值为<code>1</code>，<code>Planet.Venus</code>的隐式原始值为<code>2</code>，依次类推。</p>
<p>当使用字符串作为枚举类型的原始值时，每个枚举成员的隐式原始值为该枚举成员的名称。</p>
<p>下面的例子是<code>CompassPoint</code>枚举的细化，使用字符串类型的原始值来表示各个方向的名称：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CompassPoint</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">North</span>, <span class="type">South</span>, <span class="type">East</span>, <span class="type">West</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>CompassPoint.South</code>拥有隐式原始值<code>South</code>，依次类推。</p>
<p>使用枚举成员的<code>rawValue</code>属性可以访问该枚举成员的原始值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> earthsOrder = <span class="type">Planet</span>.<span class="type">Earth</span>.rawValue</span><br><span class="line"><span class="comment">// earthsOrder 值为 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sunsetDirection = <span class="type">CompassPoint</span>.<span class="type">West</span>.rawValue</span><br><span class="line"><span class="comment">// sunsetDirection 值为 "West"</span></span><br></pre></td></tr></table></figure>
<p><a name="initializing_from_a_raw_value"></a></p>
<h3 id="使用原始值初始化枚举实例（Initializing_from_a_Raw_Value）">使用原始值初始化枚举实例（Initializing from a Raw Value）</h3><p>如果在定义枚举类型的时候使用了原始值，那么将会自动获得一个初始化方法，这个方法接收一个叫做<code>rawValue</code>的参数，参数类型即为原始值类型，返回值则是枚举成员或<code>nil</code>。你可以使用这个初始化方法来创建一个新的枚举实例。</p>
<p>这个例子利用原始值<code>7</code>创建了枚举成员<code>Uranus</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> possiblePlanet = <span class="type">Planet</span>(rawValue: <span class="number">7</span>)</span><br><span class="line"><span class="comment">// possiblePlanet 类型为 Planet? 值为 Planet.Uranus</span></span><br></pre></td></tr></table></figure>
<p>然而，并非所有<code>Int</code>值都可以找到一个匹配的行星。因此，原始值构造器总是返回一个<em>可选</em>的枚举成员。在上面的例子中，<code>possiblePlanet</code>是<code>Planet?</code>类型，或者说“可选的<code>Planet</code>”。</p>
<blockquote>
<p>注意<br>原始值构造器是一个可失败构造器，因为并不是每一个原始值都有与之对应的枚举成员。更多信息请参见<a href="../chapter3/05_Declarations.html#failable_initializers">可失败构造器</a></p>
</blockquote>
<p>如果你试图寻找一个位置为<code>9</code>的行星，通过原始值构造器返回的可选<code>Planet</code>值将是<code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> positionToFind = <span class="number">9</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> somePlanet = <span class="type">Planet</span>(rawValue: positionToFind) &#123;</span><br><span class="line">    <span class="keyword">switch</span> somePlanet &#123;</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Earth</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Mostly harmless"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Not a safe place for humans"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"There isn't a planet at position <span class="subst">\(positionToFind)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "There isn't a planet at position 9</span></span><br></pre></td></tr></table></figure>
<p>这个例子使用了可选绑定（optional binding），试图通过原始值<code>9</code>来访问一个行星。<code>if let somePlanet = Planet(rawValue: 9)</code>语句创建了一个可选<code>Planet</code>，如果可选<code>Planet</code>的值存在，就会赋值给<code>somePlanet</code>。在这个例子中，无法检索到位置为<code>9</code>的行星，所以<code>else</code>分支被执行。</p>
<p><a name="recursive_enumerations"></a></p>
<h2 id="递归枚举（Recursive_Enumerations）">递归枚举（Recursive Enumerations）</h2><p>当各种可能的情况可以被穷举时，非常适合使用枚举进行数据建模，例如可以用枚举来表示用于简单整数运算的操作符。这些操作符让你可以将简单的算术表达式，例如整数<code>5</code>，结合为更为复杂的表达式，例如<code>5 + 4</code>。</p>
<p>算术表达式的一个重要特性是，表达式可以嵌套使用。例如，表达式<code>(5 + 4) * 2</code>，乘号右边是一个数字，左边则是另一个表达式。因为数据是嵌套的，因而用来存储数据的枚举类型也需要支持这种嵌套——这意味着枚举类型需要支持递归。</p>
<p><em>递归枚举（recursive enumeration）</em>是一种枚举类型，它有一个或多个枚举成员使用该枚举类型的实例作为关联值。使用递归枚举时，编译器会插入一个间接层。你可以在枚举成员前加上<code>indirect</code>来表示该成员可递归。</p>
<p>例如，下面的例子中，枚举类型存储了简单的算术表达式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ArithmeticExpression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Number</span>(<span class="type">Int</span>)</span><br><span class="line">    indirect <span class="keyword">case</span> <span class="type">Addition</span>(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">    indirect <span class="keyword">case</span> <span class="type">Multiplication</span>(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以在枚举类型开头加上<code>indirect</code>关键字来表明它的所有成员都是可递归的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">indirect <span class="class"><span class="keyword">enum</span> <span class="title">ArithmeticExpression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Number</span>(<span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Addition</span>(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Multiplication</span>(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面定义的枚举类型可以存储三种算术表达式：纯数字、两个表达式相加、两个表达式相乘。枚举成员<code>Addition</code>和<code>Multiplication</code>的关联值也是算术表达式——这些关联值使得嵌套表达式成为可能。</p>
<p>要操作具有递归性质的数据结构，使用递归函数是一种直截了当的方式。例如，下面是一个对算术表达式求值的函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">evaluate</span><span class="params">(expression: ArithmeticExpression)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> expression &#123;</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Number</span>(<span class="keyword">let</span> value):</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Addition</span>(<span class="keyword">let</span> <span class="keyword">left</span>, <span class="keyword">let</span> <span class="keyword">right</span>):</span><br><span class="line">        <span class="keyword">return</span> evaluate(<span class="keyword">left</span>) + evaluate(<span class="keyword">right</span>)</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Multiplication</span>(<span class="keyword">let</span> <span class="keyword">left</span>, <span class="keyword">let</span> <span class="keyword">right</span>):</span><br><span class="line">        <span class="keyword">return</span> evaluate(<span class="keyword">left</span>) * evaluate(<span class="keyword">right</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 计算 (5 + 4) * 2</span></span><br><span class="line"><span class="keyword">let</span> five = <span class="type">ArithmeticExpression</span>.<span class="type">Number</span>(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">let</span> four = <span class="type">ArithmeticExpression</span>.<span class="type">Number</span>(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">let</span> sum = <span class="type">ArithmeticExpression</span>.<span class="type">Addition</span>(five, four)</span><br><span class="line"><span class="keyword">let</span> product = <span class="type">ArithmeticExpression</span>.<span class="type">Multiplication</span>(sum, <span class="type">ArithmeticExpression</span>.<span class="type">Number</span>(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(evaluate(product))</span><br><span class="line"><span class="comment">// 输出 "18"</span></span><br></pre></td></tr></table></figure>
<p>该函数如果遇到纯数字，就直接返回该数字的值。如果遇到的是加法或乘法运算，则分别计算左边表达式和右边表达式的值，然后相加或相乘。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="枚举（Enumerations）">枚举（Enumerations）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/yankuangshi" target="_blank" rel="]]>
    </summary>
    
      <category term="swift-cn" scheme="http://yoursite.com/tags/swift-cn/"/>
    
      <category term="swift-cn" scheme="http://yoursite.com/categories/swift-cn/"/>
    
  </entry>
  
</feed>
