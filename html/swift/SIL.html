

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Swift Intermediate Language (SIL) &mdash; Swift Programming Language documentation 0.1.9 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Swift Programming Language documentation 0.1.9 documentation" href="index.html"/>
        <link rel="up" title="Contents" href="contents.html"/>
        <link rel="next" title="Type Checker Design and Implementation" href="TypeChecker.html"/>
        <link rel="prev" title="Stored and Computed Variables" href="StoredAndComputedVariables.html"/>
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>


  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Swift Programming Language documentation
          

          
          </a>

          
            
            
              <div class="version">
                0.1.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">swift docs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="ABI.html">The Swift ABI</a></li>
<li class="toctree-l1"><a class="reference internal" href="ARCOptimization.html">ARC Optimization for Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="AccessControl.html">Access Control</a></li>
<li class="toctree-l1"><a class="reference internal" href="AccessControlInStdlib.html">Scope and introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="AccessControlInStdlib.html#public"><cite>public</cite></a></li>
<li class="toctree-l1"><a class="reference internal" href="AccessControlInStdlib.html#internal"><cite>internal</cite></a></li>
<li class="toctree-l1"><a class="reference internal" href="AccessControlInStdlib.html#private"><cite>private</cite></a></li>
<li class="toctree-l1"><a class="reference internal" href="AccessControlInStdlib.html#leading-underscore-rule">Leading Underscore Rule</a></li>
<li class="toctree-l1"><a class="reference internal" href="Arrays.html">The Swift Array Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="CallingConvention.html">The Swift Calling Convention</a></li>
<li class="toctree-l1"><a class="reference internal" href="DebuggingTheCompiler.html">Debugging the Swift Compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="Dependency Analysis.html">Dependency Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="DriverInternals.html">Driver Design &amp; Internals</a></li>
<li class="toctree-l1"><a class="reference internal" href="DriverParseableOutput.html">Parseable Driver Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="ErrorHandling.html">Error Handling in Swift 2.0</a></li>
<li class="toctree-l1"><a class="reference internal" href="ErrorHandlingRationale.html">Error Handling Rationale and Proposal</a></li>
<li class="toctree-l1"><a class="reference internal" href="Failable Initializers.html">Failable initializers</a></li>
<li class="toctree-l1"><a class="reference internal" href="Generics.html">Generics in Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="GitWorkflows.html">Git Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="GitWorkflows.html#svn-git-workflows">SVN -&gt; GIT Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="HighLevelSILOptimizations.html">High-Level Optimizations in SIL</a></li>
<li class="toctree-l1"><a class="reference internal" href="Import.html">IMPORT SYNTAX</a></li>
<li class="toctree-l1"><a class="reference internal" href="Import.html#resolving-name-clashes">RESOLVING NAME CLASHES</a></li>
<li class="toctree-l1"><a class="reference internal" href="Import.html#future-extensions">FUTURE EXTENSIONS</a></li>
<li class="toctree-l1"><a class="reference internal" href="IndexInvalidation.html">Index Invalidation Rules in the Swift Standard Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#using-versioned-api">Using Versioned API</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#publishing-versioned-api">Publishing Versioned API</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#giving-up-flexibility">Giving Up Flexibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#optimization">Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#resilience-domains">Resilience Domains</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#protocol-conformances">Protocol Conformances</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#checking-binary-compatibility">Checking Binary Compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#summary">Summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#glossary">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="Literals.html">Literals</a></li>
<li class="toctree-l1"><a class="reference internal" href="LogicalObjects.html">Logical Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="Modules.html">High-Level Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="Modules.html#import"><code class="docutils literal"><span class="pre">import</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="Modules.html#interoperability-with-objective-c-via-clang">Interoperability with Objective-C via Clang</a></li>
<li class="toctree-l1"><a class="reference internal" href="Modules.html#glossary">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="MutationModel.html">Immutability and Read-Only Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="ObjectInitialization.html">Object Initialization</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html">Writing High-Performance Swift Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#enabling-optimizations">Enabling Optimizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#whole-module-optimizations">Whole Module Optimizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#reducing-dynamic-dispatch">Reducing Dynamic Dispatch</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#using-container-types-efficiently">Using Container Types Efficiently</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#unchecked-operations">Unchecked operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#generics">Generics</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#the-cost-of-large-swift-values">The cost of large swift values</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#unsafe-code">Unsafe code</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#protocols">Protocols</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#footnotes">Footnotes</a></li>
<li class="toctree-l1"><a class="reference internal" href="Pattern Matching.html">Pattern Matching</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Swift Intermediate Language (SIL)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#abstract">Abstract</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sil-in-the-swift-compiler">SIL in the Swift Compiler</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#silgen">SILGen</a></li>
<li class="toctree-l3"><a class="reference internal" href="#guaranteed-optimization-and-diagnostic-passes">Guaranteed Optimization and Diagnostic Passes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#general-optimization-passes">General Optimization Passes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#syntax">Syntax</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#sil-stage">SIL Stage</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sil-types">SIL Types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#type-lowering">Type Lowering</a></li>
<li class="toctree-l4"><a class="reference internal" href="#abstraction-difference">Abstraction Difference</a></li>
<li class="toctree-l4"><a class="reference internal" href="#legal-sil-types">Legal SIL Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#address-types">Address Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#local-storage-types">Local Storage Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#box-types">Box Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#function-types">Function Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#properties-of-types">Properties of Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#layout-compatible-types">Layout Compatible Types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#values-and-operands">Values and Operands</a></li>
<li class="toctree-l3"><a class="reference internal" href="#functions">Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#basic-blocks">Basic Blocks</a></li>
<li class="toctree-l3"><a class="reference internal" href="#declaration-references">Declaration References</a></li>
<li class="toctree-l3"><a class="reference internal" href="#linkage">Linkage</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#definition-of-the-linked-relation">Definition of the <em>linked</em> relation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#requirements-on-linked-objects">Requirements on linked objects</a></li>
<li class="toctree-l4"><a class="reference internal" href="#summary">Summary</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#vtables">VTables</a></li>
<li class="toctree-l3"><a class="reference internal" href="#witness-tables">Witness Tables</a></li>
<li class="toctree-l3"><a class="reference internal" href="#global-variables">Global Variables</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dataflow-errors">Dataflow Errors</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#definitive-initialization">Definitive Initialization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#unreachable-control-flow">Unreachable Control Flow</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#runtime-failure">Runtime Failure</a></li>
<li class="toctree-l2"><a class="reference internal" href="#undefined-behavior">Undefined Behavior</a></li>
<li class="toctree-l2"><a class="reference internal" href="#calling-convention">Calling Convention</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#swift-calling-convention-cc-swift">Swift Calling Convention &#64;cc(swift)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#reference-counts">Reference Counts</a></li>
<li class="toctree-l4"><a class="reference internal" href="#address-only-types">Address-Only Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#variadic-arguments">Variadic Arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="#function-currying">Function Currying</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inout-arguments">&#64;inout Arguments</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#swift-method-calling-convention-cc-method">Swift Method Calling Convention &#64;cc(method)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#witness-method-calling-convention-cc-witness-method">Witness Method Calling Convention &#64;cc(witness_method)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#c-calling-convention-cc-cdecl">C Calling Convention &#64;cc(cdecl)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#objective-c-calling-convention-cc-objc-method">Objective-C Calling Convention &#64;cc(objc_method)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id1">Reference Counts</a></li>
<li class="toctree-l4"><a class="reference internal" href="#method-currying">Method Currying</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#type-based-alias-analysis">Type Based Alias Analysis</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#class-tbaa">Class TBAA</a></li>
<li class="toctree-l3"><a class="reference internal" href="#typed-access-tbaa">Typed Access TBAA</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#value-dependence">Value Dependence</a></li>
<li class="toctree-l2"><a class="reference internal" href="#instruction-set">Instruction Set</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#allocation-and-deallocation">Allocation and Deallocation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#alloc-stack">alloc_stack</a></li>
<li class="toctree-l4"><a class="reference internal" href="#alloc-ref">alloc_ref</a></li>
<li class="toctree-l4"><a class="reference internal" href="#alloc-ref-dynamic">alloc_ref_dynamic</a></li>
<li class="toctree-l4"><a class="reference internal" href="#alloc-box">alloc_box</a></li>
<li class="toctree-l4"><a class="reference internal" href="#alloc-value-buffer">alloc_value_buffer</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dealloc-stack">dealloc_stack</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dealloc-box">dealloc_box</a></li>
<li class="toctree-l4"><a class="reference internal" href="#project-box">project_box</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dealloc-ref">dealloc_ref</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dealloc-partial-ref">dealloc_partial_ref</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dealloc-value-buffer">dealloc_value_buffer</a></li>
<li class="toctree-l4"><a class="reference internal" href="#project-value-buffer">project_value_buffer</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#debug-information">Debug Information</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#debug-value">debug_value</a></li>
<li class="toctree-l4"><a class="reference internal" href="#debug-value-addr">debug_value_addr</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#accessing-memory">Accessing Memory</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#load">load</a></li>
<li class="toctree-l4"><a class="reference internal" href="#store">store</a></li>
<li class="toctree-l4"><a class="reference internal" href="#assign">assign</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mark-uninitialized">mark_uninitialized</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mark-function-escape">mark_function_escape</a></li>
<li class="toctree-l4"><a class="reference internal" href="#copy-addr">copy_addr</a></li>
<li class="toctree-l4"><a class="reference internal" href="#destroy-addr">destroy_addr</a></li>
<li class="toctree-l4"><a class="reference internal" href="#index-addr">index_addr</a></li>
<li class="toctree-l4"><a class="reference internal" href="#index-raw-pointer">index_raw_pointer</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#reference-counting">Reference Counting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#strong-retain">strong_retain</a></li>
<li class="toctree-l4"><a class="reference internal" href="#strong-release">strong_release</a></li>
<li class="toctree-l4"><a class="reference internal" href="#strong-retain-unowned">strong_retain_unowned</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unowned-retain">unowned_retain</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unowned-release">unowned_release</a></li>
<li class="toctree-l4"><a class="reference internal" href="#load-weak">load_weak</a></li>
<li class="toctree-l4"><a class="reference internal" href="#store-weak">store_weak</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fix-lifetime">fix_lifetime</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mark-dependence">mark_dependence</a></li>
<li class="toctree-l4"><a class="reference internal" href="#is-unique">is_unique</a></li>
<li class="toctree-l4"><a class="reference internal" href="#is-unique-or-pinned">is_unique_or_pinned</a></li>
<li class="toctree-l4"><a class="reference internal" href="#copy-block">copy_block</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#literals">Literals</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#function-ref">function_ref</a></li>
<li class="toctree-l4"><a class="reference internal" href="#global-addr">global_addr</a></li>
<li class="toctree-l4"><a class="reference internal" href="#integer-literal">integer_literal</a></li>
<li class="toctree-l4"><a class="reference internal" href="#float-literal">float_literal</a></li>
<li class="toctree-l4"><a class="reference internal" href="#string-literal">string_literal</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#dynamic-dispatch">Dynamic Dispatch</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#class-method">class_method</a></li>
<li class="toctree-l4"><a class="reference internal" href="#super-method">super_method</a></li>
<li class="toctree-l4"><a class="reference internal" href="#witness-method">witness_method</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dynamic-method">dynamic_method</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#function-application">Function Application</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#apply">apply</a></li>
<li class="toctree-l4"><a class="reference internal" href="#partial-apply">partial_apply</a></li>
<li class="toctree-l4"><a class="reference internal" href="#builtin">builtin</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#metatypes">Metatypes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#metatype">metatype</a></li>
<li class="toctree-l4"><a class="reference internal" href="#value-metatype">value_metatype</a></li>
<li class="toctree-l4"><a class="reference internal" href="#existential-metatype">existential_metatype</a></li>
<li class="toctree-l4"><a class="reference internal" href="#objc-protocol">objc_protocol</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#aggregate-types">Aggregate Types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#retain-value">retain_value</a></li>
<li class="toctree-l4"><a class="reference internal" href="#release-value">release_value</a></li>
<li class="toctree-l4"><a class="reference internal" href="#autorelease-value">autorelease_value</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tuple">tuple</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tuple-extract">tuple_extract</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tuple-element-addr">tuple_element_addr</a></li>
<li class="toctree-l4"><a class="reference internal" href="#struct">struct</a></li>
<li class="toctree-l4"><a class="reference internal" href="#struct-extract">struct_extract</a></li>
<li class="toctree-l4"><a class="reference internal" href="#struct-element-addr">struct_element_addr</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ref-element-addr">ref_element_addr</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#enums">Enums</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#enum">enum</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unchecked-enum-data">unchecked_enum_data</a></li>
<li class="toctree-l4"><a class="reference internal" href="#init-enum-data-addr">init_enum_data_addr</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inject-enum-addr">inject_enum_addr</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unchecked-take-enum-data-addr">unchecked_take_enum_data_addr</a></li>
<li class="toctree-l4"><a class="reference internal" href="#select-enum">select_enum</a></li>
<li class="toctree-l4"><a class="reference internal" href="#select-enum-addr">select_enum_addr</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#protocol-and-protocol-composition-types">Protocol and Protocol Composition Types</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#init-existential-addr">init_existential_addr</a></li>
<li class="toctree-l4"><a class="reference internal" href="#deinit-existential-addr">deinit_existential_addr</a></li>
<li class="toctree-l4"><a class="reference internal" href="#open-existential-addr">open_existential_addr</a></li>
<li class="toctree-l4"><a class="reference internal" href="#init-existential-ref">init_existential_ref</a></li>
<li class="toctree-l4"><a class="reference internal" href="#open-existential-ref">open_existential_ref</a></li>
<li class="toctree-l4"><a class="reference internal" href="#init-existential-metatype">init_existential_metatype</a></li>
<li class="toctree-l4"><a class="reference internal" href="#open-existential-metatype">open_existential_metatype</a></li>
<li class="toctree-l4"><a class="reference internal" href="#alloc-existential-box">alloc_existential_box</a></li>
<li class="toctree-l4"><a class="reference internal" href="#open-existential-box">open_existential_box</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dealloc-existential-box">dealloc_existential_box</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#blocks">Blocks</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#project-block-storage">project_block_storage</a></li>
<li class="toctree-l4"><a class="reference internal" href="#init-block-storage-header">init_block_storage_header</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#unchecked-conversions">Unchecked Conversions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#upcast">upcast</a></li>
<li class="toctree-l4"><a class="reference internal" href="#address-to-pointer">address_to_pointer</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pointer-to-address">pointer_to_address</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unchecked-ref-cast">unchecked_ref_cast</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unchecked-ref-cast-addr">unchecked_ref_cast_addr</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unchecked-addr-cast">unchecked_addr_cast</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unchecked-trivial-bit-cast">unchecked_trivial_bit_cast</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unchecked-bitwise-cast">unchecked_bitwise_cast</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ref-to-raw-pointer">ref_to_raw_pointer</a></li>
<li class="toctree-l4"><a class="reference internal" href="#raw-pointer-to-ref">raw_pointer_to_ref</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ref-to-unowned">ref_to_unowned</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unowned-to-ref">unowned_to_ref</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ref-to-unmanaged">ref_to_unmanaged</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unmanaged-to-ref">unmanaged_to_ref</a></li>
<li class="toctree-l4"><a class="reference internal" href="#convert-function">convert_function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#thin-function-to-pointer">thin_function_to_pointer</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pointer-to-thin-function">pointer_to_thin_function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ref-to-bridge-object">ref_to_bridge_object</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bridge-object-to-ref">bridge_object_to_ref</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bridge-object-to-word">bridge_object_to_word</a></li>
<li class="toctree-l4"><a class="reference internal" href="#thin-to-thick-function">thin_to_thick_function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#thick-to-objc-metatype">thick_to_objc_metatype</a></li>
<li class="toctree-l4"><a class="reference internal" href="#objc-to-thick-metatype">objc_to_thick_metatype</a></li>
<li class="toctree-l4"><a class="reference internal" href="#objc-metatype-to-object">objc_metatype_to_object</a></li>
<li class="toctree-l4"><a class="reference internal" href="#objc-existential-metatype-to-object">objc_existential_metatype_to_object</a></li>
<li class="toctree-l4"><a class="reference internal" href="#is-nonnull">is_nonnull</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#checked-conversions">Checked Conversions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#unconditional-checked-cast">unconditional_checked_cast</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unconditional-checked-cast-addr">unconditional_checked_cast_addr</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#runtime-failures">Runtime Failures</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#cond-fail">cond_fail</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#terminators">Terminators</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#unreachable">unreachable</a></li>
<li class="toctree-l4"><a class="reference internal" href="#return">return</a></li>
<li class="toctree-l4"><a class="reference internal" href="#throw">throw</a></li>
<li class="toctree-l4"><a class="reference internal" href="#br">br</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cond-br">cond_br</a></li>
<li class="toctree-l4"><a class="reference internal" href="#switch-value">switch_value</a></li>
<li class="toctree-l4"><a class="reference internal" href="#select-value">select_value</a></li>
<li class="toctree-l4"><a class="reference internal" href="#switch-enum">switch_enum</a></li>
<li class="toctree-l4"><a class="reference internal" href="#switch-enum-addr">switch_enum_addr</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dynamic-method-br">dynamic_method_br</a></li>
<li class="toctree-l4"><a class="reference internal" href="#checked-cast-br">checked_cast_br</a></li>
<li class="toctree-l4"><a class="reference internal" href="#checked-cast-addr-br">checked_cast_addr_br</a></li>
<li class="toctree-l4"><a class="reference internal" href="#try-apply">try_apply</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#assertion-configuration">Assertion configuration</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="SequencesAndCollections.html">Sequences And Collections in Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="Serialization.html">Swift Binary Serialization Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="StdlibAPIGuidelines.html">Swift Standard Library API Design Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="StdlibRationales.html">Rationales for the Swift standard library designs</a></li>
<li class="toctree-l1"><a class="reference internal" href="StoredAndComputedVariables.html">Stored and Computed Variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="StringDesign.html">Swift String Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="Testing.html">Testing Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="TextFormatting.html">Text Formatting in Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="TransparentAttr.html"><code class="docutils literal"><span class="pre">&#64;_transparent</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="TypeChecker.html">Type Checker Design and Implementation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="contents.html">Contents</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="IndexInvalidation.html">Index Invalidation Rules in the Swift Standard Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="AccessControl.html">Access Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="DriverInternals.html">Driver Design &amp; Internals</a></li>
<li class="toctree-l2"><a class="reference internal" href="DriverParseableOutput.html">Parseable Driver Output</a></li>
<li class="toctree-l2"><a class="reference internal" href="ErrorHandling.html">Error Handling in Swift 2.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="ErrorHandlingRationale.html">Error Handling Rationale and Proposal</a></li>
<li class="toctree-l2"><a class="reference internal" href="Generics.html">Generics in Swift</a></li>
<li class="toctree-l2"><a class="reference internal" href="LogicalObjects.html">Logical Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="ObjectInitialization.html">Object Initialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="Pattern Matching.html">Pattern Matching</a></li>
<li class="toctree-l2"><a class="reference internal" href="StoredAndComputedVariables.html">Stored and Computed Variables</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Swift Intermediate Language (SIL)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#abstract">Abstract</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sil-in-the-swift-compiler">SIL in the Swift Compiler</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#silgen">SILGen</a></li>
<li class="toctree-l4"><a class="reference internal" href="#guaranteed-optimization-and-diagnostic-passes">Guaranteed Optimization and Diagnostic Passes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#general-optimization-passes">General Optimization Passes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#syntax">Syntax</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#sil-stage">SIL Stage</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sil-types">SIL Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#values-and-operands">Values and Operands</a></li>
<li class="toctree-l4"><a class="reference internal" href="#functions">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#basic-blocks">Basic Blocks</a></li>
<li class="toctree-l4"><a class="reference internal" href="#declaration-references">Declaration References</a></li>
<li class="toctree-l4"><a class="reference internal" href="#linkage">Linkage</a></li>
<li class="toctree-l4"><a class="reference internal" href="#vtables">VTables</a></li>
<li class="toctree-l4"><a class="reference internal" href="#witness-tables">Witness Tables</a></li>
<li class="toctree-l4"><a class="reference internal" href="#global-variables">Global Variables</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#dataflow-errors">Dataflow Errors</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#definitive-initialization">Definitive Initialization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unreachable-control-flow">Unreachable Control Flow</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#runtime-failure">Runtime Failure</a></li>
<li class="toctree-l3"><a class="reference internal" href="#undefined-behavior">Undefined Behavior</a></li>
<li class="toctree-l3"><a class="reference internal" href="#calling-convention">Calling Convention</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#swift-calling-convention-cc-swift">Swift Calling Convention &#64;cc(swift)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#swift-method-calling-convention-cc-method">Swift Method Calling Convention &#64;cc(method)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#witness-method-calling-convention-cc-witness-method">Witness Method Calling Convention &#64;cc(witness_method)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#c-calling-convention-cc-cdecl">C Calling Convention &#64;cc(cdecl)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#objective-c-calling-convention-cc-objc-method">Objective-C Calling Convention &#64;cc(objc_method)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#type-based-alias-analysis">Type Based Alias Analysis</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#class-tbaa">Class TBAA</a></li>
<li class="toctree-l4"><a class="reference internal" href="#typed-access-tbaa">Typed Access TBAA</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#value-dependence">Value Dependence</a></li>
<li class="toctree-l3"><a class="reference internal" href="#instruction-set">Instruction Set</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#allocation-and-deallocation">Allocation and Deallocation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#debug-information">Debug Information</a></li>
<li class="toctree-l4"><a class="reference internal" href="#accessing-memory">Accessing Memory</a></li>
<li class="toctree-l4"><a class="reference internal" href="#reference-counting">Reference Counting</a></li>
<li class="toctree-l4"><a class="reference internal" href="#literals">Literals</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dynamic-dispatch">Dynamic Dispatch</a></li>
<li class="toctree-l4"><a class="reference internal" href="#function-application">Function Application</a></li>
<li class="toctree-l4"><a class="reference internal" href="#metatypes">Metatypes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#aggregate-types">Aggregate Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#enums">Enums</a></li>
<li class="toctree-l4"><a class="reference internal" href="#protocol-and-protocol-composition-types">Protocol and Protocol Composition Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#blocks">Blocks</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unchecked-conversions">Unchecked Conversions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#checked-conversions">Checked Conversions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#runtime-failures">Runtime Failures</a></li>
<li class="toctree-l4"><a class="reference internal" href="#terminators">Terminators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#assertion-configuration">Assertion configuration</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="TypeChecker.html">Type Checker Design and Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="DebuggingTheCompiler.html">Debugging the Swift Compiler</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="weak.html">Weak References</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Swift Programming Language documentation</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
        <li><a href="contents.html">Contents</a> &raquo;</li>
      
    <li>Swift Intermediate Language (SIL)</li>
    <li class="wy-breadcrumbs-aside">
      
        
          <a href="_sources/SIL.txt" rel="nofollow"> View page source</a>
        
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="swift-intermediate-language-sil">
<h1><a class="toc-backref" href="#id2">Swift Intermediate Language (SIL)</a><a class="headerlink" href="#swift-intermediate-language-sil" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#swift-intermediate-language-sil" id="id2">Swift Intermediate Language (SIL)</a><ul>
<li><a class="reference internal" href="#abstract" id="id3">Abstract</a></li>
<li><a class="reference internal" href="#sil-in-the-swift-compiler" id="id4">SIL in the Swift Compiler</a><ul>
<li><a class="reference internal" href="#silgen" id="id5">SILGen</a></li>
<li><a class="reference internal" href="#guaranteed-optimization-and-diagnostic-passes" id="id6">Guaranteed Optimization and Diagnostic Passes</a></li>
<li><a class="reference internal" href="#general-optimization-passes" id="id7">General Optimization Passes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#syntax" id="id8">Syntax</a><ul>
<li><a class="reference internal" href="#sil-stage" id="id9">SIL Stage</a></li>
<li><a class="reference internal" href="#sil-types" id="id10">SIL Types</a><ul>
<li><a class="reference internal" href="#type-lowering" id="id11">Type Lowering</a></li>
<li><a class="reference internal" href="#abstraction-difference" id="id12">Abstraction Difference</a></li>
<li><a class="reference internal" href="#legal-sil-types" id="id13">Legal SIL Types</a></li>
<li><a class="reference internal" href="#address-types" id="id14">Address Types</a></li>
<li><a class="reference internal" href="#local-storage-types" id="id15">Local Storage Types</a></li>
<li><a class="reference internal" href="#box-types" id="id16">Box Types</a></li>
<li><a class="reference internal" href="#function-types" id="id17">Function Types</a></li>
<li><a class="reference internal" href="#properties-of-types" id="id18">Properties of Types</a></li>
<li><a class="reference internal" href="#layout-compatible-types" id="id19">Layout Compatible Types</a></li>
</ul>
</li>
<li><a class="reference internal" href="#values-and-operands" id="id20">Values and Operands</a></li>
<li><a class="reference internal" href="#functions" id="id21">Functions</a></li>
<li><a class="reference internal" href="#basic-blocks" id="id22">Basic Blocks</a></li>
<li><a class="reference internal" href="#declaration-references" id="id23">Declaration References</a></li>
<li><a class="reference internal" href="#linkage" id="id24">Linkage</a><ul>
<li><a class="reference internal" href="#definition-of-the-linked-relation" id="id25">Definition of the <em>linked</em> relation</a></li>
<li><a class="reference internal" href="#requirements-on-linked-objects" id="id26">Requirements on linked objects</a></li>
<li><a class="reference internal" href="#summary" id="id27">Summary</a></li>
</ul>
</li>
<li><a class="reference internal" href="#vtables" id="id28">VTables</a></li>
<li><a class="reference internal" href="#witness-tables" id="id29">Witness Tables</a></li>
<li><a class="reference internal" href="#global-variables" id="id30">Global Variables</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dataflow-errors" id="id31">Dataflow Errors</a><ul>
<li><a class="reference internal" href="#definitive-initialization" id="id32">Definitive Initialization</a></li>
<li><a class="reference internal" href="#unreachable-control-flow" id="id33">Unreachable Control Flow</a></li>
</ul>
</li>
<li><a class="reference internal" href="#runtime-failure" id="id34">Runtime Failure</a></li>
<li><a class="reference internal" href="#undefined-behavior" id="id35">Undefined Behavior</a></li>
<li><a class="reference internal" href="#calling-convention" id="id36">Calling Convention</a><ul>
<li><a class="reference internal" href="#swift-calling-convention-cc-swift" id="id37">Swift Calling Convention &#64;cc(swift)</a><ul>
<li><a class="reference internal" href="#reference-counts" id="id38">Reference Counts</a></li>
<li><a class="reference internal" href="#address-only-types" id="id39">Address-Only Types</a></li>
<li><a class="reference internal" href="#variadic-arguments" id="id40">Variadic Arguments</a></li>
<li><a class="reference internal" href="#function-currying" id="id41">Function Currying</a></li>
<li><a class="reference internal" href="#inout-arguments" id="id42">&#64;inout Arguments</a></li>
</ul>
</li>
<li><a class="reference internal" href="#swift-method-calling-convention-cc-method" id="id43">Swift Method Calling Convention &#64;cc(method)</a></li>
<li><a class="reference internal" href="#witness-method-calling-convention-cc-witness-method" id="id44">Witness Method Calling Convention &#64;cc(witness_method)</a></li>
<li><a class="reference internal" href="#c-calling-convention-cc-cdecl" id="id45">C Calling Convention &#64;cc(cdecl)</a></li>
<li><a class="reference internal" href="#objective-c-calling-convention-cc-objc-method" id="id46">Objective-C Calling Convention &#64;cc(objc_method)</a><ul>
<li><a class="reference internal" href="#id1" id="id47">Reference Counts</a></li>
<li><a class="reference internal" href="#method-currying" id="id48">Method Currying</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#type-based-alias-analysis" id="id49">Type Based Alias Analysis</a><ul>
<li><a class="reference internal" href="#class-tbaa" id="id50">Class TBAA</a></li>
<li><a class="reference internal" href="#typed-access-tbaa" id="id51">Typed Access TBAA</a></li>
</ul>
</li>
<li><a class="reference internal" href="#value-dependence" id="id52">Value Dependence</a></li>
<li><a class="reference internal" href="#instruction-set" id="id53">Instruction Set</a><ul>
<li><a class="reference internal" href="#allocation-and-deallocation" id="id54">Allocation and Deallocation</a><ul>
<li><a class="reference internal" href="#alloc-stack" id="id55">alloc_stack</a></li>
<li><a class="reference internal" href="#alloc-ref" id="id56">alloc_ref</a></li>
<li><a class="reference internal" href="#alloc-ref-dynamic" id="id57">alloc_ref_dynamic</a></li>
<li><a class="reference internal" href="#alloc-box" id="id58">alloc_box</a></li>
<li><a class="reference internal" href="#alloc-value-buffer" id="id59">alloc_value_buffer</a></li>
<li><a class="reference internal" href="#dealloc-stack" id="id60">dealloc_stack</a></li>
<li><a class="reference internal" href="#dealloc-box" id="id61">dealloc_box</a></li>
<li><a class="reference internal" href="#project-box" id="id62">project_box</a></li>
<li><a class="reference internal" href="#dealloc-ref" id="id63">dealloc_ref</a></li>
<li><a class="reference internal" href="#dealloc-partial-ref" id="id64">dealloc_partial_ref</a></li>
<li><a class="reference internal" href="#dealloc-value-buffer" id="id65">dealloc_value_buffer</a></li>
<li><a class="reference internal" href="#project-value-buffer" id="id66">project_value_buffer</a></li>
</ul>
</li>
<li><a class="reference internal" href="#debug-information" id="id67">Debug Information</a><ul>
<li><a class="reference internal" href="#debug-value" id="id68">debug_value</a></li>
<li><a class="reference internal" href="#debug-value-addr" id="id69">debug_value_addr</a></li>
</ul>
</li>
<li><a class="reference internal" href="#accessing-memory" id="id70">Accessing Memory</a><ul>
<li><a class="reference internal" href="#load" id="id71">load</a></li>
<li><a class="reference internal" href="#store" id="id72">store</a></li>
<li><a class="reference internal" href="#assign" id="id73">assign</a></li>
<li><a class="reference internal" href="#mark-uninitialized" id="id74">mark_uninitialized</a></li>
<li><a class="reference internal" href="#mark-function-escape" id="id75">mark_function_escape</a></li>
<li><a class="reference internal" href="#copy-addr" id="id76">copy_addr</a></li>
<li><a class="reference internal" href="#destroy-addr" id="id77">destroy_addr</a></li>
<li><a class="reference internal" href="#index-addr" id="id78">index_addr</a></li>
<li><a class="reference internal" href="#index-raw-pointer" id="id79">index_raw_pointer</a></li>
</ul>
</li>
<li><a class="reference internal" href="#reference-counting" id="id80">Reference Counting</a><ul>
<li><a class="reference internal" href="#strong-retain" id="id81">strong_retain</a></li>
<li><a class="reference internal" href="#strong-release" id="id82">strong_release</a></li>
<li><a class="reference internal" href="#strong-retain-unowned" id="id83">strong_retain_unowned</a></li>
<li><a class="reference internal" href="#unowned-retain" id="id84">unowned_retain</a></li>
<li><a class="reference internal" href="#unowned-release" id="id85">unowned_release</a></li>
<li><a class="reference internal" href="#load-weak" id="id86">load_weak</a></li>
<li><a class="reference internal" href="#store-weak" id="id87">store_weak</a></li>
<li><a class="reference internal" href="#fix-lifetime" id="id88">fix_lifetime</a></li>
<li><a class="reference internal" href="#mark-dependence" id="id89">mark_dependence</a></li>
<li><a class="reference internal" href="#is-unique" id="id90">is_unique</a></li>
<li><a class="reference internal" href="#is-unique-or-pinned" id="id91">is_unique_or_pinned</a></li>
<li><a class="reference internal" href="#copy-block" id="id92">copy_block</a></li>
</ul>
</li>
<li><a class="reference internal" href="#literals" id="id93">Literals</a><ul>
<li><a class="reference internal" href="#function-ref" id="id94">function_ref</a></li>
<li><a class="reference internal" href="#global-addr" id="id95">global_addr</a></li>
<li><a class="reference internal" href="#integer-literal" id="id96">integer_literal</a></li>
<li><a class="reference internal" href="#float-literal" id="id97">float_literal</a></li>
<li><a class="reference internal" href="#string-literal" id="id98">string_literal</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dynamic-dispatch" id="id99">Dynamic Dispatch</a><ul>
<li><a class="reference internal" href="#class-method" id="id100">class_method</a></li>
<li><a class="reference internal" href="#super-method" id="id101">super_method</a></li>
<li><a class="reference internal" href="#witness-method" id="id102">witness_method</a></li>
<li><a class="reference internal" href="#dynamic-method" id="id103">dynamic_method</a></li>
</ul>
</li>
<li><a class="reference internal" href="#function-application" id="id104">Function Application</a><ul>
<li><a class="reference internal" href="#apply" id="id105">apply</a></li>
<li><a class="reference internal" href="#partial-apply" id="id106">partial_apply</a></li>
<li><a class="reference internal" href="#builtin" id="id107">builtin</a></li>
</ul>
</li>
<li><a class="reference internal" href="#metatypes" id="id108">Metatypes</a><ul>
<li><a class="reference internal" href="#metatype" id="id109">metatype</a></li>
<li><a class="reference internal" href="#value-metatype" id="id110">value_metatype</a></li>
<li><a class="reference internal" href="#existential-metatype" id="id111">existential_metatype</a></li>
<li><a class="reference internal" href="#objc-protocol" id="id112">objc_protocol</a></li>
</ul>
</li>
<li><a class="reference internal" href="#aggregate-types" id="id113">Aggregate Types</a><ul>
<li><a class="reference internal" href="#retain-value" id="id114">retain_value</a></li>
<li><a class="reference internal" href="#release-value" id="id115">release_value</a></li>
<li><a class="reference internal" href="#autorelease-value" id="id116">autorelease_value</a></li>
<li><a class="reference internal" href="#tuple" id="id117">tuple</a></li>
<li><a class="reference internal" href="#tuple-extract" id="id118">tuple_extract</a></li>
<li><a class="reference internal" href="#tuple-element-addr" id="id119">tuple_element_addr</a></li>
<li><a class="reference internal" href="#struct" id="id120">struct</a></li>
<li><a class="reference internal" href="#struct-extract" id="id121">struct_extract</a></li>
<li><a class="reference internal" href="#struct-element-addr" id="id122">struct_element_addr</a></li>
<li><a class="reference internal" href="#ref-element-addr" id="id123">ref_element_addr</a></li>
</ul>
</li>
<li><a class="reference internal" href="#enums" id="id124">Enums</a><ul>
<li><a class="reference internal" href="#enum" id="id125">enum</a></li>
<li><a class="reference internal" href="#unchecked-enum-data" id="id126">unchecked_enum_data</a></li>
<li><a class="reference internal" href="#init-enum-data-addr" id="id127">init_enum_data_addr</a></li>
<li><a class="reference internal" href="#inject-enum-addr" id="id128">inject_enum_addr</a></li>
<li><a class="reference internal" href="#unchecked-take-enum-data-addr" id="id129">unchecked_take_enum_data_addr</a></li>
<li><a class="reference internal" href="#select-enum" id="id130">select_enum</a></li>
<li><a class="reference internal" href="#select-enum-addr" id="id131">select_enum_addr</a></li>
</ul>
</li>
<li><a class="reference internal" href="#protocol-and-protocol-composition-types" id="id132">Protocol and Protocol Composition Types</a><ul>
<li><a class="reference internal" href="#init-existential-addr" id="id133">init_existential_addr</a></li>
<li><a class="reference internal" href="#deinit-existential-addr" id="id134">deinit_existential_addr</a></li>
<li><a class="reference internal" href="#open-existential-addr" id="id135">open_existential_addr</a></li>
<li><a class="reference internal" href="#init-existential-ref" id="id136">init_existential_ref</a></li>
<li><a class="reference internal" href="#open-existential-ref" id="id137">open_existential_ref</a></li>
<li><a class="reference internal" href="#init-existential-metatype" id="id138">init_existential_metatype</a></li>
<li><a class="reference internal" href="#open-existential-metatype" id="id139">open_existential_metatype</a></li>
<li><a class="reference internal" href="#alloc-existential-box" id="id140">alloc_existential_box</a></li>
<li><a class="reference internal" href="#open-existential-box" id="id141">open_existential_box</a></li>
<li><a class="reference internal" href="#dealloc-existential-box" id="id142">dealloc_existential_box</a></li>
</ul>
</li>
<li><a class="reference internal" href="#blocks" id="id143">Blocks</a><ul>
<li><a class="reference internal" href="#project-block-storage" id="id144">project_block_storage</a></li>
<li><a class="reference internal" href="#init-block-storage-header" id="id145">init_block_storage_header</a></li>
</ul>
</li>
<li><a class="reference internal" href="#unchecked-conversions" id="id146">Unchecked Conversions</a><ul>
<li><a class="reference internal" href="#upcast" id="id147">upcast</a></li>
<li><a class="reference internal" href="#address-to-pointer" id="id148">address_to_pointer</a></li>
<li><a class="reference internal" href="#pointer-to-address" id="id149">pointer_to_address</a></li>
<li><a class="reference internal" href="#unchecked-ref-cast" id="id150">unchecked_ref_cast</a></li>
<li><a class="reference internal" href="#unchecked-ref-cast-addr" id="id151">unchecked_ref_cast_addr</a></li>
<li><a class="reference internal" href="#unchecked-addr-cast" id="id152">unchecked_addr_cast</a></li>
<li><a class="reference internal" href="#unchecked-trivial-bit-cast" id="id153">unchecked_trivial_bit_cast</a></li>
<li><a class="reference internal" href="#unchecked-bitwise-cast" id="id154">unchecked_bitwise_cast</a></li>
<li><a class="reference internal" href="#ref-to-raw-pointer" id="id155">ref_to_raw_pointer</a></li>
<li><a class="reference internal" href="#raw-pointer-to-ref" id="id156">raw_pointer_to_ref</a></li>
<li><a class="reference internal" href="#ref-to-unowned" id="id157">ref_to_unowned</a></li>
<li><a class="reference internal" href="#unowned-to-ref" id="id158">unowned_to_ref</a></li>
<li><a class="reference internal" href="#ref-to-unmanaged" id="id159">ref_to_unmanaged</a></li>
<li><a class="reference internal" href="#unmanaged-to-ref" id="id160">unmanaged_to_ref</a></li>
<li><a class="reference internal" href="#convert-function" id="id161">convert_function</a></li>
<li><a class="reference internal" href="#thin-function-to-pointer" id="id162">thin_function_to_pointer</a></li>
<li><a class="reference internal" href="#pointer-to-thin-function" id="id163">pointer_to_thin_function</a></li>
<li><a class="reference internal" href="#ref-to-bridge-object" id="id164">ref_to_bridge_object</a></li>
<li><a class="reference internal" href="#bridge-object-to-ref" id="id165">bridge_object_to_ref</a></li>
<li><a class="reference internal" href="#bridge-object-to-word" id="id166">bridge_object_to_word</a></li>
<li><a class="reference internal" href="#thin-to-thick-function" id="id167">thin_to_thick_function</a></li>
<li><a class="reference internal" href="#thick-to-objc-metatype" id="id168">thick_to_objc_metatype</a></li>
<li><a class="reference internal" href="#objc-to-thick-metatype" id="id169">objc_to_thick_metatype</a></li>
<li><a class="reference internal" href="#objc-metatype-to-object" id="id170">objc_metatype_to_object</a></li>
<li><a class="reference internal" href="#objc-existential-metatype-to-object" id="id171">objc_existential_metatype_to_object</a></li>
<li><a class="reference internal" href="#is-nonnull" id="id172">is_nonnull</a></li>
</ul>
</li>
<li><a class="reference internal" href="#checked-conversions" id="id173">Checked Conversions</a><ul>
<li><a class="reference internal" href="#unconditional-checked-cast" id="id174">unconditional_checked_cast</a></li>
<li><a class="reference internal" href="#unconditional-checked-cast-addr" id="id175">unconditional_checked_cast_addr</a></li>
</ul>
</li>
<li><a class="reference internal" href="#runtime-failures" id="id176">Runtime Failures</a><ul>
<li><a class="reference internal" href="#cond-fail" id="id177">cond_fail</a></li>
</ul>
</li>
<li><a class="reference internal" href="#terminators" id="id178">Terminators</a><ul>
<li><a class="reference internal" href="#unreachable" id="id179">unreachable</a></li>
<li><a class="reference internal" href="#return" id="id180">return</a></li>
<li><a class="reference internal" href="#throw" id="id181">throw</a></li>
<li><a class="reference internal" href="#br" id="id182">br</a></li>
<li><a class="reference internal" href="#cond-br" id="id183">cond_br</a></li>
<li><a class="reference internal" href="#switch-value" id="id184">switch_value</a></li>
<li><a class="reference internal" href="#select-value" id="id185">select_value</a></li>
<li><a class="reference internal" href="#switch-enum" id="id186">switch_enum</a></li>
<li><a class="reference internal" href="#switch-enum-addr" id="id187">switch_enum_addr</a></li>
<li><a class="reference internal" href="#dynamic-method-br" id="id188">dynamic_method_br</a></li>
<li><a class="reference internal" href="#checked-cast-br" id="id189">checked_cast_br</a></li>
<li><a class="reference internal" href="#checked-cast-addr-br" id="id190">checked_cast_addr_br</a></li>
<li><a class="reference internal" href="#try-apply" id="id191">try_apply</a></li>
</ul>
</li>
<li><a class="reference internal" href="#assertion-configuration" id="id192">Assertion configuration</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="abstract">
<h2><a class="toc-backref" href="#id3">Abstract</a><a class="headerlink" href="#abstract" title="Permalink to this headline">¶</a></h2>
<p>SIL is an SSA-form IR with high-level semantic information designed to implement
the Swift programming language. SIL accommodates the following use cases:</p>
<ul class="simple">
<li>A set of guaranteed high-level optimizations that provide a predictable
baseline for runtime and diagnostic behavior.</li>
<li>Diagnostic dataflow analysis passes that enforce Swift language requirements,
such as definitive initialization of variables and constructors, code
reachability, switch coverage.</li>
<li>High-level optimization passes, including retain/release optimization,
dynamic method devirtualization, closure inlining, memory allocation promotion,
and generic function instantiation.</li>
<li>A stable distribution format that can be used to distribute &#8220;fragile&#8221;
inlineable or generic code with Swift library modules, to be optimized into
client binaries.</li>
</ul>
<p>In contrast to LLVM IR, SIL is a generally target-independent format
representation that can be used for code distribution, but it can also express
target-specific concepts as well as LLVM can.</p>
</div>
<div class="section" id="sil-in-the-swift-compiler">
<h2><a class="toc-backref" href="#id4">SIL in the Swift Compiler</a><a class="headerlink" href="#sil-in-the-swift-compiler" title="Permalink to this headline">¶</a></h2>
<p>At a high level, the Swift compiler follows a strict pipeline architecture:</p>
<ul class="simple">
<li>The <em>Parse</em> module constructs an AST from Swift source code.</li>
<li>The <em>Sema</em> module type-checks the AST and annotates it with type information.</li>
<li>The <em>SILGen</em> module generates <em>raw SIL</em> from an AST.</li>
<li>A series of <em>Guaranteed Optimization Passes</em> and <em>Diagnostic Passes</em> are run
over the raw SIL both to perform optimizations and to emit
language-specific diagnostics.  These are always run, even at -Onone, and
produce <em>canonical SIL</em>.</li>
<li>General SIL <em>Optimization Passes</em> optionally run over the canonical SIL to
improve performance of the resulting executable.  These are enabled and
controlled by the optimization level and are not run at -Onone.</li>
<li><em>IRGen</em> lowers canonical SIL to LLVM IR.</li>
<li>The LLVM backend (optionally) applies LLVM optimizations, runs the LLVM code
generator and emits binary code.</li>
</ul>
<p>The stages pertaining to SIL processing in particular are as follows:</p>
<div class="section" id="silgen">
<h3><a class="toc-backref" href="#id5">SILGen</a><a class="headerlink" href="#silgen" title="Permalink to this headline">¶</a></h3>
<p>SILGen produces <em>raw SIL</em> by walking a type-checked Swift AST.
The form of SIL emitted by SILGen has the following properties:</p>
<ul class="simple">
<li>Variables are represented by loading and storing mutable memory locations
instead of being in strict SSA form. This is similar to the initial
<code class="docutils literal"><span class="pre">alloca</span></code>-heavy LLVM IR emitted by frontends such as Clang. However, Swift
represents variables as reference-counted &#8220;boxes&#8221; in the most general case,
which can be retained, released, and captured into closures.</li>
<li>Dataflow requirements, such as definitive assignment, function returns,
switch coverage (TBD), etc. have not yet been enforced.</li>
<li><code class="docutils literal"><span class="pre">transparent</span></code> function optimization has not yet been honored.</li>
</ul>
<p>These properties are addressed by subsequent guaranteed optimization and
diagnostic passes which are always run against the raw SIL.</p>
</div>
<div class="section" id="guaranteed-optimization-and-diagnostic-passes">
<h3><a class="toc-backref" href="#id6">Guaranteed Optimization and Diagnostic Passes</a><a class="headerlink" href="#guaranteed-optimization-and-diagnostic-passes" title="Permalink to this headline">¶</a></h3>
<p>After SILGen, a deterministic sequence of optimization passes is run over the
raw SIL. We do not want the diagnostics produced by the compiler to change as
the compiler evolves, so these passes are intended to be simple and
predictable.</p>
<ul class="simple">
<li><strong>Mandatory inlining</strong> inlines calls to &#8220;transparent&#8221; functions.</li>
<li><strong>Memory promotion</strong> is implemented as two optimization phases, the first
of which performs capture analysis to promote <code class="docutils literal"><span class="pre">alloc_box</span></code> instructions to
<code class="docutils literal"><span class="pre">alloc_stack</span></code>, and the second of which promotes non-address-exposed <code class="docutils literal"><span class="pre">alloc_stack</span></code>
instructions to SSA registers.</li>
<li><strong>Constant propagation</strong> folds constant expressions and propagates the constant values.
If an arithmetic overflow occurs during the constant expression computation, a diagnostic
is issued.</li>
<li><strong>Return analysis</strong> verifies that each function returns a value on every
code path and doesn&#8217;t &#8220;fall of the end&#8221; of its definition, which is an error.
It also issues an error when a <code class="docutils literal"><span class="pre">noreturn</span></code> function returns.</li>
<li><strong>Critical edge splitting</strong> splits all critical edges from terminators that
don&#8217;t support arbitrary basic block arguments (all non cond_branch
terminators).</li>
</ul>
<p>If all diagnostic passes succeed, the final result is the
<em>canonical SIL</em> for the program.</p>
<p>TODO:</p>
<ul class="simple">
<li>Generic specialization</li>
<li>Basic ARC optimization for acceptable performance at -Onone.</li>
</ul>
</div>
<div class="section" id="general-optimization-passes">
<h3><a class="toc-backref" href="#id7">General Optimization Passes</a><a class="headerlink" href="#general-optimization-passes" title="Permalink to this headline">¶</a></h3>
<p>SIL captures language-specific type information, making it possible to
perform high-level optimizations that are difficult to perform on LLVM
IR.</p>
<ul class="simple">
<li><strong>Generic Specialization</strong> analyzes specialized calls to generic
functions and generates new specialized version of the
functions. Then it rewrites all specialized usages of the generic
to a direct call of the appropriate specialized function.</li>
<li><strong>Witness and VTable Devirtualization</strong> for a given type looks up
the associated method from a class&#8217;s vtable or a types witness table
and replaces the indirect virtual call with a call to the mapped
function.</li>
<li><strong>Performance Inlining</strong></li>
<li><strong>Reference Counting Optimizations</strong></li>
<li><strong>Memory Promotion/Optimizations</strong></li>
<li><strong>High-level domain specific optimizations</strong> The swift compiler implements
high-level optimizations on basic Swift containers such as Array or String.
Domain specific optimizations require a defined interface between
the standard library and the optimizer. More details can be found here:
<a class="reference internal" href="HighLevelSILOptimizations.html#highlevelsiloptimizations"><span>High-Level Optimizations in SIL</span></a></li>
</ul>
</div>
</div>
<div class="section" id="syntax">
<h2><a class="toc-backref" href="#id8">Syntax</a><a class="headerlink" href="#syntax" title="Permalink to this headline">¶</a></h2>
<p>SIL is reliant on Swift&#8217;s type system and declarations, so SIL syntax
is an extension of Swift&#8217;s. A <code class="docutils literal"><span class="pre">.sil</span></code> file is a Swift source file
with added SIL definitions. The Swift source is parsed only for its
declarations; Swift <code class="docutils literal"><span class="pre">func</span></code> bodies (except for nested declarations)
and top-level code are ignored by the SIL parser. In a <code class="docutils literal"><span class="pre">.sil</span></code> file,
there are no implicit imports; the <code class="docutils literal"><span class="pre">swift</span></code> and/or <code class="docutils literal"><span class="pre">Builtin</span></code>
standard modules must be imported explicitly if used.</p>
<p>Here is an example of a <code class="docutils literal"><span class="pre">.sil</span></code> file:</p>
<div class="highlight-python"><div class="highlight"><pre>sil_stage canonical

import Swift

// Define types used by the SIL function.

struct Point {
  var x : Double
  var y : Double
}

class Button {
  func onClick()
  func onMouseDown()
  func onMouseUp()
}

// Declare a Swift function. The body is ignored by SIL.
func taxicabNorm(a:Point) -&gt; Double {
  return a.x + a.y
}

// Define a SIL function.
// The name @_T5norms11taxicabNormfT1aV5norms5Point_Sd is the mangled name
// of the taxicabNorm Swift function.
sil @_T5norms11taxicabNormfT1aV5norms5Point_Sd : $(Point) -&gt; Double {
bb0(%0 : $Point):
  // func Swift.+(Double, Double) -&gt; Double
  %1 = function_ref @_Tsoi1pfTSdSd_Sd
  %2 = struct_extract %0 : $Point, #Point.x
  %3 = struct_extract %0 : $Point, #Point.y
  %4 = apply %1(%2, %3) : $(Double, Double) -&gt; Double
  %5 = return %4 : Double
}

// Define a SIL vtable. This matches dynamically-dispatched method
// identifiers to their implementations for a known static class type.
sil_vtable Button {
  #Button.onClick!1: @_TC5norms6Button7onClickfS0_FT_T_
  #Button.onMouseDown!1: @_TC5norms6Button11onMouseDownfS0_FT_T_
  #Button.onMouseUp!1: @_TC5norms6Button9onMouseUpfS0_FT_T_
}
</pre></div>
</div>
<div class="section" id="sil-stage">
<h3><a class="toc-backref" href="#id9">SIL Stage</a><a class="headerlink" href="#sil-stage" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>decl ::= sil-stage-decl
sil-stage-decl ::= &#39;sil_stage&#39; sil-stage

sil-stage ::= &#39;raw&#39;
sil-stage ::= &#39;canonical&#39;
</pre></div>
</div>
<p>There are different invariants on SIL depending on what stage of processing
has been applied to it.</p>
<ul class="simple">
<li><strong>Raw SIL</strong> is the form produced by SILGen that has not been run through
guaranteed optimizations or diagnostic passes. Raw SIL may not have a
fully-constructed SSA graph. It may contain dataflow errors. Some instructions
may be represented in non-canonical forms, such as <code class="docutils literal"><span class="pre">assign</span></code> and
<code class="docutils literal"><span class="pre">destroy_addr</span></code> for non-address-only values. Raw SIL should not be used
for native code generation or distribution.</li>
<li><strong>Canonical SIL</strong> is SIL as it exists after guaranteed optimizations and
diagnostics. Dataflow errors must be eliminated, and certain instructions
must be canonicalized to simpler forms. Performance optimization and native
code generation are derived from this form, and a module can be distributed
containing SIL in this (or later) forms.</li>
</ul>
<p>SIL files declare the processing stage of the included SIL with one of the
declarations <code class="docutils literal"><span class="pre">sil_stage</span> <span class="pre">raw</span></code> or <code class="docutils literal"><span class="pre">sil_stage</span> <span class="pre">canonical</span></code> at top level. Only
one such declaration may appear in a file.</p>
</div>
<div class="section" id="sil-types">
<h3><a class="toc-backref" href="#id10">SIL Types</a><a class="headerlink" href="#sil-types" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>sil-type ::= &#39;$&#39; &#39;*&#39;? generic-parameter-list? type
</pre></div>
</div>
<p>SIL types are introduced with the <code class="docutils literal"><span class="pre">$</span></code> sigil. SIL&#8217;s type system is
closely related to Swift&#8217;s, and so the type after the <code class="docutils literal"><span class="pre">$</span></code> is parsed
largely according to Swift&#8217;s type grammar.</p>
<div class="section" id="type-lowering">
<h4><a class="toc-backref" href="#id11">Type Lowering</a><a class="headerlink" href="#type-lowering" title="Permalink to this headline">¶</a></h4>
<p>A <em>formal type</em> is the type of a value in Swift, such as an expression
result.  Swift&#8217;s formal type system intentionally abstracts over a
large number of representational issues like ownership transfer
conventions and directness of arguments.  However, SIL aims to
represent most such implementation details, and so these differences
deserve to be reflected in the SIL type system.  <em>Type lowering</em> is
the process of turning a formal type into its <em>lowered type</em>.</p>
<p>It is important to be aware that the lowered type of a declaration
need not be the lowered type of the formal type of that declaration.
For example, the lowered type of a declaration reference:</p>
<ul class="simple">
<li>will usually be thin,</li>
<li>will frequently be uncurried,</li>
<li>may have a non-Swift calling convention,</li>
<li>may use bridged types in its interface, and</li>
<li>may use ownership conventions that differ from Swift&#8217;s default
conventions.</li>
</ul>
</div>
<div class="section" id="abstraction-difference">
<h4><a class="toc-backref" href="#id12">Abstraction Difference</a><a class="headerlink" href="#abstraction-difference" title="Permalink to this headline">¶</a></h4>
<p>Generic functions working with values of unconstrained type must
generally work with them indirectly, e.g. by allocating sufficient
memory for them and then passing around pointers to that memory.
Consider a generic function like this:</p>
<div class="highlight-python"><div class="highlight"><pre>func generateArray&lt;T&gt;(n : Int, generator : () -&gt; T) -&gt; T[]
</pre></div>
</div>
<p>The function <code class="docutils literal"><span class="pre">generator</span></code> will be expected to store its result
indirectly into an address passed in an implicit parameter.  There&#8217;s
really just no reasonable alternative when working with a value of
arbitrary type:</p>
<ul class="simple">
<li>We don&#8217;t want to generate a different copy of <code class="docutils literal"><span class="pre">generateArray</span></code> for
every type <code class="docutils literal"><span class="pre">T</span></code>.</li>
<li>We don&#8217;t want to give every type in the language a common
representation.</li>
<li>We don&#8217;t want to dynamically construct a call to <code class="docutils literal"><span class="pre">generator</span></code>
depending on the type <code class="docutils literal"><span class="pre">T</span></code>.</li>
</ul>
<p>But we also don&#8217;t want the existence of the generic system to force
inefficiencies on non-generic code.  For example, we&#8217;d like a function
of type <code class="docutils literal"><span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">Int</span></code> to be able to return its result directly; and
yet, <code class="docutils literal"><span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">Int</span></code> is a valid substitution of <code class="docutils literal"><span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">T</span></code>, and a
caller of <code class="docutils literal"><span class="pre">generateArray&lt;Int&gt;</span></code> should be able to pass an arbitrary
<code class="docutils literal"><span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">Int</span></code> in as the generator.</p>
<p>Therefore, the representation of a formal type in a generic context
may differ from the representation of a substitution of that formal type.
We call such differences <em>abstraction differences</em>.</p>
<p>SIL&#8217;s type system is designed to make abstraction differences always
result in differences between SIL types.  The goal is that a properly-
abstracted value should be correctly usable at any level of substitution.</p>
<p>In order to achieve this, the formal type of a generic entity should
always be lowered using the abstraction pattern of its unsubstituted
formal type.  For example, consider the following generic type:</p>
<div class="highlight-python"><div class="highlight"><pre>struct Generator&lt;T&gt; {
  var fn : () -&gt; T
}
var intGen : Generator&lt;Int&gt;
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">intGen.fn</span></code> has the substituted formal type <code class="docutils literal"><span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">Int</span></code>, which
would normally lower to the type <code class="docutils literal"><span class="pre">&#64;callee_owned</span> <span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">Int</span></code>, i.e.
returning its result directly.  But if that type is properly lowered
with the pattern of its unsubstituted type <code class="docutils literal"><span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">T</span></code>, it becomes
<code class="docutils literal"><span class="pre">&#64;callee_owned</span> <span class="pre">(&#64;out</span> <span class="pre">Int)</span> <span class="pre">-&gt;</span> <span class="pre">()</span></code>.</p>
<p>When a type is lowered using the abstraction pattern of an
unrestricted type, it is lowered as if the pattern were replaced with
a type sharing the same structure but replacing all materializable
types with fresh type variables.</p>
<p>For example, if <code class="docutils literal"><span class="pre">g</span></code> has type <code class="docutils literal"><span class="pre">Generator&lt;(Int,Int)</span> <span class="pre">-&gt;</span> <span class="pre">Float&gt;</span></code>, <code class="docutils literal"><span class="pre">g.fn</span></code> is
lowered using the pattern <code class="docutils literal"><span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">T</span></code>, which eventually causes <code class="docutils literal"><span class="pre">(Int,Int)</span>
<span class="pre">-&gt;</span> <span class="pre">Float</span></code> to be lowered using the pattern <code class="docutils literal"><span class="pre">T</span></code>, which is the same as
lowering it with the pattern <code class="docutils literal"><span class="pre">U</span> <span class="pre">-&gt;</span> <span class="pre">V</span></code>; the result is that <code class="docutils literal"><span class="pre">g.fn</span></code>
has the following lowered type:</p>
<div class="highlight-python"><div class="highlight"><pre>@callee_owned () -&gt; @owned @callee_owned (@out Float, @in (Int,Int)) -&gt; ()``.
</pre></div>
</div>
<p>As another example, suppose that <code class="docutils literal"><span class="pre">h</span></code> has type
<code class="docutils literal"><span class="pre">Generator&lt;(Int,</span> <span class="pre">&#64;inout</span> <span class="pre">Int)</span> <span class="pre">-&gt;</span> <span class="pre">Float&gt;</span></code>.  Neither <code class="docutils literal"><span class="pre">(Int,</span> <span class="pre">&#64;inout</span> <span class="pre">Int)</span></code>
nor <code class="docutils literal"><span class="pre">&#64;inout</span> <span class="pre">Int</span></code> are potential results of substitution because they
aren&#8217;t materializable, so <code class="docutils literal"><span class="pre">h.fn</span></code> has the following lowered type:</p>
<div class="highlight-python"><div class="highlight"><pre>@callee_owned () -&gt; @owned @callee_owned (@out Float, @in Int, @inout Int)
</pre></div>
</div>
<p>This system has the property that abstraction patterns are preserved
through repeated substitutions.  That is, you can consider a lowered
type to encode an abstraction pattern; lowering <code class="docutils literal"><span class="pre">T</span></code> by <code class="docutils literal"><span class="pre">R</span></code> is
equivalent to lowering <code class="docutils literal"><span class="pre">T</span></code> by (<code class="docutils literal"><span class="pre">S</span></code> lowered by <code class="docutils literal"><span class="pre">R</span></code>).</p>
<p>SILGen has procedures for converting values between abstraction
patterns.</p>
<p>At present, only function and tuple types are changed by abstraction
differences.</p>
</div>
<div class="section" id="legal-sil-types">
<h4><a class="toc-backref" href="#id13">Legal SIL Types</a><a class="headerlink" href="#legal-sil-types" title="Permalink to this headline">¶</a></h4>
<p>The type of a value in SIL shall be:</p>
<ul class="simple">
<li>a loadable legal SIL type, <code class="docutils literal"><span class="pre">$T</span></code>,</li>
<li>the address of a legal SIL type, <code class="docutils literal"><span class="pre">$*T</span></code>, or</li>
<li>the address of local storage of a legal SIL type, <code class="docutils literal"><span class="pre">$*&#64;local_storage</span> <span class="pre">T</span></code>.</li>
</ul>
<p>A type <code class="docutils literal"><span class="pre">T</span></code> is a <em>legal SIL type</em> if:</p>
<ul class="simple">
<li>it is a function type which satisfies the constraints (below) on
function types in SIL,</li>
<li>it is a tuple type whose element types are legal SIL types,</li>
<li>it is a legal Swift type that is not a function, tuple, or l-value type, or</li>
<li>it is a <code class="docutils literal"><span class="pre">&#64;box</span></code> containing a legal SIL type.</li>
</ul>
<p>Note that types in other recursive positions in the type grammar are
still formal types.  For example, the instance type of a metatype or
the type arguments of a generic type are still formal Swift types, not
lowered SIL types.</p>
</div>
<div class="section" id="address-types">
<h4><a class="toc-backref" href="#id14">Address Types</a><a class="headerlink" href="#address-types" title="Permalink to this headline">¶</a></h4>
<p>The <em>address of T</em> <code class="docutils literal"><span class="pre">$*T</span></code> is a pointer to memory containing a value
of any reference or value type <code class="docutils literal"><span class="pre">$T</span></code>.  This can be an internal
pointer into a data structure. Addresses of loadable types can be
loaded and stored to access values of those types.</p>
<p>Addresses of address-only types (see below) can only be used with
instructions that manipulate their operands indirectly by address, such
as <code class="docutils literal"><span class="pre">copy_addr</span></code> or <code class="docutils literal"><span class="pre">destroy_addr</span></code>, or as arguments to functions.
It is illegal to have a value of type <code class="docutils literal"><span class="pre">$T</span></code> if <code class="docutils literal"><span class="pre">T</span></code> is address-only.</p>
<p>Addresses are not reference-counted pointers like class values are. They
cannot be retained or released.</p>
<p>Address types are not <em>first-class</em>: they cannot appear in recursive
positions in type expressions.  For example, the type <code class="docutils literal"><span class="pre">$**T</span></code> is not
a legal type.</p>
<p>The address of an address cannot be directly taken. <code class="docutils literal"><span class="pre">$**T</span></code> is not a representable
type. Values of address type thus cannot be allocated, loaded, or stored
(though addresses can of course be loaded from and stored to).</p>
<p>Addresses can be passed as arguments to functions if the corresponding
parameter is indirect.  They cannot be returned.</p>
</div>
<div class="section" id="local-storage-types">
<h4><a class="toc-backref" href="#id15">Local Storage Types</a><a class="headerlink" href="#local-storage-types" title="Permalink to this headline">¶</a></h4>
<p>The <em>address of local storage for T</em> <code class="docutils literal"><span class="pre">$*&#64;local_storage</span> <span class="pre">T</span></code> is a
handle to a stack allocation of a variable of type <code class="docutils literal"><span class="pre">$T</span></code>.</p>
<p>For many types, the handle for a stack allocation is simply the
allocated address itself.  However, if a type is runtime-sized, the
compiler must emit code to potentially dynamically allocate memory.
SIL abstracts over such differences by using values of local-storage
type as the first result of <code class="docutils literal"><span class="pre">alloc_stack</span></code> and the operand of
<code class="docutils literal"><span class="pre">dealloc_stack</span></code>.</p>
<p>Local-storage address types are not <em>first-class</em> in the same sense
that address types are not first-class.</p>
</div>
<div class="section" id="box-types">
<h4><a class="toc-backref" href="#id16">Box Types</a><a class="headerlink" href="#box-types" title="Permalink to this headline">¶</a></h4>
<p>Captured local variables and the payloads of <code class="docutils literal"><span class="pre">indirect</span></code> value types are stored
on the heap. The type <code class="docutils literal"><span class="pre">&#64;box</span> <span class="pre">T</span></code> is a reference-counted type that references
a box containing a mutable value of type <code class="docutils literal"><span class="pre">T</span></code>. Boxes always use Swift-native
reference counting, so they can be queried for uniqueness and cast to the
<code class="docutils literal"><span class="pre">Builtin.NativeObject</span></code> type.</p>
</div>
<div class="section" id="function-types">
<h4><a class="toc-backref" href="#id17">Function Types</a><a class="headerlink" href="#function-types" title="Permalink to this headline">¶</a></h4>
<p>Function types in SIL are different from function types in Swift in a
number of ways:</p>
<ul>
<li><p class="first">A SIL function type may be generic.  For example, accessing a
generic function with <code class="docutils literal"><span class="pre">function_ref</span></code> will give a value of
generic function type.</p>
</li>
<li><p class="first">A SIL function type declares its conventional treatment of its
context value:</p>
<ul class="simple">
<li>If it is <code class="docutils literal"><span class="pre">&#64;thin</span></code>, the function requires no context value.</li>
<li>If it is <code class="docutils literal"><span class="pre">&#64;callee_owned</span></code>, the context value is treated as an
owned direct parameter.</li>
<li>If it is <code class="docutils literal"><span class="pre">&#64;callee_guaranteed</span></code>, the context value is treated as
a guaranteed direct parameter.</li>
<li>Otherwise, the context value is treated as an unowned direct
parameter.</li>
</ul>
</li>
<li><p class="first">A SIL function type declares the conventions for its parameters,
including any implicit out-parameters.  The parameters are written
as an unlabelled tuple; the elements of that tuple must be legal SIL
types, optionally decorated with one of the following convention
attributes.</p>
<p>The value of an indirect parameter has type <code class="docutils literal"><span class="pre">*T</span></code>; the value of a
direct parameter has type <code class="docutils literal"><span class="pre">T</span></code>.</p>
<ul class="simple">
<li>An <code class="docutils literal"><span class="pre">&#64;in</span></code> parameter is indirect.  The address must be of an
initialized object; the function is responsible for destroying
the value held there.</li>
<li>An <code class="docutils literal"><span class="pre">&#64;inout</span></code> parameter is indirect.  The address must be of an
initialized object. The memory must remain initialized for the duration
of the call until the function returns. The function may mutate the
pointee, and furthermore may weakly assume that there are no aliasing
reads from or writes to the argument, though must preserve a valid
value at the argument so that well-ordered aliasing violations do not
compromise memory safety. This allows for optimizations such as local
load and store propagation, introduction or elimination of temporary
copies, and promotion of the <code class="docutils literal"><span class="pre">&#64;inout</span></code> parameter to an <code class="docutils literal"><span class="pre">&#64;owned</span></code> direct
parameter and result pair, but does not admit &#8220;take&#8221; optimization out
of the parameter or other optimization that would leave memory in an
uninitialized state.</li>
<li>An <code class="docutils literal"><span class="pre">&#64;inout_aliasable</span></code> parameter is indirect. The address must be of an
initialized object. The memory must remain initialized for the duration
of the call until the function returns. The function may mutate the
pointee, and must assume that other aliases may mutate it as well. These
aliases however can be assumed to be well-typed and well-ordered; ill-typed
accesses and data races to the parameter are still undefined.</li>
<li>An <code class="docutils literal"><span class="pre">&#64;out</span></code> parameter is indirect.  The address must be of an
uninitialized object; the function is responsible for initializing
a value there.  If there is an <code class="docutils literal"><span class="pre">&#64;out</span></code> parameter, it must be
the first parameter, and the direct result must be <code class="docutils literal"><span class="pre">()</span></code>.</li>
<li>An <code class="docutils literal"><span class="pre">&#64;owned</span></code> parameter is an owned direct parameter.</li>
<li>A <code class="docutils literal"><span class="pre">&#64;guaranteed</span></code> parameter is a guaranteed direct parameter.</li>
<li>An <code class="docutils literal"><span class="pre">&#64;in_guaranteed</span></code> parameter is indirect.  The address must be of an
initialized object; both the caller and callee promise not to mutate the
pointee, allowing the callee to read it.</li>
<li>Otherwise, the parameter is an unowned direct parameter.</li>
</ul>
</li>
<li><p class="first">A SIL function type declares the convention for its direct result.
The result must be a legal SIL type.</p>
<ul class="simple">
<li>An <code class="docutils literal"><span class="pre">&#64;owned</span></code> result is an owned direct result.</li>
<li>An <code class="docutils literal"><span class="pre">&#64;autoreleased</span></code> result is an autoreleased direct result.</li>
<li>Otherwise, the parameter is an unowned direct result.</li>
</ul>
</li>
</ul>
<p>A direct parameter or result of trivial type must always be unowned.</p>
<p>An owned direct parameter or result is transferred to the recipient,
which becomes responsible for destroying the value. This means that
the value is passed at +1.</p>
<p>An unowned direct parameter or result is instantaneously valid at the
point of transfer.  The recipient does not need to worry about race
conditions immediately destroying the value, but should copy it
(e.g. by <code class="docutils literal"><span class="pre">strong_retain</span></code>ing an object pointer) if the value will be
needed sooner rather than later.</p>
<p>A guaranteed direct parameter is like an unowned direct parameter
value, except that it is guaranteed by the caller to remain valid
throughout the execution of the call. This means that any
<code class="docutils literal"><span class="pre">strong_retain</span></code>, <code class="docutils literal"><span class="pre">strong_release</span></code> pairs in the callee on the
argument can be eliminated.</p>
<p>An autoreleased direct result must have a type with a retainable
pointer representation.  Autoreleased results are nominally transferred
at +0, but the runtime takes steps to ensure that a +1 can be safely
transferred, and those steps require precise code-layout control.
Accordingly, the SIL pattern for an autoreleased convention looks exactly
like the SIL pattern for an owned convention, and the extra runtime
instrumentation is inserted on both sides when the SIL is lowered into
LLVM IR.  An autoreleased <code class="docutils literal"><span class="pre">apply</span></code> of a function that is defined with
an autoreleased result has the effect of a +1 transfer of the result.
An autoreleased <code class="docutils literal"><span class="pre">apply</span></code> of a function that is not defined with
an autoreleased result has the effect of performing a strong retain in
the caller.  A non-autoreleased <code class="docutils literal"><span class="pre">apply</span></code> of a function that is defined
with an autoreleased result has the effect of performing an
autorelease in the callee.</p>
<ul>
<li><p class="first">The &#64;noescape declaration attribute on Swift parameters (which is valid only
on parameters of function type, and is implied by the &#64;autoclosure attribute)
is turned into a &#64;noescape type attribute on SIL arguments.  &#64;noescape
indicates that the lifetime of the closure parameter will not be extended by
the callee (e.g. the pointer will not be stored in a global variable).  It
corresponds to the LLVM &#8220;nocapture&#8221; attribute in terms of semantics (but is
limited to only work with parameters of function type in Swift).</p>
</li>
<li><p class="first">SIL function types may provide an optional error result, written by
placing <code class="docutils literal"><span class="pre">&#64;error</span></code> on a result.  An error result is always
implicitly <code class="docutils literal"><span class="pre">&#64;owned</span></code>.  Only functions with a native calling
convention may have an error result.</p>
<p>A function with an error result cannot be called with <code class="docutils literal"><span class="pre">apply</span></code>.
It must be called with <code class="docutils literal"><span class="pre">try_apply</span></code>.
There is one exception to this rule: a function with an error result can be
called with <code class="docutils literal"><span class="pre">apply</span> <span class="pre">[nothrow]</span></code> if the compiler can prove that the function
does not actually throw.</p>
<p><code class="docutils literal"><span class="pre">return</span></code> produces a normal result of the function.  To return
an error result, use <code class="docutils literal"><span class="pre">throw</span></code>.</p>
<p>Type lowering lowers the <code class="docutils literal"><span class="pre">throws</span></code> annotation on formal function
types into more concrete error propagation:</p>
<ul class="simple">
<li>For native Swift functions, <code class="docutils literal"><span class="pre">throws</span></code> is turned into an error
result.</li>
<li>For non-native Swift functions, <code class="docutils literal"><span class="pre">throws</span></code> is turned in an
explicit error-handling mechanism based on the imported API.  The
importer only imports non-native methods and types as <code class="docutils literal"><span class="pre">throws</span></code>
when it is possible to do this automatically.</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="properties-of-types">
<h4><a class="toc-backref" href="#id18">Properties of Types</a><a class="headerlink" href="#properties-of-types" title="Permalink to this headline">¶</a></h4>
<p>SIL classifies types into additional subgroups based on ABI stability and
generic constraints:</p>
<ul>
<li><p class="first"><em>Loadable types</em> are types with a fully exposed concrete representation:</p>
<ul class="simple">
<li>Reference types</li>
<li>Builtin value types</li>
<li>Fragile struct types in which all element types are loadable</li>
<li>Tuple types in which all element types are loadable</li>
<li>Class protocol types</li>
<li>Archetypes constrained by a class protocol</li>
</ul>
<p>A <em>loadable aggregate type</em> is a tuple or struct type that is loadable.</p>
<p>A <em>trivial type</em> is a loadable type with trivial value semantics.
Values of trivial type can be loaded and stored without any retain or
release operations and do not need to be destroyed.</p>
</li>
<li><p class="first"><em>Runtime-sized types</em> are restricted value types for which the compiler
does not know the size of the type statically:</p>
<ul class="simple">
<li>Resilient value types</li>
<li>Fragile struct or tuple types that contain resilient types as elements at
any depth</li>
<li>Archetypes not constrained by a class protocol</li>
</ul>
</li>
<li><p class="first"><em>Address-only types</em> are restricted value types which cannot be
loaded or otherwise worked with as SSA values:</p>
<ul class="simple">
<li>Runtime-sized types</li>
<li>Non-class protocol types</li>
<li>&#64;weak types</li>
</ul>
<p>Values of address-only type (“address-only values”) must reside in
memory and can only be referenced in SIL by address. Addresses of
address-only values cannot be loaded from or stored to. SIL provides
special instructions for indirectly manipulating address-only
values, such as <code class="docutils literal"><span class="pre">copy_addr</span></code> and <code class="docutils literal"><span class="pre">destroy_addr</span></code>.</p>
</li>
</ul>
<p>Some additional meaningful categories of type:</p>
<ul class="simple">
<li>A <em>heap object reference</em> type is a type whose representation consists of a
single strong-reference-counted pointer. This includes all class types,
the <code class="docutils literal"><span class="pre">Builtin.ObjectPointer</span></code> and <code class="docutils literal"><span class="pre">Builtin.ObjCPointer</span></code> types, and
archetypes that conform to one or more class protocols.</li>
<li>A <em>reference type</em> is more general in that its low-level representation may
include additional global pointers alongside a strong-reference-counted
pointer. This includes all heap object reference types and adds
thick function types and protocol/protocol composition types that conform to
one or more class protocols. All reference types can be <code class="docutils literal"><span class="pre">retain</span></code>-ed and
<code class="docutils literal"><span class="pre">release</span></code>-d. Reference types also have <em>ownership semantics</em> for their
referenced heap object; see <a class="reference internal" href="#reference-counting">Reference Counting</a> below.</li>
<li>A type with <em>retainable pointer representation</em> is guaranteed to
be compatible (in the C sense) with the Objective-C <code class="docutils literal"><span class="pre">id</span></code> type.
The value at runtime may be <code class="docutils literal"><span class="pre">nil</span></code>.  This includes classes,
class metatypes, block functions, and class-bounded existentials with
only Objective-C-compatible protocol constraints, as well as one
level of <code class="docutils literal"><span class="pre">Optional</span></code> or <code class="docutils literal"><span class="pre">ImplicitlyUnwrappedOptional</span></code> applied to any of the
above.  Types with retainable pointer representation can be returned
via the <code class="docutils literal"><span class="pre">&#64;autoreleased</span></code> return convention.</li>
</ul>
<p>SILGen does not always map Swift function types one-to-one to SIL function
types. Function types are transformed in order to encode additional attributes:</p>
<ul>
<li><p class="first">The <strong>convention</strong> of the function, indicated by the</p>
<pre class="literal-block">
&#64;convention(<em>convention</em>)
</pre>
<p>attribute. This is similar to the language-level <code class="docutils literal"><span class="pre">&#64;convention</span></code>
attribute, though SIL extends the set of supported conventions with
additional distinctions not exposed at the language level:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">&#64;convention(thin)</span></code> indicates a &#8220;thin&#8221; function reference, which uses
the Swift calling convention with no special &#8220;self&#8221; or &#8220;context&#8221; parameters.</li>
<li><code class="docutils literal"><span class="pre">&#64;convention(thick)</span></code> indicates a &#8220;thick&#8221; function reference, which
uses the Swift calling convention and carries a reference-counted context
object used to represent captures or other state required by the function.</li>
<li><code class="docutils literal"><span class="pre">&#64;convention(block)</span></code> indicates an Objective-C compatible block reference.
The function value is represented as a reference to the block object,
which is an <code class="docutils literal"><span class="pre">id</span></code>-compatible Objective-C object that embeds its invocation
function within the object. The invocation function uses the C calling
convention.</li>
<li><code class="docutils literal"><span class="pre">&#64;convention(c)</span></code> indicates a C function reference. The function value
carries no context and uses the C calling convention.</li>
<li><code class="docutils literal"><span class="pre">&#64;convention(objc_method)</span></code> indicates an Objective-C method implementation.
The function uses the C calling convention, with the SIL-level <code class="docutils literal"><span class="pre">self</span></code>
parameter (by SIL convention mapped to the final formal parameter)
mapped to the <code class="docutils literal"><span class="pre">self</span></code> and <code class="docutils literal"><span class="pre">_cmd</span></code> arguments of the implementation.</li>
<li><code class="docutils literal"><span class="pre">&#64;convention(method)</span></code> indicates a Swift instance method implementation.
The function uses the Swift calling convention, using the special <code class="docutils literal"><span class="pre">self</span></code>
parameter.</li>
<li><code class="docutils literal"><span class="pre">&#64;convention(witness_method)</span></code> indicates a Swift protocol method
implementation. The function&#8217;s polymorphic convention is emitted in such
a way as to guarantee that it is polymorphic across all possible
implementors of the protocol.</li>
</ul>
</li>
<li><p class="first">The <strong>fully uncurried representation</strong> of the function type, with
all of the curried argument clauses flattened into a single argument
clause. For instance, a curried function <code class="docutils literal"><span class="pre">func</span> <span class="pre">foo(x:A)(y:B)</span> <span class="pre">-&gt;</span> <span class="pre">C</span></code>
might be emitted as a function of type <code class="docutils literal"><span class="pre">((y:B),</span> <span class="pre">(x:A))</span> <span class="pre">-&gt;</span> <span class="pre">C</span></code>.  The
exact representation depends on the function&#8217;s <a class="reference internal" href="#calling-convention">calling
convention</a>, which determines the exact ordering of currying
clauses.  Methods are treated as a form of curried function.</p>
</li>
</ul>
</div>
<div class="section" id="layout-compatible-types">
<h4><a class="toc-backref" href="#id19">Layout Compatible Types</a><a class="headerlink" href="#layout-compatible-types" title="Permalink to this headline">¶</a></h4>
<p>(This section applies only to Swift 1.0 and will hopefully be obviated in
future releases.)</p>
<p>SIL tries to be ignorant of the details of type layout, and low-level
bit-banging operations such as pointer casts are generally undefined. However,
as a concession to implementation convenience, some types are allowed to be
considered <strong>layout compatible</strong>. Type <code class="docutils literal"><span class="pre">T</span></code> is <em>layout compatible</em> with type
<code class="docutils literal"><span class="pre">U</span></code> iff:</p>
<ul class="simple">
<li>an address of type <code class="docutils literal"><span class="pre">$*U</span></code> can be cast by
<code class="docutils literal"><span class="pre">address_to_pointer</span></code>/<code class="docutils literal"><span class="pre">pointer_to_address</span></code> to <code class="docutils literal"><span class="pre">$*T</span></code> and a valid value
of type <code class="docutils literal"><span class="pre">T</span></code> can be loaded out (or indirectly used, if <code class="docutils literal"><span class="pre">T</span></code> is address-
only),</li>
<li>if <code class="docutils literal"><span class="pre">T</span></code> is a nontrivial type, then <code class="docutils literal"><span class="pre">retain_value</span></code>/<code class="docutils literal"><span class="pre">release_value</span></code> of
the loaded <code class="docutils literal"><span class="pre">T</span></code> value is equivalent to <code class="docutils literal"><span class="pre">retain_value</span></code>/<code class="docutils literal"><span class="pre">release_value</span></code> of
the original <code class="docutils literal"><span class="pre">U</span></code> value.</li>
</ul>
<p>This is not always a commutative relationship; <code class="docutils literal"><span class="pre">T</span></code> can be layout-compatible
with <code class="docutils literal"><span class="pre">U</span></code> whereas <code class="docutils literal"><span class="pre">U</span></code> is not layout-compatible with <code class="docutils literal"><span class="pre">T</span></code>. If the layout
compatible relationship does extend both ways, <code class="docutils literal"><span class="pre">T</span></code> and <code class="docutils literal"><span class="pre">U</span></code> are
<strong>commutatively layout compatible</strong>. It is however always transitive; if <code class="docutils literal"><span class="pre">T</span></code>
is layout-compatible with <code class="docutils literal"><span class="pre">U</span></code> and <code class="docutils literal"><span class="pre">U</span></code> is layout-compatible with <code class="docutils literal"><span class="pre">V</span></code>, then
<code class="docutils literal"><span class="pre">T</span></code> is layout-compatible with <code class="docutils literal"><span class="pre">V</span></code>. All types are layout-compatible with
themselves.</p>
<p>The following types are considered layout-compatible:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">Builtin.RawPointer</span></code> is commutatively layout compatible with all heap
object reference types, and <code class="docutils literal"><span class="pre">Optional</span></code> of heap object reference types.
(Note that <code class="docutils literal"><span class="pre">RawPointer</span></code> is a trivial type, so does not have ownership
semantics.)</li>
<li><code class="docutils literal"><span class="pre">Builtin.RawPointer</span></code> is commutatively layout compatible with
<code class="docutils literal"><span class="pre">Builtin.Word</span></code>.</li>
<li>Structs containing a single stored property are commutatively layout
compatible with the type of that property.</li>
<li>A heap object reference is commutatively layout compatible with any type
that can correctly reference the heap object. For instance, given a class
<code class="docutils literal"><span class="pre">B</span></code> and a derived class <code class="docutils literal"><span class="pre">D</span></code> inheriting from <code class="docutils literal"><span class="pre">B</span></code>, a value of
type <code class="docutils literal"><span class="pre">B</span></code> referencing an instance of type <code class="docutils literal"><span class="pre">D</span></code> is layout compatible with
both <code class="docutils literal"><span class="pre">B</span></code> and <code class="docutils literal"><span class="pre">D</span></code>, as well as <code class="docutils literal"><span class="pre">Builtin.NativeObject</span></code> and
<code class="docutils literal"><span class="pre">Builtin.UnknownObject</span></code>. It is not layout compatible with an unrelated class
type <code class="docutils literal"><span class="pre">E</span></code>.</li>
<li>For payloaded enums, the payload type of the first payloaded case is
layout-compatible with the enum (<em>not</em> commutatively).</li>
</ul>
</div>
</div>
<div class="section" id="values-and-operands">
<h3><a class="toc-backref" href="#id20">Values and Operands</a><a class="headerlink" href="#values-and-operands" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>sil-identifier ::= [A-Za-z_0-9]+
sil-value-name ::= &#39;%&#39; sil-identifier
sil-value ::= sil-value-name (&#39;#&#39; [0-9]+)?
sil-value ::= &#39;undef&#39;
sil-operand ::= sil-value &#39;:&#39; sil-type
</pre></div>
</div>
<p>SIL values are introduced with the <code class="docutils literal"><span class="pre">%</span></code> sigil and named by an
alphanumeric identifier, which references the instruction or basic block
argument that produces the value.  SIL values may also refer to the keyword
&#8216;undef&#8217;, which is a value of undefined contents.
In SIL, a single instruction may produce multiple values. Operands that refer
to multiple-value instructions choose the value by following the <code class="docutils literal"><span class="pre">%name</span></code> with
<code class="docutils literal"><span class="pre">#</span></code> and the index of the value. For example:</p>
<div class="highlight-python"><div class="highlight"><pre>// alloc_box produces two values--the refcounted pointer %box#0, and the
// value address %box#1
%box = alloc_box $Int64
// Refer to the refcounted pointer
strong_retain %box#0 : $@box Int64
// Refer to the address
store %value to %box#1 : $*Int64
</pre></div>
</div>
<p>Unlike LLVM IR, SIL instructions that take value operands <em>only</em> accept
value operands. References to literal constants, functions, global variables, or
other entities require specialized instructions such as <code class="docutils literal"><span class="pre">integer_literal</span></code>,
<code class="docutils literal"><span class="pre">function_ref</span></code>, <code class="docutils literal"><span class="pre">global_addr</span></code>, etc.</p>
</div>
<div class="section" id="functions">
<h3><a class="toc-backref" href="#id21">Functions</a><a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>decl ::= sil-function
sil-function ::= &#39;sil&#39; sil-linkage? sil-function-name &#39;:&#39; sil-type
                   &#39;{&#39; sil-basic-block+ &#39;}&#39;
sil-function-name ::= &#39;@&#39; [A-Za-z_0-9]+
</pre></div>
</div>
<p>SIL functions are defined with the <code class="docutils literal"><span class="pre">sil</span></code> keyword. SIL function names
are introduced with the <code class="docutils literal"><span class="pre">&#64;</span></code> sigil and named by an alphanumeric
identifier. This name will become the LLVM IR name for the function,
and is usually the mangled name of the originating Swift declaration.
The <code class="docutils literal"><span class="pre">sil</span></code> syntax declares the function&#8217;s name and SIL type, and
defines the body of the function inside braces. The declared type must
be a function type, which may be generic.</p>
</div>
<div class="section" id="basic-blocks">
<h3><a class="toc-backref" href="#id22">Basic Blocks</a><a class="headerlink" href="#basic-blocks" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>sil-basic-block ::= sil-label sil-instruction-def* sil-terminator
sil-label ::= sil-identifier (&#39;(&#39; sil-argument (&#39;,&#39; sil-argument)* &#39;)&#39;)? &#39;:&#39;
sil-argument ::= sil-value-name &#39;:&#39; sil-type

sil-instruction-def ::= (sil-value-name &#39;=&#39;)? sil-instruction
</pre></div>
</div>
<p>A function body consists of one or more basic blocks that correspond
to the nodes of the function&#8217;s control flow graph. Each basic block
contains one or more instructions and ends with a terminator
instruction. The function&#8217;s entry point is always the first basic
block in its body.</p>
<p>In SIL, basic blocks take arguments, which are used as an alternative to LLVM&#8217;s
phi nodes. Basic block arguments are bound by the branch from the predecessor
block:</p>
<div class="highlight-python"><div class="highlight"><pre>sil @iif : $(Builtin.Int1, Builtin.Int64, Builtin.Int64) -&gt; Builtin.Int64 {
bb0(%cond : $Builtin.Int1, %ifTrue : $Builtin.Int64, %ifFalse : $Builtin.Int64):
  cond_br %cond : $Builtin.Int1, then, else
then:
  br finish(%ifTrue : $Builtin.Int64)
else:
  br finish(%ifFalse : $Builtin.Int64)
finish(%result : $Builtin.Int64):
  return %result : $Builtin.Int64
}
</pre></div>
</div>
<p>Arguments to the entry point basic block, which has no predecessor,
are bound by the function&#8217;s caller:</p>
<div class="highlight-python"><div class="highlight"><pre>sil @foo : $(Int) -&gt; Int {
bb0(%x : $Int):
  %1 = return %x : $Int
}

sil @bar : $(Int, Int) -&gt; () {
bb0(%x : $Int, %y : $Int):
  %foo = function_ref @foo
  %1 = apply %foo(%x) : $(Int) -&gt; Int
  %2 = apply %foo(%y) : $(Int) -&gt; Int
  %3 = tuple ()
  %4 = return %3 : $()
}
</pre></div>
</div>
</div>
<div class="section" id="declaration-references">
<h3><a class="toc-backref" href="#id23">Declaration References</a><a class="headerlink" href="#declaration-references" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>sil-decl-ref ::= &#39;#&#39; sil-identifier (&#39;.&#39; sil-identifier)* sil-decl-subref?
sil-decl-subref ::= &#39;!&#39; sil-decl-subref-part (&#39;.&#39; sil-decl-uncurry-level)? (&#39;.&#39; sil-decl-lang)?
sil-decl-subref ::= &#39;!&#39; sil-decl-uncurry-level (&#39;.&#39; sil-decl-lang)?
sil-decl-subref ::= &#39;!&#39; sil-decl-lang
sil-decl-subref-part ::= &#39;getter&#39;
sil-decl-subref-part ::= &#39;setter&#39;
sil-decl-subref-part ::= &#39;allocator&#39;
sil-decl-subref-part ::= &#39;initializer&#39;
sil-decl-subref-part ::= &#39;enumelt&#39;
sil-decl-subref-part ::= &#39;destroyer&#39;
sil-decl-subref-part ::= &#39;deallocator&#39;
sil-decl-subref-part ::= &#39;globalaccessor&#39;
sil-decl-subref-part ::= &#39;ivardestroyer&#39;
sil-decl-subref-part ::= &#39;ivarinitializer&#39;
sil-decl-subref-part ::= &#39;defaultarg&#39; &#39;.&#39; [0-9]+
sil-decl-uncurry-level ::= [0-9]+
sil-decl-lang ::= &#39;foreign&#39;
</pre></div>
</div>
<p>Some SIL instructions need to reference Swift declarations directly. These
references are introduced with the <code class="docutils literal"><span class="pre">#</span></code> sigil followed by the fully qualified
name of the Swift declaration. Some Swift declarations are
decomposed into multiple entities at the SIL level. These are distinguished by
following the qualified name with <code class="docutils literal"><span class="pre">!</span></code> and one or more <code class="docutils literal"><span class="pre">.</span></code>-separated component
entity discriminators:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">getter</span></code>: the getter function for a <code class="docutils literal"><span class="pre">var</span></code> declaration</li>
<li><code class="docutils literal"><span class="pre">setter</span></code>:  the setter function for a <code class="docutils literal"><span class="pre">var</span></code> declaration</li>
<li><code class="docutils literal"><span class="pre">allocator</span></code>: a <code class="docutils literal"><span class="pre">struct</span></code> or <code class="docutils literal"><span class="pre">enum</span></code> constructor, or a <code class="docutils literal"><span class="pre">class</span></code>&#8216;s <em>allocating constructor</em></li>
<li><code class="docutils literal"><span class="pre">initializer</span></code>: a <code class="docutils literal"><span class="pre">class</span></code>&#8216;s <em>initializing constructor</em></li>
<li><code class="docutils literal"><span class="pre">enumelt</span></code>: a member of a <code class="docutils literal"><span class="pre">enum</span></code> type.</li>
<li><code class="docutils literal"><span class="pre">destroyer</span></code>: a class&#8217;s destroying destructor</li>
<li><code class="docutils literal"><span class="pre">deallocator</span></code>: a class&#8217;s deallocating destructor</li>
<li><code class="docutils literal"><span class="pre">globalaccessor</span></code>: the addressor function for a global variable</li>
<li><code class="docutils literal"><span class="pre">ivardestroyer</span></code>: a class&#8217;s ivar destroyer</li>
<li><code class="docutils literal"><span class="pre">ivarinitializer</span></code>: a class&#8217;s ivar initializer</li>
<li><code class="docutils literal"><span class="pre">defaultarg.</span></code><em>n</em>: the default argument-generating function for
the <em>n</em>-th argument of a Swift <code class="docutils literal"><span class="pre">func</span></code></li>
<li><code class="docutils literal"><span class="pre">foreign</span></code>: a specific entry point for C/objective-C interoperability</li>
</ul>
<p>Methods and curried function definitions in Swift also have multiple
&#8220;uncurry levels&#8221; in SIL, representing the function at each possible
partial application level. For a curried function declaration:</p>
<div class="highlight-python"><div class="highlight"><pre>// Module example
func foo(x:A)(y:B)(z:C) -&gt; D
</pre></div>
</div>
<p>The declaration references and types for the different uncurry levels are as
follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#example.foo!0 : $@thin (x:A) -&gt; (y:B) -&gt; (z:C) -&gt; D</span>
<span class="c">#example.foo!1 : $@thin ((y:B), (x:A)) -&gt; (z:C) -&gt; D</span>
<span class="c">#example.foo!2 : $@thin ((z:C), (y:B), (x:A)) -&gt; D</span>
</pre></div>
</div>
<p>The deepest uncurry level is referred to as the <strong>natural uncurry level</strong>. In
this specific example, the reference at the natural uncurry level is
<code class="docutils literal"><span class="pre">#example.foo!2</span></code>.  Note that the uncurried argument clauses are composed
right-to-left, as specified in the <a class="reference internal" href="#calling-convention">calling convention</a>. For uncurry levels
less than the uncurry level, the entry point itself is <code class="docutils literal"><span class="pre">&#64;thin</span></code> but returns a
thick function value carrying the partially applied arguments for its context.</p>
<p><a class="reference internal" href="#dynamic-dispatch">Dynamic dispatch</a> instructions such as <code class="docutils literal"><span class="pre">class</span> <span class="pre">method</span></code> require their method
declaration reference to be uncurried to at least uncurry level 1 (which applies
both the &#8220;self&#8221; argument and the method arguments), because uncurry level zero
represents the application of the method to its &#8220;self&#8221; argument, as in
<code class="docutils literal"><span class="pre">foo.method</span></code>, which is where the dynamic dispatch semantically occurs
in Swift.</p>
</div>
<div class="section" id="linkage">
<h3><a class="toc-backref" href="#id24">Linkage</a><a class="headerlink" href="#linkage" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>sil-linkage ::= &#39;public&#39;
sil-linkage ::= &#39;hidden&#39;
sil-linkage ::= &#39;shared&#39;
sil-linkage ::= &#39;private&#39;
sil-linkage ::= &#39;public_external&#39;
sil-linkage ::= &#39;hidden_external&#39;
</pre></div>
</div>
<p>A linkage specifier controls the situations in which two objects in
different SIL modules are <em>linked</em>, i.e. treated as the same object.</p>
<p>A linkage is <em>external</em> if it ends with the suffix <code class="docutils literal"><span class="pre">external</span></code>.  An
object must be a definition if its linkage is not external.</p>
<p>All functions, global variables, and witness tables have linkage.
The default linkage of a definition is <code class="docutils literal"><span class="pre">public</span></code>.  The default linkage of a
declaration is <code class="docutils literal"><span class="pre">public_external</span></code>.  (These may eventually change to <code class="docutils literal"><span class="pre">hidden</span></code>
and <code class="docutils literal"><span class="pre">hidden_external</span></code>, respectively.)</p>
<p>On a global variable, an external linkage is what indicates that the
variable is not a definition.  A variable lacking an explicit linkage
specifier is presumed a definition (and thus gets the default linkage
for definitions, <code class="docutils literal"><span class="pre">public</span></code>.)</p>
<div class="section" id="definition-of-the-linked-relation">
<h4><a class="toc-backref" href="#id25">Definition of the <em>linked</em> relation</a><a class="headerlink" href="#definition-of-the-linked-relation" title="Permalink to this headline">¶</a></h4>
<p>Two objects are linked if they have the same name and are mutually
visible:</p>
<blockquote>
<div><ul class="simple">
<li>An object with <code class="docutils literal"><span class="pre">public</span></code> or <code class="docutils literal"><span class="pre">public_external</span></code> linkage is always
visible.</li>
<li>An object with <code class="docutils literal"><span class="pre">hidden</span></code>, <code class="docutils literal"><span class="pre">hidden_external</span></code>, or <code class="docutils literal"><span class="pre">shared</span></code>
linkage is visible only to objects in the same Swift module.</li>
<li>An object with <code class="docutils literal"><span class="pre">private</span></code> linkage is visible only to objects in
the same SIL module.</li>
</ul>
</div></blockquote>
<p>Note that the <em>linked</em> relationship is an equivalence relation: it is
reflexive, symmetric, and transitive.</p>
</div>
<div class="section" id="requirements-on-linked-objects">
<h4><a class="toc-backref" href="#id26">Requirements on linked objects</a><a class="headerlink" href="#requirements-on-linked-objects" title="Permalink to this headline">¶</a></h4>
<p>If two objects are linked, they must have the same type.</p>
<p>If two objects are linked, they must have the same linkage, except:</p>
<blockquote>
<div><ul class="simple">
<li>A <code class="docutils literal"><span class="pre">public</span></code> object may be linked to a <code class="docutils literal"><span class="pre">public_external</span></code> object.</li>
<li>A <code class="docutils literal"><span class="pre">hidden</span></code> object may be linked to a <code class="docutils literal"><span class="pre">hidden_external</span></code> object.</li>
</ul>
</div></blockquote>
<p>If two objects are linked, at most one may be a definition, unless:</p>
<blockquote>
<div><ul class="simple">
<li>both objects have <code class="docutils literal"><span class="pre">shared</span></code> linkage or</li>
<li>at least one of the objects has an external linkage.</li>
</ul>
</div></blockquote>
<p>If two objects are linked, and both are definitions, then the
definitions must be semantically equivalent.  This equivalence may
exist only on the level of user-visible semantics of well-defined
code; it should not be taken to guarantee that the linked definitions
are exactly operationally equivalent.  For example, one definition of
a function might copy a value out of an address parameter, while
another may have had an analysis applied to prove that said value is
not needed.</p>
<p>If an object has any uses, then it must be linked to a definition
with non-external linkage.</p>
</div>
<div class="section" id="summary">
<h4><a class="toc-backref" href="#id27">Summary</a><a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">public</span></code> definitions are unique and visible everywhere in the
program.  In LLVM IR, they will be emitted with <code class="docutils literal"><span class="pre">external</span></code>
linkage and <code class="docutils literal"><span class="pre">default</span></code> visibility.</li>
<li><code class="docutils literal"><span class="pre">hidden</span></code> definitions are unique and visible only within the
current Swift module.  In LLVM IR, they will be emitted with
<code class="docutils literal"><span class="pre">external</span></code> linkage and <code class="docutils literal"><span class="pre">hidden</span></code> visibility.</li>
<li><code class="docutils literal"><span class="pre">private</span></code> definitions are unique and visible only within the
current SIL module.  In LLVM IR, they will be emitted with
<code class="docutils literal"><span class="pre">private</span></code> linkage.</li>
<li><code class="docutils literal"><span class="pre">shared</span></code> definitions are visible only within the current Swift
module.  They can be linked only with other <code class="docutils literal"><span class="pre">shared</span></code>
definitions, which must be equivalent; therefore, they only need
to be emitted if actually used.  In LLVM IR, they will be emitted
with <code class="docutils literal"><span class="pre">linkonce_odr</span></code> linkage and <code class="docutils literal"><span class="pre">hidden</span></code> visibility.</li>
<li><code class="docutils literal"><span class="pre">public_external</span></code> and <code class="docutils literal"><span class="pre">hidden_external</span></code> objects always have
visible definitions somewhere else.  If this object nonetheless
has a definition, it&#8217;s only for the benefit of optimization or
analysis.  In LLVM IR, declarations will have <code class="docutils literal"><span class="pre">external</span></code> linkage
and definitions (if actually emitted as definitions) will have
<code class="docutils literal"><span class="pre">available_externally</span></code> linkage.</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="vtables">
<h3><a class="toc-backref" href="#id28">VTables</a><a class="headerlink" href="#vtables" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>decl ::= sil-vtable
sil-vtable ::= &#39;sil_vtable&#39; identifier &#39;{&#39; sil-vtable-entry* &#39;}&#39;

sil-vtable-entry ::= sil-decl-ref &#39;:&#39; sil-function-name
</pre></div>
</div>
<p>SIL represents dynamic dispatch for class methods using the <a class="reference internal" href="#class-method">class_method</a>,
<a class="reference internal" href="#super-method">super_method</a>, and <a class="reference internal" href="#dynamic-method">dynamic_method</a> instructions. The potential destinations
for these dispatch operations are tracked in <code class="docutils literal"><span class="pre">sil_vtable</span></code> declarations for
every class type. The declaration contains a mapping from every method of the
class (including those inherited from its base class) to the SIL function that
implements the method for that class:</p>
<div class="highlight-python"><div class="highlight"><pre>class A {
  func foo()
  func bar()
  func bas()
}

sil @A_foo : $@thin (@owned A) -&gt; ()
sil @A_bar : $@thin (@owned A) -&gt; ()
sil @A_bas : $@thin (@owned A) -&gt; ()

sil_vtable A {
  #A.foo!1: @A_foo
  #A.bar!1: @A_bar
  #A.bas!1: @A_bas
}

class B : A {
  func bar()
}

sil @B_bar : $@thin (@owned B) -&gt; ()

sil_vtable B {
  #A.foo!1: @A_foo
  #A.bar!1: @B_bar
  #A.bas!1: @A_bas
}

class C : B {
  func bas()
}

sil @C_bas : $@thin (@owned C) -&gt; ()

sil_vtable C {
  #A.foo!1: @A_foo
  #A.bar!1: @B_bar
  #A.bas!1: @C_bas
}
</pre></div>
</div>
<p>Note that the declaration reference in the vtable is to the least-derived method
visible through that class (in the example above, <code class="docutils literal"><span class="pre">B</span></code>&#8216;s vtable references
<code class="docutils literal"><span class="pre">A.bar</span></code> and not <code class="docutils literal"><span class="pre">B.bar</span></code>, and <code class="docutils literal"><span class="pre">C</span></code>&#8216;s vtable references <code class="docutils literal"><span class="pre">A.bas</span></code> and not
<code class="docutils literal"><span class="pre">C.bas</span></code>). The Swift AST maintains override relationships between declarations
that can be used to look up overridden methods in the SIL vtable for a derived
class (such as <code class="docutils literal"><span class="pre">C.bas</span></code> in <code class="docutils literal"><span class="pre">C</span></code>&#8216;s vtable).</p>
</div>
<div class="section" id="witness-tables">
<h3><a class="toc-backref" href="#id29">Witness Tables</a><a class="headerlink" href="#witness-tables" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>decl ::= sil-witness-table
sil-witness-table ::= &#39;sil_witness_table&#39; sil-linkage?
                      normal-protocol-conformance &#39;{&#39; sil-witness-entry* &#39;}&#39;
</pre></div>
</div>
<p>SIL encodes the information needed for dynamic dispatch of generic types into
witness tables. This information is used to produce runtime dispatch tables when
generating binary code. It can also be used by SIL optimizations to specialize
generic functions. A witness table is emitted for every declared explicit
conformance. Generic types share one generic witness table for all of their
instances. Derived classes inherit the witness tables of their base class.</p>
<div class="highlight-python"><div class="highlight"><pre>protocol-conformance ::= normal-protocol-conformance
protocol-conformance ::= &#39;inherit&#39; &#39;(&#39; protocol-conformance &#39;)&#39;
protocol-conformance ::= &#39;specialize&#39; &#39;&lt;&#39; substitution* &#39;&gt;&#39;
                         &#39;(&#39; protocol-conformance &#39;)&#39;
protocol-conformance ::= &#39;dependent&#39;
normal-protocol-conformance ::= identifier &#39;:&#39; identifier &#39;module&#39; identifier
</pre></div>
</div>
<p>Witness tables are keyed by <em>protocol conformance</em>, which is a unique identifier
for a concrete type&#8217;s conformance to a protocol.</p>
<ul class="simple">
<li>A <em>normal protocol conformance</em>
names a (potentially unbound generic) type, the protocol it conforms to, and
the module in which the type or extension declaration that provides the
conformance appears. These correspond 1:1 to protocol conformance declarations
in the source code.</li>
<li>If a derived class conforms to a protocol through inheritance from its base
class, this is represented by an <em>inherited protocol conformance</em>, which
simply references the protocol conformance for the base class.</li>
<li>If an instance of a generic type conforms to a protocol, it does so with a
<em>specialized conformance</em>, which provides the generic parameter bindings
to the normal conformance, which should be for a generic type.</li>
</ul>
<p>Witness tables are only directly associated with normal conformances.
Inherited and specialized conformances indirectly reference the witness table of
the underlying normal conformance.</p>
<div class="highlight-python"><div class="highlight"><pre>sil-witness-entry ::= &#39;base_protocol&#39; identifier &#39;:&#39; protocol-conformance
sil-witness-entry ::= &#39;method&#39; sil-decl-ref &#39;:&#39; sil-function-name
sil-witness-entry ::= &#39;associated_type&#39; identifier
sil-witness-entry ::= &#39;associated_type_protocol&#39;
                      &#39;(&#39; identifier &#39;:&#39; identifier &#39;)&#39; &#39;:&#39; protocol-conformance
</pre></div>
</div>
<p>Witness tables consist of the following entries:</p>
<ul class="simple">
<li><em>Base protocol entries</em> provide references to the protocol conformances that
satisfy the witnessed protocols&#8217; inherited protocols.</li>
<li><em>Method entries</em> map a method requirement of the protocol to a SIL function
that implements that method for the witness type. One method entry must exist
for every required method of the witnessed protocol.</li>
<li><em>Associated type entries</em> map an associated type requirement of the protocol
to the type that satisfies that requirement for the witness type. Note that
the witness type is a source-level Swift type and not a SIL type. One
associated type entry must exist for every required associated type of the
witnessed protocol.</li>
<li><em>Associated type protocol entries</em> map a protocol requirement on an associated
type to the protocol conformance that satisfies that requirement for the
associated type.</li>
</ul>
</div>
<div class="section" id="global-variables">
<h3><a class="toc-backref" href="#id30">Global Variables</a><a class="headerlink" href="#global-variables" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>decl ::= sil-global-variable
sil-global-variable ::= &#39;sil_global&#39; sil-linkage identifier &#39;:&#39; sil-type
</pre></div>
</div>
<p>SIL representation of a global variable.</p>
<p>FIXME: to be written.</p>
</div>
</div>
<div class="section" id="dataflow-errors">
<h2><a class="toc-backref" href="#id31">Dataflow Errors</a><a class="headerlink" href="#dataflow-errors" title="Permalink to this headline">¶</a></h2>
<p><em>Dataflow errors</em> may exist in raw SIL. Swift&#8217;s semantics defines these
conditions as errors, so they must be diagnosed by diagnostic
passes and must not exist in canonical SIL.</p>
<div class="section" id="definitive-initialization">
<h3><a class="toc-backref" href="#id32">Definitive Initialization</a><a class="headerlink" href="#definitive-initialization" title="Permalink to this headline">¶</a></h3>
<p>Swift requires that all local variables be initialized before use. In
constructors, all instance variables of a struct, enum, or class type must
be initialized before the object is used and before the constructor is returned
from.</p>
</div>
<div class="section" id="unreachable-control-flow">
<h3><a class="toc-backref" href="#id33">Unreachable Control Flow</a><a class="headerlink" href="#unreachable-control-flow" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">unreachable</span></code> terminator is emitted in raw SIL to mark incorrect control
flow, such as a non-<code class="docutils literal"><span class="pre">Void</span></code> function failing to <code class="docutils literal"><span class="pre">return</span></code> a value, or a
<code class="docutils literal"><span class="pre">switch</span></code> statement failing to cover all possible values of its subject.
The guaranteed dead code elimination pass can eliminate truly unreachable
basic blocks, or <code class="docutils literal"><span class="pre">unreachable</span></code> instructions may be dominated by applications
of <code class="docutils literal"><span class="pre">&#64;noreturn</span></code> functions. An <code class="docutils literal"><span class="pre">unreachable</span></code> instruction that survives
guaranteed DCE and is not immediately preceded by a <code class="docutils literal"><span class="pre">&#64;noreturn</span></code>
application is a dataflow error.</p>
</div>
</div>
<div class="section" id="runtime-failure">
<h2><a class="toc-backref" href="#id34">Runtime Failure</a><a class="headerlink" href="#runtime-failure" title="Permalink to this headline">¶</a></h2>
<p>Some operations, such as failed unconditional <a class="reference internal" href="#checked-conversions">checked conversions</a> or the
<code class="docutils literal"><span class="pre">Builtin.trap</span></code> compiler builtin, cause a <em>runtime failure</em>, which
unconditionally terminates the current actor. If it can be proven that a
runtime failure will occur or did occur, runtime failures may be reordered so
long as they remain well-ordered relative to operations external to the actor
or the program as a whole. For instance, with overflow checking on integer
arithmetic enabled, a simple <code class="docutils literal"><span class="pre">for</span></code> loop that reads inputs in from one or more
arrays and writes outputs to another array, all local
to the current actor, may cause runtime failure in the update operations:</p>
<div class="highlight-python"><div class="highlight"><pre>// Given unknown start and end values, this loop may overflow
for var i = unknownStartValue; i != unknownEndValue; ++i {
  ...
}
</pre></div>
</div>
<p>It is permitted to hoist the overflow check and associated runtime failure out
of the loop itself and check the bounds of the loop prior to entering it, so
long as the loop body has no observable effect outside of the current actor.</p>
</div>
<div class="section" id="undefined-behavior">
<h2><a class="toc-backref" href="#id35">Undefined Behavior</a><a class="headerlink" href="#undefined-behavior" title="Permalink to this headline">¶</a></h2>
<p>Incorrect use of some operations is <em>undefined behavior</em>, such as invalid
unchecked casts involving <code class="docutils literal"><span class="pre">Builtin.RawPointer</span></code> types, or use of compiler
builtins that lower to LLVM instructions with undefined behavior at the LLVM
level. A SIL program with undefined behavior is meaningless, much like undefined
behavior in C, and has no predictable semantics. Undefined behavior should not
be triggered by valid SIL emitted by a correct Swift program using a correct
standard library, but cannot in all cases be diagnosed or verified at the SIL
level.</p>
</div>
<div class="section" id="calling-convention">
<h2><a class="toc-backref" href="#id36">Calling Convention</a><a class="headerlink" href="#calling-convention" title="Permalink to this headline">¶</a></h2>
<p>This section describes how Swift functions are emitted in SIL.</p>
<div class="section" id="swift-calling-convention-cc-swift">
<h3><a class="toc-backref" href="#id37">Swift Calling Convention &#64;cc(swift)</a><a class="headerlink" href="#swift-calling-convention-cc-swift" title="Permalink to this headline">¶</a></h3>
<p>The Swift calling convention is the one used by default for native Swift
functions.</p>
<p>Tuples in the input type of the function are recursively destructured into
separate arguments, both in the entry point basic block of the callee, and
in the <code class="docutils literal"><span class="pre">apply</span></code> instructions used by callers:</p>
<div class="highlight-python"><div class="highlight"><pre>func foo(x:Int, y:Int)

sil @foo : $(x:Int, y:Int) -&gt; () {
entry(%x : $Int, %y : $Int):
  ...
}

func bar(x:Int, y:(Int, Int))

sil @bar : $(x:Int, y:(Int, Int)) -&gt; () {
entry(%x : $Int, %y0 : $Int, %y1 : $Int):
  ...
}

func call_foo_and_bar() {
  foo(1, 2)
  bar(4, (5, 6))
}

sil @call_foo_and_bar : $() -&gt; () {
entry:
  ...
  %foo = function_ref @foo : $(x:Int, y:Int) -&gt; ()
  %foo_result = apply %foo(%1, %2) : $(x:Int, y:Int) -&gt; ()
  ...
  %bar = function_ref @bar : $(x:Int, y:(Int, Int)) -&gt; ()
  %bar_result = apply %bar(%4, %5, %6) : $(x:Int, y:(Int, Int)) -&gt; ()
}
</pre></div>
</div>
<p>Calling a function with trivial value types as inputs and outputs
simply passes the arguments by value. This Swift function:</p>
<div class="highlight-python"><div class="highlight"><pre>func foo(x:Int, y:Float) -&gt; UnicodeScalar

foo(x, y)
</pre></div>
</div>
<p>gets called in SIL as:</p>
<div class="highlight-python"><div class="highlight"><pre>%foo = constant_ref $(Int, Float) -&gt; UnicodeScalar, @foo
%z = apply %foo(%x, %y) : $(Int, Float) -&gt; UnicodeScalar
</pre></div>
</div>
<div class="section" id="reference-counts">
<h4><a class="toc-backref" href="#id38">Reference Counts</a><a class="headerlink" href="#reference-counts" title="Permalink to this headline">¶</a></h4>
<p><em>NOTE</em> This section only is speaking in terms of rules of thumb. The
actual behavior of arguments with respect to arguments is defined by
the argument&#8217;s convention attribute (e.g. <code class="docutils literal"><span class="pre">&#64;owned</span></code>), not the
calling convention itself.</p>
<p>Reference type arguments are passed in at +1 retain count and consumed
by the callee. A reference type return value is returned at +1 and
consumed by the caller. Value types with reference type components
have their reference type components each retained and released the
same way. This Swift function:</p>
<div class="highlight-python"><div class="highlight"><pre>class A {}

func bar(x:A) -&gt; (Int, A) { ... }

bar(x)
</pre></div>
</div>
<p>gets called in SIL as:</p>
<div class="highlight-python"><div class="highlight"><pre>%bar = function_ref @bar : $(A) -&gt; (Int, A)
strong_retain %x : $A
%z = apply %bar(%x) : $(A) -&gt; (Int, A)
// ... use %z ...
%z_1 = tuple_extract %z : $(Int, A), 1
strong_release %z_1
</pre></div>
</div>
<p>When applying a thick function value as a callee, the function value is also
consumed at +1 retain count.</p>
</div>
<div class="section" id="address-only-types">
<h4><a class="toc-backref" href="#id39">Address-Only Types</a><a class="headerlink" href="#address-only-types" title="Permalink to this headline">¶</a></h4>
<p>For address-only arguments, the caller allocates a copy and passes the address
of the copy to the callee. The callee takes ownership of the copy and is
responsible for destroying or consuming the value, though the caller must still
deallocate the memory. For address-only return values, the
caller allocates an uninitialized buffer and passes its address as the first
argument to the callee. The callee must initialize this buffer before
returning. This Swift function:</p>
<div class="highlight-python"><div class="highlight"><pre> @API struct A {}

func bas(x:A, y:Int) -&gt; A { return x }

var z = bas(x, y)
// ... use z ...
</pre></div>
</div>
<p>gets called in SIL as:</p>
<div class="highlight-python"><div class="highlight"><pre>%bas = function_ref @bas : $(A, Int) -&gt; A
%z = alloc_stack $A
%x_arg = alloc_stack $A
copy_addr %x to [initialize] %x_arg : $*A
apply %bas(%z, %x_arg, %y) : $(A, Int) -&gt; A
dealloc_stack %x_arg : $*A // callee consumes %x.arg, caller deallocs
// ... use %z ...
destroy_addr %z : $*A
dealloc_stack stack %z : $*A
</pre></div>
</div>
<p>The implementation of <code class="docutils literal"><span class="pre">&#64;bas</span></code> is then responsible for consuming <code class="docutils literal"><span class="pre">%x_arg</span></code> and
initializing <code class="docutils literal"><span class="pre">%z</span></code>.</p>
<p>Tuple arguments are destructured regardless of the
address-only-ness of the tuple type. The destructured fields are passed
individually according to the above convention. This Swift function:</p>
<div class="highlight-python"><div class="highlight"><pre>@API struct A {}

func zim(x:Int, y:A, (z:Int, w:(A, Int)))

zim(x, y, (z, w))
</pre></div>
</div>
<p>gets called in SIL as:</p>
<div class="highlight-python"><div class="highlight"><pre>%zim = function_ref @zim : $(x:Int, y:A, (z:Int, w:(A, Int))) -&gt; ()
%y_arg = alloc_stack $A
copy_addr %y to [initialize] %y_arg : $*A
%w_0_addr = element_addr %w : $*(A, Int), 0
%w_0_arg = alloc_stack $A
copy_addr %w_0_addr to [initialize] %w_0_arg : $*A
%w_1_addr = element_addr %w : $*(A, Int), 1
%w_1 = load %w_1_addr : $*Int
apply %zim(%x, %y_arg, %z, %w_0_arg, %w_1) : $(x:Int, y:A, (z:Int, w:(A, Int))) -&gt; ()
dealloc_stack %w_0_arg
dealloc_stack %y_arg
</pre></div>
</div>
</div>
<div class="section" id="variadic-arguments">
<h4><a class="toc-backref" href="#id40">Variadic Arguments</a><a class="headerlink" href="#variadic-arguments" title="Permalink to this headline">¶</a></h4>
<p>Variadic arguments and tuple elements are packaged into an array and passed as
a single array argument. This Swift function:</p>
<div class="highlight-python"><div class="highlight"><pre>func zang(x:Int, (y:Int, z:Int...), v:Int, w:Int...)

zang(x, (y, z0, z1), v, w0, w1, w2)
</pre></div>
</div>
<p>gets called in SIL as:</p>
<div class="highlight-python"><div class="highlight"><pre>%zang = function_ref @zang : $(x:Int, (y:Int, z:Int...), v:Int, w:Int...) -&gt; ()
%zs = &lt;&lt;make array from %z1, %z2&gt;&gt;
%ws = &lt;&lt;make array from %w0, %w1, %w2&gt;&gt;
apply %zang(%x, %y, %zs, %v, %ws)  : $(x:Int, (y:Int, z:Int...), v:Int, w:Int...) -&gt; ()
</pre></div>
</div>
</div>
<div class="section" id="function-currying">
<h4><a class="toc-backref" href="#id41">Function Currying</a><a class="headerlink" href="#function-currying" title="Permalink to this headline">¶</a></h4>
<p>Curried function definitions in Swift emit multiple SIL entry points, one for
each &#8220;uncurry level&#8221; of the function. When a function is uncurried, its
outermost argument clauses are combined into a tuple in right-to-left order.
For the following declaration:</p>
<div class="highlight-python"><div class="highlight"><pre>func curried(x:A)(y:B)(z:C)(w:D) -&gt; Int {}
</pre></div>
</div>
<p>The types of the SIL entry points are as follows:</p>
<div class="highlight-python"><div class="highlight"><pre>sil @curried_0 : $(x:A) -&gt; (y:B) -&gt; (z:C) -&gt; (w:D) -&gt; Int { ... }
sil @curried_1 : $((y:B), (x:A)) -&gt; (z:C) -&gt; (w:D) -&gt; Int { ... }
sil @curried_2 : $((z:C), (y:B), (x:A)) -&gt; (w:D) -&gt; Int { ... }
sil @curried_3 : $((w:D), (z:C), (y:B), (x:A)) -&gt; Int { ... }
</pre></div>
</div>
</div>
<div class="section" id="inout-arguments">
<h4><a class="toc-backref" href="#id42">&#64;inout Arguments</a><a class="headerlink" href="#inout-arguments" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal"><span class="pre">&#64;inout</span></code> arguments are passed into the entry point by address. The callee
does not take ownership of the referenced memory. The referenced memory must
be initialized upon function entry and exit. If the <code class="docutils literal"><span class="pre">&#64;inout</span></code> argument
refers to a fragile physical variable, then the argument is the address of that
variable. If the <code class="docutils literal"><span class="pre">&#64;inout</span></code> argument refers to a logical property, then the
argument is the address of a caller-owned writeback buffer. It is the caller&#8217;s
responsibility to initialize the buffer by storing the result of the property
getter prior to calling the function and to write back to the property
on return by loading from the buffer and invoking the setter with the final
value. This Swift function:</p>
<div class="highlight-python"><div class="highlight"><pre>func inout(x:@inout Int) {
  x = 1
}
</pre></div>
</div>
<p>gets lowered to SIL as:</p>
<div class="highlight-python"><div class="highlight"><pre>sil @inout : $(@inout Int) -&gt; () {
entry(%x : $*Int):
  %1 = integer_literal 1 : $Int
  store %1 to %x
  return
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="swift-method-calling-convention-cc-method">
<h3><a class="toc-backref" href="#id43">Swift Method Calling Convention &#64;cc(method)</a><a class="headerlink" href="#swift-method-calling-convention-cc-method" title="Permalink to this headline">¶</a></h3>
<p>The method calling convention is currently identical to the freestanding
function convention. Methods are considered to be curried functions, taking
the &#8220;self&#8221; argument as their outer argument clause, and the method arguments
as the inner argument clause(s). When uncurried, the &#8220;self&#8221; argument is thus
passed last:</p>
<div class="highlight-python"><div class="highlight"><pre>struct Foo {
  func method(x:Int) -&gt; Int {}
}

sil @Foo_method_1 : $((x : Int), @inout Foo) -&gt; Int { ... }
</pre></div>
</div>
</div>
<div class="section" id="witness-method-calling-convention-cc-witness-method">
<h3><a class="toc-backref" href="#id44">Witness Method Calling Convention &#64;cc(witness_method)</a><a class="headerlink" href="#witness-method-calling-convention-cc-witness-method" title="Permalink to this headline">¶</a></h3>
<p>The witness method calling convention is used by protocol witness methods in
<a class="reference internal" href="#witness-tables">witness tables</a>. It is identical to the <code class="docutils literal"><span class="pre">method</span></code> calling convention
except that its handling of generic type parameters. For non-witness methods,
the machine-level convention for passing type parameter metadata may be
arbitrarily dependent on static aspects of the function signature, but because
witnesses must be polymorphically dispatchable on their <code class="docutils literal"><span class="pre">Self</span></code> type,
the <code class="docutils literal"><span class="pre">Self</span></code>-related metadata for a witness must be passed in a maximally
abstracted manner.</p>
</div>
<div class="section" id="c-calling-convention-cc-cdecl">
<h3><a class="toc-backref" href="#id45">C Calling Convention &#64;cc(cdecl)</a><a class="headerlink" href="#c-calling-convention-cc-cdecl" title="Permalink to this headline">¶</a></h3>
<p>In Swift&#8217;s C module importer, C types are always mapped to Swift types
considered trivial by SIL. SIL does not concern itself with platform
ABI requirements for indirect return, register vs. stack passing, etc.; C
function arguments and returns in SIL are always by value regardless of the
platform calling convention.</p>
<p>SIL (and therefore Swift) cannot currently invoke variadic C functions.</p>
</div>
<div class="section" id="objective-c-calling-convention-cc-objc-method">
<h3><a class="toc-backref" href="#id46">Objective-C Calling Convention &#64;cc(objc_method)</a><a class="headerlink" href="#objective-c-calling-convention-cc-objc-method" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id1">
<h4><a class="toc-backref" href="#id47">Reference Counts</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>Objective-C methods use the same argument and return value ownership rules as
ARC Objective-C. Selector families and the <code class="docutils literal"><span class="pre">ns_consumed</span></code>,
<code class="docutils literal"><span class="pre">ns_returns_retained</span></code>, etc. attributes from imported Objective-C definitions
are honored.</p>
<p>Applying a <code class="docutils literal"><span class="pre">&#64;convention(block)</span></code> value does not consume the block.</p>
</div>
<div class="section" id="method-currying">
<h4><a class="toc-backref" href="#id48">Method Currying</a><a class="headerlink" href="#method-currying" title="Permalink to this headline">¶</a></h4>
<p>In SIL, the &#8220;self&#8221; argument of an Objective-C method is uncurried to the last
argument of the uncurried type, just like a native Swift method:</p>
<div class="highlight-python"><div class="highlight"><pre>@objc class NSString {
  func stringByPaddingToLength(Int) withString(NSString) startingAtIndex(Int)
}

sil @NSString_stringByPaddingToLength_withString_startingAtIndex \
  : $((Int, NSString, Int), NSString)
</pre></div>
</div>
<p>That <code class="docutils literal"><span class="pre">self</span></code> is passed as the first argument at the IR level is abstracted
away in SIL, as is the existence of the <code class="docutils literal"><span class="pre">_cmd</span></code> selector argument.</p>
</div>
</div>
</div>
<div class="section" id="type-based-alias-analysis">
<h2><a class="toc-backref" href="#id49">Type Based Alias Analysis</a><a class="headerlink" href="#type-based-alias-analysis" title="Permalink to this headline">¶</a></h2>
<p>SIL supports two types of Type Based Alias Analysis (TBAA): Class TBAA and
Typed Access TBAA.</p>
<div class="section" id="class-tbaa">
<h3><a class="toc-backref" href="#id50">Class TBAA</a><a class="headerlink" href="#class-tbaa" title="Permalink to this headline">¶</a></h3>
<p>Class instances and other <em>heap object references</em> are pointers at the
implementation level, but unlike SIL addresses, they are first class values and
can be <code class="docutils literal"><span class="pre">capture</span></code>-d and alias. Swift, however, is memory-safe and statically
typed, so aliasing of classes is constrained by the type system as follows:</p>
<ul class="simple">
<li>A <code class="docutils literal"><span class="pre">Builtin.NativeObject</span></code> may alias any native Swift heap object,
including a Swift class instance, a box allocated by <code class="docutils literal"><span class="pre">alloc_box</span></code>,
or a thick function&#8217;s closure context.
It may not alias natively Objective-C class instances.</li>
<li>A <code class="docutils literal"><span class="pre">Builtin.UnknownObject</span></code> may alias any class instance, whether Swift or
Objective-C, but may not alias non-class-instance heap objects.</li>
<li>Two values of the same class type <code class="docutils literal"><span class="pre">$C</span></code> may alias. Two values of related
class type <code class="docutils literal"><span class="pre">$B</span></code> and <code class="docutils literal"><span class="pre">$D</span></code>, where there is a subclass relationship between
<code class="docutils literal"><span class="pre">$B</span></code> and <code class="docutils literal"><span class="pre">$D</span></code>, may alias. Two values of unrelated class types may not
alias. This includes different instantiations of a generic class type, such
as <code class="docutils literal"><span class="pre">$C&lt;Int&gt;</span></code> and <code class="docutils literal"><span class="pre">$C&lt;Float&gt;</span></code>, which currently may never alias.</li>
<li>Without whole-program visibility, values of archetype or protocol type must
be assumed to potentially alias any class instance. Even if it is locally
apparent that a class does not conform to that protocol, another component
may introduce a conformance by an extension. Similarly, a generic class
instance, such as <code class="docutils literal"><span class="pre">$C&lt;T&gt;</span></code> for archetype <code class="docutils literal"><span class="pre">T</span></code>, must be assumed to
potentially alias concrete instances of the generic type, such as
<code class="docutils literal"><span class="pre">$C&lt;Int&gt;</span></code>, because <code class="docutils literal"><span class="pre">Int</span></code> is a potential substitution for <code class="docutils literal"><span class="pre">T</span></code>.</li>
</ul>
</div>
<div class="section" id="typed-access-tbaa">
<h3><a class="toc-backref" href="#id51">Typed Access TBAA</a><a class="headerlink" href="#typed-access-tbaa" title="Permalink to this headline">¶</a></h3>
<p>Define a <em>typed access</em> of an address or reference as one of the following:</p>
<ul class="simple">
<li>Any instruction that performs a typed read or write operation upon the memory
at the given location (e.x. <code class="docutils literal"><span class="pre">load</span></code>, <code class="docutils literal"><span class="pre">store</span></code>).</li>
<li>Any instruction that yields a typed offset of the pointer by performing a
typed projection operation (e.x. <code class="docutils literal"><span class="pre">ref_element_addr</span></code>,
<code class="docutils literal"><span class="pre">tuple_element_addr</span></code>).</li>
</ul>
<p>It is undefined behavior to perform a typed access to an address or reference if
the stored object or referent is not an allocated object of the relevant type.</p>
<p>This allows the optimizer to assume that two addresses cannot alias if there
does not exist a substitution of archetypes that could cause one of the types to
be the type of a subobject of the other. Additionally, this applies to the types
of the values from which the addresses were derived, ignoring &#8220;blessed&#8221;
alias-introducing operations such as <code class="docutils literal"><span class="pre">pointer_to_address</span></code>, the <code class="docutils literal"><span class="pre">bitcast</span></code>
intrinsic, and the <code class="docutils literal"><span class="pre">inttoptr</span></code> intrinsic.</p>
</div>
</div>
<div class="section" id="value-dependence">
<h2><a class="toc-backref" href="#id52">Value Dependence</a><a class="headerlink" href="#value-dependence" title="Permalink to this headline">¶</a></h2>
<p>In general, analyses can assume that independent values are
independently assured of validity.  For example, a class method may
return a class reference:</p>
<div class="highlight-python"><div class="highlight"><pre>bb0(%0 : $MyClass):
  %1 = class_method %0 : $MyClass, #MyClass.foo!1
  %2 = apply %1(%0) : $@cc(method) @thin (@guaranteed MyClass) -&gt; @owned MyOtherClass
  // use of %2 goes here; no use of %1
  strong_release %2 : $MyOtherClass
  strong_release %1 : $MyClass
</pre></div>
</div>
<p>The optimizer is free to move the release of <code class="docutils literal"><span class="pre">%1</span></code> to immediately
after the call here, because <code class="docutils literal"><span class="pre">%2</span></code> can be assumed to be an
independently-managed value, and because Swift generally permits the
reordering of destructors.</p>
<p>However, some instructions do create values that are intrinsically
dependent on their operands.  For example, the result of
<code class="docutils literal"><span class="pre">ref_element_addr</span></code> will become a dangling pointer if the base is
released too soon.  This is captured by the concept of <em>value dependence</em>,
and any transformation which can reorder of destruction of a value
around another operation must remain conscious of it.</p>
<p>A value <code class="docutils literal"><span class="pre">%1</span></code> is said to be <em>value-dependent</em> on a value <code class="docutils literal"><span class="pre">%0</span></code> if:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">%1</span></code> is the result and <code class="docutils literal"><span class="pre">%0</span></code> is the first operand of one of the
following instructions:<ul>
<li><code class="docutils literal"><span class="pre">ref_element_addr</span></code></li>
<li><code class="docutils literal"><span class="pre">struct_element_addr</span></code></li>
<li><code class="docutils literal"><span class="pre">tuple_element_addr</span></code></li>
<li><code class="docutils literal"><span class="pre">unchecked_take_enum_data_addr</span></code></li>
<li><code class="docutils literal"><span class="pre">pointer_to_address</span></code></li>
<li><code class="docutils literal"><span class="pre">address_to_pointer</span></code></li>
<li><code class="docutils literal"><span class="pre">index_addr</span></code></li>
<li><code class="docutils literal"><span class="pre">index_raw_pointer</span></code></li>
<li>possibly some other conversions</li>
</ul>
</li>
<li><code class="docutils literal"><span class="pre">%1</span></code> is the result of <code class="docutils literal"><span class="pre">mark_dependence</span></code> and <code class="docutils literal"><span class="pre">%0</span></code> is either of
the operands.</li>
<li><code class="docutils literal"><span class="pre">%1</span></code> is the value address of an allocation instruction of which
<code class="docutils literal"><span class="pre">%0</span></code> is the local storage token or box reference.</li>
<li><code class="docutils literal"><span class="pre">%1</span></code> is the result of a <code class="docutils literal"><span class="pre">struct</span></code>, <code class="docutils literal"><span class="pre">tuple</span></code>, or <code class="docutils literal"><span class="pre">enum</span></code>
instruction and <code class="docutils literal"><span class="pre">%0</span></code> is an operand.</li>
<li><code class="docutils literal"><span class="pre">%1</span></code> is the result of projecting out a subobject of <code class="docutils literal"><span class="pre">%0</span></code>
with <code class="docutils literal"><span class="pre">tuple_extract</span></code>, <code class="docutils literal"><span class="pre">struct_extract</span></code>, <code class="docutils literal"><span class="pre">unchecked_enum_data</span></code>,
<code class="docutils literal"><span class="pre">select_enum</span></code>, or <code class="docutils literal"><span class="pre">select_enum_addr</span></code>.</li>
<li><code class="docutils literal"><span class="pre">%1</span></code> is the result of <code class="docutils literal"><span class="pre">select_value</span></code> and <code class="docutils literal"><span class="pre">%0</span></code> is one of the cases.</li>
<li><code class="docutils literal"><span class="pre">%1</span></code> is a basic block parameter and <code class="docutils literal"><span class="pre">%0</span></code> is the corresponding
argument from a branch to that block.</li>
<li><code class="docutils literal"><span class="pre">%1</span></code> is the result of a <code class="docutils literal"><span class="pre">load</span></code> from <code class="docutils literal"><span class="pre">%0</span></code>.  However, the value
dependence is cut after the first attempt to manage the value of
<code class="docutils literal"><span class="pre">%1</span></code>, e.g. by retaining it.</li>
<li>Transitivity: there exists a value <code class="docutils literal"><span class="pre">%2</span></code> which <code class="docutils literal"><span class="pre">%1</span></code> depends on
and which depends on <code class="docutils literal"><span class="pre">%0</span></code>.  However, transitivity does not apply
to different subobjects of a struct, tuple, or enum.</li>
</ul>
<p>Note, however, that an analysis is not required to track dependence
through memory.  Nor is it required to consider the possibility of
dependence being established &#8220;behind the scenes&#8221; by opaque code, such
as by a method returning an unsafe pointer to a class property.  The
dependence is required to be locally obvious in a function&#8217;s SIL
instructions.  Precautions must be taken against this either by SIL
generators (by using <code class="docutils literal"><span class="pre">mark_dependence</span></code> appropriately) or by the user
(by using the appropriate intrinsics and attributes with unsafe
language or library features).</p>
<p>Only certain types of SIL value can carry value-dependence:</p>
<ul class="simple">
<li>SIL address types</li>
<li>unmanaged pointer types:<ul>
<li><code class="docutils literal"><span class="pre">&#64;sil_unmanaged</span></code> types</li>
<li><code class="docutils literal"><span class="pre">Builtin.RawPointer</span></code></li>
<li>aggregates containing such a type, such as <code class="docutils literal"><span class="pre">UnsafePointer</span></code>,
possibly recursively</li>
</ul>
</li>
<li>non-trivial types (but they can be independently managed)</li>
</ul>
<p>This rule means that casting a pointer to an integer type breaks
value-dependence.  This restriction is necessary so that reading an
<code class="docutils literal"><span class="pre">Int</span></code> from a class doesn&#8217;t force the class to be kept around!
A class holding an unsafe reference to an object must use some
sort of unmanaged pointer type to do so.</p>
<p>This rule does not include generic or resilient value types which
might contain unmanaged pointer types.  Analyses are free to assume
that e.g. a <code class="docutils literal"><span class="pre">copy_addr</span></code> of a generic or resilient value type yields
an independently-managed value.  The extension of value dependence to
types containing obvious unmanaged pointer types is an affordance to
make the use of such types more convenient; it does not shift the
ultimate responsibility for assuring the safety of unsafe
language/library features away from the user.</p>
</div>
<div class="section" id="instruction-set">
<h2><a class="toc-backref" href="#id53">Instruction Set</a><a class="headerlink" href="#instruction-set" title="Permalink to this headline">¶</a></h2>
<div class="section" id="allocation-and-deallocation">
<h3><a class="toc-backref" href="#id54">Allocation and Deallocation</a><a class="headerlink" href="#allocation-and-deallocation" title="Permalink to this headline">¶</a></h3>
<p>These instructions allocate and deallocate memory.</p>
<div class="section" id="alloc-stack">
<h4><a class="toc-backref" href="#id55">alloc_stack</a><a class="headerlink" href="#alloc-stack" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;alloc_stack&#39; sil-type (&#39;,&#39; debug-var-attr)*

%1 = alloc_stack $T
// %1#0 has type $*@local_storage T
// %1#1 has type $*T
</pre></div>
</div>
<p>Allocates uninitialized memory that is sufficiently aligned on the stack
to contain a value of type <code class="docutils literal"><span class="pre">T</span></code>. The first result of the instruction
is a local-storage handle suitable for passing to <code class="docutils literal"><span class="pre">dealloc_stack</span></code>.
The second result of the instruction is the address of the allocated memory.</p>
<p><code class="docutils literal"><span class="pre">alloc_stack</span></code> marks the start of the lifetime of the value; the
allocation must be balanced with a <code class="docutils literal"><span class="pre">dealloc_stack</span></code> instruction to
mark the end of its lifetime. All <code class="docutils literal"><span class="pre">alloc_stack</span></code> allocations must be
deallocated prior to returning from a function. If a block has multiple
predecessors, the stack height and order of allocations must be consistent
coming from all predecessor blocks. <code class="docutils literal"><span class="pre">alloc_stack</span></code> allocations must be
deallocated in last-in, first-out stack order.</p>
<p>The memory is not retainable. To allocate a retainable box for a value
type, use <code class="docutils literal"><span class="pre">alloc_box</span></code>.</p>
</div>
<div class="section" id="alloc-ref">
<h4><a class="toc-backref" href="#id56">alloc_ref</a><a class="headerlink" href="#alloc-ref" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;alloc_ref&#39; (&#39;[&#39; &#39;objc&#39; &#39;]&#39;)? (&#39;[&#39; &#39;stack&#39; &#39;]&#39;)? sil-type

%1 = alloc_ref [stack] $T
// $T must be a reference type
// %1 has type $T
</pre></div>
</div>
<p>Allocates an object of reference type <code class="docutils literal"><span class="pre">T</span></code>. The object will be initialized
with retain count 1; its state will be otherwise uninitialized. The
optional <code class="docutils literal"><span class="pre">objc</span></code> attribute indicates that the object should be
allocated using Objective-C&#8217;s allocation methods (<code class="docutils literal"><span class="pre">+allocWithZone:</span></code>).
The optional <code class="docutils literal"><span class="pre">stack</span></code> attribute indicates that the object can be allocated
on the stack instead on the heap. In this case the instruction must have
balanced with a <code class="docutils literal"><span class="pre">dealloc_ref</span> <span class="pre">[stack]</span></code> instruction to mark the end of the
object&#8217;s lifetime.
Note that the <code class="docutils literal"><span class="pre">stack</span></code> attribute only specifies that stack allocation is
possible. The final decision on stack allocation is done during llvm IR
generation. This is because the decision also depends on the object size,
which is not necessarily known at SIL level.</p>
</div>
<div class="section" id="alloc-ref-dynamic">
<h4><a class="toc-backref" href="#id57">alloc_ref_dynamic</a><a class="headerlink" href="#alloc-ref-dynamic" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;alloc_ref_dynamic&#39; (&#39;[&#39; &#39;objc&#39; &#39;]&#39;)? sil-operand &#39;,&#39; sil-type

%1 = alloc_ref_dynamic %0 : $@thick T.Type, $T
%1 = alloc_ref_dynamic [objc] %0 : $@objc_metatype T.Type, $T
// $T must be a class type
// %1 has type $T
</pre></div>
</div>
<p>Allocates an object of class type <code class="docutils literal"><span class="pre">T</span></code> or a subclass thereof. The
dynamic type of the resulting object is specified via the metatype
value <code class="docutils literal"><span class="pre">%0</span></code>. The object will be initialized with retain count 1; its
state will be otherwise uninitialized. The optional <code class="docutils literal"><span class="pre">objc</span></code> attribute
indicates that the object should be allocated using Objective-C&#8217;s
allocation methods (<code class="docutils literal"><span class="pre">+allocWithZone:</span></code>).</p>
</div>
<div class="section" id="alloc-box">
<h4><a class="toc-backref" href="#id58">alloc_box</a><a class="headerlink" href="#alloc-box" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;alloc_box&#39; sil-type (&#39;,&#39; debug-var-attr)*

%1 = alloc_box $T
// %1 has two values:
//   %1#0 has type $@box T
//   %1#1 has type $*T
</pre></div>
</div>
<p>Allocates a reference-counted <code class="docutils literal"><span class="pre">&#64;box</span></code> on the heap large enough to hold a value
of type <code class="docutils literal"><span class="pre">T</span></code>, along with a retain count and any other metadata required by the
runtime.  The result of the instruction is a two-value operand; the first value
is the reference-counted <code class="docutils literal"><span class="pre">&#64;box</span></code> reference that owns the box, and the second
value is the address of the value inside the box.</p>
<p>The box will be initialized with a retain count of 1; the storage will be
uninitialized. The box owns the contained value, and releasing it to a retain
count of zero destroys the contained value as if by <code class="docutils literal"><span class="pre">destroy_addr</span></code>.
Releasing a box is undefined behavior if the box&#8217;s value is uninitialized.
To deallocate a box whose value has not been initialized, <code class="docutils literal"><span class="pre">dealloc_box</span></code>
should be used.</p>
</div>
<div class="section" id="alloc-value-buffer">
<h4><a class="toc-backref" href="#id59">alloc_value_buffer</a><a class="headerlink" href="#alloc-value-buffer" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;alloc_value_buffer&#39; sil-type &#39;in&#39; sil-operand

%1 = alloc_value_buffer $(Int, T) in %0 : $*Builtin.UnsafeValueBuffer
// The operand must have the exact type shown.
// The result has type $*(Int, T).
</pre></div>
</div>
<p>Given the address of an unallocated value buffer, allocate space in it
for a value of the given type.  This instruction has undefined
behavior if the value buffer is currently allocated.</p>
<p>The type operand must be a lowered object type.</p>
</div>
<div class="section" id="dealloc-stack">
<h4><a class="toc-backref" href="#id60">dealloc_stack</a><a class="headerlink" href="#dealloc-stack" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;dealloc_stack&#39; sil-operand

dealloc_stack %0 : $*@local_storage T
// %0 must be of a local-storage $*@local_storage T type
</pre></div>
</div>
<p>Deallocates memory previously allocated by <code class="docutils literal"><span class="pre">alloc_stack</span></code>. The
allocated value in memory must be uninitialized or destroyed prior to
being deallocated. This instruction marks the end of the lifetime for
the value created by the corresponding <code class="docutils literal"><span class="pre">alloc_stack</span></code> instruction. The operand
must be the <code class="docutils literal"><span class="pre">&#64;local_storage</span></code> of the shallowest live <code class="docutils literal"><span class="pre">alloc_stack</span></code>
allocation preceding the deallocation. In other words, deallocations must be
in last-in, first-out stack order.</p>
</div>
<div class="section" id="dealloc-box">
<h4><a class="toc-backref" href="#id61">dealloc_box</a><a class="headerlink" href="#dealloc-box" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;dealloc_box&#39; sil-operand

dealloc_box %0 : $@box T
</pre></div>
</div>
<p>Deallocates a box, bypassing the reference counting mechanism. The box
variable must have a retain count of one. The boxed type must match the
type passed to the corresponding <code class="docutils literal"><span class="pre">alloc_box</span></code> exactly, or else
undefined behavior results.</p>
<p>This does not destroy the boxed value. The contents of the
value must have been fully uninitialized or destroyed before
<code class="docutils literal"><span class="pre">dealloc_box</span></code> is applied.</p>
</div>
<div class="section" id="project-box">
<h4><a class="toc-backref" href="#id62">project_box</a><a class="headerlink" href="#project-box" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;project_box&#39; sil-operand

%1 = project_box %0 : $@box T

// %1 has type $*T
</pre></div>
</div>
<p>Given a <code class="docutils literal"><span class="pre">&#64;box</span> <span class="pre">T</span></code> reference, produces the address of the value inside the box.</p>
</div>
<div class="section" id="dealloc-ref">
<h4><a class="toc-backref" href="#id63">dealloc_ref</a><a class="headerlink" href="#dealloc-ref" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;dealloc_ref&#39; (&#39;[&#39; &#39;stack&#39; &#39;]&#39;)? sil-operand

dealloc_ref [stack] %0 : $T
// $T must be a class type
</pre></div>
</div>
<p>Deallocates an uninitialized class type instance, bypassing the reference
counting mechanism.</p>
<p>The type of the operand must match the allocated type exactly, or else
undefined behavior results.</p>
<p>The instance must have a retain count of one.</p>
<p>This does not destroy stored properties of the instance. The contents
of stored properties must be fully uninitialized at the time
<code class="docutils literal"><span class="pre">dealloc_ref</span></code> is applied.</p>
<p>The <code class="docutils literal"><span class="pre">stack</span></code> attribute indicates that the instruction is the balanced
deallocation of its operand which must be a <code class="docutils literal"><span class="pre">alloc_ref</span> <span class="pre">[stack]</span></code>.
In this case the instruction marks the end of the object&#8217;s lifetime but
has no other effect.</p>
</div>
<div class="section" id="dealloc-partial-ref">
<h4><a class="toc-backref" href="#id64">dealloc_partial_ref</a><a class="headerlink" href="#dealloc-partial-ref" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;dealloc_partial_ref&#39; sil-operand sil-metatype

dealloc_partial_ref %0 : $T, %1 : $U.Type
// $T must be a class type
// $T must be a subclass of U
</pre></div>
</div>
<p>Deallocates a partially-initialized class type instance, bypassing
the reference counting mechanism.</p>
<p>The type of the operand must be a supertype of the allocated type, or
else undefined behavior results.</p>
<p>The instance must have a retain count of one.</p>
<p>All stored properties in classes more derived than the given metatype
value must be initialized, and all other stored properties must be
uninitialized. The initialized stored properties are destroyed before
deallocating the memory for the instance.</p>
<p>This does not destroy the reference type instance. The contents of the
heap object must have been fully uninitialized or destroyed before
<code class="docutils literal"><span class="pre">dealloc_ref</span></code> is applied.</p>
</div>
<div class="section" id="dealloc-value-buffer">
<h4><a class="toc-backref" href="#id65">dealloc_value_buffer</a><a class="headerlink" href="#dealloc-value-buffer" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;dealloc_value_buffer&#39; sil-type &#39;in&#39; sil-operand

dealloc_value_buffer $(Int, T) in %0 : $*Builtin.UnsafeValueBuffer
// The operand must have the exact type shown.
</pre></div>
</div>
<p>Given the address of a value buffer, deallocate the storage in it.
This instruction has undefined behavior if the value buffer is not
currently allocated, or if it was allocated with a type other than the
type operand.</p>
<p>The type operand must be a lowered object type.</p>
</div>
<div class="section" id="project-value-buffer">
<h4><a class="toc-backref" href="#id66">project_value_buffer</a><a class="headerlink" href="#project-value-buffer" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;project_value_buffer&#39; sil-type &#39;in&#39; sil-operand

%1 = project_value_buffer $(Int, T) in %0 : $*Builtin.UnsafeValueBuffer
// The operand must have the exact type shown.
// The result has type $*(Int, T).
</pre></div>
</div>
<p>Given the address of a value buffer, return the address of the value
storage in it.  This instruction has undefined behavior if the value
buffer is not currently allocated, or if it was allocated with a type
other than the type operand.</p>
<p>The result is the same value as was originally returned by
<code class="docutils literal"><span class="pre">alloc_value_buffer</span></code>.</p>
<p>The type operand must be a lowered object type.</p>
</div>
</div>
<div class="section" id="debug-information">
<h3><a class="toc-backref" href="#id67">Debug Information</a><a class="headerlink" href="#debug-information" title="Permalink to this headline">¶</a></h3>
<p>Debug information is generally associated with allocations (alloc_stack or
alloc_box) by having a Decl node attached to the allocation with a SILLocation.
For declarations that have no allocation we have explicit instructions for
doing this.  This is used by &#8216;let&#8217; declarations, which bind a value to a name
and for var decls who are promoted into registers.  The decl they refer to is
attached to the instruction with a SILLocation.</p>
<div class="section" id="debug-value">
<h4><a class="toc-backref" href="#id68">debug_value</a><a class="headerlink" href="#debug-value" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= debug_value sil-operand (&#39;,&#39; debug-var-attr)*

debug_value %1 : $Int
</pre></div>
</div>
<p>This indicates that the value of a declaration with loadable type has changed
value to the specified operand.  The declaration in question is identified by
the SILLocation attached to the debug_value instruction.</p>
<p>The operand must have loadable type.</p>
<div class="highlight-python"><div class="highlight"><pre>debug-var-attr ::= &#39;var&#39;
debug-var-attr ::= &#39;let&#39;
debug-var-attr ::= &#39;name&#39; string-literal
debug-var-attr ::= &#39;argno&#39; integer-literal
</pre></div>
</div>
<p>There are a number of attributes that provide details about the source
variable that is being described, including the name of the
variable. For function and closure arguments <code class="docutils literal"><span class="pre">argno</span></code> is the number
of the function argument starting with 1.</p>
</div>
<div class="section" id="debug-value-addr">
<h4><a class="toc-backref" href="#id69">debug_value_addr</a><a class="headerlink" href="#debug-value-addr" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= debug_value_addr sil-operand (&#39;,&#39; debug-var-attr)*

debug_value_addr %7 : $*SomeProtocol
</pre></div>
</div>
<p>This indicates that the value of a declaration with address-only type
has changed value to the specified operand.  The declaration in
question is identified by the SILLocation attached to the
debug_value_addr instruction.</p>
</div>
</div>
<div class="section" id="accessing-memory">
<h3><a class="toc-backref" href="#id70">Accessing Memory</a><a class="headerlink" href="#accessing-memory" title="Permalink to this headline">¶</a></h3>
<div class="section" id="load">
<h4><a class="toc-backref" href="#id71">load</a><a class="headerlink" href="#load" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;load&#39; sil-operand

%1 = load %0 : $*T
// %0 must be of a $*T address type for loadable type $T
// %1 will be of type $T
</pre></div>
</div>
<p>Loads the value at address <code class="docutils literal"><span class="pre">%0</span></code> from memory. <code class="docutils literal"><span class="pre">T</span></code> must be a loadable type.
This does not affect the reference count, if any, of the loaded value; the
value must be retained explicitly if necessary. It is undefined behavior to
load from uninitialized memory or to load from an address that points to
deallocated storage.</p>
</div>
<div class="section" id="store">
<h4><a class="toc-backref" href="#id72">store</a><a class="headerlink" href="#store" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;store&#39; sil-value &#39;to&#39; sil-operand

store %0 to %1 : $*T
// $T must be a loadable type
</pre></div>
</div>
<p>Stores the value <code class="docutils literal"><span class="pre">%0</span></code> to memory at address <code class="docutils literal"><span class="pre">%1</span></code>.  The type of %1 is <code class="docutils literal"><span class="pre">*T</span></code>
and the type of <code class="docutils literal"><span class="pre">%0</span> <span class="pre">is</span> <span class="pre">``T</span></code>, which must be a loadable type. This will
overwrite the memory at <code class="docutils literal"><span class="pre">%1</span></code>. If <code class="docutils literal"><span class="pre">%1</span></code> already references a value that
requires <code class="docutils literal"><span class="pre">release</span></code> or other cleanup, that value must be loaded before being
stored over and cleaned up. It is undefined behavior to store to an address
that points to deallocated storage.</p>
</div>
<div class="section" id="assign">
<h4><a class="toc-backref" href="#id73">assign</a><a class="headerlink" href="#assign" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;assign&#39; sil-value &#39;to&#39; sil-operand

assign %0 to %1 : $*T
// $T must be a loadable type
</pre></div>
</div>
<p>Represents an abstract assignment of the value <code class="docutils literal"><span class="pre">%0</span></code> to memory at address
<code class="docutils literal"><span class="pre">%1</span></code> without specifying whether it is an initialization or a normal store.
The type of %1 is <code class="docutils literal"><span class="pre">*T</span></code> and the type of <code class="docutils literal"><span class="pre">%0</span></code> is <code class="docutils literal"><span class="pre">T</span></code>, which must be a
loadable type. This will overwrite the memory at <code class="docutils literal"><span class="pre">%1</span></code> and destroy the value
currently held there.</p>
<p>The purpose of the <code class="docutils literal"><span class="pre">assign</span></code> instruction is to simplify the
definitive initialization analysis on loadable variables by removing
what would otherwise appear to be a load and use of the current value.
It is produced by SILGen, which cannot know which assignments are
meant to be initializations.  If it is deemed to be an initialization,
it can be replaced with a <code class="docutils literal"><span class="pre">store</span></code>; otherwise, it must be replaced
with a sequence that also correctly destroys the current value.</p>
<p>This instruction is only valid in Raw SIL and is rewritten as appropriate
by the definitive initialization pass.</p>
</div>
<div class="section" id="mark-uninitialized">
<h4><a class="toc-backref" href="#id74">mark_uninitialized</a><a class="headerlink" href="#mark-uninitialized" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;mark_uninitialized&#39; &#39;[&#39; mu_kind &#39;]&#39; sil-operand
mu_kind ::= &#39;var&#39;
mu_kind ::= &#39;rootself&#39;
mu_kind ::= &#39;derivedself&#39;
mu_kind ::= &#39;derivedselfonly&#39;
mu_kind ::= &#39;delegatingself&#39;

%2 = mark_uninitialized [var] %1 : $*T
// $T must be an address
</pre></div>
</div>
<p>Indicates that a symbolic memory location is uninitialized, and must be
explicitly initialized before it escapes or before the current function returns.
This instruction returns its operands, and all accesses within the function must
be performed against the return value of the mark_uninitialized instruction.</p>
<p>The kind of mark_uninitialized instruction specifies the type of data
the mark_uninitialized instruction refers to:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">var</span></code>: designates the start of a normal variable live range</li>
<li><code class="docutils literal"><span class="pre">rootself</span></code>: designates <code class="docutils literal"><span class="pre">self</span></code> in a struct, enum, or root class</li>
<li><code class="docutils literal"><span class="pre">derivedself</span></code>: designates <code class="docutils literal"><span class="pre">self</span></code> in a derived (non-root) class</li>
<li><code class="docutils literal"><span class="pre">derivedselfonly</span></code>: designates <code class="docutils literal"><span class="pre">self</span></code> in a derived (non-root) class whose stored properties have already been initialized</li>
<li><code class="docutils literal"><span class="pre">delegatingself</span></code>: designates <code class="docutils literal"><span class="pre">self</span></code> on a struct, enum, or class in a delegating constructor (one that calls self.init)</li>
</ul>
<p>The purpose of the <code class="docutils literal"><span class="pre">mark_uninitialized</span></code> instruction is to enable
definitive initialization analysis for global variables (when marked as
&#8216;globalvar&#8217;) and instance variables (when marked as &#8216;rootinit&#8217;), which need to
be distinguished from simple allocations.</p>
<p>It is produced by SILGen, and is only valid in Raw SIL.  It is rewritten as
appropriate by the definitive initialization pass.</p>
</div>
<div class="section" id="mark-function-escape">
<h4><a class="toc-backref" href="#id75">mark_function_escape</a><a class="headerlink" href="#mark-function-escape" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;mark_function_escape&#39; sil-operand (&#39;,&#39; sil-operand)

%2 = mark_function_escape %1 : $*T
</pre></div>
</div>
<p>Indicates that a function definition closes over a symbolic memory location.
This instruction is variadic, and all of its operands must be addresses.</p>
<p>The purpose of the <code class="docutils literal"><span class="pre">mark_function_escape</span></code> instruction is to enable
definitive initialization analysis for global variables and instance variables,
which are not represented as box allocations.</p>
<p>It is produced by SILGen, and is only valid in Raw SIL.  It is rewritten as
appropriate by the definitive initialization pass.</p>
</div>
<div class="section" id="copy-addr">
<h4><a class="toc-backref" href="#id76">copy_addr</a><a class="headerlink" href="#copy-addr" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;copy_addr&#39; &#39;[take]&#39;? sil-value
                      &#39;to&#39; &#39;[initialization]&#39;? sil-operand

copy_addr [take] %0 to [initialization] %1 : $*T
// %0 and %1 must be of the same $*T address type
</pre></div>
</div>
<p>Loads the value at address <code class="docutils literal"><span class="pre">%0</span></code> from memory and assigns a copy of it back into
memory at address <code class="docutils literal"><span class="pre">%1</span></code>. A bare <code class="docutils literal"><span class="pre">copy_addr</span></code> instruction when <code class="docutils literal"><span class="pre">T</span></code> is a
non-trivial type:</p>
<div class="highlight-python"><div class="highlight"><pre>copy_addr %0 to %1 : $*T
</pre></div>
</div>
<p>is equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre>%new = load %0 : $*T        // Load the new value from the source
%old = load %1 : $*T        // Load the old value from the destination
strong_retain %new : $T            // Retain the new value
strong_release %old : $T           // Release the old
store %new to %1 : $*T      // Store the new value to the destination
</pre></div>
</div>
<p>except that <code class="docutils literal"><span class="pre">copy_addr</span></code> may be used even if <code class="docutils literal"><span class="pre">%0</span></code> is of an address-only
type. The <code class="docutils literal"><span class="pre">copy_addr</span></code> may be given one or both of the <code class="docutils literal"><span class="pre">[take]</span></code> or
<code class="docutils literal"><span class="pre">[initialization]</span></code> attributes:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">[take]</span></code> destroys the value at the source address in the course of the
copy.</li>
<li><code class="docutils literal"><span class="pre">[initialization]</span></code> indicates that the destination address is uninitialized.
Without the attribute, the destination address is treated as already
initialized, and the existing value will be destroyed before the new value
is stored.</li>
</ul>
<p>The three attributed forms thus behave like the following loadable type
operations:</p>
<div class="highlight-python"><div class="highlight"><pre>// take-assignment
  copy_addr [take] %0 to %1 : $*T
// is equivalent to:
  %new = load %0 : $*T
  %old = load %1 : $*T
  // no retain of %new!
  strong_release %old : $T
  store %new to %1 : $*T

// copy-initialization
  copy_addr %0 to [initialization] %1 : $*T
// is equivalent to:
  %new = load %0 : $*T
  strong_retain %new : $T
  // no load/release of %old!
  store %new to %1 : $*T

// take-initialization
  copy_addr [take] %0 to [initialization] %1 : $*T
// is equivalent to:
  %new = load %0 : $*T
  // no retain of %new!
  // no load/release of %old!
  store %new to %1 : $*T
</pre></div>
</div>
<p>If <code class="docutils literal"><span class="pre">T</span></code> is a trivial type, then <code class="docutils literal"><span class="pre">copy_addr</span></code> is always equivalent to its
take-initialization form.</p>
</div>
<div class="section" id="destroy-addr">
<h4><a class="toc-backref" href="#id77">destroy_addr</a><a class="headerlink" href="#destroy-addr" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;destroy_addr&#39; sil-operand

destroy_addr %0 : $*T
// %0 must be of an address $*T type
</pre></div>
</div>
<p>Destroys the value in memory at address <code class="docutils literal"><span class="pre">%0</span></code>. If <code class="docutils literal"><span class="pre">T</span></code> is a non-trivial type,
This is equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre>%1 = load %0
strong_release %1
</pre></div>
</div>
<p>except that <code class="docutils literal"><span class="pre">destroy_addr</span></code> may be used even if <code class="docutils literal"><span class="pre">%0</span></code> is of an
address-only type.  This does not deallocate memory; it only destroys the
pointed-to value, leaving the memory uninitialized.</p>
<p>If <code class="docutils literal"><span class="pre">T</span></code> is a trivial type, then <code class="docutils literal"><span class="pre">destroy_addr</span></code> is a no-op.</p>
</div>
<div class="section" id="index-addr">
<h4><a class="toc-backref" href="#id78">index_addr</a><a class="headerlink" href="#index-addr" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;index_addr&#39; sil-operand &#39;,&#39; sil-operand

%2 = index_addr %0 : $*T, %1 : $Builtin.Int&lt;n&gt;
// %0 must be of an address type $*T
// %1 must be of a builtin integer type
// %2 will be of type $*T
</pre></div>
</div>
<p>Given an address that references into an array of values, returns the address
of the <code class="docutils literal"><span class="pre">%1</span></code>-th element relative to <code class="docutils literal"><span class="pre">%0</span></code>. The address must reference into
a contiguous array. It is undefined to try to reference offsets within a
non-array value, such as fields within a homogeneous struct or tuple type, or
bytes within a value, using <code class="docutils literal"><span class="pre">index_addr</span></code>. (<code class="docutils literal"><span class="pre">Int8</span></code> address types have no
special behavior in this regard, unlike <code class="docutils literal"><span class="pre">char*</span></code> or <code class="docutils literal"><span class="pre">void*</span></code> in C.) It is
also undefined behavior to index out of bounds of an array, except to index
the &#8220;past-the-end&#8221; address of the array.</p>
</div>
<div class="section" id="index-raw-pointer">
<h4><a class="toc-backref" href="#id79">index_raw_pointer</a><a class="headerlink" href="#index-raw-pointer" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;index_raw_pointer&#39; sil-operand &#39;,&#39; sil-operand

%2 = index_raw_pointer %0 : $Builtin.RawPointer, %1 : $Builtin.Int&lt;n&gt;
// %0 must be of $Builtin.RawPointer type
// %1 must be of a builtin integer type
// %2 will be of type $*T
</pre></div>
</div>
<p>Given a <code class="docutils literal"><span class="pre">Builtin.RawPointer</span></code> value <code class="docutils literal"><span class="pre">%0</span></code>, returns a pointer value at the
byte offset <code class="docutils literal"><span class="pre">%1</span></code> relative to <code class="docutils literal"><span class="pre">%0</span></code>.</p>
</div>
</div>
<div class="section" id="reference-counting">
<h3><a class="toc-backref" href="#id80">Reference Counting</a><a class="headerlink" href="#reference-counting" title="Permalink to this headline">¶</a></h3>
<p>These instructions handle reference counting of heap objects. Values of
strong reference type have ownership semantics for the referenced heap
object. Retain and release operations, however,
are never implicit in SIL and always must be explicitly performed where needed.
Retains and releases on the value may be freely moved, and balancing
retains and releases may deleted, so long as an owning retain count is
maintained for the uses of the value.</p>
<p>All reference-counting operations are defined to work correctly on
null references (whether strong, unowned, or weak).  A non-null
reference must actually refer to a valid object of the indicated type
(or a subtype).  Address operands are required to be valid and non-null.</p>
<p>While SIL makes reference-counting operations explicit, the SIL type
system also fully represents strength of reference.  This is useful
for several reasons:</p>
<ol class="arabic simple">
<li>Type-safety: it is impossible to erroneously emit SIL that naively
uses a <code class="docutils literal"><span class="pre">&#64;weak</span></code> or <code class="docutils literal"><span class="pre">&#64;unowned</span></code> reference as if it were a strong
reference.</li>
<li>Consistency: when a reference is kept in memory, instructions like
<code class="docutils literal"><span class="pre">copy_addr</span></code> and <code class="docutils literal"><span class="pre">destroy_addr</span></code> implicitly carry the right
semantics in the type of the address, rather than needing special
variants or flags.</li>
<li>Ease of tooling: SIL directly stores the user&#8217;s intended strength
of reference, making it straightforward to generate instrumentation
that would convey this to a memory profiler.  In principle, with
only a modest number of additions and restrictions on SIL, it would
even be possible to drop all reference-counting instructions and
use the type information to feed a garbage collector.</li>
</ol>
<div class="section" id="strong-retain">
<h4><a class="toc-backref" href="#id81">strong_retain</a><a class="headerlink" href="#strong-retain" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;strong_retain&#39; sil-operand

strong_retain %0 : $T
// $T must be a reference type
</pre></div>
</div>
<p>Increases the strong retain count of the heap object referenced by <code class="docutils literal"><span class="pre">%0</span></code>.</p>
</div>
<div class="section" id="strong-release">
<h4><a class="toc-backref" href="#id82">strong_release</a><a class="headerlink" href="#strong-release" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>strong_release %0 : $T
// $T must be a reference type.
</pre></div>
</div>
<p>Decrements the strong reference count of the heap object referenced by <code class="docutils literal"><span class="pre">%0</span></code>.
If the release operation brings the strong reference count of the object to
zero, the object is destroyed and <code class="docutils literal"><span class="pre">&#64;weak</span></code> references are cleared.  When both
its strong and unowned reference counts reach zero, the object&#8217;s memory is
deallocated.</p>
</div>
<div class="section" id="strong-retain-unowned">
<h4><a class="toc-backref" href="#id83">strong_retain_unowned</a><a class="headerlink" href="#strong-retain-unowned" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;strong_retain_unowned&#39; sil-operand

strong_retain_unowned %0 : $@unowned T
// $T must be a reference type
</pre></div>
</div>
<p>Asserts that the strong reference count of the heap object referenced by <code class="docutils literal"><span class="pre">%0</span></code>
is still positive, then increases it by one.</p>
</div>
<div class="section" id="unowned-retain">
<h4><a class="toc-backref" href="#id84">unowned_retain</a><a class="headerlink" href="#unowned-retain" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;unowned_retain&#39; sil-operand

unowned_retain %0 : $@unowned T
// $T must be a reference type
</pre></div>
</div>
<p>Increments the unowned reference count of the heap object underlying <code class="docutils literal"><span class="pre">%0</span></code>.</p>
</div>
<div class="section" id="unowned-release">
<h4><a class="toc-backref" href="#id85">unowned_release</a><a class="headerlink" href="#unowned-release" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;unowned_release&#39; sil-operand

unowned_release %0 : $@unowned T
// $T must be a reference type
</pre></div>
</div>
<p>Decrements the unowned reference count of the heap object referenced by
<code class="docutils literal"><span class="pre">%0</span></code>.  When both its strong and unowned reference counts reach zero,
the object&#8217;s memory is deallocated.</p>
</div>
<div class="section" id="load-weak">
<h4><a class="toc-backref" href="#id86">load_weak</a><a class="headerlink" href="#load-weak" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;load_weak&#39; &#39;[take]&#39;? sil-operand

load_weak [take] %0 : $*@sil_weak Optional&lt;T&gt;
// $T must be an optional wrapping a reference type
</pre></div>
</div>
<p>Increments the strong reference count of the heap object held in the operand,
which must be an initialized weak reference.  The result is value of type
<code class="docutils literal"><span class="pre">$Optional&lt;T&gt;</span></code>, except that it is <code class="docutils literal"><span class="pre">null</span></code> if the heap object has begun
deallocation.</p>
<p>This operation must be atomic with respect to the final <code class="docutils literal"><span class="pre">strong_release</span></code> on
the operand heap object.  It need not be atomic with respect to <code class="docutils literal"><span class="pre">store_weak</span></code>
operations on the same address.</p>
</div>
<div class="section" id="store-weak">
<h4><a class="toc-backref" href="#id87">store_weak</a><a class="headerlink" href="#store-weak" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;store_weak&#39; sil-value &#39;to&#39; &#39;[initialization]&#39;? sil-operand

store_weak %0 to [initialization] %1 : $*@sil_weak Optional&lt;T&gt;
// $T must be an optional wrapping a reference type
</pre></div>
</div>
<p>Initializes or reassigns a weak reference.  The operand may be <code class="docutils literal"><span class="pre">nil</span></code>.</p>
<p>If <code class="docutils literal"><span class="pre">[initialization]</span></code> is given, the weak reference must currently either be
uninitialized or destroyed.  If it is not given, the weak reference must
currently be initialized.</p>
<p>This operation must be atomic with respect to the final <code class="docutils literal"><span class="pre">strong_release</span></code> on
the operand (source) heap object.  It need not be atomic with respect to
<code class="docutils literal"><span class="pre">store_weak</span></code> or <code class="docutils literal"><span class="pre">load_weak</span></code> operations on the same address.</p>
</div>
<div class="section" id="fix-lifetime">
<h4><a class="toc-backref" href="#id88">fix_lifetime</a><a class="headerlink" href="#fix-lifetime" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction :: &#39;fix_lifetime&#39; sil-operand

fix_lifetime %0 : $T
// Fix the lifetime of a value %0
fix_lifetime %1 : $*T
// Fix the lifetime of the memory object referenced by %1
</pre></div>
</div>
<p>Acts as a use of a value operand, or of the value in memory referenced by an
address operand. Optimizations may not move operations that would destroy the
value, such as <code class="docutils literal"><span class="pre">release_value</span></code>, <code class="docutils literal"><span class="pre">strong_release</span></code>, <code class="docutils literal"><span class="pre">copy_addr</span> <span class="pre">[take]</span></code>, or
<code class="docutils literal"><span class="pre">destroy_addr</span></code>, past this instruction.</p>
</div>
<div class="section" id="mark-dependence">
<h4><a class="toc-backref" href="#id89">mark_dependence</a><a class="headerlink" href="#mark-dependence" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction :: &#39;mark_dependence&#39; sil-operand &#39;on&#39; sil-operand

%2 = mark_dependence %0 : $*T on %1 : $Builtin.NativeObject
</pre></div>
</div>
<p>Indicates that the validity of the first operand depends on the value
of the second operand.  Operations that would destroy the second value
must not be moved before any instructions which depend on the result
of this instruction, exactly as if the address had been obviously
derived from that operand (e.g. using <code class="docutils literal"><span class="pre">ref_element_addr</span></code>).</p>
<p>The result is always equal to the first operand.  The first operand
will typically be an address, but it could be an address in a
non-obvious form, such as a Builtin.RawPointer or a struct containing
the same.  Transformations should be somewhat forgiving here.</p>
<p>The second operand may have either object or address type.  In the
latter case, the dependency is on the current value stored in the
address.</p>
</div>
<div class="section" id="is-unique">
<h4><a class="toc-backref" href="#id90">is_unique</a><a class="headerlink" href="#is-unique" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;is_unique&#39; sil-operand

%1 = is_unique %0 : $*T
// $T must be a reference-counted type
// %1 will be of type Builtin.Int1
</pre></div>
</div>
<p>Checks whether %0 is the address of a unique reference to a memory
object. Returns 1 if the strong reference count is 1, and 0 if the
strong reference count is greater than 1.</p>
<p>A discussion of the semantics can be found here:
<a class="reference internal" href="ARCOptimization.html#arcopts-is-unique"><span>is_unique instruction</span></a>.</p>
</div>
<div class="section" id="is-unique-or-pinned">
<h4><a class="toc-backref" href="#id91">is_unique_or_pinned</a><a class="headerlink" href="#is-unique-or-pinned" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;is_unique_or_pinned&#39; sil-operand

%1 = is_unique_or_pinned %0 : $*T
// $T must be a reference-counted type
// %1 will be of type Builtin.Int1
</pre></div>
</div>
<p>Checks whether %0 is the address of either a unique reference to a
memory object or a reference to a pinned object. Returns 1 if the
strong reference count is 1 or the object has been marked pinned by
strong_pin.</p>
</div>
<div class="section" id="copy-block">
<h4><a class="toc-backref" href="#id92">copy_block</a><a class="headerlink" href="#copy-block" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction :: &#39;copy_block&#39; sil-operand

%1 = copy_block %0 : $@convention(block) T -&gt; U
</pre></div>
</div>
<p>Performs a copy of an Objective-C block. Unlike retains of other
reference-counted types, this can produce a different value from the operand
if the block is copied from the stack to the heap.</p>
</div>
</div>
<div class="section" id="literals">
<h3><a class="toc-backref" href="#id93">Literals</a><a class="headerlink" href="#literals" title="Permalink to this headline">¶</a></h3>
<p>These instructions bind SIL values to literal constants or to global entities.</p>
<div class="section" id="function-ref">
<h4><a class="toc-backref" href="#id94">function_ref</a><a class="headerlink" href="#function-ref" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;function_ref&#39; sil-function-name &#39;:&#39; sil-type

%1 = function_ref @function : $@thin T -&gt; U
// $@thin T -&gt; U must be a thin function type
// %1 has type $T -&gt; U
</pre></div>
</div>
<p>Creates a reference to a SIL function.</p>
</div>
<div class="section" id="global-addr">
<h4><a class="toc-backref" href="#id95">global_addr</a><a class="headerlink" href="#global-addr" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;global_addr&#39; sil-global-name &#39;:&#39; sil-type

%1 = global_addr @foo : $*Builtin.Word
</pre></div>
</div>
<p>Creates a reference to the address of a global variable.</p>
</div>
<div class="section" id="integer-literal">
<h4><a class="toc-backref" href="#id96">integer_literal</a><a class="headerlink" href="#integer-literal" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;integer_literal&#39; sil-type &#39;,&#39; int-literal

%1 = integer_literal $Builtin.Int&lt;n&gt;, 123
// $Builtin.Int&lt;n&gt; must be a builtin integer type
// %1 has type $Builtin.Int&lt;n&gt;
</pre></div>
</div>
<p>Creates an integer literal value. The result will be of type
<code class="docutils literal"><span class="pre">Builtin.Int&lt;n&gt;</span></code>, which must be a builtin integer type. The literal value
is specified using Swift&#8217;s integer literal syntax.</p>
</div>
<div class="section" id="float-literal">
<h4><a class="toc-backref" href="#id97">float_literal</a><a class="headerlink" href="#float-literal" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;float_literal&#39; sil-type &#39;,&#39; int-literal

%1 = float_literal $Builtin.FP&lt;n&gt;, 0x3F800000
// $Builtin.FP&lt;n&gt; must be a builtin floating-point type
// %1 has type $Builtin.FP&lt;n&gt;
</pre></div>
</div>
<p>Creates a floating-point literal value. The result will be of type ``
<code class="docutils literal"><span class="pre">Builtin.FP&lt;n&gt;</span></code>, which must be a builtin floating-point type. The literal
value is specified as the bitwise representation of the floating point value,
using Swift&#8217;s hexadecimal integer literal syntax.</p>
</div>
<div class="section" id="string-literal">
<h4><a class="toc-backref" href="#id98">string_literal</a><a class="headerlink" href="#string-literal" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;string_literal&#39; encoding string-literal
encoding ::= &#39;utf8&#39;
encoding ::= &#39;utf16&#39;

%1 = string_literal &quot;asdf&quot;
// %1 has type $Builtin.RawPointer
</pre></div>
</div>
<p>Creates a reference to a string in the global string table. The result
is a pointer to the data.  The referenced string is always null-terminated. The
string literal value is specified using Swift&#8217;s string
literal syntax (though <code class="docutils literal"><span class="pre">\()</span></code> interpolations are not allowed).</p>
</div>
</div>
<div class="section" id="dynamic-dispatch">
<h3><a class="toc-backref" href="#id99">Dynamic Dispatch</a><a class="headerlink" href="#dynamic-dispatch" title="Permalink to this headline">¶</a></h3>
<p>These instructions perform dynamic lookup of class and generic methods. They
share a common set of attributes:</p>
<div class="highlight-python"><div class="highlight"><pre>sil-method-attributes ::= &#39;[&#39; &#39;volatile&#39;? &#39;]&#39;
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">volatile</span></code> attribute on a dynamic dispatch instruction indicates that
the method lookup is semantically required (as, for example, in Objective-C).
When the type of a dynamic dispatch instruction&#8217;s operand is known,
optimization passes can promote non-<code class="docutils literal"><span class="pre">volatile</span></code> dispatch instructions
into static <code class="docutils literal"><span class="pre">function_ref</span></code> instructions.</p>
<p>If a dynamic dispatch instruction references an Objective-C method
(indicated by the <code class="docutils literal"><span class="pre">foreign</span></code> marker on a method reference, as in
<code class="docutils literal"><span class="pre">#NSObject.description!1.foreign</span></code>), then the instruction
represents an <code class="docutils literal"><span class="pre">objc_msgSend</span></code> invocation. <code class="docutils literal"><span class="pre">objc_msgSend</span></code> invocations can
only be used as the callee of an <code class="docutils literal"><span class="pre">apply</span></code> instruction or <code class="docutils literal"><span class="pre">partial_apply</span></code>
instruction. They cannot be stored or used as <code class="docutils literal"><span class="pre">apply</span></code> or <code class="docutils literal"><span class="pre">partial_apply</span></code>
arguments.  <code class="docutils literal"><span class="pre">objc_msgSend</span></code> invocations must always be <code class="docutils literal"><span class="pre">volatile</span></code>.</p>
<div class="section" id="class-method">
<h4><a class="toc-backref" href="#id100">class_method</a><a class="headerlink" href="#class-method" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;class_method&#39; sil-method-attributes?
                      sil-operand &#39;,&#39; sil-decl-ref &#39;:&#39; sil-type

%1 = class_method %0 : $T, #T.method!1 : $@thin U -&gt; V
// %0 must be of a class type or class metatype $T
// #T.method!1 must be a reference to a dynamically-dispatched method of T or
// of one of its superclasses, at uncurry level &gt;= 1
// %1 will be of type $U -&gt; V
</pre></div>
</div>
<p>Looks up a method based on the dynamic type of a class or class metatype
instance. It is undefined behavior if the class value is null and the
method is not an Objective-C method.</p>
<p>If:</p>
<ul class="simple">
<li>the instruction is not <code class="docutils literal"><span class="pre">[volatile]</span></code>,</li>
<li>the referenced method is not a <code class="docutils literal"><span class="pre">foreign</span></code> method,</li>
<li>and the static type of the class instance is known, or the method is known
to be final,</li>
</ul>
<p>then the instruction is a candidate for devirtualization optimization. A
devirtualization pass can consult the module&#8217;s <a class="reference internal" href="#vtables">VTables</a> to find the
SIL function that implements the method and promote the instruction to a
static <a class="reference internal" href="#function-ref">function_ref</a>.</p>
</div>
<div class="section" id="super-method">
<h4><a class="toc-backref" href="#id101">super_method</a><a class="headerlink" href="#super-method" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;super_method&#39; sil-method-attributes?
                      sil-operand &#39;,&#39; sil-decl-ref &#39;:&#39; sil-type

%1 = super_method %0 : $T, #Super.method!1.foreign : $@thin U -&gt; V
// %0 must be of a non-root class type or class metatype $T
// #Super.method!1.foreign must be a reference to an ObjC method of T&#39;s
// superclass or of one of its ancestor classes, at uncurry level &gt;= 1
// %1 will be of type $@thin U -&gt; V
</pre></div>
</div>
<p>Looks up a method in the superclass of a class or class metatype instance.
Note that for native Swift methods, <code class="docutils literal"><span class="pre">super.method</span></code> calls are statically
dispatched, so this instruction is only valid for Objective-C methods.
It is undefined behavior if the class value is null and the method is
not an Objective-C method.</p>
</div>
<div class="section" id="witness-method">
<h4><a class="toc-backref" href="#id102">witness_method</a><a class="headerlink" href="#witness-method" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;witness_method&#39; sil-method-attributes?
                      sil-type &#39;,&#39; sil-decl-ref &#39;:&#39; sil-type

%1 = witness_method $T, #Proto.method!1 \
  : $@thin @cc(witness_method) &lt;Self: Proto&gt; U -&gt; V
// $T must be an archetype
// #Proto.method!1 must be a reference to a method of one of the protocol
//   constraints on T
// &lt;Self: Proto&gt; U -&gt; V must be the type of the referenced method,
//   generic on Self
// %1 will be of type $@thin &lt;Self: Proto&gt; U -&gt; V
</pre></div>
</div>
<p>Looks up the implementation of a protocol method for a generic type variable
constrained by that protocol. The result will be generic on the <code class="docutils literal"><span class="pre">Self</span></code>
archetype of the original protocol and have the <code class="docutils literal"><span class="pre">witness_method</span></code> calling
convention. If the referenced protocol is an <code class="docutils literal"><span class="pre">&#64;objc</span></code> protocol, the
resulting type has the <code class="docutils literal"><span class="pre">objc</span></code> calling convention.</p>
</div>
<div class="section" id="dynamic-method">
<h4><a class="toc-backref" href="#id103">dynamic_method</a><a class="headerlink" href="#dynamic-method" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;dynamic_method&#39; sil-method-attributes?
                    sil-operand &#39;,&#39; sil-decl-ref &#39;:&#39; sil-type

%1 = dynamic_method %0 : $P, #X.method!1 : $@thin U -&gt; V
// %0 must be of a protocol or protocol composition type $P,
// where $P contains the Swift.DynamicLookup protocol
// #X.method!1 must be a reference to an @objc method of any class
// or protocol type
//
// The &quot;self&quot; argument of the method type $@thin U -&gt; V must be
//   Builtin.ObjCPointer
</pre></div>
</div>
<p>Looks up the implementation of an Objective-C method with the same
selector as the named method for the dynamic type of the
value inside an existential container. The &#8220;self&#8221; operand of the result
function value is represented using an opaque type, the value for which must
be projected out as a value of type <code class="docutils literal"><span class="pre">Builtin.ObjCPointer</span></code>.</p>
<p>It is undefined behavior if the dynamic type of the operand does not
have an implementation for the Objective-C method with the selector to
which the <code class="docutils literal"><span class="pre">dynamic_method</span></code> instruction refers, or if that
implementation has parameter or result types that are incompatible
with the method referenced by <code class="docutils literal"><span class="pre">dynamic_method</span></code>.
This instruction should only be used in cases where its result will be
immediately consumed by an operation that performs the selector check
itself (e.g., an <code class="docutils literal"><span class="pre">apply</span></code> that lowers to <code class="docutils literal"><span class="pre">objc_msgSend</span></code>).
To query whether the operand has an implementation for the given
method and safely handle the case where it does not, use
<a class="reference internal" href="#dynamic-method-br">dynamic_method_br</a>.</p>
</div>
</div>
<div class="section" id="function-application">
<h3><a class="toc-backref" href="#id104">Function Application</a><a class="headerlink" href="#function-application" title="Permalink to this headline">¶</a></h3>
<p>These instructions call functions or wrap them in partial application or
specialization thunks.</p>
<div class="section" id="apply">
<h4><a class="toc-backref" href="#id105">apply</a><a class="headerlink" href="#apply" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;apply&#39; &#39;[nothrow]&#39;? sil-value
                      sil-apply-substitution-list?
                      &#39;(&#39; (sil-value (&#39;,&#39; sil-value)*)? &#39;)&#39;
                      &#39;:&#39; sil-type

sil-apply-substitution-list ::= &#39;&lt;&#39; sil-substitution
                                    (&#39;,&#39; sil-substitution)* &#39;&gt;&#39;
sil-substitution ::= type &#39;=&#39; type

%r = apply %0(%1, %2, ...) : $(A, B, ...) -&gt; R
// Note that the type of the callee &#39;%0&#39; is specified *after* the arguments
// %0 must be of a concrete function type $(A, B, ...) -&gt; R
// %1, %2, etc. must be of the argument types $A, $B, etc.
// %r will be of the return type $R

%r = apply %0&lt;T = A, U = B&gt;(%1, %2, ...) : $&lt;T, U&gt;(T, U, ...) -&gt; R
// %0 must be of a polymorphic function type $&lt;T, U&gt;(T, U, ...) -&gt; R
// %1, %2, etc. must be of the argument types after substitution $A, $B, etc.
// %r will be of the substituted return type $R&#39;
</pre></div>
</div>
<p>Transfers control to function <code class="docutils literal"><span class="pre">%0</span></code>, passing it the given arguments. In
the instruction syntax, the type of the callee is specified after the argument
list; the types of the argument and of the defined value are derived from the
function type of the callee. The input argument tuple type is destructured,
and each element is passed as an individual argument. The <code class="docutils literal"><span class="pre">apply</span></code>
instruction does no retaining or releasing of its arguments by itself; the
<a class="reference internal" href="#calling-convention">calling convention</a>&#8216;s retain/release policy must be handled by separate
explicit <code class="docutils literal"><span class="pre">retain</span></code> and <code class="docutils literal"><span class="pre">release</span></code> instructions. The return value will
likewise not be implicitly retained or released.</p>
<p>The callee value must have function type.  That function type may not
have an error result, except the instruction has the <code class="docutils literal"><span class="pre">nothrow</span></code> attribute set.
The <code class="docutils literal"><span class="pre">nothrow</span></code> attribute specifies that the callee has an error result but
does not actually throw.
For the regular case of calling a function with error result, use <code class="docutils literal"><span class="pre">try_apply</span></code>.</p>
<p>NB: If the callee value is of a thick function type, <code class="docutils literal"><span class="pre">apply</span></code> currently
consumes the callee value at +1 strong retain count.</p>
<p>If the callee is generic, all of its generic parameters must be bound by the
given substitution list. The arguments and return value is
given with these generic substitutions applied.</p>
</div>
<div class="section" id="partial-apply">
<h4><a class="toc-backref" href="#id106">partial_apply</a><a class="headerlink" href="#partial-apply" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;partial_apply&#39; sil-value
                      sil-apply-substitution-list?
                      &#39;(&#39; (sil-value (&#39;,&#39; sil-value)*)? &#39;)&#39;
                      &#39;:&#39; sil-type

%c = partial_apply %0(%1, %2, ...) : $(Z..., A, B, ...) -&gt; R
// Note that the type of the callee &#39;%0&#39; is specified *after* the arguments
// %0 must be of a concrete function type $(Z..., A, B, ...) -&gt; R
// %1, %2, etc. must be of the argument types $A, $B, etc.,
//   of the tail part of the argument tuple of %0
// %c will be of the partially-applied thick function type (Z...) -&gt; R

%c = partial_apply %0&lt;T = A, U = B&gt;(%1, %2, ...) : $(Z..., T, U, ...) -&gt; R
// %0 must be of a polymorphic function type $&lt;T, U&gt;(T, U, ...) -&gt; R
// %1, %2, etc. must be of the argument types after substitution $A, $B, etc.
//   of the tail part of the argument tuple of %0
// %r will be of the substituted thick function type $(Z&#39;...) -&gt; R&#39;
</pre></div>
</div>
<p>Creates a closure by partially applying the function <code class="docutils literal"><span class="pre">%0</span></code> to a partial
sequence of its arguments. In the instruction syntax, the type of the callee is
specified after the argument list; the types of the argument and of the defined
value are derived from the function type of the callee. The closure context will
be allocated with retain count 1 and initialized to contain the values <code class="docutils literal"><span class="pre">%1</span></code>,
<code class="docutils literal"><span class="pre">%2</span></code>, etc.  The closed-over values will not be retained; that must be done
separately before the <code class="docutils literal"><span class="pre">partial_apply</span></code>. The closure does however take
ownership of the partially applied arguments; when the closure reference
count reaches zero, the contained values will be destroyed.</p>
<p>If the callee is generic, all of its generic parameters must be bound by the
given substitution list. The arguments are given with these generic
substitutions applied, and the resulting closure is of concrete function
type with the given substitutions applied. The generic parameters themselves
cannot be partially applied; all of them must be bound. The result is always
a concrete function.</p>
<p>TODO: The instruction, when applied to a generic function,
currently implicitly performs abstraction difference transformations enabled
by the given substitutions, such as promoting address-only arguments and returns
to register arguments. This should be fixed.</p>
<p>This instruction is used to implement both curry thunks and closures. A
curried function in Swift:</p>
<div class="highlight-python"><div class="highlight"><pre>func foo(a:A)(b:B)(c:C)(d:D) -&gt; E { /* body of foo */ }
</pre></div>
</div>
<p>emits curry thunks in SIL as follows (retains and releases omitted for
clarity):</p>
<div class="highlight-python"><div class="highlight"><pre>func @foo : $@thin A -&gt; B -&gt; C -&gt; D -&gt; E {
entry(%a : $A):
  %foo_1 = function_ref @foo_1 : $@thin (B, A) -&gt; C -&gt; D -&gt; E
  %thunk = partial_apply %foo_1(%a) : $@thin (B, A) -&gt; C -&gt; D -&gt; E
  return %thunk : $B -&gt; C -&gt; D -&gt; E
}

func @foo_1 : $@thin (B, A) -&gt; C -&gt; D -&gt; E {
entry(%b : $B, %a : $A):
  %foo_2 = function_ref @foo_2 : $@thin (C, B, A) -&gt; D -&gt; E
  %thunk = partial_apply %foo_2(%b, %a) : $@thin (C, B, A) -&gt; D -&gt; E
  return %thunk : $(B, A) -&gt; C -&gt; D -&gt; E
}

func @foo_2 : $@thin (C, B, A) -&gt; D -&gt; E {
entry(%c : $C, %b : $B, %a : $A):
  %foo_3 = function_ref @foo_3 : $@thin (D, C, B, A) -&gt; E
  %thunk = partial_apply %foo_3(%c, %b, %a) : $@thin (D, C, B, A) -&gt; E
  return %thunk : $(C, B, A) -&gt; D -&gt; E
}

func @foo_3 : $@thin (D, C, B, A) -&gt; E {
entry(%d : $D, %c : $C, %b : $B, %a : $A):
  // ... body of foo ...
}
</pre></div>
</div>
<p>A local function in Swift that captures context, such as <code class="docutils literal"><span class="pre">bar</span></code> in the
following example:</p>
<div class="highlight-python"><div class="highlight"><pre>func foo(x:Int) -&gt; Int {
  func bar(y:Int) -&gt; Int {
    return x + y
  }
  return bar(1)
}
</pre></div>
</div>
<p>lowers to an uncurried entry point and is curried in the enclosing function:</p>
<div class="highlight-python"><div class="highlight"><pre>func @bar : $@thin (Int, @box Int, *Int) -&gt; Int {
entry(%y : $Int, %x_box : $@box Int, %x_address : $*Int):
  // ... body of bar ...
}

func @foo : $@thin Int -&gt; Int {
entry(%x : $Int):
  // Create a box for the &#39;x&#39; variable
  %x_box = alloc_box $Int
  store %x to %x_box#1 : $*Int

  // Create the bar closure
  %bar_uncurried = function_ref @bar : $(Int, Int) -&gt; Int
  %bar = partial_apply %bar_uncurried(%x_box#0, %x_box#1) \
    : $(Int, Builtin.ObjectPointer, *Int) -&gt; Int

  // Apply it
  %1 = integer_literal $Int, 1
  %ret = apply %bar(%1) : $(Int) -&gt; Int

  // Clean up
  release %bar : $(Int) -&gt; Int
  return %ret : $Int
}
</pre></div>
</div>
</div>
<div class="section" id="builtin">
<h4><a class="toc-backref" href="#id107">builtin</a><a class="headerlink" href="#builtin" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;builtin&#39; string-literal
                      sil-apply-substitution-list?
                      &#39;(&#39; (sil-operand (&#39;,&#39; sil-operand)*)? &#39;)&#39;
                      &#39;:&#39; sil-type

%1 = builtin &quot;foo&quot;(%1 : $T, %2 : $U) : $V
// &quot;foo&quot; must name a function in the Builtin module
</pre></div>
</div>
<p>Invokes functionality built into the backend code generator, such as LLVM-
level instructions and intrinsics.</p>
</div>
</div>
<div class="section" id="metatypes">
<h3><a class="toc-backref" href="#id108">Metatypes</a><a class="headerlink" href="#metatypes" title="Permalink to this headline">¶</a></h3>
<p>These instructions access metatypes, either statically by type name or
dynamically by introspecting class or generic values.</p>
<div class="section" id="metatype">
<h4><a class="toc-backref" href="#id109">metatype</a><a class="headerlink" href="#metatype" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;metatype&#39; sil-type

%1 = metatype $T.metatype
// %1 has type $T.metatype
</pre></div>
</div>
<p>Creates a reference to the metatype object for type <code class="docutils literal"><span class="pre">T</span></code>.</p>
</div>
<div class="section" id="value-metatype">
<h4><a class="toc-backref" href="#id110">value_metatype</a><a class="headerlink" href="#value-metatype" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;value_metatype&#39; sil-type &#39;,&#39; sil-operand

%1 = value_metatype $T.metatype, %0 : $T
// %0 must be a value or address of type $T
// %1 will be of type $T.metatype
</pre></div>
</div>
<p>Obtains a reference to the dynamic metatype of the value <code class="docutils literal"><span class="pre">%0</span></code>.</p>
</div>
<div class="section" id="existential-metatype">
<h4><a class="toc-backref" href="#id111">existential_metatype</a><a class="headerlink" href="#existential-metatype" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;existential_metatype&#39; sil-type &#39;,&#39; sil-operand

%1 = existential_metatype $P.metatype, %0 : $P
// %0 must be a value of class protocol or protocol composition
//   type $P, or an address of address-only protocol type $*P
// %1 will be a $P.metatype value referencing the metatype of the
//   concrete value inside %0
</pre></div>
</div>
<p>Obtains the metatype of the concrete value
referenced by the existential container referenced by <code class="docutils literal"><span class="pre">%0</span></code>.</p>
</div>
<div class="section" id="objc-protocol">
<h4><a class="toc-backref" href="#id112">objc_protocol</a><a class="headerlink" href="#objc-protocol" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;objc_protocol&#39; protocol-decl : sil-type

%0 = objc_protocol #ObjCProto : $Protocol
</pre></div>
</div>
<p><em>TODO</em> Fill this in.</p>
</div>
</div>
<div class="section" id="aggregate-types">
<h3><a class="toc-backref" href="#id113">Aggregate Types</a><a class="headerlink" href="#aggregate-types" title="Permalink to this headline">¶</a></h3>
<p>These instructions construct and project elements from structs, tuples, and
class instances.</p>
<div class="section" id="retain-value">
<h4><a class="toc-backref" href="#id114">retain_value</a><a class="headerlink" href="#retain-value" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;retain_value&#39; sil-operand

retain_value %0 : $A
</pre></div>
</div>
<p>Retains a loadable value, which simply retains any references it holds.</p>
<p>For trivial types, this is a no-op.  For reference types, this is equivalent to
a <code class="docutils literal"><span class="pre">strong_retain</span></code>.  For <code class="docutils literal"><span class="pre">&#64;unowned</span></code> types, this is equivalent to an
<code class="docutils literal"><span class="pre">unowned_retain</span></code>.  In each of these cases, those are the preferred forms.</p>
<p>For aggregate types, especially enums, it is typically both easier
and more efficient to reason about aggregate copies than it is to
reason about copies of the subobjects.</p>
</div>
<div class="section" id="release-value">
<h4><a class="toc-backref" href="#id115">release_value</a><a class="headerlink" href="#release-value" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;release_value&#39; sil-operand

release_value %0 : $A
</pre></div>
</div>
<p>Destroys a loadable value, by releasing any retainable pointers within it.</p>
<p>This is defined to be equivalent to storing the operand into a stack
allocation and using &#8216;destroy_addr&#8217; to destroy the object there.</p>
<p>For trivial types, this is a no-op.  For reference types, this is
equivalent to a <code class="docutils literal"><span class="pre">strong_release</span></code>.  For <code class="docutils literal"><span class="pre">&#64;unowned</span></code> types, this is
equivalent to an <code class="docutils literal"><span class="pre">unowned_release</span></code>.  In each of these cases, those
are the preferred forms.</p>
<p>For aggregate types, especially enums, it is typically both easier
and more efficient to reason about aggregate destroys than it is to
reason about destroys of the subobjects.</p>
</div>
<div class="section" id="autorelease-value">
<h4><a class="toc-backref" href="#id116">autorelease_value</a><a class="headerlink" href="#autorelease-value" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;autorelease_value&#39; sil-operand

autorelease_value %0 : $A
</pre></div>
</div>
<p><em>TODO</em> Complete this section.</p>
</div>
<div class="section" id="tuple">
<h4><a class="toc-backref" href="#id117">tuple</a><a class="headerlink" href="#tuple" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;tuple&#39; sil-tuple-elements
sil-tuple-elements ::= &#39;(&#39; (sil-operand (&#39;,&#39; sil-operand)*)? &#39;)&#39;
sil-tuple-elements ::= sil-type &#39;(&#39; (sil-value (&#39;,&#39; sil-value)*)? &#39;)&#39;

%1 = tuple (%a : $A, %b : $B, ...)
// $A, $B, etc. must be loadable non-address types
// %1 will be of the &quot;simple&quot; tuple type $(A, B, ...)

%1 = tuple $(a:A, b:B, ...) (%a, %b, ...)
// (a:A, b:B, ...) must be a loadable tuple type
// %1 will be of the type $(a:A, b:B, ...)
</pre></div>
</div>
<p>Creates a loadable tuple value by aggregating multiple loadable values.</p>
<p>If the destination type is a &#8220;simple&#8221; tuple type, that is, it has no keyword
argument labels or variadic arguments, then the first notation can be used,
which interleaves the element values and types. If keyword names or variadic
fields are specified, then the second notation must be used, which spells out
the tuple type before the fields.</p>
</div>
<div class="section" id="tuple-extract">
<h4><a class="toc-backref" href="#id118">tuple_extract</a><a class="headerlink" href="#tuple-extract" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;tuple_extract&#39; sil-operand &#39;,&#39; int-literal

%1 = tuple_extract %0 : $(T...), 123
// %0 must be of a loadable tuple type $(T...)
// %1 will be of the type of the selected element of %0
</pre></div>
</div>
<p>Extracts an element from a loadable tuple value.</p>
</div>
<div class="section" id="tuple-element-addr">
<h4><a class="toc-backref" href="#id119">tuple_element_addr</a><a class="headerlink" href="#tuple-element-addr" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;tuple_element_addr&#39; sil-operand &#39;,&#39; int-literal

%1 = tuple_element_addr %0 : $*(T...), 123
// %0 must of a $*(T...) address-of-tuple type
// %1 will be of address type $*U where U is the type of the 123rd
//   element of T
</pre></div>
</div>
<p>Given the address of a tuple in memory, derives the
address of an element within that value.</p>
</div>
<div class="section" id="struct">
<h4><a class="toc-backref" href="#id120">struct</a><a class="headerlink" href="#struct" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;struct&#39; sil-type &#39;(&#39; (sil-operand (&#39;,&#39; sil-operand)*)? &#39;)&#39;

%1 = struct $S (%a : $A, %b : $B, ...)
// $S must be a loadable struct type
// $A, $B, ... must be the types of the physical &#39;var&#39; fields of $S in order
// %1 will be of type $S
</pre></div>
</div>
<p>Creates a value of a loadable struct type by aggregating multiple loadable
values.</p>
</div>
<div class="section" id="struct-extract">
<h4><a class="toc-backref" href="#id121">struct_extract</a><a class="headerlink" href="#struct-extract" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;struct_extract&#39; sil-operand &#39;,&#39; sil-decl-ref

%1 = struct_extract %0 : $S, #S.field
// %0 must be of a loadable struct type $S
// #S.field must be a physical &#39;var&#39; field of $S
// %1 will be of the type of the selected field of %0
</pre></div>
</div>
<p>Extracts a physical field from a loadable struct value.</p>
</div>
<div class="section" id="struct-element-addr">
<h4><a class="toc-backref" href="#id122">struct_element_addr</a><a class="headerlink" href="#struct-element-addr" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;struct_element_addr&#39; sil-operand &#39;,&#39; sil-decl-ref

%1 = struct_element_addr %0 : $*S, #S.field
// %0 must be of a struct type $S
// #S.field must be a physical &#39;var&#39; field of $S
// %1 will be the address of the selected field of %0
</pre></div>
</div>
<p>Given the address of a struct value in memory, derives the address of a
physical field within the value.</p>
</div>
<div class="section" id="ref-element-addr">
<h4><a class="toc-backref" href="#id123">ref_element_addr</a><a class="headerlink" href="#ref-element-addr" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;ref_element_addr&#39; sil-operand &#39;,&#39; sil-decl-ref

%1 = ref_element_addr %0 : $C, #C.field
// %0 must be a value of class type $C
// #C.field must be a non-static physical field of $C
// %1 will be of type $*U where U is the type of the selected field
//   of C
</pre></div>
</div>
<p>Given an instance of a class, derives the address of a physical instance
variable inside the instance. It is undefined behavior if the class value
is null.</p>
</div>
</div>
<div class="section" id="enums">
<h3><a class="toc-backref" href="#id124">Enums</a><a class="headerlink" href="#enums" title="Permalink to this headline">¶</a></h3>
<p>These instructions construct values of enum type. Loadable enum values are
created with the <a class="reference internal" href="#enum">enum</a> instruction. Address-only enums require two-step
initialization. First, if the case requires data, that data is stored into
the enum at the address projected by <a class="reference internal" href="#init-enum-data-addr">init_enum_data_addr</a>. This step is
skipped for cases without data. Finally, the tag for
the enum is injected with an <a class="reference internal" href="#inject-enum-addr">inject_enum_addr</a> instruction:</p>
<div class="highlight-python"><div class="highlight"><pre>enum AddressOnlyEnum {
  case HasData(AddressOnlyType)
  case NoData
}

sil @init_with_data : $(AddressOnlyType) -&gt; AddressOnlyEnum {
entry(%0 : $*AddressOnlyEnum, %1 : $*AddressOnlyType):
  // Store the data argument for the case.
  %2 = init_enum_data_addr %0 : $*AddressOnlyEnum, #AddressOnlyEnum.HasData
  copy_addr [take] %2 to [initialization] %1 : $*AddressOnlyType
  // Inject the tag.
  inject_enum_addr %0 : $*AddressOnlyEnum, #AddressOnlyEnum.HasData
  return
}

sil @init_without_data : $() -&gt; AddressOnlyEnum {
  // No data. We only need to inject the tag.
  inject_enum_addr %0 : $*AddressOnlyEnum, #AddressOnlyEnum.NoData
  return
}
</pre></div>
</div>
<p>Accessing the value of a loadable enum is inseparable from dispatching on its
discriminator and is done with the <a class="reference internal" href="#switch-enum">switch_enum</a> terminator:</p>
<div class="highlight-python"><div class="highlight"><pre>enum Foo { case A(Int), B(String) }

sil @switch_foo : $(Foo) -&gt; () {
entry(%foo : $Foo):
  switch_enum %foo : $Foo, case #Foo.A: a_dest, case #Foo.B: b_dest

a_dest(%a : $Int):
  /* use %a */

b_dest(%b : $String):
  /* use %b */
}
</pre></div>
</div>
<p>An address-only enum can be tested by branching on it using the
<a class="reference internal" href="#switch-enum-addr">switch_enum_addr</a> terminator. Its value can then be taken by destructively
projecting the enum value with <a class="reference internal" href="#unchecked-take-enum-data-addr">unchecked_take_enum_data_addr</a>:</p>
<div class="highlight-python"><div class="highlight"><pre>enum Foo&lt;T&gt; { case A(T), B(String) }

sil @switch_foo : $&lt;T&gt; (Foo&lt;T&gt;) -&gt; () {
entry(%foo : $*Foo&lt;T&gt;):
  switch_enum_addr %foo : $*Foo&lt;T&gt;, case #Foo.A: a_dest, case #Foo.B: b_dest

a_dest:
  %a = unchecked_take_enum_data_addr %foo : $*Foo&lt;T&gt;, #Foo.A
  /* use %a */

b_dest:
  %b = unchecked_take_enum_data_addr %foo : $*Foo&lt;T&gt;, #Foo.B
  /* use %b */
}
</pre></div>
</div>
<div class="section" id="enum">
<h4><a class="toc-backref" href="#id125">enum</a><a class="headerlink" href="#enum" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;enum&#39; sil-type &#39;,&#39; sil-decl-ref (&#39;,&#39; sil-operand)?

%1 = enum $U, #U.EmptyCase
%1 = enum $U, #U.DataCase, %0 : $T
// $U must be an enum type
// #U.DataCase or #U.EmptyCase must be a case of enum $U
// If #U.Case has a data type $T, %0 must be a value of type $T
// If #U.Case has no data type, the operand must be omitted
// %1 will be of type $U
</pre></div>
</div>
<p>Creates a loadable enum value in the given <code class="docutils literal"><span class="pre">case</span></code>. If the <code class="docutils literal"><span class="pre">case</span></code> has a
data type, the enum value will contain the operand value.</p>
</div>
<div class="section" id="unchecked-enum-data">
<h4><a class="toc-backref" href="#id126">unchecked_enum_data</a><a class="headerlink" href="#unchecked-enum-data" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;unchecked_enum_data&#39; sil-operand &#39;,&#39; sil-decl-ref

%1 = unchecked_enum_data %0 : $U, #U.DataCase
// $U must be an enum type
// #U.DataCase must be a case of enum $U with data
// %1 will be of object type $T for the data type of case U.DataCase
</pre></div>
</div>
<p>Unsafely extracts the payload data for an enum <code class="docutils literal"><span class="pre">case</span></code> from an enum value.
It is undefined behavior if the enum does not contain a value of the given
case.</p>
</div>
<div class="section" id="init-enum-data-addr">
<h4><a class="toc-backref" href="#id127">init_enum_data_addr</a><a class="headerlink" href="#init-enum-data-addr" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;init_enum_data_addr&#39; sil-operand &#39;,&#39; sil-decl-ref

%1 = init_enum_data_addr %0 : $*U, #U.DataCase
// $U must be an enum type
// #U.DataCase must be a case of enum $U with data
// %1 will be of address type $*T for the data type of case U.DataCase
</pre></div>
</div>
<p>Projects the address of the data for an enum <code class="docutils literal"><span class="pre">case</span></code> inside an enum. This
does not modify the enum or check its value. It is intended to be used as
part of the initialization sequence for an address-only enum. Storing to
the <code class="docutils literal"><span class="pre">init_enum_data_addr</span></code> for a case followed by <code class="docutils literal"><span class="pre">inject_enum_addr</span></code> with that
same case is guaranteed to result in a fully-initialized enum value of that
case being stored. Loading from the <code class="docutils literal"><span class="pre">init_enum_data_addr</span></code> of an initialized
enum value or injecting a mismatched case tag is undefined behavior.</p>
<p>The address is invalidated as soon as the operand enum is fully initialized by
an <code class="docutils literal"><span class="pre">inject_enum_addr</span></code>.</p>
</div>
<div class="section" id="inject-enum-addr">
<h4><a class="toc-backref" href="#id128">inject_enum_addr</a><a class="headerlink" href="#inject-enum-addr" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;inject_enum_addr&#39; sil-operand &#39;,&#39; sil-decl-ref

inject_enum_addr %0 : $*U, #U.Case
// $U must be an enum type
// #U.Case must be a case of enum $U
// %0 will be overlaid with the tag for #U.Case
</pre></div>
</div>
<p>Initializes the enum value referenced by the given address by overlaying the
tag for the given case. If the case has no data, this instruction is sufficient
to initialize the enum value. If the case has data, the data must be stored
into the enum at the <code class="docutils literal"><span class="pre">init_enum_data_addr</span></code> address for the case <em>before</em>
<code class="docutils literal"><span class="pre">inject_enum_addr</span></code> is applied. It is undefined behavior if
<code class="docutils literal"><span class="pre">inject_enum_addr</span></code> is applied for a case with data to an uninitialized enum,
or if <code class="docutils literal"><span class="pre">inject_enum_addr</span></code> is applied for a case with data when data for a
mismatched case has been stored to the enum.</p>
</div>
<div class="section" id="unchecked-take-enum-data-addr">
<h4><a class="toc-backref" href="#id129">unchecked_take_enum_data_addr</a><a class="headerlink" href="#unchecked-take-enum-data-addr" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;unchecked_take_enum_data_addr&#39; sil-operand &#39;,&#39; sil-decl-ref

%1 = unchecked_take_enum_data_addr %0 : $*U, #U.DataCase
// $U must be an enum type
// #U.DataCase must be a case of enum $U with data
// %1 will be of address type $*T for the data type of case U.DataCase
</pre></div>
</div>
<p>Invalidates an enum value, and takes the address of the payload for the given
enum <code class="docutils literal"><span class="pre">case</span></code> in-place in memory. The referenced enum value is no longer valid,
but the payload value referenced by the result address is valid and must be
destroyed. It is undefined behavior if the referenced enum does not contain a
value of the given <code class="docutils literal"><span class="pre">case</span></code>. The result shares memory with the original enum
value; the enum memory cannot be reinitialized as an enum until the payload has
also been invalidated.</p>
<p>(1.0 only)</p>
<p>For the first payloaded case of an enum, <code class="docutils literal"><span class="pre">unchecked_take_enum_data_addr</span></code>
is guaranteed to have no side effects; the enum value will not be invalidated.</p>
</div>
<div class="section" id="select-enum">
<h4><a class="toc-backref" href="#id130">select_enum</a><a class="headerlink" href="#select-enum" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;select_enum&#39; sil-operand sil-select-case*
                    (&#39;,&#39; &#39;default&#39; sil-value)?
                    &#39;:&#39; sil-type

%n = select_enum %0 : $U,      \
  case #U.Case1: %1,           \
  case #U.Case2: %2, /* ... */ \
  default %3 : $T

// $U must be an enum type
// #U.Case1, Case2, etc. must be cases of enum $U
// %1, %2, %3, etc. must have type $T
// %n has type $T
</pre></div>
</div>
<p>Selects one of the &#8220;case&#8221; or &#8220;default&#8221; operands based on the case of an
enum value. This is equivalent to a trivial <a class="reference internal" href="#switch-enum">switch_enum</a> branch sequence:</p>
<div class="highlight-python"><div class="highlight"><pre>entry:
  switch_enum %0 : $U,            \
    case #U.Case1: bb1,           \
    case #U.Case2: bb2, /* ... */ \
    default bb_default
bb1:
  br cont(%1 : $T) // value for #U.Case1
bb2:
  br cont(%2 : $T) // value for #U.Case2
bb_default:
  br cont(%3 : $T) // value for default
cont(%n : $T):
  // use argument %n
</pre></div>
</div>
<p>but turns the control flow dependency into a data flow dependency.
For address-only enums, <a class="reference internal" href="#select-enum-addr">select_enum_addr</a> offers the same functionality for
an indirectly referenced enum value in memory.</p>
</div>
<div class="section" id="select-enum-addr">
<h4><a class="toc-backref" href="#id131">select_enum_addr</a><a class="headerlink" href="#select-enum-addr" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;select_enum_addr&#39; sil-operand sil-select-case*
                    (&#39;,&#39; &#39;default&#39; sil-value)?
                    &#39;:&#39; sil-type

%n = select_enum_addr %0 : $*U,      \
  case #U.Case1: %1,           \
  case #U.Case2: %2, /* ... */ \
  default %3 : $T

// %0 must be the address of an enum type $*U
// #U.Case1, Case2, etc. must be cases of enum $U
// %1, %2, %3, etc. must have type $T
// %n has type $T
</pre></div>
</div>
<p>Selects one of the &#8220;case&#8221; or &#8220;default&#8221; operands based on the case of the
referenced enum value. This is the address-only counterpart to
<a class="reference internal" href="#select-enum">select_enum</a>.</p>
</div>
</div>
<div class="section" id="protocol-and-protocol-composition-types">
<h3><a class="toc-backref" href="#id132">Protocol and Protocol Composition Types</a><a class="headerlink" href="#protocol-and-protocol-composition-types" title="Permalink to this headline">¶</a></h3>
<p>These instructions create and manipulate values of protocol and protocol
composition type.  From SIL&#8217;s perspective, protocol and protocol composition
types consist of an <em>existential container</em>, which is a generic container for
a value of unknown runtime type, referred to as an &#8220;existential type&#8221; in type
theory. The existential container consists of a reference to the
<em>witness table(s)</em> for the protocol(s) referred to by the protocol type and a
reference to the underlying <em>concrete value</em>, which may be either stored
in-line inside the existential container for small values or allocated
separately into a buffer owned and managed by the existential container for
larger values.</p>
<p>Depending on the constraints applied to an existential type, an existential
container may use one of several representations:</p>
<ul class="simple">
<li><strong>Opaque existential containers</strong>: If none of the protocols in a protocol
type are class protocols, then the existential container for that type is
address-only and referred to in the implementation as an <em>opaque existential
container</em>. The value semantics of the existential container propagate to the
contained concrete value. Applying <code class="docutils literal"><span class="pre">copy_addr</span></code> to an opaque existential
container copies the contained concrete value, deallocating or reallocating
the destination container&#8217;s owned buffer if necessary. Applying
<code class="docutils literal"><span class="pre">destroy_addr</span></code> to an opaque existential container destroys the concrete
value and deallocates any buffers owned by the existential container. The
following instructions manipulate opaque existential containers:<ul>
<li><a class="reference internal" href="#init-existential-addr">init_existential_addr</a></li>
<li><a class="reference internal" href="#open-existential-addr">open_existential_addr</a></li>
<li><a class="reference internal" href="#deinit-existential-addr">deinit_existential_addr</a></li>
</ul>
</li>
<li><strong>Class existential containers</strong>: If a protocol type is constrained by one or
more class protocols, then the existential container for that type is
loadable and referred to in the implementation as a <em>class existential
container</em>. Class existential containers have reference semantics and can be
<code class="docutils literal"><span class="pre">retain</span></code>-ed and <code class="docutils literal"><span class="pre">release</span></code>-d. The following instructions manipulate class
existential containers:<ul>
<li><a class="reference internal" href="#init-existential-ref">init_existential_ref</a></li>
<li><a class="reference internal" href="#open-existential-ref">open_existential_ref</a></li>
</ul>
</li>
<li><strong>Metatype existential containers</strong>: Existential metatypes use a
container consisting of the type metadata for the conforming type along with
the protocol conformances. Metatype existential containers are trivial types.
The following instructions manipulate metatype existential containers:<ul>
<li><a class="reference internal" href="#init-existential-metatype">init_existential_metatype</a></li>
<li><a class="reference internal" href="#open-existential-metatype">open_existential_metatype</a></li>
</ul>
</li>
<li><strong>Boxed existential containers</strong>: The standard library <code class="docutils literal"><span class="pre">ErrorType</span></code> protocol
uses a size-optimized reference-counted container, which indirectly stores
the conforming value. Boxed existential containers can be <code class="docutils literal"><span class="pre">retain</span></code>-ed
and <code class="docutils literal"><span class="pre">release</span></code>-d. The following instructions manipulate boxed existential
containers:<ul>
<li><a class="reference internal" href="#alloc-existential-box">alloc_existential_box</a></li>
<li><a class="reference internal" href="#open-existential-box">open_existential_box</a></li>
<li><a class="reference internal" href="#dealloc-existential-box">dealloc_existential_box</a></li>
</ul>
</li>
</ul>
<p>Some existential types may additionally support specialized representations
when they contain certain known concrete types. For example, when Objective-C
interop is available, the <code class="docutils literal"><span class="pre">ErrorType</span></code> protocol existential supports
a class existential container representation for <code class="docutils literal"><span class="pre">NSError</span></code> objects, so it
can be initialized from one using <code class="docutils literal"><span class="pre">init_existential_ref</span></code> instead of the
more expensive <code class="docutils literal"><span class="pre">alloc_existential_box</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>bb(%nserror: $NSError):
  // The slow general way to form an ErrorType, allocating a box and
  // storing to its value buffer:
  %error1 = alloc_existential_box $ErrorType, $NSError
  strong_retain %nserror: $NSError
  store %nserror to %error1#1 : $NSError

  // The fast path supported for NSError:
  strong_retain %nserror: $NSError
  %error2 = init_existential_ref %nserror: $NSError, $ErrorType
</pre></div>
</div>
<div class="section" id="init-existential-addr">
<h4><a class="toc-backref" href="#id133">init_existential_addr</a><a class="headerlink" href="#init-existential-addr" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;init_existential_addr&#39; sil-operand &#39;,&#39; sil-type

%1 = init_existential_addr %0 : $*P, $T
// %0 must be of a $*P address type for non-class protocol or protocol
//   composition type P
// $T must be an AST type that fulfills protocol(s) P
// %1 will be of type $*T&#39;, where T&#39; is the maximally abstract lowering
//    of type T
</pre></div>
</div>
<p>Partially initializes the memory referenced by <code class="docutils literal"><span class="pre">%0</span></code> with an existential
container prepared to contain a value of type <code class="docutils literal"><span class="pre">$T</span></code>. The result of the
instruction is an address referencing the storage for the contained value, which
remains uninitialized. The contained value must be <code class="docutils literal"><span class="pre">store</span></code>-d or
<code class="docutils literal"><span class="pre">copy_addr</span></code>-ed to in order for the existential value to be fully initialized.
If the existential container needs to be destroyed while the contained value
is uninitialized, <code class="docutils literal"><span class="pre">deinit_existential_addr</span></code> must be used to do so. A fully
initialized existential container can be destroyed with <code class="docutils literal"><span class="pre">destroy_addr</span></code> as
usual. It is undefined behavior to <code class="docutils literal"><span class="pre">destroy_addr</span></code> a partially-initialized
existential container.</p>
</div>
<div class="section" id="deinit-existential-addr">
<h4><a class="toc-backref" href="#id134">deinit_existential_addr</a><a class="headerlink" href="#deinit-existential-addr" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;deinit_existential_addr&#39; sil-operand

deinit_existential_addr %0 : $*P
// %0 must be of a $*P address type for non-class protocol or protocol
// composition type P
</pre></div>
</div>
<p>Undoes the partial initialization performed by
<code class="docutils literal"><span class="pre">init_existential_addr</span></code>.  <code class="docutils literal"><span class="pre">deinit_existential_addr</span></code> is only valid for
existential containers that have been partially initialized by
<code class="docutils literal"><span class="pre">init_existential_addr</span></code> but haven&#8217;t had their contained value initialized.
A fully initialized existential must be destroyed with <code class="docutils literal"><span class="pre">destroy_addr</span></code>.</p>
</div>
<div class="section" id="open-existential-addr">
<h4><a class="toc-backref" href="#id135">open_existential_addr</a><a class="headerlink" href="#open-existential-addr" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;open_existential_addr&#39; sil-operand &#39;to&#39; sil-type

%1 = open_existential_addr %0 : $*P to $*@opened P
// %0 must be of a $*P type for non-class protocol or protocol composition
//   type P
// $*@opened P must be a unique archetype that refers to an opened
// existential type P.
// %1 will be of type $*P
</pre></div>
</div>
<p>Obtains the address of the concrete value inside the existential
container referenced by <code class="docutils literal"><span class="pre">%0</span></code>. The protocol conformances associated
with this existential container are associated directly with the
archetype <code class="docutils literal"><span class="pre">$*&#64;opened</span> <span class="pre">P</span></code>. This pointer can be used with any operation
on archetypes, such as <code class="docutils literal"><span class="pre">witness_method</span></code>.</p>
</div>
<div class="section" id="init-existential-ref">
<h4><a class="toc-backref" href="#id136">init_existential_ref</a><a class="headerlink" href="#init-existential-ref" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;init_existential_ref&#39; sil-operand &#39;:&#39; sil-type &#39;,&#39;
                                           sil-type

%1 = init_existential_ref %0 : $C&#39; : $C, $P
// %0 must be of class type $C&#39;, lowered from AST type $C, conforming to
//    protocol(s) $P
// $P must be a class protocol or protocol composition type
// %1 will be of type $P
</pre></div>
</div>
<p>Creates a class existential container of type <code class="docutils literal"><span class="pre">$P</span></code> containing a reference to
the class instance <code class="docutils literal"><span class="pre">%0</span></code>.</p>
</div>
<div class="section" id="open-existential-ref">
<h4><a class="toc-backref" href="#id137">open_existential_ref</a><a class="headerlink" href="#open-existential-ref" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;open_existential_ref&#39; sil-operand &#39;to&#39; sil-type

%1 = open_existential_ref %0 : $P to $@opened P
// %0 must be of a $P type for a class protocol or protocol composition
// $@opened P must be a unique archetype that refers to an opened
//   existential type P
// %1 will be of type $@opened P
</pre></div>
</div>
<p>Extracts the class instance reference from a class existential
container. The protocol conformances associated with this existential
container are associated directly with the archetype <code class="docutils literal"><span class="pre">&#64;opened</span> <span class="pre">P</span></code>. This
pointer can be used with any operation on archetypes, such as
<code class="docutils literal"><span class="pre">witness_method</span></code>. When the operand is of metatype type, the result
will be the metatype of the opened archetype.</p>
</div>
<div class="section" id="init-existential-metatype">
<h4><a class="toc-backref" href="#id138">init_existential_metatype</a><a class="headerlink" href="#init-existential-metatype" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;init_existential_metatype&#39; sil-operand &#39;,&#39; sil-type

%1 = init_existential_metatype $0 : $@&lt;rep&gt; T.Type, $@&lt;rep&gt; P.Type
// %0 must be of a metatype type $@&lt;rep&gt; T.Type where T: P
// %@&lt;rep&gt; P.Type must be the existential metatype of a protocol or protocol
//    composition, with the same metatype representation &lt;rep&gt;
// %1 will be of type $@&lt;rep&gt; P.Type
</pre></div>
</div>
<p>Creates a metatype existential container of type <code class="docutils literal"><span class="pre">$P.Type</span></code> containing the
conforming metatype of <code class="docutils literal"><span class="pre">$T</span></code>.</p>
</div>
<div class="section" id="open-existential-metatype">
<h4><a class="toc-backref" href="#id139">open_existential_metatype</a><a class="headerlink" href="#open-existential-metatype" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;open_existential_metatype&#39; sil-operand &#39;to&#39; sil-type

%1 = open_existential_metatype %0 : $@&lt;rep&gt; P.Type to $@&lt;rep&gt; (@opened P).Type
// %0 must be of a $P.Type existential metatype for a protocol or protocol
//    composition
// $@&lt;rep&gt; (@opened P).Type must be the metatype of a unique archetype that
//   refers to an opened existential type P, with the same metatype
//   representation &lt;rep&gt;
// %1 will be of type $@&lt;rep&gt; (@opened P).Type
</pre></div>
</div>
<p>Extracts the metatype from an existential metatype. The protocol conformances associated with this existential
container are associated directly with the archetype <code class="docutils literal"><span class="pre">&#64;opened</span> <span class="pre">P</span></code>.</p>
</div>
<div class="section" id="alloc-existential-box">
<h4><a class="toc-backref" href="#id140">alloc_existential_box</a><a class="headerlink" href="#alloc-existential-box" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;alloc_existential_box&#39; sil-type &#39;,&#39; sil-type

%1 = alloc_existential_box $P, $T
// $P must be a protocol or protocol composition type with boxed
//   representation
// $T must be an AST type that conforms to P
// %1#0 will be of type $P
// %1#1 will be of type $*T&#39;, where T&#39; is the most abstracted lowering of T
</pre></div>
</div>
<p>Allocates a boxed existential container of type <code class="docutils literal"><span class="pre">$P</span></code> with space to hold a
value of type <code class="docutils literal"><span class="pre">$T'</span></code>. The box is not fully initialized until a valid value
has been stored into the box. If the box must be deallocated before it is
fully initialized, <code class="docutils literal"><span class="pre">dealloc_existential_box</span></code> must be used. A fully
initialized box can be <code class="docutils literal"><span class="pre">retain</span></code>-ed and <code class="docutils literal"><span class="pre">release</span></code>-d like any
reference-counted type.  The address <code class="docutils literal"><span class="pre">%0#1</span></code> is dependent on the lifetime of
the owner reference <code class="docutils literal"><span class="pre">%0#0</span></code>.</p>
</div>
<div class="section" id="open-existential-box">
<h4><a class="toc-backref" href="#id141">open_existential_box</a><a class="headerlink" href="#open-existential-box" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;open_existential_box&#39; sil-operand &#39;to&#39; sil-type

%1 = open_existential_box %0 : $P to $*@opened P
// %0 must be a value of boxed protocol or protocol composition type $P
// %@opened P must be the address type of a unique archetype that refers to
///   an opened existential type P
// %1 will be of type $*@opened P
</pre></div>
</div>
<p>Projects the address of the value inside a boxed existential container, and
uses the enclosed type and protocol conformance metadata to bind the
opened archetype <code class="docutils literal"><span class="pre">$&#64;opened</span> <span class="pre">P</span></code>. The result address is dependent on both
the owning box and the enclosing function; in order to &#8220;open&#8221; a boxed
existential that has directly adopted a class reference, temporary scratch
space may need to have been allocated.</p>
</div>
<div class="section" id="dealloc-existential-box">
<h4><a class="toc-backref" href="#id142">dealloc_existential_box</a><a class="headerlink" href="#dealloc-existential-box" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;dealloc_existential_box&#39; sil-operand, sil-type

dealloc_existential_box %0 : $P, $T
// %0 must be an uninitialized box of boxed existential container type $P
// $T must be the AST type for which the box was allocated
</pre></div>
</div>
<p>Deallocates a boxed existential container. The value inside the existential
buffer is not destroyed; either the box must be uninitialized, or the value
must have been projected out and destroyed beforehand. It is undefined behavior
if the concrete type <code class="docutils literal"><span class="pre">$T</span></code> is not the same type for which the box was
allocated with <code class="docutils literal"><span class="pre">alloc_existential_box</span></code>.</p>
</div>
</div>
<div class="section" id="blocks">
<h3><a class="toc-backref" href="#id143">Blocks</a><a class="headerlink" href="#blocks" title="Permalink to this headline">¶</a></h3>
<div class="section" id="project-block-storage">
<h4><a class="toc-backref" href="#id144">project_block_storage</a><a class="headerlink" href="#project-block-storage" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;project_block_storage&#39; sil-operand &#39;:&#39; sil-type
</pre></div>
</div>
</div>
<div class="section" id="init-block-storage-header">
<h4><a class="toc-backref" href="#id145">init_block_storage_header</a><a class="headerlink" href="#init-block-storage-header" title="Permalink to this headline">¶</a></h4>
<p><em>TODO</em> Fill this in. The printing of this instruction looks incomplete on trunk currently.</p>
</div>
</div>
<div class="section" id="unchecked-conversions">
<h3><a class="toc-backref" href="#id146">Unchecked Conversions</a><a class="headerlink" href="#unchecked-conversions" title="Permalink to this headline">¶</a></h3>
<p>These instructions implement type conversions which are not checked. These are
either user-level conversions that are always safe and do not need to be
checked, or implementation detail conversions that are unchecked for
performance or flexibility.</p>
<div class="section" id="upcast">
<h4><a class="toc-backref" href="#id147">upcast</a><a class="headerlink" href="#upcast" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;upcast&#39; sil-operand &#39;to&#39; sil-type

%1 = upcast %0 : $D to $B
// $D and $B must be class types or metatypes, with B a superclass of D
// %1 will have type $B
</pre></div>
</div>
<p>Represents a conversion from a derived class instance or metatype to a
superclass, or from a base-class-constrained archetype to its base class.</p>
</div>
<div class="section" id="address-to-pointer">
<h4><a class="toc-backref" href="#id148">address_to_pointer</a><a class="headerlink" href="#address-to-pointer" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;address_to_pointer&#39; sil-operand &#39;to&#39; sil-type

%1 = address_to_pointer %0 : $*T to $Builtin.RawPointer
// %0 must be of an address type $*T
// %1 will be of type Builtin.RawPointer
</pre></div>
</div>
<p>Creates a <code class="docutils literal"><span class="pre">Builtin.RawPointer</span></code> value corresponding to the address <code class="docutils literal"><span class="pre">%0</span></code>.
Converting the result pointer back to an address of the same type will give
an address equivalent to <code class="docutils literal"><span class="pre">%0</span></code>. It is undefined behavior to cast the
<code class="docutils literal"><span class="pre">RawPointer</span></code> to any address type other than its original address type or
any <a class="reference internal" href="#layout-compatible-types">layout compatible types</a>.</p>
</div>
<div class="section" id="pointer-to-address">
<h4><a class="toc-backref" href="#id149">pointer_to_address</a><a class="headerlink" href="#pointer-to-address" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;pointer_to_address&#39; sil-operand &#39;to&#39; sil-type

%1 = pointer_to_address %0 : $Builtin.RawPointer to $*T
// %1 will be of type $*T
</pre></div>
</div>
<p>Creates an address value corresponding to the <code class="docutils literal"><span class="pre">Builtin.RawPointer</span></code> value
<code class="docutils literal"><span class="pre">%0</span></code>.  Converting a <code class="docutils literal"><span class="pre">RawPointer</span></code> back to an address of the same type as
its originating <code class="docutils literal"><span class="pre">address_to_pointer</span></code> instruction gives back an equivalent
address. It is undefined behavior to cast the <code class="docutils literal"><span class="pre">RawPointer</span></code> back to any type
other than its original address type or <a class="reference internal" href="#layout-compatible-types">layout compatible types</a>. It is
also undefined behavior to cast a <code class="docutils literal"><span class="pre">RawPointer</span></code> from a heap object to any
address type.</p>
</div>
<div class="section" id="unchecked-ref-cast">
<h4><a class="toc-backref" href="#id150">unchecked_ref_cast</a><a class="headerlink" href="#unchecked-ref-cast" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;unchecked_ref_cast&#39; sil-operand &#39;to&#39; sil-type

%1 = unchecked_ref_cast %0 : $A to $B
// %0 must be an object of type $A
// $A must be a type with retainable pointer representation
// %1 will be of type $B
// $B must be a type with retainable pointer representation
</pre></div>
</div>
<p>Converts a heap object reference to another heap object reference
type. This conversion is unchecked, and it is undefined behavior if
the destination type is not a valid type for the heap object. The heap
object reference on either side of the cast may be a class
existential, and may be wrapped in one level of Optional.</p>
</div>
<div class="section" id="unchecked-ref-cast-addr">
<h4><a class="toc-backref" href="#id151">unchecked_ref_cast_addr</a><a class="headerlink" href="#unchecked-ref-cast-addr" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;unchecked_ref_cast_addr&#39;
                    sil-type &#39;in&#39; sil-operand &#39;to&#39;
                    sil-type &#39;in&#39; sil-operand

unchecked_ref_cast_addr $A in %0 : $*A to $B in %1 : $*B
// %0 must be the address of an object of type $A
// $A must be a type with retainable pointer representation
// %1 must be the address of storage for an object of type $B
// $B must be a retainable pointer representation
</pre></div>
</div>
<p>Loads a heap object reference from an address and stores it at the
address of another uninitialized heap object reference. The loaded
reference is always taken, and the stored reference is
initialized. This conversion is unchecked, and it is undefined
behavior if the destination type is not a valid type for the heap
object. The heap object reference on either side of the cast may be a
class existential, and may be wrapped in one level of Optional.</p>
</div>
<div class="section" id="unchecked-addr-cast">
<h4><a class="toc-backref" href="#id152">unchecked_addr_cast</a><a class="headerlink" href="#unchecked-addr-cast" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;unchecked_addr_cast&#39; sil-operand &#39;to&#39; sil-type

%1 = unchecked_addr_cast %0 : $*A to $*B
// %0 must be an address
// %1 will be of type $*B
</pre></div>
</div>
<p>Converts an address to a different address type. Using the resulting
address is undefined unless <code class="docutils literal"><span class="pre">B</span></code> is layout compatible with <code class="docutils literal"><span class="pre">A</span></code>. The
layout of <code class="docutils literal"><span class="pre">A</span></code> may be smaller than that of <code class="docutils literal"><span class="pre">B</span></code> as long as the lower
order bytes have identical layout.</p>
</div>
<div class="section" id="unchecked-trivial-bit-cast">
<h4><a class="toc-backref" href="#id153">unchecked_trivial_bit_cast</a><a class="headerlink" href="#unchecked-trivial-bit-cast" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;unchecked_trivial_bit_cast&#39; sil-operand &#39;to&#39; sil-type

%1 = unchecked_trivial_bit_cast %0 : $Builtin.NativeObject to $Builtin.Word
// %0 must be an object.
// %1 must be an object with trivial type.
</pre></div>
</div>
<p>Bitcasts an object of type <code class="docutils literal"><span class="pre">A</span></code> to be of same sized or smaller type
<code class="docutils literal"><span class="pre">B</span></code> with the constraint that <code class="docutils literal"><span class="pre">B</span></code> must be trivial. This can be used
for bitcasting among trivial types, but more importantly is a one way
bitcast from non-trivial types to trivial types.</p>
</div>
<div class="section" id="unchecked-bitwise-cast">
<h4><a class="toc-backref" href="#id154">unchecked_bitwise_cast</a><a class="headerlink" href="#unchecked-bitwise-cast" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;unchecked_bitwise_cast&#39; sil-operand &#39;to&#39; sil-type

%1 = unchecked_bitwise_cast %0 : $A to $B
</pre></div>
</div>
<p>Bitwise copies an object of type <code class="docutils literal"><span class="pre">A</span></code> into a new object of type <code class="docutils literal"><span class="pre">B</span></code>
of the same size or smaller.</p>
</div>
<div class="section" id="ref-to-raw-pointer">
<h4><a class="toc-backref" href="#id155">ref_to_raw_pointer</a><a class="headerlink" href="#ref-to-raw-pointer" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;ref_to_raw_pointer&#39; sil-operand &#39;to&#39; sil-type

%1 = ref_to_raw_pointer %0 : $C to $Builtin.RawPointer
// $C must be a class type, or Builtin.ObjectPointer, or Builtin.ObjCPointer
// %1 will be of type $Builtin.RawPointer
</pre></div>
</div>
<p>Converts a heap object reference to a <code class="docutils literal"><span class="pre">Builtin.RawPointer</span></code>. The <code class="docutils literal"><span class="pre">RawPointer</span></code>
result can be cast back to the originating class type but does not have
ownership semantics. It is undefined behavior to cast a <code class="docutils literal"><span class="pre">RawPointer</span></code> from a
heap object reference to an address using <code class="docutils literal"><span class="pre">pointer_to_address</span></code>.</p>
</div>
<div class="section" id="raw-pointer-to-ref">
<h4><a class="toc-backref" href="#id156">raw_pointer_to_ref</a><a class="headerlink" href="#raw-pointer-to-ref" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;raw_pointer_to_ref&#39; sil-operand &#39;to&#39; sil-type

%1 = raw_pointer_to_ref %0 : $Builtin.RawPointer to $C
// $C must be a class type, or Builtin.ObjectPointer, or Builtin.ObjCPointer
// %1 will be of type $C
</pre></div>
</div>
<p>Converts a <code class="docutils literal"><span class="pre">Builtin.RawPointer</span></code> back to a heap object reference. Casting
a heap object reference to <code class="docutils literal"><span class="pre">Builtin.RawPointer</span></code> back to the same type gives
an equivalent heap object reference (though the raw pointer has no ownership
semantics for the object on its own). It is undefined behavior to cast a
<code class="docutils literal"><span class="pre">RawPointer</span></code> to a type unrelated to the dynamic type of the heap object.
It is also undefined behavior to cast a <code class="docutils literal"><span class="pre">RawPointer</span></code> from an address to any
heap object type.</p>
</div>
<div class="section" id="ref-to-unowned">
<h4><a class="toc-backref" href="#id157">ref_to_unowned</a><a class="headerlink" href="#ref-to-unowned" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;ref_to_unowned&#39; sil-operand

%1 = unowned_to_ref %0 : T
// $T must be a reference type
// %1 will have type $@unowned T
</pre></div>
</div>
<p>Adds the <code class="docutils literal"><span class="pre">&#64;unowned</span></code> qualifier to the type of a reference to a heap
object.  No runtime effect.</p>
</div>
<div class="section" id="unowned-to-ref">
<h4><a class="toc-backref" href="#id158">unowned_to_ref</a><a class="headerlink" href="#unowned-to-ref" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;unowned_to_ref&#39; sil-operand

%1 = unowned_to_ref %0 : $@unowned T
// $T must be a reference type
// %1 will have type $T
</pre></div>
</div>
<p>Strips the <code class="docutils literal"><span class="pre">&#64;unowned</span></code> qualifier off the type of a reference to a
heap object.  No runtime effect.</p>
</div>
<div class="section" id="ref-to-unmanaged">
<h4><a class="toc-backref" href="#id159">ref_to_unmanaged</a><a class="headerlink" href="#ref-to-unmanaged" title="Permalink to this headline">¶</a></h4>
<p>TODO</p>
</div>
<div class="section" id="unmanaged-to-ref">
<h4><a class="toc-backref" href="#id160">unmanaged_to_ref</a><a class="headerlink" href="#unmanaged-to-ref" title="Permalink to this headline">¶</a></h4>
<p>TODO</p>
</div>
<div class="section" id="convert-function">
<h4><a class="toc-backref" href="#id161">convert_function</a><a class="headerlink" href="#convert-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;convert_function&#39; sil-operand &#39;to&#39; sil-type

%1 = convert_function %0 : $T -&gt; U to $T&#39; -&gt; U&#39;
// %0 must be of a function type $T -&gt; U ABI-compatible with $T&#39; -&gt; U&#39;
//   (see below)
// %1 will be of type $T&#39; -&gt; U&#39;
</pre></div>
</div>
<p>Performs a conversion of the function <code class="docutils literal"><span class="pre">%0</span></code> to type <code class="docutils literal"><span class="pre">T</span></code>, which must be ABI-
compatible with the type of <code class="docutils literal"><span class="pre">%0</span></code>. Function types are ABI-compatible if their
input and result types are tuple types that, after destructuring, differ only
in the following ways:</p>
<ul class="simple">
<li>Corresponding tuple elements may add, remove, or change keyword names.
<code class="docutils literal"><span class="pre">(a:Int,</span> <span class="pre">b:Float,</span> <span class="pre">UnicodeScalar)</span> <span class="pre">-&gt;</span> <span class="pre">()</span></code> and <code class="docutils literal"><span class="pre">(x:Int,</span> <span class="pre">Float,</span> <span class="pre">z:UnicodeScalar)</span> <span class="pre">-&gt;</span> <span class="pre">()</span></code> are
ABI compatible.</li>
<li>A class tuple element of the destination type may be a superclass or
subclass of the source type&#8217;s corresponding tuple element.</li>
</ul>
<p>The function types may also differ in attributes, with the following
caveats:</p>
<ul class="simple">
<li>The <code class="docutils literal"><span class="pre">convention</span></code> attribute cannot be changed.</li>
<li>A <code class="docutils literal"><span class="pre">&#64;noreturn</span></code> function may be converted to a non-<code class="docutils literal"><span class="pre">&#64;noreturn</span></code>
type and vice-versa.</li>
</ul>
</div>
<div class="section" id="thin-function-to-pointer">
<h4><a class="toc-backref" href="#id162">thin_function_to_pointer</a><a class="headerlink" href="#thin-function-to-pointer" title="Permalink to this headline">¶</a></h4>
<p>TODO</p>
</div>
<div class="section" id="pointer-to-thin-function">
<h4><a class="toc-backref" href="#id163">pointer_to_thin_function</a><a class="headerlink" href="#pointer-to-thin-function" title="Permalink to this headline">¶</a></h4>
<p>TODO</p>
</div>
<div class="section" id="ref-to-bridge-object">
<h4><a class="toc-backref" href="#id164">ref_to_bridge_object</a><a class="headerlink" href="#ref-to-bridge-object" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;ref_to_bridge_object&#39; sil-operand, sil-operand

%2 = ref_to_bridge_object %0 : $C, %1 : $Builtin.Word
// %1 must be of reference type $C
// %2 will be of type Builtin.BridgeObject
</pre></div>
</div>
<p>Creates a <code class="docutils literal"><span class="pre">Builtin.BridgeObject</span></code> that references <code class="docutils literal"><span class="pre">%0</span></code>, with spare bits
in the pointer representation populated by bitwise-OR-ing in the value of
<code class="docutils literal"><span class="pre">%1</span></code>. It is undefined behavior if this bitwise OR operation affects the
reference identity of <code class="docutils literal"><span class="pre">%0</span></code>; in other words, after the following instruction
sequence:</p>
<div class="highlight-python"><div class="highlight"><pre>%b = ref_to_bridge_object %r : $C, %w : $Builtin.Word
%r2 = bridge_object_to_ref %b : $Builtin.BridgeObject to $C
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">%r</span></code> and <code class="docutils literal"><span class="pre">%r2</span></code> must be equivalent. In particular, it is assumed that
retaining or releasing the <code class="docutils literal"><span class="pre">BridgeObject</span></code> is equivalent to retaining or
releasing the original reference, and that the above <code class="docutils literal"><span class="pre">ref_to_bridge_object</span></code>
/ <code class="docutils literal"><span class="pre">bridge_object_to_ref</span></code> round-trip can be folded away to a no-op.</p>
<p>On platforms with ObjC interop, there is additionally a platform-specific
bit in the pointer representation of a <code class="docutils literal"><span class="pre">BridgeObject</span></code> that is reserved to
indicate whether the referenced object has native Swift refcounting. It is
undefined behavior to set this bit when the first operand references an
Objective-C object.</p>
</div>
<div class="section" id="bridge-object-to-ref">
<h4><a class="toc-backref" href="#id165">bridge_object_to_ref</a><a class="headerlink" href="#bridge-object-to-ref" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;bridge_object_to_ref&#39; sil-operand &#39;to&#39; sil-type

%1 = bridge_object_to_ref %0 : $Builtin.BridgeObject to $C
// $C must be a reference type
// %1 will be of type $C
</pre></div>
</div>
<p>Extracts the object reference from a <code class="docutils literal"><span class="pre">Builtin.BridgeObject</span></code>, masking out any
spare bits.</p>
</div>
<div class="section" id="bridge-object-to-word">
<h4><a class="toc-backref" href="#id166">bridge_object_to_word</a><a class="headerlink" href="#bridge-object-to-word" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;bridge_object_to_word&#39; sil-operand &#39;to&#39; sil-type

%1 = bridge_object_to_word %0 : $Builtin.BridgeObject to $Builtin.Word
// %1 will be of type $Builtin.Word
</pre></div>
</div>
<p>Provides the bit pattern of a <code class="docutils literal"><span class="pre">Builtin.BridgeObject</span></code> as an integer.</p>
</div>
<div class="section" id="thin-to-thick-function">
<h4><a class="toc-backref" href="#id167">thin_to_thick_function</a><a class="headerlink" href="#thin-to-thick-function" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;thin_to_thick_function&#39; sil-operand &#39;to&#39; sil-type

%1 = thin_to_thick_function %0 : $@convention(thin) T -&gt; U to $T -&gt; U
// %0 must be of a thin function type $@convention(thin) T -&gt; U
// The destination type must be the corresponding thick function type
// %1 will be of type $T -&gt; U
</pre></div>
</div>
<p>Converts a thin function value, that is, a bare function pointer with no
context information, into a thick function value with ignored context.
Applying the resulting thick function value is equivalent to applying the
original thin value. The <code class="docutils literal"><span class="pre">thin_to_thick_function</span></code> conversion may be
eliminated if the context is proven not to be needed.</p>
</div>
<div class="section" id="thick-to-objc-metatype">
<h4><a class="toc-backref" href="#id168">thick_to_objc_metatype</a><a class="headerlink" href="#thick-to-objc-metatype" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;thick_to_objc_metatype&#39; sil-operand &#39;to&#39; sil-type

%1 = thick_to_objc_metatype %0 : $@thick T.metatype to $@objc_metatype T.metatype
// %0 must be of a thick metatype type $@thick T.metatype
// The destination type must be the corresponding Objective-C metatype type
// %1 will be of type $@objc_metatype T.metatype
</pre></div>
</div>
<p>Converts a thick metatype to an Objective-C class metatype. <code class="docutils literal"><span class="pre">T</span></code> must
be of class, class protocol, or class protocol composition type.</p>
</div>
<div class="section" id="objc-to-thick-metatype">
<h4><a class="toc-backref" href="#id169">objc_to_thick_metatype</a><a class="headerlink" href="#objc-to-thick-metatype" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;objc_to_thick_metatype&#39; sil-operand &#39;to&#39; sil-type

%1 = objc_to_thick_metatype %0 : $@objc_metatype T.metatype to $@thick T.metatype
// %0 must be of an Objective-C metatype type $@objc_metatype T.metatype
// The destination type must be the corresponding thick metatype type
// %1 will be of type $@thick T.metatype
</pre></div>
</div>
<p>Converts an Objective-C class metatype to a thick metatype. <code class="docutils literal"><span class="pre">T</span></code> must
be of class, class protocol, or class protocol composition type.</p>
</div>
<div class="section" id="objc-metatype-to-object">
<h4><a class="toc-backref" href="#id170">objc_metatype_to_object</a><a class="headerlink" href="#objc-metatype-to-object" title="Permalink to this headline">¶</a></h4>
<p>TODO</p>
</div>
<div class="section" id="objc-existential-metatype-to-object">
<h4><a class="toc-backref" href="#id171">objc_existential_metatype_to_object</a><a class="headerlink" href="#objc-existential-metatype-to-object" title="Permalink to this headline">¶</a></h4>
<p>TODO</p>
</div>
<div class="section" id="is-nonnull">
<h4><a class="toc-backref" href="#id172">is_nonnull</a><a class="headerlink" href="#is-nonnull" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;is_nonnull&#39; sil-operand

%1 = is_nonnull %0 : $C
// %0 must be of reference or function type $C
// %1 will be of type Builtin.Int1
</pre></div>
</div>
<p>Checks whether a reference type value is null, returning 1 if
the value is not null, or 0 if it is null.  If the value is a function
type, it checks the function pointer (not the data pointer) for null.</p>
<p>This is not a sensical thing for SIL to represent given that reference
types are non-nullable, but makes sense at the machine level.  This is
a horrible hack that should go away someday.</p>
</div>
</div>
<div class="section" id="checked-conversions">
<h3><a class="toc-backref" href="#id173">Checked Conversions</a><a class="headerlink" href="#checked-conversions" title="Permalink to this headline">¶</a></h3>
<p>Some user-level cast operations can fail and thus require runtime checking.</p>
<p>The <a class="reference internal" href="#unconditional-checked-cast-addr">unconditional_checked_cast_addr</a> and <a class="reference internal" href="#unconditional-checked-cast">unconditional_checked_cast</a>
instructions performs an unconditional checked cast; it is a runtime failure
if the cast fails. The <a class="reference internal" href="#checked-cast-addr-br">checked_cast_addr_br</a> and <a class="reference internal" href="#checked-cast-br">checked_cast_br</a>
terminator instruction performs a conditional checked cast; it branches to one
of two destinations based on whether the cast succeeds or not.</p>
<div class="section" id="unconditional-checked-cast">
<h4><a class="toc-backref" href="#id174">unconditional_checked_cast</a><a class="headerlink" href="#unconditional-checked-cast" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;unconditional_checked_cast&#39; sil-operand &#39;to&#39; sil-type

%1 = unconditional_checked_cast %0 : $A to $B
%1 = unconditional_checked_cast %0 : $*A to $*B
// $A and $B must be both objects or both addresses
// %1 will be of type $B or $*B
</pre></div>
</div>
<p>Performs a checked scalar conversion, causing a runtime failure if the
conversion fails.</p>
</div>
<div class="section" id="unconditional-checked-cast-addr">
<h4><a class="toc-backref" href="#id175">unconditional_checked_cast_addr</a><a class="headerlink" href="#unconditional-checked-cast-addr" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;unconditional_checked_cast_addr&#39;
                     sil-cast-consumption-kind
                     sil-type &#39;in&#39; sil-operand &#39;to&#39;
                     sil-type &#39;in&#39; sil-operand
sil-cast-consumption-kind ::= &#39;take_always&#39;
sil-cast-consumption-kind ::= &#39;take_on_success&#39;
sil-cast-consumption-kind ::= &#39;copy_on_success&#39;

%1 = unconditional_checked_cast_addr take_on_success $A in %0 : $*@thick A to $B in $*@thick B
// $A and $B must be both addresses
// %1 will be of type $*B
</pre></div>
</div>
<p>Performs a checked indirect conversion, causing a runtime failure if the
conversion fails.</p>
</div>
</div>
<div class="section" id="runtime-failures">
<h3><a class="toc-backref" href="#id176">Runtime Failures</a><a class="headerlink" href="#runtime-failures" title="Permalink to this headline">¶</a></h3>
<div class="section" id="cond-fail">
<h4><a class="toc-backref" href="#id177">cond_fail</a><a class="headerlink" href="#cond-fail" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;cond_fail&#39; sil-operand

cond_fail %0 : $Builtin.Int1
// %0 must be of type $Builtin.Int1
</pre></div>
</div>
<p>This instruction produces a <a class="reference internal" href="#runtime-failure">runtime failure</a> if the operand is one.
Execution proceeds normally if the operand is zero.</p>
</div>
</div>
<div class="section" id="terminators">
<h3><a class="toc-backref" href="#id178">Terminators</a><a class="headerlink" href="#terminators" title="Permalink to this headline">¶</a></h3>
<p>These instructions terminate a basic block. Every basic block must end
with a terminator. Terminators may only appear as the final instruction of
a basic block.</p>
<div class="section" id="unreachable">
<h4><a class="toc-backref" href="#id179">unreachable</a><a class="headerlink" href="#unreachable" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-terminator ::= &#39;unreachable&#39;

unreachable
</pre></div>
</div>
<p>Indicates that control flow must not reach the end of the current basic block.
It is a dataflow error if an unreachable terminator is reachable from the entry
point of a function and is not immediately preceded by an <code class="docutils literal"><span class="pre">apply</span></code> of a
<code class="docutils literal"><span class="pre">&#64;noreturn</span></code> function.</p>
</div>
<div class="section" id="return">
<h4><a class="toc-backref" href="#id180">return</a><a class="headerlink" href="#return" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-terminator ::= &#39;return&#39; sil-operand

return %0 : $T
// $T must be the return type of the current function
</pre></div>
</div>
<p>Exits the current function and returns control to the calling function. If
the current function was invoked with an <code class="docutils literal"><span class="pre">apply</span></code> instruction, the result
of that function will be the operand of this <code class="docutils literal"><span class="pre">return</span></code> instruction. If
the current function was invoked with a <code class="docutils literal"><span class="pre">try_apply`</span> <span class="pre">instruction,</span> <span class="pre">control</span>
<span class="pre">resumes</span> <span class="pre">at</span> <span class="pre">the</span> <span class="pre">normal</span> <span class="pre">destination,</span> <span class="pre">and</span> <span class="pre">the</span> <span class="pre">value</span> <span class="pre">of</span> <span class="pre">the</span> <span class="pre">basic</span> <span class="pre">block</span> <span class="pre">argument</span>
<span class="pre">will</span> <span class="pre">be</span> <span class="pre">the</span> <span class="pre">operand</span> <span class="pre">of</span> <span class="pre">this</span> <span class="pre">``return</span></code> instruction.</p>
<p><code class="docutils literal"><span class="pre">return</span></code> does not retain or release its operand or any other values.</p>
<p>A function must not contain more than one <code class="docutils literal"><span class="pre">return</span></code> instruction.</p>
</div>
<div class="section" id="throw">
<h4><a class="toc-backref" href="#id181">throw</a><a class="headerlink" href="#throw" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-terminator ::= &#39;throw&#39; sil-operand

throw %0 : $T
// $T must be the error result type of the current function
</pre></div>
</div>
<p>Exits the current function and returns control to the calling
function. The current function must have an error result, and so the
function must have been invoked with a <code class="docutils literal"><span class="pre">try_apply`</span> <span class="pre">instruction.</span>
<span class="pre">Control</span> <span class="pre">will</span> <span class="pre">resume</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">error</span> <span class="pre">destination</span> <span class="pre">of</span> <span class="pre">that</span> <span class="pre">instruction,</span> <span class="pre">and</span>
<span class="pre">the</span> <span class="pre">basic</span> <span class="pre">block</span> <span class="pre">argument</span> <span class="pre">will</span> <span class="pre">be</span> <span class="pre">the</span> <span class="pre">operand</span> <span class="pre">of</span> <span class="pre">the</span> <span class="pre">``throw</span></code>.</p>
<p><code class="docutils literal"><span class="pre">throw</span></code> does not retain or release its operand or any other values.</p>
<p>A function must not contain more than one <code class="docutils literal"><span class="pre">throw</span></code> instruction.</p>
</div>
<div class="section" id="br">
<h4><a class="toc-backref" href="#id182">br</a><a class="headerlink" href="#br" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-terminator ::= &#39;br&#39; sil-identifier
                     &#39;(&#39; (sil-operand (&#39;,&#39; sil-operand)*)? &#39;)&#39;

br label (%0 : $A, %1 : $B, ...)
// `label` must refer to a basic block label within the current function
// %0, %1, etc. must be of the types of `label`&#39;s arguments
</pre></div>
</div>
<p>Unconditionally transfers control from the current basic block to the block
labeled <code class="docutils literal"><span class="pre">label</span></code>, binding the given values to the arguments of the destination
basic block.</p>
</div>
<div class="section" id="cond-br">
<h4><a class="toc-backref" href="#id183">cond_br</a><a class="headerlink" href="#cond-br" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-terminator ::= &#39;cond_br&#39; sil-operand &#39;,&#39;
                     sil-identifier &#39;(&#39; (sil-operand (&#39;,&#39; sil-operand)*)? &#39;)&#39; &#39;,&#39;
                     sil-identifier &#39;(&#39; (sil-operand (&#39;,&#39; sil-operand)*)? &#39;)&#39;

cond_br %0 : $Builtin.Int1, true_label (%a : $A, %b : $B, ...), \
                               false_label (%x : $X, %y : $Y, ...)
// %0 must be of $Builtin.Int1 type
// `true_label` and `false_label` must refer to block labels within the
//   current function and must not be identical
// %a, %b, etc. must be of the types of `true_label`&#39;s arguments
// %x, %y, etc. must be of the types of `false_label`&#39;s arguments
</pre></div>
</div>
<p>Conditionally branches to <code class="docutils literal"><span class="pre">true_label</span></code> if <code class="docutils literal"><span class="pre">%0</span></code> is equal to <code class="docutils literal"><span class="pre">1</span></code> or to
<code class="docutils literal"><span class="pre">false_label</span></code> if <code class="docutils literal"><span class="pre">%0</span></code> is equal to <code class="docutils literal"><span class="pre">0</span></code>, binding the corresponding set of
values to the arguments of the chosen destination block.</p>
</div>
<div class="section" id="switch-value">
<h4><a class="toc-backref" href="#id184">switch_value</a><a class="headerlink" href="#switch-value" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-terminator ::= &#39;switch_value&#39; sil-operand
                     (&#39;,&#39; sil-switch-value-case)*
                     (&#39;,&#39; sil-switch-default)?
sil-switch-value-case ::= &#39;case&#39; sil-value &#39;:&#39; sil-identifier
sil-switch-default ::= &#39;default&#39; sil-identifier

switch_value %0 : $Builtin.Int&lt;n&gt;, case %1: label1, \
                                   case %2: label2, \
                                   ...,            \
                                   default labelN

// %0 must be a value of builtin integer type $Builtin.Int&lt;n&gt;
// `label1` through `labelN` must refer to block labels within the current
//   function
// FIXME: All destination labels currently must take no arguments
</pre></div>
</div>
<p>Conditionally branches to one of several destination basic blocks based on a
value of builtin integer or function type. If the operand value matches one of the <code class="docutils literal"><span class="pre">case</span></code>
values of the instruction, control is transferred to the corresponding basic
block. If there is a <code class="docutils literal"><span class="pre">default</span></code> basic block, control is transferred to it if
the value does not match any of the <code class="docutils literal"><span class="pre">case</span></code> values. It is undefined behavior
if the value does not match any cases and no <code class="docutils literal"><span class="pre">default</span></code> branch is provided.</p>
</div>
<div class="section" id="select-value">
<h4><a class="toc-backref" href="#id185">select_value</a><a class="headerlink" href="#select-value" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-instruction ::= &#39;select_value&#39; sil-operand sil-select-value-case*
                    (&#39;,&#39; &#39;default&#39; sil-value)?
                    &#39;:&#39; sil-type
sil-selct-value-case ::= &#39;case&#39; sil-value &#39;:&#39; sil-value


%n = select_value %0 : $U, \
  case %c1: %r1,           \
  case %c2: %r2, /* ... */ \
  default %r3 : $T

// $U must be a builtin type. Only integers types are supported currently.
// c1, c2, etc must be of type $U
// %r1, %r2, %r3, etc. must have type $T
// %n has type $T
</pre></div>
</div>
<p>Selects one of the &#8220;case&#8221; or &#8220;default&#8221; operands based on the case of an
value. This is equivalent to a trivial <a class="reference internal" href="#switch-value">switch_value</a> branch sequence:</p>
<div class="highlight-python"><div class="highlight"><pre>entry:
  switch_value %0 : $U,            \
    case %c1: bb1,           \
    case %c2: bb2, /* ... */ \
    default bb_default
bb1:
  br cont(%r1 : $T) // value for %c1
bb2:
  br cont(%r2 : $T) // value for %c2
bb_default:
  br cont(%r3 : $T) // value for default
cont(%n : $T):
  // use argument %n
</pre></div>
</div>
<p>but turns the control flow dependency into a data flow dependency.</p>
</div>
<div class="section" id="switch-enum">
<h4><a class="toc-backref" href="#id186">switch_enum</a><a class="headerlink" href="#switch-enum" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-terminator ::= &#39;switch_enum&#39; sil-operand
                     (&#39;,&#39; sil-switch-enum-case)*
                     (&#39;,&#39; sil-switch-default)?
sil-switch-enum-case ::= &#39;case&#39; sil-decl-ref &#39;:&#39; sil-identifier

switch_enum %0 : $U, case #U.Foo: label1, \
                      case #U.Bar: label2, \
                      ...,                 \
                      default labelN

// %0 must be a value of enum type $U
// #U.Foo, #U.Bar, etc. must be &#39;case&#39; declarations inside $U
// `label1` through `labelN` must refer to block labels within the current
//   function
// label1 must take either no basic block arguments, or a single argument
//   of the type of #U.Foo&#39;s data
// label2 must take either no basic block arguments, or a single argument
//   of the type of #U.Bar&#39;s data, etc.
// labelN must take no basic block arguments
</pre></div>
</div>
<p>Conditionally branches to one of several destination basic blocks based on the
discriminator in a loadable <code class="docutils literal"><span class="pre">enum</span></code> value. Unlike <code class="docutils literal"><span class="pre">switch_int</span></code>,
<code class="docutils literal"><span class="pre">switch_enum</span></code> requires coverage of the operand type: If the <code class="docutils literal"><span class="pre">enum</span></code> type
is resilient, the <code class="docutils literal"><span class="pre">default</span></code> branch is required; if the <code class="docutils literal"><span class="pre">enum</span></code> type is
fragile, the <code class="docutils literal"><span class="pre">default</span></code> branch is required unless a destination is assigned to
every <code class="docutils literal"><span class="pre">case</span></code> of the <code class="docutils literal"><span class="pre">enum</span></code>. The destination basic block for a <code class="docutils literal"><span class="pre">case</span></code> may
take an argument of the corresponding <code class="docutils literal"><span class="pre">enum</span></code> <code class="docutils literal"><span class="pre">case</span></code>&#8216;s data type (or of the
address type, if the operand is an address). If the branch is taken, the
destination&#8217;s argument will be bound to the associated data inside the
original enum value.  For example:</p>
<div class="highlight-python"><div class="highlight"><pre>enum Foo {
  case Nothing
  case OneInt(Int)
  case TwoInts(Int, Int)
}

sil @sum_of_foo : $Foo -&gt; Int {
entry(%x : $Foo):
  switch_enum %x : $Foo,       \
    case #Foo.Nothing: nothing, \
    case #Foo.OneInt:  one_int, \
    case #Foo.TwoInts: two_ints

nothing:
  %zero = integer_literal 0 : $Int
  return %zero : $Int

one_int(%y : $Int):
  return %y : $Int

two_ints(%ab : $(Int, Int)):
  %a = tuple_extract %ab : $(Int, Int), 0
  %b = tuple_extract %ab : $(Int, Int), 1
  %add = function_ref @add : $(Int, Int) -&gt; Int
  %result = apply %add(%a, %b) : $(Int, Int) -&gt; Int
  return %result : $Int
}
</pre></div>
</div>
<p>On a path dominated by a destination block of <code class="docutils literal"><span class="pre">switch_enum</span></code>, copying or
destroying the basic block argument has equivalent reference counting semantics
to copying or destroying the <code class="docutils literal"><span class="pre">switch_enum</span></code> operand:</p>
<div class="highlight-python"><div class="highlight"><pre>  // This retain_value...
  retain_value %e1 : $Enum
  switch_enum %e1, case #Enum.A: a, case #Enum.B: b
a(%a : $A):
  // ...is balanced by this release_value
  release_value %a
b(%b : $B):
  // ...and this one
  release_value %b
</pre></div>
</div>
</div>
<div class="section" id="switch-enum-addr">
<h4><a class="toc-backref" href="#id187">switch_enum_addr</a><a class="headerlink" href="#switch-enum-addr" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-terminator ::= &#39;switch_enum_addr&#39; sil-operand
                     (&#39;,&#39; sil-switch-enum-case)*
                     (&#39;,&#39; sil-switch-default)?

switch_enum_addr %0 : $*U, case #U.Foo: label1, \
                                        case #U.Bar: label2, \
                                        ...,                 \
                                        default labelN

// %0 must be the address of an enum type $*U
// #U.Foo, #U.Bar, etc. must be cases of $U
// `label1` through `labelN` must refer to block labels within the current
//   function
// The destinations must take no basic block arguments
</pre></div>
</div>
<p>Conditionally branches to one of several destination basic blocks based on
the discriminator in the enum value referenced by the address operand.</p>
<p>Unlike <code class="docutils literal"><span class="pre">switch_int</span></code>, <code class="docutils literal"><span class="pre">switch_enum</span></code> requires coverage of the operand type:
If the <code class="docutils literal"><span class="pre">enum</span></code> type is resilient, the <code class="docutils literal"><span class="pre">default</span></code> branch is required; if the
<code class="docutils literal"><span class="pre">enum</span></code> type is fragile, the <code class="docutils literal"><span class="pre">default</span></code> branch is required unless a
destination is assigned to every <code class="docutils literal"><span class="pre">case</span></code> of the <code class="docutils literal"><span class="pre">enum</span></code>.
Unlike <code class="docutils literal"><span class="pre">switch_enum</span></code>, the payload value is not passed to the destination
basic blocks; it must be projected out separately with <a class="reference internal" href="#unchecked-take-enum-data-addr">unchecked_take_enum_data_addr</a>.</p>
</div>
<div class="section" id="dynamic-method-br">
<h4><a class="toc-backref" href="#id188">dynamic_method_br</a><a class="headerlink" href="#dynamic-method-br" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-terminator ::= &#39;dynamic_method_br&#39; sil-operand &#39;,&#39; sil-decl-ref
                     &#39;,&#39; sil-identifier &#39;,&#39; sil-identifier

dynamic_method_br %0 : $P, #X.method!1, bb1, bb2
// %0 must be of protocol type
// #X.method!1 must be a reference to an @objc method of any class
// or protocol type
</pre></div>
</div>
<p>Looks up the implementation of an Objective-C method with the same
selector as the named method for the dynamic type of the value inside
an existential container. The &#8220;self&#8221; operand of the result function
value is represented using an opaque type, the value for which must be
projected out as a value of type <code class="docutils literal"><span class="pre">Builtin.ObjCPointer</span></code>.</p>
<p>If the operand is determined to have the named method, this
instruction branches to <code class="docutils literal"><span class="pre">bb1</span></code>, passing it the uncurried function
corresponding to the method found. If the operand does not have the
named method, this instruction branches to <code class="docutils literal"><span class="pre">bb2</span></code>.</p>
</div>
<div class="section" id="checked-cast-br">
<h4><a class="toc-backref" href="#id189">checked_cast_br</a><a class="headerlink" href="#checked-cast-br" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-terminator ::= &#39;checked_cast_br&#39; sil-checked-cast-exact?
                    sil-operand &#39;to&#39; sil-type &#39;,&#39;
                    sil-identifier &#39;,&#39; sil-identifier
sil-checked-cast-exact ::= &#39;[&#39; &#39;exact&#39; &#39;]&#39;

checked_cast_br %0 : $A to $B, bb1, bb2
checked_cast_br %0 : $*A to $*B, bb1, bb2
checked_cast_br [exact] %0 : $A to $A, bb1, bb2
// $A and $B must be both object types or both address types
// bb1 must take a single argument of type $B or $*B
// bb2 must take no arguments
</pre></div>
</div>
<p>Performs a checked scalar conversion from <code class="docutils literal"><span class="pre">$A</span></code> to <code class="docutils literal"><span class="pre">$B</span></code>. If the conversion
succeeds, control is transferred to <code class="docutils literal"><span class="pre">bb1</span></code>, and the result of the cast is
passed into <code class="docutils literal"><span class="pre">bb1</span></code> as an argument. If the conversion fails, control is
transferred to <code class="docutils literal"><span class="pre">bb2</span></code>.</p>
<p>An exact cast checks whether the dynamic type is exactly the target
type, not any possible subtype of it.  The source and target types
must be class types.</p>
</div>
<div class="section" id="checked-cast-addr-br">
<h4><a class="toc-backref" href="#id190">checked_cast_addr_br</a><a class="headerlink" href="#checked-cast-addr-br" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-terminator ::= &#39;checked_cast_addr_br&#39;
                    sil-cast-consumption-kind
                    sil-type &#39;in&#39; sil-operand &#39;to&#39;
                    sil-stype &#39;in&#39; sil-operand &#39;,&#39;
                    sil-identifier &#39;,&#39; sil-identifier
sil-cast-consumption-kind ::= &#39;take_always&#39;
sil-cast-consumption-kind ::= &#39;take_on_success&#39;
sil-cast-consumption-kind ::= &#39;copy_on_success&#39;

checked_cast_addr_br take_always $A in %0 : $*@thick A to $B in %2 : $*@thick B, bb1, bb2
// $A and $B must be both address types
// bb1 must take a single argument of type $*B
// bb2 must take no arguments
</pre></div>
</div>
<p>Performs a checked indirect conversion from <code class="docutils literal"><span class="pre">$A</span></code> to <code class="docutils literal"><span class="pre">$B</span></code>. If the
conversion succeeds, control is transferred to <code class="docutils literal"><span class="pre">bb1</span></code>, and the result of the
cast is left in the destination. If the conversion fails, control is
transferred to <code class="docutils literal"><span class="pre">bb2</span></code>.</p>
</div>
<div class="section" id="try-apply">
<h4><a class="toc-backref" href="#id191">try_apply</a><a class="headerlink" href="#try-apply" title="Permalink to this headline">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre>sil-terminator ::= &#39;try_apply&#39; sil-value
                      sil-apply-substitution-list?
                      &#39;(&#39; (sil-value (&#39;,&#39; sil-value)*)? &#39;)&#39;
                      &#39;:&#39; sil-type
  &#39;normal&#39; sil-identifier, &#39;error&#39; sil-identifier

try_apply %0(%1, %2, ...) : $(A, B, ...) -&gt; (R, @error E),
  normal bb1, error bb2
bb1(%3 : R):
bb2(%4 : E):

// Note that the type of the callee &#39;%0&#39; is specified *after* the arguments
// %0 must be of a concrete function type $(A, B, ...) -&gt; (R, @error E)
// %1, %2, etc. must be of the argument types $A, $B, etc.
</pre></div>
</div>
<p>Transfers control to the function specified by <code class="docutils literal"><span class="pre">%0</span></code>, passing it the
given arguments.  When <code class="docutils literal"><span class="pre">%0</span></code> returns, control resumes in either the
normal destination (if it returns with <code class="docutils literal"><span class="pre">return</span></code>) or the error
destination (if it returns with <code class="docutils literal"><span class="pre">throw</span></code>).</p>
<p><code class="docutils literal"><span class="pre">%0</span></code> must have a function type with an error result.</p>
<p>The rules on generic substitutions are identical to those of <code class="docutils literal"><span class="pre">apply</span></code>.</p>
</div>
</div>
<div class="section" id="assertion-configuration">
<h3><a class="toc-backref" href="#id192">Assertion configuration</a><a class="headerlink" href="#assertion-configuration" title="Permalink to this headline">¶</a></h3>
<p>To be able to support disabling assertions at compile time there is a builtin
<code class="docutils literal"><span class="pre">assertion_configuration</span></code> function. A call to this function can be replaced at
compile time by a constant or can stay opaque.</p>
<p>All calls to the <code class="docutils literal"><span class="pre">assert_configuration</span></code> function are replaced by the constant
propagation pass to the appropriate constant depending on compile time settings.
Subsequent passes remove dependent unwanted control flow. Using this mechanism
we support conditionally enabling/disabling of code in SIL libraries depending
on the assertion configuration selected when the library is linked into user
code.</p>
<p>There are three assertion configurations: Debug (0), Release (1) and
DisableReplacement (-1).</p>
<p>The optimization flag or a special assert configuration flag determines the
value. Depending on the configuration value assertions in the standard library
will be executed or not.</p>
<p>The standard library uses this builtin to define an assert that can be
disabled at compile time.</p>
<div class="highlight-python"><div class="highlight"><pre>func assert(...) {
  if (Int32(Builtin.assert_configuration()) == 0) {
    _fatal_error_message(message, ...)
  }
}
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">assert_configuration</span></code> function application is serialized when we build
the standard library (we recognize the <code class="docutils literal"><span class="pre">-parse-stdlib</span></code> option and don&#8217;t do the
constant replacement but leave the function application to be serialized to
sil).</p>
<p>The compiler flag that influences the value of the <code class="docutils literal"><span class="pre">assert_configuration</span></code>
function application is the optimization flag: at <code class="docutils literal"><span class="pre">-Onone`</span> <span class="pre">the</span> <span class="pre">application</span> <span class="pre">will</span>
<span class="pre">be</span> <span class="pre">replaced</span> <span class="pre">by</span> <span class="pre">``Debug</span></code> at higher optimization levels the instruction will be
replaced by <code class="docutils literal"><span class="pre">Release</span></code>. Optionally, the value to use for replacement can be
specified with the <code class="docutils literal"><span class="pre">-AssertConf</span></code> flag which overwrites the value selected by
the optimization flag (possible values are <code class="docutils literal"><span class="pre">Debug</span></code>, <code class="docutils literal"><span class="pre">Release</span></code>,
<code class="docutils literal"><span class="pre">DisableReplacement</span></code>).</p>
<p>If the call to the <code class="docutils literal"><span class="pre">assert_configuration</span></code> function stays opaque until IRGen,
IRGen will replace the application by the constant representing Debug mode (0).
This happens we can build the standard library .dylib. The generate sil will
retain the function call but the generated .dylib will contain code with
assertions enabled.</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="TypeChecker.html" class="btn btn-neutral float-right" title="Type Checker Design and Implementation" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="StoredAndComputedVariables.html" class="btn btn-neutral" title="Stored and Computed Variables" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright apple.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.1.9',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>