

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Initialization &mdash; Swift Programming Language documentation 0.1.9 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Swift Programming Language documentation 0.1.9 documentation" href="../index.html"/>
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>


  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Swift Programming Language documentation
          

          
          </a>

          
            
            
              <div class="version">
                0.1.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">swift docs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../ABI.html">The Swift ABI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ARCOptimization.html">ARC Optimization for Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="../AccessControl.html">Access Control</a></li>
<li class="toctree-l1"><a class="reference internal" href="../AccessControlInStdlib.html">Scope and introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../AccessControlInStdlib.html#public"><cite>public</cite></a></li>
<li class="toctree-l1"><a class="reference internal" href="../AccessControlInStdlib.html#internal"><cite>internal</cite></a></li>
<li class="toctree-l1"><a class="reference internal" href="../AccessControlInStdlib.html#private"><cite>private</cite></a></li>
<li class="toctree-l1"><a class="reference internal" href="../AccessControlInStdlib.html#leading-underscore-rule">Leading Underscore Rule</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Arrays.html">The Swift Array Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CallingConvention.html">The Swift Calling Convention</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DebuggingTheCompiler.html">Debugging the Swift Compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Dependency Analysis.html">Dependency Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DriverInternals.html">Driver Design &amp; Internals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DriverParseableOutput.html">Parseable Driver Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ErrorHandling.html">Error Handling in Swift 2.0</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ErrorHandlingRationale.html">Error Handling Rationale and Proposal</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Failable Initializers.html">Failable initializers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Generics.html">Generics in Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="../GitWorkflows.html">Git Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../GitWorkflows.html#svn-git-workflows">SVN -&gt; GIT Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HighLevelSILOptimizations.html">High-Level Optimizations in SIL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Import.html">IMPORT SYNTAX</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Import.html#resolving-name-clashes">RESOLVING NAME CLASHES</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Import.html#future-extensions">FUTURE EXTENSIONS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../IndexInvalidation.html">Index Invalidation Rules in the Swift Standard Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#using-versioned-api">Using Versioned API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#publishing-versioned-api">Publishing Versioned API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#giving-up-flexibility">Giving Up Flexibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#optimization">Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#resilience-domains">Resilience Domains</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#protocol-conformances">Protocol Conformances</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#checking-binary-compatibility">Checking Binary Compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#summary">Summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#glossary">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Literals.html">Literals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LogicalObjects.html">Logical Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Modules.html">High-Level Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Modules.html#import"><code class="docutils literal"><span class="pre">import</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../Modules.html#interoperability-with-objective-c-via-clang">Interoperability with Objective-C via Clang</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Modules.html#glossary">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../MutationModel.html">Immutability and Read-Only Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ObjectInitialization.html">Object Initialization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html">Writing High-Performance Swift Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#enabling-optimizations">Enabling Optimizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#whole-module-optimizations">Whole Module Optimizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#reducing-dynamic-dispatch">Reducing Dynamic Dispatch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#using-container-types-efficiently">Using Container Types Efficiently</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#unchecked-operations">Unchecked operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#generics">Generics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#the-cost-of-large-swift-values">The cost of large swift values</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#unsafe-code">Unsafe code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#protocols">Protocols</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#footnotes">Footnotes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Pattern Matching.html">Pattern Matching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SIL.html">Swift Intermediate Language (SIL)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SequencesAndCollections.html">Sequences And Collections in Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Serialization.html">Swift Binary Serialization Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="../StdlibAPIGuidelines.html">Swift Standard Library API Design Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../StdlibRationales.html">Rationales for the Swift standard library designs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../StoredAndComputedVariables.html">Stored and Computed Variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../StringDesign.html">Swift String Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Testing.html">Testing Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="../TextFormatting.html">Text Formatting in Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="../TransparentAttr.html"><code class="docutils literal"><span class="pre">&#64;_transparent</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../TypeChecker.html">Type Checker Design and Implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contents.html">Contents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../weak.html">Weak References</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">Swift Programming Language documentation</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
    <li>Initialization</li>
    <li class="wy-breadcrumbs-aside">
      
        
          <a href="../_sources/proposals/Initialization.txt" rel="nofollow"> View page source</a>
        
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="initialization">
<h1><a class="toc-backref" href="#id1">Initialization</a><a class="headerlink" href="#initialization" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#initialization" id="id1">Initialization</a><ul>
<li><a class="reference internal" href="#superclass-delegation" id="id2">Superclass Delegation</a></li>
<li><a class="reference internal" href="#peer-delegation" id="id3">Peer Delegation</a></li>
<li><a class="reference internal" href="#initializer-inheritance" id="id4">Initializer Inheritance</a></li>
<li><a class="reference internal" href="#virtual-initializers" id="id5">Virtual Initializers</a></li>
<li><a class="reference internal" href="#initializers-in-protocols" id="id6">Initializers in Protocols</a></li>
<li><a class="reference internal" href="#objective-c-interoperability" id="id7">Objective-C Interoperability</a><ul>
<li><a class="reference internal" href="#objective-c-entrypoints" id="id8">Objective-C Entrypoints</a></li>
<li><a class="reference internal" href="#objective-c-restrictions" id="id9">Objective-C Restrictions</a></li>
<li><a class="reference internal" href="#remaining-soundness-holes" id="id10">Remaining Soundness Holes</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="superclass-delegation">
<h2><a class="toc-backref" href="#id2">Superclass Delegation</a><a class="headerlink" href="#superclass-delegation" title="Permalink to this headline">¶</a></h2>
<p>The initializer for a class that has a superclass must ensure that its
superclass subobject gets initialized. The typical way to do so is
through the use of superclass delegation:</p>
<div class="highlight-python"><div class="highlight"><pre>class A {
  var x: Int

  init(x: Int) {
    self.x = x
  }
}

class B : A {
  var value: String

  init() {
    value = &quot;Hello&quot;
    super.init(5) // superclass delegation
  }
}
</pre></div>
</div>
<p>Swift implements two-phase initialization, which requires that all of
the instance variables of the subclass be initialized (either within
the class or within the initializer) before delegating to the
superclass initializer with <code class="docutils literal"><span class="pre">super.init</span></code>.</p>
<p>If the superclass is a Swift class, superclass delegation is a direct
call to the named initializer in the superclass. If the superclass is
an Objective-C class, superclass delegation uses dynamic dispatch via
<code class="docutils literal"><span class="pre">objc_msgSendSuper</span></code> (and its variants).</p>
</div>
<div class="section" id="peer-delegation">
<h2><a class="toc-backref" href="#id3">Peer Delegation</a><a class="headerlink" href="#peer-delegation" title="Permalink to this headline">¶</a></h2>
<p>An initializer can delegate to one of its peer initializers, which
then takes responsibility for initializing this subobject and any
superclass subobjects:</p>
<div class="highlight-python"><div class="highlight"><pre>extension A {
  init fromString(s: String) {
    self.init(Int(s)) // peer delegation to init(Int)
  }
}
</pre></div>
</div>
<p>One cannot access any of the instance variables of <code class="docutils literal"><span class="pre">self</span></code> nor invoke
any instance methods on <code class="docutils literal"><span class="pre">self</span></code> before delegating to the peer
initializer, because the object has not yet been
constructed. Additionally, one cannot initialize the instance
variables of <code class="docutils literal"><span class="pre">self</span></code>, prior to delegating to the peer, because doing
so would lead to double initializations.</p>
<p>Peer delegation is always a direct call to the named initializer, and
always calls an initializer defined for the same type as the
delegating initializer. Despite the syntactic similarities, this is
very different from Objective-C&#8217;s <code class="docutils literal"><span class="pre">[self</span> <span class="pre">init...]</span></code>, which can call
methods in either the superclass or subclass.</p>
<p>Peer delegation is primarily useful when providing convenience
initializers without having to duplicate initialization code. However,
peer delegation is also the only viable way to implement an
initializer for a type within an extension that resides in a different
resilience domain than the definition of the type itself. For example,
consider the following extension of <code class="docutils literal"><span class="pre">A</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>extension A {
  init(i: Int, j: Int) {
    x = i + j    // initialize x
  }
}
</pre></div>
</div>
<p>If this extension is in a different resilience domain than the
definition of <code class="docutils literal"><span class="pre">A</span></code>, there is no way to ensure that this initializer
is initializing all of the instance variables of <code class="docutils literal"><span class="pre">A</span></code>: new instance
variables could be added to <code class="docutils literal"><span class="pre">A</span></code> in a future version (these would not
be properly initialized) and existing instance variables could become
computed properties (these would be initialized when they shouldn&#8217;t
be).</p>
</div>
<div class="section" id="initializer-inheritance">
<h2><a class="toc-backref" href="#id4">Initializer Inheritance</a><a class="headerlink" href="#initializer-inheritance" title="Permalink to this headline">¶</a></h2>
<p>Initializers are <em>not</em> inherited by default. Each subclass takes
responsibility for its own initialization by declaring the
initializers one can use to create it. To make a superclass&#8217;s
initializer available in a subclass, one can re-declare the
initializer and then use superclass delegation to call it:</p>
<div class="highlight-python"><div class="highlight"><pre>class C : A {
  var value = &quot;Hello&quot;

  init(x: Int) {
    super.init(x) // superclass delegation
  }
}
</pre></div>
</div>
<p>Although <code class="docutils literal"><span class="pre">C</span></code>&#8216;s initializer has the same parameters as <code class="docutils literal"><span class="pre">A</span></code>&#8216;s
initializer, it does not &#8220;override&#8221; <code class="docutils literal"><span class="pre">A</span></code>&#8216;s initializer because there
is no dynamic dispatch for initializers (but see below).</p>
<p>We could syntax-optimize initializer inheritance if this becomes
onerous. DaveA provides a reasonable suggestion:</p>
<div class="highlight-python"><div class="highlight"><pre>class C : A {
  var value = &quot;Hello&quot;

  @inherit init(Int)
}
</pre></div>
</div>
<p><em>Note</em>: one can only inherit an initializer into a class <code class="docutils literal"><span class="pre">C</span></code> if all
of the instance variables in that class have in-class initializers.</p>
</div>
<div class="section" id="virtual-initializers">
<h2><a class="toc-backref" href="#id5">Virtual Initializers</a><a class="headerlink" href="#virtual-initializers" title="Permalink to this headline">¶</a></h2>
<p>The initializer model above only safely permits initialization when we
statically know the type of the complete object being initialized. For
example, this permits the construction <code class="docutils literal"><span class="pre">A(5)</span></code> but not the
following:</p>
<div class="highlight-python"><div class="highlight"><pre>func createAnA(aClass: A.metatype) -&gt; A {
  return aClass(5) // error: no complete initializer accepting an ``Int``
}
</pre></div>
</div>
<p>The issue here is that, while <code class="docutils literal"><span class="pre">A</span></code> has an initializer accepting an
<code class="docutils literal"><span class="pre">Int</span></code>, it&#8217;s not guaranteed that an arbitrary subclass of <code class="docutils literal"><span class="pre">A</span></code> will
have such an initializer. Even if we had that guarantee, there
wouldn&#8217;t necessarily be any way to call the initializer, because (as
noted above), there is no dynamic dispatch for initializers.</p>
<p>This is an unacceptable limitation for a few reasons. The most obvious
reason is that <code class="docutils literal"><span class="pre">NSCoding</span></code> depends on dynamic dispatch to
<code class="docutils literal"><span class="pre">-initWithCoder:</span></code> to deserialize an object of a class type that is
dynamically determined, and Swift classes must safely support this
paradigm. To address this limitation, we can add the <code class="docutils literal"><span class="pre">virtual</span></code>
attribute to turn an initializer into a virtual initializer:</p>
<div class="highlight-python"><div class="highlight"><pre>class A {
  @virtual init(x: Int) { ... }
}
</pre></div>
</div>
<p>Virtual initializers can be invoked when constructing an object using
an arbitrary value of metatype type (as in the <code class="docutils literal"><span class="pre">createAnA</span></code> example
above), using dynamic dispatch. Therefore, we need to ensure that a
virtual initializer is always a complete object initializer, which
requires that every subclass provide a definition for each virtual
initializer defined in its superclass. For example, the following
class definition would be ill-formed:</p>
<div class="highlight-python"><div class="highlight"><pre>class D : A {
  var floating: Double
}
</pre></div>
</div>
<p>because <code class="docutils literal"><span class="pre">D</span></code> does not provide an initializer accepting an <code class="docutils literal"><span class="pre">Int</span></code>. To
address this issue, one would add:</p>
<div class="highlight-python"><div class="highlight"><pre>class D : A {
  var floating: Double

  @virtual init(x: Int) {
    floating = 3.14159
    super.init(x)
  }
}
</pre></div>
</div>
<p>As a convenience, the compiler could synthesize virtual initializer
definitions when all of the instance variables in the subclass have
in-class initializers:</p>
<div class="highlight-python"><div class="highlight"><pre>class D2 : A {
  var floating = 3.14159

  /* compiler-synthesized */
  @virtual init(x: Int) {
    super.init(x)
  }
}
</pre></div>
</div>
<p>This looks a lot like inherited initializers, and can eliminate some
boilerplate for simple subclasses. The primary downside is that the
synthesized implementation might not be the right one, e.g., it will
almost surely be wrong for an inherited <code class="docutils literal"><span class="pre">-initWithCoder:</span></code>. I don&#8217;t
think this is worth doing.</p>
<p><em>Note</em>: as a somewhat unfortunate side effect of the terminology, the
initializers for structs and enums are considered to be virtual,
because they are guaranteed to be complete object initializers. If
this bothers us, we could use the term (and attribute) &#8220;complete&#8221;
instead of &#8220;virtual&#8221;. I&#8217;d prefer to stick with &#8220;virtual&#8221; and accept
the corner case.</p>
</div>
<div class="section" id="initializers-in-protocols">
<h2><a class="toc-backref" href="#id6">Initializers in Protocols</a><a class="headerlink" href="#initializers-in-protocols" title="Permalink to this headline">¶</a></h2>
<p>We currently ban initializers in protocols because we didn&#8217;t have an
implementation model for them. Protocols, whether used via generics or
via existentials, use dynamic dispatch through the witness table. More
importantly, one of the important aspects of protocols is that, when a
given class <code class="docutils literal"><span class="pre">A</span></code> conforms to a protocol <code class="docutils literal"><span class="pre">P</span></code>, all of the subclasses
of <code class="docutils literal"><span class="pre">A</span></code> also conform to <code class="docutils literal"><span class="pre">P</span></code>. This property interacts directly with
initializers:</p>
<div class="highlight-python"><div class="highlight"><pre>protocol NSCoding {
  init withCoder(coder: NSCoder)
}

class A : NSCoding {
  init withCoder(coder: NSCoder) { /* ... */ }
}

class B : A {
  // conforms to NSCoding?
}
</pre></div>
</div>
<p>Here, <code class="docutils literal"><span class="pre">A</span></code> appears to conform to <code class="docutils literal"><span class="pre">NSCoding</span></code> because it provides a
matching initializer. <code class="docutils literal"><span class="pre">B</span></code> should conform to <code class="docutils literal"><span class="pre">NSCoding</span></code>, because it
should inherit its conformance from <code class="docutils literal"><span class="pre">A</span></code>, but the lack of an
<code class="docutils literal"><span class="pre">initWithCoder:</span></code> initializer causes problems. The fix here is to
require that the witness be a virtual initializer, which guarantees
that all of the subclasses will have the same initializer. Thus, the
definition of <code class="docutils literal"><span class="pre">A</span></code> above will be ill-formed unless <code class="docutils literal"><span class="pre">initWithCoder:</span></code>
is made virtual:</p>
<div class="highlight-python"><div class="highlight"><pre>protocol NSCoding {
  init withCoder(coder: NSCoder)
}

class A : NSCoding {
  @virtual init withCoder(coder: NSCoder) { /* ... */ }
}

class B : A {
  // either error (due to missing initWithCoder) or synthesized initWithCoder:
}
</pre></div>
</div>
<p>As noted earlier, the initializers of structs and enums are considered
virtual.</p>
</div>
<div class="section" id="objective-c-interoperability">
<h2><a class="toc-backref" href="#id7">Objective-C Interoperability</a><a class="headerlink" href="#objective-c-interoperability" title="Permalink to this headline">¶</a></h2>
<p>The initialization model described above guarantees that objects are
properly initialized before they are used, covering all of the major
use cases for initialization while maintaining soundness. Objective-C
has a very different initialization model with which Swift must
interoperate.</p>
<div class="section" id="objective-c-entrypoints">
<h3><a class="toc-backref" href="#id8">Objective-C Entrypoints</a><a class="headerlink" href="#objective-c-entrypoints" title="Permalink to this headline">¶</a></h3>
<p>Each Swift initializer definition produces a corresponding Objective-C
init method. The existence of this init method allows object
construction from Objective-C (both directly via <code class="docutils literal"><span class="pre">[[A</span> <span class="pre">alloc]</span>
<span class="pre">init:5]</span></code> and indirectly via, e.g., <code class="docutils literal"><span class="pre">[obj</span> <span class="pre">initWithCoder:coder]</span></code>)
and initialization of the superclass subobject when an Objective-C class
inherits from a Swift class (e.g., <code class="docutils literal"><span class="pre">[super</span> <span class="pre">initWithCoder:coder]</span></code>).</p>
<p>Note that, while Swift&#8217;s initializers are not inherited and cannot
override, this is only true <em>in Swift code</em>. If a subclass defines an
initializer with the same Objective-C selector as an initializer in
its superclass, the Objective-C init method produced for the former
will override the Objective-C init method produced for the
latter.</p>
</div>
<div class="section" id="objective-c-restrictions">
<h3><a class="toc-backref" href="#id9">Objective-C Restrictions</a><a class="headerlink" href="#objective-c-restrictions" title="Permalink to this headline">¶</a></h3>
<p>The emission of Objective-C init methods for Swift initializers open
up a few soundness problems, illustrated here:</p>
<div class="highlight-python"><div class="highlight"><pre>@interface A
@end

@implementation A
- init {
  return [self initWithInt:5];
}

- initWithInt:(int)x {
  // initialize me
}

- initWithString:(NSString *)s {
  // initialize me
}
@end

class B1 : A {
  var dict: NSDictionary

  init withInt(x: Int) {
    dict = []
    super.init() // loops forever, initializing dict repeatedly
  }
}

class B2 : A {
}

@interface C : B2
@end

@implementation C
@end

void getCFromString(NSString *str) {
  return [C initWithString:str]; // doesn&#39;t initialize B&#39;s dict ivar
}
</pre></div>
</div>
<p>The first problem, with <code class="docutils literal"><span class="pre">B1</span></code>, comes from <code class="docutils literal"><span class="pre">A</span></code>&#8216;s dispatched
delegation to <code class="docutils literal"><span class="pre">-initWithInt:</span></code>, which is overridden by <code class="docutils literal"><span class="pre">B1</span></code>&#8216;s
initializer with the same selector. We can address this problem by
enforcing that superclass delegation to an Objective-C superclass
initializer refer to a designated initializer of that superclass when
that class has at least one initializer marked as a designated
initializer.</p>
<p>The second problem, with <code class="docutils literal"><span class="pre">C</span></code>, comes from Objective-C&#8217;s implicit
inheritance of initializers. We can address this problem by specifying
that init methods in Objective-C are never visible through Swift
classes, making the message send <code class="docutils literal"><span class="pre">[C</span> <span class="pre">initWithString:str]</span></code>
ill-formed. This is a relatively small Clang-side change.</p>
</div>
<div class="section" id="remaining-soundness-holes">
<h3><a class="toc-backref" href="#id10">Remaining Soundness Holes</a><a class="headerlink" href="#remaining-soundness-holes" title="Permalink to this headline">¶</a></h3>
<p>Neither of the above &#8220;fixes&#8221; are complete. The first depends entirely
on the adoption of a not-yet-implemented Clang attribute to mark the
designated initializers for Objective-C classes, while the second is
(almost trivially) defeated by passing the <code class="docutils literal"><span class="pre">-initWithString:</span></code>
message to an object of type <code class="docutils literal"><span class="pre">id</span></code> or using some other dynamic
reflection.</p>
<p>If we want to close these holes tighter, we could stop emitting
Objective-C init methods for Swift initializers. Instead, we would
fake the init method declarations when importing Swift modules into
Clang, and teach Clang&#8217;s CodeGen to emit calls directly to the Swift
initializers. It would still not be perfect (e.g., some variant of the
problem with <code class="docutils literal"><span class="pre">C</span></code> would persist), but it would be closer. I suspect
that this is far more work than it is worth, and that the &#8220;fixes&#8221;
described above are sufficient.</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright apple.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.1.9',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>