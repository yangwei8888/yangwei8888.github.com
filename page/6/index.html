<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="terry yang's blog | java | scala | bi" />



  <meta name="keywords" content="Hexo,next" />



  <link rel="alternate" href="/atom.xml" title="yosita" type="application/atom+xml" />



  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="terry yang&apos;s blog | java | scala | bi">
<meta property="og:type" content="website">
<meta property="og:title" content="yosita">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="yosita">
<meta property="og:description" content="terry yang&apos;s blog | java | scala | bi">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="yosita">
<meta name="twitter:description" content="terry yang&apos;s blog | java | scala | bi">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>

  <title> yosita </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  

  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?7e8961fdae021b7bf62f2c767bb18c23";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">yosita</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/15_Deinitialization/" itemprop="url">
                第二章-15析构过程（Deinitialization）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:12+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/15_Deinitialization/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/15_Deinitialization/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="析构过程（Deinitialization）">析构过程（Deinitialization）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/bruce0505" target="_blank" rel="external">bruce0505</a><br>校对：<a href="https://github.com/fd5788" target="_blank" rel="external">fd5788</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/chenmingbiao" target="_blank" rel="external">chenmingbiao</a></p>
<p>2.1<br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a>，2015-10-31</p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#how_deinitialization_works">析构过程原理</a></li>
<li><a href="#deinitializers_in_action">析构器实践</a></li>
</ul>
<p><em>析构器</em>只适用于类类型，当一个类的实例被释放之前，析构器会被立即调用。析构器用关键字<code>deinit</code>来标示，类似于构造器要用<code>init</code>来标示。</p>
<p><a name="how_deinitialization_works"></a></p>
<p>##析构过程原理</p>
<p>Swift 会自动释放不再需要的实例以释放资源。如<a href="./16_Automatic_Reference_Counting.html">自动引用计数</a>章节中所讲述，Swift 通过<code>自动引用计数（ARC）</code>处理实例的内存管理。通常当你的实例被释放时不需要手动地去清理。但是，当使用自己的资源时，你可能需要进行一些额外的清理。例如，如果创建了一个自定义的类来打开一个文件，并写入一些数据，你可能需要在类实例被释放之前手动去关闭该文件。</p>
<p>在类的定义中，每个类最多只能有一个析构器，而且析构器不带任何参数，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">deinit</span> &#123;</span><br><span class="line">    <span class="comment">// 执行析构过程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>析构器是在实例释放发生前被自动调用。你不能主动调用析构器。子类继承了父类的析构器，并且在子类析构器实现的最后，父类的析构器会被自动调用。即使子类没有提供自己的析构器，父类的析构器也同样会被调用。</p>
<p>因为直到实例的析构器被调用后，实例才会被释放，所以析构器可以访问实例的所有属性，并且可以根据那些属性可以修改它的行为（比如查找一个需要被关闭的文件）。</p>
<p><a name="deinitializers_in_action"></a></p>
<p>##析构器实践</p>
<p>这是一个析构器实践的例子。这个例子描述了一个简单的游戏，这里定义了两种新类型，分别是<code>Bank</code>和<code>Player</code>。<code>Bank</code>类管理一种虚拟硬币，确保流通的硬币数量永远不可能超过 10,000。在游戏中有且只能有一个<code>Bank</code>存在，因此<code>Bank</code>用类来实现，并使用静态属性和静态方法来存储和管理其当前状态。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> coinsInBank = <span class="number">10_000</span></span><br><span class="line">    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">vendCoins</span><span class="params">(<span class="keyword">var</span> numberOfCoinsToVend: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        numberOfCoinsToVend = <span class="built_in">min</span>(numberOfCoinsToVend, coinsInBank)</span><br><span class="line">        coinsInBank -= numberOfCoinsToVend</span><br><span class="line">        <span class="keyword">return</span> numberOfCoinsToVend</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">receiveCoins</span><span class="params">(coins: Int)</span></span> &#123;</span><br><span class="line">        coinsInBank += coins</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Bank</code>使用<code>coinsInBank</code>属性来跟踪它当前拥有的硬币数量。<code>Bank</code>还提供了两个方法，<code>vendCoins(_:)</code>和<code>receiveCoins(_:)</code>，分别用来处理硬币的分发和收集。</p>
<p><code>vendCoins(_:)</code>方法在<code>Bank</code>对象分发硬币之前检查是否有足够的硬币。如果硬币不足，<code>Bank</code>对象会返回一个比请求时小的数字（如果<code>Bank</code>对象中没有硬币了就返回<code>0</code>）。<code>vendCoins</code>方法声明<code>numberOfCoinsToVend</code>为一个变量参数，这样就可以在方法体内部修改分发的硬币数量，而不需要定义一个新的变量。<code>vendCoins</code>方法返回一个整型值，表示提供的硬币的实际数量。</p>
<p><code>receiveCoins(_:)</code>方法只是将<code>Bank</code>对象接收到的硬币数目加回硬币存储中。</p>
<p><code>Player</code>类描述了游戏中的一个玩家。每一个玩家在任意时间都有一定数量的硬币存储在他们的钱包中。这通过玩家的<code>coinsInPurse</code>属性来表示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> coinsInPurse: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(coins: <span class="type">Int</span>) &#123;</span><br><span class="line">        coinsInPurse = <span class="type">Bank</span>.vendCoins(coins)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">winCoins</span><span class="params">(coins: Int)</span></span> &#123;</span><br><span class="line">        coinsInPurse += <span class="type">Bank</span>.vendCoins(coins)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="type">Bank</span>.receiveCoins(coinsInPurse)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个<code>Player</code>实例在初始化的过程中，都从<code>Bank</code>对象获取指定数量的硬币。如果没有足够的硬币可用，<code>Player</code>实例可能会收到比指定数量少的硬币.</p>
<p><code>Player</code>类定义了一个<code>winCoins(_:)</code>方法，该方法从<code>Bank</code>对象获取一定数量的硬币，并把它们添加到玩家的钱包。<code>Player</code>类还实现了一个析构器，这个析构器在<code>Player</code>实例释放前被调用。在这里，析构器的作用只是将玩家的所有硬币都返还给<code>Bank</code>对象：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> playerOne: <span class="type">Player</span>? = <span class="type">Player</span>(coins: <span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"A new player has joined the game with <span class="subst">\(playerOne!.coinsInPurse)</span> coins"</span>)</span><br><span class="line"><span class="comment">// 打印 "A new player has joined the game with 100 coins"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"There are now <span class="subst">\(Bank.coinsInBank)</span> coins left in the bank"</span>)</span><br><span class="line"><span class="comment">// 打印 "There are now 9900 coins left in the bank"</span></span><br></pre></td></tr></table></figure>
<p>创建一个<code>Player</code>实例的时候，会向<code>Bank</code>对象请求 100 个硬币，如果有足够的硬币可用的话。这个<code>Player</code>实例存储在一个名为<code>playerOne</code>的可选类型的变量中。这里使用了一个可选类型的变量，因为玩家可以随时离开游戏，设置为可选使你可以追踪玩家当前是否在游戏中。</p>
<p>因为<code>playerOne</code>是可选的，所以访问其<code>coinsInPurse</code>属性来打印钱包中的硬币数量时，使用感叹号（<code>!</code>）来解包：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">playerOne!.winCoins(<span class="number">2_000</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"PlayerOne won 2000 coins &amp; now has <span class="subst">\(playerOne!.coinsInPurse)</span> coins"</span>)</span><br><span class="line"><span class="comment">// 输出 "PlayerOne won 2000 coins &amp; now has 2100 coins"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The bank now only has <span class="subst">\(Bank.coinsInBank)</span> coins left"</span>)</span><br><span class="line"><span class="comment">// 输出 "The bank now only has 7900 coins left"</span></span><br></pre></td></tr></table></figure>
<p>这里，玩家已经赢得了 2,000 枚硬币，所以玩家的钱包中现在有 2,100 枚硬币，而<code>Bank</code>对象只剩余 7,900 枚硬币。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">playerOne = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"PlayerOne has left the game"</span>)</span><br><span class="line"><span class="comment">// 打印 "PlayerOne has left the game"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The bank now has <span class="subst">\(Bank.coinsInBank)</span> coins"</span>)</span><br><span class="line"><span class="comment">// 打印 "The bank now has 10000 coins"</span></span><br></pre></td></tr></table></figure>
<p>玩家现在已经离开了游戏。这通过将可选类型的<code>playerOne</code>变量设置为<code>nil</code>来表示，意味着“没有<code>Player</code>实例”。当这一切发生时，<code>playerOne</code>变量对<code>Player</code>实例的引用被破坏了。没有其它属性或者变量引用<code>Player</code>实例，因此该实例会被释放，以便回收内存。在这之前，该实例的析构器被自动调用，玩家的硬币被返还给银行。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/16_Automatic_Reference_Counting/" itemprop="url">
                第二章-16自动引用计数（Automatic Reference Counting）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:11+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/16_Automatic_Reference_Counting/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/16_Automatic_Reference_Counting/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="自动引用计数（Automatic_Reference_Counting）">自动引用计数（Automatic Reference Counting）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/TimothyYe" target="_blank" rel="external">TimothyYe</a><br>校对：<a href="https://github.com/Hawstein" target="_blank" rel="external">Hawstein</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/Channe" target="_blank" rel="external">Channe</a></p>
<p>2.1<br>翻译：<a href="https://github.com/Channe" target="_blank" rel="external">Channe</a><br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a>，2015-10-31</p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#how_arc_works">自动引用计数的工作机制</a></li>
<li><a href="#arc_in_action">自动引用计数实践</a></li>
<li><a href="#strong_reference_cycles_between_class_instances">类实例之间的循环强引用</a></li>
<li><a href="#resolving_strong_reference_cycles_between_class_instances">解决实例之间的循环强引用</a></li>
<li><a href="#strong_reference_cycles_for_closures">闭包引起的循环强引用</a></li>
<li><a href="#resolving_strong_reference_cycles_for_closures">解决闭包引起的循环强引用</a></li>
</ul>
<p>Swift 使用自动引用计数（ARC）机制来跟踪和管理你的应用程序的内存。通常情况下，Swift 内存管理机制会一直起作用，你无须自己来考虑内存的管理。ARC 会在类的实例不再被使用时，自动释放其占用的内存。</p>
<p>然而，在少数情况下，ARC 为了能帮助你管理内存，需要更多的关于你的代码之间关系的信息。本章描述了这些情况，并且为你示范怎样启用 ARC 来管理你的应用程序的内存。</p>
<blockquote>
<p>注意<br>引用计数仅仅应用于类的实例。结构体和枚举类型是值类型，不是引用类型，也不是通过引用的方式存储和传递。</p>
</blockquote>
<p><a name="how_arc_works"></a></p>
<h2 id="自动引用计数的工作机制">自动引用计数的工作机制</h2><p>当你每次创建一个类的新的实例的时候，ARC 会分配一大块内存用来储存实例的信息。内存中会包含实例的类型信息，以及这个实例所有相关属性的值。</p>
<p>此外，当实例不再被使用时，ARC 释放实例所占用的内存，并让释放的内存能挪作他用。这确保了不再被使用的实例，不会一直占用内存空间。</p>
<p>然而，当 ARC 收回和释放了正在被使用中的实例，该实例的属性和方法将不能再被访问和调用。实际上，如果你试图访问这个实例，你的应用程序很可能会崩溃。</p>
<p>为了确保使用中的实例不会被销毁，ARC 会跟踪和计算每一个实例正在被多少属性，常量和变量所引用。哪怕实例的引用数为1，ARC都不会销毁这个实例。</p>
<p>为了使上述成为可能，无论你将实例赋值给属性、常量或变量，它们都会创建此实例的强引用。之所以称之为“强”引用，是因为它会将实例牢牢地保持住，只要强引用还在，实例是不允许被销毁的。</p>
<p><a name="arc_in_action"></a></p>
<h2 id="自动引用计数实践">自动引用计数实践</h2><p>下面的例子展示了自动引用计数的工作机制。例子以一个简单的<code>Person</code>类开始，并定义了一个叫<code>name</code>的常量属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span> is being initialized"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span> is being deinitialized"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Person</code>类有一个构造函数，此构造函数为实例的<code>name</code>属性赋值，并打印一条消息以表明初始化过程生效。<code>Person</code>类也拥有一个析构函数，这个析构函数会在实例被销毁时打印一条消息。</p>
<p>接下来的代码片段定义了三个类型为<code>Person?</code>的变量，用来按照代码片段中的顺序，为新的<code>Person</code>实例建立多个引用。由于这些变量是被定义为可选类型（<code>Person?</code>，而不是<code>Person</code>），它们的值会被自动初始化为<code>nil</code>，目前还不会引用到<code>Person</code>类的实例。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reference1: <span class="type">Person</span>?</span><br><span class="line"><span class="keyword">var</span> reference2: <span class="type">Person</span>?</span><br><span class="line"><span class="keyword">var</span> reference3: <span class="type">Person</span>?</span><br></pre></td></tr></table></figure>
<p>现在你可以创建<code>Person</code>类的新实例，并且将它赋值给三个变量中的一个：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reference1 = <span class="type">Person</span>(name: <span class="string">"John Appleseed"</span>)</span><br><span class="line"><span class="comment">// prints "John Appleseed is being initialized”</span></span><br></pre></td></tr></table></figure>
<p>应当注意到当你调用<code>Person</code>类的构造函数的时候，<code>“John Appleseed is being initialized”</code>会被打印出来。由此可以确定构造函数被执行。</p>
<p>由于<code>Person</code>类的新实例被赋值给了<code>reference1</code>变量，所以<code>reference1</code>到<code>Person</code>类的新实例之间建立了一个强引用。正是因为这一个强引用，ARC 会保证<code>Person</code>实例被保持在内存中不被销毁。</p>
<p>如果你将同一个<code>Person</code>实例也赋值给其他两个变量，该实例又会多出两个强引用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reference2 = reference1</span><br><span class="line">reference3 = reference1</span><br></pre></td></tr></table></figure>
<p>现在这一个<code>Person</code>实例已经有三个强引用了。</p>
<p>如果你通过给其中两个变量赋值<code>nil</code>的方式断开两个强引用（包括最先的那个强引用），只留下一个强引用，<code>Person</code>实例不会被销毁：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reference1 = <span class="literal">nil</span></span><br><span class="line">reference2 = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>在你清楚地表明不再使用这个<code>Person</code>实例时，即第三个也就是最后一个强引用被断开时，ARC 会销毁它：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reference3 = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// 打印 “John Appleseed is being deinitialized”</span></span><br></pre></td></tr></table></figure>
<p><a name="strong_reference_cycles_between_class_instances"></a></p>
<h2 id="类实例之间的循环强引用">类实例之间的循环强引用</h2><p>在上面的例子中，ARC 会跟踪你所新创建的<code>Person</code>实例的引用数量，并且会在<code>Person</code>实例不再被需要时销毁它。</p>
<p>然而，我们可能会写出一个类实例的强引用数永远不能变成<code>0</code>的代码。如果两个类实例互相持有对方的强引用，因而每个实例都让对方一直存在，就是这种情况。这就是所谓的循环强引用。</p>
<p>你可以通过定义类之间的关系为弱引用或无主引用，以替代强引用，从而解决循环强引用的问题。具体的过程在<a href="#resolving_strong_reference_cycles_between_class_instances">解决类实例之间的循环强引用</a>中有描述。不管怎样，在你学习怎样解决循环强引用之前，很有必要了解一下它是怎样产生的。</p>
<p>下面展示了一个不经意产生循环强引用的例子。例子定义了两个类：<code>Person</code>和<code>Apartment</code>，用来建模公寓和它其中的居民：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123; <span class="keyword">self</span>.name = name &#125;</span><br><span class="line">    <span class="keyword">var</span> apartment: <span class="type">Apartment</span>?</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span> is being deinitialized"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apartment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> unit: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(unit: <span class="type">String</span>) &#123; <span class="keyword">self</span>.unit = unit &#125;</span><br><span class="line">    <span class="keyword">var</span> tenant: <span class="type">Person</span>?</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"Apartment <span class="subst">\(unit)</span> is being deinitialized"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一个<code>Person</code>实例有一个类型为<code>String</code>，名字为<code>name</code>的属性，并有一个可选的初始化为<code>nil</code>的<code>apartment</code>属性。<code>apartment</code>属性是可选的，因为一个人并不总是拥有公寓。</p>
<p>类似的，每个<code>Apartment</code>实例有一个叫<code>number</code>，类型为<code>Int</code>的属性，并有一个可选的初始化为<code>nil</code>的<code>tenant</code>属性。<code>tenant</code>属性是可选的，因为一栋公寓并不总是有居民。</p>
<p>这两个类都定义了析构函数，用以在类实例被析构的时候输出信息。这让你能够知晓<code>Person</code>和<code>Apartment</code>的实例是否像预期的那样被销毁。</p>
<p>接下来的代码片段定义了两个可选类型的变量<code>john</code>和<code>unit4A</code>，并分别被设定为下面的<code>Apartment</code>和<code>Person</code>的实例。这两个变量都被初始化为<code>nil</code>，这正是可选的优点：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> john: <span class="type">Person</span>?</span><br><span class="line"><span class="keyword">var</span> unit4A: <span class="type">Apartment</span>?</span><br></pre></td></tr></table></figure>
<p>现在你可以创建特定的<code>Person</code>和<code>Apartment</code>实例并将赋值给<code>john</code>和<code>unit4A</code>变量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">john = <span class="type">Person</span>(name: <span class="string">"John Appleseed"</span>)</span><br><span class="line">unit4A = <span class="type">Apartment</span>(unit: <span class="string">"4A"</span>)</span><br></pre></td></tr></table></figure>
<p>在两个实例被创建和赋值后，下图表现了强引用的关系。变量<code>john</code>现在有一个指向<code>Person</code>实例的强引用，而变量<code>unit4A</code>有一个指向<code>Apartment</code>实例的强引用：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle01_2x.png" alt=""></p>
<p>现在你能够将这两个实例关联在一起，这样人就能有公寓住了，而公寓也有了房客。注意感叹号是用来展开和访问可选变量<code>john</code>和<code>unit4A</code>中的实例，这样实例的属性才能被赋值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">john!.apartment = unit4A</span><br><span class="line">unit4A!.tenant = john</span><br></pre></td></tr></table></figure>
<p>在将两个实例联系在一起之后，强引用的关系如图所示：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle02_2x.png" alt=""></p>
<p>不幸的是，这两个实例关联后会产生一个循环强引用。<code>Person</code>实例现在有了一个指向<code>Apartment</code>实例的强引用，而<code>Apartment</code>实例也有了一个指向<code>Person</code>实例的强引用。因此，当你断开<code>john</code>和<code>unit4A</code>变量所持有的强引用时，引用计数并不会降为<code>0</code>，实例也不会被 ARC 销毁：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">john = <span class="literal">nil</span></span><br><span class="line">unit4A = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>注意，当你把这两个变量设为<code>nil</code>时，没有任何一个析构函数被调用。循环强引用会一直阻止<code>Person</code>和<code>Apartment</code>类实例的销毁，这就在你的应用程序中造成了内存泄漏。</p>
<p>在你将<code>john</code>和<code>unit4A</code>赋值为<code>nil</code>后，强引用关系如下图：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle03_2x.png" alt=""></p>
<p><code>Person</code>和<code>Apartment</code>实例之间的强引用关系保留了下来并且不会被断开。</p>
<p><a name="resolving_strong_reference_cycles_between_class_instances"></a></p>
<h2 id="解决实例之间的循环强引用">解决实例之间的循环强引用</h2><p>Swift 提供了两种办法用来解决你在使用类的属性时所遇到的循环强引用问题：弱引用（weak reference）和无主引用（unowned reference）。</p>
<p>弱引用和无主引用允许循环引用中的一个实例引用另外一个实例而不保持强引用。这样实例能够互相引用而不产生循环强引用。</p>
<p>对于生命周期中会变为<code>nil</code>的实例使用弱引用。相反地，对于初始化赋值后再也不会被赋值为<code>nil</code>的实例，使用无主引用。</p>
<p><a name="weak_references"></a></p>
<h3 id="弱引用">弱引用</h3><p>弱引用不会对其引用的实例保持强引用，因而不会阻止 ARC 销毁被引用的实例。这个特性阻止了引用变为循环强引用。声明属性或者变量时，在前面加上<code>weak</code>关键字表明这是一个弱引用。</p>
<p>在实例的生命周期中，如果某些时候引用没有值，那么弱引用可以避免循环强引用。如果引用总是有值，则可以使用无主引用，在<a href="#unowned_references">无主引用</a>中有描述。在上面<code>Apartment</code>的例子中，一个公寓的生命周期中，有时是没有“居民”的，因此适合使用弱引用来解决循环强引用。</p>
<blockquote>
<p>注意<br>弱引用必须被声明为变量，表明其值能在运行时被修改。弱引用不能被声明为常量。  </p>
</blockquote>
<p>因为弱引用可以没有值，你必须将每一个弱引用声明为可选类型。在 Swift 中，推荐使用可选类型描述可能没有值的类型。</p>
<p>因为弱引用不会保持所引用的实例，即使引用存在，实例也有可能被销毁。因此，ARC 会在引用的实例被销毁后自动将其赋值为<code>nil</code>。你可以像其他可选值一样，检查弱引用的值是否存在，你将永远不会访问已销毁的实例的引用。</p>
<p>下面的例子跟上面<code>Person</code>和<code>Apartment</code>的例子一致，但是有一个重要的区别。这一次，<code>Apartment</code>的<code>tenant</code>属性被声明为弱引用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123; <span class="keyword">self</span>.name = name &#125;</span><br><span class="line">    <span class="keyword">var</span> apartment: <span class="type">Apartment</span>?</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span> is being deinitialized"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apartment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> unit: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(unit: <span class="type">String</span>) &#123; <span class="keyword">self</span>.unit = unit &#125;</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> tenant: <span class="type">Person</span>?</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"Apartment <span class="subst">\(unit)</span> is being deinitialized"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后跟之前一样，建立两个变量（<code>john</code>和<code>unit4A</code>）之间的强引用，并关联两个实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> john: <span class="type">Person</span>?</span><br><span class="line"><span class="keyword">var</span> unit4A: <span class="type">Apartment</span>?</span><br><span class="line"></span><br><span class="line">john = <span class="type">Person</span>(name: <span class="string">"John Appleseed"</span>)</span><br><span class="line">unit4A = <span class="type">Apartment</span>(unit: <span class="string">"4A"</span>)</span><br><span class="line"></span><br><span class="line">john!.apartment = unit4A</span><br><span class="line">unit4A!.tenant = john</span><br></pre></td></tr></table></figure>
<p>现在，两个关联在一起的实例的引用关系如下图所示：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference01_2x.png" alt=""></p>
<p><code>Person</code>实例依然保持对<code>Apartment</code>实例的强引用，但是<code>Apartment</code>实例只持有对<code>Person</code>实例的弱引用。这意味着当你断开<code>john</code>变量所保持的强引用时，再也没有指向<code>Person</code>实例的强引用了：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference02_2x.png" alt=""></p>
<p>由于再也没有指向<code>Person</code>实例的强引用，该实例会被销毁：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">john = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// 打印 “John Appleseed is being deinitialized”</span></span><br></pre></td></tr></table></figure>
<p>唯一剩下的指向<code>Apartment</code>实例的强引用来自于变量<code>unit4A</code>。如果你断开这个强引用，再也没有指向<code>Apartment</code>实例的强引用了：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference03_2x.png" alt=""></p>
<p>由于再也没有指向<code>Apartment</code>实例的强引用，该实例也会被销毁：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unit4A = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// 打印 “Apartment 4A is being deinitialized”</span></span><br></pre></td></tr></table></figure>
<p>上面的两段代码展示了变量<code>john</code>和<code>unit4A</code>在被赋值为<code>nil</code>后，<code>Person</code>实例和<code>Apartment</code>实例的析构函数都打印出“销毁”的信息。这证明了引用循环被打破了。</p>
<blockquote>
<p>注意<br> 在使用垃圾收集的系统里，弱指针有时用来实现简单的缓冲机制，因为没有强引用的对象只会在内存压力触发垃圾收集时才被销毁。但是在 ARC 中，一旦值的最后一个强引用被移除，就会被立即销毁，这导致弱引用并不适合上面的用途。</p>
</blockquote>
<p><a name="unowned_references"></a></p>
<h3 id="无主引用">无主引用</h3><p>和弱引用类似，无主引用不会牢牢保持住引用的实例。和弱引用不同的是，无主引用是永远有值的。因此，无主引用总是被定义为非可选类型（non-optional type）。你可以在声明属性或者变量时，在前面加上关键字<code>unowned</code>表示这是一个无主引用。</p>
<p>由于无主引用是非可选类型，你不需要在使用它的时候将它展开。无主引用总是可以被直接访问。不过 ARC 无法在实例被销毁后将无主引用设为<code>nil</code>，因为非可选类型的变量不允许被赋值为<code>nil</code>。</p>
<blockquote>
<p>注意<br>如果你试图在实例被销毁后，访问该实例的无主引用，会触发运行时错误。使用无主引用，你必须确保引用始终指向一个未销毁的实例。<br>还需要注意的是如果你试图访问实例已经被销毁的无主引用，Swift 确保程序会直接崩溃，而不会发生无法预期的行为。所以你应当避免这样的事情发生。  </p>
</blockquote>
<p>下面的例子定义了两个类，<code>Customer</code>和<code>CreditCard</code>，模拟了银行客户和客户的信用卡。这两个类中，每一个都将另外一个类的实例作为自身的属性。这种关系可能会造成循环强引用。</p>
<p><code>Customer</code>和<code>CreditCard</code>之间的关系与前面弱引用例子中<code>Apartment</code>和<code>Person</code>的关系略微不同。在这个数据模型中，一个客户可能有或者没有信用卡，但是一张信用卡总是关联着一个客户。为了表示这种关系，<code>Customer</code>类有一个可选类型的<code>card</code>属性，但是<code>CreditCard</code>类有一个非可选类型的<code>customer</code>属性。</p>
<p>此外，只能通过将一个<code>number</code>值和<code>customer</code>实例传递给<code>CreditCard</code>构造函数的方式来创建<code>CreditCard</code>实例。这样可以确保当创建<code>CreditCard</code>实例时总是有一个<code>customer</code>实例与之关联。</p>
<p>由于信用卡总是关联着一个客户，因此将<code>customer</code>属性定义为无主引用，用以避免循环强引用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> card: <span class="type">CreditCard</span>?</span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span> is being deinitialized"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditCard</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> number: <span class="type">UInt64</span></span><br><span class="line">    <span class="keyword">unowned</span> <span class="keyword">let</span> customer: <span class="type">Customer</span></span><br><span class="line">    <span class="keyword">init</span>(number: <span class="type">UInt64</span>, customer: <span class="type">Customer</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.number = number</span><br><span class="line">        <span class="keyword">self</span>.customer = customer</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"Card #<span class="subst">\(number)</span> is being deinitialized"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br><code>CreditCard</code>类的<code>number</code>属性被定义为<code>UInt64</code>类型而不是<code>Int</code>类型，以确保<code>number</code>属性的存储量在 32 位和 64 位系统上都能足够容纳 16 位的卡号。</p>
</blockquote>
<p>下面的代码片段定义了一个叫<code>john</code>的可选类型<code>Customer</code>变量，用来保存某个特定客户的引用。由于是可选类型，所以变量被初始化为<code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> john: <span class="type">Customer</span>?</span><br></pre></td></tr></table></figure>
<p>现在你可以创建<code>Customer</code>类的实例，用它初始化<code>CreditCard</code>实例，并将新创建的<code>CreditCard</code>实例赋值为客户的<code>card</code>属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">john = <span class="type">Customer</span>(name: <span class="string">"John Appleseed"</span>)</span><br><span class="line">john!.card = <span class="type">CreditCard</span>(number: <span class="number">1234_5678_9012_3456</span>, customer: john!)</span><br></pre></td></tr></table></figure>
<p>在你关联两个实例后，它们的引用关系如下图所示：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/unownedReference01_2x.png" alt=""></p>
<p><code>Customer</code>实例持有对<code>CreditCard</code>实例的强引用，而<code>CreditCard</code>实例持有对<code>Customer</code>实例的无主引用。</p>
<p>由于<code>customer</code>的无主引用，当你断开<code>john</code>变量持有的强引用时，再也没有指向<code>Customer</code>实例的强引用了：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/unownedReference02_2x.png" alt=""></p>
<p>由于再也没有指向<code>Customer</code>实例的强引用，该实例被销毁了。其后，再也没有指向<code>CreditCard</code>实例的强引用，该实例也随之被销毁了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">john = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// 打印 “John Appleseed is being deinitialized”</span></span><br><span class="line"><span class="comment">// 打印 ”Card #1234567890123456 is being deinitialized”</span></span><br></pre></td></tr></table></figure>
<p>最后的代码展示了在<code>john</code>变量被设为<code>nil</code>后<code>Customer</code>实例和<code>CreditCard</code>实例的构造函数都打印出了“销毁”的信息。</p>
<p><a name="unowned_references_and_implicitly_unwrapped_optional_properties"></a></p>
<p>###无主引用以及隐式解析可选属性</p>
<p>上面弱引用和无主引用的例子涵盖了两种常用的需要打破循环强引用的场景。</p>
<p><code>Person</code>和<code>Apartment</code>的例子展示了两个属性的值都允许为<code>nil</code>，并会潜在的产生循环强引用。这种场景最适合用弱引用来解决。</p>
<p><code>Customer</code>和<code>CreditCard</code>的例子展示了一个属性的值允许为<code>nil</code>，而另一个属性的值不允许为<code>nil</code>，这也可能会产生循环强引用。这种场景最适合通过无主引用来解决。</p>
<p>然而，存在着第三种场景，在这种场景中，两个属性都必须有值，并且初始化完成后永远不会为<code>nil</code>。在这种场景中，需要一个类使用无主属性，而另外一个类使用隐式解析可选属性。</p>
<p>这使两个属性在初始化完成后能被直接访问（不需要可选展开），同时避免了循环引用。这一节将为你展示如何建立这种关系。</p>
<p>下面的例子定义了两个类，<code>Country</code>和<code>City</code>，每个类将另外一个类的实例保存为属性。在这个模型中，每个国家必须有首都，每个城市必须属于一个国家。为了实现这种关系，<code>Country</code>类拥有一个<code>capitalCity</code>属性，而<code>City</code>类有一个<code>country</code>属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Country</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> capitalCity: <span class="type">City</span>!</span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, capitalName: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.capitalCity = <span class="type">City</span>(name: capitalName, country: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">City</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">unowned</span> <span class="keyword">let</span> country: <span class="type">Country</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, country: <span class="type">Country</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.country = country</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了建立两个类的依赖关系，<code>City</code>的构造函数接受一个<code>Country</code>实例作为参数，并且将实例保存到<code>country</code>属性。</p>
<p><code>Country</code>的构造函数调用了<code>City</code>的构造函数。然而，只有<code>Country</code>的实例完全初始化后，<code>Country</code>的构造函数才能把<code>self</code>传给<code>City</code>的构造函数。（在<a href="./14_Initialization.html#two_phase_initialization">两段式构造过程</a>中有具体描述）</p>
<p>为了满足这种需求，通过在类型结尾处加上感叹号（<code>City!</code>）的方式，将<code>Country</code>的<code>capitalCity</code>属性声明为隐式解析可选类型的属性。这意味着像其他可选类型一样，<code>capitalCity</code>属性的默认值为<code>nil</code>，但是不需要展开它的值就能访问它。（在<a href="./01_The_Basics.html#implicityly_unwrapped_optionals">隐式解析可选类型</a>中有描述）</p>
<p>由于<code>capitalCity</code>默认值为<code>nil</code>，一旦<code>Country</code>的实例在构造函数中给<code>name</code>属性赋值后，整个初始化过程就完成了。这意味着一旦<code>name</code>属性被赋值后，<code>Country</code>的构造函数就能引用并传递隐式的<code>self</code>。<code>Country</code>的构造函数在赋值<code>capitalCity</code>时，就能将<code>self</code>作为参数传递给<code>City</code>的构造函数。</p>
<p>以上的意义在于你可以通过一条语句同时创建<code>Country</code>和<code>City</code>的实例，而不产生循环强引用，并且<code>capitalCity</code>的属性能被直接访问，而不需要通过感叹号来展开它的可选值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> country = <span class="type">Country</span>(name: <span class="string">"Canada"</span>, capitalName: <span class="string">"Ottawa"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(country.name)</span>'s capital city is called <span class="subst">\(country.capitalCity.name)</span>"</span>)</span><br><span class="line"><span class="comment">// 打印 “Canada's capital city is called Ottawa”</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，使用隐式解析可选值意味着满足了类的构造函数的两个构造阶段的要求。<code>capitalCity</code>属性在初始化完成后，能像非可选值一样使用和存取，同时还避免了循环强引用。</p>
<p><a name="strong_reference_cycles_for_closures"></a></p>
<p>##闭包引起的循环强引用</p>
<p>前面我们看到了循环强引用是在两个类实例属性互相保持对方的强引用时产生的，还知道了如何用弱引用和无主引用来打破这些循环强引用。</p>
<p>循环强引用还会发生在当你将一个闭包赋值给类实例的某个属性，并且这个闭包体中又使用了这个类实例时。这个闭包体中可能访问了实例的某个属性，例如<code>self.someProperty</code>，或者闭包中调用了实例的某个方法，例如<code>self.someMethod()</code>。这两种情况都导致了闭包“捕获”<code>self</code>，从而产生了循环强引用。</p>
<p>循环强引用的产生，是因为闭包和类相似，都是引用类型。当你把一个闭包赋值给某个属性时，你是将这个闭包的引用赋值给了属性。实质上，这跟之前的问题是一样的——两个强引用让彼此一直有效。但是，和两个类实例不同，这次一个是类实例，另一个是闭包。</p>
<p>Swift 提供了一种优雅的方法来解决这个问题，称之为闭包捕获列表（closuer capture list）。同样的，在学习如何用闭包捕获列表破坏循环强引用之前，先来了解一下这里的循环强引用是如何产生的，这对我们很有帮助。</p>
<p>下面的例子为你展示了当一个闭包引用了<code>self</code>后是如何产生一个循环强引用的。例子中定义了一个叫<code>HTMLElement</code>的类，用一种简单的模型表示 HTML 文档中的一个单独的元素：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> text: <span class="type">String</span>?</span><br><span class="line"></span><br><span class="line">    lazy <span class="keyword">var</span> asHTML: <span class="type">Void</span> -&gt; <span class="type">String</span> = &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> text = <span class="keyword">self</span>.text &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"&lt;<span class="subst">\(<span class="keyword">self</span>.name)</span>&gt;<span class="subst">\(text)</span>&lt;/<span class="subst">\(<span class="keyword">self</span>.name)</span>&gt;"</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"&lt;<span class="subst">\(<span class="keyword">self</span>.name)</span> /&gt;"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, text: <span class="type">String</span>? = <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.text = text</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span> is being deinitialized"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>HTMLElement</code>类定义了一个<code>name</code>属性来表示这个元素的名称，例如代表段落的<code>“p”</code>，或者代表换行的<code>“br”</code>。<code>HTMLElement</code>还定义了一个可选属性<code>text</code>，用来设置 HTML 元素呈现的文本。</p>
<p>除了上面的两个属性，<code>HTMLElement</code>还定义了一个<code>lazy</code>属性<code>asHTML</code>。这个属性引用了一个将<code>name</code>和<code>text</code>组合成 HTML 字符串片段的闭包。该属性是<code>Void -&gt; String</code>类型，或者可以理解为“一个没有参数，返回<code>String</code>的函数”。</p>
<p>默认情况下，闭包赋值给了<code>asHTML</code>属性，这个闭包返回一个代表 HTML 标签的字符串。如果<code>text</code>值存在，该标签就包含可选值<code>text</code>；如果<code>text</code>不存在，该标签就不包含文本。对于段落元素，根据<code>text</code>是<code>“some text”</code>还是<code>nil</code>，闭包会返回<code>&quot;&lt;p&gt;some text&lt;/p&gt;&quot;</code>或者<code>&quot;&lt;p /&gt;&quot;</code>。</p>
<p>可以像实例方法那样去命名、使用<code>asHTML</code>属性。然而，由于<code>asHTML</code>是闭包而不是实例方法，如果你想改变特定 HTML 元素的处理方式的话，可以用自定义的闭包来取代默认值。</p>
<p>例如，可以将一个闭包赋值给<code>asHTML</code>属性，这个闭包能在<code>text</code>属性是<code>nil</code>时使用默认文本，这是为了避免返回一个空的 HTML 标签：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> heading = <span class="type">HTMLElement</span>(name: <span class="string">"h1"</span>)</span><br><span class="line"><span class="keyword">let</span> defaultText = <span class="string">"some default text"</span></span><br><span class="line">heading.asHTML = &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&lt;<span class="subst">\(heading.name)</span>&gt;<span class="subst">\(heading.text ?? defaultText)</span>&lt;/<span class="subst">\(heading.name)</span>&gt;"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(heading.asHTML())</span><br><span class="line"><span class="comment">// 打印 “&lt;h1&gt;some default text&lt;/h1&gt;”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br><code>asHTML</code>声明为<code>lazy</code>属性，因为只有当元素确实需要被处理为 HTML 输出的字符串时，才需要使用<code>asHTML</code>。也就是说，在默认的闭包中可以使用<code>self</code>，因为只有当初始化完成以及<code>self</code>确实存在后，才能访问<code>lazy</code>属性。</p>
</blockquote>
<p><code>HTMLElement</code>类只提供了一个构造函数，通过<code>name</code>和<code>text</code>（如果有的话）参数来初始化一个新元素。该类也定义了一个析构函数，当<code>HTMLElement</code>实例被销毁时，打印一条消息。</p>
<p>下面的代码展示了如何用<code>HTMLElement</code>类创建实例并打印消息：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> paragraph: <span class="type">HTMLElement</span>? = <span class="type">HTMLElement</span>(name: <span class="string">"p"</span>, text: <span class="string">"hello, world"</span>)</span><br><span class="line"><span class="built_in">print</span>(paragraph!.asHTML())</span><br><span class="line"><span class="comment">// 打印 “hello, world”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>上面的<code>paragraph</code>变量定义为可选类型的<code>HTMLElement</code>，因此我们可以赋值<code>nil</code>给它来演示循环强引用。</p>
</blockquote>
<p>不幸的是，上面写的<code>HTMLElement</code>类产生了类实例和作为<code>asHTML</code>默认值的闭包之间的循环强引用。循环强引用如下图所示：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/closureReferenceCycle01_2x.png" alt=""></p>
<p>实例的<code>asHTML</code>属性持有闭包的强引用。但是，闭包在其闭包体内使用了<code>self</code>（引用了<code>self.name</code>和<code>self.text</code>），因此闭包捕获了<code>self</code>，这意味着闭包又反过来持有了<code>HTMLElement</code>实例的强引用。这样两个对象就产生了循环强引用。（更多关于闭包捕获值的信息，请参考<a href="./07_Closures.html#capturing_values">值捕获</a>）。</p>
<blockquote>
<p>注意<br>虽然闭包多次使用了<code>self</code>，它只捕获<code>HTMLElement</code>实例的一个强引用。</p>
</blockquote>
<p>如果设置<code>paragraph</code>变量为<code>nil</code>，打破它持有的<code>HTMLElement</code>实例的强引用，<code>HTMLElement</code>实例和它的闭包都不会被销毁，也是因为循环强引用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paragraph = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>HTMLElement</code>的析构函数中的消息并没有被打印，证明了<code>HTMLElement</code>实例并没有被销毁。</p>
<p><a name="resolving_strong_reference_cycles_for_closures"></a></p>
<p>##解决闭包引起的循环强引用</p>
<p>在定义闭包时同时定义捕获列表作为闭包的一部分，通过这种方式可以解决闭包和类实例之间的循环强引用。捕获列表定义了闭包体内捕获一个或者多个引用类型的规则。跟解决两个类实例间的循环强引用一样，声明每个捕获的引用为弱引用或无主引用，而不是强引用。应当根据代码关系来决定使用弱引用还是无主引用。</p>
<blockquote>
<p>注意<br>Swift 有如下要求：只要在闭包内使用<code>self</code>的成员，就要用<code>self.someProperty</code>或者<code>self.someMethod()</code>（而不只是<code>someProperty</code>或<code>someMethod()</code>）。这提醒你可能会一不小心就捕获了<code>self</code>。</p>
</blockquote>
<p><a name="defining_a_capture_list"></a></p>
<p>###定义捕获列表</p>
<p>捕获列表中的每一项都由一对元素组成，一个元素是<code>weak</code>或<code>unowned</code>关键字，另一个元素是类实例的引用（例如<code>self</code>）或初始化过的变量（如<code>delegate = self.delegate!</code>）。这些项在方括号中用逗号分开。</p>
<p>如果闭包有参数列表和返回类型，把捕获列表放在它们前面：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lazy <span class="keyword">var</span> someClosure: (<span class="type">Int</span>, <span class="type">String</span>) -&gt; <span class="type">String</span> = &#123;</span><br><span class="line">    [<span class="keyword">unowned</span> <span class="keyword">self</span>, <span class="keyword">weak</span> delegate = <span class="keyword">self</span>.delegate!] (index: <span class="type">Int</span>, stringToProcess: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// 这里是闭包的函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果闭包没有指明参数列表或者返回类型，即它们会通过上下文推断，那么可以把捕获列表和关键字<code>in</code>放在闭包最开始的地方：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lazy <span class="keyword">var</span> someClosure: <span class="type">Void</span> -&gt; <span class="type">String</span> = &#123;</span><br><span class="line">    [<span class="keyword">unowned</span> <span class="keyword">self</span>, <span class="keyword">weak</span> delegate = <span class="keyword">self</span>.delegate!] <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// 这里是闭包的函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="weak_and_unowned_references"></a></p>
<p>###弱引用和无主引用</p>
<p>在闭包和捕获的实例总是互相引用并且总是同时销毁时，将闭包内的捕获定义为无主引用。</p>
<p>相反的，在被捕获的引用可能会变为<code>nil</code>时，将闭包内的捕获定义为弱引用。弱引用总是可选类型，并且当引用的实例被销毁后，弱引用的值会自动置为<code>nil</code>。这使我们可以在闭包体内检查它们是否存在。</p>
<blockquote>
<p>注意<br>如果被捕获的引用绝对不会变为<code>nil</code>，应该用无主引用，而不是弱引用。</p>
</blockquote>
<p>前面的<code>HTMLElement</code>例子中，无主引用是正确的解决循环强引用的方法。这样编写<code>HTMLElement</code>类来避免循环强引用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> text: <span class="type">String</span>?</span><br><span class="line"></span><br><span class="line">    lazy <span class="keyword">var</span> asHTML: <span class="type">Void</span> -&gt; <span class="type">String</span> = &#123;</span><br><span class="line">        [<span class="keyword">unowned</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> text = <span class="keyword">self</span>.text &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"&lt;<span class="subst">\(<span class="keyword">self</span>.name)</span>&gt;<span class="subst">\(text)</span>&lt;/<span class="subst">\(<span class="keyword">self</span>.name)</span>&gt;"</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"&lt;<span class="subst">\(<span class="keyword">self</span>.name)</span> /&gt;"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, text: <span class="type">String</span>? = <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.text = text</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span> is being deinitialized"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的<code>HTMLElement</code>实现和之前的实现一致，除了在<code>asHTML</code>闭包中多了一个捕获列表。这里，捕获列表是<code>[unowned self]</code>，表示“将<code>self</code>捕获为无主引用而不是强引用”。</p>
<p>和之前一样，我们可以创建并打印<code>HTMLElement</code>实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> paragraph: <span class="type">HTMLElement</span>? = <span class="type">HTMLElement</span>(name: <span class="string">"p"</span>, text: <span class="string">"hello, world"</span>)</span><br><span class="line"><span class="built_in">print</span>(paragraph!.asHTML())</span><br><span class="line"><span class="comment">// 打印 “&lt;p&gt;hello, world&lt;/p&gt;”</span></span><br></pre></td></tr></table></figure>
<p>使用捕获列表后引用关系如下图所示：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/closureReferenceCycle02_2x.png" alt=""></p>
<p>这一次，闭包以无主引用的形式捕获<code>self</code>，并不会持有<code>HTMLElement</code>实例的强引用。如果将<code>paragraph</code>赋值为<code>nil</code>，<code>HTMLElement</code>实例将会被销毁，并能看到它的析构函数打印出的消息：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">paragraph = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// 打印 “p is being deinitialized”</span></span><br></pre></td></tr></table></figure>
<p>你可以查看<a href="../chapter3/04_Expressions.html">捕获列表</a>章节，获取更多关于捕获列表的信息。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/17_Optional_Chaining/" itemprop="url">
                第二章-17可选链式调用（Optional Chaining）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:10+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/17_Optional_Chaining/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/17_Optional_Chaining/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="可选链式调用（Optional_Chaining）">可选链式调用（Optional Chaining）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/Jasonbroker" target="_blank" rel="external">Jasonbroker</a><br>校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>, <a href="https://github.com/stanzhai" target="_blank" rel="external">stanzhai</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/lyojo" target="_blank" rel="external">lyojo</a></p>
<p>2.1<br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a>，2015-10-31</p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#optional_chaining_as_an_alternative_to_forced_unwrapping">使用可选链式调用代替强制展开</a></li>
<li><a href="#defining_model_classes_for_optional_chaining">为可选链式调用定义模型类</a></li>
<li><a href="#accessing_properties_through_optional_chaining">通过可选链式调用访问属性</a></li>
<li><a href="#calling_methods_through_optional_chaining">通过可选链式调用调用方法</a></li>
<li><a href="#accessing_subscripts_through_optional_chaining">通过可选链式调用访问下标</a></li>
<li><a href="#linking_multiple_levels_of_chaining">连接多层可选链式调用</a></li>
<li><a href="#chaining_on_methods_with_optional_return_values">在方法的可选返回值上进行可选链式调用</a></li>
</ul>
<p>可选链式调用（Optional Chaining）是一种可以在当前值可能为<code>nil</code>的可选值上请求和调用属性、方法及下标的方法。如果可选值有值，那么调用就会成功；如果可选值是<code>nil</code>，那么调用将返回<code>nil</code>。多个调用可以连接在一起形成一个调用链，如果其中任何一个节点为<code>nil</code>，整个调用链都会失败，即返回<code>nil</code>。</p>
<blockquote>
<p>注意<br>Swift 的可选链式调用和 Objective-C 中向<code>nil</code>发送消息有些相像，但是 Swift 的可选链式调用可以应用于任意类型，并且能检查调用是否成功。</p>
</blockquote>
<p><a name="optional_chaining_as_an_alternative_to_forced_unwrapping"></a></p>
<h2 id="使用可选链式调用代替强制展开">使用可选链式调用代替强制展开</h2><p>通过在想调用的属性、方法、或下标的可选值（optional value）后面放一个问号（<code>?</code>），可以定义一个可选链。这一点很像在可选值后面放一个叹号（<code>!</code>）来强制展开它的值。它们的主要区别在于当可选值为空时可选链式调用只会调用失败，然而强制展开将会触发运行时错误。</p>
<p>为了反映可选链式调用可以在空值（<code>nil</code>）上调用的事实，不论这个调用的属性、方法及下标返回的值是不是可选值，它的返回结果都是一个可选值。你可以利用这个返回值来判断你的可选链式调用是否调用成功，如果调用有返回值则说明调用成功，返回<code>nil</code>则说明调用失败。</p>
<p>特别地，可选链式调用的返回结果与原本的返回结果具有相同的类型，但是被包装成了一个可选值。例如，使用可选链式调用访问属性，当可选链式调用成功时，如果属性原本的返回结果是<code>Int</code>类型，则会变为<code>Int?</code>类型。</p>
<p>下面几段代码将解释可选链式调用和强制展开的不同。</p>
<p>首先定义两个类<code>Person</code>和<code>Residence</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> residence: <span class="type">Residence</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Residence</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> numberOfRooms = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Residence</code>有一个<code>Int</code>类型的属性<code>numberOfRooms</code>，其默认值为<code>1</code>。<code>Person</code>具有一个可选的<code>residence</code>属性，其类型为<code>Residence?</code>。</p>
<p>如果创建一个新的<code>Person</code>实例，因为它的<code>residence</code>属性是可选的，<code>john</code>属性将初始化为<code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> john = <span class="type">Person</span>()</span><br></pre></td></tr></table></figure>
<p>如果使用叹号（<code>!</code>）强制展开获得这个<code>john</code>的<code>residence</code>属性中的<code>numberOfRooms</code>值，会触发运行时错误，因为这时<code>residence</code>没有可以展开的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> roomCount = john.residence!.numberOfRooms</span><br><span class="line"><span class="comment">// 这会引发运行时错误</span></span><br></pre></td></tr></table></figure>
<p><code>john.residence</code>为非<code>nil</code>值的时候，上面的调用会成功，并且把<code>roomCount</code>设置为<code>Int</code>类型的房间数量。正如上面提到的，当<code>residence</code>为<code>nil</code>的时候上面这段代码会触发运行时错误。</p>
<p>可选链式调用提供了另一种访问<code>numberOfRooms</code>的方式，使用问号（<code>?</code>）来替代原来的叹号（<code>!</code>）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> roomCount = john.residence?.numberOfRooms &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"John's residence has <span class="subst">\(roomCount)</span> room(s)."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Unable to retrieve the number of rooms."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “Unable to retrieve the number of rooms.”</span></span><br></pre></td></tr></table></figure>
<p>在<code>residence</code>后面添加问号之后，Swift 就会在<code>residence</code>不为<code>nil</code>的情况下访问<code>numberOfRooms</code>。</p>
<p>因为访问<code>numberOfRooms</code>有可能失败，可选链式调用会返回<code>Int?</code>类型，或称为“可选的 <code>Int</code>”。如上例所示，当<code>residence</code>为<code>nil</code>的时候，可选的<code>Int</code>将会为<code>nil</code>，表明无法访问<code>numberOfRooms</code>。访问成功时，可选的<code>Int</code>值会通过可选绑定展开，并赋值给非可选类型的<code>roomCount</code>常量。</p>
<p>要注意的是，即使<code>numberOfRooms</code>是非可选的<code>Int</code>时，这一点也成立。只要使用可选链式调用就意味着<code>numberOfRooms</code>会返回一个<code>Int?</code>而不是<code>Int</code>。</p>
<p>可以将一个<code>Residence</code>的实例赋给<code>john.residence</code>，这样它就不再是<code>nil</code>了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">john.residence = <span class="type">Residence</span>()</span><br></pre></td></tr></table></figure>
<p><code>john.residence</code>现在包含一个实际的<code>Residence</code>实例，而不再是<code>nil</code>。如果你试图使用先前的可选链式调用访问<code>numberOfRooms</code>，它现在将返回值为<code>1</code>的<code>Int?</code>类型的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> roomCount = john.residence?.numberOfRooms &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"John's residence has <span class="subst">\(roomCount)</span> room(s)."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Unable to retrieve the number of rooms."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “John's residence has 1 room(s).”</span></span><br></pre></td></tr></table></figure>
<p><a name="defining_model_classes_for_optional_chaining"></a></p>
<h2 id="为可选链式调用定义模型类">为可选链式调用定义模型类</h2><p>通过使用可选链式调用可以调用多层属性、方法和下标。这样可以在复杂的模型中向下访问各种子属性，并且判断能否访问子属性的属性、方法或下标。</p>
<p>下面这段代码定义了四个模型类，这些例子包括多层可选链式调用。为了方便说明，在<code>Person</code>和<code>Residence</code>的基础上增加了<code>Room</code>类和<code>Address</code>类，以及相关的属性、方法以及下标。</p>
<p><code>Person</code>类的定义基本保持不变：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> residence: <span class="type">Residence</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Residence</code>类比之前复杂些，增加了一个名为<code>rooms</code>的变量属性，该属性被初始化为<code>[Room]</code>类型的空数组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Residence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rooms = [<span class="type">Room</span>]()</span><br><span class="line">    <span class="keyword">var</span> numberOfRooms: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rooms.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">Room</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> rooms[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            rooms[i] = newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">printNumberOfRooms</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"The number of rooms is <span class="subst">\(numberOfRooms)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> address: <span class="type">Address</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在<code>Residence</code>有了一个存储<code>Room</code>实例的数组，<code>numberOfRooms</code>属性被实现为计算型属性，而不是存储型属性。<code>numberOfRooms</code>属性简单地返回<code>rooms</code>数组的<code>count</code>属性的值。</p>
<p><code>Residence</code>还提供了访问<code>rooms</code>数组的快捷方式，即提供可读写的下标来访问<code>rooms</code>数组中指定位置的元素。</p>
<p>此外，<code>Residence</code>还提供了<code>printNumberOfRooms()</code>方法，这个方法的作用是打印<code>numberOfRooms</code>的值。</p>
<p>最后，<code>Residence</code>还定义了一个可选属性<code>address</code>，其类型为<code>Address?</code>。<code>Address</code>类的定义在下面会说明。</p>
<p><code>Room</code>类是一个简单类，其实例被存储在<code>rooms</code>数组中。该类只包含一个属性<code>name</code>，以及一个用于将该属性设置为适当的房间名的初始化函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Room</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123; <span class="keyword">self</span>.name = name &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一个类是<code>Address</code>，这个类有三个<code>String?</code>类型的可选属性。<code>buildingName</code>以及<code>buildingNumber</code>属性分别表示某个大厦的名称和号码，第三个属性<code>street</code>表示大厦所在街道的名称：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> buildingName: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> buildingNumber: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> street: <span class="type">String</span>?</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">buildingIdentifier</span><span class="params">()</span></span> -&gt; <span class="type">String</span>? &#123;</span><br><span class="line">        <span class="keyword">if</span> buildingName != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> buildingName</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> buildingNumber != <span class="literal">nil</span> &amp;&amp; street != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"<span class="subst">\(buildingNumber)</span> <span class="subst">\(street)</span>"</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Address</code>类提供了<code>buildingIdentifier()</code>方法，返回值为<code>String?</code>。 如果<code>buildingName</code>有值则返回<code>buildingName</code>。或者，如果<code>buildingNumber</code>和<code>street</code>均有值则返回<code>buildingNumber</code>。否则，返回<code>nil</code>。</p>
<p><a name="accessing_properties_through_optional_chaining"></a></p>
<h2 id="通过可选链式调用访问属性">通过可选链式调用访问属性</h2><p>正如<a href="#optional_chaining_as_an_alternative_to_forced_unwrapping">使用可选链式调用代替强制展开</a>中所述，可以通过可选链式调用在一个可选值上访问它的属性，并判断访问是否成功。</p>
<p>下面的代码创建了一个<code>Person</code>实例，然后像之前一样，尝试访问<code>numberOfRooms</code>属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> john = <span class="type">Person</span>()</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> roomCount = john.residence?.numberOfRooms &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"John's residence has <span class="subst">\(roomCount)</span> room(s)."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Unable to retrieve the number of rooms."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “Unable to retrieve the number of rooms.”</span></span><br></pre></td></tr></table></figure>
<p>因为<code>john.residence</code>为<code>nil</code>，所以这个可选链式调用依旧会像先前一样失败。</p>
<p>还可以通过可选链式调用来设置属性值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someAddress = <span class="type">Address</span>()</span><br><span class="line">someAddress.buildingNumber = <span class="string">"29"</span></span><br><span class="line">someAddress.street = <span class="string">"Acacia Road"</span></span><br><span class="line">john.residence?.address = someAddress</span><br></pre></td></tr></table></figure>
<p>在这个例子中，通过<code>john.residence</code>来设定<code>address</code>属性也会失败，因为<code>john.residence</code>当前为<code>nil</code>。</p>
<p>上面代码中的赋值过程是可选链式调用的一部分，这意味着可选链式调用失败时，等号右侧的代码不会被执行。对于上面的代码来说，很难验证这一点，因为像这样赋值一个常量没有任何副作用。下面的代码完成了同样的事情，但是它使用一个函数来创建<code>Address</code>实例，然后将该实例返回用于赋值。该函数会在返回前打印“Function was called”，这使你能验证等号右侧的代码是否被执行。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">createAddress</span><span class="params">()</span></span> -&gt; <span class="type">Address</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Function was called."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> someAddress = <span class="type">Address</span>()</span><br><span class="line">    someAddress.buildingNumber = <span class="string">"29"</span></span><br><span class="line">    someAddress.street = <span class="string">"Acacia Road"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> someAddress</span><br><span class="line">&#125;</span><br><span class="line">john.residence?.address = createAddress()</span><br></pre></td></tr></table></figure>
<p>没有任何打印消息，可以看出<code>createAddress()</code>函数并未被执行。</p>
<p><a name="calling_methods_through_optional_chaining"></a></p>
<h2 id="通过可选链式调用调用方法">通过可选链式调用调用方法</h2><p>可以通过可选链式调用来调用方法，并判断是否调用成功，即使这个方法没有返回值。</p>
<p><code>Residence</code>类中的<code>printNumberOfRooms()</code>方法打印当前的<code>numberOfRooms</code>值，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">printNumberOfRooms</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The number of rooms is <span class="subst">\(numberOfRooms)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法没有返回值。然而，没有返回值的方法具有隐式的返回类型<code>Void</code>，如<a href="./06_Functions.html#functions_without_return_values">无返回值函数</a>中所述。这意味着没有返回值的方法也会返回<code>()</code>，或者说空的元组。</p>
<p>如果在可选值上通过可选链式调用来调用这个方法，该方法的返回类型会是<code>Void?</code>，而不是<code>Void</code>，因为通过可选链式调用得到的返回值都是可选的。这样我们就可以使用<code>if</code>语句来判断能否成功调用<code>printNumberOfRooms()</code>方法，即使方法本身没有定义返回值。通过判断返回值是否为<code>nil</code>可以判断调用是否成功：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> john.residence?.printNumberOfRooms() != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"It was possible to print the number of rooms."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"It was not possible to print the number of rooms."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “It was not possible to print the number of rooms.”</span></span><br></pre></td></tr></table></figure>
<p>同样的，可以据此判断通过可选链式调用为属性赋值是否成功。在上面的<a href="#accessing_properties_through_optional_chaining">通过可选链式调用访问属性</a>的例子中，我们尝试给<code>john.residence</code>中的<code>address</code>属性赋值，即使<code>residence</code>为<code>nil</code>。通过可选链式调用给属性赋值会返回<code>Void?</code>，通过判断返回值是否为<code>nil</code>就可以知道赋值是否成功：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (john.residence?.address = someAddress) != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"It was possible to set the address."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"It was not possible to set the address."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “It was not possible to set the address.”</span></span><br></pre></td></tr></table></figure>
<p><a name="accessing_subscripts_through_optional_chaining"></a></p>
<h2 id="通过可选链式调用访问下标">通过可选链式调用访问下标</h2><p>通过可选链式调用，我们可以在一个可选值上访问下标，并且判断下标调用是否成功。</p>
<blockquote>
<p>注意<br>通过可选链式调用访问可选值的下标时，应该将问号放在下标方括号的前面而不是后面。可选链式调用的问号一般直接跟在可选表达式的后面。</p>
</blockquote>
<p>下面这个例子用下标访问<code>john.residence</code>属性存储的<code>Residence</code>实例的<code>rooms</code>数组中的第一个房间的名称，因为<code>john.residence</code>为<code>nil</code>，所以下标调用失败了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstRoomName = john.residence?[<span class="number">0</span>].name &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The first room name is <span class="subst">\(firstRoomName)</span>."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Unable to retrieve the first room name."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “Unable to retrieve the first room name.”</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，问号直接放在<code>john.residence</code>的后面，并且在方括号的前面，因为<code>john.residence</code>是可选值。</p>
<p>类似的，可以通过下标，用可选链式调用来赋值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">john.residence?[<span class="number">0</span>] = <span class="type">Room</span>(name: <span class="string">"Bathroom"</span>)</span><br></pre></td></tr></table></figure>
<p>这次赋值同样会失败，因为<code>residence</code>目前是<code>nil</code>。</p>
<p>如果你创建一个<code>Residence</code>实例，并为其<code>rooms</code>数组添加一些<code>Room</code>实例，然后将<code>Residence</code>实例赋值给<code>john.residence</code>，那就可以通过可选链和下标来访问数组中的元素：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> johnsHouse = <span class="type">Residence</span>()</span><br><span class="line">johnsHouse.rooms.append(<span class="type">Room</span>(name: <span class="string">"Living Room"</span>))</span><br><span class="line">johnsHouse.rooms.append(<span class="type">Room</span>(name: <span class="string">"Kitchen"</span>))</span><br><span class="line">john.residence = johnsHouse</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstRoomName = john.residence?[<span class="number">0</span>].name &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"The first room name is <span class="subst">\(firstRoomName)</span>."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Unable to retrieve the first room name."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “The first room name is Living Room.”</span></span><br></pre></td></tr></table></figure>
<p><a name="accessing_subscripts_of_optional_type"></a></p>
<h3 id="访问可选类型的下标">访问可选类型的下标</h3><p>如果下标返回可选类型值，比如 Swift 中<code>Dictionary</code>类型的键的下标，可以在下标的结尾括号后面放一个问号来在其可选返回值上进行可选链式调用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> testScores = [<span class="string">"Dave"</span>: [<span class="number">86</span>, <span class="number">82</span>, <span class="number">84</span>], <span class="string">"Bev"</span>: [<span class="number">79</span>, <span class="number">94</span>, <span class="number">81</span>]]</span><br><span class="line">testScores[<span class="string">"Dave"</span>]?[<span class="number">0</span>] = <span class="number">91</span></span><br><span class="line">testScores[<span class="string">"Bev"</span>]?[<span class="number">0</span>]++</span><br><span class="line">testScores[<span class="string">"Brian"</span>]?[<span class="number">0</span>] = <span class="number">72</span></span><br><span class="line"><span class="comment">// "Dave" 数组现在是 [91, 82, 84]，"Bev" 数组现在是 [80, 94, 81]</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中定义了一个<code>testScores</code>数组，包含了两个键值对，把<code>String</code>类型的键映射到一个<code>Int</code>值的数组。这个例子用可选链式调用把<code>&quot;Dave&quot;</code>数组中第一个元素设为<code>91</code>，把<code>&quot;Bev&quot;</code>数组的第一个元素<code>+1</code>，然后尝试把<code>&quot;Brian&quot;</code>数组中的第一个元素设为<code>72</code>。前两个调用成功，因为<code>testScores</code>字典中包含<code>&quot;Dave&quot;</code>和<code>&quot;Bev&quot;</code>这两个键。但是<code>testScores</code>字典中没有<code>&quot;Brian&quot;</code>这个键，所以第三个调用失败。</p>
<p><a name="linking_multiple_levels_of_chaining"></a></p>
<h2 id="连接多层可选链式调用">连接多层可选链式调用</h2><p>可以通过连接多个可选链式调用在更深的模型层级中访问属性、方法以及下标。然而，多层可选链式调用不会增加返回值的可选层级。</p>
<p>也就是说：</p>
<ul>
<li>如果你访问的值不是可选的，可选链式调用将会返回可选值。</li>
<li>如果你访问的值就是可选的，可选链式调用不会让可选返回值变得“更可选”。</li>
</ul>
<p>因此：</p>
<ul>
<li>通过可选链式调用访问一个<code>Int</code>值，将会返回<code>Int?</code>，无论使用了多少层可选链式调用。</li>
<li>类似的，通过可选链式调用访问<code>Int?</code>值，依旧会返回<code>Int?</code>值，并不会返回<code>Int??</code>。</li>
</ul>
<p>下面的例子尝试访问<code>john</code>中的<code>residence</code>属性中的<code>address</code>属性中的<code>street</code>属性。这里使用了两层可选链式调用，<code>residence</code>以及<code>address</code>都是可选值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> johnsStreet = john.residence?.address?.street &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"John's street name is <span class="subst">\(johnsStreet)</span>."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Unable to retrieve the address."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “Unable to retrieve the address.”</span></span><br></pre></td></tr></table></figure>
<p><code>john.residence</code>现在包含一个有效的<code>Residence</code>实例。然而，<code>john.residence.address</code>的值当前为<code>nil</code>。因此，调用<code>john.residence?.address?.street</code>会失败。</p>
<p>需要注意的是，上面的例子中，<code>street</code>的属性为<code>String?</code>。<code>john.residence?.address?.street</code>的返回值也依然是<code>String?</code>，即使已经使用了两层可选链式调用。</p>
<p>如果为<code>john.residence.address</code>赋值一个<code>Address</code>实例，并且为<code>address</code>中的<code>street</code>属性设置一个有效值，我们就能过通过可选链式调用来访问<code>street</code>属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> johnsAddress = <span class="type">Address</span>()</span><br><span class="line">johnsAddress.buildingName = <span class="string">"The Larches"</span></span><br><span class="line">johnsAddress.street = <span class="string">"Laurel Street"</span></span><br><span class="line">john.residence?.address = johnsAddress</span><br><span class="line">	</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> johnsStreet = john.residence?.address?.street &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"John's street name is <span class="subst">\(johnsStreet)</span>."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Unable to retrieve the address."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “John's street name is Laurel Street.”</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，因为<code>john.residence</code>包含一个有效的<code>Residence</code>实例，所以对<code>john.residence</code>的<code>address</code>属性赋值将会成功。</p>
<p><a name="chaining_on_methods_with_optional_return_values"></a></p>
<h2 id="在方法的可选返回值上进行可选链式调用">在方法的可选返回值上进行可选链式调用</h2><p>上面的例子展示了如何在一个可选值上通过可选链式调用来获取它的属性值。我们还可以在一个可选值上通过可选链式调用来调用方法，并且可以根据需要继续在方法的可选返回值上进行可选链式调用。</p>
<p>在下面的例子中，通过可选链式调用来调用<code>Address</code>的<code>buildingIdentifier()</code>方法。这个方法返回<code>String?</code>类型的值。如上所述，通过可选链式调用来调用该方法，最终的返回值依旧会是<code>String?</code>类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> buildingIdentifier = john.residence?.address?.buildingIdentifier() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"John's building identifier is <span class="subst">\(buildingIdentifier)</span>."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “John's building identifier is The Larches.”</span></span><br></pre></td></tr></table></figure>
<p>如果要在该方法的返回值上进行可选链式调用，在方法的圆括号后面加上问号即可：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> beginsWithThe =</span><br><span class="line">	john.residence?.address?.buildingIdentifier()?.hasPrefix(<span class="string">"The"</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> beginsWithThe &#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">"John's building identifier begins with \"The\"."</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">"John's building identifier does not begin with \"The\"."</span>)</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “John's building identifier begins with "The".”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>在上面的例子中，在方法的圆括号后面加上问号是因为你要在<code>buildingIdentifier()</code>方法的可选返回值上进行可选链式调用，而不是方法本身。</p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/18_Error_Handling/" itemprop="url">
                第二章-18错误处理（Error Handling）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:09+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/18_Error_Handling/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/18_Error_Handling/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="错误处理（Error_Handling）">错误处理（Error Handling）</h1><hr>
<blockquote>
<p>2.1<br>翻译+校对：<a href="https://github.com/lyojo" target="_blank" rel="external">lyojo</a> <a href="https://github.com/ray16897188" target="_blank" rel="external">ray16897188</a> 2015-10-23<br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a> 2015-10-24</p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#representing_and_throwing_errors">表示并抛出错误</a></li>
<li><a href="#handling_errors">处理错误</a></li>
<li><a href="#specifying_cleanup_actions">指定清理操作</a></li>
</ul>
<p><em>错误处理（Error handling）</em>是响应错误以及从错误中恢复的过程。Swift 提供了在运行时对可恢复错误的抛出、捕获、传递和操作的一流支持。</p>
<p>某些操作无法保证总是执行完所有代码或总是生成有用的结果。可选类型可用来表示值缺失，但是当某个操作失败时，最好能得知失败的原因，从而可以作出相应的应对。</p>
<p>举个例子，假如有个从磁盘上的某个文件读取数据并进行处理的任务，该任务会有多种可能失败的情况，包括指定路径下文件并不存在，文件不具有可读权限，或者文件编码格式不兼容。区分这些不同的失败情况可以让程序解决并处理某些错误，然后把它解决不了的错误报告给用户。</p>
<blockquote>
<p>注意<br>Swift 中的错误处理涉及到错误处理模式，这会用到 Cocoa 和 Objective-C 中的<code>NSError</code>。关于这个类的更多信息请参见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216" target="_blank" rel="external">Using Swift with Cocoa and Objective-C (Swift 2.1)</a> 中的<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-ID10" target="_blank" rel="external">错误处理</a>。</p>
</blockquote>
<p><a name="representing_and_throwing_errors"></a></p>
<p>##表示并抛出错误</p>
<p>在 Swift 中，错误用符合<code>ErrorType</code>协议的类型的值来表示。这个空协议表明该类型可以用于错误处理。</p>
<p>Swift 的枚举类型尤为适合构建一组相关的错误状态，枚举的关联值还可以提供错误状态的额外信息。例如，你可以这样表示在一个游戏中操作自动贩卖机时可能会出现的错误状态：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">VendingMachineError</span>: <span class="title">ErrorType</span> </span>&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">InvalidSelection</span>				     <span class="comment">//选择无效</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">InsufficientFunds</span>(coinsNeeded: <span class="type">Int</span>) <span class="comment">//金额不足</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">OutOfStock</span>			                 <span class="comment">//缺货</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抛出一个错误可以让你表明有意外情况发生，导致正常的执行流程无法继续执行。抛出错误使用<code>throws</code>关键字。例如，下面的代码抛出一个错误，提示贩卖机还需要<code>5</code>个硬币：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw <span class="type">VendingMachineError</span>.<span class="type">InsufficientFunds</span>(coinsNeeded: <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p><a name="handling_errors"></a></p>
<p>##处理错误</p>
<p>某个错误被抛出时，附近的某部分代码必须负责处理这个错误，例如纠正这个问题、尝试另外一种方式、或是向用户报告错误。</p>
<p>Swift 中有<code>4</code>种处理错误的方式。你可以把函数抛出的错误传递给调用此函数的代码、用<code>do-catch</code>语句处理错误、将错误作为可选类型处理、或者断言此错误根本不会发生。每种方式在下面的小节中都有描述。</p>
<p>当一个函数抛出一个错误时，你的程序流程会发生改变，所以重要的是你能迅速识别代码中会抛出错误的地方。为了标识出这些地方，在调用一个能抛出错误的函数、方法或者构造器之前，加上<code>try</code>关键字，或者<code>try?</code>或<code>try!</code>这种变体。这些关键字在下面的小节中有具体讲解。</p>
<blockquote>
<p>注意<br>Swift 中的错误处理和其他语言中用<code>try</code>，<code>catch</code>和<code>throw</code>进行异常处理很像。和其他语言中（包括 Objective-C ）的异常处理不同的是，Swift 中的错误处理并不涉及解除调用栈，这是一个计算代价高昂的过程。就此而言，<code>throw</code>语句的性能特性是可以和<code>return</code>语句相媲美的。</p>
</blockquote>
<p>###用 throwing 函数传递错误</p>
<p>为了表示一个函数、方法或构造器可以抛出错误，在函数声明的参数列表之后加上<code>throws</code>关键字。一个标有<code>throws</code>关键字的函数被称作<em>throwing 函数</em>。如果这个函数指明了返回值类型，<code>throws</code>关键词需要写在箭头（<code>-&gt;</code>）的前面。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">canThrowErrors</span><span class="params">()</span></span> throws -&gt; <span class="type">String</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">cannotThrowErrors</span><span class="params">()</span></span> -&gt; <span class="type">String</span></span><br></pre></td></tr></table></figure>
<p>一个 throwing 函数可以在其内部抛出错误，并将错误传递到函数被调用时的作用域。</p>
<blockquote>
<p>注意<br>只有 throwing 函数可以传递错误。任何在某个非 throwing 函数内部抛出的错误只能在函数内部处理。</p>
</blockquote>
<p>下面的例子中，<code>VendingMechine</code>类有一个<code>vend(itemNamed:)</code>方法，如果请求的物品不存在、缺货或者花费超过了投入金额，该方法就会抛出一个相应的<code>VendingMachineError</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> price: <span class="type">Int</span></span><br><span class="line">	<span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VendingMachine</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> inventory = [</span><br><span class="line">        <span class="string">"Candy Bar"</span>: <span class="type">Item</span>(price: <span class="number">12</span>, <span class="built_in">count</span>: <span class="number">7</span>),</span><br><span class="line">        <span class="string">"Chips"</span>: <span class="type">Item</span>(price: <span class="number">10</span>, <span class="built_in">count</span>: <span class="number">4</span>),</span><br><span class="line">        <span class="string">"Pretzels"</span>: <span class="type">Item</span>(price: <span class="number">7</span>, <span class="built_in">count</span>: <span class="number">11</span>)</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">var</span> coinsDeposited = <span class="number">0</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">dispenseSnack</span><span class="params">(snack: String)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Dispensing <span class="subst">\(snack)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">vend</span><span class="params">(itemNamed name: String)</span></span> throws &#123;</span><br><span class="line">        guard <span class="keyword">var</span> item = inventory[name] <span class="keyword">else</span> &#123;</span><br><span class="line">            throw <span class="type">VendingMachineError</span>.<span class="type">InvalidSelection</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        guard item.<span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            throw <span class="type">VendingMachineError</span>.<span class="type">OutOfStock</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        guard item.price &lt;= coinsDeposited <span class="keyword">else</span> &#123;</span><br><span class="line">            throw <span class="type">VendingMachineError</span>.<span class="type">InsufficientFunds</span>(coinsNeeded: item.price - coinsDeposited)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        coinsDeposited -= item.price</span><br><span class="line">        --item.<span class="built_in">count</span></span><br><span class="line">        inventory[name] = item</span><br><span class="line">        dispenseSnack(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>vend(itemNamed:)</code>方法的实现中使用了<code>guard</code>语句来提前退出方法，确保在购买某个物品所需的条件中，有任一条件不满足时，能提前退出方法并抛出相应的错误。由于<code>throw</code>语句会立即退出方法，所以物品只有在所有条件都满足时才会被售出。</p>
<p>因为<code>vend(itemNamed:)</code>方法会传递出它抛出的任何错误，在你的代码中调用此方法的地方，必须要么直接处理这些错误——使用<code>do-catch</code>语句，<code>try?</code>或<code>try!</code>；要么继续将这些错误传递下去。例如下面例子中，<code>buyFavoriteSnack(_:vendingMachine:)</code>同样是一个 throwing 函数，任何由<code>vend(itemNamed:)</code>方法抛出的错误会一直被传递到<code>buyFavoriteSnack(_:vendingMachine:)</code>函数被调用的地方。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> favoriteSnacks = [</span><br><span class="line">	<span class="string">"Alice"</span>: <span class="string">"Chips"</span>,</span><br><span class="line">	<span class="string">"Bob"</span>: <span class="string">"Licorice"</span>,</span><br><span class="line">	<span class="string">"Eve"</span>: <span class="string">"Pretzels"</span>,</span><br><span class="line">]</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">buyFavoriteSnack</span><span class="params">(person: String, vendingMachine: VendingMachine)</span></span> throws &#123;</span><br><span class="line">	<span class="keyword">let</span> snackName = favoriteSnacks[person] ?? <span class="string">"Candy Bar"</span></span><br><span class="line">	try vendingMachine.vend(itemNamed: snackName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例中，<code>buyFavoriteSnack(_:vendingMachine:)</code>函数会查找某人最喜欢的零食，并通过调用<code>vend(itemNamed:)</code>方法来尝试为他们购买。因为<code>vend(itemNamed:)</code>方法能抛出错误，所以在调用的它时候在它前面加了<code>try</code>关键字。</p>
<p>###用 Do-Catch 处理错误</p>
<p>可以使用一个<code>do-catch</code>语句运行一段闭包代码来处理错误。如果在<code>do</code>子句中的代码抛出了一个错误，这个错误会与<code>catch</code>子句做匹配，从而决定哪条子句能处理它。</p>
<p>下面是<code>do-catch</code>语句的一般形式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    try expression</span><br><span class="line">    statements</span><br><span class="line">&#125; catch pattern <span class="number">1</span> &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; catch pattern <span class="number">2</span> <span class="keyword">where</span> condition &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>catch</code>后面写一个匹配模式来表明这个子句能处理什么样的错误。如果一条<code>catch</code>子句没有指定匹配模式，那么这条子句可以匹配任何错误，并且把错误绑定到一个名字为<code>error</code>的局部常量。关于模式匹配的更多信息请参考 <a href="../chapter3/07_Patterns.html">模式</a>。</p>
<p><code>catch</code>子句不必将<code>do</code>子句中的代码所抛出的每一个可能的错误都作处理。如果所有<code>catch</code>子句都未处理错误，错误就会传递到周围的作用域。然而，错误还是必须要被某个周围的作用域处理的——要么是一个外围的<code>do-catch</code>错误处理语句，要么是一个 throwing 函数的内部。举例来说，下面的代码处理了<code>VendingMachineError</code>枚举类型的全部枚举值，但是所有其它的错误就必须由它周围的作用域处理：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vendingMachine = <span class="type">VendingMachine</span>()</span><br><span class="line">vendingMachine.coinsDeposited = <span class="number">8</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    try buyFavoriteSnack(<span class="string">"Alice"</span>, vendingMachine: vendingMachine)</span><br><span class="line">&#125; catch <span class="type">VendingMachineError</span>.<span class="type">InvalidSelection</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Invalid Selection."</span>)</span><br><span class="line">&#125; catch <span class="type">VendingMachineError</span>.<span class="type">OutOfStock</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Out of Stock."</span>)</span><br><span class="line">&#125; catch <span class="type">VendingMachineError</span>.<span class="type">InsufficientFunds</span>(<span class="keyword">let</span> coinsNeeded) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Insufficient funds. Please insert an additional <span class="subst">\(coinsNeeded)</span> coins."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “Insufficient funds. Please insert an additional 2 coins.”</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，<code>buyFavoriteSnack(_:vendingMachine:)</code>函数在一个<code>try</code>表达式中调用，因为它能抛出错误。如果错误被抛出，相应的执行会马上转移到<code>catch</code>子句中，并判断这个错误是否要被继续传递下去。如果没有错误抛出，<code>do</code>子句中余下的语句就会被执行。</p>
<p>###将错误转换成可选值</p>
<p>可以使用<code>try?</code>通过将错误转换成一个可选值来处理错误。如果在评估<code>try?</code>表达式时一个错误被抛出，那么表达式的值就是<code>nil</code>。例如下面代码中的<code>x</code>和<code>y</code>具有相同的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">someThrowingFunction</span><span class="params">()</span></span> throws -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> x = try? someThrowingFunction()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> y: <span class="type">Int</span>?</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    y = try someThrowingFunction()</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    y = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>someThrowingFunction()</code>抛出一个错误，<code>x</code>和<code>y</code>的值是<code>nil</code>。否则<code>x</code>和<code>y</code>的值就是该函数的返回值。注意，无论<code>someThrowingFunction()</code>的返回值类型是什么类型，<code>x</code>和<code>y</code>都是这个类型的可选类型。例子中此函数返回一个整型，所以<code>x</code>和<code>y</code>是可选整型。</p>
<p>如果你想对所有的错误都采用同样的方式来处理，用<code>try?</code>就可以让你写出简洁的错误处理代码。例如，下面的代码用几种方式来获取数据，如果所有方式都失败了则返回<code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">fetchData</span><span class="params">()</span></span> -&gt; <span class="type">Data</span>? &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> data = try? fetchDataFromDisk() &#123; <span class="keyword">return</span> data &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> data = try? fetchDataFromServer() &#123; <span class="keyword">return</span> data &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="禁用错误传递">禁用错误传递</h3><p>有时你知道某个 throwing 函数实际上在运行时是不会抛出错误的，在这种情况下，你可以在表达式前面写<code>try!</code>来禁用错误传递，这会把调用包装在一个断言不会有错误抛出的运行时断言中。如果实际上抛出了错误，你会得到一个运行时错误。</p>
<p>例如，下面的代码使用了<code>loadImage(_:)</code>函数，该函数从给定的路径加载图片资源，如果图片无法载入则抛出一个错误。在这种情况下，因为图片是和应用绑定的，运行时不会有错误抛出，所以适合禁用错误传递：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> photo = try! loadImage(<span class="string">"./Resources/John Appleseed.jpg"</span>)</span><br></pre></td></tr></table></figure>
<p><a name="specifying_cleanup_actions"></a></p>
<p>##指定清理操作</p>
<p>可以使用<code>defer</code>语句在即将离开当前代码块时执行一系列语句。该语句让你能执行一些必要的清理工作，不管是以何种方式离开当前代码块的——无论是由于抛出错误而离开，还是由于诸如<code>return</code>或者<code>break</code>的语句。例如，你可以用<code>defer</code>语句来确保文件描述符得以关闭，以及手动分配的内存得以释放。</p>
<p><code>defer</code>语句将代码的执行延迟到当前的作用域退出之前。该语句由<code>defer</code>关键字和要被延迟执行的语句组成。延迟执行的语句不能包含任何控制转移语句，例如<code>break</code>或是<code>return</code>语句，或是抛出一个错误。延迟执行的操作会按照它们被指定时的顺序的相反顺序执行——也就是说，第一条<code>defer</code>语句中的代码会在第二条<code>defer</code>语句中的代码被执行之后才执行，以此类推。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">processFile</span><span class="params">(filename: String)</span></span> throws &#123;</span><br><span class="line">    <span class="keyword">if</span> exists(filename) &#123;</span><br><span class="line">        <span class="keyword">let</span> file = open(filename)</span><br><span class="line">        defer &#123;</span><br><span class="line">            close(file)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> line = try file.readline() &#123;</span><br><span class="line">            <span class="comment">// 处理文件。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// close(file) 会在这里被调用，即作用域的最后。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码使用一条<code>defer</code>语句来确保<code>open(_:)</code>函数有一个相应的对<code>close(_:)</code>函数的调用。</p>
<blockquote>
<p>注意<br>即使没有涉及到错误处理，你也可以使用<code>defer</code>语句。</p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/19_Type_Casting/" itemprop="url">
                第二章-19类型转换（Type Casting）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:08+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/19_Type_Casting/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/19_Type_Casting/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="类型转换（Type_Casting）">类型转换（Type Casting）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/xiehurricane" target="_blank" rel="external">xiehurricane</a><br>校对：<a href="https://github.com/happyming" target="_blank" rel="external">happyming</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/yangsiy" target="_blank" rel="external">yangsiy</a></p>
<p>2.1<br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a>，2015-11-01</p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#defining_a_class_hierarchy_for_type_casting">定义一个类层次作为例子</a></li>
<li><a href="#checking_type">检查类型</a></li>
<li><a href="#downcasting">向下转型（Downcasting）</a></li>
<li><a href="#type_casting_for_any_and_anyobject"><code>Any</code> 和 <code>AnyObject</code> 的类型转换</a></li>
</ul>
<p><em>类型转换</em> 可以判断实例的类型，也可以将实例看做是其父类或者子类的实例。</p>
<p>类型转换在 Swift 中使用 <code>is</code> 和 <code>as</code> 操作符实现。这两个操作符提供了一种简单达意的方式去检查值的类型或者转换它的类型。</p>
<p>你也可以用它来检查一个类型是否实现了某个协议，就像在<a href="./22_Protocols.html#checking_for_protocol_conformance">检验协议的一致性</a>部分讲述的一样。</p>
<p><a name="defining_a_class_hierarchy_for_type_casting"></a></p>
<h2 id="定义一个类层次作为例子">定义一个类层次作为例子</h2><p>你可以将类型转换用在类和子类的层次结构上，检查特定类实例的类型并且转换这个类实例的类型成为这个层次结构中的其他类型。下面的三个代码段定义了一个类层次和一个包含了这些类实例的数组，作为类型转换的例子。</p>
<p>第一个代码片段定义了一个新的基类 <code>MediaItem</code>。这个类为任何出现在数字媒体库的媒体项提供基础功能。特别的，它声明了一个 <code>String</code> 类型的 <code>name</code> 属性，和一个 <code>init(name:)</code> 初始化器。（假定所有的媒体项都有个名称。）</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MediaItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一个代码段定义了 <code>MediaItem</code> 的两个子类。第一个子类 <code>Movie</code> 封装了与电影相关的额外信息，在父类（或者说基类）的基础上增加了一个 <code>director</code>（导演）属性，和相应的初始化器。第二个子类 <code>Song</code>，在父类的基础上增加了一个 <code>artist</code>（艺术家）属性，和相应的初始化器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Movie</span>: <span class="title">MediaItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> director: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, director: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.director = director</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Song</span>: <span class="title">MediaItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> artist: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, artist: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.artist = artist</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一个代码段创建了一个数组常量 <code>library</code>，包含两个 <code>Movie</code> 实例和三个 <code>Song</code> 实例。<code>library</code> 的类型是在它被初始化时根据它数组中所包含的内容推断来的。Swift 的类型检测器能够推断出 <code>Movie</code> 和 <code>Song</code> 有共同的父类 <code>MediaItem</code>，所以它推断出 <code>[MediaItem]</code> 类作为 <code>library</code> 的类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> library = [</span><br><span class="line">    <span class="type">Movie</span>(name: <span class="string">"Casablanca"</span>, director: <span class="string">"Michael Curtiz"</span>),</span><br><span class="line">    <span class="type">Song</span>(name: <span class="string">"Blue Suede Shoes"</span>, artist: <span class="string">"Elvis Presley"</span>),</span><br><span class="line">    <span class="type">Movie</span>(name: <span class="string">"Citizen Kane"</span>, director: <span class="string">"Orson Welles"</span>),</span><br><span class="line">    <span class="type">Song</span>(name: <span class="string">"The One And Only"</span>, artist: <span class="string">"Chesney Hawkes"</span>),</span><br><span class="line">    <span class="type">Song</span>(name: <span class="string">"Never Gonna Give You Up"</span>, artist: <span class="string">"Rick Astley"</span>)</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 数组 library 的类型被推断为 [MediaItem]</span></span><br></pre></td></tr></table></figure>
<p>在幕后 <code>library</code> 里存储的媒体项依然是 <code>Movie</code> 和 <code>Song</code> 类型的。但是，若你迭代它，依次取出的实例会是 <code>MediaItem</code> 类型的，而不是 <code>Movie</code> 和 <code>Song</code> 类型。为了让它们作为原本的类型工作，你需要检查它们的类型或者向下转换它们到其它类型，就像下面描述的一样。</p>
<p><a name="checking_type"></a></p>
<h2 id="检查类型（Checking_Type）">检查类型（Checking Type）</h2><p>用类型检查操作符（<code>is</code>）来检查一个实例是否属于特定子类型。若实例属于那个子类型，类型检查操作符返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p>下面的例子定义了两个变量，<code>movieCount</code> 和 <code>songCount</code>，用来计算数组 <code>library</code> 中 <code>Movie</code> 和 <code>Song</code> 类型的实例数量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> movieCount = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> songCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> library &#123;</span><br><span class="line">    <span class="keyword">if</span> item <span class="keyword">is</span> <span class="type">Movie</span> &#123;</span><br><span class="line">        ++movieCount</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> item <span class="keyword">is</span> <span class="type">Song</span> &#123;</span><br><span class="line">        ++songCount</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Media library contains <span class="subst">\(movieCount)</span> movies and <span class="subst">\(songCount)</span> songs"</span>)</span><br><span class="line"><span class="comment">// 打印 “Media library contains 2 movies and 3 songs”</span></span><br></pre></td></tr></table></figure>
<p>示例迭代了数组 <code>library</code> 中的所有项。每一次，<code>for-in</code> 循环设置<br><code>item</code> 为数组中的下一个 <code>MediaItem</code>。</p>
<p>若当前 <code>MediaItem</code> 是一个 <code>Movie</code> 类型的实例，<code>item is Movie</code> 返回<br><code>true</code>，否则返回 <code>false</code>。同样的，<code>item is Song</code> 检查 <code>item</code> 是否为 <code>Song</code> 类型的实例。在循环结束后，<code>movieCount</code> 和 <code>songCount</code> 的值就是被找到的属于各自类型的实例的数量。</p>
<p><a name="downcasting"></a></p>
<h2 id="向下转型（Downcasting）">向下转型（Downcasting）</h2><p>某类型的一个常量或变量可能在幕后实际上属于一个子类。当确定是这种情况时，你可以尝试向下转到它的子类型，用类型转换操作符（<code>as?</code> 或 <code>as!</code>）。</p>
<p>因为向下转型可能会失败，类型转型操作符带有两种不同形式。条件形式（conditional form）<code>as?</code> 返回一个你试图向下转成的类型的可选值（optional value）。强制形式 <code>as!</code> 把试图向下转型和强制解包（force-unwraps）转换结果结合为一个操作。</p>
<p>当你不确定向下转型可以成功时，用类型转换的条件形式（<code>as?</code>）。条件形式的类型转换总是返回一个可选值（optional value），并且若下转是不可能的，可选值将是 <code>nil</code>。这使你能够检查向下转型是否成功。</p>
<p>只有你可以确定向下转型一定会成功时，才使用强制形式（<code>as!</code>）。当你试图向下转型为一个不正确的类型时，强制形式的类型转换会触发一个运行时错误。</p>
<p>下面的例子，迭代了 <code>library</code> 里的每一个 <code>MediaItem</code>，并打印出适当的描述。要这样做，<code>item</code> 需要真正作为 <code>Movie</code> 或 <code>Song</code> 的类型来使用，而不仅仅是作为 <code>MediaItem</code>。为了能够在描述中使用 <code>Movie</code> 或 <code>Song</code> 的 <code>director</code> 或 <code>artist</code> 属性，这是必要的。</p>
<p>在这个示例中，数组中的每一个 <code>item</code> 可能是 <code>Movie</code> 或 <code>Song</code>。事前你不知道每个 <code>item</code> 的真实类型，所以这里使用条件形式的类型转换（<code>as?</code>）去检查循环里的每次下转：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> library &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> movie = item <span class="keyword">as</span>? <span class="type">Movie</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Movie: '<span class="subst">\(movie.name)</span>', dir. <span class="subst">\(movie.director)</span>"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> song = item <span class="keyword">as</span>? <span class="type">Song</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Song: '<span class="subst">\(song.name)</span>', by <span class="subst">\(song.artist)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Movie: 'Casablanca', dir. Michael Curtiz</span></span><br><span class="line"><span class="comment">// Song: 'Blue Suede Shoes', by Elvis Presley</span></span><br><span class="line"><span class="comment">// Movie: 'Citizen Kane', dir. Orson Welles</span></span><br><span class="line"><span class="comment">// Song: 'The One And Only', by Chesney Hawkes</span></span><br><span class="line"><span class="comment">// Song: 'Never Gonna Give You Up', by Rick Astley</span></span><br></pre></td></tr></table></figure>
<p>示例首先试图将 <code>item</code> 下转为 <code>Movie</code>。因为 <code>item</code> 是一个 <code>MediaItem</code><br>类型的实例，它可能是一个 <code>Movie</code>；同样，它也可能是一个 <code>Song</code>，或者仅仅是基类<br><code>MediaItem</code>。因为不确定，<code>as?</code> 形式在试图下转时将返回一个可选值。<code>item as? Movie</code> 的返回值是 <code>Movie?</code> 或者说“可选 <code>Movie</code>”。</p>
<p>当向下转型为 <code>Movie</code> 应用在两个 <code>Song</code><br>实例时将会失败。为了处理这种情况，上面的例子使用了可选绑定（optional binding）来检查可选 <code>Movie</code> 真的包含一个值（这个是为了判断下转是否成功。）可选绑定是这样写的“<code>if let movie = item as? Movie</code>”，可以这样解读：</p>
<p>“尝试将 <code>item</code> 转为 <code>Movie</code> 类型。若成功，设置一个新的临时常量 <code>movie</code> 来存储返回的可选 <code>Movie</code> 中的值”</p>
<p>若向下转型成功，然后 <code>movie</code> 的属性将用于打印一个 <code>Movie</code> 实例的描述，包括它的导演的名字 <code>director</code>。相似的原理被用来检测 <code>Song</code> 实例，当 <code>Song</code> 被找到时则打印它的描述（包含 <code>artist</code> 的名字）。</p>
<blockquote>
<p>注意<br>转换没有真的改变实例或它的值。根本的实例保持不变；只是简单地把它作为它被转换成的类型来使用。</p>
</blockquote>
<p><a name="type_casting_for_any_and_anyobject"></a></p>
<h2 id="Any_和_AnyObject_的类型转换"><code>Any</code> 和 <code>AnyObject</code> 的类型转换</h2><p>Swift 为不确定类型提供了两种特殊的类型别名：</p>
<ul>
<li><code>AnyObject</code> 可以表示任何类类型的实例。</li>
<li><code>Any</code> 可以表示任何类型，包括函数类型。</li>
</ul>
<blockquote>
<p>注意<br>只有当你确实需要它们的行为和功能时才使用 <code>Any</code> 和 <code>AnyObject</code>。在你的代码里使用你期望的明确类型总是更好的。</p>
</blockquote>
<p><a name="anyobject"></a></p>
<h3 id="AnyObject_类型"><code>AnyObject</code> 类型</h3><p>当在工作中使用 Cocoa APIs 时，我们经常会接收到一个 <code>[AnyObject]</code> 类型的数组，或者说“一个任意类型对象的数组”。这是因为 Objective-C 没有明确的类型化数组。但是，你常常可以从 API 提供的信息来确定数组中对象的类型。</p>
<blockquote>
<p>译者注<br>这段文档似乎没有及时更新，从 Xcode 7 和 Swift 2.0 开始，由于 Objective-C 引入了轻量泛型，集合类型已经可以类型化了，在 Swift 中使用 Cocoa API 也越来越少遇到 <code>AnyObject</code> 类型了。详情请参阅 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID173" target="_blank" rel="external">Lightweight Generics</a> 和 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID69" target="_blank" rel="external">Collection Classes</a>。</p>
</blockquote>
<p>在这些情况下，你可以使用强制形式的类型转换（<code>as</code>）来下转数组中的每一项到比 <code>AnyObject</code> 更明确的类型，不需要可选解包（optional unwrapping）。</p>
<p>下面的示例定义了一个 <code>[AnyObject]</code> 类型的数组并填入三个 <code>Movie</code> 类型的实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someObjects: [<span class="type">AnyObject</span>] = [</span><br><span class="line">    <span class="type">Movie</span>(name: <span class="string">"2001: A Space Odyssey"</span>, director: <span class="string">"Stanley Kubrick"</span>),</span><br><span class="line">    <span class="type">Movie</span>(name: <span class="string">"Moon"</span>, director: <span class="string">"Duncan Jones"</span>),</span><br><span class="line">    <span class="type">Movie</span>(name: <span class="string">"Alien"</span>, director: <span class="string">"Ridley Scott"</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>因为知道这个数组只包含 <code>Movie</code> 实例，你可以直接用（<code>as!</code>）下转并解包到非可选的 <code>Movie</code> 类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> object <span class="keyword">in</span> someObjects &#123;</span><br><span class="line">    <span class="keyword">let</span> movie = object <span class="keyword">as</span>! <span class="type">Movie</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Movie: '<span class="subst">\(movie.name)</span>', dir. <span class="subst">\(movie.director)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Movie: '2001: A Space Odyssey', dir. Stanley Kubrick</span></span><br><span class="line"><span class="comment">// Movie: 'Moon', dir. Duncan Jones</span></span><br><span class="line"><span class="comment">// Movie: 'Alien', dir. Ridley Scott</span></span><br></pre></td></tr></table></figure>
<p>为了变为一个更简短的形式，下转 <code>someObjects</code> 数组为 <code>[Movie]</code> 类型而不是下转数组中的每一项：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> movie <span class="keyword">in</span> someObjects <span class="keyword">as</span>! [<span class="type">Movie</span>] &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Movie: '<span class="subst">\(movie.name)</span>', dir. <span class="subst">\(movie.director)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Movie: '2001: A Space Odyssey', dir. Stanley Kubrick</span></span><br><span class="line"><span class="comment">// Movie: 'Moon', dir. Duncan Jones</span></span><br><span class="line"><span class="comment">// Movie: 'Alien', dir. Ridley Scott</span></span><br></pre></td></tr></table></figure>
<p><a name="any"></a></p>
<h3 id="Any_类型"><code>Any</code> 类型</h3><p>这里有个示例，使用 <code>Any</code> 类型来和混合的不同类型一起工作，包括函数类型和非类类型。它创建了一个可以存储 <code>Any</code> 类型的数组 <code>things</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> things = [<span class="type">Any</span>]()</span><br><span class="line"></span><br><span class="line">things.append(<span class="number">0</span>)</span><br><span class="line">things.append(<span class="number">0.0</span>)</span><br><span class="line">things.append(<span class="number">42</span>)</span><br><span class="line">things.append(<span class="number">3.14159</span>)</span><br><span class="line">things.append(<span class="string">"hello"</span>)</span><br><span class="line">things.append((<span class="number">3.0</span>, <span class="number">5.0</span>))</span><br><span class="line">things.append(<span class="type">Movie</span>(name: <span class="string">"Ghostbusters"</span>, director: <span class="string">"Ivan Reitman"</span>))</span><br><span class="line">things.append(&#123; (name: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span> <span class="string">"Hello, <span class="subst">\(name)</span>"</span> &#125;)</span><br></pre></td></tr></table></figure>
<p><code>things</code> 数组包含两个 <code>Int</code> 值，两个 <code>Double</code> 值，一个 <code>String</code> 值，一个元组 <code>(Double, Double)</code>，一个<code>Movie</code>实例“Ghostbusters”，以及一个接受 <code>String</code> 值并返回另一个 <code>String</code> 值的闭包表达式。</p>
<p>你可以在 <code>switch</code> 表达式的 <code>case</code> 中使用 <code>is</code> 和 <code>as</code> 操作符来找出只知道是 <code>Any</code> 或 <code>AnyObject</code> 类型的常量或变量的具体类型。下面的示例迭代 <code>things</code> 数组中的每一项，并用 <code>switch</code> 语句查找每一项的类型。有几个 <code>switch</code> 语句的 <code>case</code> 绑定它们匹配到的值到一个指定类型的常量，从而可以打印这些值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> thing <span class="keyword">in</span> things &#123;</span><br><span class="line">    <span class="keyword">switch</span> thing &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span> <span class="keyword">as</span> <span class="type">Int</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"zero as an Int"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span> <span class="keyword">as</span> <span class="type">Double</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"zero as a Double"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> someInt <span class="keyword">as</span> <span class="type">Int</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"an integer value of <span class="subst">\(someInt)</span>"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> someDouble <span class="keyword">as</span> <span class="type">Double</span> <span class="keyword">where</span> someDouble &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"a positive double value of <span class="subst">\(someDouble)</span>"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">is</span> <span class="type">Double</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"some other double value that I don't want to print"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> someString <span class="keyword">as</span> <span class="type">String</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"a string value of \"<span class="subst">\(someString)</span>\""</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">as</span> (<span class="type">Double</span>, <span class="type">Double</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"an (x, y) point at <span class="subst">\(x)</span>, <span class="subst">\(y)</span>"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> movie <span class="keyword">as</span> <span class="type">Movie</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"a movie called '<span class="subst">\(movie.name)</span>', dir. <span class="subst">\(movie.director)</span>"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> stringConverter <span class="keyword">as</span> <span class="type">String</span> -&gt; <span class="type">String</span>:</span><br><span class="line">        <span class="built_in">print</span>(stringConverter(<span class="string">"Michael"</span>))</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"something else"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// zero as an Int</span></span><br><span class="line"><span class="comment">// zero as a Double</span></span><br><span class="line"><span class="comment">// an integer value of 42</span></span><br><span class="line"><span class="comment">// a positive double value of 3.14159</span></span><br><span class="line"><span class="comment">// a string value of "hello"</span></span><br><span class="line"><span class="comment">// an (x, y) point at 3.0, 5.0</span></span><br><span class="line"><span class="comment">// a movie called 'Ghostbusters', dir. Ivan Reitman</span></span><br><span class="line"><span class="comment">// Hello, Michael</span></span><br></pre></td></tr></table></figure>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/20_Nested_Types/" itemprop="url">
                第二章-20嵌套类型（Nested Types）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:07+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/20_Nested_Types/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/20_Nested_Types/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="嵌套类型（Nested_Types）">嵌套类型（Nested Types）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/Lin-H" target="_blank" rel="external">Lin-H</a><br>校对：<a href="https://github.com/shinyzhu" target="_blank" rel="external">shinyzhu</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/SergioChan" target="_blank" rel="external">SergioChan</a></p>
<p>2.1<br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a>，2015-11-01</p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#nested_types_in_action">嵌套类型实践</a></li>
<li><a href="#referring_to_nested_types">引用嵌套类型</a></li>
</ul>
<p>枚举常被用于为特定类或结构体实现某些功能。类似的，也能够在某个复杂的类型中，方便地定义工具类或结构体来使用。为了实现这种功能，Swift 允许你定义嵌套类型，可以在支持的类型中定义嵌套的枚举、类和结构体。</p>
<p>要在一个类型中嵌套另一个类型，将嵌套类型的定义写在其外部类型的<code>{}</code>内，而且可以根据需要定义多级嵌套。</p>
<p><a name="nested_types_in_action"></a></p>
<h2 id="嵌套类型实践">嵌套类型实践</h2><p>下面这个例子定义了一个结构体<code>BlackjackCard</code>（二十一点），用来模拟<code>BlackjackCard</code>中的扑克牌点数。<code>BlackjackCard</code>结构体包含两个嵌套定义的枚举类型<code>Suit</code>和<code>Rank</code>。</p>
<p>在<code>BlackjackCard</code>中，<code>Ace</code>牌可以表示<code>1</code>或者<code>11</code>，<code>Ace</code>牌的这一特征通过一个嵌套在<code>Rank</code>枚举中的结构体<code>Values</code>来表示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BlackjackCard</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 嵌套的 Suit 枚举</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Suit</span>: <span class="title">Character</span> </span>&#123;</span><br><span class="line">       <span class="keyword">case</span> <span class="type">Spades</span> = <span class="string">"♠"</span>, <span class="type">Hearts</span> = <span class="string">"♡"</span>, <span class="type">Diamonds</span> = <span class="string">"♢"</span>, <span class="type">Clubs</span> = <span class="string">"♣"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 嵌套的 Rank 枚举</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Rank</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">       <span class="keyword">case</span> <span class="type">Two</span> = <span class="number">2</span>, <span class="type">Three</span>, <span class="type">Four</span>, <span class="type">Five</span>, <span class="type">Six</span>, <span class="type">Seven</span>, <span class="type">Eight</span>, <span class="type">Nine</span>, <span class="type">Ten</span></span><br><span class="line">       <span class="keyword">case</span> <span class="type">Jack</span>, <span class="type">Queen</span>, <span class="type">King</span>, <span class="type">Ace</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">Values</span> </span>&#123;</span><br><span class="line">           <span class="keyword">let</span> first: <span class="type">Int</span>, second: <span class="type">Int</span>?</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">var</span> values: <span class="type">Values</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Ace</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Values</span>(first: <span class="number">1</span>, second: <span class="number">11</span>)</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Jack</span>, .<span class="type">Queen</span>, .<span class="type">King</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Values</span>(first: <span class="number">10</span>, second: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Values</span>(first: <span class="keyword">self</span>.rawValue, second: <span class="literal">nil</span>)</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BlackjackCard 的属性和方法</span></span><br><span class="line">    <span class="keyword">let</span> rank: <span class="type">Rank</span>, suit: <span class="type">Suit</span></span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">    	<span class="keyword">var</span> output = <span class="string">"suit is <span class="subst">\(suit.rawValue)</span>,"</span></span><br><span class="line">        output += <span class="string">" value is <span class="subst">\(rank.values.first)</span>"</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> second = rank.values.second &#123;</span><br><span class="line">            output += <span class="string">" or <span class="subst">\(second)</span>"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Suit</code>枚举用来描述扑克牌的四种花色，并用一个<code>Character</code>类型的原始值表示花色符号。</p>
<p><code>Rank</code>枚举用来描述扑克牌从<code>Ace</code>~<code>10</code>，以及<code>J</code>、<code>Q</code>、<code>K</code>，这<code>13</code>种牌，并用一个<code>Int</code>类型的原始值表示牌的面值。（这个<code>Int</code>类型的原始值未用于<code>Ace</code>、<code>J</code>、<code>Q</code>、<code>K</code>这<code>4</code>种牌。）</p>
<p>如上所述，<code>Rank</code>枚举在内部定义了一个嵌套结构体<code>Values</code>。结构体<code>Values</code>中定义了两个属性，用于反映只有<code>Ace</code>有两个数值，其余牌都只有一个数值：</p>
<ul>
<li><code>first</code>的类型为<code>Int</code></li>
<li><code>second</code>的类型为<code>Int?</code>，或者说“optional <code>Int</code>”</li>
</ul>
<p><code>Rank</code>还定义了一个计算型属性<code>values</code>，它将会返回一个<code>Values</code>结构体的实例。这个计算型属性会根据牌的面值，用适当的数值去初始化<code>Values</code>实例。对于<code>J</code>、<code>Q</code>、<code>K</code>、<code>Ace</code>这四种牌，会使用特殊数值。对于数字面值的牌，使用枚举实例的原始值。</p>
<p><code>BlackjackCard</code>结构体拥有两个属性——<code>rank</code>与<code>suit</code>。它也同样定义了一个计算型属性<code>description</code>，<code>description</code>属性用<code>rank</code>和<code>suit</code>中的内容来构建对扑克牌名字和数值的描述。该属性使用可选绑定来检查可选类型<code>second</code>是否有值，若有值，则在原有的描述中增加对<code>second</code>的描述。</p>
<p>因为<code>BlackjackCard</code>是一个没有自定义构造器的结构体，在<a href="./14_Initialization.html#memberwise_initializers_for_structure_types">结构体的逐一成员构造器</a>中可知，结构体有默认的成员构造器，所以你可以用默认的构造器去初始化新常量<code>theAceOfSpades</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> theAceOfSpades = <span class="type">BlackjackCard</span>(rank: .<span class="type">Ace</span>, suit: .<span class="type">Spades</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"theAceOfSpades: <span class="subst">\(theAceOfSpades.description)</span>"</span>)</span><br><span class="line"><span class="comment">// 打印 “theAceOfSpades: suit is ♠, value is 1 or 11”</span></span><br></pre></td></tr></table></figure>
<p>尽管<code>Rank</code>和<code>Suit</code>嵌套在<code>BlackjackCard</code>中，但它们的类型仍可从上下文中推断出来，所以在初始化实例时能够单独通过成员名称（<code>.Ace</code>和<code>.Spades</code>）引用枚举实例。在上面的例子中，<code>description</code>属性正确地反映了黑桃A牌具有<code>1</code>和<code>11</code>两个值。</p>
<p><a name="referring_to_nested_types"></a></p>
<h2 id="引用嵌套类型">引用嵌套类型</h2><p>在外部引用嵌套类型时，在嵌套类型的类型名前加上其外部类型的类型名作为前缀：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> heartsSymbol = <span class="type">BlackjackCard</span>.<span class="type">Suit</span>.<span class="type">Hearts</span>.rawValue</span><br><span class="line"><span class="comment">// 红心符号为 “♡”</span></span><br></pre></td></tr></table></figure>
<p>对于上面这个例子，这样可以使<code>Suit</code>、<code>Rank</code>和<code>Values</code>的名字尽可能的短，因为它们的名字可以由定义它们的上下文来限定。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/21_Extensions/" itemprop="url">
                第二章-21扩展（Extensions）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:06+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/21_Extensions/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/21_Extensions/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="扩展（Extensions）">扩展（Extensions）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/lyuka" target="_blank" rel="external">lyuka</a><br>校对：<a href="https://github.com/Hawstein" target="_blank" rel="external">Hawstein</a></p>
<p>2.0<br>翻译+校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a></p>
<p>2.1<br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#extension_syntax">扩展语法</a></li>
<li><a href="#computed_properties">计算型属性</a></li>
<li><a href="#initializers">构造器</a></li>
<li><a href="#methods">方法</a></li>
<li><a href="#subscripts">下标</a></li>
<li><a href="#nested_types">嵌套类型</a></li>
</ul>
<p><em>扩展</em> 就是为一个已有的类、结构体、枚举类型或者协议类型添加新功能。这包括在没有权限获取原始源代码的情况下扩展类型的能力（即 <em>逆向建模</em> ）。扩展和 Objective-C 中的分类类似。（与 Objective-C 不同的是，Swift 的扩展没有名字。）</p>
<p>Swift 中的扩展可以：</p>
<ul>
<li>添加计算型属性和计算型类型属性</li>
<li>定义实例方法和类型方法</li>
<li>提供新的构造器</li>
<li>定义下标</li>
<li>定义和使用新的嵌套类型</li>
<li>使一个已有类型符合某个协议</li>
</ul>
<p>在 Swift 中，你甚至可以对协议进行扩展，提供协议要求的实现，或者添加额外的功能，从而可以让符合协议的类型拥有这些功能。你可以从<a href="./22_Protocols.html#protocol_extensions">协议扩展</a>获取更多的细节。</p>
<blockquote>
<p>注意<br>扩展可以为一个类型添加新的功能，但是不能重写已有的功能。</p>
</blockquote>
<p><a name="extension_syntax"></a></p>
<h2 id="扩展语法（Extension_Syntax）">扩展语法（Extension Syntax）</h2><p>使用关键字 <code>extension</code> 来声明扩展：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SomeType</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为 SomeType 添加的新功能写到这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过扩展来扩展一个已有类型，使其采纳一个或多个协议。在这种情况下，无论是类还是结构体，协议名字的书写方式完全一样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SomeType</span>: <span class="title">SomeProtocol</span>, <span class="title">AnotherProctocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 协议实现写到这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这种方式添加协议一致性的详细描述请参阅<a href="./22_Protocols.html#adding_protocol_conformance_with_an_extension">利用扩展添加协议一致性</a>。</p>
<blockquote>
<p>注意<br>如果你通过扩展为一个已有类型添加新功能，那么新功能对该类型的所有已有实例都是可用的，即使它们是在这个扩展定义之前创建的。</p>
</blockquote>
<p><a name="computed_properties"></a></p>
<h2 id="计算型属性（Computed_Properties）">计算型属性（Computed Properties）</h2><p>扩展可以为已有类型添加计算型实例属性和计算型类型属性。下面的例子为 Swift 的内建 <code>Double</code> 类型添加了五个计算型实例属性，从而提供与距离单位协作的基本支持：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Double</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> km: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> * <span class="number">1_000.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> m : <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> cm: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> / <span class="number">100.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> mm: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> / <span class="number">1_000.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> ft: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> / <span class="number">3.28084</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> oneInch = <span class="number">25.4</span>.mm</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"One inch is <span class="subst">\(oneInch)</span> meters"</span>)</span><br><span class="line"><span class="comment">// 打印 “One inch is 0.0254 meters”</span></span><br><span class="line"><span class="keyword">let</span> threeFeet = <span class="number">3</span>.ft</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Three feet is <span class="subst">\(threeFeet)</span> meters"</span>)</span><br><span class="line"><span class="comment">// 打印 “Three feet is 0.914399970739201 meters”</span></span><br></pre></td></tr></table></figure>
<p>这些计算型属性表达的含义是把一个 <code>Double</code> 值看作是某单位下的长度值。即使它们被实现为计算型属性，但这些属性的名字仍可紧接一个浮点型字面值，从而通过点语法来使用，并以此实现距离转换。</p>
<p>在上述例子中，<code>Double</code> 值 <code>1.0</code> 用来表示“1米”。这就是为什么计算型属性 <code>m</code> 返回 <code>self</code>，即表达式 <code>1.m</code> 被认为是计算 <code>Double</code> 值 <code>1.0</code>。</p>
<p>其它单位则需要一些单位换算。一千米等于 1,000 米，所以计算型属性 <code>km</code> 要把值乘以 <code>1_000.00</code> 来实现千米到米的单位换算。类似地，一米有 3.28024 英尺，所以计算型属性 <code>ft</code> 要把对应的 <code>Double</code> 值除以 <code>3.28024</code> 来实现英尺到米的单位换算。</p>
<p>这些属性是只读的计算型属性，为了更简洁，省略了 <code>get</code> 关键字。它们的返回值是 <code>Double</code>，而且可以用于所有接受 <code>Double</code> 值的数学计算中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aMarathon = <span class="number">42</span>.km + <span class="number">195</span>.m</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"A marathon is <span class="subst">\(aMarathon)</span> meters long"</span>)</span><br><span class="line"><span class="comment">// 打印 “A marathon is 42195.0 meters long”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>扩展可以添加新的计算型属性，但是不可以添加存储型属性，也不可以为已有属性添加属性观察器。</p>
</blockquote>
<p><a name="initializers"></a></p>
<h2 id="构造器（Initializers）">构造器（Initializers）</h2><p>扩展可以为已有类型添加新的构造器。这可以让你扩展其它类型，将你自己的定制类型作为其构造器参数，或者提供该类型的原始实现中未提供的额外初始化选项。  </p>
<p>扩展能为类添加新的便利构造器，但是它们不能为类添加新的指定构造器或析构器。指定构造器和析构器必须总是由原始的类实现来提供。</p>
<blockquote>
<p>注意<br>如果你使用扩展为一个值类型添加构造器，且该值类型的原始实现中未定义任何定制的构造器时，你可以在扩展中的构造器里调用逐一成员构造器。如果该值类型为所有存储型属性提供了默认值，你还可以在扩展中的构造器里调用默认构造器。<br>正如在<a href="./14_Initialization.html#initializer_delegation_for_value_types">值类型的构造器代理</a>中描述的，如果你把定制的构造器写在值类型的原始实现中，上述规则将不再适用。</p>
</blockquote>
<p>下面的例子定义了一个用于描述几何矩形的结构体 <code>Rect</code>。这个例子同时定义了两个辅助结构体 <code>Size</code> 和 <code>Point</code>，它们都把 <code>0.0</code> 作为所有属性的默认值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span>, height = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> origin = <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size = <span class="type">Size</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为结构体 <code>Rect</code> 未提供定制的构造器，因此它会获得一个逐一成员构造器。又因为它为所有存储型属性提供了默认值，它又会获得一个默认构造器。详情请参阅<a href="./14_Initialization.html#default_initializers">默认构造器</a>。这些构造器可以用于构造新的 <code>Rect</code> 实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> defaultRect = <span class="type">Rect</span>()</span><br><span class="line"><span class="keyword">let</span> memberwiseRect = <span class="type">Rect</span>(origin: <span class="type">Point</span>(x: <span class="number">2.0</span>, y: <span class="number">2.0</span>),</span><br><span class="line">    size: <span class="type">Size</span>(width: <span class="number">5.0</span>, height: <span class="number">5.0</span>))</span><br></pre></td></tr></table></figure>
<p>你可以提供一个额外的接受指定中心点和大小的构造器来扩展 <code>Rect</code> 结构体：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Rect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>(center: <span class="type">Point</span>, size: <span class="type">Size</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> originX = center.x - (size.width / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">let</span> originY = center.y - (size.height / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(origin: <span class="type">Point</span>(x: originX, y: originY), size: size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个新的构造器首先根据提供的 <code>center</code> 和 <code>size</code> 的值计算一个合适的原点。然后调用该结构体的逐一成员构造器 <code>init(origin:size:)</code>，该构造器将新的原点和大小的值保存到了相应的属性中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> centerRect = <span class="type">Rect</span>(center: <span class="type">Point</span>(x: <span class="number">4.0</span>, y: <span class="number">4.0</span>),</span><br><span class="line">    size: <span class="type">Size</span>(width: <span class="number">3.0</span>, height: <span class="number">3.0</span>))</span><br><span class="line"><span class="comment">// centerRect 的原点是 (2.5, 2.5)，大小是 (3.0, 3.0)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>如果你使用扩展提供了一个新的构造器，你依旧有责任确保构造过程能够让实例完全初始化。</p>
</blockquote>
<p><a name="methods"></a></p>
<h2 id="方法（Methods）">方法（Methods）</h2><p>扩展可以为已有类型添加新的实例方法和类型方法。下面的例子为 <code>Int</code> 类型添加了一个名为 <code>repetitions</code> 的实例方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">repetitions</span><span class="params">(task: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="keyword">self</span> &#123;</span><br><span class="line">            task()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 <code>repetitions(:_)</code> 方法接受一个 <code>() -&gt; Void</code> 类型的单参数，表示没有参数且没有返回值的函数。</p>
<p>定义该扩展之后，你就可以对任意整数调用 <code>repetitions(_:)</code> 方法，将闭包中的任务执行整数对应的次数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>.repetitions(&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello!"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// Hello!</span></span><br><span class="line"><span class="comment">// Hello!</span></span><br><span class="line"><span class="comment">// Hello!</span></span><br></pre></td></tr></table></figure>
<p>可以使用尾随闭包让调用更加简洁：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>.repetitions &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Goodbye!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Goodbye!</span></span><br><span class="line"><span class="comment">// Goodbye!</span></span><br><span class="line"><span class="comment">// Goodbye!</span></span><br></pre></td></tr></table></figure>
<p><a name="mutating_instance_methods"></a></p>
<h3 id="可变实例方法（Mutating_Instance_Methods）">可变实例方法（Mutating Instance Methods）</h3><p>通过扩展添加的实例方法也可以修改该实例本身。结构体和枚举类型中修改 <code>self</code> 或其属性的方法必须将该实例方法标注为 <code>mutating</code>，正如来自原始实现的可变方法一样。</p>
<p>下面的例子为 Swift 的 <code>Int</code> 类型添加了一个名为 <code>square</code> 的可变方法，用于计算原始值的平方值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">square</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span> = <span class="keyword">self</span> * <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> someInt = <span class="number">3</span></span><br><span class="line">someInt.square()</span><br><span class="line"><span class="comment">// someInt 的值现在是 9</span></span><br></pre></td></tr></table></figure>
<p><a name="subscripts"></a></p>
<h2 id="下标（Subscripts）">下标（Subscripts）</h2><p>扩展可以为已有类型添加新下标。这个例子为 Swift 内建类型 <code>Int</code> 添加了一个整型下标。该下标 <code>[n]</code> 返回十进制数字从右向左数的第 <code>n</code> 个数字：</p>
<ul>
<li><code>123456789[0]</code> 返回 <code>9</code></li>
<li><code>123456789[1]</code> 返回 <code>8</code></li>
</ul>
<p>……以此类推。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="keyword">var</span> digitIndex: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> decimalBase = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> digitIndex &gt; <span class="number">0</span> &#123;</span><br><span class="line">            decimalBase *= <span class="number">10</span></span><br><span class="line">            --digitIndex</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">self</span> / decimalBase) % <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">746381295</span>[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 返回 5</span></span><br><span class="line"><span class="number">746381295</span>[<span class="number">1</span>]</span><br><span class="line"><span class="comment">// 返回 9</span></span><br><span class="line"><span class="number">746381295</span>[<span class="number">2</span>]</span><br><span class="line"><span class="comment">// 返回 2</span></span><br><span class="line"><span class="number">746381295</span>[<span class="number">8</span>]</span><br><span class="line"><span class="comment">// 返回 7</span></span><br></pre></td></tr></table></figure>
<p>如果该 <code>Int</code> 值没有足够的位数，即下标越界，那么上述下标实现会返回 <code>0</code>，犹如在数字左边自动补 <code>0</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">746381295</span>[<span class="number">9</span>]</span><br><span class="line"><span class="comment">// 返回 0，即等同于：</span></span><br><span class="line"><span class="number">0746381295</span>[<span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<p><a name="nested_types"></a></p>
<h2 id="嵌套类型（Nested_Types）">嵌套类型（Nested Types）</h2><p>扩展可以为已有的类、结构体和枚举添加新的嵌套类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Kind</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Negative</span>, <span class="type">Zero</span>, <span class="type">Positive</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> kind: <span class="type">Kind</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> .<span class="type">Zero</span></span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> x <span class="keyword">where</span> x &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> .<span class="type">Positive</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> .<span class="type">Negative</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该例子为 <code>Int</code> 添加了嵌套枚举。这个名为 <code>Kind</code> 的枚举表示特定整数的类型。具体来说，就是表示整数是正数、零或者负数。</p>
<p>这个例子还为 <code>Int</code> 添加了一个计算型实例属性，即 <code>kind</code>，用来根据整数返回适当的 <code>Kind</code> 枚举成员。</p>
<p>现在，这个嵌套枚举可以和任意 <code>Int</code> 值一起使用了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">printIntegerKinds</span><span class="params">(numbers: [Int])</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        <span class="keyword">switch</span> number.kind &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Negative</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"- "</span>, terminator: <span class="string">""</span>)</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Zero</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"0 "</span>, terminator: <span class="string">""</span>)</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Positive</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"+ "</span>, terminator: <span class="string">""</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">""</span>)</span><br><span class="line">&#125;</span><br><span class="line">printIntegerKinds([<span class="number">3</span>, <span class="number">19</span>, -<span class="number">27</span>, <span class="number">0</span>, -<span class="number">6</span>, <span class="number">0</span>, <span class="number">7</span>])</span><br><span class="line"><span class="comment">// 打印 “+ + - 0 - 0 +”</span></span><br></pre></td></tr></table></figure>
<p>函数 <code>printIntegerKinds(_:)</code> 接受一个 <code>Int</code> 数组，然后对该数组进行迭代。在每次迭代过程中，对当前整数的计算型属性 <code>kind</code> 的值进行评估，并打印出适当的描述。</p>
<blockquote>
<p>注意<br>由于已知 <code>number.kind</code> 是 <code>Int.Kind</code> 类型，因此在 <code>switch</code> 语句中，<code>Int.Kind</code> 中的所有成员值都可以使用简写形式，例如使用 <code>. Negative</code> 而不是 <code>Int.Kind.Negative</code>。</p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/22_Protocols/" itemprop="url">
                第二章-22协议（Protocols）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:05+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/22_Protocols/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/22_Protocols/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="协议（Protocols）">协议（Protocols）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/geek5nan" target="_blank" rel="external">geek5nan</a><br>校对：<a href="https://github.com/dabing1022" target="_blank" rel="external">dabing1022</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/futantan" target="_blank" rel="external">futantan</a></p>
<p>2.1<br>翻译：<a href="https://github.com/kevin833752" target="_blank" rel="external">小铁匠Linus</a><br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a>，2015-11-01</p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#protocol_syntax">协议语法（Protocol Syntax）</a></li>
<li><a href="#property_requirements">属性要求（Property Requirements）</a></li>
<li><a href="#method_requirements">方法要求（Method Requirements）</a></li>
<li><a href="#mutating_method_requirements">Mutating 方法要求（Mutating Method Requirements）</a></li>
<li><a href="#initializer_requirements">构造器要求（Initializer Requirements）</a></li>
<li><a href="#protocols_as_types">协议作为类型（Protocols as Types）</a></li>
<li><a href="#delegation">委托（代理）模式（Delegation）</a></li>
<li><a href="#adding_protocol_conformance_with_an_extension">通过扩展添加协议一致性（Adding Protocol Conformance with an Extension）</a></li>
<li><a href="#declaring_protocol_adoption_with_an_extension">通过扩展采纳协议（Declaring Protocol Adoption with an Extension）</a></li>
<li><a href="#collections_of_protocol_types">协议类型的集合（Collections of Protocol Types）</a></li>
<li><a href="#protocol_inheritance">协议的继承（Protocol Inheritance）</a></li>
<li><a href="#class_only_protocol">类类型专属协议（Class-Only Protocol）</a></li>
<li><a href="#protocol_composition">协议合成（Protocol Composition）</a></li>
<li><a href="#checking_for_protocol_conformance">检查协议一致性（Checking for Protocol Conformance）</a></li>
<li><a href="#optional_protocol_requirements">可选的协议要求（Optional Protocol Requirements）</a></li>
<li><a href="#protocol_extensions">协议扩展（Protocol Extensions）</a></li>
</ul>
<p>协议定义了一个蓝图，规定了用来实现某一特定任务或者功能的方法、属性，以及其他需要的东西。类、结构体或枚举都可以采纳协议，并为协议定义的这些要求提供具体实现。某个类型能够满足某个协议的要求，就可以说该类型“符合”这个协议。</p>
<p>除了采纳协议的类型必须实现的要求外，还可以对协议进行扩展，通过扩展来实现一部分要求或者实现一些附加功能，这样采纳协议的类型就能够使用这些功能。</p>
<p><a name="protocol_syntax"></a></p>
<h2 id="协议语法">协议语法</h2><p>协议的定义方式与类、结构体和枚举的定义非常相似：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 这里是协议的定义部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要让自定义类型采纳某个协议，在定义类型时，需要在类型名称后加上协议名称，中间以冒号（<code>:</code>）分隔。采纳多个协议时，各协议之间用逗号（<code>,</code>）分隔：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeStructure</span>: <span class="title">FirstProtocol</span>, <span class="title">AnotherProtocol</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 这里是结构体的定义部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拥有父类的类在采纳协议时，应该将父类名放在协议名之前，以逗号分隔：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>: <span class="title">SomeSuperClass</span>, <span class="title">FirstProtocol</span>, <span class="title">AnotherProtocol</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 这里是类的定义部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="property_requirements"></a></p>
<h2 id="属性要求">属性要求</h2><p>协议可以要求采纳协议的类型提供特定名称和类型的实例属性或类型属性。协议不指定属性是存储型属性还是计算型属性，它只指定属性的名称和类型。此外，协议还指定属性是只读的还是可读可写的。</p>
<p>如果协议要求属性是可读可写的，那么该属性不能是常量属性或只读的计算型属性。如果协议只要求属性是只读的，那么该属性不仅可以是只读的，如果代码需要的话，还可以是可写的。</p>
<p>协议通常用 <code>var</code> 关键字来声明变量属性，在类型声明后加上 <code>{ set get }</code> 来表示属性是可读可写的，只读属性则用 <code>{ get }</code> 来表示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> mustBeSettable: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">	<span class="keyword">var</span> doesNotNeedToBeSettable: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在协议中定义类型属性时，总是使用 <code>static</code> 关键字作为前缀。当类类型采纳协议时，除了 <code>static</code> 关键字，还可以使用 <code>class</code> 关键字来声明类型属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">AnotherProtocol</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">var</span> someTypeProperty: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下所示，这是一个只含有一个实例属性要求的协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">FullyNamed</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> fullName: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>FullyNamed</code> 协议除了要求采纳协议的类型提供 <code>fullName</code> 属性外，并没有其他特别的要求。这个协议表示，任何采纳 <code>FullyNamed</code> 的类型，都必须有一个只读的 <code>String</code> 类型的实例属性 <code>fullName</code>。</p>
<p>下面是一个采纳 <code>FullyNamed</code> 协议的简单结构体：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>: <span class="title">FullyNamed</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> fullName: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> john = <span class="type">Person</span>(fullName: <span class="string">"John Appleseed"</span>)</span><br><span class="line"><span class="comment">// john.fullName 为 "John Appleseed"</span></span><br></pre></td></tr></table></figure>
<p>这个例子中定义了一个叫做 <code>Person</code> 的结构体，用来表示一个具有名字的人。从第一行代码可以看出，它采纳了 <code>FullyNamed</code> 协议。</p>
<p><code>Person</code> 结构体的每一个实例都有一个 <code>String</code> 类型的存储型属性 <code>fullName</code>。这正好满足了 <code>FullyNamed</code> 协议的要求，也就意味着 <code>Person</code> 结构体正确地符合了协议。（如果协议要求未被完全满足，在编译时会报错。）</p>
<p>下面是一个更为复杂的类，它采纳并符合了 <code>FullyNamed</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Starship</span>: <span class="title">FullyNamed</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">prefix</span>: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, <span class="keyword">prefix</span>: <span class="type">String</span>? = <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">prefix</span> = <span class="keyword">prefix</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> fullName: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">prefix</span> != <span class="literal">nil</span> ? <span class="keyword">prefix</span>! + <span class="string">" "</span> : <span class="string">""</span>) + name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ncc1701 = <span class="type">Starship</span>(name: <span class="string">"Enterprise"</span>, <span class="keyword">prefix</span>: <span class="string">"USS"</span>)</span><br><span class="line"><span class="comment">// ncc1701.fullName 是 "USS Enterprise"</span></span><br></pre></td></tr></table></figure>
<p><code>Starship</code> 类把 <code>fullName</code> 属性实现为只读的计算型属性。每一个 <code>Starship</code> 类的实例都有一个名为 <code>name</code> 的非可选属性和一个名为 <code>prefix</code> 的可选属性。 当 <code>prefix</code> 存在时，计算型属性 <code>fullName</code> 会将 <code>prefix</code> 插入到 <code>name</code> 之前，从而为星际飞船构建一个全名。</p>
<p><a name="method_requirements"></a></p>
<h2 id="方法要求">方法要求</h2><p>协议可以要求采纳协议的类型实现某些指定的实例方法或类方法。这些方法作为协议的一部分，像普通方法一样放在协议的定义中，但是不需要大括号和方法体。可以在协议中定义具有可变参数的方法，和普通方法的定义方式相同。但是，不支持为协议中的方法的参数提供默认值。</p>
<p>正如属性要求中所述，在协议中定义类方法的时候，总是使用 <code>static</code> 关键字作为前缀。当类类型采纳协议时，除了 <code>static</code> 关键字，还可以使用 <code>class</code> 关键字作为前缀：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">someTypeMethod</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的例子定义了一个只含有一个实例方法的协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">RandomNumberGenerator</span> </span>&#123;</span><br><span class="line">	<span class="func"><span class="keyword">func</span> <span class="title">random</span><span class="params">()</span></span> -&gt; <span class="type">Double</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RandomNumberGenerator</code> 协议要求采纳协议的类型必须拥有一个名为 <code>random</code>， 返回值类型为 <code>Double</code> 的实例方法。尽管这里并未指明，但是我们假设返回值在 <code>[0.0,1.0)</code> 区间内。</p>
<p><code>RandomNumberGenerator</code> 协议并不关心每一个随机数是怎样生成的，它只要求必须提供一个随机数生成器。</p>
<p>如下所示，下边是一个采纳了 <code>RandomNumberGenerator</code> 协议的类。该类实现了一个叫做 <em>线性同余生成器（linear congruential generator）</em> 的伪随机数算法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearCongruentialGenerator</span>: <span class="title">RandomNumberGenerator</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> lastRandom = <span class="number">42.0</span></span><br><span class="line">	<span class="keyword">let</span> m = <span class="number">139968.0</span></span><br><span class="line">	<span class="keyword">let</span> a = <span class="number">3877.0</span></span><br><span class="line">	<span class="keyword">let</span> <span class="built_in">c</span> = <span class="number">29573.0</span></span><br><span class="line">	<span class="func"><span class="keyword">func</span> <span class="title">random</span><span class="params">()</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">		lastRandom = ((lastRandom * a + <span class="built_in">c</span>) % m)</span><br><span class="line">		<span class="keyword">return</span> lastRandom / m</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generator = <span class="type">LinearCongruentialGenerator</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Here's a random number: <span class="subst">\(generator.random()</span>)"</span>)</span><br><span class="line"><span class="comment">// 打印 “Here's a random number: 0.37464991998171”</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"And another one: <span class="subst">\(generator.random()</span>)"</span>)</span><br><span class="line"><span class="comment">// 打印 “And another one: 0.729023776863283”</span></span><br></pre></td></tr></table></figure>
<p><a name="mutating_method_requirements"></a></p>
<h2 id="Mutating_方法要求">Mutating 方法要求</h2><p>有时需要在方法中改变方法所属的实例。例如，在值类型（即结构体和枚举）的实例方法中，将 <code>mutating</code> 关键字作为方法的前缀，写在 <code>func</code> 关键字之前，表示可以在该方法中修改它所属的实例以及实例的任意属性的值。这一过程在<a href="./11_Methods.html#modifying_value_types_from_within_instance_methods">在实例方法中修改值类型</a>章节中有详细描述。</p>
<p>如果你在协议中定义了一个实例方法，该方法会改变采纳该协议的类型的实例，那么在定义协议时需要在方法前加 <code>mutating</code> 关键字。这使得结构体和枚举能够采纳此协议并满足此方法要求。</p>
<blockquote>
<p>注意<br>实现协议中的 <code>mutating</code> 方法时，若是类类型，则不用写 <code>mutating</code> 关键字。而对于结构体和枚举，则必须写 <code>mutating</code> 关键字。</p>
</blockquote>
<p>如下所示，<code>Togglable</code> 协议只要求实现一个名为 <code>toggle</code> 的实例方法。根据名称的暗示，<code>toggle()</code> 方法将改变实例属性，从而切换采纳该协议类型的实例的状态。</p>
<p><code>toggle()</code> 方法在定义的时候，使用 <code>mutating</code> 关键字标记，这表明当它被调用时，该方法将会改变采纳协议的类型的实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Togglable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">toggle</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当使用枚举或结构体来实现 <code>Togglable</code> 协议时，需要提供一个带有 <code>mutating</code> 前缀的 <code>toggle()</code> 方法。</p>
<p>下面定义了一个名为 <code>OnOffSwitch</code> 的枚举。这个枚举在两种状态之间进行切换，用枚举成员 <code>On</code> 和 <code>Off</code> 表示。枚举的 <code>toggle()</code> 方法被标记为 <code>mutating</code>，以满足 <code>Togglable</code> 协议的要求：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">OnOffSwitch</span>: <span class="title">Togglable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Off</span>, <span class="type">On</span></span><br><span class="line">	<span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">toggle</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="type">Off</span>:</span><br><span class="line">			<span class="keyword">self</span> = <span class="type">On</span></span><br><span class="line">		<span class="keyword">case</span> <span class="type">On</span>:</span><br><span class="line">			<span class="keyword">self</span> = <span class="type">Off</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> lightSwitch = <span class="type">OnOffSwitch</span>.<span class="type">Off</span></span><br><span class="line">lightSwitch.toggle()</span><br><span class="line"><span class="comment">// lightSwitch 现在的值为 .On</span></span><br></pre></td></tr></table></figure>
<p><a name="initializer_requirements"></a></p>
<h2 id="构造器要求">构造器要求</h2><p>协议可以要求采纳协议的类型实现指定的构造器。你可以像编写普通构造器那样，在协议的定义里写下构造器的声明，但不需要写花括号和构造器的实体：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>(someParameter: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造器要求在类中的实现">构造器要求在类中的实现</h3><p>你可以在采纳协议的类中实现构造器，无论是作为指定构造器，还是作为便利构造器。无论哪种情况，你都必须为构造器实现标上 <code>required</code> 修饰符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>: <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line">    required <span class="keyword">init</span>(someParameter: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里是构造器的实现部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>required</code> 修饰符可以确保所有子类也必须提供此构造器实现，从而也能符合协议。</p>
<p>关于 <code>required</code> 构造器的更多内容，请参考<a href="./14_Initialization.html#required_initializers">必要构造器</a>。</p>
<blockquote>
<p>注意<br>如果类已经被标记为 <code>final</code>，那么不需要在协议构造器的实现中使用 <code>required</code> 修饰符，因为 <code>final</code> 类不能有子类。关于 <code>final</code> 修饰符的更多内容，请参见<a href="./13_Inheritance.html#preventing_overrides">防止重写</a>。</p>
</blockquote>
<p>如果一个子类重写了父类的指定构造器，并且该构造器满足了某个协议的要求，那么该构造器的实现需要同时标注 <code>required</code> 和 <code>override</code> 修饰符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeSuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 这里是构造器的实现部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeSubClass</span>: <span class="title">SomeSuperClass</span>, <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 因为采纳协议，需要加上 required</span></span><br><span class="line">    <span class="comment">// 因为继承自父类，需要加上 override</span></span><br><span class="line">    required <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 这里是构造器的实现部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可失败构造器要求">可失败构造器要求</h3><p>协议还可以为采纳协议的类型定义可失败构造器要求，详见<a href="./14_Initialization.html#failable_initializers">可失败构造器</a>。</p>
<p>采纳协议的类型可以通过可失败构造器（<code>init?</code>）或非可失败构造器（<code>init</code>）来满足协议中定义的可失败构造器要求。协议中定义的非可失败构造器要求可以通过非可失败构造器（<code>init</code>）或隐式解包可失败构造器（<code>init!</code>）来满足。</p>
<p><a name="protocols_as_types"></a></p>
<h2 id="协议作为类型">协议作为类型</h2><p>尽管协议本身并未实现任何功能，但是协议可以被当做一个成熟的类型来使用。</p>
<p>协议可以像其他普通类型一样使用，使用场景如下：</p>
<ul>
<li>作为函数、方法或构造器中的参数类型或返回值类型</li>
<li>作为常量、变量或属性的类型</li>
<li>作为数组、字典或其他容器中的元素类型</li>
</ul>
<blockquote>
<p>注意<br>协议是一种类型，因此协议类型的名称应与其他类型（例如 <code>Int</code>，<code>Double</code>，<code>String</code>）的写法相同，使用大写字母开头的驼峰式写法，例如（<code>FullyNamed</code> 和 <code>RandomNumberGenerator</code>）。</p>
</blockquote>
<p>下面是将协议作为类型使用的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dice</span> </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> sides: <span class="type">Int</span></span><br><span class="line">	<span class="keyword">let</span> generator: <span class="type">RandomNumberGenerator</span></span><br><span class="line">	<span class="keyword">init</span>(sides: <span class="type">Int</span>, generator: <span class="type">RandomNumberGenerator</span>) &#123;</span><br><span class="line">		<span class="keyword">self</span>.sides = sides</span><br><span class="line">		<span class="keyword">self</span>.generator = generator</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="func"><span class="keyword">func</span> <span class="title">roll</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="type">Int</span>(generator.random() * <span class="type">Double</span>(sides)) + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子中定义了一个 <code>Dice</code> 类，用来代表桌游中拥有 N 个面的骰子。<code>Dice</code> 的实例含有 <code>sides</code> 和 <code>generator</code> 两个属性，前者是整型，用来表示骰子有几个面，后者为骰子提供一个随机数生成器，从而生成随机点数。</p>
<p><code>generator</code> 属性的类型为 <code>RandomNumberGenerator</code>，因此任何采纳了 <code>RandomNumberGenerator</code> 协议的类型的实例都可以赋值给 <code>generator</code>，除此之外并无其他要求。</p>
<p><code>Dice</code> 类还有一个构造器，用来设置初始状态。构造器有一个名为 <code>generator</code>，类型为 <code>RandomNumberGenerator</code> 的形参。在调用构造方法创建 <code>Dice</code> 的实例时，可以传入任何采纳 <code>RandomNumberGenerator</code> 协议的实例给 <code>generator</code>。</p>
<p><code>Dice</code> 类提供了一个名为 <code>roll</code> 的实例方法，用来模拟骰子的面值。它先调用 <code>generator</code> 的 <code>random()</code> 方法来生成一个 <code>[0.0,1.0)</code> 区间内的随机数，然后使用这个随机数生成正确的骰子面值。因为 <code>generator</code> 采纳了 <code>RandomNumberGenerator</code> 协议，可以确保它有个 <code>random()</code> 方法可供调用。</p>
<p>下面的例子展示了如何使用 <code>LinearCongruentialGenerator</code> 的实例作为随机数生成器来创建一个六面骰子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d6 = <span class="type">Dice</span>(sides: <span class="number">6</span>, generator: <span class="type">LinearCongruentialGenerator</span>())</span><br><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>...<span class="number">5</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Random dice roll is <span class="subst">\(d6.roll()</span>)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Random dice roll is 3</span></span><br><span class="line"><span class="comment">// Random dice roll is 5</span></span><br><span class="line"><span class="comment">// Random dice roll is 4</span></span><br><span class="line"><span class="comment">// Random dice roll is 5</span></span><br><span class="line"><span class="comment">// Random dice roll is 4</span></span><br></pre></td></tr></table></figure>
<p><a name="delegation"></a></p>
<h2 id="委托（代理）模式">委托（代理）模式</h2><p>委托是一种设计模式，它允许类或结构体将一些需要它们负责的功能委托给其他类型的实例。委托模式的实现很简单：定义协议来封装那些需要被委托的功能，这样就能确保采纳协议的类型能提供这些功能。委托模式可以用来响应特定的动作，或者接收外部数据源提供的数据，而无需关心外部数据源的类型。</p>
<p>下面的例子定义了两个基于骰子游戏的协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">DiceGame</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> dice: <span class="type">Dice</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">	<span class="func"><span class="keyword">func</span> <span class="title">play</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">DiceGameDelegate</span> </span>&#123;</span><br><span class="line">	<span class="func"><span class="keyword">func</span> <span class="title">gameDidStart</span><span class="params">(game: DiceGame)</span></span></span><br><span class="line">	<span class="func"><span class="keyword">func</span> <span class="title">game</span><span class="params">(game: DiceGame, didStartNewTurnWithDiceRoll diceRoll:Int)</span></span></span><br><span class="line">	<span class="func"><span class="keyword">func</span> <span class="title">gameDidEnd</span><span class="params">(game: DiceGame)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DiceGame</code> 协议可以被任意涉及骰子的游戏采纳。<code>DiceGameDelegate</code> 协议可以被任意类型采纳，用来追踪 <code>DiceGame</code> 的游戏过程。</p>
<p>如下所示，<code>SnakesAndLadders</code> 是 <a href="./05_Control_Flow.html">Control Flow</a> 章节引入的蛇梯棋游戏的新版本。新版本使用 <code>Dice</code> 实例作为骰子，并且实现了 <code>DiceGame</code> 和 <code>DiceGameDelegate</code> 协议，后者用来记录游戏的过程：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnakesAndLadders</span>: <span class="title">DiceGame</span> </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> finalSquare = <span class="number">25</span></span><br><span class="line">	<span class="keyword">let</span> dice = <span class="type">Dice</span>(sides: <span class="number">6</span>, generator: <span class="type">LinearCongruentialGenerator</span>())</span><br><span class="line">	<span class="keyword">var</span> square = <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> board: [<span class="type">Int</span>]</span><br><span class="line">	<span class="keyword">init</span>() &#123;</span><br><span class="line">		board = [<span class="type">Int</span>](<span class="built_in">count</span>: finalSquare + <span class="number">1</span>, repeatedValue: <span class="number">0</span>)</span><br><span class="line">		board[<span class="number">03</span>] = +<span class="number">08</span>; board[<span class="number">06</span>] = +<span class="number">11</span>; board[<span class="number">09</span>] = +<span class="number">09</span>; board[<span class="number">10</span>] = +<span class="number">02</span></span><br><span class="line">		board[<span class="number">14</span>] = -<span class="number">10</span>; board[<span class="number">19</span>] = -<span class="number">11</span>; board[<span class="number">22</span>] = -<span class="number">02</span>; board[<span class="number">24</span>] = -<span class="number">08</span></span><br><span class="line">	&#125;</span><br><span class="line"> 	<span class="keyword">var</span> delegate: <span class="type">DiceGameDelegate</span>?</span><br><span class="line"> 	<span class="func"><span class="keyword">func</span> <span class="title">play</span><span class="params">()</span></span> &#123;</span><br><span class="line"> 		square = <span class="number">0</span></span><br><span class="line"> 		delegate?.gameDidStart(<span class="keyword">self</span>)</span><br><span class="line"> 		gameLoop: <span class="keyword">while</span> square != finalSquare &#123;</span><br><span class="line"> 			<span class="keyword">let</span> diceRoll = dice.roll()</span><br><span class="line"> 			delegate?.game(<span class="keyword">self</span>, didStartNewTurnWithDiceRoll: diceRoll)</span><br><span class="line"> 			<span class="keyword">switch</span> square + diceRoll &#123;</span><br><span class="line"> 			<span class="keyword">case</span> finalSquare:</span><br><span class="line"> 				<span class="keyword">break</span> gameLoop</span><br><span class="line"> 			<span class="keyword">case</span> <span class="keyword">let</span> newSquare <span class="keyword">where</span> newSquare &gt; finalSquare:</span><br><span class="line"> 				<span class="keyword">continue</span> gameLoop</span><br><span class="line"> 			<span class="keyword">default</span>:</span><br><span class="line"> 			    square += diceRoll</span><br><span class="line"> 			    square += board[square]</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		delegate?.gameDidEnd(<span class="keyword">self</span>)</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于这个蛇梯棋游戏的详细描述请参阅 <a href="./05_Control_Flow.html">Control Flow</a> 章节中的 <a href="./05_Control_Flow.html#break">Break</a> 部分。</p>
<p>这个版本的游戏封装到了 <code>SnakesAndLadders</code> 类中，该类采纳了 <code>DiceGame</code> 协议，并且提供了相应的只读的 <code>dice</code> 属性和 <code>play()</code> 方法。（ <code>dice</code> 属性在构造之后就不再改变，且协议只要求 <code>dice</code> 为只读的，因此将 <code>dice</code> 声明为常量属性。）</p>
<p>游戏使用 <code>SnakesAndLadders</code> 类的 <code>init()</code> 构造器来初始化游戏。所有的游戏逻辑被转移到了协议中的 <code>play()</code> 方法，<code>play()</code> 方法使用协议要求的 <code>dice</code> 属性提供骰子摇出的值。</p>
<p>注意，<code>delegate</code> 并不是游戏的必备条件，因此 <code>delegate</code> 被定义为 <code>DiceGameDelegate</code> 类型的可选属性。因为 <code>delegate</code> 是可选值，因此会被自动赋予初始值 <code>nil</code>。随后，可以在游戏中为 <code>delegate</code> 设置适当的值。</p>
<p><code>DicegameDelegate</code> 协议提供了三个方法用来追踪游戏过程。这三个方法被放置于游戏的逻辑中，即 <code>play()</code> 方法内。分别在游戏开始时，新一轮开始时，以及游戏结束时被调用。</p>
<p>因为 <code>delegate</code> 是一个 <code>DiceGameDelegate</code> 类型的可选属性，因此在 <code>play()</code> 方法中通过可选链式调用来调用它的方法。若 <code>delegate</code> 属性为 <code>nil</code>，则调用方法会优雅地失败，并不会产生错误。若 <code>delegate</code> 不为 <code>nil</code>，则方法能够被调用，并传递 <code>SnakesAndLadders</code> 实例作为参数。</p>
<p>如下示例定义了 <code>DiceGameTracker</code> 类，它采纳了 <code>DiceGameDelegate</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiceGameTracker</span>: <span class="title">DiceGameDelegate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfTurns = <span class="number">0</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">gameDidStart</span><span class="params">(game: DiceGame)</span></span> &#123;</span><br><span class="line">        numberOfTurns = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> game <span class="keyword">is</span> <span class="type">SnakesAndLadders</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Started a new game of Snakes and Ladders"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"The game is using a <span class="subst">\(game.dice.sides)</span>-sided dice"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">game</span><span class="params">(game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int)</span></span> &#123;</span><br><span class="line">        ++numberOfTurns</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Rolled a <span class="subst">\(diceRoll)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">gameDidEnd</span><span class="params">(game: DiceGame)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"The game lasted for <span class="subst">\(numberOfTurns)</span> turns"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DiceGameTracker</code> 实现了 <code>DiceGameDelegate</code> 协议要求的三个方法，用来记录游戏已经进行的轮数。当游戏开始时，<code>numberOfTurns</code> 属性被赋值为 <code>0</code>，然后在每新一轮中递增，游戏结束后，打印游戏的总轮数。</p>
<p><code>gameDidStart(_:)</code> 方法从 <code>game</code> 参数获取游戏信息并打印。<code>game</code> 参数是 <code>DiceGame</code> 类型而不是 <code>SnakeAndLadders</code> 类型，所以在方法中只能访问 <code>DiceGame</code> 协议中的内容。当然了，<code>SnakeAndLadders</code> 的方法也可以在类型转换之后调用。在上例代码中，通过 <code>is</code> 操作符检查 <code>game</code> 是否为 <code>SnakesAndLadders</code> 类型的实例，如果是，则打印出相应的消息。</p>
<p>无论当前进行的是何种游戏，由于 <code>game</code> 符合 <code>DiceGame</code> 协议，可以确保 <code>game</code> 含有 <code>dice</code> 属性。因此在 <code>gameDidStart(_:)</code> 方法中可以通过传入的 <code>game</code> 参数来访问 <code>dice</code> 属性，进而打印出 <code>dice</code> 的 <code>sides</code> 属性的值。</p>
<p><code>DiceGameTracker</code> 的运行情况如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tracker = <span class="type">DiceGameTracker</span>()</span><br><span class="line"><span class="keyword">let</span> game = <span class="type">SnakesAndLadders</span>()</span><br><span class="line">game.delegate = tracker</span><br><span class="line">game.play()</span><br><span class="line"><span class="comment">// Started a new game of Snakes and Ladders</span></span><br><span class="line"><span class="comment">// The game is using a 6-sided dice</span></span><br><span class="line"><span class="comment">// Rolled a 3</span></span><br><span class="line"><span class="comment">// Rolled a 5</span></span><br><span class="line"><span class="comment">// Rolled a 4</span></span><br><span class="line"><span class="comment">// Rolled a 5</span></span><br><span class="line"><span class="comment">// The game lasted for 4 turns</span></span><br></pre></td></tr></table></figure>
<p><a name="adding_protocol_conformance_with_an_extension"></a></p>
<h2 id="通过扩展添加协议一致性">通过扩展添加协议一致性</h2><p>即便无法修改源代码，依然可以通过扩展令已有类型采纳并符合协议。扩展可以为已有类型添加属性、方法、下标脚本以及构造器，因此可以符合协议中的相应要求。详情请在<a href="./21_Extensions.html">扩展</a>章节中查看。</p>
<blockquote>
<p>注意<br>通过扩展令已有类型采纳并符合协议时，该类型的所有实例也会随之获得协议中定义的各项功能。</p>
</blockquote>
<p>例如下面这个 <code>TextRepresentable</code> 协议，任何想要通过文本表示一些内容的类型都可以实现该协议。这些想要表示的内容可以是实例本身的描述，也可以是实例当前状态的文本描述：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TextRepresentable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textualDescription: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过扩展，令先前提到的 <code>Dice</code> 类采纳并符合 <code>TextRepresentable</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Dice</span>: <span class="title">TextRepresentable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textualDescription: <span class="type">String</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"A <span class="subst">\(sides)</span>-sided dice"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过扩展采纳并符合协议，和在原始定义中采纳并符合协议的效果完全相同。协议名称写在类型名之后，以冒号隔开，然后在扩展的大括号内实现协议要求的内容。</p>
<p>现在所有 <code>Dice</code> 的实例都可以看做 <code>TextRepresentable</code> 类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> d12 = <span class="type">Dice</span>(sides: <span class="number">12</span>,generator: <span class="type">LinearCongruentialGenerator</span>())</span><br><span class="line"><span class="built_in">print</span>(d12. textualDescription)</span><br><span class="line"><span class="comment">// 打印 “A 12-sided dice”</span></span><br></pre></td></tr></table></figure>
<p>同样，<code>SnakesAndLadders</code> 类也可以通过扩展采纳并符合 <code>TextRepresentable</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SnakesAndLadders</span>: <span class="title">TextRepresentable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textualDescription: <span class="type">String</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"A game of Snakes and Ladders with <span class="subst">\(finalSquare)</span> squares"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(game.textualDescription)</span><br><span class="line"><span class="comment">// 打印 “A game of Snakes and Ladders with 25 squares”</span></span><br></pre></td></tr></table></figure>
<p><a name="declaring_protocol_adoption_with_an_extension"></a></p>
<h2 id="通过扩展采纳协议">通过扩展采纳协议</h2><p>当一个类型已经符合了某个协议中的所有要求，却还没有声明采纳该协议时，可以通过空扩展体的扩展来采纳该协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hamster</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">   	<span class="keyword">var</span> textualDescription: <span class="type">String</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"A hamster named <span class="subst">\(name)</span>"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Hamster</span>: <span class="title">TextRepresentable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>从现在起，<code>Hamster</code> 的实例可以作为 <code>TextRepresentable</code> 类型使用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> simonTheHamster = <span class="type">Hamster</span>(name: <span class="string">"Simon"</span>)</span><br><span class="line"><span class="keyword">let</span> somethingTextRepresentable: <span class="type">TextRepresentable</span> = simonTheHamster</span><br><span class="line"><span class="built_in">print</span>(somethingTextRepresentable.textualDescription)</span><br><span class="line"><span class="comment">// 打印 “A hamster named Simon”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>即使满足了协议的所有要求，类型也不会自动采纳协议，必须显式地采纳协议。</p>
</blockquote>
<p><a name="collections_of_protocol_types"></a></p>
<h2 id="协议类型的集合">协议类型的集合</h2><p>协议类型可以在数组或者字典这样的集合中使用，在<a href="./22_Protocols.html##protocols_as_types">协议类型</a>提到了这样的用法。下面的例子创建了一个元素类型为 <code>TextRepresentable</code> 的数组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> things: [<span class="type">TextRepresentable</span>] = [game, d12, simonTheHamster]</span><br></pre></td></tr></table></figure>
<p>如下所示，可以遍历 <code>things</code> 数组，并打印每个元素的文本表示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> thing <span class="keyword">in</span> things &#123;</span><br><span class="line">	<span class="built_in">print</span>(thing.textualDescription)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A game of Snakes and Ladders with 25 squares</span></span><br><span class="line"><span class="comment">// A 12-sided dice</span></span><br><span class="line"><span class="comment">// A hamster named Simon</span></span><br></pre></td></tr></table></figure>
<p><code>thing</code> 是 <code>TextRepresentable</code> 类型而不是 <code>Dice</code>，<code>DiceGame</code>，<code>Hamster</code> 等类型，即使实例在幕后确实是这些类型中的一种。由于 <code>thing</code> 是 <code>TextRepresentable</code> 类型，任何 <code>TextRepresentable</code> 的实例都有一个 <code>textualDescription</code> 属性，所以在每次循环中可以安全地访问 <code>thing.textualDescription</code>。</p>
<p><a name="protocol_inheritance"></a></p>
<h2 id="协议的继承">协议的继承</h2><p>协议能够继承一个或多个其他协议，可以在继承的协议的基础上增加新的要求。协议的继承语法与类的继承相似，多个被继承的协议间用逗号分隔：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">InheritingProtocol</span>: <span class="title">SomeProtocol</span>, <span class="title">AnotherProtocol</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 这里是协议的定义部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下所示，<code>PrettyTextRepresentable</code> 协议继承了 <code>TextRepresentable</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">PrettyTextRepresentable</span>: <span class="title">TextRepresentable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> prettyTextualDescription: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子中定义了一个新的协议 <code>PrettyTextRepresentable</code>，它继承自 <code>TextRepresentable</code> 协议。任何采纳 <code>PrettyTextRepresentable</code> 协议的类型在满足该协议的要求时，也必须满足 <code>TextRepresentable</code> 协议的要求。在这个例子中，<code>PrettyTextRepresentable</code> 协议额外要求采纳协议的类型提供一个返回值为 <code>String</code> 类型的 <code>prettyTextualDescription</code> 属性。</p>
<p>如下所示，扩展 <code>SnakesAndLadders</code>，使其采纳并符合 <code>PrettyTextRepresentable</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SnakesAndLadders</span>: <span class="title">PrettyTextRepresentable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prettyTextualDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> output = textualDescription + <span class="string">":\n"</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span>...finalSquare &#123;</span><br><span class="line">            <span class="keyword">switch</span> board[index] &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">let</span> ladder <span class="keyword">where</span> ladder &gt; <span class="number">0</span>:</span><br><span class="line">                output += <span class="string">"▲ "</span></span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">let</span> snake <span class="keyword">where</span> snake &lt; <span class="number">0</span>:</span><br><span class="line">                output += <span class="string">"▼ "</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                output += <span class="string">"○ "</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述扩展令 <code>SnakesAndLadders</code> 采纳了 <code>PrettyTextRepresentable</code> 协议，并提供了协议要求的 <code>prettyTextualDescription</code> 属性。每个 <code>PrettyTextRepresentable</code> 类型同时也是 <code>TextRepresentable</code> 类型，所以在 <code>prettyTextualDescription</code> 的实现中，可以访问 <code>textualDescription</code> 属性。然后，拼接上了冒号和换行符。接着，遍历数组中的元素，拼接一个几何图形来表示每个棋盘方格的内容：</p>
<ul>
<li>当从数组中取出的元素的值大于 <code>0</code> 时，用 <code>▲</code> 表示。</li>
<li>当从数组中取出的元素的值小于 <code>0</code> 时，用 <code>▼</code> 表示。</li>
<li>当从数组中取出的元素的值等于 <code>0</code> 时，用 <code>○</code> 表示。</li>
</ul>
<p>任意 <code>SankesAndLadders</code> 的实例都可以使用 <code>prettyTextualDescription</code> 属性来打印一个漂亮的文本描述：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(game.prettyTextualDescription)</span><br><span class="line"><span class="comment">// A game of Snakes and Ladders with 25 squares:</span></span><br><span class="line"><span class="comment">// ○ ○ ▲ ○ ○ ▲ ○ ○ ▲ ▲ ○ ○ ○ ▼ ○ ○ ○ ○ ▼ ○ ○ ▼ ○ ▼ ○</span></span><br></pre></td></tr></table></figure>
<p><a name="class_only_protocol"></a></p>
<h2 id="类类型专属协议">类类型专属协议</h2><p>你可以在协议的继承列表中，通过添加 <code>class</code> 关键字来限制协议只能被类类型采纳，而结构体或枚举不能采纳该协议。<code>class</code> 关键字必须第一个出现在协议的继承列表中，在其他继承的协议之前：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeClassOnlyProtocol</span>: <span class="title">class</span>, <span class="title">SomeInheritedProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里是类类型专属协议的定义部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以上例子中，协议 <code>SomeClassOnlyProtocol</code> 只能被类类型采纳。如果尝试让结构体或枚举类型采纳该协议，则会导致编译错误。</p>
<blockquote>
<p>注意<br>当协议定义的要求需要采纳协议的类型必须是引用语义而非值语义时，应该采用类类型专属协议。关于引用语义和值语义的更多内容，请查看<a href="./09_Classes_and_Structures.html#structures_and_enumerations_are_value_types">结构体和枚举是值类型</a>和<a href="./09_Classes_and_Structures.html#classes_are_reference_types">类是引用类型</a>。</p>
</blockquote>
<p><a name="protocol_composition"></a></p>
<h2 id="协议合成">协议合成</h2><p>有时候需要同时采纳多个协议，你可以将多个协议采用 <code>protocol&lt;SomeProtocol, AnotherProtocol&gt;</code> 这样的格式进行组合，称为 <em>协议合成（protocol composition）</em>。你可以在 <code>&lt;&gt;</code> 中罗列任意多个你想要采纳的协议，以逗号分隔。</p>
<p>下面的例子中，将 <code>Named</code> 和 <code>Aged</code> 两个协议按照上述语法组合成一个协议，作为函数参数的类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Named</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Aged</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>: <span class="title">Named</span>, <span class="title">Aged</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">wishHappyBirthday</span><span class="params">(celebrator: <span class="keyword">protocol</span>&lt;Named, Aged&gt;)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Happy birthday <span class="subst">\(celebrator.name)</span> - you're <span class="subst">\(celebrator.age)</span>!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> birthdayPerson = <span class="type">Person</span>(name: <span class="string">"Malcolm"</span>, age: <span class="number">21</span>)</span><br><span class="line">wishHappyBirthday(birthdayPerson)</span><br><span class="line"><span class="comment">// 打印 “Happy birthday Malcolm - you're 21!”</span></span><br></pre></td></tr></table></figure>
<p><code>Named</code> 协议包含 <code>String</code> 类型的 <code>name</code> 属性。<code>Aged</code> 协议包含 <code>Int</code> 类型的 <code>age</code> 属性。<code>Person</code> 结构体采纳了这两个协议。</p>
<p><code>wishHappyBirthday(_:)</code> 函数的参数 <code>celebrator</code> 的类型为 <code>protocol&lt;Named，Aged&gt;</code>。这意味着它不关心参数的具体类型，只要参数符合这两个协议即可。</p>
<p>上面的例子创建了一个名为 <code>birthdayPerson</code> 的 <code>Person</code> 的实例，作为参数传递给了 <code>wishHappyBirthday(_:)</code> 函数。因为 <code>Person</code> 同时符合这两个协议，所以这个参数合法，函数将打印生日问候语。</p>
<blockquote>
<p>注意<br>协议合成并不会生成新的、永久的协议类型，而是将多个协议中的要求合成到一个只在局部作用域有效的临时协议中。</p>
</blockquote>
<p><a name="checking_for_protocol_conformance"></a></p>
<h2 id="检查协议一致性">检查协议一致性</h2><p>你可以使用<a href="./20_Type_Casting.html">类型转换</a>中描述的 <code>is</code> 和 <code>as</code> 操作符来检查协议一致性，即是否符合某协议，并且可以转换到指定的协议类型。检查和转换到某个协议类型在语法上和类型的检查和转换完全相同：</p>
<ul>
<li><code>is</code> 用来检查实例是否符合某个协议，若符合则返回 <code>true</code>，否则返回 <code>false</code>。</li>
<li><code>as?</code> 返回一个可选值，当实例符合某个协议时，返回类型为协议类型的可选值，否则返回 <code>nil</code>。</li>
<li><code>as!</code> 将实例强制向下转换到某个协议类型，如果强转失败，会引发运行时错误。</li>
</ul>
<p>下面的例子定义了一个 <code>HasArea</code> 协议，该协议定义了一个 <code>Double</code> 类型的只读属性 <code>area</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">HasArea</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">Double</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下所示，<code>Circle</code> 类和 <code>Country</code> 类都采纳了 <code>HasArea</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>: <span class="title">HasArea</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pi = <span class="number">3.1415927</span></span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">Double</span> &#123; <span class="keyword">return</span> pi * radius * radius &#125;</span><br><span class="line">    <span class="keyword">init</span>(radius: <span class="type">Double</span>) &#123; <span class="keyword">self</span>.radius = radius &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Country</span>: <span class="title">HasArea</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">init</span>(area: <span class="type">Double</span>) &#123; <span class="keyword">self</span>.area = area &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Circle</code> 类把 <code>area</code> 属性实现为基于存储型属性 <code>radius</code> 的计算型属性。<code>Country</code> 类则把 <code>area</code> 属性实现为存储型属性。这两个类都正确地符合了 <code>HasArea</code> 协议。</p>
<p>如下所示，<code>Animal</code> 是一个未采纳 <code>HasArea</code> 协议的类：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> legs: <span class="type">Int</span></span><br><span class="line">	<span class="keyword">init</span>(legs: <span class="type">Int</span>) &#123; <span class="keyword">self</span>.legs = legs &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Circle</code>，<code>Country</code>，<code>Animal</code> 并没有一个共同的基类，尽管如此，它们都是类，它们的实例都可以作为 <code>AnyObject</code> 类型的值，存储在同一个数组中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> objects: [<span class="type">AnyObject</span>] = [</span><br><span class="line">	<span class="type">Circle</span>(radius: <span class="number">2.0</span>),</span><br><span class="line">	<span class="type">Country</span>(area: <span class="number">243_610</span>),</span><br><span class="line">	<span class="type">Animal</span>(legs: <span class="number">4</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><code>objects</code> 数组使用字面量初始化，数组包含一个 <code>radius</code> 为 <code>2</code> 的 <code>Circle</code> 的实例，一个保存了英国国土面积的 <code>Country</code> 实例和一个 <code>legs</code> 为 <code>4</code> 的 <code>Animal</code> 实例。</p>
<p>如下所示，<code>objects</code> 数组可以被迭代，并对迭代出的每一个元素进行检查，看它是否符合 <code>HasArea</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> object <span class="keyword">in</span> objects &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> objectWithArea = object <span class="keyword">as</span>? <span class="type">HasArea</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Area is <span class="subst">\(objectWithArea.area)</span>"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Something that doesn't have an area"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Area is 12.5663708</span></span><br><span class="line"><span class="comment">// Area is 243610.0</span></span><br><span class="line"><span class="comment">// Something that doesn't have an area</span></span><br></pre></td></tr></table></figure>
<p>当迭代出的元素符合 <code>HasArea</code> 协议时，将 <code>as?</code> 操作符返回的可选值通过可选绑定，绑定到 <code>objectWithArea</code> 常量上。<code>objectWithArea</code> 是 <code>HasArea</code> 协议类型的实例，因此 <code>area</code> 属性可以被访问和打印。</p>
<p><code>objects</code> 数组中的元素的类型并不会因为强转而丢失类型信息，它们仍然是 <code>Circle</code>，<code>Country</code>，<code>Animal</code> 类型。然而，当它们被赋值给 <code>objectWithArea</code> 常量时，只被视为 <code>HasArea</code> 类型，因此只有 <code>area</code> 属性能够被访问。</p>
<p><a name="optional_protocol_requirements"></a></p>
<h2 id="可选的协议要求">可选的协议要求</h2><p>协议可以定义可选要求，采纳协议的类型可以选择是否实现这些要求。在协议中使用 <code>optional</code> 关键字作为前缀来定义可选要求。使用可选要求时（例如，可选的方法或者属性），它们的类型会自动变成可选的。比如，一个类型为 <code>(Int) -&gt; String</code> 的方法会变成 <code>((Int) -&gt; String)?</code>。需要注意的是整个函数类型是可选的，而不是函数的返回值。</p>
<p>协议中的可选要求可通过可选链式调用来使用，因为采纳协议的类型可能没有实现这些可选要求。类似 <code>someOptionalMethod?(someArgument)</code> 这样，你可以在可选方法名称后加上 <code>?</code> 来调用可选方法。详细内容可在<a href="./17_Optional_Chaining.html">可选链式调用</a>章节中查看。</p>
<blockquote>
<p>注意<br>可选的协议要求只能用在标记 <code>@objc</code> 特性的协议中。<br>该特性表示协议将暴露给 Objective-C 代码，详情参见<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216" target="_blank" rel="external"><code>Using Swift with Cocoa and Objective-C(Swift 2.1)</code></a>。即使你不打算和 Objective-C 有什么交互，如果你想要指定可选的协议要求，那么还是要为协议加上 <code>@obj</code> 特性。<br>还需要注意的是，标记 <code>@objc</code> 特性的协议只能被继承自 Objective-C 类的类或者 <code>@objc</code> 类采纳，其他类以及结构体和枚举均不能采纳这种协议。</p>
</blockquote>
<p>下面的例子定义了一个名为 <code>Counter</code> 的用于整数计数的类，它使用外部的数据源来提供每次的增量。数据源由 <code>CounterDataSource</code> 协议定义，包含两个可选要求：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">CounterDataSource</span> </span>&#123;</span><br><span class="line">    optional <span class="func"><span class="keyword">func</span> <span class="title">incrementForCount</span><span class="params">(<span class="built_in">count</span>: Int)</span></span> -&gt; <span class="type">Int</span></span><br><span class="line">    optional <span class="keyword">var</span> fixedIncrement: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CounterDataSource</code> 协议定义了一个可选方法 <code>incrementForCount(_:)</code> 和一个可选属性 <code>fiexdIncrement</code>，它们使用了不同的方法来从数据源中获取适当的增量值。</p>
<blockquote>
<p>注意<br>严格来讲，<code>CounterDataSource</code> 协议中的方法和属性都是可选的，因此采纳协议的类可以不实现这些要求，尽管技术上允许这样做，不过最好不要这样写。</p>
</blockquote>
<p><code>Counter</code> 类含有 <code>CounterDataSource?</code> 类型的可选属性 <code>dataSource</code>，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> dataSource: <span class="type">CounterDataSource</span>?</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">increment</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> amount = dataSource?.incrementForCount?(<span class="built_in">count</span>) &#123;</span><br><span class="line">            <span class="built_in">count</span> += amount</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> amount = dataSource?.fixedIncrement &#123;</span><br><span class="line">            <span class="built_in">count</span> += amount</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Counter</code> 类使用变量属性 <code>count</code> 来存储当前值。该类还定义了一个 <code>increment()</code> 方法，每次调用该方法的时候，将会增加 <code>count</code> 的值。</p>
<p><code>increment()</code> 方法首先试图使用 <code>incrementForCount(_:)</code> 方法来得到每次的增量。<code>increment()</code> 方法使用可选链式调用来尝试调用 <code>incrementForCount(_:)</code>，并将当前的 <code>count</code> 值作为参数传入。</p>
<p>这里使用了两层可选链式调用。首先，由于 <code>dataSource</code> 可能为 <code>nil</code>，因此在 <code>dataSource</code> 后边加上了 <code>?</code>，以此表明只在 <code>dataSource</code> 非空时才去调用 <code>incrementForCount(_:)</code> 方法。其次，即使 <code>dataSource</code> 存在，也无法保证其是否实现了 <code>incrementForCount(_:)</code> 方法，因为这个方法是可选的。因此，<code>incrementForCount(_:)</code> 方法同样使用可选链式调用进行调用，只有在该方法被实现的情况下才能调用它，所以在 <code>incrementForCount(_:)</code> 方法后边也加上了 <code>?</code>。</p>
<p>调用 <code>incrementForCount(_:)</code> 方法在上述两种情形下都有可能失败，所以返回值为 <code>Int?</code> 类型。虽然在 <code>CounterDataSource</code> 协议中，<code>incrementForCount(_:)</code> 的返回值类型是非可选 <code>Int</code>。另外，即使这里使用了两层可选链式调用，最后的返回结果依旧是单层的可选类型，即 <code>Int?</code> 而不是 <code>Int??</code>。关于这一点的更多信息，请查阅<a href="./17_Optional_Chaining">连接多层可选链式调用</a></p>
<p>在调用 <code>incrementForCount(_:)</code> 方法后，<code>Int?</code> 型的返回值通过可选绑定解包并赋值给常量 <code>amount</code>。如果可选值确实包含一个数值，也就是说，数据源和方法都存在，数据源方法返回了一个有效值。之后便将解包后的 <code>amount</code> 加到 <code>count</code> 上，增量操作完成。</p>
<p>如果没有从 <code>incrementForCount(_:)</code> 方法获取到值，可能由于 <code>dataSource</code> 为 <code>nil</code>，或者它并没有实现 <code>incrementForCount(_:)</code> 方法，那么 <code>increment()</code> 方法将试图从数据源的 <code>fixedIncrement</code> 属性中获取增量。<code>fixedIncrement</code> 是一个可选属性，因此属性值是一个 <code>Int?</code> 值，即使该属性在 <code>CounterDataSource</code> 协议中的类型是非可选的 <code>Int</code>。</p>
<p>下面的例子展示了 <code>CounterDataSource</code> 的简单实现。<code>ThreeSource</code> 类采纳了 <code>CounterDataSource</code> 协议，它实现了可选属性 <code>fixedIncrement</code>，每次会返回 <code>3</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreeSource</span>: <span class="title">NSObject</span>, <span class="title">CounterDataSource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fixedIncrement = <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用 <code>ThreeSource</code> 的实例作为 <code>Counter</code> 实例的数据源：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="type">Counter</span>()</span><br><span class="line">counter.dataSource = <span class="type">ThreeSource</span>()</span><br><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>...<span class="number">4</span> &#123;</span><br><span class="line">    counter.increment()</span><br><span class="line">    <span class="built_in">print</span>(counter.<span class="built_in">count</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 12</span></span><br></pre></td></tr></table></figure>
<p>上述代码新建了一个 <code>Counter</code> 实例，并将它的数据源设置为一个 <code>TreeSource</code> 的实例，然后调用 <code>increment()</code> 方法四次。和预期一样，每次调用都会将 <code>count</code> 的值增加 <code>3</code>.</p>
<p>下面是一个更为复杂的数据源 <code>TowardsZeroSource</code>，它将使得最后的值变为 <code>0</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">@objc</span> <span class="class"><span class="keyword">class</span> <span class="title">TowardsZeroSource</span>: <span class="title">NSObject</span>, <span class="title">CounterDataSource</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">incrementForCount</span><span class="params">(<span class="built_in">count</span>: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">count</span> == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">count</span> &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TowardsZeroSource</code> 实现了 <code>CounterDataSource</code> 协议中的 <code>incrementForCount(_:)</code> 方法，以 <code>count</code> 参数为依据，计算出每次的增量。如果 <code>count</code> 已经为 <code>0</code>，此方法返回 <code>0</code>，以此表明之后不应再有增量操作发生。</p>
<p>你可以使用 <code>TowardsZeroSource</code> 实例将 <code>Counter</code> 实例来从 <code>-4</code> 增加到 <code>0</code>。一旦增加到 <code>0</code>，数值便不会再有变动：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">counter.<span class="built_in">count</span> = -<span class="number">4</span></span><br><span class="line">counter.dataSource = <span class="type">TowardsZeroSource</span>()</span><br><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>...<span class="number">5</span> &#123;</span><br><span class="line">    counter.increment()</span><br><span class="line">    <span class="built_in">print</span>(counter.<span class="built_in">count</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -3</span></span><br><span class="line"><span class="comment">// -2</span></span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p><a name="protocol_extensions"></a></p>
<h2 id="协议扩展">协议扩展</h2><p>协议可以通过扩展来为采纳协议的类型提供属性、方法以及下标脚本的实现。通过这种方式，你可以基于协议本身来实现这些功能，而无需在每个采纳协议的类型中都重复同样的实现，也无需使用全局函数。</p>
<p>例如，可以扩展 <code>RandomNumberGenerator</code> 协议来提供 <code>randomBool()</code> 方法。该方法使用协议中定义的 <code>random()</code> 方法来返回一个随机的 <code>Bool</code> 值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">RandomNumberGenerator</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">randomBool</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> random() &gt; <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过协议扩展，所有采纳协议的类型，都能自动获得这个扩展所增加的方法实现，无需任何额外修改：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> generator = <span class="type">LinearCongruentialGenerator</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Here's a random number: <span class="subst">\(generator.random()</span>)"</span>)</span><br><span class="line"><span class="comment">// 打印 “Here's a random number: 0.37464991998171”</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"And here's a random Boolean: <span class="subst">\(generator.randomBool()</span>)"</span>)</span><br><span class="line"><span class="comment">// 打印 “And here's a random Boolean: true”</span></span><br></pre></td></tr></table></figure>
<p><a name="providing_default_implementations"></a></p>
<h3 id="提供默认实现">提供默认实现</h3><p>可以通过协议扩展来为协议要求的属性、方法以及下标脚本提供默认的实现。如果采纳协议的类型为这些要求提供了自己的实现，那么这些自定义实现将会替代扩展中的默认实现被使用。</p>
<blockquote>
<p>注意<br>通过协议扩展为协议要求提供的默认实现和可选的协议要求不同。虽然在这两种情况下，采纳协议的类型都无需自己实现这些要求，但是通过扩展提供的默认实现可以直接调用，而无需使用可选链式调用。</p>
</blockquote>
<p>例如，<code>PrettyTextRepresentable</code> 协议继承自 <code>TextRepresentable</code> 协议，可以为其提供一个默认的 <code>prettyTextualDescription</code> 属性，只是简单地返回 <code>textualDescription</code> 属性的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PrettyTextRepresentable</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prettyTextualDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> textualDescription</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="adding_constraints_to_protocol_extensions"></a></p>
<h3 id="为协议扩展添加限制条件">为协议扩展添加限制条件</h3><p>在扩展协议的时候，可以指定一些限制条件，只有采纳协议的类型满足这些限制条件时，才能获得协议扩展提供的默认实现。这些限制条件写在协议名之后，使用 <code>where</code> 子句来描述，正如<a href="./23_Generics.html#where_clauses">Where子句</a>)中所描述的。</p>
<p>例如，你可以扩展 <code>CollectionType</code> 协议，但是只适用于集合中的元素采纳了 <code>TextRepresentable</code> 协议的情况：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CollectionType</span> <span class="title">where</span> <span class="title">Generator</span>.<span class="title">Element</span>: <span class="title">TextRepresentable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textualDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> itemsAsText = <span class="keyword">self</span>.<span class="built_in">map</span> &#123; $<span class="number">0</span>.textualDescription &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"["</span> + itemsAsText.joinWithSeparator(<span class="string">", "</span>) + <span class="string">"]"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>textualDescription</code> 属性返回整个集合的文本描述，它将集合中的每个元素的文本描述以逗号分隔的方式连接起来，包在一对方括号中。</p>
<p>现在我们来看看先前的 <code>Hamster</code> 结构体，它符合 <code>TextRepresentable</code> 协议，同时这里还有个装有 <code>Hamster</code> 的实例的数组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> murrayTheHamster = <span class="type">Hamster</span>(name: <span class="string">"Murray"</span>)</span><br><span class="line"><span class="keyword">let</span> morganTheHamster = <span class="type">Hamster</span>(name: <span class="string">"Morgan"</span>)</span><br><span class="line"><span class="keyword">let</span> mauriceTheHamster = <span class="type">Hamster</span>(name: <span class="string">"Maurice"</span>)</span><br><span class="line"><span class="keyword">let</span> hamsters = [murrayTheHamster, morganTheHamster, mauriceTheHamster]</span><br></pre></td></tr></table></figure>
<p>因为 <code>Array</code> 符合 <code>CollectionType</code> 协议，而数组中的元素又符合 <code>TextRepresentable</code> 协议，所以数组可以使用 <code>textualDescription</code> 属性得到数组内容的文本表示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(hamsters.textualDescription)</span><br><span class="line"><span class="comment">// 打印 “[A hamster named Murray, A hamster named Morgan, A hamster named Maurice]”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>如果多个协议扩展都为同一个协议要求提供了默认实现，而采纳协议的类型又同时满足这些协议扩展的限制条件，那么将会使用限制条件最多的那个协议扩展提供的默认实现。</p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/23_Generics/" itemprop="url">
                第二章-23泛型（Generics）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:04+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/23_Generics/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/23_Generics/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="泛型（Generics）">泛型（Generics）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/takalard" target="_blank" rel="external">takalard</a><br>校对：<a href="https://github.com/lifedim" target="_blank" rel="external">lifedim</a></p>
<p>2.0<br>翻译+校对： <a href="https://github.com/SergioChan" target="_blank" rel="external">SergioChan</a></p>
<p>2.1<br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a>，2015-11-01</p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#the_problem_that_generics_solve">泛型所解决的问题</a></li>
<li><a href="#generic_functions">泛型函数</a></li>
<li><a href="#type_parameters">类型参数</a></li>
<li><a href="#naming_type_parameters">命名类型参数</a></li>
<li><a href="#generic_types">泛型类型</a></li>
<li><a href="#extending_a_generic_type">扩展一个泛型类型</a></li>
<li><a href="#type_constraints">类型约束</a></li>
<li><a href="#associated_types">关联类型</a></li>
<li><a href="#where_clauses">Where 子句</a></li>
</ul>
<p>泛型代码可以让你编写适用自定义需求以及任意类型的灵活可重用的函数和类型。它的可以让你避免重复的代码，用一种清晰和抽象的方式来表达代码的意图。</p>
<p>泛型是 Swift 的强大特性之一，许多 Swift 标准库是通过泛型代码构建的。事实上，泛型的使用贯穿了整本语言手册，只是你可能没有发现而已。例如，Swift 的 <code>Array</code> 和 <code>Dictionary</code> 都是泛型集合。你可以创建一个 <code>Int</code> 数组，也可创建一个 <code>String</code> 数组，甚至可以是任意其他 Swift 类型的数组。同样的，你也可以创建存储任意指定类型的字典。</p>
<p><a name="the_problem_that_generics_solve"></a></p>
<h2 id="泛型所解决的问题">泛型所解决的问题</h2><p>下面是一个标准的非泛型函数 <code>swapTwoInts(_:_:)</code>，用来交换两个 <code>Int</code> 值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">swapTwoInts</span><span class="params">(<span class="keyword">inout</span> a: Int, <span class="keyword">inout</span> <span class="number">_</span> b: Int)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA = a</span><br><span class="line">    a = b</span><br><span class="line">    b = temporaryA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数使用输入输出参数（<code>inout</code>）来交换 <code>a</code> 和 <code>b</code> 的值，请参考<a href="./06_Functions.html#in_out_parameters">输入输出参数</a>。</p>
<p><code>swapTwoInts(_:_:)</code> 函数交换 <code>b</code> 的原始值到 <code>a</code>，并交换 <code>a</code> 的原始值到 <code>b</code>。你可以调用这个函数交换两个 <code>Int</code> 变量的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someInt = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> anotherInt = <span class="number">107</span></span><br><span class="line">swapTwoInts(&amp;someInt, &amp;anotherInt)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"someInt is now <span class="subst">\(someInt)</span>, and anotherInt is now <span class="subst">\(anotherInt)</span>"</span>)</span><br><span class="line"><span class="comment">// 打印 “someInt is now 107, and anotherInt is now 3”</span></span><br></pre></td></tr></table></figure>
<p>诚然，<code>swapTwoInts(_:_:)</code> 函数挺有用，但是它只能交换 <code>Int</code> 值，如果你想要交换两个 <code>String</code> 值或者 <code>Double</code>值，就不得不写更多的函数，例如 <code>swapTwoStrings(_:_:)</code> 和 <code>swapTwoDoubles(_:_:)</code>，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">swapTwoStrings</span><span class="params">(<span class="keyword">inout</span> a: String, <span class="keyword">inout</span> <span class="number">_</span> b: String)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA = a</span><br><span class="line">    a = b</span><br><span class="line">    b = temporaryA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">swapTwoDoubles</span><span class="params">(<span class="keyword">inout</span> a: Double, <span class="keyword">inout</span> <span class="number">_</span> b: Double)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA = a</span><br><span class="line">    a = b</span><br><span class="line">    b = temporaryA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能注意到 <code>swapTwoInts(_:_:)</code>、<code>swapTwoStrings(_:_:)</code> 和 <code>swapTwoDoubles(_:_:)</code> 的函数功能都是相同的，唯一不同之处就在于传入的变量类型不同，分别是 <code>Int</code>、<code>String</code> 和 <code>Double</code>。</p>
<p>在实际应用中，通常需要一个更实用更灵活的函数来交换两个任意类型的值，幸运的是，泛型代码帮你解决了这种问题。（这些函数的泛型版本已经在下面定义好了。）</p>
<blockquote>
<p>注意<br>在上面三个函数中，<code>a</code> 和 <code>b</code> 类型相同。如果 <code>a</code> 和 <code>b</code> 类型不同，那它们俩就不能互换值。Swift 是类型安全的语言，所以它不允许一个 <code>String</code> 类型的变量和一个 <code>Double</code> 类型的变量互换值。试图这样做将导致编译错误。</p>
</blockquote>
<p><a name="generic_functions"></a></p>
<h2 id="泛型函数">泛型函数</h2><p>泛型函数可以适用于任何类型，下面的 <code>swapTwoValues(_:_:)</code> 函数是上面三个函数的泛型版本：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">swapTwoValues</span><span class="generics">&lt;T&gt;</span><span class="params">(<span class="keyword">inout</span> a: T, <span class="keyword">inout</span> <span class="number">_</span> b: T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA = a</span><br><span class="line">    a = b</span><br><span class="line">    b = temporaryA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>swapTwoValues(_:_:)</code> 的函数主体和 <code>swapTwoInts(_:_:)</code> 函数是一样的，它们只在第一行有点不同，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">swapTwoInts</span><span class="params">(<span class="keyword">inout</span> a: Int, <span class="keyword">inout</span> <span class="number">_</span> b: Int)</span></span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">swapTwoValues</span><span class="generics">&lt;T&gt;</span><span class="params">(<span class="keyword">inout</span> a: T, <span class="keyword">inout</span> <span class="number">_</span> b: T)</span></span></span><br></pre></td></tr></table></figure>
<p>这个函数的泛型版本使用了占位类型名（在这里用字母 <code>T</code> 来表示）来代替实际类型名（例如 <code>Int</code>、<code>String</code> 或 <code>Double</code>）。占位类型名没有指明 <code>T</code> 必须是什么类型，但是它指明了 <code>a</code> 和 <code>b</code> 必须是同一类型 <code>T</code>，而无论 <code>T</code> 代表什么类型。只有 <code>swapTwoValues(_:_:)</code> 函数在调用时，才能根据所传入的实际类型决定 <code>T</code> 所代表的类型。</p>
<p>另外一个不同之处在于这个泛型函数名后面跟着占位类型名（<code>T</code>），而且是用尖括号括起来的（<code>&lt;T&gt;</code>）。这个尖括号告诉 Swift 那个 <code>T</code> 是 <code>swapTwoValues(_:_:)</code> 函数定义的一个占位类型名，因此 Swift 不会去查找名为 <code>T</code> 的实际类型。</p>
<p><code>swapTwoValues(_:_:)</code> 函数现在可以像 <code>swapTwoInts(_:_:)</code> 那样调用，可以传入任意类型的值，只要两个值的类型相同。<code>swapTwoValues(_:_:)</code> 函数被调用时，<code>T</code> 所代表的类型都会由传入的值的类型推断出来。</p>
<p>在下面的两个例子中，<code>T</code> 分别代表 <code>Int</code> 和 <code>String</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someInt = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> anotherInt = <span class="number">107</span></span><br><span class="line">swapTwoValues(&amp;someInt, &amp;anotherInt)</span><br><span class="line"><span class="comment">// someInt is now 107, and anotherInt is now 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someString = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">var</span> anotherString = <span class="string">"world"</span></span><br><span class="line">swapTwoValues(&amp;someString, &amp;anotherString)</span><br><span class="line"><span class="comment">// someString is now "world", and anotherString is now "hello"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>上面定义的 <code>swapTwoValues(_:_:)</code> 函数是受 <code>swap(_:_:)</code> 函数启发而实现的。后者存在于 Swift 标准库，你可以在你的应用程序中使用它。如果你在代码中需要类似 <code>swapTwoValues(_:_:)</code> 函数的功能，你可以使用已存在的 <code>swap(_:_:)</code> 函数。</p>
</blockquote>
<p><a name="type_parameters"></a></p>
<h2 id="类型参数">类型参数</h2><p>在上面的 <code>swapTwoValues(_:_:)</code> 例子中，占位类型 <code>T</code> 是类型参数的一个例子。类型参数指定并命名一个占位类型，并且紧随在函数名后面，使用一对尖括号括起来（例如 <code>&lt;T&gt;</code>）。</p>
<p>一旦一个类型参数被指定，你可以用它来定义一个函数的参数类型（例如 <code>swapTwoValues(_:_:)</code> 函数中的参数 <code>a</code> 和 <code>b</code>），或者作为函数的返回类型，还可以用作函数主体中的注释类型。在这些情况下，类型参数会在函数调用时被实际类型所替换。（在上面的 <code>swapTwoValues(_:_:)</code> 例子中，当函数第一次被调用时，<code>T</code> 被 <code>Int</code> 替换，第二次调用时，被 <code>String</code> 替换。）</p>
<p>你可提供多个类型参数，将它们都写在尖括号中，用逗号分开。</p>
<p><a name="naming_type_parameters"></a></p>
<h2 id="命名类型参数">命名类型参数</h2><p>在大多数情况下，类型参数具有一个描述性名字，例如 <code>Dictionary&lt;Key, Value&gt;</code> 中的 <code>Key</code> 和 <code>Value</code>，以及 <code>Array&lt;Element&gt;</code> 中的 <code>Element</code>，这可以告诉阅读代码的人这些类型参数和泛型函数之间的关系。然而，当它们之间的关系没有意义时，通常使用单一的字母来命名，例如 <code>T</code>、<code>U</code>、<code>V</code>，正如上面演示的 <code>swapTwoValues(_:_:)</code> 函数中的 <code>T</code> 一样。</p>
<blockquote>
<p>注意<br>请始终使用大写字母开头的驼峰式命名法（例如 <code>T</code> 和 <code>MyTypeParameter</code>）来为类型参数命名，以表明它们是占位类型，而不是一个值。</p>
</blockquote>
<p><a name="generic_types"></a></p>
<h2 id="泛型类型">泛型类型</h2><p>除了泛型函数，Swift 还允许你定义泛型类型。这些自定义类、结构体和枚举可以适用于任何类型，如同 <code>Array</code> 和 <code>Dictionary</code> 的用法。</p>
<p>这部分内容将向你展示如何编写一个名为 <code>Stack</code> （栈）的泛型集合类型。栈是一系列值的有序集合，和 <code>Array</code> 类似，但它相比 Swift 的 <code>Array</code> 类型有更多的操作限制。数组允许对其中任意位置的元素执行插入或删除操作。而栈，只允许在集合的末端添加新的元素（称之为入栈）。同样的，栈也只能从末端移除元素（称之为出栈）。</p>
<blockquote>
<p>注意<br>栈的概念已被 <code>UINavigationController</code> 类用来模拟视图控制器的导航结构。你通过调用 <code>UINavigationController</code> 的 <code>pushViewController(_:animated:)</code> 方法来添加新的视图控制器到导航栈，通过 <code>popViewControllerAnimated(_:)</code> 方法来从导航栈中移除某个视图控制器。每当你需要一个严格的“后进先出”方式来管理集合，栈都是最实用的模型。</p>
</blockquote>
<p>下图展示了一个栈的压栈（push）和出栈（pop）的行为：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPushPop_2x.png" alt="此处输入图片的描述"></p>
<ol>
<li>现在有三个值在栈中。</li>
<li>第四个值被压入到栈的顶部。</li>
<li>现在有四个值在栈中，最近入栈的那个值在顶部。</li>
<li>栈中最顶部的那个值被移除，或称之为出栈。</li>
<li>移除掉一个值后，现在栈再一次只有三个值。</li>
</ol>
<p>下面展示了如何编写一个非泛型版本的栈，在这种情况下是 <code>Int</code> 型的栈：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IntStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> items = [<span class="type">Int</span>]()</span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">push</span><span class="params">(item: Int)</span></span> &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个结构体在栈中使用一个名为 <code>items</code> 的 <code>Array</code> 属性来存储值。<code>Stack</code> 提供了两个方法：<code>push(_:)</code> 和 <code>pop()</code>，用来向栈中压入值以及从栈中移除值。这些方法被标记为 <code>mutating</code>，因为它们需要修改结构体的 <code>items</code> 数组。</p>
<p>上面的 <code>IntStack</code> 结构体只能用于 <code>Int</code> 类型。不过，可以定义一个泛型 <code>Stack</code> 结构体，从而能够处理任意类型的值。</p>
<p>下面是相同代码的泛型版本：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> items = [<span class="type">Element</span>]()</span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">push</span><span class="params">(item: Element)</span></span> &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，<code>Stack</code> 基本上和 <code>IntStack</code> 相同，只是用占位类型参数 <code>Element</code> 代替了实际的 <code>Int</code> 类型。这种类型参数包裹在一对尖括号里（<code>&lt;Element&gt;</code>），紧跟在结构体名后面。</p>
<p><code>Element</code> 为尚未提供的类型定义了一个占位名。这种尚未提供的类型可以在结构体的定义中通过 <code>Element</code> 来引用。在这种情况下，<code>Element</code> 在如下三个地方被用作占位符：</p>
<ul>
<li>创建 <code>items</code> 属性，使用 <code>Element</code> 类型的空数组对其进行初始化。</li>
<li>指定 <code>push(_:)</code> 方法的单一参数 <code>item</code> 的类型必须是 <code>Element</code> 类型。</li>
<li>指定 <code>pop()</code> 方法的返回值类型必须是 <code>Element</code> 类型。</li>
</ul>
<p>由于 <code>Stack</code> 是泛型类型，因此可以用来创建 Swift 中任意有效类型的栈，如同 <code>Array</code> 和 <code>Dictionary</code>。</p>
<p>你可以通过在尖括号中写出栈中需要存储的数据类型来创建并初始化一个 <code>Stack</code> 实例。例如，要创建一个 <code>String</code> 类型的栈，可以写成 <code>Stack&lt;String&gt;()</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stackOfStrings = <span class="type">Stack</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">stackOfStrings.push(<span class="string">"uno"</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">"dos"</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">"tres"</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">"cuatro"</span>)</span><br><span class="line"><span class="comment">// 栈中现在有 4 个字符串</span></span><br></pre></td></tr></table></figure>
<p>下图展示了 <code>stackOfStrings</code> 如何将这四个值入栈：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPushedFourStrings_2x.png" alt="此处输入图片的描述"></p>
<p>移除并返回栈顶部的值 <code>&quot;cuatro&quot;</code>，即将其出栈：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fromTheTop = stackOfStrings.pop()</span><br><span class="line"><span class="comment">// fromTheTop 的值为 "cuatro"，现在栈中还有 3 个字符串</span></span><br></pre></td></tr></table></figure>
<p>下图展示了 <code>stackOfStrings</code> 如何将顶部的值出栈：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPoppedOneString_2x.png" alt="此处输入图片的描述"></p>
<p><a name="extending_a_generic_type"></a></p>
<h2 id="扩展一个泛型类型">扩展一个泛型类型</h2><p>当你扩展一个泛型类型的时候，你并不需要在扩展的定义中提供类型参数列表。更加方便的是，原始类型定义中声明的类型参数列表在扩展中可以直接使用，并且这些来自原始类型中的参数名称会被用作原始定义中类型参数的引用。</p>
<p>下面的例子扩展了泛型类型 <code>Stack</code>，为其添加了一个名为 <code>topItem</code> 的只读计算型属性，它将会返回当前栈顶端的元素而不会将其从栈中移除：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> topItem: <span class="type">Element</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> items.isEmpty ? <span class="literal">nil</span> : items[items.<span class="built_in">count</span> - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>topItem</code> 属性会返回一个 <code>Element</code> 类型的可选值。当栈为空的时候，<code>topItem</code> 会返回 <code>nil</code>；当栈不为空的时候，<code>topItem</code> 会返回 <code>items</code> 数组中的最后一个元素。</p>
<p>注意，这个扩展并没有定义一个类型参数列表。相反的，<code>Stack</code> 类型已有的类型参数名称 <code>Element</code>，被用在扩展中来表示计算型属性 <code>topItem</code> 的可选类型。</p>
<p>计算型属性 <code>topItem</code> 现在可以用来访问任意 <code>Stack</code> 实例的顶端元素而不是移除它：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> topItem = stackOfStrings.topItem &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The top item on the stack is <span class="subst">\(topItem)</span>."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “The top item on the stack is tres.”</span></span><br></pre></td></tr></table></figure>
<p><a name="type_constraints"></a></p>
<h2 id="类型约束">类型约束</h2><p><code>swapTwoValues(_:_:)</code> 函数和 <code>Stack</code> 类型可以作用于任何类型。不过，有的时候如果能将使用在泛型函数和泛型类型中的类型，强制约束为某种特定类型，将会是非常有用的。类型约束可以指定一个类型参数必须继承自指定类，或者符合一个特定的协议或协议组合。</p>
<p>例如，Swift 的 <code>Dictionary</code> 类型对字典的键的类型做了些限制。在<a href="./04_Collection_Types.html#dictionaries">字典</a>的描述中，字典的键的类型必须是可哈希的。也就是说，必须有一种方法能作为其唯一的表示。<code>Dictionary</code> 之所以需要其键是可哈希的，是为了便于检查字典是否已经包含某个特定键的值。如无此要求，<code>Dictionary</code> 将无法判断是否可以插入或者替换某个指定键的值，也不能查找到已经存储在字典中的指定键的值。</p>
<p>这个要求强制加上了一个类型约束作用于 <code>Dictionary</code> 的键类型上，其键类型必须符合 <code>Hashable</code> 协议，这是 Swift 标准库中定义的一个特定协议。所有的 Swift 基本类型（例如 <code>String</code>、<code>Int</code>、<code>Double</code> 和 <code>Bool</code>）默认都是可哈希的。</p>
<p>当你创建自定义泛型类型时，你可以定义你自己的类型约束，这些约束将提供更为强大的泛型编程能力。抽象概念，例如可哈希的，描述的是类型在概念上的特征，而不是它们的显式类型。</p>
<p><a name="type_constraint_syntax"></a></p>
<h3 id="类型约束语法">类型约束语法</h3><p>你可以在一个类型参数名后面放置一个类名或者协议名，通过冒号分隔，从而定义类型约束，它们将作为类型参数列表的一部分。这种基本的类型约束作用于泛型函数时的语法如下所示（作用于泛型类型时的语法与之相同）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">someFunction</span><span class="generics">&lt;T: SomeClass, U: SomeProtocol&gt;</span><span class="params">(someT: T, someU: U)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这里是泛型函数的函数体部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个函数有两个类型参数。第一个类型参数 <code>T</code>，有一个要求 <code>T</code> 必须是 <code>SomeClass</code> 子类的类型约束；第二个类型参数 <code>U</code>，有一个要求 <code>U</code> 必须符合 <code>SomeProtocol</code> 协议的类型约束。</p>
<p><a name="type_constraints_in_action"></a></p>
<h3 id="类型约束实践">类型约束实践</h3><p>这里有个名为 <code>findStringIndex</code> 的非泛型函数，该函数的功能是在 <code>String</code> 值的数组中查找给定 <code>String</code> 值的索引。若查找到匹配的字符串，<code>findStringIndex(_:_:)</code> 函数返回该字符串在数组中的索引值，反之则返回 <code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">findStringIndex</span><span class="params">(array: [String], <span class="number">_</span> valueToFind: String)</span></span> -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> array.<span class="built_in">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> value == valueToFind &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>findStringIndex(_:_:)</code> 函数可以用于查找字符串数组中的某个字符串：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> strings = [<span class="string">"cat"</span>, <span class="string">"dog"</span>, <span class="string">"llama"</span>, <span class="string">"parakeet"</span>, <span class="string">"terrapin"</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> foundIndex = findStringIndex(strings, <span class="string">"llama"</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The index of llama is <span class="subst">\(foundIndex)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “The index of llama is 2”</span></span><br></pre></td></tr></table></figure>
<p>如果只能查找字符串在数组中的索引，用处不是很大。不过，你可以写出相同功能的泛型函数 <code>findIndex(_:_:)</code>，用占位类型 <code>T</code> 替换 <code>String</code> 类型。</p>
<p>下面展示了 <code>findStringIndex(_:_:)</code> 函数的泛型版本 <code>findIndex(_:_:)</code>。请注意这个函数仍然返回 <code>Int?</code>，那是因为函数返回的是一个可选的索引数，而不是从数组中得到的一个可选值。需要提醒的是，这个函数无法通过编译，原因在例子后面会说明：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">findIndex</span><span class="generics">&lt;T&gt;</span><span class="params">(array: [T], <span class="number">_</span> valueToFind: T)</span></span> -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> array.<span class="built_in">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> value == valueToFind &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面所写的函数无法通过编译。这个问题出在相等性检查上，即 <code>“if value == valueToFind”</code>。不是所有的 Swift 类型都可以用等式符（<code>==</code>）进行比较。例如，如果你创建一个你自己的类或结构体来表示一个复杂的数据模型，那么 Swift 无法猜到对于这个类或结构体而言“相等”意味着什么。正因如此，这部分代码无法保证适用于每个可能的类型 <code>T</code>，当你试图编译这部分代码时会出现相应的错误。</p>
<p>不过，所有的这些并不会让我们无从下手。Swift 标准库中定义了一个 <code>Equatable</code> 协议，该协议要求任何符合该协议的类型必须实现等式符（<code>==</code>），从而能对符合该协议的类型的任意两个值进行比较。所有的 Swift 标准类型自动支持 <code>Equatable</code> 协议。</p>
<p>任何 <code>Equatable</code> 类型都可以安全地使用在 <code>findIndex(_:_:)</code> 函数中，因为其保证支持等式操作符。为了说明这个事实，当你定义一个函数时，你可以定义一个 <code>Equatable</code> 类型约束作为类型参数定义的一部分：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">findIndex</span><span class="generics">&lt;T: Equatable&gt;</span><span class="params">(array: [T], <span class="number">_</span> valueToFind: T)</span></span> -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> array.<span class="built_in">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> value == valueToFind &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>findIndex(_:_:)</code> 中的这个单一类型参数写做 <code>T: Equatable</code>，也就意味着“任何符合 <code>Equatable</code> 协议的 <code>T</code> 类型”。</p>
<p><code>findIndex(_:_:)</code> 函数现在可以成功编译了，并且可以作用于任何符合 <code>Equatable</code> 的类型，如 <code>Double</code> 或 <code>String</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> doubleIndex = findIndex([<span class="number">3.14159</span>, <span class="number">0.1</span>, <span class="number">0.25</span>], <span class="number">9.3</span>)</span><br><span class="line"><span class="comment">// doubleIndex 类型为 Int?，其值为 nil，因为 9.3 不在数组中</span></span><br><span class="line"><span class="keyword">let</span> stringIndex = findIndex([<span class="string">"Mike"</span>, <span class="string">"Malcolm"</span>, <span class="string">"Andrea"</span>], <span class="string">"Andrea"</span>)</span><br><span class="line"><span class="comment">// stringIndex 类型为 Int?，其值为 2</span></span><br></pre></td></tr></table></figure>
<p><a name="associated_types"></a></p>
<h2 id="关联类型">关联类型</h2><p>定义一个协议时，有的时候声明一个或多个关联类型作为协议定义的一部分将会非常有用。关联类型作为协议的一部分，为某个类型提供了一个占位名（或者说别名），其代表的实际类型在协议被采纳时才会被指定。你可以通过 <code>typealias</code> 关键字来指定关联类型。</p>
<p><a name="associated_types_in_action"></a></p>
<h3 id="关联类型实践">关联类型实践</h3><p>下面例子定义了一个 <code>Container</code> 协议，该协议定义了一个关联类型 <code>ItemType</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">ItemType</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">append</span><span class="params">(item: ItemType)</span></span></span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">ItemType</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Container</code> 协议定义了三个任何采纳协议的类型必须提供的功能：</p>
<ul>
<li>必须可以通过 <code>append(_:)</code> 方法添加一个新元素到容器里。</li>
<li>必须可以通过 <code>count</code> 属性获取容器中元素的数量，并返回一个 <code>Int</code> 值。</li>
<li>必须可以通过接受 <code>Int</code> 索引值的下标检索到每一个元素。</li>
</ul>
<p>这个协议没有指定容器中元素该如何存储，以及元素必须是何种类型。这个协议只指定了三个任何采纳 <code>Container</code> 协议的类型必须提供的功能。采纳协议的类型在满足这三个条件的情况下也可以提供其他额外的功能。</p>
<p>任何采纳 <code>Container</code> 协议的类型必须能够指定其存储的元素的类型，必须保证只有正确类型的元素可以加进容器中，必须明确通过其下标返回的元素的类型。</p>
<p>为了定义这三个条件，<code>Container</code> 协议需要在不知道容器中元素的具体类型的情况下引用这种类型。<code>Container</code> 协议需要指定任何通过 <code>append(_:)</code> 方法添加到容器中的元素和容器中的元素是相同类型，并且通过容器下标返回的元素的类型也是这种类型。</p>
<p>为了达到此目的，<code>Container</code> 协议声明了一个关联类型 <code>ItemType</code>，写作 <code>typealias ItemType</code>。这个协议无法定义 <code>ItemType</code> 是什么类型的别名，这个信息将留给采纳协议的类型来提供。尽管如此，<code>ItemType</code> 别名提供了一种方式来引用 <code>Container</code> 中元素的类型，并将之用于 <code>append(_:)</code> 方法和下标，从而保证任何 <code>Container</code> 的预期行为都能够被执行。</p>
<p>下面是先前的非泛型的 <code>IntStack</code> 类型，这一版本采纳并符合了 <code>Container</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IntStack</span>: <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="comment">// IntStack 的原始实现部分</span></span><br><span class="line">    <span class="keyword">var</span> items = [<span class="type">Int</span>]()</span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">push</span><span class="params">(item: Int)</span></span> &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Container 协议的实现部分</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">ItemType</span> = <span class="type">Int</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">append</span><span class="params">(item: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>IntStack</code> 结构体实现了 <code>Container</code> 协议的三个要求，其原有功能也不会和这些要求相冲突。</p>
<p>此外，<code>IntStack</code> 指定 <code>ItemType</code> 为 <code>Int</code> 类型，即 <code>typealias ItemType = Int</code>，从而将 <code>Container</code> 协议中抽象的 <code>ItemType</code> 类型转换为具体的 <code>Int</code> 类型。</p>
<p>由于 Swift 的类型推断，你实际上不用在 <code>IntStack</code> 的定义中声明 <code>ItemType</code> 为 <code>Int</code>。因为 <code>IntStack</code> 符合 <code>Container</code> 协议的所有要求，Swift 只需通过 <code>append(_:)</code> 方法的 <code>item</code> 参数类型和下标返回值的类型，就可以推断出 <code>ItemType</code> 的具体类型。事实上，如果你在上面的代码中删除了 <code>typealias ItemType = Int</code> 这一行，这一切仍旧可以正常工作，因为 Swift 清楚地知道 <code>ItemType</code> 应该是何种类型。</p>
<p>你也可以令泛型 <code>Stack</code> 结构体符合 <code>Container</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&lt;<span class="title">Element</span>&gt;: <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Stack&lt;Element&gt; 的原始实现部分</span></span><br><span class="line">    <span class="keyword">var</span> items = [<span class="type">Element</span>]()</span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">push</span><span class="params">(item: Element)</span></span> &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Container 协议的实现部分</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">append</span><span class="params">(item: Element)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一次，占位类型参数 <code>Element</code> 被用作 <code>append(_:)</code> 方法的 <code>item</code> 参数和下标的返回类型。Swift 可以据此推断出 <code>Element</code> 的类型即是 <code>ItemType</code> 的类型。</p>
<p><a name="extending_an_existing_type_to_specify_an_associated_type"></a></p>
<h3 id="通过扩展一个存在的类型来指定关联类型">通过扩展一个存在的类型来指定关联类型</h3><p><a href="./22_Protocols.html#adding_protocol_conformance_with_an_extension">通过扩展添加协议一致性</a>中描述了如何利用扩展让一个已存在的类型符合一个协议，这包括使用了关联类型的协议。</p>
<p>Swift 的 <code>Array</code> 已经提供 <code>append(_:)</code> 方法，一个 <code>count</code> 属性，以及一个接受 <code>Int</code> 型索引值的可用来检索数组元素的下标。这三个功能都符合 <code>Container</code> 协议的要求，也就意味着你可以扩展 <code>Array</code> 去符合 <code>Container</code> 协议，只需简单地声明 <code>Array</code> 采纳该协议即可。你可以通过一个空扩展来实现这点，正如<a href="./22_Protocols.html#declaring_protocol_adoption_with_an_extension">通过扩展采纳协议</a>中的描述：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span>: <span class="title">Container</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如同上面的泛型 <code>Stack</code> 结构体一样，<code>Array</code> 的 <code>append(_:)</code> 方法和下标确保了 Swift 可以推断出 <code>ItemType</code> 的类型。定义了这个扩展后，你可以将任意 <code>Array</code> 当作 <code>Container</code> 来使用。</p>
<p><a name="where_clauses"></a></p>
<h2 id="Where_子句">Where 子句</h2><p><a href="#type_constraints">类型约束</a>让你能够为泛型函数或泛型类型的类型参数定义一些强制要求。</p>
<p>为关联类型定义约束也是非常有用的。你可以在参数列表中通过 <code>where</code> 子句为关联类型定义约束。一个 <code>where</code> 子句能够使一个关联类型符合某个特定的协议，以及某个特定的类型参数和关联类型必须类型相同。你可以通过将 <code>where</code> 关键字紧跟在类型参数列表后面来定义 <code>where</code> 子句，<code>where</code> 子句后跟一个或者多个针对关联类型的约束，以及一个或多个类型参数和关联类型间的相等关系。</p>
<p>下面的例子定义了一个名为 <code>allItemsMatch</code> 的泛型函数，用来检查两个 <code>Container</code> 实例是否包含相同顺序的相同元素。如果所有的元素能够匹配，那么返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p>被检查的两个 <code>Container</code> 可以不是相同类型的容器（虽然它们可以相同），但它们必须拥有相同类型的元素。这个要求通过一个类型约束以及一个 <code>where</code> 子句来表示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">allItemsMatch</span><span class="generics">&lt;</span><br><span class="line">    C1: Container, C2: Container</span><br><span class="line">    where C1.ItemType == C2.ItemType, C1.ItemType: Equatable&gt;</span></span><br><span class="line">    <span class="params">(someContainer: C1, <span class="number">_</span> anotherContainer: C2)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查两个容器含有相同数量的元素</span></span><br><span class="line">        <span class="keyword">if</span> someContainer.<span class="built_in">count</span> != anotherContainer.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查每一对元素是否相等</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;someContainer.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> someContainer[i] != anotherContainer[i] &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所有元素都匹配，返回 true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数接受 <code>someContainer</code> 和 <code>anotherContainer</code> 两个参数。参数 <code>someContainer</code> 的类型为 <code>C1</code>，参数 <code>anotherContainer</code> 的类型为 <code>C2</code>。<code>C1</code> 和 <code>C2</code> 是容器的两个占位类型参数，函数被调用时才能确定它们的具体类型。</p>
<p>这个函数的类型参数列表还定义了两个类型参数的要求：</p>
<ul>
<li><code>C1</code> 必须符合 <code>Container</code> 协议（写作 <code>C1: Container</code>）。</li>
<li><code>C2</code> 必须符合 <code>Container</code> 协议（写作 <code>C2: Container</code>）。</li>
<li><code>C1</code> 的 <code>ItemType</code> 必须和 <code>C2</code> 的 <code>ItemType</code>类型相同（写作 <code>C1.ItemType == C2.ItemType</code>）。</li>
<li><code>C1</code> 的 <code>ItemType</code> 必须符合 <code>Equatable</code> 协议（写作 <code>C1.ItemType: Equatable</code>）。</li>
</ul>
<p>第三个和第四个要求被定义为一个 <code>where</code> 子句，写在关键字 <code>where</code> 后面，它们也是泛型函数类型参数列表的一部分。</p>
<p>这些要求意味着：</p>
<ul>
<li><code>someContainer</code> 是一个 <code>C1</code> 类型的容器。</li>
<li><code>anotherContainer</code> 是一个 <code>C2</code> 类型的容器。</li>
<li><code>someContainer</code> 和 <code>anotherContainer</code> 包含相同类型的元素。</li>
<li><code>someContainer</code> 中的元素可以通过不等于操作符（<code>!=</code>）来检查它们是否彼此不同。</li>
</ul>
<p>第三个和第四个要求结合起来意味着 <code>anotherContainer</code> 中的元素也可以通过 <code>!=</code> 操作符来比较，因为它们和 <code>someContainer</code> 中的元素类型相同。</p>
<p>这些要求让 <code>allItemsMatch(_:_:)</code> 函数能够比较两个容器，即使它们是不同的容器类型。</p>
<p><code>allItemsMatch(_:_:)</code> 函数首先检查两个容器是否拥有相同数量的元素，如果它们的元素数量不同，那么一定不匹配，函数就会返回 <code>false</code>。</p>
<p>进行这项检查之后，通过 <code>for-in</code> 循环和半闭区间操作符（<code>..&lt;</code>）来迭代每个元素，检查 <code>someContainer</code> 中的元素是否不等于 <code>anotherContainer</code> 中的对应元素。如果两个元素不相等，那么两个容器不匹配，函数返回 <code>false</code>。</p>
<p>如果循环体结束后未发现任何不匹配的情况，表明两个容器匹配，函数返回 <code>true</code>。</p>
<p>下面演示了 <code>allItemsMatch(_:_:)</code> 函数的使用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stackOfStrings = <span class="type">Stack</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">stackOfStrings.push(<span class="string">"uno"</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">"dos"</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">"tres"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arrayOfStrings = [<span class="string">"uno"</span>, <span class="string">"dos"</span>, <span class="string">"tres"</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> allItemsMatch(stackOfStrings, arrayOfStrings) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"All items match."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Not all items match."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “All items match.”</span></span><br></pre></td></tr></table></figure>
<p>上面的例子创建一个 <code>Stack</code> 实例来存储一些 <code>String</code> 值，然后将三个字符串压入栈中。这个例子还通过数组字面量创建了一个 <code>Array</code> 实例，数组中包含三个同栈中一样的字符串。即使栈和数组是不同的类型，但它们都符合 <code>Container</code> 协议，而且它们都包含相同类型的值。因此你可以用这两个容器作为参数来调用 <code>allItemsMatch(_:_:)</code> 函数。在上面的例子中，<code>allItemsMatch(_:_:)</code> 函数正确地显示了这两个容器中的所有元素都是相互匹配的。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/24_Access_Control/" itemprop="url">
                第二章-24访问控制（Access Control）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:03+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/24_Access_Control/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/24_Access_Control/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="访问控制（Access_Control）">访问控制（Access Control）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="http://www.devtalking.com/" target="_blank" rel="external">JaceFu</a><br>校对：<a href="http://childhood.logdown.com" target="_blank" rel="external">ChildhoodAndy</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/mmoaay" target="_blank" rel="external">mmoaay</a></p>
<p>2.1<br>翻译：<a href="https://github.com/futantan" target="_blank" rel="external">Prayer</a><br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a>，2015-11-01</p>
</blockquote>
<p>本页内容包括：</p>
<ul>
<li><a href="#modules_and_source_files">模块和源文件</a></li>
<li><a href="#access_levels">访问级别</a><ul>
<li><a href="#guiding_principle_of_access_levels">访问级别基本原则</a></li>
<li><a href="#default_access_levels">默认访问级别</a></li>
<li><a href="#access_levels_for_single-target_apps">单 target 应用程序的访问级别</a></li>
<li><a href="#access_levels_for_frameworks">框架的访问级别</a></li>
<li><a href="#access_levels_for_unit_test_targets">单元测试 target 的访问级别</a></li>
</ul>
</li>
<li><a href="#access_control_syntax">访问控制语法</a></li>
<li><a href="#custom_types">自定义类型</a><ul>
<li><a href="#tuple_types">元组类型</a></li>
<li><a href="#function_types">函数类型</a></li>
<li><a href="#enumeration_types">枚举类型</a></li>
<li><a href="#nested_types">嵌套类型</a></li>
</ul>
</li>
<li><a href="#subclassing">子类</a></li>
<li><a href="#constants_variables_properties_subscripts">常量、变量、属性、下标</a><ul>
<li><a href="#getters_and_setters">Getter和Setter</a></li>
</ul>
</li>
<li><a href="#initializers">构造器</a><ul>
<li><a href="#default_initializers">默认构造器</a></li>
<li><a href="#default_memberwise_initializers_for_structure_types">结构体默认的成员逐一构造器</a></li>
</ul>
</li>
<li><a href="#protocols">协议</a><ul>
<li><a href="#protocol_inheritance">协议继承</a></li>
<li><a href="#protocol_conformance">协议一致性</a></li>
</ul>
</li>
<li><a href="#extensions">扩展</a><ul>
<li><a href="#adding_protocol_conformance_with_an_extension">通过扩展添加协议一致性</a></li>
</ul>
</li>
<li><a href="#generics">泛型</a></li>
<li><a href="#type_aliases">类型别名</a></li>
</ul>
<p>访问控制可以限定其他源文件或模块中的代码对你的代码的访问级别。这个特性可以让我们隐藏代码的一些实现细节，并且可以为其他人可以访问和使用的代码提供接口。</p>
<p>你可以明确地给单个类型（类、结构体、枚举）设置访问级别，也可以给这些类型的属性、方法、构造器、下标等设置访问级别。协议也可以被限定在一定的范围内使用，包括协议里的全局常量、变量和函数。</p>
<p>Swift 不仅提供了多种不同的访问级别，还为某些典型场景提供了默认的访问级别，这样就不需要我们在每段代码中都申明显式访问级别。其实，如果只是开发一个单一 target 的应用程序，我们完全可以不用显式申明代码的访问级别。</p>
<blockquote>
<p>注意<br>为了简单起见，对于代码中可以设置访问级别的特性（属性、基本类型、函数等），在下面的章节中我们会称之为“实体”。</p>
</blockquote>
<p><a name="modules_and_source_files"></a></p>
<h2 id="模块和源文件">模块和源文件</h2><p>Swift 中的访问控制模型基于模块和源文件这两个概念。</p>
<p>模块指的是独立的代码单元，框架或应用程序会作为一个独立的模块来构建和发布。在 Swift 中，一个模块可以使用 <code>import</code> 关键字导入另外一个模块。</p>
<p>在 Swift 中，Xcode 的每个 target（例如框架或应用程序）都被当作独立的模块处理。如果你是为了实现某个通用的功能，或者是为了封装一些常用方法而将代码打包成独立的框架，这个框架就是 Swift 中的一个模块。当它被导入到某个应用程序或者其他框架时，框架内容都将属于这个独立的模块。  </p>
<p>源文件就是 Swift 中的源代码文件，它通常属于一个模块，即一个应用程序或者框架。尽管我们一般会将不同的类型分别定义在不同的源文件中，但是同一个源文件也可以包含多个类型、函数之类的定义。</p>
<p><a name="access_levels"></a></p>
<h2 id="访问级别">访问级别</h2><p>Swift 为代码中的实体提供了三种不同的访问级别。这些访问级别不仅与源文件中定义的实体相关，同时也与源文件所属的模块相关。</p>
<ul>
<li><code>public</code>：可以访问同一模块源文件中的任何实体，在模块外也可以通过导入该模块来访问源文件里的所有实体。通常情况下，框架中的某个接口可以被任何人使用时，你可以将其设置为 <code>public</code> 级别。</li>
<li><code>internal</code>：可以访问同一模块源文件中的任何实体，但是不能从模块外访问该模块源文件中的实体。通常情况下，某个接口只在应用程序或框架内部使用时，你可以将其设置为 <code>internal</code> 级别。</li>
<li><code>private</code>：限制实体只能在所在的源文件内部使用。使用 <code>private</code> 级别可以隐藏某些功能的实现细节。</li>
</ul>
<p><code>public</code> 为最高（限制最少）访问级别，<code>private</code> 为最低（限制最多）访问级别。</p>
<blockquote>
<p>注意<br>Swift 中的 <code>private</code> 访问级别不同于其他语言，它的范围限于源文件，而不是声明范围内。这就意味着，一个类型可以访问其所在源文件中的所有 <code>private</code> 实体，但是如果它的扩展定义在其他源文件中，那么它的扩展就不能访问它在这个源文件中定义的 <code>private</code> 实体。</p>
</blockquote>
<p><a name="guiding_principle_of_access_levels"></a></p>
<h3 id="访问级别基本原则">访问级别基本原则</h3><p>Swift 中的访问级别遵循一个基本原则：不可以在某个实体中定义访问级别更高的实体。</p>
<p>例如：</p>
<ul>
<li>一个 <code>public</code> 访问级别的变量，其类型的访问级别不能是 <code>internal</code> 或 <code>private</code>。因为无法保证变量的类型在使用变量的地方也具有访问权限。</li>
<li>函数的访问级别不能高于它的参数类型和返回类型的访问级别。因为如果函数定义为 <code>public</code> 而参数类型或者返回类型定义为 <code>internal</code> 或 <code>private</code>，就会出现函数可以在任何地方被访问，但是它的参数类型和返回类型却不可以。</li>
</ul>
<p><a name="default_access_levels"></a></p>
<h3 id="默认访问级别">默认访问级别</h3><p>如果你不为代码中的实体显式指定访问级别，那么它们默认为 <code>internal</code> 级别（有一些例外情况，稍后会进行说明）。因此，在大多数情况下，我们不需要显式指定实体的访问级别。</p>
<p><a name="access_levels_for_single-target_apps"></a></p>
<h3 id="单_target_应用程序的访问级别">单 target 应用程序的访问级别</h3><p>当你编写一个单 target 应用程序时，应用的所有功能都是为该应用服务，而不需要提供给其他应用或者模块使用，所以我们不需要明确设置访问级别，使用默认的访问级别 <code>internal</code> 即可。但是，你也可以使用 <code>private</code> 级别，用于隐藏一些功能的实现细节。</p>
<p><a name="access_levels_for_frameworks"></a></p>
<h3 id="框架的访问级别">框架的访问级别</h3><p>当你开发框架时，就需要把一些对外的接口定义为 <code>public</code> 级别，以便使用者导入该框架后可以正常使用其功能。这些被你定义为 <code>public</code> 的接口，就是这个框架的 API。</p>
<blockquote>
<p>注意<br>框架依然会使用默认的 <code>internal</code> 级别，也可以指定为 <code>private</code> 级别。当你想把某个实体作为框架的 API 的时候，需显式为其指定 <code>public</code> 级别。</p>
</blockquote>
<p><a name="access_levels_for_unit_test_targets"></a></p>
<h3 id="单元测试_target_的访问级别">单元测试 target 的访问级别</h3><p>当你的应用程序包含单元测试 target 时，为了测试，测试模块需要访问应用程序模块中的代码。默认情况下只有 <code>public</code> 级别的实体才可以被其他模块访问。然而，如果在导入应用程序模块的语句前使用 <code>@testable</code> 特性，然后在允许测试的编译设置（<code>Build Options -&gt; Enable Testability</code>）下编译这个应用程序模块，单元测试 target 就可以访问应用程序模块中所有 <code>internal</code> 级别的实体。</p>
<p><a name="access_control_syntax"></a></p>
<h2 id="访问控制语法">访问控制语法</h2><p>通过修饰符 <code>public</code>、<code>internal</code>、<code>private</code> 来声明实体的访问级别：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SomePublicClass</span> </span>&#123;&#125;</span><br><span class="line">internal <span class="class"><span class="keyword">class</span> <span class="title">SomeInternalClass</span> </span>&#123;&#125;</span><br><span class="line">private <span class="class"><span class="keyword">class</span> <span class="title">SomePrivateClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">var</span> somePublicVariable = <span class="number">0</span></span><br><span class="line">internal <span class="keyword">let</span> someInternalConstant = <span class="number">0</span></span><br><span class="line">private <span class="func"><span class="keyword">func</span> <span class="title">somePrivateFunction</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>除非专门指定，否则实体默认的访问级别为 <code>internal</code>，可以查阅<a href="#default_access_levels">默认访问级别</a>这一节。这意味着在不使用修饰符显式声明访问级别的情况下，<code>SomeInternalClass</code> 和 <code>someInternalConstant</code> 仍然拥有隐式的访问级别 <code>internal</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeInternalClass</span> </span>&#123;&#125;   <span class="comment">// 隐式访问级别 internal</span></span><br><span class="line"><span class="keyword">var</span> someInternalConstant = <span class="number">0</span> <span class="comment">// 隐式访问级别 internal</span></span><br></pre></td></tr></table></figure>
<p><a name="custom_types"></a></p>
<h2 id="自定义类型">自定义类型</h2><p>如果想为一个自定义类型指定访问级别，在定义类型时进行指定即可。新类型只能在它的访问级别限制范围内使用。例如，你定义了一个 <code>private</code> 级别的类，那这个类就只能在定义它的源文件中使用，可以作为属性类型、函数参数类型或者返回类型，等等。</p>
<p>一个类型的访问级别也会影响到类型成员（属性、方法、构造器、下标）的默认访问级别。如果你将类型指定为 <code>private</code> 级别，那么该类型的所有成员的默认访问级别也会变成 <code>private</code>。如果你将类型指定为 <code>public</code> 或者 <code>internal</code> 级别（或者不明确指定访问级别，而使用默认的 <code>internal</code> 访问级别），那么该类型的所有成员的默认访问级别将是 <code>internal</code>。</p>
<blockquote>
<p>注意<br>上面提到，一个 <code>public</code> 类型的所有成员的访问级别默认为 <code>internal</code> 级别，而不是 <code>public</code> 级别。如果你想将某个成员指定为 <code>public</code> 级别，那么你必须显式指定。这样做的好处是，在你定义公共接口的时候，可以明确地选择哪些接口是需要公开的，哪些是内部使用的，避免不小心将内部使用的接口公开。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SomePublicClass</span> </span>&#123;          <span class="comment">// 显式的 public 类</span></span><br><span class="line">   	public <span class="keyword">var</span> somePublicProperty = <span class="number">0</span>   <span class="comment">// 显式的 public 类成员</span></span><br><span class="line">   	<span class="keyword">var</span> someInternalProperty = <span class="number">0</span>        <span class="comment">// 隐式的 internal 类成员</span></span><br><span class="line">   	private <span class="func"><span class="keyword">func</span> <span class="title">somePrivateMethod</span><span class="params">()</span></span> &#123;&#125; <span class="comment">// 显式的 private 类成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeInternalClass</span> </span>&#123;               <span class="comment">// 隐式的 internal 类</span></span><br><span class="line">   	<span class="keyword">var</span> someInternalProperty = <span class="number">0</span>        <span class="comment">// 隐式的 internal 类成员</span></span><br><span class="line">   	private <span class="func"><span class="keyword">func</span> <span class="title">somePrivateMethod</span><span class="params">()</span></span> &#123;&#125; <span class="comment">// 显式的 private 类成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private <span class="class"><span class="keyword">class</span> <span class="title">SomePrivateClass</span> </span>&#123;        <span class="comment">// 显式的 private 类</span></span><br><span class="line">   	<span class="keyword">var</span> somePrivateProperty = <span class="number">0</span>         <span class="comment">// 隐式的 private 类成员</span></span><br><span class="line">   	<span class="func"><span class="keyword">func</span> <span class="title">somePrivateMethod</span><span class="params">()</span></span> &#123;&#125;         <span class="comment">// 隐式的 private 类成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="tuple_types"></a></p>
<h3 id="元组类型">元组类型</h3><p>元组的访问级别将由元组中访问级别最严格的类型来决定。例如，如果你构建了一个包含两种不同类型的元组，其中一个类型为 <code>internal</code> 级别，另一个类型为 <code>private</code> 级别，那么这个元组的访问级别为 <code>private</code>。</p>
<blockquote>
<p>注意<br>元组不同于类、结构体、枚举、函数那样有单独的定义。元组的访问级别是在它被使用时自动推断出的，而无法明确指定。</p>
</blockquote>
<p><a name="function_types"></a></p>
<h3 id="函数类型">函数类型</h3><p>函数的访问级别根据访问级别最严格的参数类型或返回类型的访问级别来决定。但是，如果这种访问级别不符合函数定义所在环境的默认访问级别，那么就需要明确地指定该函数的访问级别。</p>
<p>下面的例子定义了一个名为 <code>someFunction</code> 的全局函数，并且没有明确地指定其访问级别。也许你会认为该函数应该拥有默认的访问级别 <code>internal</code>，但事实并非如此。事实上，如果按下面这种写法，代码将无法通过编译：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">()</span></span> -&gt; (<span class="type">SomeInternalClass</span>, <span class="type">SomePrivateClass</span>) &#123;</span><br><span class="line">   	<span class="comment">// 此处是函数实现部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，这个函数的返回类型是一个元组，该元组中包含两个自定义的类（可查阅<a href="#custom_types">自定义类型</a>）。其中一个类的访问级别是 <code>internal</code>，另一个的访问级别是 <code>private</code>，所以根据元组访问级别的原则，该元组的访问级别是 <code>private</code>（元组的访问级别与元组中访问级别最低的类型一致）。</p>
<p>因为该函数返回类型的访问级别是 <code>private</code>，所以你必须使用 <code>private</code> 修饰符，明确指定该函数的访问级别：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private <span class="func"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">()</span></span> -&gt; (<span class="type">SomeInternalClass</span>, <span class="type">SomePrivateClass</span>) &#123;</span><br><span class="line">   	<span class="comment">// 此处是函数实现部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将该函数指定为 <code>public</code> 或 <code>internal</code>，或者使用默认的访问级别 <code>internal</code> 都是错误的，因为如果把该函数当做 <code>public</code> 或 <code>internal</code> 级别来使用的话，可能会无法访问 <code>private</code> 级别的返回值。</p>
<p><a name="enumeration_types"></a></p>
<h3 id="枚举类型">枚举类型</h3><p>枚举成员的访问级别和该枚举类型相同，你不能为枚举成员单独指定不同的访问级别。</p>
<p>比如下面的例子，枚举 <code>CompassPoint</code> 被明确指定为 <code>public</code> 级别，那么它的成员 <code>North</code>、<code>South</code>、<code>East</code>、<code>West</code> 的访问级别同样也是 <code>public</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">enum</span> <span class="title">CompassPoint</span> </span>&#123;</span><br><span class="line">   	<span class="keyword">case</span> <span class="type">North</span></span><br><span class="line">   	<span class="keyword">case</span> <span class="type">South</span></span><br><span class="line">   	<span class="keyword">case</span> <span class="type">East</span></span><br><span class="line">   	<span class="keyword">case</span> <span class="type">West</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="raw_values_and_associated_values"></a></p>
<h4 id="原始值和关联值">原始值和关联值</h4><p>枚举定义中的任何原始值或关联值的类型的访问级别至少不能低于枚举类型的访问级别。例如，你不能在一个 <code>internal</code> 访问级别的枚举中定义 <code>private</code> 级别的原始值类型。</p>
<p><a name="nested_types"></a></p>
<h3 id="嵌套类型">嵌套类型</h3><p>如果在 <code>private</code> 级别的类型中定义嵌套类型，那么该嵌套类型就自动拥有 <code>private</code> 访问级别。如果在 <code>public</code> 或者 <code>internal</code> 级别的类型中定义嵌套类型，那么该嵌套类型自动拥有 <code>internal</code> 访问级别。如果想让嵌套类型拥有 <code>public</code> 访问级别，那么需要明确指定该嵌套类型的访问级别。</p>
<p><a name="subclassing"></a></p>
<h2 id="子类">子类</h2><p>子类的访问级别不得高于父类的访问级别。例如，父类的访问级别是 <code>internal</code>，子类的访问级别就不能是 <code>public</code>。</p>
<p>此外，你可以在符合当前访问级别的条件下重写任意类成员（方法、属性、构造器、下标等）。</p>
<p>可以通过重写为继承来的类成员提供更高的访问级别。下面的例子中，类 <code>A</code> 的访问级别是 <code>public</code>，它包含一个方法 <code>someMethod()</code>，访问级别为 <code>private</code>。类 <code>B</code> 继承自类 <code>A</code>，访问级别为 <code>internal</code>，但是在类 <code>B</code> 中重写了类 <code>A</code> 中访问级别为 <code>private</code> 的方法 <code>someMethod()</code>，并重新指定为 <code>internal</code> 级别。通过这种方式，我们就可以将某类中 <code>private</code> 级别的类成员重新指定为更高的访问级别，以便其他人使用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">   	private <span class="func"><span class="keyword">func</span> <span class="title">someMethod</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">internal <span class="class"><span class="keyword">class</span> <span class="title">B</span>: <span class="title">A</span> </span>&#123;</span><br><span class="line">   	<span class="keyword">override</span> internal <span class="func"><span class="keyword">func</span> <span class="title">someMethod</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们甚至可以在子类中，用子类成员去访问访问级别更低的父类成员，只要这一操作在相应访问级别的限制范围内（也就是说，在同一源文件中访问父类 <code>private</code> 级别的成员，在同一模块内访问父类 <code>internal</code> 级别的成员）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    private <span class="func"><span class="keyword">func</span> <span class="title">someMethod</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">internal <span class="class"><span class="keyword">class</span> <span class="title">B</span>: <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> internal <span class="func"><span class="keyword">func</span> <span class="title">someMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.someMethod()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为父类 <code>A</code> 和子类 <code>B</code> 定义在同一个源文件中，所以在子类 <code>B</code> 可以在重写的 <code>someMethod()</code> 方法中调用 <code>super.someMethod()</code>。</p>
<p><a name="constants_variables_properties_subscripts"></a></p>
<h2 id="常量、变量、属性、下标">常量、变量、属性、下标</h2><p>常量、变量、属性不能拥有比它们的类型更高的访问级别。例如，你不能定义一个 <code>public</code> 级别的属性，但是它的类型却是 <code>private</code> 级别的。同样，下标也不能拥有比索引类型或返回类型更高的访问级别。  </p>
<p>如果常量、变量、属性、下标的类型是 <code>private</code> 级别的，那么它们必须明确指定访问级别为 <code>private</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">var</span> privateInstance = <span class="type">SomePrivateClass</span>()</span><br></pre></td></tr></table></figure>
<p><a name="getters_and_setters"></a></p>
<h3 id="Getter_和_Setter">Getter 和 Setter</h3><p>常量、变量、属性、下标的 <code>Getters</code> 和 <code>Setters</code> 的访问级别和它们所属类型的访问级别相同。</p>
<p><code>Setter</code> 的访问级别可以低于对应的 <code>Getter</code> 的访问级别，这样就可以控制变量、属性或下标的读写权限。在 <code>var</code> 或 <code>subscript</code> 关键字之前，你可以通过 <code>private(set)</code> 或 <code>internal(set)</code> 为它们的写入权限指定更低的访问级别。</p>
<blockquote>
<p>注意<br>这个规则同时适用于存储型属性和计算型属性。即使你不明确指定存储型属性的 <code>Getter</code> 和 <code>Setter</code>，Swift 也会隐式地为其创建 <code>Getter</code> 和 <code>Setter</code>，用于访问该属性的后备存储。使用 <code>private(set)</code> 和 <code>internal(set)</code> 可以改变 <code>Setter</code> 的访问级别，这对计算型属性也同样适用。  </p>
</blockquote>
<p>下面的例子中定义了一个名为 <code>TrackedString</code> 的结构体，它记录了 <code>value</code> 属性被修改的次数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrackedString</span> </span>&#123;</span><br><span class="line">    private(<span class="keyword">set</span>) <span class="keyword">var</span> numberOfEdits = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> value: <span class="type">String</span> = <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            numberOfEdits++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TrackedString</code> 结构体定义了一个用于存储 <code>String</code> 值的属性 <code>value</code>，并将初始值设为 <code>&quot;&quot;</code>（一个空字符串）。该结构体还定义了另一个用于存储 <code>Int</code> 值的属性 <code>numberOfEdits</code>，它用于记录属性 <code>value</code> 被修改的次数。这个功能通过属性 <code>value</code> 的 <code>didSet</code> 观察器实现，每当给 <code>value</code> 赋新值时就会调用 <code>didSet</code> 方法，然后将 <code>numberOfEdits</code> 的值加一。</p>
<p>结构体 <code>TrackedString</code> 和它的属性 <code>value</code> 均没有显式指定访问级别，所以它们都拥有默认的访问级别 <code>internal</code>。但是该结构体的 <code>numberOfEdits</code> 属性使用了 <code>private(set)</code> 修饰符，这意味着 <code>numberOfEdits</code> 属性只能在定义该结构体的源文件中赋值。<code>numberOfEdits</code> 属性的 <code>Getter</code> 依然是默认的访问级别 <code>internal</code>，但是 <code>Setter</code> 的访问级别是 <code>private</code>，这表示该属性只有在当前的源文件中是可读写的，而在当前源文件所属的模块中只是一个可读的属性。  </p>
<p>如果你实例化 <code>TrackedString</code> 结构体，并多次对 <code>value</code> 属性的值进行修改，你就会看到 <code>numberOfEdits</code> 的值会随着修改次数而变化：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringToEdit = <span class="type">TrackedString</span>()</span><br><span class="line">stringToEdit.value = <span class="string">"This string will be tracked."</span></span><br><span class="line">stringToEdit.value += <span class="string">" This edit will increment numberOfEdits."</span></span><br><span class="line">stringToEdit.value += <span class="string">" So will this one."</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The number of edits is <span class="subst">\(stringToEdit.numberOfEdits)</span>"</span>)</span><br><span class="line"><span class="comment">// 打印 “The number of edits is 3”</span></span><br></pre></td></tr></table></figure>
<p>虽然你可以在其他的源文件中实例化该结构体并且获取到 <code>numberOfEdits</code> 属性的值，但是你不能对其进行赋值。这一限制保护了该记录功能的实现细节，同时还提供了方便的访问方式。</p>
<p>你可以在必要时为 <code>Getter</code> 和 <code>Setter</code> 显式指定访问级别。下面的例子将 <code>TrackedString</code> 结构体明确指定为了 <code>public</code> 访问级别。结构体的成员（包括 <code>numberOfEdits</code> 属性）拥有默认的访问级别 <code>internal</code>。你可以结合 <code>public</code> 和 <code>private(set)</code> 修饰符把结构体中的 <code>numberOfEdits</code> 属性的 <code>Getter</code> 的访问级别设置为 <code>public</code>，而 <code>Setter</code> 的访问级别设置为 <code>private</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">struct</span> <span class="title">TrackedString</span> </span>&#123;</span><br><span class="line">    public private(<span class="keyword">set</span>) <span class="keyword">var</span> numberOfEdits = <span class="number">0</span></span><br><span class="line">    public <span class="keyword">var</span> value: <span class="type">String</span> = <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            numberOfEdits++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="initializers"></a></p>
<h2 id="构造器">构造器</h2><p>自定义构造器的访问级别可以低于或等于其所属类型的访问级别。唯一的例外是<a href="./14_Initialization.html#required_initializers">必要构造器</a>，它的访问级别必须和所属类型的访问级别相同。</p>
<p>如同函数或方法的参数，构造器参数的访问级别也不能低于构造器本身的访问级别。</p>
<p><a name="default_initializers"></a></p>
<h3 id="默认构造器">默认构造器</h3><p>如<a href="./14_Initialization.html#default_initializers">默认构造器</a>所述，Swift 会为结构体和类提供一个默认的无参数的构造器，只要它们为所有存储型属性设置了默认初始值，并且未提供自定义的构造器。</p>
<p>默认构造器的访问级别与所属类型的访问级别相同，除非类型的访问级别是 <code>public</code>。如果一个类型被指定为 <code>public</code> 级别，那么默认构造器的访问级别将为 <code>internal</code>。如果你希望一个 <code>public</code> 级别的类型也能在其他模块中使用这种无参数的默认构造器，你只能自己提供一个 <code>public</code> 访问级别的无参数构造器。</p>
<p><a name="default_memberwise_initializers_for_structure_types"></a></p>
<h3 id="结构体默认的成员逐一构造器">结构体默认的成员逐一构造器</h3><p>如果结构体中任意存储型属性的访问级别为 <code>private</code>，那么该结构体默认的成员逐一构造器的访问级别就是 <code>private</code>。否则，这种构造器的访问级别依然是 <code>internal</code>。</p>
<p>如同前面提到的默认构造器，如果你希望一个 <code>public</code> 级别的结构体也能在其他模块中使用其默认的成员逐一构造器，你依然只能自己提供一个 <code>public</code> 访问级别的成员逐一构造器。</p>
<p><a name="protocols"></a></p>
<h2 id="协议">协议</h2><p>如果想为一个协议类型明确地指定访问级别，在定义协议时指定即可。这将限制该协议只能在适当的访问级别范围内被采纳。</p>
<p>协议中的每一个要求都具有和该协议相同的访问级别。你不能将协议中的要求设置为其他访问级别。这样才能确保该协议的所有要求对于任意采纳者都将可用。</p>
<blockquote>
<p>注意<br>如果你定义了一个 <code>public</code> 访问级别的协议，那么该协议的所有实现也会是 <code>public</code> 访问级别。这一点不同于其他类型，例如，当类型是 <code>public</code> 访问级别时，其成员的访问级别却只是 <code>internal</code>。</p>
</blockquote>
<p><a name="protocol_inheritance"></a></p>
<h3 id="协议继承">协议继承</h3><p>如果定义了一个继承自其他协议的新协议，那么新协议拥有的访问级别最高也只能和被继承协议的访问级别相同。例如，你不能将继承自 <code>internal</code> 协议的新协议定义为 <code>public</code> 协议。</p>
<p><a name="protocol_conformance"></a></p>
<h3 id="协议一致性">协议一致性</h3><p>一个类型可以采纳比自身访问级别低的协议。例如，你可以定义一个 <code>public</code> 级别的类型，它可以在其他模块中使用，同时它也可以采纳一个 <code>internal</code> 级别的协议，但是只能在该协议所在的模块中作为符合该协议的类型使用。</p>
<p>采纳了协议的类型的访问级别取它本身和所采纳协议两者间最低的访问级别。也就是说如果一个类型是 <code>public</code> 级别，采纳的协议是 <code>internal</code> 级别，那么采纳了这个协议后，该类型作为符合协议的类型时，其访问级别也是 <code>internal</code>。</p>
<p>如果你采纳了协议，那么实现了协议的所有要求后，你必须确保这些实现的访问级别不能低于协议的访问级别。例如，一个 <code>public</code> 级别的类型，采纳了 <code>internal</code> 级别的协议，那么协议的实现至少也得是 <code>internal</code> 级别。</p>
<blockquote>
<p>注意<br>Swift 和 Objective-C 一样，协议的一致性是全局的，也就是说，在同一程序中，一个类型不可能用两种不同的方式实现同一个协议。</p>
</blockquote>
<p><a name="extensions"></a></p>
<h2 id="扩展">扩展</h2><p>你可以在访问级别允许的情况下对类、结构体、枚举进行扩展。扩展成员具有和原始类型成员一致的访问级别。例如，你扩展了一个 <code>public</code> 或者 <code>internal</code> 类型，扩展中的成员具有默认的 <code>internal</code> 访问级别，和原始类型中的成员一致 。如果你扩展了一个 <code>private</code> 类型，扩展成员则拥有默认的 <code>private</code> 访问级别。</p>
<p>或者，你可以明确指定扩展的访问级别（例如，<code>private extension</code>），从而给该扩展中的所有成员指定一个新的默认访问级别。这个新的默认访问级别仍然可以被单独指定的访问级别所覆盖。</p>
<p><a name="adding_protocol_conformance_with_an_extension"></a></p>
<h3 id="通过扩展添加协议一致性">通过扩展添加协议一致性</h3><p>如果你通过扩展来采纳协议，那么你就不能显式指定该扩展的访问级别了。协议拥有相应的访问级别，并会为该扩展中所有协议要求的实现提供默认的访问级别。</p>
<p><a name="generics"></a></p>
<h2 id="泛型">泛型</h2><p>泛型类型或泛型函数的访问级别取决于泛型类型或泛型函数本身的访问级别，还需结合类型参数的类型约束的访问级别，根据这些访问级别中的最低访问级别来确定。</p>
<p><a name="type_aliases"></a></p>
<h2 id="类型别名">类型别名</h2><p>你定义的任何类型别名都会被当作不同的类型，以便于进行访问控制。类型别名的访问级别不可高于其表示的类型的访问级别。例如，<code>private</code> 级别的类型别名可以作为 <code>public</code>、<code>internal</code>、<code>private</code> 类型的别名，但是 <code>public</code> 级别的类型别名只能作为 <code>public</code> 类型的别名，不能作为 <code>internal</code> 或 <code>private</code> 类型的别名。</p>
<blockquote>
<p>注意<br>这条规则也适用于为满足协议一致性而将类型别名用于关联类型的情况。</p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/">&laquo;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/7/">&raquo;</a>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="https://avatars2.githubusercontent.com/u/14305708?v=3&s=460" alt="terry" itemprop="image"/>
          <p class="site-author-name" itemprop="name">terry</p>
        </div>
        <p class="site-description motion-element" itemprop="description">terry yang's blog | java | scala | bi</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">135</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">11</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-next-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yangwei8888" target="_blank">github</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/microsoftgoogles" target="_blank">weibo</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/run-zhi-38" target="_blank">zhihu</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">terry</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  

    <script type="text/javascript">
      var disqus_shortname = 'yangwei888';
      var disqus_identifier = 'page/6/index.html';
      var disqus_title = '';
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
