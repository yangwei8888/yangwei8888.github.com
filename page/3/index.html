<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="terry yang's blog | java | scala | bi" />



  <meta name="keywords" content="Hexo,next" />



  <link rel="alternate" href="/atom.xml" title="yosita" type="application/atom+xml" />



  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="terry yang&apos;s blog | java | scala | bi">
<meta property="og:type" content="website">
<meta property="og:title" content="yosita">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="yosita">
<meta property="og:description" content="terry yang&apos;s blog | java | scala | bi">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="yosita">
<meta name="twitter:description" content="terry yang&apos;s blog | java | scala | bi">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>

  <title> yosita </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  

  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?7e8961fdae021b7bf62f2c767bb18c23";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">yosita</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/03Working with Cocoa Data Types/" itemprop="url">
                02Interoperability-03与 Cocoa 数据类型共舞
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-26T22:00:08+08:00" content="2015-12-26">
            2015-12-26
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Using-Swift-with-Cocoa-and-Objective-C/" itemprop="url" rel="index">
                  <span itemprop="name">Using-Swift-with-Cocoa-and-Objective-C</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/03Working with Cocoa Data Types/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/03Working with Cocoa Data Types/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><blockquote>
<p>翻译：<a href="https://github.com/wongzigii" target="_blank" rel="external">wongzigii</a>、<a href="https://github.com/SemperIdem" target="_blank" rel="external">星夜暮晨</a></p>
<p>校对：<a href="https://github.com/dabing1022" target="_blank" rel="external">ChildhoodAndy</a></p>
</blockquote>
<h2 id="#与_Cocoa_数据类型共舞">#与 Cocoa 数据类型共舞</h2><p>本节内容包括：</p>
<ul>
<li><a href="#strings">字符串（Strings）</a></li>
<li><a href="#numbers">数值（Numbers）</a></li>
<li><a href="#collection_classes">集合类（Collection Classes）</a></li>
<li><a href="#errors">错误（Errors）</a></li>
<li><a href="#foundation_data_types">Foundation数据类型（Foundation Data Types）</a></li>
<li><a href="#foundation_functions">Foundation函数（Foundation Functions）</a></li>
<li><a href="#core_foundation">Core Foundation</a></li>
</ul>
<p>作为对 Objective-C 互用性（互操作性）的一部分，Swift提供快捷高效的方式来处理 Cocoa 数据类型。</p>
<p>Swift 会自动将一些 Objective-C 类型转换为 Swift 类型，以及将 Swift 类型转换为 Objective-C 类型。在 Objective-C 和 Swift 中也有一些具有互用性的数据类型。那些可转换的数据类型或者具有互用性的数据类型被称为<em>bridged</em>数据类型。举个例子，在 Swift 中，我们可以将一个<code>Array</code>值传递给一个要求为<code>NSArray</code>对象的方法。我们也可以转换一个 bridged 类型和它的副本。当我们使用<code>as</code>转换 bridged 类型或者那些由常量和变量所提供的类型时，Swift 会桥接它们的数据类型。</p>
<p>Swift 也提供一种简单便捷的覆盖方法来连接 Foundation 的数据类型，在后面的 Swift 语言中，我们能在它的句法中感受到自然和统一。</p>
<p><a name="strings"></a></p>
<p>##字符串</p>
<p>Swift会在<code>String</code>类型和<code>NSString</code>类型中自动转换。这意味着在可以使用<code>NSString</code>对象的地方，我们可以使用一个属于 Swift 的<code>String</code>类型代替它，这样做会同时拥有它们数据类型的特点，比如说<code>String</code>类型的字符串插值，基于Swift设计的API，以及<code>NSString</code>类的多种功能。因此，我们几乎不必再在我们的代码中使用<code>NSString</code>类。事实上，当 Swift 接入 Objective-C API 时，它将把所有<code>NSString</code>类型替换为<code>String</code>类型。当我们在我们的Objective-C代码中使用 Swift 类时，接入的API会将所有<code>String</code>类型替换成<code>NSString</code>类型。</p>
<p>为了允许字符串转换，只需导入Foundation框架。举个例子，我们在 Swift的一个字符串中可以访问<code>capitalizedString</code>，这是<code>NSString</code>类的一个属性，然后 Swift 会自动将<code>String</code>转换为一个<code>NSString</code>对象来访问这个属性。这个属性甚至会返回一个 Swift的<code>String</code>类型，因为它在导入的时候被替换了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">let</span> greeting = <span class="string">"hello, world!"</span></span><br><span class="line"><span class="keyword">let</span> capitalizedGreeting = greeting.capitalizedString</span><br><span class="line"><span class="comment">// capitalizedGreeting: String = Hello, World!</span></span><br></pre></td></tr></table></figure>
<p>如果我们确实需要用到一个<code>NSString</code>对象，我们可以用一个 Swift 的<code>String</code>值并转换它。<code>String</code>类型总是可以从一个<code>NSString</code>对象转换为一个Swift的<code>String</code>的值，因此，再没有必要去使用一个可选的类型转换器(<code>as?</code>)。我们也可以在一个字符串中通过定义常量和变量来创建一个<code>NSString</code>对象。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">let</span> myString: <span class="type">NSString</span> = <span class="string">"123"</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> integerValue = <span class="type">Int</span>(myString <span class="keyword">as</span> <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(myString)</span> is the integer <span class="subst">\(integerValue)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// prints "123 is the integer 123"</span></span><br></pre></td></tr></table></figure>
<p>###本地化<br>在Objective-C中，常用<code>NSLocalizedString</code>类的宏来定位一个字符串。这集合的宏包括<code>NSLocalizedString</code>，<code>NSLocalizedStringFromTable</code>，<code>NSLocalizedStringFromTableInBundle</code>，和<code>NSLocalizedStringWithDefaultValue</code>。而在Swift中，只用一个函数就可以实现跟整个<code>NSLocalizedString</code>集一样的功能，即<code>NSLocalizedString(key:tableName:bundle:value:comment:)</code>。这个<code>NSLocalizedString</code>函数分别为<code>tableName</code>，<code>bundle</code>和<code>value</code>参数提供了一个默认值。我们可以用它来替换宏。</p>
<p><a name="numbers"></a></p>
<p>##数值</p>
<p>Swift会自动将已确定的数值类型<code>Int</code>和<code>Float</code>转换为<code>NSNumber</code>。这样的转换允许我们基于其中一种类型创建一个<code>NSNumber</code>：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let <span class="keyword">n</span> = 42</span><br><span class="line">let <span class="keyword">m</span>: NSNumber = <span class="keyword">n</span></span><br></pre></td></tr></table></figure>
<p>我们也能传递一个<code>Int</code>类型的值，比如传递给一个要求为<code>NSNumber</code>类型的参数。同时需要注意的是，<code>NSNumber</code>可以包含多种不同的类型，因此我们不能把它传递给单一的一个<code>Int</code>值。</p>
<p>下面所列出的类型都会自动转换为<code>NSNumber</code>：</p>
<ul>
<li><code>Int</code></li>
<li><code>UInt</code></li>
<li><code>Float</code></li>
<li><code>Double</code></li>
<li><code>Bool</code></li>
</ul>
<p><a name="collection_classes"></a></p>
<p>##集合类</p>
<p>Swift 会自动将<code>NSArray</code>、<code>NSSet</code>和<code>NSDictionary</code>类转换为Swift里等价的类：<code>Array</code>、<code>Set</code>和<code>Dictionary</code>。这意味着我们将受益于Swift强大的算法和得天独厚的语法来处理集合–可互相转换的 Foundation 和 Swift 集合类型。</p>
<p>###数组(Arrays)</p>
<p>Swift 会在<code>Array</code>类型和<code>NSArray</code>类型中自动转换。当我们从一个 Swift 数组转换成一个<code>NSArray</code>对象后，转换后的结果则是一个<code>[ObjectType]</code>类型的数组。如果<code>NSArray</code>对象没有指明一个确切的参数类型，那么它将会转换成<code>[AnyObject]</code>类型的Swift数组。</p>
<p>比如说，我们看到以下Objective-C声明：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSDate</span> *&gt;* dates;</span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">NSDate</span> *&gt; *)datesBeforeDate:(<span class="built_in">NSDate</span> *)date;</span><br><span class="line">- (<span class="keyword">void</span>)addDatesParsedFromTimestamps:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)timestamps;</span><br></pre></td></tr></table></figure>
<p>那么，转换为Swift，则是这样子的：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dates: [<span class="type">NSDate</span>]</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">datesBeforeDate</span><span class="params">(date: NSDate)</span></span> -&gt; [<span class="type">NSDate</span>]</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">addDatesParsedFromTimestamps</span><span class="params">(timestamps: [String])</span></span></span><br></pre></td></tr></table></figure></p>
<p>如果某个对象是 Objective-C 或者 Swift 类的实例，或者这个对象可以转换成另一种类型，那么这个对象则属于<code>AnyObject</code>类型的对象。我们可以将任一<code>NSArray</code>对象转换成一个 Swift 数组，因为所有 Objective-C 的对象都是<code>AnyObject</code>类型的。正因如此，Swift 的编译器会在接入 Objective-C APIs 的时候将<code>NSArray</code>类替换成<code>AnyObject[]</code>。</p>
<p>当我们将一个<code>NSArray</code>对象转换成一个 Swift 数组后，我们也可以将数组强制类型转换成一个特定的类型。与从<code>NSArray</code>类转换到<code>AnyObject[]</code>不同的是，从<code>AnyObject</code>类型的对象转换成明确的类型并不会保证成功。由于直到运行时编译器才知道<code>AnyObject</code>的对象能否被强制转换为特定的类型，因此，从<code>AnyObject[]</code>转换为<code>SomeType[]</code>会返回一个 optional 的值。举个例子，如果我们知道一个Swift数组只包含<code>UIView</code>类的实例(或者一个<code>UIView</code>类的子类)，我们可以将<code>AnyObject</code>类型的数组元素强制转换为<code>UIView</code>对象。如果Swift数组中的元素在运行时不是<code>UIView</code>类型的对象，那么转换则会返回<code>nil</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> swiftyArray = foundationArray <span class="keyword">as</span> <span class="type">AnyObject</span>[]</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> downcastedSwiftArray = swiftArray <span class="keyword">as</span>? <span class="type">UIView</span>[] &#123;</span><br><span class="line">    <span class="comment">// downcastedSwiftArray contains only UIView objects</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以在for循环中将NSArray对象定向地强制转换为特定类型的Swift数组:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> aView: <span class="type">UIView</span>! <span class="keyword">in</span> foundationArray &#123;</span><br><span class="line">     <span class="comment">// aView is of type UIView</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这种转换是强制转换，如果转换不成功则会在运行时产生错误信息。</p>
</blockquote>
<p>当我们从 Swift 数组转换为<code>NSArray</code>对象时，Swift 数组里的元素必须是属于<code>AnyObject</code>的。例如，一个<code>Int[]</code>类型的 Swift 数组包含<code>Int</code>结构的元素。<code>Int</code>类型并不是一个类的实例，但由于<code>Int</code>类型转换成了<code>NSNumber</code>类，<code>Int</code>类型属于<code>AnyObject</code>类型的。因此，我们可以将一个<code>Int[]</code>类型的Swift数组转换为<code>NSArray</code>对象。如果 Swift 数组里的一个元素不属于<code>AnyObject</code>类型，那么在运行时就会产生错误。</p>
<p>我们也可以从 Swift 数组中创建一个<code>NSArray</code>对象。当我们将一个常量或变量定义为一个<code>NSArray</code>对象并分配一个数组给它作为实例变量时，Swift 将会创建 <code>NSArray</code>对象，而不是 Swift 数组。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> schoolSupplies: <span class="type">NSArray</span> = [<span class="string">"Pencil"</span>, <span class="string">"Eraser"</span>, <span class="string">"Notebkko"</span>]</span><br><span class="line"><span class="comment">// schoolSupplies is an NSArray object containing NSString objects</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，Swift 数组包含包含三个<code>String</code>字符串。由于从<code>String</code>类型转换为<code>NSString</code>类，数组字面量被转换成一个<code>NSArray</code>对象，并成功分配给<code>schoolSupplies</code>变量。</p>
<p>当我们在 Objective-C 代码中使用 Swift 类或者协议时，接入的API会将全部所有类型的Swift数组代替为<code>NSArray</code>。若我们将一个<code>NSArray</code>对象传递给Swift的API并要求数组元素为一个新的类型，运行时就会产生错误。如果 Swift API 返回一个不能被转换为<code>NSArray</code>类型的 Swift 数组，错误也会随之产生。</p>
<p>###集合(Sets)</p>
<p>除了数组以外，Swift还会自动在<code>Set</code>类型和<code>NSSet</code>类之间进行转换。当我们将一个带有参数类型的<code>NSSet</code>对象转换为Swift集合之后，得到的结果是<code>Set&lt;ObjectType&gt;</code>类型的集合。而如果<code>NSSet</code>对象没有指明其参数类型，那么它将会转换为<code>Set&lt;AnyObject&gt;</code>类型的Swift集合。</p>
<p>比如说，我们看到以下Objective-C声明：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt;* words;</span><br><span class="line">- (<span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt; *)wordsMatchingPredicate:(<span class="built_in">NSPredicate</span> *)predicate;</span><br><span class="line">- (<span class="keyword">void</span>)removeWords:(<span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt; *)words;</span><br></pre></td></tr></table></figure>
<p>那么，转换为Swift，则是这个样子的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> words: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">wordsMatchingPredicate</span><span class="params">(predicate: NSPredicate)</span></span> -&gt; <span class="type">Set</span>&lt;<span class="type">String</span>&gt;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">removeWords</span><span class="params">(words: Set&lt;String&gt;)</span></span></span><br></pre></td></tr></table></figure>
<p>我们能够将所有<code>NSSet</code>对象转换为Swift集合，因为所有的Objective-C对象都可以被转换为<code>AnyObject</code>。所有的<code>NSSet</code>对象都能够转换为Swift对象，因此Swift编译器将会在导入Objective-C API的时候，将所有的<code>NSSet</code>类转换为<code>Set&lt;AnyObject&gt;</code>。同理，当我们在Objective-C中使用Swift类或者协议的时候，导入器将会将Swift集合重新映射为Objective-C兼容的类型：<code>NSSet</code>对象。</p>
<p>当我们将<code>NSSet</code>对象转换为Swift集合后，还可以将集合下转为其他指定类型。就如同Swift数组的下转一样，Swift集合的下转不确保一定成功。对<code>Set&lt;AnyObject&gt;</code>下转为指定类型的结果需要使用<code>as?</code>操作符，以确保其是可选值。</p>
<p>我们仍然可以直接从Swift数组字面量中直接创建一个<code>NSSet</code>对象，它同样遵循上面提到的转换规则。当我们明确地将某个常量或者变量定义为<code>NSSet</code>对象，并且使用一个数组字面量来赋值的时候，Swift将会创建一个<code>NSSet</code>对象，而不是Swift集合。</p>
<p>###字典(Dictionaries)</p>
<p>Swift同样可以在<code>Dictionary</code>和<code>NSDictionary</code>类当中自动转换。当我们将带有参数类型的<code>NSDictionary</code>对象转换为Swift字典之后，得到的结果是一个<code>[ObjectType]</code>类型的字典。如果<code>NSDictionary</code>对象没有指明参数类型，那么它将会被转换为<code>[NSObject:AnyObject]</code>类型的Swift字典。</p>
<p>比如说，我们看到以下Objective-C声明：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSURL</span> *, <span class="built_in">NSData</span> *&gt;* cachedData;</span><br><span class="line">- (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSURL</span> *, <span class="built_in">NSNumber</span> *&gt; *)fileSizesForURLsWithSuffix:(<span class="built_in">NSString</span> *)suffix;</span><br><span class="line">- (<span class="keyword">void</span>)setCacheExpirations:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSURL</span> *, <span class="built_in">NSDate</span> *&gt; *)expirations;</span><br></pre></td></tr></table></figure>
<p>那么，转换为Swift，则是这个样子的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cachedData: [<span class="type">NSURL</span>: <span class="type">NSData</span>]</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">fileSizesForURLsWithSuffix</span><span class="params">(suffix: String)</span></span> -&gt; [<span class="type">NSURL</span>: <span class="type">NSNumber</span>]</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">setCacheExpirations</span><span class="params">(expirations: [NSURL: NSDate])</span></span></span><br></pre></td></tr></table></figure>
<p>我们能够将所有的<code>NSDictionary</code>对象转换为Swift字典，因为所有的Objective-C对象都兼容<code>AnyObject</code>。重申一下，某个对象能够“兼容”<code>AnyObject</code>，指的是其是Objective-C的一个实例，或者是Swift的类，亦或者是能够转换为这两者之一的东西。所有的<code>NSDictionary</code>对象都能够转换为Swift字典，因此Swift编译器会在导入Objective-C API的时候，将所有的<code>NSDictionary</code>类替换成<code>[NSObject: AnyObject]</code>。同理，当我们在Objective-C中使用Swift类或者协议的时候，导入器将会将Swift字典重新映射为Objective-C兼容的类型：<code>NSDictionary</code>对象。</p>
<p>当我们将<code>NSDictionary</code>对象转换为Swift字典后，还可以将字典<em>下转</em>为其他指定类型。就如同Swift数组的下转一样，Swift字典的下转不确保一定成功。对<code>[NSObject: AnyObject]</code>下转为指定类型的结果需要使用<code>as?</code>操作符，以确保其是可选值。</p>
<p>当我们进行反向转换，也就是将Swift字典转换为<code>NSDictionary</code>对象的过程中，其键值都必须是某个类的实例，或者能够被转换为某个类的实例。</p>
<p>我们仍然可以直接从Swift数组字面量中直接创建一个<code>NSDictionary</code>对象，它同样遵循上面提到的转换规则。当我们明确地将某个常量或者变量定义为<code>NSDictionary</code>对象，并且使用一个数组字面量来赋值的时候，Swift将会创建一个<code>NSDictionary</code>对象，而不是Swift字典。</p>
<p><a name="errors"></a></p>
<p>##错误</p>
<p>Swift能够自动在<code>ErrorType</code>类型和<code>NSError</code>类之间转换，会发生错误的Objective-C方法等价于Swift中的<code>throw</code>方法，而会发生错误的Swift方法通过Objecitive-C错误约定，也等价于产生错误的Objective-C方法。</p>
<p>实现<code>ErrorType</code>协议，并且使用<code>@objc</code>特性声明的Swift枚举类型，会产生一个<code>NS_ENUM</code>声明和一个<code>NSString</code>常量，以能够在产生的头文件中设定对应的错误范围。比如说，有以下Swift枚举声明代码：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@objc</span> public <span class="class"><span class="keyword">enum</span> <span class="title">CustomError</span>: <span class="title">Int</span>, <span class="title">ErrorType</span> &#123;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="constant">A</span>, <span class="constant">B</span>, <span class="constant">C</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，在相应的生成头文件中的Objectivive-C声明就是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Project-Swift.h</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">SWIFT_ENUM</span><span class="params">(NSInteger, CustomError)</span> </span>&#123;</span><br><span class="line">  CustomErrorA = <span class="number">0</span>,</span><br><span class="line">  CustomErrorB = <span class="number">1</span>,</span><br><span class="line">  CustomErrorC = <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> NSString * <span class="keyword">const</span> CustomErrorDomain = @<span class="string">"Project.CustomError"</span>;</span><br></pre></td></tr></table></figure>
<p>关于更多Swift和Objective-C API中错误处理的相关信息，请参阅<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-ID10" target="_blank" rel="external">Error Handling</a>。</p>
<p><a name="foundation_data_types"></a></p>
<p>##Foundation数据类型<br>Swift 也提供一种简单便捷的覆盖方法来连接定义在 Foundation 框架中的数据类型。在<code>CGSize</code>和<code>CGPoint</code>中使用覆盖方法，我们就能在它的句法中感受到Swift语言的自然和统一。比如，我们可以使用如下语法创建一个<code>CGSize</code>类型的结构:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> size = <span class="type">CGSize</span>(width: <span class="number">20</span>, height: <span class="number">40</span>)</span><br></pre></td></tr></table></figure>
<p>覆盖方法也允许我们以一种自然的方式调用 Foundation 的结构函数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rect = <span class="type">CGRect</span>(x: <span class="number">50</span>, y: <span class="number">50</span>, width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line"><span class="keyword">let</span> width = rect.width    <span class="comment">// equivalent of CGRectGetWidth(rect)</span></span><br><span class="line"><span class="keyword">let</span> maxX = rect.maxY      <span class="comment">// equivalent of CGRectGetMaxY(rect)</span></span><br></pre></td></tr></table></figure>
<p>Swift可以将<code>NSUInteger</code>和<code>NSInteger</code>转换为<code>Int</code>类型。这些类型都会在 Foundation APIs 中变为<code>Int</code>类型。在 Swift 中<code>Int</code>常被尽可能地用以连贯性，同时当我们要求一个无符号整数类型时，<code>UInt</code>类型总是可使用的。</p>
<p><a name="foundation_functions"></a></p>
<p>##Foundation函数</p>
<p>在 Swift 中，<code>NSLog</code>可在系统控制台输出信息。我们可以像在 Objective-C 中使用过的语法格式那样使用此函数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSLog</span>(<span class="string">"%.7f"</span>, pi)</span><br><span class="line"><span class="comment">// Logs "3.1415927" to the console</span></span><br></pre></td></tr></table></figure>
<p>同时，Swift 也提供像<code>print(_:)</code>这样的输出函数。多亏于 Swift 的字符插值机制才让这些函数简单，粗暴，高效。这些函数不会在系统控制台输出信息，但在需要调用的时候却是可用的。</p>
<p>Swift 中不再存在<code>NSAssert</code>函数，取而代之的是<code>assert</code>函数。</p>
<p><a name="core_foundation"></a></p>
<p>##Core Foundation</p>
<p>Swift中的 Core Foundation 类型是一个成熟的类。当出现内存管理注释时，Swift 会自动地管理 Core Foundation 对象的内存，这其中包括我们实例化了的 Core Foundation 对象。在 Swift 中，我们可以自由变换 Fundation 和 Core Foundation 类型。如果我们想先转换为桥接 Foundation 类型时，那么也可以桥接一些 toll-free bridged Core Foundation 类型到 Swift 标准库类型。</p>
<p>###重映射类型(Remapped Types)</p>
<p>当 Swift 导入 Core Foundation 类型时，编译器会重映射导入的类型名字。编译器会从每个类型名字的末端移除 <em>Ref</em>，这是因为所有的 Swift 类都属于引用类型，因此后缀是多余的。</p>
<p>Core Foundation 中的<code>CFTypeRef</code>类型会对<code>Anyobject</code>类型重映射。所以我们以前使用的<code>CFTypeRef</code>，现在该换成<code>AnyObject</code>了。</p>
<p>###内存管理对象(Memory Managed Objects)</p>
<p>在 Swift 中，从 annotated APIs 返回的 Core Foundation 对象能够自动进行内存管理–我们不再需要调用自身的<code>CFRetain</code>，<code>CFRelease</code>，或者<code>CFAutorelease</code>函数。</p>
<p>如果我们从自身的C函数和 Objective-C 方法中返回一个 Core Foundation 对象，我们需要用<code>CF_RETURNS_RETAINED</code>或者<code>CF_RETURNS_NOT_RETAINED</code>注释这个对象。我们同样可以使用<code>CF_IMPLICIT_BRIDGING_ENABLED</code>和<code>CF_IMPLICIT_BRIDGING_DISABLED</code>宏命令来封装C函数声明，这些函数遵循Core Foundation的管理规定、命名规定，以便能够根据命名退导出内存管理机制能。</p>
<p>如果我们只调用那些不会间接返回 Core Foundation 对象的 annotated APIs，那么现在我们可以跳过本节的剩余部分了。否则，下面我们继续学习非托管的 Core Foundation 对象。</p>
<p>###非托管对象(Unmanaged Objects)</p>
<p>当 Swift 导入 unannotated 的APIs时，编译器将不会自动地对返回的 Core Foundation 对象进行内存管理托管。Swift 将这些返回的 Core Foundation 对象封闭在一个<code>Unmanaged&lt;T&gt;</code>结构中。那些间接返回 Core Foundation 的对象也是非托管的。举个例子，这里有一个 unannotated 的 C 函数:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CFStringRef</span> <span class="type">StringByAddingTwoStrings</span>(<span class="type">CFStringRef</span> string1, <span class="type">CFStringRef</span> string2)</span><br></pre></td></tr></table></figure>
<p>这里说明了Swift是怎么导入的:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">StringByAddingTwoStrings</span><span class="params">(CFString!, CFString!)</span></span> -&gt; <span class="type">Unmanaged</span>&lt;<span class="type">CFString</span>&gt;!</span><br></pre></td></tr></table></figure>
<p>假设我们从 unannotated APIs 接收了非托管的对象，在使用它之前，我们必须将它转换为能够内存管理的对象。在这方面，Swift 可以帮我们进行内存管理而不用自己动手。同时，<code>Unmanaged&lt;T&gt;</code>结构也提供了两个方法来把一个非托管对象转换为一个可内存管理的对象–<code>takeUnretainedValue()</code>方法和<code>takeRetainedValue()</code>方法。这两个方法会返回原始的，非封闭的对象类型。我们可以根据我们实际调用的APIs返回的unretained或retained的对象，来选择哪一方法更合适。</p>
<p>比如，假设这里有一个 C 函数，这个函数在返回值前不会释放<code>CFString</code>对象。在使用这个对象前，我们使用<code>takeUnretainedValue()</code>函数，以将它转换为一个能够内存管理托管的对象。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> memoryManagedResult = <span class="type">StringByAddingTwoStrings</span>(str1, str2).takeUnretainedValue()</span><br><span class="line"><span class="comment">// memoryManagedResult is a memory managed CFString</span></span><br></pre></td></tr></table></figure>
<p>我们也可以在一个非托管的对象中使用<code>retain()</code>，<code>release()</code>和<code>autorelease()</code>方法，但是这种做法并不值得推荐。</p>
<p>要了解更多信息，请参考<a href="https://developer.apple.com/library/prerelease/ios/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/CFMemoryMgmt.html#//apple_ref/doc/uid/10000127i" target="_blank" rel="external">Memory Management Programming Guide for Core Foundation</a>中的<a href="https://developer.apple.com/library/prerelease/ios/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148" target="_blank" rel="external">Memory Management Programming Guide for Core Foundation</a>一节。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/04Adopting Cocoa Design Patterns/" itemprop="url">
                02Interoperability-04采用Cocoa设计模式
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-26T22:00:07+08:00" content="2015-12-26">
            2015-12-26
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Using-Swift-with-Cocoa-and-Objective-C/" itemprop="url" rel="index">
                  <span itemprop="name">Using-Swift-with-Cocoa-and-Objective-C</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/04Adopting Cocoa Design Patterns/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/04Adopting Cocoa Design Patterns/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><blockquote>
<p>翻译：<a href="https://github.com/JaceFu" target="_blank" rel="external">JaceFu</a> <a href="https://github.com/dabing1022" target="_blank" rel="external">ChildhoodAndy</a></p>
<p>校正：<a href="https://github.com/LunaticM" target="_blank" rel="external">LunaticM</a> <a href="https://github.com/dabing1022" target="_blank" rel="external">ChildhoodAndy</a></p>
</blockquote>
<h2 id="#采用Cocoa设计模式">#采用Cocoa设计模式</h2><p>本页包含内容：</p>
<ul>
<li><a href="#Delegation">委托（Delegation）</a></li>
<li><a href="#error_handling">错误处理（Error Handling）</a></li>
<li><a href="#Key-Value_Observing">键值观察（Key-Value Observing）</a></li>
<li><a href="#Target_Action">Target-Action模式（Target-Action）</a></li>
<li><a href="#Introspection">类型匹配与统一规范（Introspection）</a></li>
<li><a href="#API_Availability">API 可用性</a></li>
</ul>
<p>使用 Cocoa 现有的一些设计模式，是帮助开发者开发一款拥有合理设计思路、稳定的性能、良好的可扩展性应用的有效方法之一。这些模式都依赖于在 Objective-C 中定义的类。因为 Swift 与 Objective-C 的互用性，所以你依然可以在 Swift 代码中使用这些设计模式。在一些情况下，你甚至可以使用 Swift 语言的特性扩展或简化这些 Cocoa 设计模式，使这些设计模式更强大、更易于使用。</p>
<p><a name="Delegation"></a></p>
<h2 id="委托">委托</h2><p>在 Swift 和 Objective-C 中，委托通常由一个定义交互方法和遵循规范的委托属性的协议表示。与 Objective-C 相比，当你在 Swift 中继承一个委托时，虽然继承模式不变，但是内部的实现已经改变了。就像在 Objective-C 中，在你向委托发送消息之前，不管它是不是 <code>nil</code> 你都会去查看，如果定义的方法是非必须实现的方法，不管委托有没有实现这个方法，你也都会去查看。而在 Swift 中，通过保持类型安全的特性，可以有效的消除这些繁琐、不必要的行为问题。</p>
<p>下面列出的代码可以说明这个过程：</p>
<ol>
<li>检查 <code>myDelegate</code> 不为 <code>nil</code>。</li>
<li>检查 <code>myDelegate</code> 是否实现了继承的 <code>window:willUseFullScreenContentSize:</code> 方法。</li>
<li>如果<code>myDelegate</code> 不为 <code>nil</code> 并且实现了 <code>window:willUseFullScreenContentSize:</code> 方法，那么调用该方法，将该方法的返回值分配给名为 <code>fullScreenSize</code> 的属性。</li>
<li>将该方法的返回值输出在控制台。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @inteface MyObject : NSObject</span></span><br><span class="line"><span class="comment">// @property (nonatomic, weak) id&lt;NSWindowDelegate&gt; delegate;</span></span><br><span class="line"><span class="comment">// @end</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> fullScreenSize = myDelegate?.window?(myWindow, willUseFullScreenContentSize: mySize) &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="type">NSStringFromSize</span>(fullScreenSize))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>在一个完全使用 Swift 编写的 app 中，在定义 <code>delegate</code> 属性时，它作为一个不定值的 <code>NSWindowDelegate</code> 对象，并将初始值设为 <code>nil</code>。</p>
</blockquote>
<h2 id="错误处理">错误处理</h2><p>在 Cocoa 中，产生错误的方法将<code>NSError</code>指针参数作为最后一个参数，当错误产生时，该参数会被<code>NSError</code>对象填充。Swift 自动的将 Objective-C 中产生错误的方法转换为 Swift 的原生错误处理功能。</p>
<blockquote>
<p>注意</p>
<p>产生错误的方法，例如代理方法或者采用一个<code>NSError</code>对象作为参数的完成处理函数，不会被 Swift 处理为<code>throw</code>的方法。</p>
</blockquote>
<p>例如，考虑下面的来自于<code>NSFileManager</code>的 Objective-C 方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)removeItemAtURL:(NSURL *)URL&#10;                  error:(NSError **)error;</span><br></pre></td></tr></table></figure>
<p>在 Swift 中，它会被这样的导入：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">removeItemAtURL</span><span class="params">(URL: NSURL)</span></span> throws</span><br></pre></td></tr></table></figure>
<p>注意到<code>removeItemAtURL(_:)</code>方法被 Swift 导入时，返回值类型为 Void，没有错误参数，而是一个<code>throws</code>声明。</p>
<p>如果 Objective-C 方法的最后一个非闭包参数是<code>NSError **</code>类型，Swift 则会将之替换为<code>throws</code>关键字，以表明该方法可以抛出一个错误。如果 Objective-C 方法的错误参数也是它的第一个参数，Swift 则会尝试通过删除选择器的第一部分中的<code>AndReturnError</code>后缀来进一步简化方法的名称，如果存在的话。如果另一种方法是用所得选择器声明的，那么该方法名将不可改变。</p>
<p>如果产生错误的 Objective-C 的方法返回一个用来表示方法调用成功或失败的<code>BOOL</code>值，Swift 会把函数的返回值转换为<code>Void</code>。同样的，如果产生错误的 Objective-C 方法返回一个<code>nil</code>值来表明方法调用的失败，Swift 会把函数的返回值转换为非可选值类型。</p>
<p>否则，如果没有约定可以推断，该方法保持不变。</p>
<h3 id="捕获和处理错误">捕获和处理错误</h3><p>在 Objective-C 中，错误处理是可选的，意味着方法产生的错误会被忽略除非你提供了一个错误指针。在 Swift 中，调用一个会抛出错误的方法要求显示的进行错误处理。</p>
<p>下面是如何在 Objective-C 中处理调用方法产生的错误：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSFileManager *fileManager = [NSFileManager defaultManager];&#10;NSURL *URL = [NSURL fileURLWithPath:@&#34;/path/to/file&#34;];&#10;NSError *error = nil;&#10;BOOL success = [fileManager removeItemAtURL:URL error:&#38;error];&#10;if (!success &#38;&#38; error) &#123;&#10;    NSLog(@&#34;Error: %@&#34;, error.domain);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>下面是 Swift 中等同的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fileManager = <span class="type">NSFileManager</span>.defaultManager()</span><br><span class="line"><span class="keyword">let</span> <span class="type">URL</span> = <span class="type">NSURL</span>.fileURLWithPath(<span class="string">"/path/to/file"</span>)</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    try fileManager.removeItemAtURL(<span class="type">URL</span>)</span><br><span class="line">&#125; catch <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">NSError</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Error: <span class="subst">\(error.domain)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="抛出错误">抛出错误</h3><p>如果一个错误出现在了 Objective-C 方法中，那么该错误被用来填充方法的错误指针参数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// an error occurred</span></span><br><span class="line"><span class="keyword">if</span> (errorPtr) &#123;</span><br><span class="line">   *errorPtr = [<span class="type">NSError</span> errorWithDomain:<span class="type">NSURLErrorDomain</span></span><br><span class="line">                                   code:<span class="type">NSURLErrorCannotOpenFile</span></span><br><span class="line">                               userInfo:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个错误出现在了 Swift 方法中，那么该错误便会被抛出，并且会自动的传递给调用者：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// an error occurred</span></span><br><span class="line">throw <span class="type">NSError</span>(domain: <span class="type">NSURLErrorDomain</span>, code: <span class="type">NSURLErrorCannotOpenFile</span>, userInfo: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>如果 Objective-C 代码调用 Swift 方法抛出了错误，那么该错误会被自动的传递给桥接的 Objective-C 方法的错误指针参数。</p>
<p>例如，考虑<code>NSDocument</code>中的<code>readFromFileWrapper(_:ofType:)</code>方法。在 Objective-C 中，这个方法的最后一个参数是<code>NSError **</code>。当在 Swift 的<code>NSDocument</code>的子类中重写该方法时，该方法会用<code>throws</code>替代错误指针参数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerializedDocument</span>: <span class="title">NSDocument</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">ErrorDomain</span> = <span class="string">"com.example.error.serialized-document"</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> representedObject: [<span class="type">String</span>: <span class="type">AnyObject</span>] = [:]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">readFromFileWrapper</span><span class="params">(fileWrapper: NSFileWrapper, ofType typeName: String)</span></span> throws &#123;</span><br><span class="line">        guard <span class="keyword">let</span> data = fileWrapper.regularFileContents <span class="keyword">else</span> &#123;</span><br><span class="line">            throw <span class="type">NSError</span>(domain: <span class="type">NSURLErrorDomain</span>, code: <span class="type">NSURLErrorCannotOpenFile</span>, userInfo: <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> <span class="type">JSON</span> <span class="keyword">as</span> [<span class="type">String</span>: <span class="type">AnyObject</span>] = try <span class="type">NSJSONSerialization</span>.<span class="type">JSONObjectWithData</span>(data, options: []) &#123;</span><br><span class="line">            <span class="keyword">self</span>.representedObject = <span class="type">JSON</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            throw <span class="type">NSError</span>(domain: <span class="type">SerializedDocument</span>.<span class="type">ErrorDomain</span>, code: -<span class="number">1</span>, userInfo: <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果方法不能够使用常规的文件的内容来创建一个对象，则会抛出一个<code>NSError</code>对象。如果方法是从 Swift 代码中调用的，那么该错误会被传递到它的调用域。如果该方法是在 Objective-C 代码中被调用，错误将会传递到错误指针参数里。</p>
<p>在 Objective-C 中，错误处理是可选的，意味着方法产生的错误会被忽略除非你提供了一个错误指针。在 Swift 中，调用一个会抛出错误的方法要求显式的进行错误处理。</p>
<blockquote>
<p>注意</p>
<p>尽管 Swift 的错误处理类似 Objective-C 的异常处理，但它是完全独立的功能。如果一个 Objective-C 方法抛出了一个运行时异常，Swift 则会触发一个运行时错误。没有办法直接在 Swift 中恢复来自 Objective-C 的异常。任何在 Objective-C 代码中的异常处理行为必须用 Swift 来实现。</p>
</blockquote>
<p><a name="Key-Value_Observing"></a></p>
<p>##键值观察</p>
<p>键值观察是一种机制，该机制允许对象获得其他对象的特定属性的变化的通知。只要你的类继承自 NSObject 类，你便可在 Swift 类里使用键值观察。你可以在 Swift 中使用下面三步来实现键值观察：</p>
<ol>
<li>为你想要观察的属性添加动态修改符。关于<code>dynamic</code>更多信息，请见<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID57" target="_blank" rel="external">Requiring Dynamic Dispatch</a></li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObjectToObserve</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    dynamic <span class="keyword">var</span> myDate = <span class="type">NSDate</span>()</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">updateDate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        myDate = <span class="type">NSDate</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>创建一个全局上下文变量。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">var</span> myContext = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ol>
<li>为键-路径增加一个观察者，重写<code>observeValueForKeyPath:ofObject:change:context:</code>函数，并且在<code>deinit</code>中移除观察者。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObserver</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> objectToObserve = <span class="type">MyObjectToObserve</span>()</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        objectToObserve.addObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"myDate"</span>, options: .<span class="type">New</span>, context: &amp;myContext)</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">observeValueForKeyPath</span><span class="params">(keyPath: String?, ofObject object: AnyObject?, change: [NSObject : AnyObject]?, context: UnsafeMutablePointer&lt;Void&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> context == &amp;myContext &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> newValue = change?[<span class="type">NSKeyValueChangeNewKey</span>] &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Date changed: <span class="subst">\(newValue)</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.observeValueForKeyPath(keyPath, ofObject: object, change: change, context: context)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        objectToObserve.removeObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"myDate"</span>, context: &amp;myContext)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="Target_Action"></a></p>
<p>##Target-Action模式（Target-Action）##<br>当有特定事件发生，需要一个对象向另一个对象发送消息时，我们通常采用 Cocoa 的 Target-Action 设计模式。Swift 和 Objective-C 中的 Target-Action 模型基本类似。在 Swift 中，你可以使用 <code>Selector</code> 类型达到 Objective-C 中 selectors 的效果。请在 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID59" target="_blank" rel="external">Objective-C Selectors</a> 中查看在 Swift 中使用 Target-Action 设计模式的示例。</p>
<p><a name="Introspection"></a></p>
<p>##类型匹配与统一规范（Introspection）##<br>在 Objective-C 中，你可以使用 <code>isKindOfClass:</code> 方法检查某个对象是否是指定类型，可以使用 <code>conformsToProtocol:</code> 方法检查某个对象是否遵循特定协议的规范。在 Swift 中，你可以使用 <code>is</code> 运算符完成上述的功能，或者也可以使用 <code>as?</code> 向下匹配指定类型。</p>
<p>你可以使用 <code>is</code> 运算符检查一个实例是否是指定的子类。如果该实例是指定的子类，那么 <code>is</code> 运算结果为 <code>true</code>，反之为 <code>false</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> object <span class="keyword">is</span> <span class="type">UIButton</span> &#123;</span><br><span class="line">    <span class="comment">// object is of type UIButton</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// object is not of type UIButton</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以使用 <code>as?</code> 运算符尝试向下匹配子类型，<code>as?</code> 运算符返回不定值，结合 <code>if-let</code> 语句使用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> button = object <span class="keyword">as</span>? <span class="type">UIButton</span> &#123;</span><br><span class="line">    <span class="comment">// object is successfully cast to type UIButton and bound to button</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// object could not be cast to type UIButton</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请在 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TypeCasting.html#//apple_ref/doc/uid/TP40014097-CH22" target="_blank" rel="external">Type Casting</a> 中查看更多信息。</p>
<p>检查匹配协议的语法与检查匹配类的语法是一样的，下面是使用 <code>as?</code> 检查匹配协议的示例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> dataSource = object <span class="keyword">as</span>? <span class="type">UITableViewDataSource</span> &#123;</span><br><span class="line">    <span class="comment">// object conforms to UITableViewDataSource and is bound to dataSource</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// object not conform to UITableViewDataSource</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，当做完匹配之后，<code>dataSource</code> 会转换为  <code>UITableViewDataSource</code> 类型，所以你只能访问和调用<code>UITableViewDataSource</code> 协议定义的属性和方法。当你想进行其他操作时，必须将其转换为其他的类型。<br><br>可以在 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25" target="_blank" rel="external">Protocols</a> 查看更多相关信息。</p>
<p><a name="API_Availability"></a></p>
<h2 id="API_可用性">API 可用性</h2><p>一些类和方法并不是在你的应用所有平台的所有版本都可用。为了确保你的应用功能上能够适应差异，你需要检查这些 API 的可用性。</p>
<p>在 Objective-C 中，我们使用<code>respondsToSelector:</code>和<code>instancesRespondToSelector:</code>方法来检查一个类或者实例方法是否可用。如果没有检查，调用方法则会抛出<code>NSInvalidArgumentException</code>“unrecognized selector sent to instance”异常。例如，<code>requestWhenInUseAuthorization</code>方法只在 iOS8.0 和 OS X 10.10 中对<code>CLLocationManager</code>实例可用。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if ([CLLocationManager instancesRespondToSelector:@selector(requestWhenInUseAuthorization)]) &#123;&#10;  // &#26041;&#27861;&#21487;&#29992;&#10;&#125; else &#123;&#10;  // &#26041;&#27861;&#19981;&#21487;&#29992;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在 Swift 中，尝试着调用一个目标平台版本不支持的方法将会报出编译时错误。</p>
<p>下面是上一个例子，采用 Swift 编写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> locationManager = <span class="type">CLLocationManager</span>()</span><br><span class="line">locationManager.requestWhenInUseAuthorization()</span><br><span class="line"><span class="comment">// error: only available on iOS 8.0 or newer</span></span><br></pre></td></tr></table></figure>
<p>如果应用的目标低于 ios8.0 或者 OSX10.10，<code>requestWhenInUseAuthorization()</code>方法则不可用，所以编译器会报告错误。</p>
<p>Swift 代码可以使用 API 可用性来作为运行时的条件判断。可用性检查可以使用在一个控制流语句的条件中，例如<code>if</code>,<code>guard</code>或者<code>while</code>语句。</p>
<p>拿前面的例子举例，你可以使用<code>if</code>语句来检查可用性，只有当方法在运行时可用时方可调用<code>requestWhenInUseAuthorization()</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> locationManager = <span class="type">CLLocationManager</span>()</span><br><span class="line"><span class="keyword">if</span> #available(iOS <span class="number">8.0</span>, <span class="type">OSX</span> <span class="number">10.10</span>, *) &#123;</span><br><span class="line">    locationManager.requestWhenInUseAuthorization()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者，你可以使用<code>guard</code>语句来检查可用性，除非当前的目标符合规定要求，否则将会退出作用域。这种方法简化了处理不同平台功能的逻辑。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> locationManager = <span class="type">CLLocationManager</span>()</span><br><span class="line">guard #available(iOS <span class="number">8.0</span>, <span class="type">OSX</span> <span class="number">10.10</span>, *) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">locationManager.requestWhenInUseAuthorization()</span><br></pre></td></tr></table></figure>
<p>每个平台参数包括下面列出的平台名称，后面跟着相应的版本号。最后一个参数是一个星号（*），是用来处理未来潜在的平台。</p>
<p>平台名称：</p>
<ul>
<li>iOS</li>
<li>iOSApplicationExtension</li>
<li>OSX</li>
<li>OSXApplicationExtension</li>
<li>watchOS</li>
</ul>
<p>所有的 Cocoa API 都提供有可用性信息，所以你可以很自信的编写应用所针对的平台的代码。</p>
<p>你可以通过 @available 属性来标注声明从而简化你的 API 的可用性检查。@available 属性使用和 #available 同样的语法来做运行时检查，参数都以逗号隔开平台版本需求。</p>
<p>例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@available(iOS <span class="number">8.0</span>, <span class="type">OSX</span> <span class="number">10.10</span>, *)</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">useShinyNewFeature</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>使用 @available 属性标记的方法可以安全的使用满足特定平台需求的可用 API 而不用显式的做可用性检查。</p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/05Interacting with C APIs/" itemprop="url">
                02Interoperability-05与 C 的 API 交互
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-26T22:00:06+08:00" content="2015-12-26">
            2015-12-26
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Using-Swift-with-Cocoa-and-Objective-C/" itemprop="url" rel="index">
                  <span itemprop="name">Using-Swift-with-Cocoa-and-Objective-C</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/05Interacting with C APIs/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/05Interacting with C APIs/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><blockquote>
<p>翻译：<a href="https://github.com/shockinglee" target="_blank" rel="external">shockinglee</a></p>
<p>校对：<a href="https://github.com/shanyimin" target="_blank" rel="external">shanyimin</a> <a href="https://github.com/dabing1022" target="_blank" rel="external">ChildhoodAndy</a> <a href="https://github.com/Phenmod" target="_blank" rel="external">Phenmod</a></p>
</blockquote>
<h1 id="与_C_的_API_交互">与 C 的 API 交互</h1><hr>
<p>本节包含内容：</p>
<ul>
<li><a href="#primitive_types">基本数据类型（Primitive Types）</a></li>
<li><a href="#enumerations">枚举（Enumerations）</a></li>
<li><a href="#pointer">指针（Pointer）</a></li>
<li><a href="#global_constants">全局常量（Global Constants）</a></li>
<li><a href="#preprocessor_directives">预处理指令（Preprocessor Directives）</a></li>
</ul>
<p>作为与Objective-C语言的互用性的一部分，Swift也对一些C语言的类型和特性保持了兼容性。如果你的代码有需要，Swift也提供了一些方式来使用常见的C结构和模式。</p>
<h2 id="基本数据类型">基本数据类型</h2><p>Swift提供了一些与C语言基本类型如<code>char</code>,<code>int</code>,<code>float</code>和<code>double</code>等的对应类型。然而，这些类型和Swift核心基本类型之间不能进行隐式转换，如Int。因此，只有你的代码明确要求时才使用这些类型，其它任何可能的情况下都应该使用Int。</p>
<table>
<thead>
<tr>
<th>C 类型</th>
<th>Swift 类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>bool</td>
<td>CBool</td>
</tr>
<tr>
<td>char, signed char</td>
<td>CChar</td>
</tr>
<tr>
<td>unsigned char</td>
<td>CUnsignedChar</td>
</tr>
<tr>
<td>short</td>
<td>CShort</td>
</tr>
<tr>
<td>unsigned short</td>
<td>CUnsignedShort</td>
</tr>
<tr>
<td>int</td>
<td>CInt</td>
</tr>
<tr>
<td>unsigned int</td>
<td>CUnsignedInt</td>
</tr>
<tr>
<td>long</td>
<td>CLong</td>
</tr>
<tr>
<td>unsigned long</td>
<td>CUnsignedLong</td>
</tr>
<tr>
<td>long long</td>
<td>CLongLong</td>
</tr>
<tr>
<td>unsigned long long</td>
<td>CUnsignedLongLong</td>
</tr>
<tr>
<td>wchar_t</td>
<td>CWideChar</td>
</tr>
<tr>
<td>char16_t</td>
<td>CChar16</td>
</tr>
<tr>
<td>char32_t</td>
<td>CChar32</td>
</tr>
<tr>
<td>float</td>
<td>CFloat</td>
</tr>
<tr>
<td>double</td>
<td>CDouble</td>
</tr>
</tbody>
</table>
<h2 id="枚举">枚举</h2><p>任何用宏<code>NS_ENUM</code>来声明的C风格的枚举，都会被Swfit导入为一个Swfit枚举类型。无论枚举值是在系统框架还是在自己的代码中定义的，当它们导入到Swift时，它们的前缀名将被截掉。</p>
<p>例如，看这个Objective-C枚举的声明：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Objective-C</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UITableViewCellStyle</span>) &#123;</span><br><span class="line">    <span class="built_in">UITableViewCellStyleDefault</span>,</span><br><span class="line">    <span class="built_in">UITableViewCellStyleValue1</span>,</span><br><span class="line">    <span class="built_in">UITableViewCellStyleValue2</span>,</span><br><span class="line">    <span class="built_in">UITableViewCellStyleSubtitle</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在Swift中，会被导入为这样：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//Swift</span><br><span class="line"><span class="keyword">enum</span> UITableViewCellStyle: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">Default</span></span><br><span class="line">    <span class="keyword">case</span> Value1</span><br><span class="line">    <span class="keyword">case</span> Value2</span><br><span class="line">    <span class="keyword">case</span> Subtitle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你需要使用一个枚举值时，使用以点（.）开头的枚举名称：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="keyword">let</span> cellStyle: UITableViewCellStyle = .<span class="built_in">Default</span></span><br></pre></td></tr></table></figure>
<h2 id="选项集">选项集</h2><p>对使用宏<code>NS_OPTIONS</code>声明的C风格的枚举，Swift会把它导入为一个Swfit选项集类型。选项集像枚举一样，会把前缀截掉，只剩下选项值名称。</p>
<p>例如，看这个Objective-C选项的声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Objective-C</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NS_OPTIONS</span><span class="params">(NSUInteger, NSJSONReadingOptions)</span> </span>&#123;</span><br><span class="line">	NSJSONReadingMutableContainers = (<span class="number">1U</span>L &lt;&lt; <span class="number">0</span>),</span><br><span class="line">	NSJSONReadingMutableLeaves = (<span class="number">1U</span>L &lt;&lt; <span class="number">1</span>),</span><br><span class="line">	NSJSONReadingAllowFragments = (<span class="number">1U</span>L &lt;&lt; <span class="number">2</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在Swift中，它被导入为这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NSJSONReadingOptions</span> : <span class="title">OptionSetType</span> </span>&#123;</span><br><span class="line">	<span class="keyword">init</span>(rawValue: <span class="type">UInt</span>)</span><br><span class="line">   </span><br><span class="line">   	<span class="keyword">static</span> <span class="keyword">var</span> <span class="type">MutableContainers</span>: <span class="type">NSJSONReadingOptions</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">   	<span class="keyword">static</span> <span class="keyword">var</span> <span class="type">MutableLeaves</span>: <span class="type">NSJSONReadingOptions</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">   	<span class="keyword">static</span> <span class="keyword">var</span> <span class="type">AllowFragments</span>: <span class="type">NSJSONReadingOptions</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在Objective-C中，一个选项集是整数值的一个位掩码。你可以使用按位或操作符（<code>|</code>）来组合选项值，使用按位与操作符（<code>&amp;</code>）以检测选项值。创建一个选项集，可以使用常量值或者表达式。一个空的选项集使用常数<code>0</code>来表示。</p>
<p>在Swift中，选项集使用一个遵循<code>OptionSetType</code>协议的结构体来表示，其中每个选项值都是一个静态变量。选项集类似于Swift的集合类型<code>Set</code>，你可以用<code>insert(_:)</code>或者<code>unionInPlace(_:)</code>方法来添加选项值，用<code>remove(_:)</code>或者<code>subtractInPlace(_:)</code>方法来删除选项值，用<code>contains(_:)</code>方法来检测选项值。创建一个选项集的值可以使用一个数组字面量，里面的选项值像枚举一样都用点（<code>.</code>）开头。创建一个空的选项集可以使用一个空的数组字面量，也可以调用默认初始化函数。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line">let options: NSDataBase64EncodingOptions = [</span><br><span class="line">	<span class="class">.Encoding76CharacterLineLength</span>,</span><br><span class="line">   	<span class="class">.EncodingEndLineWithLineFeed</span></span><br><span class="line">   ]</span><br><span class="line">let string = data.<span class="function"><span class="title">base64EncodedStringWithOptions</span><span class="params">(options)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="共用体">共用体</h2><p>Swift仅部分支持C的共用体（union）类型。在导入混有C的共用体或者位段（bitfields）的类型时，例如Foundation的<code>NSDecimal</code>类型，Swift不能存取不支持的字段。但是，参数和/或返回值为这些类型的C和Objective-C的API是能够在Swift中使用的。</p>
<h2 id="指针">指针</h2><p>Swift尽可能避免让您直接访问指针。然而，当您需要直接操作内存的时候，Swift也为您提供了多种指针类型。下面的表使用<code>Type</code>作为类型名称的占位符。</p>
<p>对于返回类型，变量和参数，使用如下形式：</p>
<table>
<thead>
<tr>
<th>C 句法</th>
<th>Swift 句法</th>
</tr>
</thead>
<tbody>
<tr>
<td>const Type *</td>
<td>UnsafePointer\<type\></type\></td>
</tr>
<tr>
<td>Type *</td>
<td>UnsafeMutablePointer\<type\></type\></td>
</tr>
</tbody>
</table>
<p>对于类（class）类型，使用如下形式：</p>
<table>
<thead>
<tr>
<th>C 句法</th>
<th>Swift 句法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Type <em> const </em></td>
<td>UnsafePointer\<type\></type\></td>
</tr>
<tr>
<td>Type <em> __strong </em></td>
<td>UnsafeMutablePointer\<type\></type\></td>
</tr>
<tr>
<td>Type **</td>
<td>AutoreleasingUnsafeMutablePointer\<type\></type\></td>
</tr>
</tbody>
</table>
<h3 id="常量指针">常量指针</h3><p>当一个函数被声明为接受<code>UnsafePointer&lt;Type&gt;</code>参数时，这个函数可以接受下列任何一个类型作为参数：</p>
<ul>
<li><code>nil</code>，作为空指针传入；</li>
<li>一个<code>UnsafePointer&lt;Type&gt;</code>，<code>UnsafeMutablePointer&lt;Type&gt;</code>， 或者<code>AutoreleasingUnsafeMutablePointer&lt;Type&gt;</code>的值，在必要情况下会转换成<code>UnsafePointer&lt;Type&gt;</code>的值；</li>
<li>一个<code>String</code>类型的值，如果<code>Type</code>是<code>Int8</code>或者<code>UInt8</code>的话。该字符串会自动在一个缓冲区内被转换为UTF8，该缓冲区在本次调用期间有效；</li>
<li>一个左值操作数为<code>Type</code>类型的输入输出（inout）表达式，传入的是这个左值的内存地址；</li>
<li>一个<code>[Type]</code>值，传入该数组的起始指针，并且它的生命周期将在本次调用期间被延长。</li>
</ul>
<p>如果您这样定义了一个函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesAPointer</span><span class="params">(x: UnsafePointer&lt;Float&gt;)</span></span> &#123; <span class="comment">/*...*/</span> &#125;</span><br></pre></td></tr></table></figure>
<p>那么您可以使用以下任何一种方式来调用这个函数：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//Swift</span></span><br><span class="line">   <span class="tag">var</span> x: Float = <span class="number">0.0</span></span><br><span class="line"><span class="tag">var</span> <span class="tag">p</span>: UnsafePointer&lt;Float&gt; = nil</span><br><span class="line"><span class="function"><span class="title">takesAPointer</span><span class="params">(nil)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAPointer</span><span class="params">(p)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAPointer</span><span class="params">(&amp;x)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAPointer</span><span class="params">([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>])</span></span></span><br></pre></td></tr></table></figure>
<p>如果函数被声明为使用一个<code>UnsafePointer&lt;Void&gt;</code>参数，那么这个函数接受任何<code>Type</code>的<code>UnsafePointer&lt;Type&gt;</code>类型的操作数。<br>￼<br>如果您这样定义了一个函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesAVoidPointer</span><span class="params">(x: UnsafePointer&lt;Void&gt;)</span></span>  &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>那么您可以使用以下任何一种方式来调用这个函数：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//Swift</span></span><br><span class="line">   <span class="tag">var</span> x: Float = <span class="number">0.0</span>, y: Int = <span class="number">0</span></span><br><span class="line"><span class="tag">var</span> <span class="tag">p</span>: UnsafePointer&lt;Float&gt; = nil, <span class="tag">q</span>: UnsafePointer&lt;Int&gt; = nil</span><br><span class="line"><span class="function"><span class="title">takesAVoidPointer</span><span class="params">(nil)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAVoidPointer</span><span class="params">(p)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAVoidPointer</span><span class="params">(q)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAVoidPointer</span><span class="params">(&amp;x)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAVoidPointer</span><span class="params">(&amp;y)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAVoidPointer</span><span class="params">([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>] as [Float])</span></span></span><br><span class="line">let intArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="function"><span class="title">takesAVoidPointer</span><span class="params">(intArray)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="可变指针">可变指针</h3><p>当一个方法被声明为接受<code>UnsafeMutablePointer&lt;Type&gt;</code>参数时，这个函数可以接受下列任何一个类型作为参数：</p>
<ul>
<li><code>nil</code>，作为空指针传入；</li>
<li>一个<code>UnsafeMutablePointer&lt;Type&gt;</code>类型的值；</li>
<li>一个输入输出（inout）表达式，其左值操作数是<code>Type</code>类型的，且被存储起来了。传入的是这个左值的内存地址；</li>
<li>一个输入输出的<code>[Type]</code>类型的值，传入的是该数组的起始指针，并且它的生命周期将在本次调用期间被延长。</li>
</ul>
<p>如果您这样定义了一个函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesAMutablePointer</span><span class="params">(x: UnsafeMutablePointer&lt;Float&gt;)</span></span> &#123; <span class="comment">/*...*/</span> &#125;</span><br></pre></td></tr></table></figure>
<p>那么您可以使用以下任何一种方式来调用这个函数：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//Swift</span></span><br><span class="line">   <span class="tag">var</span> x: Float = <span class="number">0.0</span></span><br><span class="line"><span class="tag">var</span> <span class="tag">p</span>: UnsafeMutablePointer&lt;Float&gt; = nil</span><br><span class="line"><span class="tag">var</span> <span class="tag">a</span>: [Float] = [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>]</span><br><span class="line"><span class="function"><span class="title">takesAMutablePointer</span><span class="params">(nil)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAMutablePointer</span><span class="params">(p)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAMutablePointer</span><span class="params">(&amp;x)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAMutablePointer</span><span class="params">(&amp;a)</span></span></span><br></pre></td></tr></table></figure>
<p>如果函数被声明使用一个<code>UnsafeMutablePointer&lt;Void&gt;</code>参数，那么这个函数接受任何<code>Type</code>的<code>UnsafeMutablePointer&lt;Type&gt;</code>类型的操作数。</p>
<p>如果您这样定义了一个函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesAMutableVoidPointer</span><span class="params">(x: UnsafeMutablePointer&lt;Void&gt;)</span></span>  &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>那么您可以使用以下任何一种方式来调用这个函数：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//Swift</span></span><br><span class="line">   <span class="tag">var</span> x: Float = <span class="number">0.0</span>, y: Int = <span class="number">0</span></span><br><span class="line"><span class="tag">var</span> <span class="tag">p</span>: UnsafeMutablePointer&lt;Float&gt; = nil, <span class="tag">q</span>: UnsafeMutablePointer&lt;Int&gt; = nil</span><br><span class="line"><span class="tag">var</span> <span class="tag">a</span>: [Float] = [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>], <span class="tag">b</span>: [Int] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="function"><span class="title">takesAMutableVoidPointer</span><span class="params">(nil)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAMutableVoidPointer</span><span class="params">(p)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAMutableVoidPointer</span><span class="params">(q)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAMutableVoidPointer</span><span class="params">(&amp;x)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAMutableVoidPointer</span><span class="params">(&amp;y)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAMutableVoidPointer</span><span class="params">(&amp;a)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAMutableVoidPointer</span><span class="params">(&amp;b)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="自动释放指针">自动释放指针</h3><p>当一个函数被声明为接受<code>AutoreleasingUnsafeMutablePointer&lt;Type&gt;</code>参数时，这个函数可以接受下列任何一个类型作为参数：</p>
<ul>
<li><code>nil</code>，作为空指针传入；</li>
<li>一个<code>AutoreleasingUnsafeMutablePointer&lt;Type&gt;</code>类型的值；</li>
<li>一个输入输出（inout）表达式，其操作数首先被拷贝到一个无拥有者的缓冲区，传递给被调用函数的就是这个缓冲区的地址。在调用返回时，缓冲区中的值被加载、保存、并重新复制给操作数。</li>
</ul>
<p>注意，这个列表中没有包含数组。</p>
<p>如果您这样定义了一个函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesAnAutoreleasingPointer</span><span class="params">(x: AutoreleasingUnsafeMutablePointer&lt;NSDate?&gt;)</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>那么您可以使用以下任何一种方式来调用这个函数：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//Swift</span></span><br><span class="line">   <span class="keyword">var</span> x: NSDate? = <span class="keyword">nil</span></span><br><span class="line"><span class="keyword">var</span> p: AutoreleasingUnsafeMutablePointer&lt;NSDate?&gt; = <span class="keyword">nil</span></span><br><span class="line">takesAnAutoreleasingPointer(<span class="keyword">nil</span>)</span><br><span class="line">takesAnAutoreleasingPointer(p)</span><br><span class="line">takesAnAutoreleasingPointer(&amp;x)</span><br></pre></td></tr></table></figure>
<p>被指针指向的类型并不会被桥接。例如，<code>NSString **</code>转换到Swift后，是<code>AutoreleasingUnsafeMutablePointer&lt;NSString?&gt;</code>，而不是<code>AutoreleasingUnsafeMutablePointer&lt;String?&gt;</code>。</p>
<h3 id="函数指针">函数指针</h3><p>C语言的函数指针通过调用约定，以闭包的形式被引入Swift中，表示形式为<code>@convention(c)</code>。例如，一个类型为<code>int (*)(void)</code>的C语言函数指针，会转换为Swift的<code>@convention(c) () -&gt; Int32</code>。</p>
<p>在调用一个以函数指针为参数的函数时，给它传的值可以是一个顶层的Swift函数，也可以是个闭包字面量，或者<code>nil</code>。只有符合C语言函数指针调用约定的Swift函数，才能用来给函数指针类型的形参传值。例如，Core Foundation的<code>CFArrayCreateMutable(_:_:_:)</code>函数，它有个参数的类型为<code>CFArrayCallBacks</code>结构体。这个<code>CFArrayCallBacks</code>结构体就是用一些函数指针进行初始化的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">customCopyDescription</span><span class="params">(p: UnsafePointer&lt;Void&gt;)</span></span> -&gt; <span class="type">Unmanaged</span>&lt;<span class="type">CFString</span>&gt;! &#123;</span><br><span class="line">   	<span class="comment">// return an Unmanaged&lt;CFString&gt;! value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> callbacks = <span class="type">CFArrayCallBacks</span>(</span><br><span class="line">   	version: <span class="number">0</span> <span class="keyword">as</span> <span class="type">CFIndex</span>,</span><br><span class="line">   	retain: <span class="literal">nil</span>,</span><br><span class="line">   	release: <span class="literal">nil</span>,</span><br><span class="line">   	copyDescription: customCopyDescription,</span><br><span class="line">   	<span class="built_in">equal</span>: &#123; (p1, p2) -&gt; <span class="type">Boolean</span> <span class="keyword">in</span></span><br><span class="line">       	<span class="comment">// return Boolean value</span></span><br><span class="line">   	&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mutableArray = <span class="type">CFArrayCreateMutable</span>(<span class="literal">nil</span>, <span class="number">0</span>, callbacks)</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，在<code>CFArrayCallBacks</code>初始化时，传给<code>retain</code>和<code>release</code>作参数的是<code>nil</code>，传给<code>copyDescription</code>作参数的是函数<code>customCopyDescription</code>，传给<code>equal</code>作参数的是一个闭包字面量。</p>
<h2 id="全局常量">全局常量</h2><p>在C和Objective-C语言源文件中定义的全局常量会自动地被Swift编译引进并做为Swift的全局常量。</p>
<h2 id="预处理指令">预处理指令</h2><p>Swift编译器不包含预处理器。取而代之的是，它充分利用了编译时属性，生成配置，和语言特性来完成相同的功能。因此，Swift没有引进预处理指令。</p>
<h3 id="简单宏">简单宏</h3><p>在C和Objective-C中，通常使用<code>#define</code>指令来定义一个简单的常数，在Swift，您可以使用全局常量来代替。例如：定义一个常数的<code>#define FADE_ANIMATION_DURATION 0.35</code>，在Swift使用<code>let FADE_ANIMATION_DURATION = 0.35</code>来表述会更好一些。由于简单的用于定义常量的宏会被直接被映射成Swift全局量，Swift编译器会自动引进在C或Objective-C源文件中定义的简单宏。</p>
<h3 id="复杂宏">复杂宏</h3><p>在C和Objective-C中使用的复杂宏在Swift中没有相对应的东西。复杂宏是那些不用来定义常量的宏，包含了括号的函数式宏。您在C和Objective-C使用复杂的宏以避免类型检查的限制或避免重新键入大量的样板代码。然而，宏也会造成debug和重构起来更困难。在Swift中你可以使用函数和泛型来达到同样的效果，而没有任何的委屈折中。因此，在C和Objective-C源文件中定义的复杂宏在Swift是不能使用的。</p>
<h3 id="生成配置">生成配置</h3><p>Swift代码使用和C、Objective-C代码不同的方式进行条件编译。Swift代码可以根据生成配置的组合进行条件编译。生成配置包括<code>true</code>和<code>false</code>字面值，命令行标志，和下表中的平台测试函数。您可以使用<code>-D &lt;＃Flag＃&gt;</code>指定命令行标志。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>有效参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>os()</td>
<td>OSX，iOS，watchOS</td>
</tr>
<tr>
<td>arch()</td>
<td>x86_64，arm，arm64，i386</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意：生成配置<code>arch(arm)</code>不会为64位ARM设备返回<code>true</code>，生成配置<code>arch(i386)</code>在为32位iOS模拟器编译代码时会返回<code>true</code>。</p>
</blockquote>
<p>一个简单的条件编译可以像下面这段代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">if</span> build configuration</span></span><br><span class="line">  statements</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">  statements</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>由零个或多个有效的Swift语句组成的<em>statements</em>，可以包括表达式，普通语句和控制流语句。可以使用<code>&amp;&amp;</code>和<code>||</code>操作符往一个条件编译语句上添加新的编译条件，使用<code>!</code>操作符来否定某条件，使用<code>#elseif</code>来添加编译块：</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">if</span> build configuration &amp;&amp; !build configuration</span></span><br><span class="line">  statements<span class="preprocessor"></span><br><span class="line">#<span class="keyword">elseif</span> build configuration</span></span><br><span class="line">  statements<span class="preprocessor"></span><br><span class="line">#<span class="keyword">else</span></span></span><br><span class="line">  statements<span class="preprocessor"></span><br><span class="line">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>与C语言编译器的条件编译不同的是，Swift条件编译的语句必须是独立完整、语法有效的代码块。这是因为所有的Swift代码都会做语法检查，而不管会不会被编译。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/03Mix and Match/Swift and Objective-C in the Same Project/" itemprop="url">
                03Mix and Match-01Mix and Match 概述（Mix and Match Overview
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-26T22:00:05+08:00" content="2015-12-26">
            2015-12-26
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Using-Swift-with-Cocoa-and-Objective-C/" itemprop="url" rel="index">
                  <span itemprop="name">Using-Swift-with-Cocoa-and-Objective-C</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/03Mix and Match/Swift and Objective-C in the Same Project/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/03Mix and Match/Swift and Objective-C in the Same Project/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><blockquote>
<p>翻译：<a href="https://github.com/haolloyin" target="_blank" rel="external">haolloyin</a></p>
<p>校对：<a href="https://github.com/dabing1022" target="_blank" rel="external">ChildhoodAndy</a></p>
</blockquote>
<h1 id="在同个工程中使用_Swift_和_Objective-C">在同个工程中使用 Swift 和 Objective-C</h1><hr>
<p>本节包含内容：</p>
<ul>
<li><a href="#mix_and_match_overview">Mix and Match 概述（Mix and Match Overview）</a></li>
<li><a href="#importing_code_from_within_the_same_app_target">在同个应用的 target 中导入（Importing Code from Within the Same App Target）</a></li>
<li><a href="#importing_code_from_within_the_same_framework_target">在同个 Framework 的 target 中导入（Importing Code from Within the Same Framework Target）</a></li>
<li><a href="#importing_external_frameworks">导入外部 framework（Importing External Frameworks）</a></li>
<li><a href="#using_swift_from_objective-c">在 Objective-C 中使用 Swift（Using Swift from Objective-C）</a></li>
<li><a href="#overriding_swift_names_for_Objective">为 Objective-C 接口重写 Swift 名称</a></li>
<li><a href="#naming_your_product_module">Product 模块命名（Naming Your Product Module）</a></li>
<li><a href="#troubleshooting_tips_and_reminders">问题解决提示（Troubleshooting Tips and Reminders）</a></li>
</ul>
<p>Swift 与 Objective-C 的兼容能力使你可以在同一个工程中同时使用两种语言。你可以用这种叫做 <code>mix and match</code> 的特性来开发基于混合语言的应用，可以用 Swift 的最新特性实现应用的一部分功能，并无缝地并入已有的 Objective-C 的代码中。</p>
<p><a name="mix_and_match_overview"></a></p>
<h2 id="Mix_and_Match_概述">Mix and Match 概述</h2><p>Objective-C 和 Swift 文件可以在一个工程中并存，不管这个工程原本是基于 Objective-C 还是 Swift。你可以直接往现有工程中简单地添加另一种语言的源文件。这种自然的工作流使得创建混合语言的应用或框架 target，与用单独一种语言时一样简单。</p>
<p>混合语言的工作流程只有一点点区别，这取决于你是在写应用还是写框架。下面描述了普通的用两种语言在一个 target 中导入模型的情况，后续章节会有更多细节。</p>
<p><img src="http://7xp6cn.com1.z0.glb.clouddn.com/DAG_2x.png" alt="DAG_2x.png"></p>
<p><a name="importing_code_from_within_the_same_app_target"></a></p>
<h2 id="在同个应用的_target_中导入">在同个应用的 target 中导入</h2><p>如果你在写混合语言的应用，可能需要用 Swift 代码访问 Objective-C 代码，或者反之。下面的流程描述了在非框架 target 中的应用。</p>
<h3 id="将_Objective-C_导入_Swift">将 Objective-C 导入 Swift</h3><p>在一个应用的 target 中导入一些 Objective-C 文件供 Swift 代码使用时，你需要依赖于 Objective-C 的桥接头文件（<code>bridging header</code>）来暴露给 Swift。当你添加 Swift 文件到现有的 Objective-C 应用（或反之）时，Xcode 会自动创建这些头文件。</p>
<p><img src="http://7xp6cn.com1.z0.glb.clouddn.com/bridgingheader_2x.png" alt="bridgingheader_2x.png"></p>
<p>如果你同意，Xcode 会在源文件创建的同时生成头文件，并用 product 的模块名加上 <code>-Bridging-Header.h</code> 命名。关于 product 的模块名，详见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_85" target="_blank" rel="external">Naming Your Product Module</a>。</p>
<p>你应该编辑这个头文件来对 Swift 暴露出 Objective-C 代码。</p>
<h4 id="在同一_target_中将_Objective-C_代码导入到_Swift_中">在同一 target 中将 Objective-C 代码导入到 Swift 中</h4><ol>
<li>在 Objective-C 桥接头文件中，<code>import</code>任何你想暴露给 Swift 的头文件，例如：</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &#34;XYZCustomCell.h&#34;&#10;#import &#34;XYZCustomView.h&#34;&#10;#import &#34;XYZCustomViewController.h&#34;</span><br></pre></td></tr></table></figure>
<ol>
<li>确保在 <code>Build Settings</code> 中 Objective-C 桥接头文件的 <code>build setting</code> 是基于 Swfit 编译器，即 <code>Code Generation</code> 含有头文件的路径。这个路径必须是头文件自身的路径，而不是它所在的目录。</li>
</ol>
<p>这个路径应该是你工程的相对路径，类似 <code>Info.plist</code> 在 <code>Build Settings</code> 中指定的路径。在大多数情况下，你不需要修改这个设置。</p>
<p>在这个桥接头文件中列出的所有 public 的 Objective-C 头文件都会对 Swift 可见。之后当前 target 的所有 Swift 文件都可以使用这些头文件中的方法，不需要任何 import 语句。用 Swift 语法使用这些 Objective-C 代码，就像使用系统自带的 Swift 类一样。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myCell = <span class="type">XYZCustomCell</span>()</span><br><span class="line">myCell.subtitle = <span class="string">"A custom cell"</span></span><br></pre></td></tr></table></figure>
<h3 id="将_Swift_导入到_Objective-C">将 Swift 导入到 Objective-C</h3><p>当你在将 Swift 代码导入到 Objective-C 中时，你依赖于 Xcode 生成的头文件来将这些文件暴漏给 Objective-C。这个自动生成的文件是一个 Objective-C 头文件，它包含了你的 target 中所有 Swift 代码中定义的接口。可以把这个 Objective-C 头文件看作 Swift 代码的 <code>umbrella header</code>。头文件名称以 product 模块名加 <code>-Swift.h</code> 来命名。（关于 product 的模块名，详见<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_85" target="_blank" rel="external">Naming Your Product Module</a>）。</p>
<p>默认情况下，生成的头文件包含了标记有<code>public</code>修饰符的 Swift 声明接口。它还包含那些打上，如果您的应用程序的目标有一个Objective-C的桥接头内部修改。标有private修饰符声明不会出现在所生成的报头。私人声明没有接触到Objective-C的，除非它们被明确标有@IBAction，@IBOutlet，或@objc为好。如果您的应用程序的目标是编译测试启用，单元测试目标可以访问任何声明与内部修饰，仿佛他们与公众修饰符通过预先@testable的产品模块导入语句声明。</p>
<p>你不需要做任何事情来生成这个头文件，只需要将它导入到你的 Objective-C 代码来使用它。注意这个头文件中的 Swift 接口包含了它所使用到的所有 Objective-C 类型。如果你在 Swift 代码中使用你自己的 Objective-C 类型，确保先将对应的 Objective-C 头文件导入到你的 Swift 代码中，然后才将 Swift 自动生成的头文件导入到 Objective-C .m 源文件中来访问 Swift 代码。</p>
<h5 id="在同一_target_中将_Swift_代码导入到_Objective-C_中">在同一 target 中将 Swift 代码导入到 Objective-C 中</h5><ul>
<li>在相同 target 的 Objective-C .m 源文件中，用下面的语法来导入Swift 代码：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &#34;ProductModuleName-Swift.h&#34;</span><br></pre></td></tr></table></figure>
<p>target 中任何 Swift 文件将会对 Objective-C .m 源文件可见，包括这个 import 语句。关于在 Objective-C 代码中使用 Swift 代码，详见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_84" target="_blank" rel="external">Using Swift from Objective-C</a>。</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">导入到 Swift</th>
<th style="text-align:center">导入到 Objective-C</th>
</tr>
</thead>
<tbody>
<tr>
<td>Swift 代码</td>
<td style="text-align:center">不需要import语句</td>
<td style="text-align:center">#import “ProductModuleName-Swift.h”</td>
</tr>
<tr>
<td>Objective-C 代码</td>
<td style="text-align:center">不需要import语句；需要 Objective-C bridging头文件</td>
<td style="text-align:center">#import “Header.h”</td>
</tr>
</tbody>
</table>
<p><a name="importing_code_from_within_the_same_framework_target"></a></p>
<h2 id="在同个_Framework_的_target_中导入">在同个 Framework 的 target 中导入</h2><p>如果你在写一个混合语言的框架，可能会从 Swift 代码访问 Objective-C 代码，或者反之。</p>
<h3 id="将_Objective-C_导入_Swift-1">将 Objective-C 导入 Swift</h3><p>要将一些 Objective-C 文件导入到同个框架 target 的 Swift 代码中去，你需要将这些文件导入到 Objective-C 的 <code>umbrella header</code> 来供框架使用。</p>
<h5 id="在同一_framework_中将_Objective-C_代码导入到_Swift_中">在同一 framework 中将 Objective-C 代码导入到 Swift 中</h5><p>确保将框架 target 的 <code>Build Settings &gt; Packaging &gt; Defines Module</code> 设置为 <code>Yes</code>。然后在你的 <code>umbrella header</code> 头文件中导入你想暴露给 Swift 访问的 Objective-C 头文件，例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &#60;XYZ/XYZCustomCell.h&#62;&#10;#import &#60;XYZ/XYZCustomView.h&#62;&#10;#import &#60;XYZ/XYZCustomViewController.h&#62;</span><br></pre></td></tr></table></figure>
<p>Swift 将会看到所有你在 <code>umbrella header</code> 中公开暴露出来的头文件，框架 target 中的所有 Swift 文件都可以访问你 Objective-C 文件的内容，不需要任何 import 语句。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myCell = <span class="type">XYZCustomCell</span>()</span><br><span class="line">myCell.subtitle = <span class="string">"A custom cell"</span></span><br></pre></td></tr></table></figure>
<h3 id="将_Swift_导入_Objective-C">将 Swift 导入 Objective-C</h3><p>要将一些 Swift 文件导入到同个框架的 target 的 Objective-C 代码去，你不需要导入任何东西到 <code>umbrella header</code> 文件，而是将 Xcode 为你的 Swift 代码自动生成的头文件导入到你的 Obj .m 源文件去，以便在 Objective-C 代码中访问 Swift 代码。</p>
<h5 id="在同一_framework_中将_Swift_代码导入到_Objective-C_中">在同一 framework 中将 Swift 代码导入到 Objective-C 中</h5><p>确保将框架 target 的 <code>Build Settings &gt; Packaging</code> 中的 <code>Defines Module</code> 设置为 <code>Yes</code>。用下面的语法将 Swift 代码导入到同个框架 target 下的 Objective-C .m 源文件去。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// OBJECTIVE-C&#10;#import &#60;ProductName/ProductModuleName-Swift.h&#62;</span><br></pre></td></tr></table></figure>
<p>这个 import 语句所包含的 Swift 文件都可以被同个框架 target 下的 Objective-C .m 源文件访问。关于在 Objective-C 代码中使用 Swift 代码，详见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_84" target="_blank" rel="external">Using Swift from Objective-C</a>。</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">导入到 Swift</th>
<th style="text-align:center">导入到 Objective-C</th>
</tr>
</thead>
<tbody>
<tr>
<td>Swift 代码</td>
<td style="text-align:center">不需要import语句</td>
<td style="text-align:center">#import “ProductName/ProductModuleName-Swift.h”</td>
</tr>
<tr>
<td>Objective-C 代码</td>
<td style="text-align:center">不需要import语句；需要 Objective-C umbrella头文件</td>
<td style="text-align:center">#import “Header.h”</td>
</tr>
</tbody>
</table>
<p><a name="importing_external_frameworks"></a></p>
<h2 id="导入外部_Framework">导入外部 Framework</h2><p>你可以导入外部框架，不管这个框架是纯 Objective-C，纯 Swift，还是混合语言的。import 外部框架的流程都是一样的，不管这个框架是用一种语言写的，还是包含两种语言。当你导入外部框架时，确保 <code>Build Setting &gt; Pakaging &gt; Defines Module</code> 设置为 <code>Yes</code>。</p>
<p>用下面的语法将框架导入到不同 target 的 Swift 文件中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> FrameworkName</span><br></pre></td></tr></table></figure>
<p>用下面的语法将框架导入到不同 target 的 Objective-C .m 文件中：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import FrameworkName;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">导入到 Swift</th>
<th style="text-align:center">导入到 Objective-C</th>
</tr>
</thead>
<tbody>
<tr>
<td>任意语言框架</td>
<td style="text-align:center">import FrameworkName</td>
<td style="text-align:center">@import FrameworkName;</td>
</tr>
</tbody>
</table>
<p><a name="using_swift_from_objective-c"></a></p>
<h2 id="在_Objective-C_中使用_Swift">在 Objective-C 中使用 Swift</h2><p>当你将 Swift 代码导入 Objective-C 之后，便可用常规的 Objective-C 语法来使用 Swift 类。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MySwiftClass *swiftObject = [[MySwiftClass alloc] init];&#10;[swiftObject swiftMethod];</span><br></pre></td></tr></table></figure>
<p>Swift 的类或协议必须用 <code>@objc</code>属性来标记，以便在 Objective-C 中可访问。这个 属性告诉编译器这块 Swift 代码可以从 Objective-C 代码中访问。如果你的 Swift 类是 Objective-C 类的子类，编译器会自动为你添加 <code>@objc</code>。详见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID53" target="_blank" rel="external">Swift Type Compatibility</a>。</p>
<p>你可以访问在 Swift 类或协议中使用用<code>@objc</code>属性标记的任何对象，只要该对象与 Objective-C 兼容。不包括以下 Swift 独有的特性：</p>
<ul>
<li><p>范型（Generics）</p>
</li>
<li><p>元组（Tuples）</p>
</li>
<li><p>Swift 中定义的枚举不包括<code>Int</code>原始值类型（Enumerations defined in Swift without Int raw value type）</p>
</li>
<li><p>Swift 中定义的结构体（Structures defined in Swift）   </p>
</li>
<li><p>Swift 中定义的顶层函数（Top-level functions defined in Swift）</p>
</li>
<li><p>Swift 中定义的全局变量（Global variables defined in Swift）</p>
</li>
<li><p>Swift 中定义的类型别名（Typealiases defined in Swift）</p>
</li>
<li><p>Swift风格可变参数（Swift-style variadics）</p>
</li>
<li><p>嵌套类型（Nested types）</p>
</li>
<li><p>柯里化函数（Curried functions）</p>
</li>
</ul>
<p>例如，使用范型类型作为参数，或者返回元组的方法将不能在 Objective-C 中使用。</p>
<blockquote>
<p>注意<br>你不能在 Objective-C 继承一个 Swift 类。</p>
</blockquote>
<h3 id="在_Objective-C_头文件中引用_Swift_类">在 Objective-C 头文件中引用 Swift 类</h3><p>这样前向声明 Swift 类：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// OBJECTIVE-C&#10;// MyObjective-CClass.h&#10;&#10;@class MySwiftClass;&#10;&#10;@interface MyObjective-CClass : NSObject&#10;- (MySwiftClass *)returnSwiftObject;&#10;/* ... */&#10;@end</span><br></pre></td></tr></table></figure>
<p><a name="overriding_swift_names_for_Objective-C_interfaces"></a></p>
<h2 id="为_Objective-C_接口重写_Swift_名称">为 Objective-C 接口重写 Swift 名称</h2><p>Swift 编译器自动的将 Objective-C 代码作为常规 Swift 代码导入。它将 Objective-C 的类工厂方法作为 Swift 构造器导入，以及将 Objective-C 的枚举类型名称截断处理。</p>
<p>在你的代码中也许存在不能够被自动处理的边界情况。如果你需要更改导入到 Swift 中的 Objective-C 方法，枚举，或者可选 set 值，你可以使用<code>NS_SWIFT_NAME</code>宏来自定义导入的声明。</p>
<h3 id="类工厂方法">类工厂方法</h3><p>如果 Swift 编译器无法识别类工厂方法，你可以使用<code>NS_SWIFT_NAME</code>宏，来正确导入构造器的 Swift 签名。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)recordWithRPM:(NSUInteger)RPM NS_SWIFT_NAME(init(RPM:));</span><br></pre></td></tr></table></figure>
<p>如果 Swift 编译器错误的将一个方法识别为类工厂方法，你可以使用<code>NS_SWIFT_NAME</code>宏，来正确导入构造器的 Swift 签名。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(id)recordWithQuality:(double)quality NS_SWIFT_NAME(record(quality:));</span><br></pre></td></tr></table></figure>
<h3 id="枚举">枚举</h3><p>默认情况下，Swift 将枚举值的名称前缀做截断来导入枚举。如果要自定义枚举值的名称，你可以使用<code>NS_SWIFT_NAME</code>宏来传递 Swift 枚举值名称。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, ABCRecordSide) &#123;&#10;  ABCRecordSideA,&#10;  ABCRecordSideB NS_SWIFT_NAME(&#34;FlipSide&#34;),&#10;&#125;;</span><br></pre></td></tr></table></figure>
<p><a name="naming_your_product_module"></a></p>
<h2 id="Product_模块命名">Product 模块命名</h2><p>Xcode 为 Swift 代码生成的头文件的名称，以及 Xcode 创建的 Objective-C 桥接头文件名称，都是从你的 product 模块名生成的。默认你的 product 模块名和 product 名一样。然而，如果你的 product 名有特殊字符（nonalphanumeric，非数字、字母的字符），例如点号，那么它们会被下划线（<code>_</code>）替换之后作为你的 product 模块名。如果 product 名以数字开头，那么第一个数字会用下划线替换掉。</p>
<p>你可以给 product 模块名提供一个自定义的名称，Xcode 会用这个名称来命名桥接的和自动生成的头文件。你只需要在修改在 <code>build setting</code> 中的 <code>Product Module Name</code> 即可。</p>
<p><a name="troubleshooting_tips_and_reminders"></a></p>
<h2 id="问题解决提示">问题解决提示</h2><ul>
<li>把 Swift 和 Objective-C 文件看作相同的代码集合，并注意命名冲突。</li>
<li>如果你使用了框架，确保在<code>Packaging</code>下的<code>Defines Module</code>编译设置被设置为 <code>Yes</code>。</li>
<li>如果你使用了 Objective-C 桥接头文件，确保 Swift 编译器中 Objective-C 桥接头文件的编译设置<code>Code Generation</code>有一个与项目相关的头文件的路径。这个路径必须是头文件自身的路径，而不是它所在的目录。</li>
<li>Xcode 使用你的工程模块名，而不是以<code>target</code>的名称来命名 Objective-C 桥接头文件以及为 Swift 代码 自动生成的头文件。详见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-ID138" target="_blank" rel="external">Naming Your Product Module</a>。</li>
<li>为了在 Objective-C 中可用， Swift 类必须是 Objective-C 类的子类，或者用 <code>@objc</code> 标记。</li>
<li>当你将 Swift 导入到 Objective-C 中时，记住 Objective-C 不会将 Swift 独有的特性转化成 Objective-C 对应的特性。详见列表 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-ID136" target="_blank" rel="external">Using Swift from Objective-C</a>。</li>
<li>如果你在 Swift 代码中使用你自己的 Objective-C 类型，确保先将对应的 Objective-C 头文件导入到你的 Swift 代码中，然后才将 Swift 自动生成的头文件导入到 Objective-C .m 源文件中来访问 Swift 代码。</li>
<li>用<code>private</code>修饰符标记的 Swift 声明不会出现在自动生成的头文件中。私有声明不会暴漏给 Objective-C，除非它们被明确标记有<code>@IBAction</code>，<code>@IBOutlet</code>或者<code>@objc</code>等。</li>
<li>对于应用 targets 而言，如果有 Objective-C 桥接头文件时，被<code>internal</code>修饰符标记的声明会出现在自动产生的头文件中。</li>
<li>对于框架 targets 而言，只有被<code>public</code>修饰符标记的声明才会出现在自动生成的头文件中。你仍然可以在框架中的 Objective-C 部分使用被<code>internal</code>修饰符标记的 Swift 方法和属性，只要它们声明所在的类继承自 Objective-C 类。关于访问级别修饰符的更多信息，请查看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097" target="_blank" rel="external">The Swift Programming Language</a>中的<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html#//apple_ref/doc/uid/TP40014097-CH41" target="_blank" rel="external">访问控制(Access Control)</a></li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/04Migration/Migrating Your Objective-C Code to Swift/" itemprop="url">
                04Migration-01为你的Objective-c代码做好迁移准备
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-26T22:00:04+08:00" content="2015-12-26">
            2015-12-26
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Using-Swift-with-Cocoa-and-Objective-C/" itemprop="url" rel="index">
                  <span itemprop="name">Using-Swift-with-Cocoa-and-Objective-C</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/04Migration/Migrating Your Objective-C Code to Swift/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/04Migration/Migrating Your Objective-C Code to Swift/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><blockquote>
<p>翻译：<a href="https://github.com/xudeheng" target="_blank" rel="external">xudeheng</a></p>
<p>校对：<a href="http://github.com/dabing1022" target="_blank" rel="external">ChildhoodAndy</a></p>
</blockquote>
<h1 id="将_Objective-C_代码迁移到_Swift">将 Objective-C 代码迁移到 Swift</h1><hr>
<p>本节内容包括：</p>
<ul>
<li><a href="#preparing_your_objective-c_code_for_migration">为你的Objective-c代码做好迁移准备<br>（Preparing Your Objective-C Code for Migration）</a></li>
<li><a href="#the_migration_process">迁移过程（The Migration Process）</a></li>
<li><a href="#troubleshooting_tips_and_reminders">问题解决提示（Troubleshooting Tips and Reminders）</a></li>
</ul>
<p>迁移工作提供了一个重新审视现有 Objective-C 应用程序的机会，并通过 替换部分Swift 代码来更好的优化应用程序的架构，逻辑以及性能。换句话说，所谓增量app迁移，就是让你使用之前的工具-mix and match 来提升相互之间的可操作性。当要选择哪些特性和功能来用 Swift，哪些依然用 Objective-C 实现时，Mix-and-match让这一切变得简单。Swift 和 Objective-C 的互用性又使得将这些功能集成到 Objective-C 变得并不困难。通过这些工具可以开放 Swift 的扩展功能并集成到现有的 Objective-C 项目中而完全不必立刻使用 Swift 重写整个项目。</p>
<p><a name="preparing_your_objective-c_code_for_migration"></a></p>
<h2 id="为你的Objective-C代码做好迁移准备">为你的Objective-C代码做好迁移准备</h2><p>在开始迁移你的代码之前，请确保你的 Objective-C 和 Swift 代码间有着最佳兼容性。这意味着整理并使用 Objective-C 的现代化特性来优化你的现有项目。为了和 Swift 进行更容易的无缝交互，你的现有代码需要遵循现代编码实践。在开始前，有个简短的适配练习列表，参看<a href="https://developer.apple.com/library/prerelease/ios/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html#//apple_ref/doc/uid/TP40014150" target="_blank" rel="external">Adopting Mordern Objective-C</a>。</p>
<p><a name="the_migration_process"></a></p>
<h2 id="迁移过程">迁移过程</h2><p>最有效迁移代码的方式是基于逐个文件，即一次完成一个类。由于你不能在 Objective-C 中继承 Swift类， 最好选择一个没有子类的（译者：从类的继承角度来看，应该先从类族树的叶子节点开始，自底向上的进行迁移操作）。你就可以用单个<code>.swift</code>文件来代替对应的<code>.m</code>和<code>.h</code>文件了。你所有的实现代码和接口将直接放进单个 Swift 文件。你不用再创建头文件了；Xcode 会在你需要引用的时候自动生成头文件。(译者：当然这是在xcode内部机制完成的了，对开发者是透明的)</p>
<h3 id="准备工作">准备工作</h3><ul>
<li>在 Xcode 中:File&gt;New&gt;File&gt;(iOS 或者 OS X) &gt; Other &gt; Swift 为对应的 Objective-C<code>.m</code> 和<code>.h</code>文件创建一个 Swift 类。</li>
<li>导入相关系统框架。</li>
<li>如果你希望在 Swift 文件中访问 Objective-C 代码的话，可以填入一个 Objective-C 桥接头。具体的操作步骤，请看 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_77" target="_blank" rel="external">Importing Code from Within the Same App Target</a>。</li>
<li>为使你的 Swift 类能在 Objective-C 中访问使用，可以继承 Objective-C 类，或者标记上<code>@objc</code>属性。为类指定特殊的名称，以在 Objective-C 中使用，标记上<code>@objc(#name#)</code>, <code>&lt;#name#&gt;</code>就是在 Objective-C 中引用的 Swift 类名。 更多信息，请看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-XID_36" target="_blank" rel="external">Swift Type Compatibility</a>。</li>
</ul>
<h3 id="开始工作">开始工作</h3><ul>
<li>你可以通过继承 Objective-C 类，适配 Objective-C 协议，或者更多的方式，来让 Swift 类集成  Objective-C 行为。更多信息，请看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WritingSwiftClassesWithObjective-CBehavior.html#//apple_ref/doc/uid/TP40014216-CH5-XID_54" target="_blank" rel="external">Writing Swift Classes with Objective-C Behavior</a></li>
<li>当你使用 Objective-C APIs 的时候，你需要知道 Swift 是怎样来翻译某些 Objective-C 特性的。更多信息，请看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-XID_26" target="_blank" rel="external">Interacting with Objective-C APIs</a></li>
<li>当用 Swift 编写用到 Cocoa 框架的代码时，记住某些类型是被桥接的，意味着你可以使用某些 Swift 类型来替代 Objective-C 类型。更多信息，请看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-XID_40" target="_blank" rel="external">Working with Cocoa Data Types</a></li>
<li>当你在 Swift 中运用 Cocoa设计模式得时候，请看 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-XID_5" target="_blank" rel="external">Adopting Cocoa Design Patterns</a>获取更多的通用设计模式的转换信息。</li>
<li>对于打算将项目从 Objective-C 转换到 Swfit 的人，请看 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13" target="_blank" rel="external">Properties</a>。</li>
<li>在必要的时候，请为 Swift 的属性或方法，通过<code>@objc(&lt;#name#&gt;)</code>属性来提供 Objective-C 名称，就像这样：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> enabled: <span class="type">Bool</span> &#123;</span><br><span class="line">	<span class="preprocessor">@objc</span>(isEnabled) <span class="keyword">get</span> &#123;</span><br><span class="line">		<span class="comment">/* ... */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>分别用<code>func</code>和<code>class func</code>来表示 instance(-) 和 class(+) 方法。</li>
<li>声明简单的宏来作为常量，将复杂的宏转换为函数。</li>
</ul>
<h3 id="大功告成">大功告成</h3><ul>
<li>在你的 Objective-C 代码中更新 import 语句为 #import “模块名-Swift.h”，可参阅<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_77" target="_blank" rel="external">Importing Code from Within the Same App Target</a>中曾有提到。</li>
<li>在Target 的成员选择框中去掉勾选框来移除原始的 Objective-C<code>.m</code>文件.不要立刻删除<code>.m</code>和<code>.h</code>文件，以备解决问题用。</li>
<li>如果你给 Swift 类起了一个不同的名字，请使用 Swift 类名代替 Objective-C 名。</li>
</ul>
<p><a name="troubleshooting_tips_and_reminders"></a></p>
<h2 id="问题解决提示">问题解决提示</h2><p>尽管对于不同的项目，迁移的经历是不尽相同的，无论怎样，都有一些通用的步骤和工具能帮你解决代码迁移时碰到的问题：</p>
<ul>
<li>记住：你不能在 Objective-C 中继承 Swift 类。因此，被你迁移的类不能有任何的 Objective-C 子类存在于你的应用中。</li>
<li>当你迁移一个类到 Swift 的时候，你必须从 target 中移除相关的<code>.m</code>文件，以避免编译时提示出现重复的符号等编译错误。</li>
<li>为了在 Objective-C 中可以访问并使用，Swift 类必须是一个 Objective-C 类的子类，或者被标记为<code>@objc</code>。</li>
<li>当你在 Objective-C 中使用 Swift 代码的时候，记住 Objective-C 不能理解那些 Swift 的某些特性，请看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_84" target="_blank" rel="external">Using Swift from Objective-C</a>。</li>
<li>可以通过<code>Commond + 单击</code>一个 Swift 类名来查看它生成的头文件。</li>
<li>可以通过<code>Option + 单击</code>一个符号来查看更详细的信息，比如它的类型，属性以及文档注释等。</li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/05Revision History/Document Revision History/" itemprop="url">
                05Revision History-Document Revision History
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-26T22:00:03+08:00" content="2015-12-26">
            2015-12-26
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Using-Swift-with-Cocoa-and-Objective-C/" itemprop="url" rel="index">
                  <span itemprop="name">Using-Swift-with-Cocoa-and-Objective-C</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/05Revision History/Document Revision History/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/05Revision History/Document Revision History/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="文档修订历史">文档修订历史</h1><p>该表格描述了 Using Swift with Cocoa and Objective-C 一书的改动。</p>
<table class="graybox" border="0" cellspacing="0" cellpadding="5"><br><thead><br>    <tr><br>        <th scope="col" width="100">日期</th><br>       <th scope="col">变更记录</th><br>    </tr><br></thead><br><tbody><br>    <tr><br>    <td scope="row">2015-06-08</td><br>    <td><ul class="list-bullet"><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID35" target="_blank" rel="external"> Interacting with Objective-C APIs </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WritingSwiftClassesWithObjective-CBehavior.html#//apple_ref/doc/uid/TP40014216-CH5-ID152" target="_blank" rel="external"> NSCoding </a>部分。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID61" target="_blank" rel="external"> Working with Cocoa Data Types </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID83" target="_blank" rel="external"> Memory Managed Objects </a>部分。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID61" target="_blank" rel="external"> Working with Cocoa Data Types </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID151" target="_blank" rel="external"> Sets </a>部分。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216-CH2-ID2" target="_blank" rel="external"> Setting Up Your Swift Environment </a>中补充说明有关由命令行建立的可执行文件的 Swift target 系统要求。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID35" target="_blank" rel="external"> Interacting with Objective-C APIs </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID45" target="_blank" rel="external"> Nullability and Optionals </a>部分。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID35" target="_blank" rel="external"> Interacting with Objective-C APIs </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-ID170" target="_blank" rel="external"> Unions </a>部分。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID35" target="_blank" rel="external"> Interacting with Objective-C APIs </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-ID169" target="_blank" rel="external"> Option Sets </a>部分。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-ID6" target="_blank" rel="external"> Adopting Cocoa Design Patterns </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-ID160" target="_blank" rel="external"> API Availability </a>部分。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID35" target="_blank" rel="external"> Interacting with Objective-C APIs </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-ID162" target="_blank" rel="external"> Overriding Swift Names for Objective-C Interfaces </a>部分。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-ID6" target="_blank" rel="external"> Adopting Cocoa Design Patterns </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-ID10" target="_blank" rel="external"> Error Handling </a>部分。<br>        </p></li><br>        <li><p><br>        更新<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-ID122" target="_blank" rel="external"> Swift and Objective-C in the Same Project </a>章节中关于 @testable 注解的信息。<br>        </p></li><br>        <li><p><br>        更新<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-ID148" target="_blank" rel="external"> Function Pointers </a>章节中关于将 Swift 函数和闭包与 C 函数指针桥接的信息。<br>        </p></li><br>        <li><p><br>        更新<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-ID146" target="_blank" rel="external"> Constant Pointers </a>章节中关于将 Swift String 值与 C 指针桥接的信息。<br>        </p></li><br>        <li><p><br>        更新<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID55" target="_blank" rel="external"> Exposing Swift Interfaces in Objective-C </a>章节中关于在 Swift 中使用 @objc 来标注枚举的信息。<br>        </p></li><br>        <li><p><br>        更新<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID69" target="_blank" rel="external"> Collection Classes </a>章节，讨论 Swift 对 Objective-C 集合类的参数化桥接。<br>        </p></li><br>        </ul><br>    </td><br>  </tr><br><br>      <tr><br>    <td scope="row">2015-02-23</td><br>    <td><ul class="list-bullet"><br>        <li><p><br>        更新<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID61" target="_blank" rel="external"> Working with Cocoa Data Types </a>章节，在 Swift 1.2 中使用 as! 操作符和桥接语义。<br>        </p></li><br>        </ul><br>    </td><br>   </tr><br><br>    <tr><br>    <td scope="row">2015-01-18</td><br>    <td><ul class="list-bullet"><br>        <li><p><br>        修复了 UIBezierPath 例子以正确的创建一个三角形<br>        </p></li><br>        </ul><br>    </td><br>   </tr><br><br>    <tr><br>    <td scope="row">2015-01-18</td><br>    <td><ul class="list-bullet"><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID35" target="_blank" rel="external"> Interacting with Objective-C APIs </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID145" target="_blank" rel="external"> Failable Initialization </a>部分。<br><br>        </p></li><br>        </ul><br>    </td><br>   </tr><br><br>       <tr><br>    <td scope="row">2014-09-02</td><br>    <td><ul class="list-bullet"><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WritingSwiftClassesWithObjective-CBehavior.html#//apple_ref/doc/uid/TP40014216-CH5-ID86" target="_blank" rel="external"> Writing Swift Classes with Objective-C Behavior </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WritingSwiftClassesWithObjective-CBehavior.html#//apple_ref/doc/uid/TP40014216-CH5-ID107" target="_blank" rel="external"> Using Swift Class Names with Objective-C APIs </a>部分。<br>        </p></li><br>        <li><p><br>        纠正<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WritingSwiftClassesWithObjective-CBehavior.html#//apple_ref/doc/uid/TP40014216-CH5-ID98" target="_blank" rel="external"> Live Rendering </a>只对编译在框架中的 designable 类生效的陈述。这个限制已经不再存在。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-ID12" target="_blank" rel="external"> Key-Value Observing </a>中添加对 deinit 的实现以及以往代码中对 super 的调用。<br>        </p></li><br>        </ul><br>    </td><br>   </tr><br></tbody><br></table>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/26/swift-cn/SUMMARY/" itemprop="url">
                Summary
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-26T12:00:00+08:00" content="2015-12-26">
            2015-12-26
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn/</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/26/swift-cn/SUMMARY/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/26/swift-cn/SUMMARY/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="Summary">Summary</h1><ul>
<li><a href="/2015/12/25/swift-cn/chapter1/chapter1/">欢迎使用 Swift</a><ul>
<li><a href="/2015/12/25/swift-cn/chapter1/01_swift/">关于 Swift</a></li>
<li><a href="/2015/12/25/swift-cn/chapter1/02_a_swift_tour/">Swift 初见</a></li>
<li><a href="/2015/12/25/swift-cn/chapter1/03_revision_history/">Swift 版本历史记录</a></li>
<li><a href="v1.0/">Swift 1.0 发布内容</a></li>
</ul>
</li>
<li><a href="/2015/12/25/swift-cn/chapter2/chapter2/">Swift 教程</a><ul>
<li><a href="/2015/12/25/swift-cn/chapter2/01_The_Basics/">基础部分</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/02_Basic_Operators/">基本运算符</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/03_Strings_and_Characters/">字符串和字符</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/04_Collection_Types/">集合类型</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/05_Control_Flow/">控制流</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/06_Functions/">函数</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/07_Closures/">闭包</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/08_Enumerations/">枚举</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/09_Classes_and_Structures/">类和结构体</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/10_Properties/">属性</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/11_Methods/">方法</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/12_Subscripts/">下标脚本</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/13_Inheritance/">继承</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/14_Initialization/">构造过程</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/15_Deinitialization/">析构过程</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/16_Automatic_Reference_Counting/">自动引用计数</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/17_Optional_Chaining/">可选链</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/18_Error_Handling/">错误处理</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/19_Type_Casting/">类型转换</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/20_Nested_Types/">嵌套类型</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/21_Extensions/">扩展</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/22_Protocols/">协议</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/23_Generics/">泛型</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/24_Access_Control/">访问控制</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/25_Advanced_Operators/">高级运算符</a></li>
</ul>
</li>
<li>语言参考<ul>
<li><a href="/2015/12/25/swift-cn/chapter3/01_About_the_Language_Reference/">关于语言参考</a></li>
<li><a href="/2015/12/25/swift-cn/chapter3/02_Lexical_Structure/">词法结构</a></li>
<li><a href="/2015/12/25/swift-cn/chapter3/03_Types/">类型</a></li>
<li><a href="/2015/12/25/swift-cn/chapter3/04_Expressions/">表达式</a></li>
<li><a href="/2015/12/25/swift-cn/chapter3/10_Statements/">语句</a></li>
<li><a href="/2015/12/25/swift-cn/chapter3/05_Declarations/">声明</a></li>
<li><a href="/2015/12/25/swift-cn/chapter3/06_Attributes/">特性</a></li>
<li><a href="/2015/12/25/swift-cn/chapter3/07_Patterns/">模式</a></li>
<li><a href="/2015/12/25/swift-cn/chapter3/08_Generic_Parameters_and_Arguments/">泛型参数</a></li>
<li><a href="/2015/12/25/swift-cn/chapter3/09_Summary_of_the_Grammar/">语法总结</a></li>
</ul>
</li>
<li>苹果官方Blog官方翻译<ul>
<li><a href="/2015/12/25/swift-cn/chapter4/01_Access_Control/">Access Control 权限控制的黑与白</a></li>
<li><a href="/2015/12/25/swift-cn/chapter4/02_Type_Custom/">造个类型不是梦-白话Swift类型创建</a></li>
<li><a href="/2015/12/25/swift-cn/chapter4/03_Ballons/">WWDC里面的那个“大炮打气球”</a></li>
<li><a href="/2015/12/25/swift-cn/chapter4/04_Interacting_with_C_Pointers/">Swift与C语言指针友好合作</a></li>
<li><a href="/2015/12/25/swift-cn/chapter4/05_Value_and_Reference_Types/">引用类型和值类型的恩怨</a></li>
<li><a href="/2015/12/25/swift-cn/chapter4/06_Access_Control_and_Protected/">访问控制和Protected</a></li>
<li><a href="/2015/12/25/swift-cn/chapter4/07_Optional_Case_Study/">可选类型完美解决占位问题</a></li>
</ul>
</li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter1/01_swift/" itemprop="url">
                第一章-01关于 Swift（About Swift）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T23:00:00+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter1/01_swift/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter1/01_swift/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="关于_Swift（About_Swift）">关于 Swift（About Swift）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a><br>校对：<a href="https://github.com/yeahdongcn" target="_blank" rel="external">yeahdongcn</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/xtymichael" target="_blank" rel="external">xtymichael</a></p>
</blockquote>
<p>Swift 是一种新的编程语言，用于编写 iOS，OS X 和 watchOS应用程序。Swift 结合了 C 和 Objective-C 的优点并且不受 C 兼容性的限制。Swift 采用安全的编程模式并添加了很多新特性，这将使编程更简单，更灵活，也更有趣。Swift 是基于成熟而且倍受喜爱的 Cocoa 和 Cocoa Touch 框架，它的降临将重新定义软件开发。</p>
<p>Swift 的开发从很久之前就开始了。为了给 Swift 打好基础，苹果公司改进了编译器，调试器和框架结构。我们使用自动引用计数（Automatic Reference Counting, ARC）来简化内存管理。我们在 Foundation 和 Cocoa 的基础上构建框架栈使其完全现代化和标准化。<br>Objective-C 本身支持块、集合语法和模块，所以框架可以轻松支持现代编程语言技术。正是得益于这些基础工作，我们现在才能发布这样一个用于未来苹果软件开发的新语言。</p>
<p>Objective-C 开发者对 Swift 并不会感到陌生。它采用了 Objective-C 的命名参数以及动态对象模型，可以无缝对接到现有的 Cocoa 框架，并且可以兼容 Objective-C 代码。在此基础之上，Swift 还有许多新特性并且支持过程式编程和面向对象编程。</p>
<p>Swift 对于初学者来说也很友好。它是第一个既满足工业标准又像脚本语言一样充满表现力和趣味的脚本语言。它支持代码预览，这个革命性的特性可以允许程序员在不编译和运行应用程序的前提下运行 Swift 代码并实时查看结果。</p>
<p>Swift 将现代编程语言的精华和苹果工程师文化的智慧结合了起来。编译器对性能进行了优化，编程语言对开发进行了优化，两者互不干扰，鱼与熊掌兼得。Swift 既可以用于开发 “hello, world” 这样的小程序，也可以用于开发一套完整的操作系统。所有的这些特性让 Swift 对于开发者和苹果来说都是一项值得的投资。</p>
<p>Swift 是编写 iOS，OS X 和 watchOS应用的极佳手段，并将伴随着新的特性和功能持续演进。我们对 Swift 充满信心，你还在等什么！</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter1/chapter1/" itemprop="url">
                第一章-欢迎使用 Swift
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T20:00:00+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter1/chapter1/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter1/chapter1/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="欢迎使用_Swift">欢迎使用 Swift</h1><p>在本章中您将了解 Swift 的特性和开发历史，并对 Swift 有一个初步的了解。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/01_The_Basics/" itemprop="url">
                第二章-01基础部分（The Basics）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:26+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/01_The_Basics/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/01_The_Basics/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="基础部分（The_Basics）">基础部分（The Basics）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>, <a href="https://github.com/lyuka" target="_blank" rel="external">lyuka</a>, <a href="https://github.com/JaySurplus" target="_blank" rel="external">JaySurplus</a><br>校对：<a href="https://github.com/lslxdx" target="_blank" rel="external">lslxdx</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/xtymichael" target="_blank" rel="external">xtymichael</a></p>
<p>2.1<br>翻译：<a href="https://github.com/futantan" target="_blank" rel="external">Prayer</a><br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#constants_and_variables">常量和变量</a></li>
<li><a href="#declaring">声明常量和变量</a></li>
<li><a href="#type_annotations">类型标注</a></li>
<li><a href="#naming">常量和变量的命名</a></li>
<li><a href="#printing">输出常量和变量</a></li>
<li><a href="#comments">注释</a></li>
<li><a href="#semicolons">分号</a></li>
<li><a href="#integers">整数</a></li>
<li><a href="#integer_bounds">整数范围</a></li>
<li><a href="#Int">Int</a></li>
<li><a href="#UInt">UInt</a></li>
<li><a href="#floating-point_numbers">浮点数</a></li>
<li><a href="#type_safety_and_type_inference">类型安全和类型推断</a></li>
<li><a href="#numeric_literals">数值型字面量</a></li>
<li><a href="#numeric_type_conversion">数值型类型转换</a></li>
<li><a href="#integer_conversion">整数转换</a></li>
<li><a href="#integer_and_floating_point_conversion">数整数和浮点数转换</a></li>
<li><a href="#type_aliases">类型别名</a></li>
<li><a href="#booleans">布尔值</a></li>
<li><a href="#tuples">元组</a></li>
<li><a href="#optionals">可选</a></li>
<li><a href="#nil">nil</a></li>
<li><a href="#if">if 语句以及强制解析</a></li>
<li><a href="#optional_binding">可选绑定</a></li>
<li><a href="#implicityly_unwrapped_optionals">隐式解析可选类型</a></li>
<li><a href="#error_handling">错误处理</a></li>
<li><a href="#assertions">断言</a></li>
</ul>
<p>Swift 是一门开发 iOS, OS X 和 watchOS 应用的新语言。然而，如果你有 C 或者 Objective-C 开发经验的话，你会发现 Swift 的很多内容都是你熟悉的。</p>
<p>Swift 包含了 C 和 Objective-C 上所有基础数据类型，<code>Int</code>表示整型值；<code>Double</code>和<code>Float</code>表示浮点型值；<code>Bool</code>是布尔型值；<code>String</code>是文本型数据。Swift 还提供了三个基本的集合类型，<code>Array</code>，<code>Set</code>和<code>Dictionary</code>，详见<a href="04_Collection_Types.html">集合类型</a>。</p>
<p>就像 C 语言一样，Swift 使用变量来进行存储并通过变量名来关联值。在 Swift 中，广泛的使用着值不可变的变量，它们就是常量，而且比 C 语言的常量更强大。在 Swift 中，如果你要处理的值不需要改变，那使用常量可以让你的代码更加安全并且更清晰地表达你的意图。</p>
<p>除了我们熟悉的类型，Swift 还增加了 Objective-C 中没有的高阶数据类型比如元组（Tuple）。元组可以让你创建或者传递一组数据，比如作为函数的返回值时，你可以用一个元组可以返回多个值。</p>
<p>Swift 还增加了可选（Optional）类型，用于处理值缺失的情况。可选表示“那儿有一个值，并且它等于 x ”或者“那儿没有值”。可选有点像在 Objective-C 中使用<code>nil</code>，但是它可以用在任何类型上，不仅仅是类。可选类型比 Objective-C 中的<code>nil</code>指针更加安全也更具表现力，它是 Swift 许多强大特性的重要组成部分。</p>
<p>Swift 是一门类型安全的语言，可选类型就是一个很好的例子。Swift 可以让你清楚地知道值的类型。如果你的代码期望得到一个<code>String</code>，类型安全会阻止你不小心传入一个<code>Int</code>。你可以在开发阶段尽早发现并修正错误。</p>
<p><a name="constants_and_variables"></a></p>
<h2 id="常量和变量">常量和变量</h2><p>常量和变量把一个名字（比如<code>maximumNumberOfLoginAttempts</code>或者<code>welcomeMessage</code>）和一个指定类型的值（比如数字<code>10</code>或者字符串<code>&quot;Hello&quot;</code>）关联起来。常量的值一旦设定就不能改变，而变量的值可以随意更改。</p>
<p><a name="declaring"></a></p>
<h3 id="声明常量和变量">声明常量和变量</h3><p>常量和变量必须在使用前声明，用<code>let</code>来声明常量，用<code>var</code>来声明变量。下面的例子展示了如何用常量和变量来记录用户尝试登录的次数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> maximumNumberOfLoginAttempts = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> currentLoginAttempt = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这两行代码可以被理解为：</p>
<p>“声明一个名字是<code>maximumNumberOfLoginAttempts</code>的新常量，并给它一个值<code>10</code>。然后，声明一个名字是<code>currentLoginAttempt</code>的变量并将它的值初始化为<code>0</code>。”</p>
<p>在这个例子中，允许的最大尝试登录次数被声明为一个常量，因为这个值不会改变。当前尝试登录次数被声明为一个变量，因为每次尝试登录失败的时候都需要增加这个值。</p>
<p>你可以在一行中声明多个常量或者多个变量，用逗号隔开：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span>, z = <span class="number">0.0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>如果你的代码中有不需要改变的值，请使用<code>let</code>关键字将它声明为常量。只将需要改变的值声明为变量。</p>
</blockquote>
<p><a name="type_annotations"></a></p>
<h3 id="类型标注">类型标注</h3><p>当你声明常量或者变量的时候可以加上类型标注（type annotation），说明常量或者变量中要存储的值的类型。如果要添加类型标注，需要在常量或者变量名后面加上一个冒号和空格，然后加上类型名称。</p>
<p>这个例子给<code>welcomeMessage</code>变量添加了类型标注，表示这个变量可以存储<code>String</code>类型的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> welcomeMessage: <span class="type">String</span></span><br></pre></td></tr></table></figure>
<p>声明中的冒号代表着“是…类型”，所以这行代码可以被理解为：</p>
<p>“声明一个类型为<code>String</code>，名字为<code>welcomeMessage</code>的变量。”</p>
<p>“类型为<code>String</code>”的意思是“可以存储任意<code>String</code>类型的值。”</p>
<p><code>welcomeMessage</code>变量现在可以被设置成任意字符串：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">welcomeMessage = <span class="string">"Hello"</span></span><br></pre></td></tr></table></figure>
<p>你可以在一行中定义多个同样类型的变量，用逗号分割，并在最后一个变量名之后添加类型标注：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> red, green, blue: <span class="type">Double</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>一般来说你很少需要写类型标注。如果你在声明常量或者变量的时候赋了一个初始值，Swift可以推断出这个常量或者变量的类型，请参考<a href="#type_safety_and_type_inference">类型安全和类型推断</a>。在上面的例子中，没有给<code>welcomeMessage</code>赋初始值，所以变量<code>welcomeMessage</code>的类型是通过一个类型标注指定的，而不是通过初始值推断的。</p>
</blockquote>
<p><a name="naming"></a></p>
<h3 id="常量和变量的命名">常量和变量的命名</h3><p>你可以用任何你喜欢的字符作为常量和变量名，包括 Unicode 字符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> π = <span class="number">3.14159</span></span><br><span class="line"><span class="keyword">let</span> 你好 = <span class="string">"你好世界"</span></span><br><span class="line"><span class="keyword">let</span> 🐶🐮 = <span class="string">"dogcow"</span></span><br></pre></td></tr></table></figure>
<p>常量与变量名不能包含数学符号，箭头，保留的（或者非法的）Unicode 码位，连线与制表符。也不能以数字开头，但是可以在常量与变量名的其他地方包含数字。</p>
<p>一旦你将常量或者变量声明为确定的类型，你就不能使用相同的名字再次进行声明，或者改变其存储的值的类型。同时，你也不能将常量与变量进行互转。</p>
<blockquote>
<p>注意：<br>如果你需要使用与Swift保留关键字相同的名称作为常量或者变量名，你可以使用反引号（`）将关键字包围的方式将其作为名字使用。无论如何，你应当避免使用关键字作为常量或变量名，除非你别无选择。</p>
</blockquote>
<p>你可以更改现有的变量值为其他同类型的值，在下面的例子中，<code>friendlyWelcome</code>的值从<code>&quot;Hello!&quot;</code>改为了<code>&quot;Bonjour!&quot;</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> friendlyWelcome = <span class="string">"Hello!"</span></span><br><span class="line">friendlyWelcome = <span class="string">"Bonjour!"</span></span><br><span class="line"><span class="comment">// friendlyWelcome 现在是 "Bonjour!"</span></span><br></pre></td></tr></table></figure>
<p>与变量不同，常量的值一旦被确定就不能更改了。尝试这样做会导致编译时报错：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> languageName = <span class="string">"Swift"</span></span><br><span class="line">languageName = <span class="string">"Swift++"</span></span><br><span class="line"><span class="comment">// 这会报编译时错误 - languageName 不可改变</span></span><br></pre></td></tr></table></figure>
<p><a name="printing"></a></p>
<h3 id="输出常量和变量">输出常量和变量</h3><p>你可以用<code>print(_:separator:terminator:)</code>函数来输出当前常量或变量的值:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(friendlyWelcome)</span><br><span class="line"><span class="comment">// 输出 "Bonjour!"</span></span><br></pre></td></tr></table></figure>
<p><code>print(_:separator:terminator:)</code>是一个用来输出一个或多个值到适当输出区的全局函数。如果你用 Xcode，<code>print(_:separator:terminator:)</code>将会输出内容到“console”面板上。<code>separator</code>和<code>terminator</code>参数具有默认值，因此你调用这个函数的时候可以忽略它们。默认情况下，该函数通过添加换行符来结束当前行。如果不想换行，可以传递一个空字符串给<code>terminator</code>参数–例如，<code>print(someValue, terminator:&quot;&quot;)</code>。关于参数默认值的更多信息，请参考<a href="./06_Functions.html#default_parameter_values">默认参数值</a>。</p>
<p>Swift 用字符串插值（string interpolation）的方式把常量名或者变量名当做占位符加入到长字符串中，Swift 会用当前常量或变量的值替换这些占位符。将常量或变量名放入圆括号中，并在开括号前使用反斜杠将其转义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"The current value of friendlyWelcome is <span class="subst">\(friendlyWelcome)</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "The current value of friendlyWelcome is Bonjour!</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>字符串插值所有可用的选项，请参考<a href="./03_Strings_and_Characters.html#string_interpolation">字符串插值</a>。</p>
</blockquote>
<p><a name="comments"></a></p>
<h2 id="注释">注释</h2><p>请将你的代码中的非执行文本注释成提示或者笔记以方便你将来阅读。Swift 的编译器将会在编译代码时自动忽略掉注释部分。</p>
<p>Swift 中的注释与 C 语言的注释非常相似。单行注释以双正斜杠（<code>//</code>）作为起始标记:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个注释</span></span><br></pre></td></tr></table></figure>
<p>你也可以进行多行注释，其起始标记为单个正斜杠后跟随一个星号（<code>/*</code>），终止标记为一个星号后跟随单个正斜杠（<code>*/</code>）:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这是一个,</span><br><span class="line">多行注释 */</span></span><br></pre></td></tr></table></figure>
<p>与 C 语言多行注释不同，Swift 的多行注释可以嵌套在其它的多行注释之中。你可以先生成一个多行注释块，然后在这个注释块之中再嵌套成第二个多行注释。终止注释时先插入第二个注释块的终止标记，然后再插入第一个注释块的终止标记：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这是第一个多行注释的开头</span><br><span class="line"><span class="comment">/* 这是第二个被嵌套的多行注释 */</span></span><br><span class="line">这是第一个多行注释的结尾 */</span></span><br></pre></td></tr></table></figure>
<p>通过运用嵌套多行注释，你可以快速方便的注释掉一大段代码，即使这段代码之中已经含有了多行注释块。</p>
<p><a name="semicolons"></a></p>
<h2 id="分号">分号</h2><p>与其他大部分编程语言不同，Swift 并不强制要求你在每条语句的结尾处使用分号（<code>;</code>），当然，你也可以按照你自己的习惯添加分号。有一种情况下必须要用分号，即你打算在同一行内写多条独立的语句：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cat = <span class="string">"🐱"</span>; <span class="built_in">print</span>(cat)</span><br><span class="line"><span class="comment">// 输出 "🐱"</span></span><br></pre></td></tr></table></figure>
<p><a name="integers"></a></p>
<h2 id="整数">整数</h2><p>整数就是没有小数部分的数字，比如<code>42</code>和<code>-23</code>。整数可以是<code>有符号</code>（正、负、零）或者<code>无符号</code>（正、零）。</p>
<p>Swift 提供了8，16，32和64位的有符号和无符号整数类型。这些整数类型和 C 语言的命名方式很像，比如8位无符号整数类型是<code>UInt8</code>，32位有符号整数类型是<code>Int32</code>。就像 Swift 的其他类型一样，整数类型采用大写命名法。</p>
<p><a name="integer_bounds"></a></p>
<h3 id="整数范围">整数范围</h3><p>你可以访问不同整数类型的<code>min</code>和<code>max</code>属性来获取对应类型的最小值和最大值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> minValue = <span class="type">UInt8</span>.<span class="built_in">min</span>  <span class="comment">// minValue 为 0，是 UInt8 类型</span></span><br><span class="line"><span class="keyword">let</span> maxValue = <span class="type">UInt8</span>.<span class="built_in">max</span>  <span class="comment">// maxValue 为 255，是 UInt8 类型</span></span><br></pre></td></tr></table></figure>
<p><code>min</code>和<code>max</code>所传回值的类型，正是其所对的整数类型(如上例UInt8, 所传回的类型是UInt8)，可用在表达式中相同类型值旁。</p>
<p><a name="Int"></a></p>
<h3 id="Int">Int</h3><p>一般来说，你不需要专门指定整数的长度。Swift 提供了一个特殊的整数类型<code>Int</code>，长度与当前平台的原生字长相同：</p>
<ul>
<li>在32位平台上，<code>Int</code>和<code>Int32</code>长度相同。</li>
<li>在64位平台上，<code>Int</code>和<code>Int64</code>长度相同。</li>
</ul>
<p>除非你需要特定长度的整数，一般来说使用<code>Int</code>就够了。这可以提高代码一致性和可复用性。即使是在32位平台上，<code>Int</code>可以存储的整数范围也可以达到<code>-2,147,483,648</code>~<code>2,147,483,647</code>，大多数时候这已经足够大了。</p>
<p><a name="UInt"></a></p>
<h3 id="UInt">UInt</h3><p>Swift 也提供了一个特殊的无符号类型<code>UInt</code>，长度与当前平台的原生字长相同：</p>
<ul>
<li>在32位平台上，<code>UInt</code>和<code>UInt32</code>长度相同。</li>
<li>在64位平台上，<code>UInt</code>和<code>UInt64</code>长度相同。</li>
</ul>
<blockquote>
<p>注意：<br>尽量不要使用<code>UInt</code>，除非你真的需要存储一个和当前平台原生字长相同的无符号整数。除了这种情况，最好使用<code>Int</code>，即使你要存储的值已知是非负的。统一使用<code>Int</code>可以提高代码的可复用性，避免不同类型数字之间的转换，并且匹配数字的类型推断，请参考<a href="#type_safety_and_type_inference">类型安全和类型推断</a>。</p>
</blockquote>
<p><a name="floating-point_numbers"></a></p>
<h2 id="浮点数">浮点数</h2><p>浮点数是有小数部分的数字，比如<code>3.14159</code>，<code>0.1</code>和<code>-273.15</code>。</p>
<p>浮点类型比整数类型表示的范围更大，可以存储比<code>Int</code>类型更大或者更小的数字。Swift 提供了两种有符号浮点数类型：</p>
<ul>
<li><code>Double</code>表示64位浮点数。当你需要存储很大或者很高精度的浮点数时请使用此类型。</li>
<li><code>Float</code>表示32位浮点数。精度要求不高的话可以使用此类型。</li>
</ul>
<blockquote>
<p>注意：<br><code>Double</code>精确度很高，至少有15位数字，而<code>Float</code>最少只有6位数字。选择哪个类型取决于你的代码需要处理的值的范围。</p>
</blockquote>
<p><a name="type_safety_and_type_inference"></a></p>
<h2 id="类型安全和类型推断">类型安全和类型推断</h2><p>Swift 是一个<em>类型安全（type safe）</em>的语言。类型安全的语言可以让你清楚地知道代码要处理的值的类型。如果你的代码需要一个<code>String</code>，你绝对不可能不小心传进去一个<code>Int</code>。</p>
<p>由于 Swift 是类型安全的，所以它会在编译你的代码时进行<em>类型检查（type checks）</em>，并把不匹配的类型标记为错误。这可以让你在开发的时候尽早发现并修复错误。</p>
<p>当你要处理不同类型的值时，类型检查可以帮你避免错误。然而，这并不是说你每次声明常量和变量的时候都需要显式指定类型。如果你没有显式指定类型，Swift 会使用<em>类型推断（type inference）</em>来选择合适的类型。有了类型推断，编译器可以在编译代码的时候自动推断出表达式的类型。原理很简单，只要检查你赋的值即可。</p>
<p>因为有类型推断，和 C 或者 Objective-C 比起来 Swift 很少需要声明类型。常量和变量虽然需要明确类型，但是大部分工作并不需要你自己来完成。</p>
<p>当你声明常量或者变量并赋初值的时候类型推断非常有用。当你在声明常量或者变量的时候赋给它们一个字面量（literal value 或 literal）即可触发类型推断。（字面量就是会直接出现在你代码中的值，比如<code>42</code>和<code>3.14159</code>。）</p>
<p>例如，如果你给一个新常量赋值<code>42</code>并且没有标明类型，Swift 可以推断出常量类型是<code>Int</code>，因为你给它赋的初始值看起来像一个整数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> meaningOfLife = <span class="number">42</span></span><br><span class="line"><span class="comment">// meaningOfLife 会被推测为 Int 类型</span></span><br></pre></td></tr></table></figure>
<p>同理，如果你没有给浮点字面量标明类型，Swift 会推断你想要的是<code>Double</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pi = <span class="number">3.14159</span></span><br><span class="line"><span class="comment">// pi 会被推测为 Double 类型</span></span><br></pre></td></tr></table></figure>
<p>当推断浮点数的类型时，Swift 总是会选择<code>Double</code>而不是<code>Float</code>。</p>
<p>如果表达式中同时出现了整数和浮点数，会被推断为<code>Double</code>类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherPi = <span class="number">3</span> + <span class="number">0.14159</span></span><br><span class="line"><span class="comment">// anotherPi 会被推测为 Double 类型</span></span><br></pre></td></tr></table></figure>
<p>原始值<code>3</code>没有显式声明类型，而表达式中出现了一个浮点字面量，所以表达式会被推断为<code>Double</code>类型。</p>
<p><a name="numeric_literals"></a></p>
<h2 id="数值型字面量">数值型字面量</h2><p>整数字面量可以被写作：</p>
<ul>
<li>一个<em>十进制</em>数，没有前缀</li>
<li>一个<em>二进制</em>数，前缀是<code>0b</code></li>
<li>一个<em>八进制</em>数，前缀是<code>0o</code></li>
<li>一个<em>十六进制</em>数，前缀是<code>0x</code></li>
</ul>
<p>下面的所有整数字面量的十进制值都是<code>17</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decimalInteger = <span class="number">17</span></span><br><span class="line"><span class="keyword">let</span> binaryInteger = <span class="number">0b10001</span>       <span class="comment">// 二进制的17</span></span><br><span class="line"><span class="keyword">let</span> octalInteger = <span class="number">0o21</span>           <span class="comment">// 八进制的17</span></span><br><span class="line"><span class="keyword">let</span> hexadecimalInteger = <span class="number">0x11</span>     <span class="comment">// 十六进制的17</span></span><br></pre></td></tr></table></figure>
<p>浮点字面量可以是十进制（没有前缀）或者是十六进制（前缀是<code>0x</code>）。小数点两边必须有至少一个十进制数字（或者是十六进制的数字）。浮点字面量还有一个可选的指数（exponent，在十进制浮点数中通过大写或者小写的<code>e</code>来指定，在十六进制浮点数中通过大写或者小写的<code>p</code>来指定。</p>
<p>如果一个十进制数的指数为<code>exp</code>，那这个数相当于基数和10^exp的乘积：</p>
<ul>
<li><code>1.25e2</code> 表示 1.25 × 10^2，等于 <code>125.0</code>。</li>
<li><code>1.25e-2</code> 表示 1.25 × 10^-2，等于 <code>0.0125</code>。</li>
</ul>
<p>如果一个十六进制数的指数为<code>exp</code>，那这个数相当于基数和2^exp的乘积：</p>
<ul>
<li><code>0xFp2</code> 表示 15 × 2^2，等于 <code>60.0</code>。</li>
<li><code>0xFp-2</code> 表示 15 × 2^-2，等于 <code>3.75</code>。</li>
</ul>
<p>下面的这些浮点字面量都等于十进制的<code>12.1875</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decimalDouble = <span class="number">12.1875</span></span><br><span class="line"><span class="keyword">let</span> exponentDouble = <span class="number">1.21875e1</span></span><br><span class="line"><span class="keyword">let</span> hexadecimalDouble = <span class="number">0xC.3p0</span></span><br></pre></td></tr></table></figure>
<p>数值类字面量可以包括额外的格式来增强可读性。整数和浮点数都可以添加额外的零并且包含下划线，并不会影响字面量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> paddedDouble = <span class="number">000123.456</span></span><br><span class="line"><span class="keyword">let</span> oneMillion = <span class="number">1_000_000</span></span><br><span class="line"><span class="keyword">let</span> justOverOneMillion = <span class="number">1_000_000.000_000_1</span></span><br></pre></td></tr></table></figure>
<p><a name="numeric_type_conversion"></a></p>
<h2 id="数值型类型转换">数值型类型转换</h2><p>通常来讲，即使代码中的整数常量和变量已知非负，也请使用<code>Int</code>类型。总是使用默认的整数类型可以保证你的整数常量和变量可以直接被复用并且可以匹配整数类字面量的类型推断。</p>
<p>只有在必要的时候才使用其他整数类型，比如要处理外部的长度明确的数据或者为了优化性能、内存占用等等。使用显式指定长度的类型可以及时发现值溢出并且可以暗示正在处理特殊数据。</p>
<p><a name="integer_conversion"></a></p>
<h3 id="整数转换">整数转换</h3><p>不同整数类型的变量和常量可以存储不同范围的数字。<code>Int8</code>类型的常量或者变量可以存储的数字范围是<code>-128</code>~<code>127</code>，而<code>UInt8</code>类型的常量或者变量能存储的数字范围是<code>0</code>~<code>255</code>。如果数字超出了常量或者变量可存储的范围，编译的时候会报错：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cannotBeNegative: <span class="type">UInt8</span> = -<span class="number">1</span></span><br><span class="line"><span class="comment">// UInt8 类型不能存储负数，所以会报错</span></span><br><span class="line"><span class="keyword">let</span> tooBig: <span class="type">Int8</span> = <span class="type">Int8</span>.<span class="built_in">max</span> + <span class="number">1</span></span><br><span class="line"><span class="comment">// Int8 类型不能存储超过最大值的数，所以会报错</span></span><br></pre></td></tr></table></figure>
<p>由于每种整数类型都可以存储不同范围的值，所以你必须根据不同情况选择性使用数值型类型转换。这种选择性使用的方式，可以预防隐式转换的错误并让你的代码中的类型转换意图变得清晰。</p>
<p>要将一种数字类型转换成另一种，你要用当前值来初始化一个期望类型的新数字，这个数字的类型就是你的目标类型。在下面的例子中，常量<code>twoThousand</code>是<code>UInt16</code>类型，然而常量<code>one</code>是<code>UInt8</code>类型。它们不能直接相加，因为它们类型不同。所以要调用<code>UInt16(one)</code>来创建一个新的<code>UInt16</code>数字并用<code>one</code>的值来初始化，然后使用这个新数字来计算：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> twoThousand: <span class="type">UInt16</span> = <span class="number">2_000</span></span><br><span class="line"><span class="keyword">let</span> one: <span class="type">UInt8</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> twoThousandAndOne = twoThousand + <span class="type">UInt16</span>(one)</span><br></pre></td></tr></table></figure>
<p>现在两个数字的类型都是<code>UInt16</code>，可以进行相加。目标常量<code>twoThousandAndOne</code>的类型被推断为<code>UInt16</code>，因为它是两个<code>UInt16</code>值的和。</p>
<p><code>SomeType(ofInitialValue)</code>是调用 Swift 构造器并传入一个初始值的默认方法。在语言内部，<code>UInt16</code>有一个构造器，可以接受一个<code>UInt8</code>类型的值，所以这个构造器可以用现有的<code>UInt8</code>来创建一个新的<code>UInt16</code>。注意，你并不能传入任意类型的值，只能传入<code>UInt16</code>内部有对应构造器的值。不过你可以扩展现有的类型来让它可以接收其他类型的值（包括自定义类型），请参考<a href="./20_Extensions.html">扩展</a>。</p>
<p><a name="integer_and_floating_point_conversion"></a></p>
<h3 id="整数和浮点数转换">整数和浮点数转换</h3><p>整数和浮点数的转换必须显式指定类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> three = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> pointOneFourOneFiveNine = <span class="number">0.14159</span></span><br><span class="line"><span class="keyword">let</span> pi = <span class="type">Double</span>(three) + pointOneFourOneFiveNine</span><br><span class="line"><span class="comment">// pi 等于 3.14159，所以被推测为 Double 类型</span></span><br></pre></td></tr></table></figure>
<p>这个例子中，常量<code>three</code>的值被用来创建一个<code>Double</code>类型的值，所以加号两边的数类型须相同。如果不进行转换，两者无法相加。</p>
<p>浮点数到整数的反向转换同样行，整数类型可以用<code>Double</code>或者<code>Float</code>类型来初始化：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> integerPi = <span class="type">Int</span>(pi)</span><br><span class="line"><span class="comment">// integerPi 等于 3，所以被推测为 Int 类型</span></span><br></pre></td></tr></table></figure>
<p>当用这种方式来初始化一个新的整数值时，浮点值会被截断。也就是说<code>4.75</code>会变成<code>4</code>，<code>-3.9</code>会变成<code>-3</code>。</p>
<blockquote>
<p>注意：<br>结合数字类常量和变量不同于结合数字类字面量。字面量<code>3</code>可以直接和字面量<code>0.14159</code>相加，因为数字字面量本身没有明确的类型。它们的类型只在编译器需要求值的时候被推测。</p>
</blockquote>
<p><a name="type_aliases"></a></p>
<h2 id="类型别名">类型别名</h2><p>类型别名（type aliases）就是给现有类型定义另一个名字。你可以使用<code>typealias</code>关键字来定义类型别名。</p>
<p>当你想要给现有类型起一个更有意义的名字时，类型别名非常有用。假设你正在处理特定长度的外部资源的数据：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">AudioSample</span> = <span class="type">UInt16</span></span><br></pre></td></tr></table></figure>
<p>定义了一个类型别名之后，你可以在任何使用原始名的地方使用别名：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxAmplitudeFound = <span class="type">AudioSample</span>.<span class="built_in">min</span></span><br><span class="line"><span class="comment">// maxAmplitudeFound 现在是 0</span></span><br></pre></td></tr></table></figure>
<p>本例中，<code>AudioSample</code>被定义为<code>UInt16</code>的一个别名。因为它是别名，<code>AudioSample.min</code>实际上是<code>UInt16.min</code>，所以会给<code>maxAmplitudeFound</code>赋一个初值<code>0</code>。</p>
<p><a name="booleans"></a></p>
<h2 id="布尔值">布尔值</h2><p>Swift 有一个基本的布尔（Boolean）类型，叫做<code>Bool</code>。布尔值指逻辑上的值，因为它们只能是真或者假。Swift 有两个布尔常量，<code>true</code>和<code>false</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> orangesAreOrange = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> turnipsAreDelicious = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p><code>orangesAreOrange</code>和<code>turnipsAreDelicious</code>的类型会被推断为<code>Bool</code>，因为它们的初值是布尔字面量。就像之前提到的<code>Int</code>和<code>Double</code>一样，如果你创建变量的时候给它们赋值<code>true</code>或者<code>false</code>，那你不需要将常量或者变量声明为<code>Bool</code>类型。初始化常量或者变量的时候如果所赋的值类型已知，就可以触发类型推断，这让 Swift 代码更加简洁并且可读性更高。</p>
<p>当你编写条件语句比如<code>if</code>语句的时候，布尔值非常有用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> turnipsAreDelicious &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Mmm, tasty turnips!"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Eww, turnips are horrible."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "Eww, turnips are horrible."</span></span><br></pre></td></tr></table></figure>
<p>条件语句，例如<code>if</code>，请参考<a href="./05_Control_Flow.html">控制流</a>。</p>
<p>如果你在需要使用<code>Bool</code>类型的地方使用了非布尔值，Swift 的类型安全机制会报错。下面的例子会报告一个编译时错误：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> i &#123;</span><br><span class="line">    <span class="comment">// 这个例子不会通过编译，会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，下面的例子是合法的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> i == <span class="number">1</span> &#123;</span><br><span class="line">    <span class="comment">// 这个例子会编译成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>i == 1</code>的比较结果是<code>Bool</code>类型，所以第二个例子可以通过类型检查。类似<code>i == 1</code>这样的比较，请参考<a href="./05_Control_Flow.html">基本操作符</a>。</p>
<p>和 Swift 中的其他类型安全的例子一样，这个方法可以避免错误并保证这块代码的意图总是清晰的。</p>
<p><a name="tuples"></a></p>
<h2 id="元组">元组</h2><p><em>元组（tuples）</em>把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。</p>
<p>下面这个例子中，<code>(404, &quot;Not Found&quot;)</code>是一个描述 <em>HTTP 状态码（HTTP status code）</em>的元组。HTTP 状态码是当你请求网页的时候 web 服务器返回的一个特殊值。如果你请求的网页不存在就会返回一个<code>404 Not Found</code>状态码。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> http404Error = (<span class="number">404</span>, <span class="string">"Not Found"</span>)</span><br><span class="line"><span class="comment">// http404Error 的类型是 (Int, String)，值是 (404, "Not Found")</span></span><br></pre></td></tr></table></figure>
<p><code>(404, &quot;Not Found&quot;)</code>元组把一个<code>Int</code>值和一个<code>String</code>值组合起来表示 HTTP 状态码的两个部分：一个数字和一个人类可读的描述。这个元组可以被描述为“一个类型为<code>(Int, String)</code>的元组”。</p>
<p>你可以把任意顺序的类型组合成一个元组，这个元组可以包含所有类型。只要你想，你可以创建一个类型为<code>(Int, Int, Int)</code>或者<code>(String, Bool)</code>或者其他任何你想要的组合的元组。</p>
<p>你可以将一个元组的内容分解（decompose）成单独的常量和变量，然后你就可以正常使用它们了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (statusCode, statusMessage) = http404Error</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The status code is <span class="subst">\(statusCode)</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "The status code is 404"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The status message is <span class="subst">\(statusMessage)</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "The status message is Not Found"</span></span><br></pre></td></tr></table></figure>
<p>如果你只需要一部分元组值，分解的时候可以把要忽略的部分用下划线（<code>_</code>）标记：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (justTheStatusCode, <span class="number">_</span>) = http404Error</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The status code is <span class="subst">\(justTheStatusCode)</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "The status code is 404"</span></span><br></pre></td></tr></table></figure>
<p>此外，你还可以通过下标来访问元组中的单个元素，下标从零开始：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"The status code is <span class="subst">\(http404Error.<span class="number">0</span>)</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "The status code is 404"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The status message is <span class="subst">\(http404Error.<span class="number">1</span>)</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "The status message is Not Found"</span></span><br></pre></td></tr></table></figure>
<p>你可以在定义元组的时候给单个元素命名：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> http200Status = (statusCode: <span class="number">200</span>, description: <span class="string">"OK"</span>)</span><br></pre></td></tr></table></figure>
<p>给元组中的元素命名后，你可以通过名字来获取这些元素的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"The status code is <span class="subst">\(http200Status.statusCode)</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "The status code is 200"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The status message is <span class="subst">\(http200Status.description)</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "The status message is OK"</span></span><br></pre></td></tr></table></figure>
<p>作为函数返回值时，元组非常有用。一个用来获取网页的函数可能会返回一个<code>(Int, String)</code>元组来描述是否获取成功。和只能返回一个类型的值比较起来，一个包含两个不同类型值的元组可以让函数的返回信息更有用。请参考<a href="./06_Functions.html#Function_Parameters_and_Return_Values">函数参数与返回值</a>。</p>
<blockquote>
<p>注意：<br>元组在临时组织值的时候很有用，但是并不适合创建复杂的数据结构。如果你的数据结构并不是临时使用，请使用类或者结构体而不是元组。请参考<a href="./09_Classes_and_Structures.html">类和结构体</a>。</p>
</blockquote>
<p><a name="optionals"></a></p>
<h2 id="可选类型">可选类型</h2><p>使用<em>可选类型（optionals）</em>来处理值可能缺失的情况。可选类型表示：</p>
<ul>
<li>有值，等于 x</li>
</ul>
<p>或者</p>
<ul>
<li>没有值</li>
</ul>
<blockquote>
<p>注意：<br>C 和 Objective-C 中并没有可选类型这个概念。最接近的是 Objective-C 中的一个特性，一个方法要不返回一个对象要不返回<code>nil</code>，<code>nil</code>表示“缺少一个合法的对象”。然而，这只对对象起作用——对于结构体，基本的 C 类型或者枚举类型不起作用。对于这些类型，Objective-C 方法一般会返回一个特殊值（比如<code>NSNotFound</code>）来暗示值缺失。这种方法假设方法的调用者知道并记得对特殊值进行判断。然而，Swift 的可选类型可以让你暗示<em>任意类型</em>的值缺失，并不需要一个特殊值。</p>
</blockquote>
<p>来看一个例子。Swift 的<code>String</code>类型有一种构造器，作用是将一个<code>String</code>值转换成一个<code>Int</code>值。然而，并不是所有的字符串都可以转换成一个整数。字符串<code>&quot;123&quot;</code>可以被转换成数字<code>123</code>，但是字符串<code>&quot;hello, world&quot;</code>不行。</p>
<p>下面的例子使用这种构造器来尝试将一个<code>String</code>转换成<code>Int</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> possibleNumber = <span class="string">"123"</span></span><br><span class="line"><span class="keyword">let</span> convertedNumber = <span class="type">Int</span>(possibleNumber)</span><br><span class="line"><span class="comment">// convertedNumber 被推测为类型 "Int?"， 或者类型 "optional Int"</span></span><br></pre></td></tr></table></figure>
<p>因为该构造器可能会失败，所以它返回一个<em>可选类型</em>（optional）<code>Int</code>，而不是一个<code>Int</code>。一个可选的<code>Int</code>被写作<code>Int?</code>而不是<code>Int</code>。问号暗示包含的值是可选类型，也就是说可能包含<code>Int</code>值也可能<em>不包含值</em>。（不能包含其他任何值比如<code>Bool</code>值或者<code>String</code>值。只能是<code>Int</code>或者什么都没有。）</p>
<p><a name="nil"></a></p>
<h3 id="nil">nil</h3><p>你可以给可选变量赋值为<code>nil</code>来表示它没有值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serverResponseCode: <span class="type">Int</span>? = <span class="number">404</span></span><br><span class="line"><span class="comment">// serverResponseCode 包含一个可选的 Int 值 404</span></span><br><span class="line">serverResponseCode = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// serverResponseCode 现在不包含值</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br><code>nil</code>不能用于非可选的常量和变量。如果你的代码中有常量或者变量需要处理值缺失的情况，请把它们声明成对应的可选类型。</p>
</blockquote>
<p>如果你声明一个可选常量或者变量但是没有赋值，它们会自动被设置为<code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> surveyAnswer: <span class="type">String</span>?</span><br><span class="line"><span class="comment">// surveyAnswer 被自动设置为 nil</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>Swift 的<code>nil</code>和 Objective-C 中的<code>nil</code>并不一样。在 Objective-C 中，<code>nil</code>是一个指向不存在对象的指针。在 Swift 中，<code>nil</code>不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设置为<code>nil</code>，不只是对象类型。</p>
</blockquote>
<p><a name="if"></a></p>
<h3 id="if_语句以及强制解析">if 语句以及强制解析</h3><p>你可以使用<code>if</code>语句和<code>nil</code>比较来判断一个可选值是否包含值。你可以使用“相等”(<code>==</code>)或“不等”(<code>!=</code>)来执行比较。</p>
<p>如果可选类型有值，它将不等于<code>nil</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> convertedNumber != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"convertedNumber contains some integer value."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "convertedNumber contains some integer value."</span></span><br></pre></td></tr></table></figure>
<p>当你确定可选类型确实包含值之后，你可以在可选的名字后面加一个感叹号（<code>!</code>）来获取值。这个惊叹号表示“我知道这个可选有值，请使用它。”这被称为可选值的<em>强制解析（forced unwrapping）</em>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> convertedNumber != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"convertedNumber has an integer value of <span class="subst">\(convertedNumber!)</span>."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "convertedNumber has an integer value of 123."</span></span><br></pre></td></tr></table></figure>
<p>更多关于<code>if</code>语句的内容，请参考<a href="05_Control_Flow.html">控制流</a>。</p>
<blockquote>
<p>注意：<br>使用<code>!</code>来获取一个不存在的可选值会导致运行时错误。使用<code>!</code>来强制解析值之前，一定要确定可选包含一个非<code>nil</code>的值。</p>
</blockquote>
<p><a name="optional_binding"></a></p>
<h3 id="可选绑定">可选绑定</h3><p>使用<em>可选绑定（optional binding）</em>来判断可选类型是否包含值，如果包含就把值赋给一个临时常量或者变量。可选绑定可以用在<code>if</code>和<code>while</code>语句中，这条语句不仅可以用来判断可选类型中是否有值，同时可以将可选类型中的值赋给一个常量或者变量。<code>if</code>和<code>while</code>语句，请参考<a href="./05_Control_Flow.html">控制流</a>。</p>
<p>像下面这样在<code>if</code>语句中写一个可选绑定：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> constantName = someOptional &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以像上面这样使用可选绑定来重写<code>possibleNumber</code>这个<a href="./01_The_Basics.html#optionals">例子</a>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> actualNumber = <span class="type">Int</span>(possibleNumber) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\'<span class="subst">\(possibleNumber)</span>\' has an integer value of <span class="subst">\(actualNumber)</span>"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\'<span class="subst">\(possibleNumber)</span>\' could not be converted to an integer"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "'123' has an integer value of 123"</span></span><br></pre></td></tr></table></figure>
<p>这段代码可以被理解为：</p>
<p>“如果<code>Int(possibleNumber)</code>返回的可选<code>Int</code>包含一个值，创建一个叫做<code>actualNumber</code>的新常量并将可选包含的值赋给它。”</p>
<p>如果转换成功，<code>actualNumber</code>常量可以在<code>if</code>语句的第一个分支中使用。它已经被可选类型<em>包含的</em>值初始化过，所以不需要再使用<code>!</code>后缀来获取它的值。在这个例子中，<code>actualNumber</code>只被用来输出转换结果。</p>
<p>你可以在可选绑定中使用常量和变量。如果你想在<code>if</code>语句的第一个分支中操作<code>actualNumber</code>的值，你可以改成<code>if var actualNumber</code>，这样可选类型包含的值就会被赋给一个变量而非常量。</p>
<p>你可以包含多个可选绑定在<code>if</code>语句中，并使用<code>where</code>子句做布尔值判断。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstNumber = <span class="type">Int</span>(<span class="string">"4"</span>), secondNumber = <span class="type">Int</span>(<span class="string">"42"</span>) <span class="keyword">where</span> firstNumber &lt; secondNumber &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(firstNumber)</span> &lt; <span class="subst">\(secondNumber)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// prints "4 &lt; 42"</span></span><br></pre></td></tr></table></figure>
<p><a name="implicityly_unwrapped_optionals"></a></p>
<h3 id="隐式解析可选类型">隐式解析可选类型</h3><p>如上所述，可选类型暗示了常量或者变量可以“没有值”。可选可以通过<code>if</code>语句来判断是否有值，如果有值的话可以通过可选绑定来解析值。</p>
<p>有时候在程序架构中，第一次被赋值之后，可以确定一个可选类型<em>总会</em>有值。在这种情况下，每次都要判断和解析可选值是非常低效的，因为可以确定它总会有值。</p>
<p>这种类型的可选状态被定义为隐式解析可选类型（implicitly unwrapped optionals）。把想要用作可选的类型的后面的问号（<code>String?</code>）改成感叹号（<code>String!</code>）来声明一个隐式解析可选类型。</p>
<p>当可选类型被第一次赋值之后就可以确定之后一直有值的时候，隐式解析可选类型非常有用。隐式解析可选类型主要被用在 Swift 中类的构造过程中，请参考<a href="./16_Automatic_Reference_Counting.html#unowned_references_and_implicitly_unwrapped_optional_properties">无主引用以及隐式解析可选属性</a>。</p>
<p>一个隐式解析可选类型其实就是一个普通的可选类型，但是可以被当做非可选类型来使用，并不需要每次都使用解析来获取可选值。下面的例子展示了可选类型<code>String</code>和隐式解析可选类型<code>String</code>之间的区别：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> possibleString: <span class="type">String</span>? = <span class="string">"An optional string."</span></span><br><span class="line"><span class="keyword">let</span> forcedString: <span class="type">String</span> = possibleString! <span class="comment">// 需要惊叹号来获取值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> assumedString: <span class="type">String</span>! = <span class="string">"An implicitly unwrapped optional string."</span></span><br><span class="line"><span class="keyword">let</span> implicitString: <span class="type">String</span> = assumedString  <span class="comment">// 不需要感叹号</span></span><br></pre></td></tr></table></figure>
<p>你可以把隐式解析可选类型当做一个可以自动解析的可选类型。你要做的只是声明的时候把感叹号放到类型的结尾，而不是每次取值的可选名字的结尾。</p>
<blockquote>
<p>注意：<br>如果你在隐式解析可选类型没有值的时候尝试取值，会触发运行时错误。和你在没有值的普通可选类型后面加一个惊叹号一样。</p>
</blockquote>
<p>你仍然可以把隐式解析可选类型当做普通可选类型来判断它是否包含值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> assumedString != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(assumedString)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "An implicitly unwrapped optional string."</span></span><br></pre></td></tr></table></figure>
<p>你也可以在可选绑定中使用隐式解析可选类型来检查并解析它的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> definiteString = assumedString &#123;</span><br><span class="line">    <span class="built_in">print</span>(definiteString)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "An implicitly unwrapped optional string."</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>如果一个变量之后可能变成<code>nil</code>的话请不要使用隐式解析可选类型。如果你需要在变量的生命周期中判断是否是<code>nil</code>的话，请使用普通可选类型。</p>
</blockquote>
<p><a name="error_handling"></a></p>
<h2 id="错误处理">错误处理</h2><p>你可以使用<em>错误处理（error handling）</em>来应对程序执行中可能会遇到的错误条件。</p>
<p>相对于可选中运用值的存在与缺失来表达函数的成功与失败，错误处理可以推断失败的原因，并传播至程序的其他部分。</p>
<p>当一个函数遇到错误条件，它能报错。调用函数的地方能抛出错误消息并合理处理。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">canThrowAnError</span><span class="params">()</span></span> throws &#123;</span><br><span class="line">    <span class="comment">// 这个函数有可能抛出错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个函数可以通过在声明中添加<code>throws</code>关键词来抛出错误消息。当你的函数能抛出错误消息时, 你应该在表达式中前置<code>try</code>关键词。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    try canThrowAnError()</span><br><span class="line">    <span class="comment">// 没有错误消息抛出</span></span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    <span class="comment">// 有一个错误消息抛出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个<code>do</code>语句创建了一个新的包含作用域,使得错误能被传播到一个或多个<code>catch</code>从句。</p>
<p>这里有一个错误处理如何用来应对不同错误条件的例子。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">makeASandwich</span><span class="params">()</span></span> throws &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    try makeASandwich()</span><br><span class="line">    eatASandwich()</span><br><span class="line">&#125; catch <span class="type">Error</span>.<span class="type">OutOfCleanDishes</span> &#123;</span><br><span class="line">    washDishes()</span><br><span class="line">&#125; catch <span class="type">Error</span>.<span class="type">MissingIngredients</span>(<span class="keyword">let</span> ingredients) &#123;</span><br><span class="line">    buyGroceries(ingredients)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此例中，<code>makeASandwich()</code>（做一个三明治）函数会抛出一个错误消息如果没有干净的盘子或者某个原料缺失。因为<code>makeASandwich()</code>抛出错误，函数调用被包裹在<code>try</code>表达式中。将函数包裹在一个<code>do</code>语句中,任何被抛出的错误会被传播到提供的<code>catch</code>从句中。</p>
<p>如果没有错误被抛出, <code>eatASandwich()</code>函数会被调用。如果一个匹配<code>Error.OutOfCleanDishes</code>的错误被抛出,<code>washDishes</code>函数会被调用。如果一个匹配<code>Error.MissingIngredients</code>的错误被抛出，<code>buyGroceries(_:)</code>函数会随着被<code>catch</code>所捕捉到的关联值<code>[String]</code>被调用。</p>
<p>抛出，捕捉，以及传播错误会在<a href="./18_Error_Handling.html">错误处理</a>章节详细说明。</p>
<p><a name="assertions"></a></p>
<h2 id="断言">断言</h2><p>可选类型可以让你判断值是否存在，你可以在代码中优雅地处理值缺失的情况。然而，在某些情况下，如果值缺失或者值并不满足特定的条件，你的代码可能没办法继续执行。这时，你可以在你的代码中触发一个<em>断言（assertion）</em>来结束代码运行并通过调试来找到值缺失的原因。</p>
<h3 id="使用断言进行调试">使用断言进行调试</h3><p>断言会在运行时判断一个逻辑条件是否为<code>true</code>。从字面意思来说，断言“断言”一个条件是否为真。你可以使用断言来保证在运行其他代码之前，某些重要的条件已经被满足。如果条件判断为<code>true</code>，代码运行会继续进行；如果条件判断为<code>false</code>，代码执行结束，你的应用被终止。</p>
<p>如果你的代码在调试环境下触发了一个断言，比如你在 Xcode 中构建并运行一个应用，你可以清楚地看到不合法的状态发生在哪里并检查断言被触发时你的应用的状态。此外，断言允许你附加一条调试信息。</p>
<p>你可以使用全局<code>assert(_:_file:line:)</code>函数来写一个断言。向这个函数传入一个结果为<code>true</code>或者<code>false</code>的表达式以及一条信息，当表达式的结果为<code>false</code>的时候这条信息会被显示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = -<span class="number">3</span></span><br><span class="line"><span class="built_in">assert</span>(age &gt;= <span class="number">0</span>, <span class="string">"A person's age cannot be less than zero"</span>)</span><br><span class="line"><span class="comment">// 因为 age &lt; 0，所以断言会触发</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，只有<code>age &gt;= 0</code>为<code>true</code>的时候，即<code>age</code>的值非负的时候，代码才会继续执行。如果<code>age</code>的值是负数，就像代码中那样，<code>age &gt;= 0</code>为<code>false</code>，断言被触发，终止应用。</p>
<p>如果不需要断言信息，可以省略，就像这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span>(age &gt;= <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>当代码使用优化编译的时候，断言将会被禁用，例如在 Xcode 中，使用默认的 target Release 配置选项来 build 时，断言会被禁用。</p>
</blockquote>
<h3 id="何时使用断言">何时使用断言</h3><p>当条件可能为假时使用断言，但是最终一定要<em>保证</em>条件为真，这样你的代码才能继续运行。断言的适用情景：</p>
<ul>
<li>整数类型的下标索引被传入一个自定义下标脚本实现，但是下标索引值可能太小或者太大。</li>
<li>需要给函数传入一个值，但是非法的值可能导致函数不能正常执行。</li>
<li>一个可选值现在是<code>nil</code>，但是后面的代码运行需要一个非<code>nil</code>值。</li>
</ul>
<p>请参考<a href="./12_Subscripts.html">下标脚本</a>和<a href="./06_Functions.html">函数</a>。</p>
<blockquote>
<p>注意：<br>断言可能导致你的应用终止运行，所以你应当仔细设计你的代码来让非法条件不会出现。然而，在你的应用发布之前，有时候非法条件可能出现，这时使用断言可以快速发现问题。</p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/">&laquo;</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/4/">&raquo;</a>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="https://avatars2.githubusercontent.com/u/14305708?v=3&s=460" alt="terry" itemprop="image"/>
          <p class="site-author-name" itemprop="name">terry</p>
        </div>
        <p class="site-description motion-element" itemprop="description">terry yang's blog | java | scala | bi</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">130</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">11</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-next-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yangwei8888" target="_blank">github</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/microsoftgoogles" target="_blank">weibo</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/run-zhi-38" target="_blank">zhihu</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">terry</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  

    <script type="text/javascript">
      var disqus_shortname = 'yangwei888';
      var disqus_identifier = 'page/3/index.html';
      var disqus_title = '';
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
