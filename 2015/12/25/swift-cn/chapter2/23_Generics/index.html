<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="terry yang's blog | java | scala | bi" />



  <meta name="keywords" content="swift-cn," />



  <link rel="alternate" href="/atom.xml" title="yosita" type="application/atom+xml" />



  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="泛型（Generics）

1.0翻译：takalard校对：lifedim
2.0翻译+校对： SergioChan
2.1校对：shanks，2015-11-01

本页包含内容：

泛型所解决的问题
泛型函数
类型参数
命名类型参数
泛型类型
扩展一个泛型类型
类型约束
关联类型
Where 子句

泛型代码可以让你编写适用自定义需求以及任意类型的灵活可重用的函数和类型。它的可以让你避免重复">
<meta property="og:type" content="article">
<meta property="og:title" content="第二章-23泛型（Generics）">
<meta property="og:url" content="http://yoursite.com/2015/12/25/swift-cn/chapter2/23_Generics/index.html">
<meta property="og:site_name" content="yosita">
<meta property="og:description" content="泛型（Generics）

1.0翻译：takalard校对：lifedim
2.0翻译+校对： SergioChan
2.1校对：shanks，2015-11-01

本页包含内容：

泛型所解决的问题
泛型函数
类型参数
命名类型参数
泛型类型
扩展一个泛型类型
类型约束
关联类型
Where 子句

泛型代码可以让你编写适用自定义需求以及任意类型的灵活可重用的函数和类型。它的可以让你避免重复">
<meta property="og:image" content="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPushPop_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPushedFourStrings_2x.png">
<meta property="og:image" content="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPoppedOneString_2x.png">
<meta property="og:updated_time" content="2015-12-15T05:43:16.331Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第二章-23泛型（Generics）">
<meta name="twitter:description" content="泛型（Generics）

1.0翻译：takalard校对：lifedim
2.0翻译+校对： SergioChan
2.1校对：shanks，2015-11-01

本页包含内容：

泛型所解决的问题
泛型函数
类型参数
命名类型参数
泛型类型
扩展一个泛型类型
类型约束
关联类型
Where 子句

泛型代码可以让你编写适用自定义需求以及任意类型的灵活可重用的函数和类型。它的可以让你避免重复">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>

  <title> 第二章-23泛型（Generics） | yosita </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  

  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?953e46480b0a75d01aaf6d872cc77099";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">yosita</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              第二章-23泛型（Generics）
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:04+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/23_Generics/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/23_Generics/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        <span itemprop="articleBody"><h1 id="u6CDB_u578B_uFF08Generics_uFF09"><a href="#u6CDB_u578B_uFF08Generics_uFF09" class="headerlink" title="泛型（Generics）"></a>泛型（Generics）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/takalard" target="_blank" rel="external">takalard</a><br>校对：<a href="https://github.com/lifedim" target="_blank" rel="external">lifedim</a></p>
<p>2.0<br>翻译+校对： <a href="https://github.com/SergioChan" target="_blank" rel="external">SergioChan</a></p>
<p>2.1<br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a>，2015-11-01</p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="/#the_problem_that_generics_solve">泛型所解决的问题</a></li>
<li><a href="/#generic_functions">泛型函数</a></li>
<li><a href="/#type_parameters">类型参数</a></li>
<li><a href="/#naming_type_parameters">命名类型参数</a></li>
<li><a href="/#generic_types">泛型类型</a></li>
<li><a href="/#extending_a_generic_type">扩展一个泛型类型</a></li>
<li><a href="/#type_constraints">类型约束</a></li>
<li><a href="/#associated_types">关联类型</a></li>
<li><a href="/#where_clauses">Where 子句</a></li>
</ul>
<p>泛型代码可以让你编写适用自定义需求以及任意类型的灵活可重用的函数和类型。它的可以让你避免重复的代码，用一种清晰和抽象的方式来表达代码的意图。</p>
<p>泛型是 Swift 的强大特性之一，许多 Swift 标准库是通过泛型代码构建的。事实上，泛型的使用贯穿了整本语言手册，只是你可能没有发现而已。例如，Swift 的 <code>Array</code> 和 <code>Dictionary</code> 都是泛型集合。你可以创建一个 <code>Int</code> 数组，也可创建一个 <code>String</code> 数组，甚至可以是任意其他 Swift 类型的数组。同样的，你也可以创建存储任意指定类型的字典。</p>
<p><a name="the_problem_that_generics_solve"></a></p>
<h2 id="u6CDB_u578B_u6240_u89E3_u51B3_u7684_u95EE_u9898"><a href="#u6CDB_u578B_u6240_u89E3_u51B3_u7684_u95EE_u9898" class="headerlink" title="泛型所解决的问题"></a>泛型所解决的问题</h2><p>下面是一个标准的非泛型函数 <code>swapTwoInts(_:_:)</code>，用来交换两个 <code>Int</code> 值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">swapTwoInts</span><span class="params">(<span class="keyword">inout</span> a: Int, <span class="keyword">inout</span> <span class="number">_</span> b: Int)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA = a</span><br><span class="line">    a = b</span><br><span class="line">    b = temporaryA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数使用输入输出参数（<code>inout</code>）来交换 <code>a</code> 和 <code>b</code> 的值，请参考<a href="/./06_Functions.html#in_out_parameters">输入输出参数</a>。</p>
<p><code>swapTwoInts(_:_:)</code> 函数交换 <code>b</code> 的原始值到 <code>a</code>，并交换 <code>a</code> 的原始值到 <code>b</code>。你可以调用这个函数交换两个 <code>Int</code> 变量的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someInt = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> anotherInt = <span class="number">107</span></span><br><span class="line">swapTwoInts(&amp;someInt, &amp;anotherInt)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"someInt is now <span class="subst">\(someInt)</span>, and anotherInt is now <span class="subst">\(anotherInt)</span>"</span>)</span><br><span class="line"><span class="comment">// 打印 “someInt is now 107, and anotherInt is now 3”</span></span><br></pre></td></tr></table></figure>
<p>诚然，<code>swapTwoInts(_:_:)</code> 函数挺有用，但是它只能交换 <code>Int</code> 值，如果你想要交换两个 <code>String</code> 值或者 <code>Double</code>值，就不得不写更多的函数，例如 <code>swapTwoStrings(_:_:)</code> 和 <code>swapTwoDoubles(_:_:)</code>，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">swapTwoStrings</span><span class="params">(<span class="keyword">inout</span> a: String, <span class="keyword">inout</span> <span class="number">_</span> b: String)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA = a</span><br><span class="line">    a = b</span><br><span class="line">    b = temporaryA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">swapTwoDoubles</span><span class="params">(<span class="keyword">inout</span> a: Double, <span class="keyword">inout</span> <span class="number">_</span> b: Double)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA = a</span><br><span class="line">    a = b</span><br><span class="line">    b = temporaryA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能注意到 <code>swapTwoInts(_:_:)</code>、<code>swapTwoStrings(_:_:)</code> 和 <code>swapTwoDoubles(_:_:)</code> 的函数功能都是相同的，唯一不同之处就在于传入的变量类型不同，分别是 <code>Int</code>、<code>String</code> 和 <code>Double</code>。</p>
<p>在实际应用中，通常需要一个更实用更灵活的函数来交换两个任意类型的值，幸运的是，泛型代码帮你解决了这种问题。（这些函数的泛型版本已经在下面定义好了。）</p>
<blockquote>
<p>注意<br>在上面三个函数中，<code>a</code> 和 <code>b</code> 类型相同。如果 <code>a</code> 和 <code>b</code> 类型不同，那它们俩就不能互换值。Swift 是类型安全的语言，所以它不允许一个 <code>String</code> 类型的变量和一个 <code>Double</code> 类型的变量互换值。试图这样做将导致编译错误。</p>
</blockquote>
<p><a name="generic_functions"></a></p>
<h2 id="u6CDB_u578B_u51FD_u6570"><a href="#u6CDB_u578B_u51FD_u6570" class="headerlink" title="泛型函数"></a>泛型函数</h2><p>泛型函数可以适用于任何类型，下面的 <code>swapTwoValues(_:_:)</code> 函数是上面三个函数的泛型版本：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">swapTwoValues</span><span class="generics">&lt;T&gt;</span><span class="params">(<span class="keyword">inout</span> a: T, <span class="keyword">inout</span> <span class="number">_</span> b: T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA = a</span><br><span class="line">    a = b</span><br><span class="line">    b = temporaryA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>swapTwoValues(_:_:)</code> 的函数主体和 <code>swapTwoInts(_:_:)</code> 函数是一样的，它们只在第一行有点不同，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">swapTwoInts</span><span class="params">(<span class="keyword">inout</span> a: Int, <span class="keyword">inout</span> <span class="number">_</span> b: Int)</span></span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">swapTwoValues</span><span class="generics">&lt;T&gt;</span><span class="params">(<span class="keyword">inout</span> a: T, <span class="keyword">inout</span> <span class="number">_</span> b: T)</span></span></span><br></pre></td></tr></table></figure>
<p>这个函数的泛型版本使用了占位类型名（在这里用字母 <code>T</code> 来表示）来代替实际类型名（例如 <code>Int</code>、<code>String</code> 或 <code>Double</code>）。占位类型名没有指明 <code>T</code> 必须是什么类型，但是它指明了 <code>a</code> 和 <code>b</code> 必须是同一类型 <code>T</code>，而无论 <code>T</code> 代表什么类型。只有 <code>swapTwoValues(_:_:)</code> 函数在调用时，才能根据所传入的实际类型决定 <code>T</code> 所代表的类型。</p>
<p>另外一个不同之处在于这个泛型函数名后面跟着占位类型名（<code>T</code>），而且是用尖括号括起来的（<code>&lt;T&gt;</code>）。这个尖括号告诉 Swift 那个 <code>T</code> 是 <code>swapTwoValues(_:_:)</code> 函数定义的一个占位类型名，因此 Swift 不会去查找名为 <code>T</code> 的实际类型。</p>
<p><code>swapTwoValues(_:_:)</code> 函数现在可以像 <code>swapTwoInts(_:_:)</code> 那样调用，可以传入任意类型的值，只要两个值的类型相同。<code>swapTwoValues(_:_:)</code> 函数被调用时，<code>T</code> 所代表的类型都会由传入的值的类型推断出来。</p>
<p>在下面的两个例子中，<code>T</code> 分别代表 <code>Int</code> 和 <code>String</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someInt = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> anotherInt = <span class="number">107</span></span><br><span class="line">swapTwoValues(&amp;someInt, &amp;anotherInt)</span><br><span class="line"><span class="comment">// someInt is now 107, and anotherInt is now 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someString = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">var</span> anotherString = <span class="string">"world"</span></span><br><span class="line">swapTwoValues(&amp;someString, &amp;anotherString)</span><br><span class="line"><span class="comment">// someString is now "world", and anotherString is now "hello"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>上面定义的 <code>swapTwoValues(_:_:)</code> 函数是受 <code>swap(_:_:)</code> 函数启发而实现的。后者存在于 Swift 标准库，你可以在你的应用程序中使用它。如果你在代码中需要类似 <code>swapTwoValues(_:_:)</code> 函数的功能，你可以使用已存在的 <code>swap(_:_:)</code> 函数。</p>
</blockquote>
<p><a name="type_parameters"></a></p>
<h2 id="u7C7B_u578B_u53C2_u6570"><a href="#u7C7B_u578B_u53C2_u6570" class="headerlink" title="类型参数"></a>类型参数</h2><p>在上面的 <code>swapTwoValues(_:_:)</code> 例子中，占位类型 <code>T</code> 是类型参数的一个例子。类型参数指定并命名一个占位类型，并且紧随在函数名后面，使用一对尖括号括起来（例如 <code>&lt;T&gt;</code>）。</p>
<p>一旦一个类型参数被指定，你可以用它来定义一个函数的参数类型（例如 <code>swapTwoValues(_:_:)</code> 函数中的参数 <code>a</code> 和 <code>b</code>），或者作为函数的返回类型，还可以用作函数主体中的注释类型。在这些情况下，类型参数会在函数调用时被实际类型所替换。（在上面的 <code>swapTwoValues(_:_:)</code> 例子中，当函数第一次被调用时，<code>T</code> 被 <code>Int</code> 替换，第二次调用时，被 <code>String</code> 替换。）</p>
<p>你可提供多个类型参数，将它们都写在尖括号中，用逗号分开。</p>
<p><a name="naming_type_parameters"></a></p>
<h2 id="u547D_u540D_u7C7B_u578B_u53C2_u6570"><a href="#u547D_u540D_u7C7B_u578B_u53C2_u6570" class="headerlink" title="命名类型参数"></a>命名类型参数</h2><p>在大多数情况下，类型参数具有一个描述性名字，例如 <code>Dictionary&lt;Key, Value&gt;</code> 中的 <code>Key</code> 和 <code>Value</code>，以及 <code>Array&lt;Element&gt;</code> 中的 <code>Element</code>，这可以告诉阅读代码的人这些类型参数和泛型函数之间的关系。然而，当它们之间的关系没有意义时，通常使用单一的字母来命名，例如 <code>T</code>、<code>U</code>、<code>V</code>，正如上面演示的 <code>swapTwoValues(_:_:)</code> 函数中的 <code>T</code> 一样。</p>
<blockquote>
<p>注意<br>请始终使用大写字母开头的驼峰式命名法（例如 <code>T</code> 和 <code>MyTypeParameter</code>）来为类型参数命名，以表明它们是占位类型，而不是一个值。</p>
</blockquote>
<p><a name="generic_types"></a></p>
<h2 id="u6CDB_u578B_u7C7B_u578B"><a href="#u6CDB_u578B_u7C7B_u578B" class="headerlink" title="泛型类型"></a>泛型类型</h2><p>除了泛型函数，Swift 还允许你定义泛型类型。这些自定义类、结构体和枚举可以适用于任何类型，如同 <code>Array</code> 和 <code>Dictionary</code> 的用法。</p>
<p>这部分内容将向你展示如何编写一个名为 <code>Stack</code> （栈）的泛型集合类型。栈是一系列值的有序集合，和 <code>Array</code> 类似，但它相比 Swift 的 <code>Array</code> 类型有更多的操作限制。数组允许对其中任意位置的元素执行插入或删除操作。而栈，只允许在集合的末端添加新的元素（称之为入栈）。同样的，栈也只能从末端移除元素（称之为出栈）。</p>
<blockquote>
<p>注意<br>栈的概念已被 <code>UINavigationController</code> 类用来模拟视图控制器的导航结构。你通过调用 <code>UINavigationController</code> 的 <code>pushViewController(_:animated:)</code> 方法来添加新的视图控制器到导航栈，通过 <code>popViewControllerAnimated(_:)</code> 方法来从导航栈中移除某个视图控制器。每当你需要一个严格的“后进先出”方式来管理集合，栈都是最实用的模型。</p>
</blockquote>
<p>下图展示了一个栈的压栈（push）和出栈（pop）的行为：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPushPop_2x.png" alt="此处输入图片的描述"></p>
<ol>
<li>现在有三个值在栈中。</li>
<li>第四个值被压入到栈的顶部。</li>
<li>现在有四个值在栈中，最近入栈的那个值在顶部。</li>
<li>栈中最顶部的那个值被移除，或称之为出栈。</li>
<li>移除掉一个值后，现在栈再一次只有三个值。</li>
</ol>
<p>下面展示了如何编写一个非泛型版本的栈，在这种情况下是 <code>Int</code> 型的栈：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IntStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> items = [<span class="type">Int</span>]()</span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">push</span><span class="params">(item: Int)</span></span> &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个结构体在栈中使用一个名为 <code>items</code> 的 <code>Array</code> 属性来存储值。<code>Stack</code> 提供了两个方法：<code>push(_:)</code> 和 <code>pop()</code>，用来向栈中压入值以及从栈中移除值。这些方法被标记为 <code>mutating</code>，因为它们需要修改结构体的 <code>items</code> 数组。</p>
<p>上面的 <code>IntStack</code> 结构体只能用于 <code>Int</code> 类型。不过，可以定义一个泛型 <code>Stack</code> 结构体，从而能够处理任意类型的值。</p>
<p>下面是相同代码的泛型版本：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> items = [<span class="type">Element</span>]()</span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">push</span><span class="params">(item: Element)</span></span> &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，<code>Stack</code> 基本上和 <code>IntStack</code> 相同，只是用占位类型参数 <code>Element</code> 代替了实际的 <code>Int</code> 类型。这种类型参数包裹在一对尖括号里（<code>&lt;Element&gt;</code>），紧跟在结构体名后面。</p>
<p><code>Element</code> 为尚未提供的类型定义了一个占位名。这种尚未提供的类型可以在结构体的定义中通过 <code>Element</code> 来引用。在这种情况下，<code>Element</code> 在如下三个地方被用作占位符：</p>
<ul>
<li>创建 <code>items</code> 属性，使用 <code>Element</code> 类型的空数组对其进行初始化。</li>
<li>指定 <code>push(_:)</code> 方法的单一参数 <code>item</code> 的类型必须是 <code>Element</code> 类型。</li>
<li>指定 <code>pop()</code> 方法的返回值类型必须是 <code>Element</code> 类型。</li>
</ul>
<p>由于 <code>Stack</code> 是泛型类型，因此可以用来创建 Swift 中任意有效类型的栈，如同 <code>Array</code> 和 <code>Dictionary</code>。</p>
<p>你可以通过在尖括号中写出栈中需要存储的数据类型来创建并初始化一个 <code>Stack</code> 实例。例如，要创建一个 <code>String</code> 类型的栈，可以写成 <code>Stack&lt;String&gt;()</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stackOfStrings = <span class="type">Stack</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">stackOfStrings.push(<span class="string">"uno"</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">"dos"</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">"tres"</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">"cuatro"</span>)</span><br><span class="line"><span class="comment">// 栈中现在有 4 个字符串</span></span><br></pre></td></tr></table></figure>
<p>下图展示了 <code>stackOfStrings</code> 如何将这四个值入栈：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPushedFourStrings_2x.png" alt="此处输入图片的描述"></p>
<p>移除并返回栈顶部的值 <code>&quot;cuatro&quot;</code>，即将其出栈：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fromTheTop = stackOfStrings.pop()</span><br><span class="line"><span class="comment">// fromTheTop 的值为 "cuatro"，现在栈中还有 3 个字符串</span></span><br></pre></td></tr></table></figure>
<p>下图展示了 <code>stackOfStrings</code> 如何将顶部的值出栈：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPoppedOneString_2x.png" alt="此处输入图片的描述"></p>
<p><a name="extending_a_generic_type"></a></p>
<h2 id="u6269_u5C55_u4E00_u4E2A_u6CDB_u578B_u7C7B_u578B"><a href="#u6269_u5C55_u4E00_u4E2A_u6CDB_u578B_u7C7B_u578B" class="headerlink" title="扩展一个泛型类型"></a>扩展一个泛型类型</h2><p>当你扩展一个泛型类型的时候，你并不需要在扩展的定义中提供类型参数列表。更加方便的是，原始类型定义中声明的类型参数列表在扩展中可以直接使用，并且这些来自原始类型中的参数名称会被用作原始定义中类型参数的引用。</p>
<p>下面的例子扩展了泛型类型 <code>Stack</code>，为其添加了一个名为 <code>topItem</code> 的只读计算型属性，它将会返回当前栈顶端的元素而不会将其从栈中移除：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> topItem: <span class="type">Element</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> items.isEmpty ? <span class="literal">nil</span> : items[items.<span class="built_in">count</span> - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>topItem</code> 属性会返回一个 <code>Element</code> 类型的可选值。当栈为空的时候，<code>topItem</code> 会返回 <code>nil</code>；当栈不为空的时候，<code>topItem</code> 会返回 <code>items</code> 数组中的最后一个元素。</p>
<p>注意，这个扩展并没有定义一个类型参数列表。相反的，<code>Stack</code> 类型已有的类型参数名称 <code>Element</code>，被用在扩展中来表示计算型属性 <code>topItem</code> 的可选类型。</p>
<p>计算型属性 <code>topItem</code> 现在可以用来访问任意 <code>Stack</code> 实例的顶端元素而不是移除它：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> topItem = stackOfStrings.topItem &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The top item on the stack is <span class="subst">\(topItem)</span>."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “The top item on the stack is tres.”</span></span><br></pre></td></tr></table></figure>
<p><a name="type_constraints"></a></p>
<h2 id="u7C7B_u578B_u7EA6_u675F"><a href="#u7C7B_u578B_u7EA6_u675F" class="headerlink" title="类型约束"></a>类型约束</h2><p><code>swapTwoValues(_:_:)</code> 函数和 <code>Stack</code> 类型可以作用于任何类型。不过，有的时候如果能将使用在泛型函数和泛型类型中的类型，强制约束为某种特定类型，将会是非常有用的。类型约束可以指定一个类型参数必须继承自指定类，或者符合一个特定的协议或协议组合。</p>
<p>例如，Swift 的 <code>Dictionary</code> 类型对字典的键的类型做了些限制。在<a href="/./04_Collection_Types.html#dictionaries">字典</a>的描述中，字典的键的类型必须是可哈希的。也就是说，必须有一种方法能作为其唯一的表示。<code>Dictionary</code> 之所以需要其键是可哈希的，是为了便于检查字典是否已经包含某个特定键的值。如无此要求，<code>Dictionary</code> 将无法判断是否可以插入或者替换某个指定键的值，也不能查找到已经存储在字典中的指定键的值。</p>
<p>这个要求强制加上了一个类型约束作用于 <code>Dictionary</code> 的键类型上，其键类型必须符合 <code>Hashable</code> 协议，这是 Swift 标准库中定义的一个特定协议。所有的 Swift 基本类型（例如 <code>String</code>、<code>Int</code>、<code>Double</code> 和 <code>Bool</code>）默认都是可哈希的。</p>
<p>当你创建自定义泛型类型时，你可以定义你自己的类型约束，这些约束将提供更为强大的泛型编程能力。抽象概念，例如可哈希的，描述的是类型在概念上的特征，而不是它们的显式类型。</p>
<p><a name="type_constraint_syntax"></a></p>
<h3 id="u7C7B_u578B_u7EA6_u675F_u8BED_u6CD5"><a href="#u7C7B_u578B_u7EA6_u675F_u8BED_u6CD5" class="headerlink" title="类型约束语法"></a>类型约束语法</h3><p>你可以在一个类型参数名后面放置一个类名或者协议名，通过冒号分隔，从而定义类型约束，它们将作为类型参数列表的一部分。这种基本的类型约束作用于泛型函数时的语法如下所示（作用于泛型类型时的语法与之相同）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">someFunction</span><span class="generics">&lt;T: SomeClass, U: SomeProtocol&gt;</span><span class="params">(someT: T, someU: U)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这里是泛型函数的函数体部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个函数有两个类型参数。第一个类型参数 <code>T</code>，有一个要求 <code>T</code> 必须是 <code>SomeClass</code> 子类的类型约束；第二个类型参数 <code>U</code>，有一个要求 <code>U</code> 必须符合 <code>SomeProtocol</code> 协议的类型约束。</p>
<p><a name="type_constraints_in_action"></a></p>
<h3 id="u7C7B_u578B_u7EA6_u675F_u5B9E_u8DF5"><a href="#u7C7B_u578B_u7EA6_u675F_u5B9E_u8DF5" class="headerlink" title="类型约束实践"></a>类型约束实践</h3><p>这里有个名为 <code>findStringIndex</code> 的非泛型函数，该函数的功能是在 <code>String</code> 值的数组中查找给定 <code>String</code> 值的索引。若查找到匹配的字符串，<code>findStringIndex(_:_:)</code> 函数返回该字符串在数组中的索引值，反之则返回 <code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">findStringIndex</span><span class="params">(array: [String], <span class="number">_</span> valueToFind: String)</span></span> -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> array.<span class="built_in">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> value == valueToFind &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>findStringIndex(_:_:)</code> 函数可以用于查找字符串数组中的某个字符串：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> strings = [<span class="string">"cat"</span>, <span class="string">"dog"</span>, <span class="string">"llama"</span>, <span class="string">"parakeet"</span>, <span class="string">"terrapin"</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> foundIndex = findStringIndex(strings, <span class="string">"llama"</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The index of llama is <span class="subst">\(foundIndex)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “The index of llama is 2”</span></span><br></pre></td></tr></table></figure>
<p>如果只能查找字符串在数组中的索引，用处不是很大。不过，你可以写出相同功能的泛型函数 <code>findIndex(_:_:)</code>，用占位类型 <code>T</code> 替换 <code>String</code> 类型。</p>
<p>下面展示了 <code>findStringIndex(_:_:)</code> 函数的泛型版本 <code>findIndex(_:_:)</code>。请注意这个函数仍然返回 <code>Int?</code>，那是因为函数返回的是一个可选的索引数，而不是从数组中得到的一个可选值。需要提醒的是，这个函数无法通过编译，原因在例子后面会说明：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">findIndex</span><span class="generics">&lt;T&gt;</span><span class="params">(array: [T], <span class="number">_</span> valueToFind: T)</span></span> -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> array.<span class="built_in">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> value == valueToFind &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面所写的函数无法通过编译。这个问题出在相等性检查上，即 <code>“if value == valueToFind”</code>。不是所有的 Swift 类型都可以用等式符（<code>==</code>）进行比较。例如，如果你创建一个你自己的类或结构体来表示一个复杂的数据模型，那么 Swift 无法猜到对于这个类或结构体而言“相等”意味着什么。正因如此，这部分代码无法保证适用于每个可能的类型 <code>T</code>，当你试图编译这部分代码时会出现相应的错误。</p>
<p>不过，所有的这些并不会让我们无从下手。Swift 标准库中定义了一个 <code>Equatable</code> 协议，该协议要求任何符合该协议的类型必须实现等式符（<code>==</code>），从而能对符合该协议的类型的任意两个值进行比较。所有的 Swift 标准类型自动支持 <code>Equatable</code> 协议。</p>
<p>任何 <code>Equatable</code> 类型都可以安全地使用在 <code>findIndex(_:_:)</code> 函数中，因为其保证支持等式操作符。为了说明这个事实，当你定义一个函数时，你可以定义一个 <code>Equatable</code> 类型约束作为类型参数定义的一部分：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">findIndex</span><span class="generics">&lt;T: Equatable&gt;</span><span class="params">(array: [T], <span class="number">_</span> valueToFind: T)</span></span> -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> array.<span class="built_in">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> value == valueToFind &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>findIndex(_:_:)</code> 中的这个单一类型参数写做 <code>T: Equatable</code>，也就意味着“任何符合 <code>Equatable</code> 协议的 <code>T</code> 类型”。</p>
<p><code>findIndex(_:_:)</code> 函数现在可以成功编译了，并且可以作用于任何符合 <code>Equatable</code> 的类型，如 <code>Double</code> 或 <code>String</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> doubleIndex = findIndex([<span class="number">3.14159</span>, <span class="number">0.1</span>, <span class="number">0.25</span>], <span class="number">9.3</span>)</span><br><span class="line"><span class="comment">// doubleIndex 类型为 Int?，其值为 nil，因为 9.3 不在数组中</span></span><br><span class="line"><span class="keyword">let</span> stringIndex = findIndex([<span class="string">"Mike"</span>, <span class="string">"Malcolm"</span>, <span class="string">"Andrea"</span>], <span class="string">"Andrea"</span>)</span><br><span class="line"><span class="comment">// stringIndex 类型为 Int?，其值为 2</span></span><br></pre></td></tr></table></figure>
<p><a name="associated_types"></a></p>
<h2 id="u5173_u8054_u7C7B_u578B"><a href="#u5173_u8054_u7C7B_u578B" class="headerlink" title="关联类型"></a>关联类型</h2><p>定义一个协议时，有的时候声明一个或多个关联类型作为协议定义的一部分将会非常有用。关联类型作为协议的一部分，为某个类型提供了一个占位名（或者说别名），其代表的实际类型在协议被采纳时才会被指定。你可以通过 <code>typealias</code> 关键字来指定关联类型。</p>
<p><a name="associated_types_in_action"></a></p>
<h3 id="u5173_u8054_u7C7B_u578B_u5B9E_u8DF5"><a href="#u5173_u8054_u7C7B_u578B_u5B9E_u8DF5" class="headerlink" title="关联类型实践"></a>关联类型实践</h3><p>下面例子定义了一个 <code>Container</code> 协议，该协议定义了一个关联类型 <code>ItemType</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">ItemType</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">append</span><span class="params">(item: ItemType)</span></span></span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">ItemType</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Container</code> 协议定义了三个任何采纳协议的类型必须提供的功能：</p>
<ul>
<li>必须可以通过 <code>append(_:)</code> 方法添加一个新元素到容器里。</li>
<li>必须可以通过 <code>count</code> 属性获取容器中元素的数量，并返回一个 <code>Int</code> 值。</li>
<li>必须可以通过接受 <code>Int</code> 索引值的下标检索到每一个元素。</li>
</ul>
<p>这个协议没有指定容器中元素该如何存储，以及元素必须是何种类型。这个协议只指定了三个任何采纳 <code>Container</code> 协议的类型必须提供的功能。采纳协议的类型在满足这三个条件的情况下也可以提供其他额外的功能。</p>
<p>任何采纳 <code>Container</code> 协议的类型必须能够指定其存储的元素的类型，必须保证只有正确类型的元素可以加进容器中，必须明确通过其下标返回的元素的类型。</p>
<p>为了定义这三个条件，<code>Container</code> 协议需要在不知道容器中元素的具体类型的情况下引用这种类型。<code>Container</code> 协议需要指定任何通过 <code>append(_:)</code> 方法添加到容器中的元素和容器中的元素是相同类型，并且通过容器下标返回的元素的类型也是这种类型。</p>
<p>为了达到此目的，<code>Container</code> 协议声明了一个关联类型 <code>ItemType</code>，写作 <code>typealias ItemType</code>。这个协议无法定义 <code>ItemType</code> 是什么类型的别名，这个信息将留给采纳协议的类型来提供。尽管如此，<code>ItemType</code> 别名提供了一种方式来引用 <code>Container</code> 中元素的类型，并将之用于 <code>append(_:)</code> 方法和下标，从而保证任何 <code>Container</code> 的预期行为都能够被执行。</p>
<p>下面是先前的非泛型的 <code>IntStack</code> 类型，这一版本采纳并符合了 <code>Container</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IntStack</span>: <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="comment">// IntStack 的原始实现部分</span></span><br><span class="line">    <span class="keyword">var</span> items = [<span class="type">Int</span>]()</span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">push</span><span class="params">(item: Int)</span></span> &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Container 协议的实现部分</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">ItemType</span> = <span class="type">Int</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">append</span><span class="params">(item: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>IntStack</code> 结构体实现了 <code>Container</code> 协议的三个要求，其原有功能也不会和这些要求相冲突。</p>
<p>此外，<code>IntStack</code> 指定 <code>ItemType</code> 为 <code>Int</code> 类型，即 <code>typealias ItemType = Int</code>，从而将 <code>Container</code> 协议中抽象的 <code>ItemType</code> 类型转换为具体的 <code>Int</code> 类型。</p>
<p>由于 Swift 的类型推断，你实际上不用在 <code>IntStack</code> 的定义中声明 <code>ItemType</code> 为 <code>Int</code>。因为 <code>IntStack</code> 符合 <code>Container</code> 协议的所有要求，Swift 只需通过 <code>append(_:)</code> 方法的 <code>item</code> 参数类型和下标返回值的类型，就可以推断出 <code>ItemType</code> 的具体类型。事实上，如果你在上面的代码中删除了 <code>typealias ItemType = Int</code> 这一行，这一切仍旧可以正常工作，因为 Swift 清楚地知道 <code>ItemType</code> 应该是何种类型。</p>
<p>你也可以令泛型 <code>Stack</code> 结构体符合 <code>Container</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&lt;<span class="title">Element</span>&gt;: <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Stack&lt;Element&gt; 的原始实现部分</span></span><br><span class="line">    <span class="keyword">var</span> items = [<span class="type">Element</span>]()</span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">push</span><span class="params">(item: Element)</span></span> &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Container 协议的实现部分</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">append</span><span class="params">(item: Element)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一次，占位类型参数 <code>Element</code> 被用作 <code>append(_:)</code> 方法的 <code>item</code> 参数和下标的返回类型。Swift 可以据此推断出 <code>Element</code> 的类型即是 <code>ItemType</code> 的类型。</p>
<p><a name="extending_an_existing_type_to_specify_an_associated_type"></a></p>
<h3 id="u901A_u8FC7_u6269_u5C55_u4E00_u4E2A_u5B58_u5728_u7684_u7C7B_u578B_u6765_u6307_u5B9A_u5173_u8054_u7C7B_u578B"><a href="#u901A_u8FC7_u6269_u5C55_u4E00_u4E2A_u5B58_u5728_u7684_u7C7B_u578B_u6765_u6307_u5B9A_u5173_u8054_u7C7B_u578B" class="headerlink" title="通过扩展一个存在的类型来指定关联类型"></a>通过扩展一个存在的类型来指定关联类型</h3><p><a href="/./22_Protocols.html#adding_protocol_conformance_with_an_extension">通过扩展添加协议一致性</a>中描述了如何利用扩展让一个已存在的类型符合一个协议，这包括使用了关联类型的协议。</p>
<p>Swift 的 <code>Array</code> 已经提供 <code>append(_:)</code> 方法，一个 <code>count</code> 属性，以及一个接受 <code>Int</code> 型索引值的可用来检索数组元素的下标。这三个功能都符合 <code>Container</code> 协议的要求，也就意味着你可以扩展 <code>Array</code> 去符合 <code>Container</code> 协议，只需简单地声明 <code>Array</code> 采纳该协议即可。你可以通过一个空扩展来实现这点，正如<a href="/./22_Protocols.html#declaring_protocol_adoption_with_an_extension">通过扩展采纳协议</a>中的描述：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span>: <span class="title">Container</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如同上面的泛型 <code>Stack</code> 结构体一样，<code>Array</code> 的 <code>append(_:)</code> 方法和下标确保了 Swift 可以推断出 <code>ItemType</code> 的类型。定义了这个扩展后，你可以将任意 <code>Array</code> 当作 <code>Container</code> 来使用。</p>
<p><a name="where_clauses"></a></p>
<h2 id="Where__u5B50_u53E5"><a href="#Where__u5B50_u53E5" class="headerlink" title="Where 子句"></a>Where 子句</h2><p><a href="/#type_constraints">类型约束</a>让你能够为泛型函数或泛型类型的类型参数定义一些强制要求。</p>
<p>为关联类型定义约束也是非常有用的。你可以在参数列表中通过 <code>where</code> 子句为关联类型定义约束。一个 <code>where</code> 子句能够使一个关联类型符合某个特定的协议，以及某个特定的类型参数和关联类型必须类型相同。你可以通过将 <code>where</code> 关键字紧跟在类型参数列表后面来定义 <code>where</code> 子句，<code>where</code> 子句后跟一个或者多个针对关联类型的约束，以及一个或多个类型参数和关联类型间的相等关系。</p>
<p>下面的例子定义了一个名为 <code>allItemsMatch</code> 的泛型函数，用来检查两个 <code>Container</code> 实例是否包含相同顺序的相同元素。如果所有的元素能够匹配，那么返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p>被检查的两个 <code>Container</code> 可以不是相同类型的容器（虽然它们可以相同），但它们必须拥有相同类型的元素。这个要求通过一个类型约束以及一个 <code>where</code> 子句来表示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">allItemsMatch</span><span class="generics">&lt;</span><br><span class="line">    C1: Container, C2: Container</span><br><span class="line">    where C1.ItemType == C2.ItemType, C1.ItemType: Equatable&gt;</span></span><br><span class="line">    <span class="params">(someContainer: C1, <span class="number">_</span> anotherContainer: C2)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查两个容器含有相同数量的元素</span></span><br><span class="line">        <span class="keyword">if</span> someContainer.<span class="built_in">count</span> != anotherContainer.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查每一对元素是否相等</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;someContainer.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> someContainer[i] != anotherContainer[i] &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所有元素都匹配，返回 true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数接受 <code>someContainer</code> 和 <code>anotherContainer</code> 两个参数。参数 <code>someContainer</code> 的类型为 <code>C1</code>，参数 <code>anotherContainer</code> 的类型为 <code>C2</code>。<code>C1</code> 和 <code>C2</code> 是容器的两个占位类型参数，函数被调用时才能确定它们的具体类型。</p>
<p>这个函数的类型参数列表还定义了两个类型参数的要求：</p>
<ul>
<li><code>C1</code> 必须符合 <code>Container</code> 协议（写作 <code>C1: Container</code>）。</li>
<li><code>C2</code> 必须符合 <code>Container</code> 协议（写作 <code>C2: Container</code>）。</li>
<li><code>C1</code> 的 <code>ItemType</code> 必须和 <code>C2</code> 的 <code>ItemType</code>类型相同（写作 <code>C1.ItemType == C2.ItemType</code>）。</li>
<li><code>C1</code> 的 <code>ItemType</code> 必须符合 <code>Equatable</code> 协议（写作 <code>C1.ItemType: Equatable</code>）。</li>
</ul>
<p>第三个和第四个要求被定义为一个 <code>where</code> 子句，写在关键字 <code>where</code> 后面，它们也是泛型函数类型参数列表的一部分。</p>
<p>这些要求意味着：</p>
<ul>
<li><code>someContainer</code> 是一个 <code>C1</code> 类型的容器。</li>
<li><code>anotherContainer</code> 是一个 <code>C2</code> 类型的容器。</li>
<li><code>someContainer</code> 和 <code>anotherContainer</code> 包含相同类型的元素。</li>
<li><code>someContainer</code> 中的元素可以通过不等于操作符（<code>!=</code>）来检查它们是否彼此不同。</li>
</ul>
<p>第三个和第四个要求结合起来意味着 <code>anotherContainer</code> 中的元素也可以通过 <code>!=</code> 操作符来比较，因为它们和 <code>someContainer</code> 中的元素类型相同。</p>
<p>这些要求让 <code>allItemsMatch(_:_:)</code> 函数能够比较两个容器，即使它们是不同的容器类型。</p>
<p><code>allItemsMatch(_:_:)</code> 函数首先检查两个容器是否拥有相同数量的元素，如果它们的元素数量不同，那么一定不匹配，函数就会返回 <code>false</code>。</p>
<p>进行这项检查之后，通过 <code>for-in</code> 循环和半闭区间操作符（<code>..&lt;</code>）来迭代每个元素，检查 <code>someContainer</code> 中的元素是否不等于 <code>anotherContainer</code> 中的对应元素。如果两个元素不相等，那么两个容器不匹配，函数返回 <code>false</code>。</p>
<p>如果循环体结束后未发现任何不匹配的情况，表明两个容器匹配，函数返回 <code>true</code>。</p>
<p>下面演示了 <code>allItemsMatch(_:_:)</code> 函数的使用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stackOfStrings = <span class="type">Stack</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">stackOfStrings.push(<span class="string">"uno"</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">"dos"</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">"tres"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arrayOfStrings = [<span class="string">"uno"</span>, <span class="string">"dos"</span>, <span class="string">"tres"</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> allItemsMatch(stackOfStrings, arrayOfStrings) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"All items match."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Not all items match."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “All items match.”</span></span><br></pre></td></tr></table></figure>
<p>上面的例子创建一个 <code>Stack</code> 实例来存储一些 <code>String</code> 值，然后将三个字符串压入栈中。这个例子还通过数组字面量创建了一个 <code>Array</code> 实例，数组中包含三个同栈中一样的字符串。即使栈和数组是不同的类型，但它们都符合 <code>Container</code> 协议，而且它们都包含相同类型的值。因此你可以用这两个容器作为参数来调用 <code>allItemsMatch(_:_:)</code> 函数。在上面的例子中，<code>allItemsMatch(_:_:)</code> 函数正确地显示了这两个容器中的所有元素都是相互匹配的。</p>
</span>
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/swift-cn/" rel="tag">#swift-cn</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/12/25/swift-cn/chapter2/22_Protocols/" rel="prev">第二章-22协议（Protocols）</a>
            
          </div>

          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/12/25/swift-cn/chapter2/24_Access_Control/" rel="next">第二章-24访问控制（Access Control）</a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

 </div>

        

        
          <div class="comments" id="comments">
            
              <div id="disqus_thread">
                <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
              </div>
            
          </div>
        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="https://avatars2.githubusercontent.com/u/14305708?v=3&s=460" alt="terry" itemprop="image"/>
          <p class="site-author-name" itemprop="name">terry</p>
        </div>
        <p class="site-description motion-element" itemprop="description">terry yang's blog | java | scala | bi</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">160</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">14</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">53</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-next-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yangwei8888" target="_blank">github</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/microsoftgoogles" target="_blank">weibo</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/run-zhi-38" target="_blank">zhihu</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#u6CDB_u578B_uFF08Generics_uFF09"><span class="nav-number">1.</span> <span class="nav-text">泛型（Generics）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#u6CDB_u578B_u6240_u89E3_u51B3_u7684_u95EE_u9898"><span class="nav-number">1.1.</span> <span class="nav-text">泛型所解决的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#u6CDB_u578B_u51FD_u6570"><span class="nav-number">1.2.</span> <span class="nav-text">泛型函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#u7C7B_u578B_u53C2_u6570"><span class="nav-number">1.3.</span> <span class="nav-text">类型参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#u547D_u540D_u7C7B_u578B_u53C2_u6570"><span class="nav-number">1.4.</span> <span class="nav-text">命名类型参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#u6CDB_u578B_u7C7B_u578B"><span class="nav-number">1.5.</span> <span class="nav-text">泛型类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#u6269_u5C55_u4E00_u4E2A_u6CDB_u578B_u7C7B_u578B"><span class="nav-number">1.6.</span> <span class="nav-text">扩展一个泛型类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#u7C7B_u578B_u7EA6_u675F"><span class="nav-number">1.7.</span> <span class="nav-text">类型约束</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u7C7B_u578B_u7EA6_u675F_u8BED_u6CD5"><span class="nav-number">1.7.1.</span> <span class="nav-text">类型约束语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u7C7B_u578B_u7EA6_u675F_u5B9E_u8DF5"><span class="nav-number">1.7.2.</span> <span class="nav-text">类型约束实践</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#u5173_u8054_u7C7B_u578B"><span class="nav-number">1.8.</span> <span class="nav-text">关联类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u5173_u8054_u7C7B_u578B_u5B9E_u8DF5"><span class="nav-number">1.8.1.</span> <span class="nav-text">关联类型实践</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u901A_u8FC7_u6269_u5C55_u4E00_u4E2A_u5B58_u5728_u7684_u7C7B_u578B_u6765_u6307_u5B9A_u5173_u8054_u7C7B_u578B"><span class="nav-number">1.8.2.</span> <span class="nav-text">通过扩展一个存在的类型来指定关联类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Where__u5B50_u53E5"><span class="nav-number">1.9.</span> <span class="nav-text">Where 子句</span></a></li></ol></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </section>
      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">terry</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  

    <script type="text/javascript">
      var disqus_shortname = 'yangwei888';
      var disqus_identifier = '2015/12/25/swift-cn/chapter2/23_Generics/';
      var disqus_title = '第二章-23泛型（Generics）';
      var disqus_url = 'http://yoursite.com/2015/12/25/swift-cn/chapter2/23_Generics/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.5.1" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 0.4 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    var $tocContent = $('.post-toc-content');
    if (isDesktop() && CONFIG.sidebar === 'post') {
      if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
        displaySidebar();
      }
    }
  });
</script>



  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
