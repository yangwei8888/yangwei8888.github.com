<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="terry yang's blog | java | scala | bi" />



  <meta name="keywords" content="Hexo,next" />



  <link rel="alternate" href="/atom.xml" title="yosita" type="application/atom+xml" />



  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="terry yang&apos;s blog | java | scala | bi">
<meta property="og:type" content="website">
<meta property="og:title" content="yosita">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="yosita">
<meta property="og:description" content="terry yang&apos;s blog | java | scala | bi">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="yosita">
<meta name="twitter:description" content="terry yang&apos;s blog | java | scala | bi">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>

  <title> yosita </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  

  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?7e8961fdae021b7bf62f2c767bb18c23";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">yosita</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/25_Advanced_Operators/" itemprop="url">
                第二章-25高级运算符（Advanced Operators）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:02+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/25_Advanced_Operators/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/25_Advanced_Operators/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="高级运算符（Advanced_Operators）">高级运算符（Advanced Operators）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/xielingwang" target="_blank" rel="external">xielingwang</a><br>校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/buginux" target="_blank" rel="external">buginux</a></p>
<p>2.1<br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a>，2015-11-01</p>
</blockquote>
<p>本页内容包括：</p>
<ul>
<li><a href="#bitwise_operators">位运算符</a></li>
<li><a href="#overflow_operators">溢出运算符</a></li>
<li><a href="#precedence_and_associativity">优先级和结合性</a></li>
<li><a href="#operator_functions">运算符函数</a></li>
<li><a href="#custom_operators">自定义运算符</a></li>
</ul>
<p>除了在之前介绍过的<a href="./02_Basic_Operators.html">基本运算符</a>，Swift 中还有许多可以对数值进行复杂运算的高级运算符。这些高级运算符包含了在 C 和 Objective-C 中已经被大家所熟知的位运算符和移位运算符。</p>
<p>与 C 语言中的算术运算符不同，Swift 中的算术运算符默认是不会溢出的。所有溢出行为都会被捕获并报告为错误。如果想让系统允许溢出行为，可以选择使用 Swift 中另一套默认支持溢出的运算符，比如溢出加法运算符（<code>&amp;+</code>）。所有的这些溢出运算符都是以 <code>&amp;</code> 开头的。</p>
<p>自定义结构体、类和枚举时，如果也为它们提供标准 Swift 运算符的实现，将会非常有用。在 Swift 中自定义运算符非常简单，运算符也会针对不同类型使用对应实现。</p>
<p>我们不用被预定义的运算符所限制。在 Swift 中可以自由地定义中缀、前缀、后缀和赋值运算符，以及相应的优先级与结合性。这些运算符在代码中可以像预定义的运算符一样使用，我们甚至可以扩展已有的类型以支持自定义的运算符。</p>
<p><a name="bitwise_operators"></a></p>
<h2 id="位运算符">位运算符</h2><p>位运算符可以操作数据结构中每个独立的比特位。它们通常被用在底层开发中，比如图形编程和创建设备驱动。位运算符在处理外部资源的原始数据时也十分有用，比如对自定义通信协议传输的数据进行编码和解码。</p>
<p>Swift 支持 C 语言中的全部位运算符，接下来会一一介绍。</p>
<p><a name="bitwise_not_operator"></a></p>
<h3 id="按位取反运算符">按位取反运算符</h3><p>按位取反运算符（<code>~</code>）可以对一个数值的全部比特位进行取反：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitwiseNOT_2x.png" alt="Art/bitwiseNOT_2x.png"></p>
<p>按位取反运算符是一个前缀运算符，需要直接放在运算的数之前，并且它们之间不能添加任何空格：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> initialBits: <span class="type">UInt8</span> = <span class="number">0b00001111</span></span><br><span class="line"><span class="keyword">let</span> invertedBits = ~initialBits <span class="comment">// 等于 0b11110000</span></span><br></pre></td></tr></table></figure>
<p><code>UInt8</code> 类型的整数有 8 个比特位，可以存储 <code>0 ~ 255</code> 之间的任意整数。这个例子初始化了一个 <code>UInt8</code> 类型的整数，并赋值为二进制的 <code>00001111</code>，它的前 4 位都为 <code>0</code>，后 4 位都为 <code>1</code>。这个值等价于十进制的 <code>15</code>。</p>
<p>接着使用按位取反运算符创建了一个名为 <code>invertedBits</code> 的常量，这个常量的值与全部位取反后的 <code>initialBits</code> 相等。即所有的 <code>0</code> 都变成了 <code>1</code>，同时所有的 <code>1</code> 都变成 <code>0</code>。<code>invertedBits</code> 的二进制值为 <code>11110000</code>，等价于无符号十进制数的 <code>240</code>。</p>
<p><a name="bitwise_and_operator"></a></p>
<h3 id="按位与运算符">按位与运算符</h3><p>按位与运算符（<code>&amp;</code>）可以对两个数的比特位进行合并。它返回一个新的数，只有当两个数的对应位都为 <code>1</code> 的时候，新数的对应位才为 <code>1</code>：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitwiseAND_2x.png" alt="Art/bitwiseAND_2x.png"></p>
<p>在下面的示例当中，<code>firstSixBits</code> 和 <code>lastSixBits</code> 中间 4 个位的值都为 <code>1</code>。按位与运算符对它们进行了运算，得到二进制数值 <code>00111100</code>，等价于无符号十进制数的 <code>60</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstSixBits: <span class="type">UInt8</span> = <span class="number">0b11111100</span></span><br><span class="line"><span class="keyword">let</span> lastSixBits: <span class="type">UInt8</span>  = <span class="number">0b00111111</span></span><br><span class="line"><span class="keyword">let</span> middleFourBits = firstSixBits &amp; lastSixBits <span class="comment">// 等于 00111100</span></span><br></pre></td></tr></table></figure>
<p><a name="bitwise_or_operator"></a></p>
<h3 id="按位或运算符">按位或运算符</h3><p>按位或运算符（<code>|</code>）可以对两个数的比特位进行比较。它返回一个新的数，只要两个数的对应位中有任意一个为 <code>1</code> 时，新数的对应位就为 <code>1</code>：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitwiseOR_2x.png" alt="Art/bitwiseOR_2x.png" title="Art/bitwiseOR_2x.png"></p>
<p>在下面的示例中，<code>someBits</code> 和 <code>moreBits</code> 不同的位会被设置为 <code>1</code>。接位或运算符对它们进行了运算，得到二进制数值 <code>11111110</code>，等价于无符号十进制数的 <code>254</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someBits: <span class="type">UInt8</span> = <span class="number">0b10110010</span></span><br><span class="line"><span class="keyword">let</span> moreBits: <span class="type">UInt8</span> = <span class="number">0b01011110</span></span><br><span class="line"><span class="keyword">let</span> combinedbits = someBits | moreBits <span class="comment">// 等于 11111110</span></span><br></pre></td></tr></table></figure>
<p><a name="bitwise_xor_operator"></a></p>
<h3 id="按位异或运算符">按位异或运算符</h3><p>按位异或运算符（<code>^</code>）可以对两个数的比特位进行比较。它返回一个新的数，当两个数的对应位不相同时，新数的对应位就为 <code>1</code>：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitwiseXOR_2x.png" alt="Art/bitwiseXOR_2x.png" title="Art/bitwiseXOR_2x.png"></p>
<p>在下面的示例当中，<code>firstBits</code> 和 <code>otherBits</code> 都有一个自己的位为 <code>1</code> 而对方的对应位为 <code>0</code> 的位。 按位异或运算符将新数的这两个位都设置为 <code>1</code>，同时将其它位都设置为 <code>0</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstBits: <span class="type">UInt8</span> = <span class="number">0b00010100</span></span><br><span class="line"><span class="keyword">let</span> otherBits: <span class="type">UInt8</span> = <span class="number">0b00000101</span></span><br><span class="line"><span class="keyword">let</span> outputBits = firstBits ^ otherBits <span class="comment">// 等于 00010001</span></span><br></pre></td></tr></table></figure>
<p><a name="bitwise_left_and_right_shift_operators"></a></p>
<h3 id="按位左移、右移运算符">按位左移、右移运算符</h3><p>按位左移运算符（<code>&lt;&lt;</code>）和按位右移运算符（<code>&gt;&gt;</code>）可以对一个数的所有位进行指定位数的左移和右移，但是需要遵守下面定义的规则。</p>
<p>对一个数进行按位左移或按位右移，相当于对这个数进行乘以 2 或除以 2 的运算。将一个整数左移一位，等价于将这个数乘以 2，同样地，将一个整数右移一位，等价于将这个数除以 2。</p>
<p><a name="shifting_behavior_for_unsigned_integers"></a></p>
<h4 id="无符号整数的移位运算">无符号整数的移位运算</h4><p>对无符号整数进行移位的规则如下：</p>
<ol>
<li>已经存在的位按指定的位数进行左移和右移。</li>
<li>任何因移动而超出整型存储范围的位都会被丢弃。</li>
<li>用 <code>0</code> 来填充移位后产生的空白位。</li>
</ol>
<p>这种方法称为逻辑移位。</p>
<p>以下这张图展示了 <code>11111111 &lt;&lt; 1</code>（即把 <code>11111111</code> 向左移动 <code>1</code> 位），和 <code>11111111 &gt;&gt; 1</code>（即把 <code>11111111</code> 向右移动 <code>1</code> 位）的结果。蓝色的部分是被移位的，灰色的部分是被抛弃的，橙色的部分则是被填充进来的：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftUnsigned_2x.png" alt="Art/bitshiftUnsigned_2x.png" title="Art/bitshiftUnsigned_2x.png"></p>
<p>下面的代码演示了 Swift 中的移位运算：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> shiftBits: <span class="type">UInt8</span> = <span class="number">4</span> <span class="comment">// 即二进制的 00000100</span></span><br><span class="line">shiftBits &lt;&lt; <span class="number">1</span>           <span class="comment">// 00001000</span></span><br><span class="line">shiftBits &lt;&lt; <span class="number">2</span>           <span class="comment">// 00010000</span></span><br><span class="line">shiftBits &lt;&lt; <span class="number">5</span>           <span class="comment">// 10000000</span></span><br><span class="line">shiftBits &lt;&lt; <span class="number">6</span>           <span class="comment">// 00000000</span></span><br><span class="line">shiftBits &gt;&gt; <span class="number">2</span>           <span class="comment">// 00000001</span></span><br></pre></td></tr></table></figure>
<p>可以使用移位运算对其他的数据类型进行编码和解码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pink: <span class="type">UInt32</span> = <span class="number">0xCC6699</span></span><br><span class="line"><span class="keyword">let</span> redComponent = (pink &amp; <span class="number">0xFF0000</span>) &gt;&gt; <span class="number">16</span>  <span class="comment">// redComponent 是 0xCC，即 204</span></span><br><span class="line"><span class="keyword">let</span> greenComponent = (pink &amp; <span class="number">0x00FF00</span>) &gt;&gt; <span class="number">8</span> <span class="comment">// greenComponent 是 0x66， 即 102</span></span><br><span class="line"><span class="keyword">let</span> blueComponent = pink &amp; <span class="number">0x0000FF</span>         <span class="comment">// blueComponent 是 0x99，即 153</span></span><br></pre></td></tr></table></figure>
<p>这个示例使用了一个命名为 <code>pink</code> 的 <code>UInt32</code> 型常量来存储 CSS 中粉色的颜色值。该 CSS 的十六进制颜色值 <code>#CC6699</code>，在 Swift 中表示为 <code>0xCC6699</code>。然后利用按位与运算符（<code>&amp;</code>）和按位右移运算符（<code>&gt;&gt;</code>）从这个颜色值中分解出红（<code>CC</code>）、绿（<code>66</code>）以及蓝（<code>99</code>）三个部分。</p>
<p>红色部分是通过对 <code>0xCC6699</code> 和 <code>0xFF0000</code> 进行按位与运算后得到的。<code>0xFF0000</code> 中的 <code>0</code> 部分“掩盖”了 <code>OxCC6699</code> 中的第二、第三个字节，使得数值中的 <code>6699</code> 被忽略，只留下 <code>0xCC0000</code>。</p>
<p>然后，再将这个数按向右移动 16 位（<code>&gt;&gt; 16</code>）。十六进制中每两个字符表示 8 个比特位，所以移动 16 位后 <code>0xCC0000</code> 就变为 <code>0x0000CC</code>。这个数和<code>0xCC</code>是等同的，也就是十进制数值的 <code>204</code>。</p>
<p>同样的，绿色部分通过对 <code>0xCC6699</code> 和 <code>0x00FF00</code> 进行按位与运算得到 <code>0x006600</code>。然后将这个数向右移动 8 位，得到 <code>0x66</code>，也就是十进制数值的 <code>102</code>。</p>
<p>最后，蓝色部分通过对 <code>0xCC6699</code> 和 <code>0x0000FF</code> 进行按位与运算得到 <code>0x000099</code>。这里不需要再向右移位，所以结果为 <code>0x99</code> ，也就是十进制数值的 <code>153</code>。</p>
<p><a name="shifting_behavior_for_signed_integers"></a></p>
<h4 id="有符号整数的移位运算">有符号整数的移位运算</h4><p>对比无符号整数，有符号整数的移位运算相对复杂得多，这种复杂性源于有符号整数的二进制表现形式。（为了简单起见，以下的示例都是基于 8 比特位的有符号整数的，但是其中的原理对任何位数的有符号整数都是通用的。）</p>
<p>有符号整数使用第 1 个比特位（通常被称为符号位）来表示这个数的正负。符号位为 <code>0</code> 代表正数，为 <code>1</code> 代表负数。</p>
<p>其余的比特位（通常被称为数值位）存储了实际的值。有符号正整数和无符号数的存储方式是一样的，都是从 <code>0</code> 开始算起。这是值为 <code>4</code> 的 <code>Int8</code> 型整数的二进制位表现形式：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftSignedFour_2x.png" alt="Art/bitshiftSignedFour_2x.png" title="Art/bitshiftSignedFour_2x.png"></p>
<p>符号位为 <code>0</code>，说明这是一个正数，另外 7 位则代表了十进制数值 <code>4</code> 的二进制表示。</p>
<p>负数的存储方式略有不同。它存储的值的绝对值等于 <code>2</code> 的 <code>n</code> 次方减去它的实际值（也就是数值位表示的值），这里的 <code>n</code> 为数值位的比特位数。一个 8 比特位的数有 7 个比特位是数值位，所以是 <code>2</code> 的 <code>7</code> 次方，即 <code>128</code>。</p>
<p>这是值为 <code>-4</code> 的 <code>Int8</code> 型整数的二进制位表现形式：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftSignedMinusFour_2x.png" alt="Art/bitshiftSignedMinusFour_2x.png" title="Art/bitshiftSignedMinusFour_2x.png"></p>
<p>这次的符号位为 <code>1</code>，说明这是一个负数，另外 7 个位则代表了数值 <code>124</code>（即 <code>128 - 4</code>）的二进制表示：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftSignedMinusFourValue_2x.png" alt="Art/bitshiftSignedMinusFourValue_2x.png" title="Art/bitshiftSignedMinusFourValue_2x.png"></p>
<p>负数的表示通常被称为二进制补码表示。用这种方法来表示负数乍看起来有点奇怪，但它有几个优点。</p>
<p>首先，如果想对 <code>-1</code> 和 <code>-4</code> 进行加法运算，我们只需要将这两个数的全部 8 个比特位进行相加，并且将计算结果中超出 8 位的数值丢弃：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftSignedAddition_2x.png" alt="Art/bitshiftSignedAddition_2x.png" title="Art/bitshiftSignedAddition_2x.png"></p>
<p>其次，使用二进制补码可以使负数的按位左移和右移运算得到跟正数同样的效果，即每向左移一位就将自身的数值乘以 2，每向右一位就将自身的数值除以 2。要达到此目的，对有符号整数的右移有一个额外的规则：</p>
<ul>
<li>当对正整数进行按位右移运算时，遵循与无符号整数相同的规则，但是对于移位产生的空白位使用符号位进行填充，而不是用 <code>0</code>。</li>
</ul>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftSigned_2x.png" alt="Art/bitshiftSigned_2x.png" title="Art/bitshiftSigned_2x.png"></p>
<p>这个行为可以确保有符号整数的符号位不会因为右移运算而改变，这通常被称为算术移位。</p>
<p>由于正数和负数的特殊存储方式，在对它们进行右移的时候，会使它们越来越接近 <code>0</code>。在移位的过程中保持符号位不变，意味着负整数在接近 <code>0</code> 的过程中会一直保持为负。</p>
<p><a name="overflow_operators"></a></p>
<h2 id="溢出运算符">溢出运算符</h2><p>在默认情况下，当向一个整数赋予超过它容量的值时，Swift 默认会报错，而不是生成一个无效的数。这个行为为我们在运算过大或着过小的数的时候提供了额外的安全性。</p>
<p>例如，<code>Int16</code> 型整数能容纳的有符号整数范围是 <code>-32768</code> 到 <code>32767</code>，当为一个 <code>Int16</code> 型变量赋的值超过这个范围时，系统就会报错：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> potentialOverflow = <span class="type">Int16</span>.<span class="built_in">max</span></span><br><span class="line"><span class="comment">// potentialOverflow 的值是 32767，这是 Int16 能容纳的最大整数</span></span><br><span class="line">potentialOverflow += <span class="number">1</span></span><br><span class="line"><span class="comment">// 这里会报错</span></span><br></pre></td></tr></table></figure>
<p>为过大或者过小的数值提供错误处理，能让我们在处理边界值时更加灵活。</p>
<p>然而，也可以选择让系统在数值溢出的时候采取截断处理，而非报错。可以使用 Swift 提供的三个溢出运算符来让系统支持整数溢出运算。这些运算符都是以 <code>&amp;</code> 开头的：</p>
<ul>
<li>溢出加法 <code>&amp;+</code></li>
<li>溢出减法 <code>&amp;-</code></li>
<li>溢出乘法 <code>&amp;*</code></li>
</ul>
<p><a name="value_overflow"></a></p>
<h3 id="数值溢出">数值溢出</h3><p>数值有可能出现上溢或者下溢。</p>
<p>这个示例演示了当我们对一个无符号整数使用溢出加法（<code>&amp;+</code>）进行上溢运算时会发生什么：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> unsignedOverflow = <span class="type">UInt8</span>.<span class="built_in">max</span></span><br><span class="line"><span class="comment">// unsignedOverflow 等于 UInt8 所能容纳的最大整数 255</span></span><br><span class="line">unsignedOverflow = unsignedOverflow &amp;+ <span class="number">1</span></span><br><span class="line"><span class="comment">// 此时 unsignedOverflow 等于 0</span></span><br></pre></td></tr></table></figure>
<p><code>unsignedOverflow</code> 被初始化为 <code>UInt8</code> 所能容纳的最大整数（<code>255</code>，以二进制表示即 <code>11111111</code>）。然后使用了溢出加法运算符（<code>&amp;+</code>）对其进行加 <code>1</code> 运算。这使得它的二进制表示正好超出 <code>UInt8</code> 所能容纳的位数，也就导致了数值的溢出，如下图所示。数值溢出后，留在 <code>UInt8</code> 边界内的值是 <code>00000000</code>，也就是十进制数值的 <code>0</code>。</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/overflowAddition_2x.png" alt="Art/overflowAddition_2x.png" title="Art/overflowAddition_2x.png"></p>
<p>同样地，当我们对一个无符号整数使用溢出减法（<code>&amp;-</code>）进行下溢运算时也会产生类似的现象：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> unsignedOverflow = <span class="type">UInt8</span>.<span class="built_in">min</span></span><br><span class="line"><span class="comment">// unsignedOverflow 等于 UInt8 所能容纳的最小整数 0</span></span><br><span class="line">unsignedOverflow = unsignedOverflow &amp;- <span class="number">1</span></span><br><span class="line"><span class="comment">// 此时 unsignedOverflow 等于 255</span></span><br></pre></td></tr></table></figure>
<p><code>UInt8</code> 型整数能容纳的最小值是 <code>0</code>，以二进制表示即 <code>00000000</code>。当使用溢出减法运算符对其进行减 <code>1</code> 运算时，数值会产生下溢并被截断为 <code>11111111</code>， 也就是十进制数值的 <code>255</code>。</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/overflowUnsignedSubtraction_2x.png" alt="Art/overflowUnsignedSubtraction_2x.png" title="Art/overflowAddition_2x.png"></p>
<p>溢出也会发生在有符号整型数值上。在对有符号整型数值进行溢出加法或溢出减法运算时，符号位也需要参与计算，正如<a href="#bitwise_left_and_right_shift_operators">按位左移、右移运算符</a>所描述的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> signedOverflow = <span class="type">Int8</span>.<span class="built_in">min</span></span><br><span class="line"><span class="comment">// signedOverflow 等于 Int8 所能容纳的最小整数 -128</span></span><br><span class="line">signedOverflow = signedOverflow &amp;- <span class="number">1</span></span><br><span class="line"><span class="comment">// 此时 signedOverflow 等于 127</span></span><br></pre></td></tr></table></figure>
<p><code>Int8</code> 型整数能容纳的最小值是 <code>-128</code>，以二进制表示即 <code>10000000</code>。当使用溢出减法运算符对其进行减 <code>1</code> 运算时，符号位被翻转，得到二进制数值 <code>01111111</code>，也就是十进制数值的 <code>127</code>，这个值也是 <code>Int8</code> 型整数所能容纳的最大值。</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/overflowSignedSubtraction_2x.png" alt="Art/overflowSignedSubtraction_2x.png" title="Art/overflowSignedSubtraction_2x.png"></p>
<p>对于无符号与有符号整型数值来说，当出现上溢时，它们会从数值所能容纳的最大数变成最小的数。同样地，当发生下溢时，它们会从所能容纳的最小数变成最大的数。</p>
<p><a name="precedence_and_associativity"></a></p>
<h2 id="优先级和结合性">优先级和结合性</h2><p>运算符的优先级使得一些运算符优先于其他运算符，高优先级的运算符会先被计算。</p>
<p>结合性定义了相同优先级的运算符是如何结合的，也就是说，是与左边结合为一组，还是与右边结合为一组。可以将这意思理解为“它们是与左边的表达式结合的”或者“它们是与右边的表达式结合的”。</p>
<p>在复合表达式的运算顺序中，运算符的优先级和结合性是非常重要的。举例来说，运算符优先级解释了为什么下面这个表达式的运算结果会是 <code>17</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> + <span class="number">3</span> % <span class="number">4</span> * <span class="number">5</span></span><br><span class="line"><span class="comment">// 结果是 17</span></span><br></pre></td></tr></table></figure>
<p>如果完全从左到右进行运算，则运算的过程是这样的：</p>
<ul>
<li>2 + 3 = 5</li>
<li>5 % 4 = 1</li>
<li>1 * 5 = 5</li>
</ul>
<p>但是正确答案是 <code>17</code> 而不是 <code>5</code>。优先级高的运算符要先于优先级低的运算符进行计算。与 C 语言类似，在 Swift 中，乘法运算符（<code>*</code>）与取余运算符（<code>%</code>）的优先级高于加法运算符（<code>+</code>）。因此，它们的计算顺序要先于加法运算。</p>
<p>而乘法与取余的优先级相同。这时为了得到正确的运算顺序，还需要考虑结合性。乘法与取余运算都是左结合的。可以将这考虑成为这两部分表达式都隐式地加上了括号：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> + ((<span class="number">3</span> % <span class="number">4</span>) * <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p><code>(3 % 4)</code> 等于 <code>3</code>，所以表达式相当于：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> + (<span class="number">3</span> * <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p><code>3 * 5</code> 等于 <code>15</code>，所以表达式相当于：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> + <span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>因此计算结果为 <code>17</code>。</p>
<p>如果想查看完整的 Swift 运算符优先级和结合性规则，请参考<a href="../chapter3/04_Expressions.html">表达式</a>。如果想查看 Swift 标准库提供所有的运算符，请查看 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Reference/Swift_StandardLibrary_Operators/index.html#//apple_ref/doc/uid/TP40016054" target="_blank" rel="external">Swift Standard Library Operators Reference</a>。</p>
<blockquote>
<p>注意<br>相对 C 语言和 Objective-C 来说，Swift 的运算符优先级和结合性规则更加简洁和可预测。但是，这也意味着它们相较于 C 语言及其衍生语言并不是完全一致的。在对现有的代码进行移植的时候，要注意确保运算符的行为仍然符合你的预期。</p>
</blockquote>
<p><a name="operator_functions"></a></p>
<h2 id="运算符函数">运算符函数</h2><p>类和结构体可以为现有的运算符提供自定义的实现，这通常被称为运算符重载。</p>
<p>下面的例子展示了如何为自定义的结构体实现加法运算符（<code>+</code>）。算术加法运算符是一个双目运算符，因为它可以对两个值进行运算，同时它还是中缀运算符，因为它出现在两个值中间。</p>
<p>例子中定义了一个名为 <code>Vector2D</code> 的结构体用来表示二维坐标向量 <code>(x, y)</code>，紧接着定义了一个可以对两个 <code>Vector2D</code> 结构体进行相加的运算符函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vector2D</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> + <span class="params">(<span class="keyword">left</span>: Vector2D, <span class="keyword">right</span>: Vector2D)</span></span> -&gt; <span class="type">Vector2D</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Vector2D</span>(x: <span class="keyword">left</span>.x + <span class="keyword">right</span>.x, y: <span class="keyword">left</span>.y + <span class="keyword">right</span>.y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该运算符函数被定义为一个全局函数，并且函数的名字与它要进行重载的 <code>+</code> 名字一致。因为算术加法运算符是双目运算符，所以这个运算符函数接收两个类型为 <code>Vector2D</code> 的参数，同时有一个 <code>Vector2D</code> 类型的返回值。</p>
<p>在这个实现中，输入参数分别被命名为 <code>left</code> 和 <code>right</code>，代表在 <code>+</code> 运算符左边和右边的两个 <code>Vector2D</code> 实例。函数返回了一个新的 <code>Vector2D</code> 实例，这个实例的 <code>x</code> 和 <code>y</code> 分别等于作为参数的两个实例的 <code>x</code> 和 <code>y</code> 的值之和。</p>
<p>这个函数被定义成全局的，而不是 <code>Vector2D</code> 结构体的成员方法，所以任意两个 <code>Vector2D</code> 实例都可以使用这个中缀运算符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vector = <span class="type">Vector2D</span>(x: <span class="number">3.0</span>, y: <span class="number">1.0</span>)</span><br><span class="line"><span class="keyword">let</span> anotherVector = <span class="type">Vector2D</span>(x: <span class="number">2.0</span>, y: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">let</span> combinedVector = vector + anotherVector</span><br><span class="line"><span class="comment">// combinedVector 是一个新的 Vector2D 实例，值为 (5.0, 5.0)</span></span><br></pre></td></tr></table></figure>
<p>这个例子实现两个向量 <code>(3.0，1.0)</code> 和 <code>(2.0，4.0)</code> 的相加，并得到新的向量 <code>(5.0，5.0)</code>。这个过程如下图示：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/vectorAddition_2x.png" alt="Art/vectorAddition_2x.png" title="Art/vectorAddition_2x.png"></p>
<p><a name="prefix_and_postfix_operators"></a></p>
<h3 id="前缀和后缀运算符">前缀和后缀运算符</h3><p>上个例子演示了一个双目中缀运算符的自定义实现。类与结构体也能提供标准单目运算符的实现。单目运算符只运算一个值。当运算符出现在值之前时，它就是前缀的（例如 <code>-a</code>），而当它出现在值之后时，它就是后缀的（例如 <code>i++</code>）。</p>
<p>要实现前缀或者后缀运算符，需要在声明运算符函数的时候在 <code>func</code> 关键字之前指定 <code>prefix</code> 或者 <code>postfix</code> 修饰符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">prefix</span> <span class="func"><span class="keyword">func</span> - <span class="params">(vector: Vector2D)</span></span> -&gt; <span class="type">Vector2D</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Vector2D</span>(x: -vector.x, y: -vector.y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码为 <code>Vector2D</code> 类型实现了单目负号运算符。由于该运算符是前缀运算符，所以这个函数需要加上 <code>prefix</code> 修饰符。</p>
<p>对于简单数值，单目负号运算符可以对它们的正负性进行改变。对于 <code>Vector2D</code> 来说，该运算将其 <code>x</code> 和 <code>y</code> 属性的正负性都进行了改变：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> positive = <span class="type">Vector2D</span>(x: <span class="number">3.0</span>, y: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">let</span> negative = -positive</span><br><span class="line"><span class="comment">// negative 是一个值为 (-3.0, -4.0) 的 Vector2D 实例</span></span><br><span class="line"><span class="keyword">let</span> alsoPositive = -negative</span><br><span class="line"><span class="comment">// alsoPositive 是一个值为 (3.0, 4.0) 的 Vector2D 实例</span></span><br></pre></td></tr></table></figure>
<p><a name="compound_assignment_operators"></a></p>
<h3 id="复合赋值运算符">复合赋值运算符</h3><p>复合赋值运算符将赋值运算符（<code>=</code>）与其它运算符进行结合。例如，将加法与赋值结合成加法赋值运算符（<code>+=</code>）。在实现的时候，需要把运算符的左参数设置成 <code>inout</code> 类型，因为这个参数的值会在运算符函数内直接被修改。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> += <span class="params">(<span class="keyword">inout</span> <span class="keyword">left</span>: Vector2D, <span class="keyword">right</span>: Vector2D)</span></span> &#123;</span><br><span class="line">    <span class="keyword">left</span> = <span class="keyword">left</span> + <span class="keyword">right</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为加法运算在之前已经定义过了，所以在这里无需重新定义。在这里可以直接利用现有的加法运算符函数，用它来对左值和右值进行相加，并再次赋值给左值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> original = <span class="type">Vector2D</span>(x: <span class="number">1.0</span>, y: <span class="number">2.0</span>)</span><br><span class="line"><span class="keyword">let</span> vectorToAdd = <span class="type">Vector2D</span>(x: <span class="number">3.0</span>, y: <span class="number">4.0</span>)</span><br><span class="line">original += vectorToAdd</span><br><span class="line"><span class="comment">// original 的值现在为 (4.0, 6.0)</span></span><br></pre></td></tr></table></figure>
<p>还可以将赋值与 <code>prefix</code> 或 <code>postfix</code> 修饰符结合起来，下面的代码为 <code>Vector2D</code> 实例实现了前缀自增运算符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">prefix</span> <span class="func"><span class="keyword">func</span> ++ <span class="params">(<span class="keyword">inout</span> vector: Vector2D)</span></span> -&gt; <span class="type">Vector2D</span> &#123;</span><br><span class="line">    vector += <span class="type">Vector2D</span>(x: <span class="number">1.0</span>, y: <span class="number">1.0</span>)</span><br><span class="line">    <span class="keyword">return</span> vector</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个前缀自增运算符使用了前面定义的加法赋值运算。它对 <code>Vector2D</code> 的 <code>x</code> 和 <code>y</code> 属性都进行了加 <code>1</code> 运算，再将结果返回：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toIncrement = <span class="type">Vector2D</span>(x: <span class="number">3.0</span>, y: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">let</span> afterIncrement = ++toIncrement</span><br><span class="line"><span class="comment">// toIncrement 的值现在为 (4.0, 5.0)</span></span><br><span class="line"><span class="comment">// afterIncrement 的值同样为 (4.0, 5.0)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>不能对默认的赋值运算符（<code>=</code>）进行重载。只有组合赋值运算符可以被重载。同样地，也无法对三目条件运算符 （<code>a ? b : c</code>） 进行重载。</p>
</blockquote>
<p><a name="equivalence_operators"></a></p>
<h3 id="等价运算符">等价运算符</h3><p>自定义的类和结构体没有对等价运算符进行默认实现，等价运算符通常被称为“相等”运算符（<code>==</code>）与“不等”运算符（<code>!=</code>）。对于自定义类型，Swift 无法判断其是否“相等”，因为“相等”的含义取决于这些自定义类型在你的代码中所扮演的角色。</p>
<p>为了使用等价运算符能对自定义的类型进行判等运算，需要为其提供自定义实现，实现的方法与其它中缀运算符一样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> == <span class="params">(<span class="keyword">left</span>: Vector2D, <span class="keyword">right</span>: Vector2D)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">left</span>.x == <span class="keyword">right</span>.x) &amp;&amp; (<span class="keyword">left</span>.y == <span class="keyword">right</span>.y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> != <span class="params">(<span class="keyword">left</span>: Vector2D, <span class="keyword">right</span>: Vector2D)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !(<span class="keyword">left</span> == <span class="keyword">right</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码实现了“相等”运算符（<code>==</code>）来判断两个 <code>Vector2D</code> 实例是否相等。对于 <code>Vector2D</code> 类型来说，“相等”意味着“两个实例的 <code>x</code> 属性和 <code>y</code> 属性都相等”，这也是代码中用来进行判等的逻辑。示例里同时也实现了“不等”运算符（<code>!=</code>），它简单地将“相等”运算符的结果进行取反后返回。</p>
<p>现在我们可以使用这两个运算符来判断两个 <code>Vector2D</code> 实例是否相等：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> twoThree = <span class="type">Vector2D</span>(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">let</span> anotherTwoThree = <span class="type">Vector2D</span>(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">if</span> twoThree == anotherTwoThree &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"These two vectors are equivalent."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “These two vectors are equivalent.”</span></span><br></pre></td></tr></table></figure>
<p><a name="custom_operators"></a></p>
<h2 id="自定义运算符">自定义运算符</h2><p>除了实现标准运算符，在 Swift 中还可以声明和实现自定义运算符。可以用来自定义运算符的字符列表请参考<a href="../chapter3/02_Lexical_Structure.html#operators">运算符</a>。</p>
<p>新的运算符要使用 <code>operator</code> 关键字在全局作用域内进行定义，同时还要指定 <code>prefix</code>、<code>infix</code> 或者 <code>postfix</code> 修饰符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">prefix</span> <span class="keyword">operator</span> +++ &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码定义了一个新的名为 <code>+++</code> 的前缀运算符。对于这个运算符，在 Swift 中并没有意义，因此我们针对 <code>Vector2D</code> 的实例来定义它的意义。对这个示例来讲，<code>+++</code> 被实现为“前缀双自增”运算符。它使用了前面定义的复合加法运算符来让矩阵对自身进行相加，从而让 <code>Vector2D</code> 实例的 <code>x</code> 属性和 <code>y</code> 属性的值翻倍：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">prefix</span> <span class="func"><span class="keyword">func</span> +++ <span class="params">(<span class="keyword">inout</span> vector: Vector2D)</span></span> -&gt; <span class="type">Vector2D</span> &#123;</span><br><span class="line">    vector += vector</span><br><span class="line">    <span class="keyword">return</span> vector</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Vector2D</code> 的 <code>+++</code> 的实现和 <code>++</code> 的实现很相似，唯一不同的是前者对自身进行相加，而后者是与另一个值为 <code>(1.0, 1.0)</code> 的向量相加。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toBeDoubled = <span class="type">Vector2D</span>(x: <span class="number">1.0</span>, y: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">let</span> afterDoubling = +++toBeDoubled</span><br><span class="line"><span class="comment">// toBeDoubled 现在的值为 (2.0, 8.0)</span></span><br><span class="line"><span class="comment">// afterDoubling 现在的值也为 (2.0, 8.0)</span></span><br></pre></td></tr></table></figure>
<p><a name="precedence_and_associativity_for_custom_infix_operators"></a></p>
<h3 id="自定义中缀运算符的优先级和结合性">自定义中缀运算符的优先级和结合性</h3><p>自定义的中缀运算符也可以指定优先级和结合性。<a href="#precedence_and_associativity">优先级和结合性</a>中详细阐述了这两个特性是如何对中缀运算符的运算产生影响的。</p>
<p>结合性可取的值有<code>left</code>，<code>right</code> 和 <code>none</code>。当左结合运算符跟其他相同优先级的左结合运算符写在一起时，会跟左边的值进行结合。同理，当右结合运算符跟其他相同优先级的右结合运算符写在一起时，会跟右边的值进行结合。而非结合运算符不能跟其他相同优先级的运算符写在一起。</p>
<p>结合性的默认值是 <code>none</code>，优先级的默认值 <code>100</code>。</p>
<p>以下例子定义了一个新的中缀运算符 <code>+-</code>，此运算符的结合性为 <code>left</code>，并且它的优先级为 <code>140</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> +- &#123; <span class="keyword">associativity</span> <span class="keyword">left</span> <span class="keyword">precedence</span> <span class="number">140</span> &#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> +- <span class="params">(<span class="keyword">left</span>: Vector2D, <span class="keyword">right</span>: Vector2D)</span></span> -&gt; <span class="type">Vector2D</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Vector2D</span>(x: <span class="keyword">left</span>.x + <span class="keyword">right</span>.x, y: <span class="keyword">left</span>.y - <span class="keyword">right</span>.y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> firstVector = <span class="type">Vector2D</span>(x: <span class="number">1.0</span>, y: <span class="number">2.0</span>)</span><br><span class="line"><span class="keyword">let</span> secondVector = <span class="type">Vector2D</span>(x: <span class="number">3.0</span>, y: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">let</span> plusMinusVector = firstVector +- secondVector</span><br><span class="line"><span class="comment">// plusMinusVector 是一个 Vector2D 实例，并且它的值为 (4.0, -2.0)</span></span><br></pre></td></tr></table></figure>
<p>这个运算符把两个向量的 <code>x</code> 值相加，同时用第一个向量的 <code>y</code> 值减去第二个向量的 <code>y</code> 值。因为它本质上是属于“相加型”运算符，所以将它的结合性和优先级被分别设置为 <code>left</code> 和 <code>140</code>，这与 <code>+</code> 和 <code>-</code> 等默认的中缀“相加型”运算符是相同的。关于 Swift 标准库提供的运算符的结合性与优先级，请参考 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Reference/Swift_StandardLibrary_Operators/index.html#//apple_ref/doc/uid/TP40016054" target="_blank" rel="external">Swift Standard Library Operators Reference</a>。</p>
<blockquote>
<p>注意<br>当定义前缀与后缀运算符的时候，我们并没有指定优先级。然而，如果对同一个值同时使用前缀与后缀运算符，则后缀运算符会先参与运算。</p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/chapter2/" itemprop="url">
                第二章-Swift 教程
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:01+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/chapter2/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/chapter2/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="Swift_教程">Swift 教程</h1><p>本章介绍了 Swift 的各种特性及其使用方法，是全书的核心部分。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/README/" itemprop="url">
                已同步更新到 Swift 2.1
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:00+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/README/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/README/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><blockquote>
<p>已同步更新到 Swift 2.1</p>
</blockquote>
<h1 id="2-0_新的开始">2.0 新的开始</h1><blockquote>
<p>Swift 兴趣交流群：<code>131595168</code>, <code>146932759</code>, <code>151336833</code>, <code>153549217</code>. <strong>加入一个群即可，请勿重复添加</strong></p>
<p><a target="_blank" href="http://swiftweekly.cn">订阅 Swift 开发者周报，每周获取最新 Swift 资源</a></p>
</blockquote>
<!-- -->
<blockquote>
<p>如果您觉得这个项目不错，请<a target="_blank" href="https://github.com/numbbbbb/the-swift-programming-language-in-chinese">点击Star一下</a>，您的支持是我们最大的动力。</p>
</blockquote>
<h2 id="1">1</h2><p>开源项目完成难，维护更难。</p>
<p>大家看到的是发布时的瞩目和荣耀，却没有看到项目本身质量不高、错误频出。这并不是翻译者和校对者的问题，他们已经付出了足够的努力。真正的问题在我，没有建立起长期的维护团队，因此后期的校对和更新都难以实施。</p>
<p>1.0发布之后，我们就再也没能和苹果的文档同步。语法错误、编译不通过、语言不通顺，阅读量直线下降，最低时每天只有不到1000人访问。</p>
<p>6月9日，calvingit发了一个issue“准备翻译2.0版本吗”，我没有回复，应该已经没人关注这个项目了吧，我想。</p>
<h2 id="2">2</h2><p>我错了。</p>
<p><img src="https://cloud.githubusercontent.com/assets/1472352/10558349/74eb84de-74fe-11e5-99d2-155dfacff068.png" alt="1"><br><img src="https://cloud.githubusercontent.com/assets/1472352/10558351/79101476-74fe-11e5-82d5-feb815d0b86b.png" alt="2"><br><img src="https://cloud.githubusercontent.com/assets/1472352/10558353/7c983272-74fe-11e5-8397-97c5176261ca.png" alt="3"><br><img src="https://cloud.githubusercontent.com/assets/1472352/10558354/7cd63ae0-74fe-11e5-9b9d-1d7ec6516319.png" alt="4"><br><img src="https://cloud.githubusercontent.com/assets/1472352/10558358/7fe50914-74fe-11e5-9b2b-a7b9129ea638.png" alt="5"><br><img src="https://cloud.githubusercontent.com/assets/1472352/10558360/83a8b064-74fe-11e5-9c2f-2e79d3309f62.png" alt="6"></p>
<p>在我没有任何回复的情况下，不到一天时间，有五位朋友报名。看到这些回复的时候我真的很惊讶，也很感动，无论这个项目存在多少问题，只要有人关注，有人愿意为它付出，那我还有什么理由放弃呢？</p>
<p>6月28日8点55分，Swift 2.0翻译正式启动。按下发送按钮后，我不停的刷新页面，半个小时过去了，一个回复都没有。“还是不行啊”“如果再过一个小时没人回复我就把issue删掉”，类似的念头不断出现，又不断消失。</p>
<p>9:35，xtymichael第一个回复，而且一下就认领了三篇！接下来就是不断的回复认领，到中午已经有超过一半章节被认领。</p>
<p>第二天早晨，37个章节全部认领完毕。</p>
<h2 id="3">3</h2><p>经过一个多月的努力，我们终于完成了文档的更新。听起来似乎没什么，确实，从1到n总是没有从0到1那么振奋人心。不过真正参与了才知道，修改往往比创造更麻烦，一个需要耐心，一个需要激情，前者往往得不到应有的重视。</p>
<p>但是我还是想尽最大可能去感谢他们，这个项目能走到今天，靠的不是我，是那个issue，是那些回复，是这几十个兄弟在工作学习的空闲敲下的每一个字符。而我能做的，只是在每篇文章的开头，那个所有人都会忽略的地方，加上他们的ID。</p>
<p>下次你再打开这篇文档，可以多看看那些列在最上方的ID，哪怕不去follow和star，只是看一眼就好。他们的所有努力和付出，就存在于这短暂的一瞥中。</p>
<p>Swift 2.0 参与者名单（按照章节顺序）：</p>
<ul>
<li><a href="https://github.com/xtymichael" target="_blank" rel="external">xtymichael</a></li>
<li><a href="https://github.com/AlanMelody" target="_blank" rel="external">AlanMelody</a></li>
<li><a href="https://github.com/DianQK" target="_blank" rel="external">DianQK</a></li>
<li><a href="https://github.com/dreamkidd" target="_blank" rel="external">dreamkidd</a></li>
<li><a href="https://github.com/100mango" target="_blank" rel="external">100mango</a></li>
<li><a href="https://github.com/futantan" target="_blank" rel="external">futantan</a></li>
<li><a href="https://github.com/SkyJean" target="_blank" rel="external">SkyJean</a></li>
<li><a href="https://github.com/yangsiy" target="_blank" rel="external">yangsiy</a></li>
<li><a href="https://github.com/shanksyang" target="_blank" rel="external">shanksyang</a></li>
<li><a href="https://github.com/chenmingbiao" target="_blank" rel="external">chenmingbiao</a></li>
<li><a href="https://github.com/Channe" target="_blank" rel="external">Channe</a></li>
<li><a href="https://github.com/lyojo" target="_blank" rel="external">lyojo</a></li>
<li><a href="https://github.com/SergioChan" target="_blank" rel="external">SergioChan</a></li>
<li><a href="https://github.com/mmoaay" target="_blank" rel="external">mmoaay</a></li>
<li><a href="https://github.com/buginux" target="_blank" rel="external">buginux</a></li>
<li><a href="https://github.com/KYawn" target="_blank" rel="external">KYawn</a></li>
<li><a href="https://github.com/EudeMorgen" target="_blank" rel="external">EudeMorgen</a></li>
<li><a href="https://github.com/littledogboy" target="_blank" rel="external">littledogboy</a></li>
<li><a href="https://github.com/Lenhoon" target="_blank" rel="external">Lenhoon</a></li>
<li><a href="https://github.com/ray16897188" target="_blank" rel="external">ray16897188</a></li>
<li><a href="https://github.com/wardenNScaiyi" target="_blank" rel="external">wardenNScaiyi</a></li>
<li><a href="https://github.com/miaosiqi" target="_blank" rel="external">miaosiqi</a></li>
</ul>
<p>最后，感谢<a href="http://wiki.jikexueyuan.com" target="_blank" rel="external">极客学院</a>提供的wiki系统，在国内访问起来速度很快，优化后的样式看起来也更舒服。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/v1.0/" itemprop="url">
                v1.0
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:00+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/v1.0/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/v1.0/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><blockquote>
<p>Swift 兴趣交流群：<code>305014012</code>，307017261（已满）<br><a href="http://swiftist.org" target="_blank" rel="external">Swift 开发者社区</a></p>
</blockquote>
<!-- -->
<blockquote>
<p>如果你觉得这个项目不错，请<a href="https://github.com/numbbbbb/the-swift-programming-language-in-chinese" target="_blank" rel="external">点击Star一下</a>，您的支持是我们最大的动力。</p>
</blockquote>
<!-- -->
<blockquote>
<p>关于文档中翻译错误，逻辑错误以及疑难问题答疑，请关注<a href="http://weibo.com/u/5241713117" target="_blank" rel="external">“@老码团队”</a>官方微博，会有技术人员统一收集答疑</p>
</blockquote>
<h1 id="The_Swift_Programming_Language_中文版">The Swift Programming Language 中文版</h1><p>###这一次，让中国和世界同步</p>
<p>现在是6月12日凌晨4:38，我用了整整一晚上的时间来进行最后的校对，终于可以在12日拿出一个可以发布的版本。</p>
<p>9天时间，1317个 Star，310个 Fork，超过30人参与翻译和校对工作，项目最高排名GitHub总榜第4。</p>
<p>设想过很多遍校对完成时的场景，仰天大笑还是泪流满面？真正到了这一刻才发现，疲倦已经不允许我有任何情绪。</p>
<p>说实话，刚开始发起项目的时候完全没想到会发展成今天这样，我一度计划自己一个人翻译完整本书。万万没想到，会有这么多的人愿意加入并贡献出自己的力量。</p>
<p>coverxit发给我最后一份文档的时候说，我要去背单词了，我问他，周末要考六级？他说是的。</p>
<p>pp-prog告诉我，这几天太累了，校对到一半睡着了，醒来又继续做。2点17分，发给我校对完成的文档。</p>
<p>lifedim说他平时12点就会睡，1点47分，发给我校对后的文档。</p>
<p>团队里每个人都有自己的事情，上班、上学、创业，但是我们只用了9天就完成整本书的翻译。我不知道大家付出了多少，牺牲了多少，但是我知道，他们的付出必将被这些文字记录下来，即使再过10年，20年，依然熠熠生辉，永不被人遗忘。</p>
<p>全体人员名单（排名不分先后）：</p>
<ul>
<li><a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></li>
<li><a href="https://github.com/stanzhai" target="_blank" rel="external">stanzhai</a></li>
<li><a href="https://github.com/coverxit" target="_blank" rel="external">coverxit</a></li>
<li><a href="https://github.com/wh1100717" target="_blank" rel="external">wh1100717</a></li>
<li><a href="https://github.com/TimothyYe" target="_blank" rel="external">TimothyYe</a></li>
<li><a href="https://github.com/honghaoz" target="_blank" rel="external">honghaoz</a></li>
<li><a href="https://github.com/lyuka" target="_blank" rel="external">lyuka</a></li>
<li><a href="https://github.com/JaySurplus" target="_blank" rel="external">JaySurplus</a></li>
<li><a href="https://github.com/Hawstein" target="_blank" rel="external">Hawstein</a></li>
<li><a href="https://github.com/geek5nan" target="_blank" rel="external">geek5nan</a></li>
<li><a href="https://github.com/yankuangshi" target="_blank" rel="external">yankuangshi</a></li>
<li><a href="https://github.com/xielingwang" target="_blank" rel="external">xielingwang</a></li>
<li><a href="https://github.com/yulingtianxia" target="_blank" rel="external">yulingtianxia</a></li>
<li><a href="https://github.com/twlkyao" target="_blank" rel="external">twlkyao</a></li>
<li><a href="https://github.com/dabing1022" target="_blank" rel="external">dabing1022</a></li>
<li><a href="https://github.com/vclwei" target="_blank" rel="external">vclwei</a></li>
<li><a href="https://github.com/fd5788" target="_blank" rel="external">fd5788</a></li>
<li><a href="https://github.com/siemenliu" target="_blank" rel="external">siemenliu</a></li>
<li><a href="https://github.com/youkugems" target="_blank" rel="external">youkugems</a></li>
<li><a href="https://github.com/haolloyin" target="_blank" rel="external">haolloyin</a></li>
<li><a href="https://github.com/wxstars" target="_blank" rel="external">wxstars</a></li>
<li><a href="https://github.com/IceskYsl" target="_blank" rel="external">IceskYsl</a></li>
<li><a href="https://github.com/sg552" target="_blank" rel="external">sg552</a></li>
<li><a href="https://github.com/superkam" target="_blank" rel="external">superkam</a></li>
<li><a href="https://github.com/zac1st1k" target="_blank" rel="external">zac1st1k</a></li>
<li><a href="https://github.com/bzsy" target="_blank" rel="external">bzsy</a></li>
<li><a href="https://github.com/pyanfield" target="_blank" rel="external">pyanfield</a></li>
<li><a href="https://github.com/ericzyh" target="_blank" rel="external">ericzyh</a></li>
<li><a href="https://github.com/peiyucn" target="_blank" rel="external">peiyucn</a></li>
<li><a href="https://github.com/sunfiled" target="_blank" rel="external">sunfiled</a></li>
<li><a href="https://github.com/lzw120" target="_blank" rel="external">lzw120</a></li>
<li><a href="https://github.com/viztor" target="_blank" rel="external">viztor</a></li>
<li><a href="https://github.com/wongzigii" target="_blank" rel="external">wongzigii</a></li>
<li><a href="https://github.com/umcsdon" target="_blank" rel="external">umcsdon</a></li>
<li><a href="https://github.com/zq54zquan" target="_blank" rel="external">zq54zquan</a></li>
<li><a href="https://github.com/xiehurricane" target="_blank" rel="external">xiehurricane</a></li>
<li><a href="https://github.com/Jasonbroker" target="_blank" rel="external">Jasonbroker</a></li>
<li><a href="https://github.com/tualatrix" target="_blank" rel="external">tualatrix</a></li>
<li><a href="https://github.com/pp-prog" target="_blank" rel="external">pp-prog</a></li>
<li><a href="https://github.com/088haizi" target="_blank" rel="external">088haizi</a></li>
<li><a href="https://github.com/baocaixiong" target="_blank" rel="external">baocaixiong</a></li>
<li><a href="https://github.com/yeahdongcn" target="_blank" rel="external">yeahdongcn</a></li>
<li><a href="https://github.com/shinyzhu" target="_blank" rel="external">shinyzhu</a></li>
<li><a href="https://github.com/lslxdx" target="_blank" rel="external">lslxdx</a></li>
<li><a href="https://github.com/Evilcome" target="_blank" rel="external">Evilcome</a></li>
<li><a href="https://github.com/zqp" target="_blank" rel="external">zqp</a></li>
<li><a href="https://github.com/NicePiao" target="_blank" rel="external">NicePiao</a></li>
<li><a href="https://github.com/LunaticM" target="_blank" rel="external">LunaticM</a></li>
<li><a href="https://github.com/menlongsheng" target="_blank" rel="external">menlongsheng</a></li>
<li><a href="https://github.com/lifedim" target="_blank" rel="external">lifedim</a></li>
<li><a href="https://github.com/happyming" target="_blank" rel="external">happyming</a></li>
<li><a href="https://github.com/bruce0505" target="_blank" rel="external">bruce0505</a></li>
<li><a href="https://github.com/Lin-H" target="_blank" rel="external">Lin-H</a></li>
<li><a href="https://github.com/takalard" target="_blank" rel="external">takalard</a></li>
<li><a href="https://github.com/dabing1022" target="_blank" rel="external">dabing1022</a></li>
<li><a href="https://github.com/marsprince" target="_blank" rel="external">marsprince</a></li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter3/01_About_the_Language_Reference/" itemprop="url">
                第三章-01关于语言参考（About the Language Reference）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T11:00:20+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter3/01_About_the_Language_Reference/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter3/01_About_the_Language_Reference/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="关于语言参考（About_the_Language_Reference）">关于语言参考（About the Language Reference）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/dabing1022" target="_blank" rel="external">dabing1022</a><br>校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/KYawn" target="_blank" rel="external">KYawn</a></p>
</blockquote>
<p>本页内容包括：</p>
<ul>
<li><a href="#how_to_read_the_grammar">如何阅读语法</a></li>
</ul>
<p>本书的这一节描述了 Swift 编程语言的形式语法。这里描述的语法是为了帮助您更详细地了解该语言，而不是让您直接实现一个解析器或编译器。</p>
<p>Swift 语言相对较小，这是由于 Swift 代码中的几乎所有常见类型、函数以及运算符都已经在 Swift 标准库中定义了。虽然这些类型、函数和运算符并不是 Swift 语言自身的一部分，但是它们被广泛应用于本书的讨论和代码范例中。</p>
<p><a name="how_to_read_the_grammar"></a></p>
<h2 id="如何阅读语法">如何阅读语法</h2><p>用来描述 Swift 编程语言形式语法的符号遵循下面几个约定：</p>
<ul>
<li>箭头（<code>→</code>）用来标记语法产式，可以理解为“可由……构成”。</li>
<li>斜体文字用来表示句法类型，并出现在一个语法产式规则两侧。</li>
<li>关键字和标点符号由固定宽度的粗体文本表示，只出现在一个语法产式规则的右侧。</li>
<li>可供选择的语法产式由竖线（<code>|</code>）分隔。当可选用的语法产式太多时，为了阅读方便，它们将被拆分为多行语法产式规则。</li>
<li>少数情况下，语法产式规则的右侧会有用于描述的常规字体文字。</li>
<li>可选的句法类型和字面值用尾标 <code>opt</code> 来标记。</li>
</ul>
<p>举个例子，getter-setter 的语法块的定义如下：</p>
<blockquote>
<p>getter-setter 方法块语法<br><em>getter-setter 方法块</em> → { <a href="05_Declarations.html#getter-clause"><em>getter 子句</em></a> <a href="05_Declarations.html#setter-clause"><em>setter 子句</em></a><sub>可选</sub> } | { <a href="05_Declarations.html#setter-clause"><em>setter 子句</em></a> <a href="05_Declarations.html#getter-clause"><em>getter 子句</em></a> }</p>
</blockquote>
<p>这个定义表明，一个 getter-setter 方法块可以由一个 getter 子句后跟一个可选的 setter 子句构成，然后用大括号括起来，或者由一个 setter 子句后跟一个 getter 子句构成，然后用大括号括起来。下面的两个语法产式等价于上述的语法产式，并明确指出了如何取舍：</p>
<blockquote>
<p>getter-setter 方法块语法<br>getter-setter 方法块 → { <a href="05_Declarations.html#getter-clause"><em>getter 子句</em></a>  <a href="05_Declarations.html#setter-clause"><em>setter 子句</em></a><sub>可选</sub> }<br>getter-setter 方法块 → { <a href="05_Declarations.html#setter-clause"><em>setter 子句</em></a> <a href="05_Declarations.html#getter-clause"><em>getter 子句</em></a> }</p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter3/02_Lexical_Structure/" itemprop="url">
                第三章-02词法结构（Lexical Structure）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T11:00:19+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter3/02_Lexical_Structure/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter3/02_Lexical_Structure/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="词法结构（Lexical_Structure）">词法结构（Lexical Structure）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/superkam" target="_blank" rel="external">superkam</a><br>校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/buginux" target="_blank" rel="external">buginux</a></p>
<p>2.1<br>翻译：<a href="https://github.com/mmoaay" target="_blank" rel="external">mmoaay</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#whitespace_and_comments">空白与注释</a></li>
<li><a href="#identifiers">标识符</a></li>
<li><a href="#keywords">关键字和标点符号</a></li>
<li><a href="#literals">字面量</a><ul>
<li><a href="#integer_literals">整数字面量</a> </li>
<li><a href="#floating_point_literals">浮点数字面量</a></li>
<li><a href="#string_literals">字符串字面量</a></li>
</ul>
</li>
<li><a href="#operators">运算符</a></li>
</ul>
<p>Swift 的“词法结构”描述了能构成该语言中合法符号的字符序列。这些合法符号组成了语言中最底层的构建基块，并在之后的章节中用于描述语言的其他部分。一个合法符号由一个标识符、关键字、标点符号、字面量或运算符组成。</p>
<p>通常情况下，符号是根据随后将介绍的语法约束，由 Swift 源文件的输入文本中提取可能的最长子串生成。这种方法称为“最长匹配”，或者“最大适合”。</p>
<p><a id="whitespace_and_comments"></a></p>
<h2 id="空白与注释">空白与注释</h2><p>空白有两个用途：分隔源文件中的符号以及帮助区分运算符属于前缀还是后缀（参见 <a href="#operators">运算符</a>），在其他情况下则会被忽略。以下的字符会被当作空白：空格（U+0020）、换行符（U+000A）、回车符（U+000D）、水平制表符（U+0009）、垂直制表符（U+000B）、换页符（U+000C）以及空（U+0000）。</p>
<p>注释被编译器当作空白处理。单行注释由 <code>//</code> 开始直至遇到换行符（U+000A）或者回车符（U+000D）。多行注释由 <code>/*</code> 开始，以 <code>*/</code> 结束。注释允许嵌套，但注释标记必须匹配。</p>
<p>正如 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Xcode/Reference/xcode_markup_formatting_ref/index.html#//apple_ref/doc/uid/TP40016497" target="_blank" rel="external"><em>Markup Formatting Reference</em></a> 所述，注释可以包含附加的格式和标记。</p>
<p><a id="identifiers"></a></p>
<h2 id="标识符">标识符</h2><p>标识符可以由以下的字符开始：大写或小写的字母 <code>A</code> 到 <code>Z</code>、下划线 <code>_</code>、基本多文种平面中的 Unicode 非组合字符以及基本多文种平面以外的非个人专用区字符。首字符之后，允许使用数字和 Unicode 字符组合。</p>
<p>使用保留字作为标识符，需要在其前后增加反引号 <code>` </code>。例如，<code>class</code> 不是合法的标识符，但可以使用 <code>`class` </code>。反引号不属于标识符的一部分，<code>`x` </code> 和 <code>x</code> 表示同一标识符。</p>
<p>闭包中如果没有明确指定参数名称，参数将被隐式命名为 <code>$0</code>、<code>$1</code>、<code>$2</code> 等等。这些命名在闭包作用域范围内是合法的标识符。</p>
<blockquote>
<p>标识符语法</p>
</blockquote>
<p><a id="identifier"></a></p>
<blockquote>
<p><em>标识符</em> → <a href="#identifier-head"><em>头部标识符</em></a> <a href="#identifier-characters"><em>标识符字符组</em></a><sub>可选</sub><br><em>标识符</em> → `<a href="#identifier-head"><em>头部标识符</em></a> <a href="#identifier-characters"><em>标识符字符组</em></a><sub>可选</sub>`<br><em>标识符</em> → <a href="#implicit-parameter-name"><em>隐式参数名</em></a><br><a id="identifier-list"></a><br><em>标识符列表</em> → <a href="#identifier"><em>标识符</em></a> | <a href="#identifier"><em>标识符</em></a> <strong>,</strong> <a href="#identifier-list"><em>标识符列表</em></a></p>
</blockquote>
<p><a id="identifier-head"></a>        </p>
<blockquote>
<p><em>头部标识符</em> → 大写或小写字母 A - Z<br><em>头部标识符</em> → _<br><em>头部标识符</em> → U+00A8，U+00AA，U+00AD，U+00AF，U+00B2–U+00B5，或者 U+00B7–U+00BA<br><em>头部标识符</em> → U+00BC–U+00BE，U+00C0–U+00D6，U+00D8–U+00F6，或者 U+00F8–U+00FF<br><em>头部标识符</em> → U+0100–U+02FF，U+0370–U+167F，U+1681–U+180D，或者 U+180F–U+1DBF<br><em>头部标识符</em> → U+1E00–U+1FFF<br><em>头部标识符</em> → U+200B–U+200D，U+202A–U+202E，U+203F–U+2040，U+2054，或者 U+2060–U+206F<br><em>头部标识符</em> → U+2070–U+20CF，U+2100–U+218F，U+2460–U+24FF，或者 U+2776–U+2793<br><em>头部标识符</em> → U+2C00–U+2DFF 或者 U+2E80–U+2FFF<br><em>头部标识符</em> → U+3004–U+3007，U+3021–U+302F，U+3031–U+303F，或者 U+3040–U+D7FF<br><em>头部标识符</em> → U+F900–U+FD3D，U+FD40–U+FDCF，U+FDF0–U+FE1F，或者 U+FE30–U+FE44<br><em>头部标识符</em> → U+FE47–U+FFFD<br><em>头部标识符</em> → U+10000–U+1FFFD，U+20000–U+2FFFD，U+30000–U+3FFFD，或者 U+40000–U+4FFFD<br><em>头部标识符</em> → U+50000–U+5FFFD，U+60000–U+6FFFD，U+70000–U+7FFFD，或者 U+80000–U+8FFFD<br><em>头部标识符</em> → U+90000–U+9FFFD，U+A0000–U+AFFFD，U+B0000–U+BFFFD，或者 U+C0000–U+CFFFD<br><em>头部标识符</em> → U+D0000–U+DFFFD 或者 U+E0000–U+EFFFD  </p>
</blockquote>
<p><a id="identifier-character"></a></p>
<blockquote>
<p><em>标识符字符</em> → 数值 0 - 9<br><em>标识符字符</em> → U+0300–U+036F，U+1DC0–U+1DFF，U+20D0–U+20FF，或者 U+FE20–U+FE2F<br><em>标识符字符</em> → <a href="#identifier-head"><em>头部标识符</em></a><br><a id="identifier-characters"></a><br><em>标识符字符组</em> → <a href="#identifier-character"><em>标识符字符</em></a> <a href="#identifier-characters"><em>标识符字符组</em></a><sub>可选</sub>  </p>
</blockquote>
<p><a id="implicit-parameter-name"></a>    </p>
<blockquote>
<p><em>隐式参数名</em> → <strong>$</strong> <a href="#decimal-digits"><em>十进制数字列表</em></a>  </p>
</blockquote>
<p><a id="keywords"></a></p>
<h2 id="关键字和标点符号">关键字和标点符号</h2><p>下面这些被保留的关键字不允许用作标识符，除非被反引号转义，具体描述请参考 <a href="#identifiers">标识符</a>。</p>
<ul>
<li>用在声明中的关键字： <code>class</code>、<code>deinit</code>、<code>enum</code>、<code>extension</code>、<code>func</code>、<code>import</code>、<code>init</code>、<code>inout</code>、<code>internal</code>、<code>let</code>、<code>operator</code>、<code>private</code>、<code>protocol</code>、<code>public</code>、<code>static</code>、<code>struct</code>、<code>subscript</code>、<code>typealias</code>、<code>var</code>。</li>
<li>用在语句中的关键字： <code>break</code>、<code>case</code>、<code>continue</code>、<code>default</code>、<code>defer</code>、<code>do</code>、<code>else</code>、<code>fallthrough</code>、<code>for</code>、<code>guard</code>、<code>if</code>、<code>in</code>、<code>repeat</code>、<code>return</code>、<code>switch</code>、<code>where</code>、<code>while</code>。</li>
<li>用在表达式和类型中的关键字： <code>as</code>、<code>catch</code>、<code>dynamicType</code>、<code>false</code>、<code>is</code>、<code>nil</code>、<code>rethrows</code>、<code>super</code>、<code>self</code>、<code>Self</code>、<code>throw</code>、<code>throws</code>、<code>true</code>、<code>try</code>、<code>__COLUMN__</code>、<code>__FILE__</code>、<code>__FUNCTION__</code>、<code>__LINE__</code>。</li>
<li>用在模式中的关键字：<code>_</code></li>
<li>特定上下文中被保留的关键字： <code>associativity</code>、<code>convenience</code>、<code>dynamic</code>、<code>didSet</code>、<code>final</code>、<code>get</code>、<code>infix</code>、<code>indirect</code>、<code>lazy</code>、<code>left</code>、<code>mutating</code>、<code>none</code>、<code>nonmutating</code>、<code>optional</code>、<code>override</code>、<code>postfix</code>、<code>precedence</code>、<code>prefix</code>、<code>Protocol</code>、<code>required</code>、<code>right</code>、<code>set</code>、<code>Type</code>、<code>unowned</code>、<code>weak</code>、<code>willSet</code>，这些关键字在特定上下文之外可以被用做标识符。</li>
</ul>
<p>以下符号被当作保留符号，不能用于自定义运算符： <code>(</code>、<code>)</code>、<code>{</code>、<code>}</code>、<code>[</code>、<code>]</code>、<code>.</code>、<code>,</code>、<code>:</code>、<code>;</code>、<code>=</code>、<code>@</code>、<code>#</code>、<code>&amp;</code>（作为前缀运算符）、<code>-&gt;</code>、<code>` </code>、<code>?</code>、<code>!</code>（作为后缀运算符）。</p>
<p><a id="literals"></a></p>
<h2 id="字面量">字面量</h2><p>字面量是用来表示源码中某种特定类型的值，比如一个数字或字符串。</p>
<p>下面是字面量的一些示例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">42</span>              <span class="comment">// 整数字面量</span></span><br><span class="line"><span class="number">3.14159</span>         <span class="comment">// 浮点数字面量</span></span><br><span class="line"><span class="string">"Hello, world!"</span> <span class="comment">// 字符串字面量</span></span><br><span class="line"><span class="literal">true</span>			<span class="comment">// 布尔值字面量</span></span><br></pre></td></tr></table></figure>
<p>字面量本身并不包含类型信息。事实上，一个字面量会被解析为拥有无限的精度，然后 Swift 的类型推导会尝试去推导出这个字面量的类型。比如，在 <code>let x: Int8 = 42</code> 这个声明中，Swift 使用了显式类型标注（<code>: Int8</code>）来推导出 <code>42</code> 这个整数字面量的类型是 <code>Int8</code>。如果没有可用的类型信息， Swift 则会从标准库中定义的字面量类型中推导出一个默认的类型。整数字面量的默认类型是 <code>Int</code>，浮点数字面量的默认类型是 <code>Double</code>，字符串字面量的默认类型是 <code>String</code>，布尔值字面量的默认类型是 <code>Bool</code>。比如，在 <code>let str = &quot;Hello, world&quot;</code> 这个声明中，字符串 <code>&quot;Hello, world&quot;</code> 的默认推导类型就是 <code>String</code>。</p>
<p>当为一个字面量值指定了类型标注的时候，这个标注的类型必须能通过这个字面量值实例化。也就是说，这个类型必须符合这些 Swift 标准库协议中的一个：整数字面量的 <code>IntegerLiteralConvertible</code> 协议、浮点数字面量的 <code>FloatingPointLiteralConvertible</code> 协议、字符串字面量的 <code>StringLiteralConvertible</code> 协议以及布尔值字面量的 <code>BooleanLiteralConvertible</code> 协议。比如，<code>Int8</code> 符合 <code>IntegerLiteralConvertible</code> 协议，因此它能在 <code>let x: Int8 = 42</code> 这个声明中作为整数字面量 <code>42</code> 的类型标注。</p>
<blockquote>
<p>字面量语法  </p>
<p><em>字面量</em> → <a href="#numeric-literal"><em>数值字面量</em></a> | <a href="#string-literal"><em>字符串字面量</em></a> | <a href="#boolean-literal"><em>布尔值字面量</em></a> | <a href="#nil-literal"><em>nil 字面量</em></a>    </p>
</blockquote>
<p><a id="numeric-literal"></a>    </p>
<blockquote>
<p><em>数值字面量</em> → <strong>-</strong><sub>可选</sub> <a href="#integer-literal"><em>整数字面量</em></a> | <strong>-</strong><sub>可选</sub> <a href="#floating-point-literal"><em>浮点数字面量</em></a><br><a id="boolean-literal"></a><br><em>布尔值字面量</em> → <strong>true</strong> | <strong>false</strong><br><a id="nil-literal"></a><br><em>nil 字面量</em> → <strong>nil</strong></p>
</blockquote>
<p><a id="integer_literals"></a></p>
<h3 id="整数字面量">整数字面量</h3><p>整数字面量表示未指定精度整数的值。整数字面量默认用十进制表示，可以加前缀来指定其他的进制，二进制字面量加 <code>0b</code>，八进制字面量加 <code>0o</code>，十六进制字面量加 <code>0x</code>。</p>
<p>十进制字面量包含数字 <code>0</code> 至 <code>9</code>。二进制字面量只包含 <code>0</code> 或 <code>1</code>，八进制字面量包含数字 <code>0</code> 至 <code>7</code>，十六进制字面量包含数字 <code>0</code> 至 <code>9</code> 以及字母 <code>A</code> 至 <code>F</code>（大小写均可）。</p>
<p>负整数的字面量在整数字面量前加负号 <code>-</code>，比如 <code>-42</code>。</p>
<p>整型字面面可以使用下划线 <code>_</code> 来增加数字的可读性，下划线会被系统忽略，因此不会影响字面量的值。同样地，也可以在数字前加 <code>0</code>，并不会影响字面量的值。</p>
<p>除非特别指定，整数字面量的默认推导类型为 Swift 标准库类型中的 <code>Int</code>。Swift 标准库还定义了其他不同长度以及是否带符号的整数类型，请参考 <a href="../chapter2/01_The_Basics.html#integers">整数</a>。</p>
<blockquote>
<p>整数字面量语法  </p>
</blockquote>
<p><a id="integer-literal"></a></p>
<blockquote>
<p><em>整数字面量</em> → <a href="#binary-literal"><em>二进制字面量</em></a><br><em>整数字面量</em> → <a href="#octal-literal"><em>八进制字面量</em></a><br><em>整数字面量</em> → <a href="#decimal-literal"><em>十进制字面量</em></a><br><em>整数字面量</em> → <a href="#hexadecimal-literal"><em>十六进制字面量</em></a>  </p>
</blockquote>
<p><a id="binary-literal"></a></p>
<blockquote>
<p><em>二进制字面量</em> → <strong>0b</strong> <a href="#binary-digit"><em>二进制数字</em></a> <a href="#binary-literal-characters"><em>二进制字面量字符组</em></a><sub>可选</sub><br><a id="binary-digit"></a><br><em>二进制数字</em> → 数值 0 到 1<br><a id="binary-literal-character"></a><br><em>二进制字面量字符</em> → <a href="#binary-digit"><em>二进制数字</em></a> | _<br><a id="binary-literal-characters"></a><br><em>二进制字面量字符组</em> → <a href="#binary-literal-character"><em>二进制字面量字符</em></a> <a href="#binary-literal-characters"><em>二进制字面量字符组</em></a><sub>可选</sub>  </p>
</blockquote>
<p><a id="octal-literal"></a>    </p>
<blockquote>
<p><em>八进制字面量</em> → <strong>0o</strong> <a href="#octal-digit"><em>八进字数字</em></a> <a href="#octal-literal-characters"><em>八进制字符组</em></a><sub>可选</sub><br><a id="octal-digit"></a><br><em>八进字数字</em> → 数值 0 到 7<br><a id="octal-literal-character"></a><br><em>八进制字符</em> → <a href="#octal-digit"><em>八进字数字</em></a> | _<br><a id="octal-literal-characters"></a><br><em>八进制字符组</em> → <a href="#octal-literal-character"><em>八进制字符</em></a> <a href="#octal-literal-characters"><em>八进制字符组</em></a><sub>可选</sub></p>
</blockquote>
<p><a id="decimal-literal"></a>    </p>
<blockquote>
<p><em>十进制字面量</em> → <a href="#decimal-digit"><em>十进制数字</em></a> <a href="#decimal-literal-characters"><em>十进制字符组</em></a><sub>可选</sub><br><a id="decimal-digit"></a><br><em>十进制数字</em> → 数值 0 到 9<br><a id="decimal-digits"></a><br><em>十进制数字组</em> → <a href="#decimal-digit"><em>十进制数字</em></a> <a href="#decimal-digits"><em>十进制数字组</em></a><sub>可选</sub><br><a id="decimal-literal-character"></a><br><em>十进制字符</em> → <a href="#decimal-digit"><em>十进制数字</em></a> | _<br><a id="decimal-literal-characters"></a><br><em>十进制字符组</em> → <a href="#decimal-literal-character"><em>十进制字符</em></a> <a href="#decimal-literal-characters"><em>十进制字符组</em></a><sub>可选</sub> </p>
</blockquote>
<p><a id="hexadecimal-literal"></a>    </p>
<blockquote>
<p><em>十六进制字面量</em> → <strong>0x</strong> <a href="#hexadecimal-digit"><em>十六进制数字</em></a> <a href="#hexadecimal-literal-characters"><em>十六进制字面量字符组</em></a><sub>可选</sub><br><a id="hexadecimal-digit"></a><br><em>十六进制数字</em> → 数值 0 到 9, 字母 a 到 f, 或 A 到 F<br><a id="hexadecimal-literal-character"></a><br><em>十六进制字符</em> → <a href="#hexadecimal-digit"><em>十六进制数字</em></a> | _<br><a id="hexadecimal-literal-characters"></a><br><em>十六进制字面量字符组</em> → <a href="#hexadecimal-literal-character"><em>十六进制字符</em></a> <a href="#hexadecimal-literal-characters"><em>十六进制字面量字符组</em></a><sub>可选</sub>  </p>
</blockquote>
<p><a id="floating_point_literals"></a></p>
<h3 id="浮点数字面量">浮点数字面量</h3><p>浮点数字面量表示未指定精度浮点数的值。</p>
<p>浮点数字面量默认用十进制表示（无前缀），也可以用十六进制表示（加前缀 <code>0x</code>）。</p>
<p>十进制浮点数字面量由十进制数字串后跟小数部分或指数部分（或两者皆有）组成。十进制小数部分由小数点 <code>.</code> 后跟十进制数字串组成。指数部分由大写或小写字母 <code>e</code> 为前缀后跟十进制数字串组成，这串数字表示 <code>e</code> 之前的数量乘以 10 的几次方。例如：<code>1.25e2</code> 表示 <code>1.25 ⨉ 10^2</code>，也就是 <code>125.0</code>；同样，<code>1.25e－2</code> 表示 <code>1.25 ⨉ 10^－2</code>，也就是 <code>0.0125</code>。</p>
<p>十六进制浮点数字面量由前缀 <code>0x</code> 后跟可选的十六进制小数部分以及十六进制指数部分组成。十六进制小数部分由小数点后跟十六进制数字串组成。指数部分由大写或小写字母 <code>p</code> 为前缀后跟十进制数字串组成，这串数字表示 <code>p</code> 之前的数量乘以 2 的几次方。例如：<code>0xFp2</code> 表示 <code>15 ⨉ 2^2</code>，也就是 <code>60</code>；同样，<code>0xFp-2</code> 表示 <code>15 ⨉ 2^-2</code>，也就是 <code>3.75</code>。</p>
<p>负数的浮点数字面量由负号 <code>-</code> 和浮点数字面量组成，例如 <code>-42.5</code>。</p>
<p>浮点数字面量允许使用下划线 <code>_</code> 来增强数字的可读性，下划线会被系统忽略，因此不会影响字面量的值。同样地，也可以在数字前加 <code>0</code>，并不会影响字面量的值。</p>
<p>除非特别指定，浮点数字面量的默认推导类型为 Swift 标准库类型中的 <code>Double</code>，表示 64 位浮点数。Swift 标准库也定义了 <code>Float</code> 类型，表示 32 位浮点数。</p>
<blockquote>
<p>浮点数字面量语法  </p>
</blockquote>
<p><a id="floating-point-literal"></a> </p>
<blockquote>
<p><em>浮点数字面量</em> → <a href="#decimal-literal"><em>十进制字面量</em></a> <a href="#decimal-fraction"><em>十进制分数</em></a><sub>可选</sub> <a href="#decimal-exponent"><em>十进制指数</em></a><sub>可选</sub><br><em>浮点数字面量</em> → <a href="#hexadecimal-literal"><em>十六进制字面量</em></a> <a href="#hexadecimal-fraction"><em>十六进制分数</em></a><sub>可选</sub> <a href="#hexadecimal-exponent"><em>十六进制指数</em></a></p>
</blockquote>
<p><a id="decimal-fraction"></a>    </p>
<blockquote>
<p><em>十进制分数</em> → <strong>.</strong> <a href="#decimal-literal"><em>十进制字面量</em></a><br><a id="decimal-exponent"></a><br><em>十进制指数</em> → <a href="#floating-point-e"><em>十进制指数 e</em></a> <a href="#sign"><em>正负号</em></a><sub>可选</sub> <a href="#decimal-literal"><em>十进制字面量</em></a>  </p>
</blockquote>
<p><a id="hexadecimal-fraction"></a></p>
<blockquote>
<p><em>十六进制分数</em> → <strong>.</strong> <a href="#hexadecimal-digit"><em>十六进制数字</em></a> <a href="#hexadecimal-literal-characters"><em>十六进制字面量字符组</em></a><sub>可选</sub><br><a id="hexadecimal-exponent"></a><br><em>十六进制指数</em> → <a href="#floating-point-p"><em>十六进制指数 p</em></a> <a href="#sign"><em>正负号</em></a><sub>可选</sub> <a href="#decimal-literal"><em>十进制字面量</em></a>  </p>
</blockquote>
<p><a id="floating-point-e"></a></p>
<blockquote>
<p><em>十进制指数 e</em> → <strong>e</strong> | <strong>E</strong><br><a id="floating-point-p"></a><br><em>十六进制指数 p</em> → <strong>p</strong> | <strong>P</strong><br><a id="sign"></a><br><em>正负号</em> → <strong>+</strong> | <strong>-</strong>  </p>
</blockquote>
<p><a id="string_literals"></a></p>
<h3 id="字符串字面量">字符串字面量</h3><p>字符串字面量由被包在双引号中的一串字符组成，形式如下：</p>
<blockquote>
<p>“<code>字符</code>“</p>
</blockquote>
<p>字符串字面量中不能包含未转义的双引号（<code>&quot;</code>）、未转义的反斜线（<code>\</code>）、回车符、换行符。</p>
<p>可以在字符串字面量中使用的转义特殊符号如下：</p>
<ul>
<li>空字符 <code>\0</code></li>
<li>反斜线 <code>\\</code></li>
<li>水平制表符 <code>\t</code></li>
<li>换行符 <code>\n</code></li>
<li>回车符 <code>\r</code></li>
<li>双引号 <code>\&quot;</code></li>
<li>单引号 <code>\&#39;</code></li>
<li>Unicode 标量 <code>\u{</code>n<code>}</code>，n 为一到八位的十六进制数字</li>
</ul>
<p>字符串字面量允许在反斜杠 <code>\</code> 后的括号 <code>()</code> 中插入表达式的值。插入表达式可以包含字符串字面量，但不能包含未转义的双引号 <code>&quot;</code>、未转义的反斜线 <code>\</code>、回车符、换行符。</p>
<p>例如，以下所有字符串字面量的值都是相同的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"1 2 3"</span></span><br><span class="line"><span class="string">"1 2 <span class="subst">\("<span class="number">3</span>")</span>"</span></span><br><span class="line"><span class="string">"1 2 <span class="subst">\(<span class="number">3</span>)</span>"</span></span><br><span class="line"><span class="string">"1 2 <span class="subst">\(<span class="number">1</span> + <span class="number">2</span>)</span>"</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">3</span>; <span class="string">"1 2 <span class="subst">\(x)</span>"</span></span><br></pre></td></tr></table></figure>
<p>字符串字面量的默认推导类型为 <code>String</code>。更多有关 <code>String</code> 类型的信息请参考 <a href="../chapter2/03_Strings_and_Characters.html">字符串和字符</a> 以及 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Reference/Swift_String_Structure/index.html#//apple_ref/doc/uid/TP40015181" target="_blank" rel="external"><em>String Structure Reference</em></a>。</p>
<p>用 <code>＋</code> 操作符连接的字符型字面量是在编译时进行连接的。比如下面的 <code>textA</code> 和 <code>textB</code> 是完全一样的，<code>textA</code> 没有任何运行时的连接操作。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> textA = <span class="string">"Hello "</span> + <span class="string">"world"</span></span><br><span class="line"><span class="keyword">let</span> textB = <span class="string">"Hello world"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>字符串字面量语法  </p>
</blockquote>
<p><a id="string-literal"></a></p>
<blockquote>
<p><em>字符串字面量</em> → <a href="#static-string-literal"><em>静态字符串字面量</em></a> | <a href="#interpolated-string-literal"><em>插值字符串字面量</em></a> </p>
</blockquote>
<p><a id="static-string-literal"></a></p>
<blockquote>
<p><em>静态字符串字面量</em> → <strong>“</strong><a href="#quoted-text"><em>引用文本</em></a><sub>可选</sub><strong>“</strong><br><a id="quoted-text"></a><br><em>引用文本</em> → <a href="#quoted-text-item"><em>引用文本项</em></a> <a href="#quoted-text"><em>引用文本</em></a><sub>可选</sub><br><a id="quoted-text-item"></a><br><em>引用文本项</em> → <a href="#escaped-character"><em>转义字符</em></a><br><em>引用文本项</em> → 除了 <strong>“</strong>、<strong>\</strong>、U+000A、U+000D 以外的所有 Unicode 字符</p>
</blockquote>
<p><a id="interpolated-string-literal"></a></p>
<blockquote>
<p><em>插值字符串字面量</em> → <strong>“</strong><a href="#interpolated-text"><em>插值文本</em></a><sub>可选</sub><strong>“</strong><br><a id="interpolated-text"></a><br><em>插值文本</em> → <a href="#interpolated-text-item"><em>插值文本项</em></a> <a href="#interpolated-text"><em>插值文本</em></a><sub>可选</sub><br><a id="interpolated-text-item"></a><br><em>插值文本项</em> → <strong>\**</strong>(<strong><a href="./04_Expressions.html"><em>表达式</em></a></strong>)<em>* | [</em>引用文本项*](#quoted-text-item)</p>
</blockquote>
<p><a id="escaped-character"></a></p>
<blockquote>
<p><em>转义字符</em> → <strong>\**</strong>0<strong> | </strong>\<strong>**\</strong> | <strong>\t</strong> | <strong>\n</strong> | <strong>\r</strong> | <strong>\“</strong> | <strong>\‘</strong><br><em>转义字符</em> → <strong>\u {</strong> <a href="#unicode-scalar-digits"><em>unicode 标量数字</em></a> <strong>}</strong><br><a id="unicode-scalar-digits"></a><br><em>unicode 标量数字</em> → 一到八位的十六进制数字</p>
</blockquote>
<p><a id="operators"></a></p>
<h2 id="运算符">运算符</h2><p>Swift 标准库定义了许多可供使用的运算符，其中大部分在 <a href="../chapter2/02_Basic_Operators.html">基础运算符</a> 和 <a href="../chapter2/25_Advanced_Operators.html">高级运算符</a> 中进行了阐述。这一小节将描述哪些字符能用于自定义运算符。</p>
<p>自定义运算符可以由以下其中之一的 ASCII 字符 <code>/</code>、<code>=</code>、 <code>-</code>、<code>+</code>、<code>!</code>、<code>*</code>、<code>%</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&amp;</code>、<code>|</code>、<code>^</code>、<code>?</code> 以及 <code>~</code>，或者后面语法中规定的任一个 Unicode 字符开始。在第一个字符之后，允许使用组合型 Unicode 字符。也可以使用两个或者多个的点号来自定义运算符（比如，<code>....</code>）。虽然可以自定义包含问号 <code>?</code> 的运算符，但是这个运算符不能只包含单独的一个问号。</p>
<blockquote>
<p>注意<br>以下这些标记 <code>=</code>、<code>-&gt;</code>、<code>//</code>、<code>/*</code>、<code>*/</code>、<code>.</code>、<code>&lt;</code>（前缀运算符）、<code>&amp;</code>、<code>?</code>、<code>?</code>（中缀运算符）、<code>&gt;</code>（后缀运算符）、<code>!</code> 、<code>?</code> 是被系统保留的。这些符号不能被重载，也不能用于自定义运算符。</p>
</blockquote>
<p>运算符两侧的空白被用来区分该运算符是否为前缀运算符、后缀运算符或二元运算符。规则总结如下：</p>
<ul>
<li>如果运算符两侧都有空白或两侧都无空白，将被看作二元运算符。例如：<code>a+b</code> 和 <code>a + b</code> 中的运算符 <code>+</code> 被看作二元运算符。</li>
<li>如果运算符只有左侧空白，将被看作前缀一元运算符。例如 <code>a ++b</code> 中的 <code>++</code> 被看作前缀一元运算符。</li>
<li>如果运算符只有右侧空白，将被看作后缀一元运算符。例如 <code>a++ b</code> 中的 <code>++</code> 被看作后缀一元运算符。</li>
<li>如果运算符左侧没有空白并紧跟 <code>.</code>，将被看作后缀一元运算符。例如 <code>a++.b</code> 中的 <code>++</code> 被看作后缀一元运算符（即上式被视为 <code>a++ .b</code> 而非 <code>a ++ .b</code>）。</li>
</ul>
<p>鉴于这些规则，运算符前的字符 <code>(</code>、<code>[</code> 和 <code>{</code>，运算符后的字符 <code>)</code>、<code>]</code> 和 <code>}</code>，以及字符 <code>,</code>、<code>;</code> 和 <code>:</code> 都被视为空白。</p>
<p>以上规则需注意一点，如果预定义运算符 <code>!</code> 或 <code>?</code> 左侧没有空白，则不管右侧是否有空白都将被看作后缀运算符。如果将 <code>?</code> 用作可选链式调用运算符，左侧必须无空白。如果用于条件运算符 <code>? :</code>，必须两侧都有空白。</p>
<p>在某些特定的设计中 ，以 <code>&lt;</code> 或 <code>&gt;</code> 开头的运算符会被分离成两个或多个符号，剩余部分可能会以同样的方式被再次分离。因此，在 <code>Dictionary&lt;String, Array&lt;Int&gt;&gt;</code> 中没有必要添加空白来消除闭合字符 <code>&gt;</code> 的歧义。在这个例子中， 闭合字符 <code>&gt;</code> 不会被视为单独的符号，因而不会被错误解析为 <code>&gt;&gt;</code> 运算符。</p>
<p>要学习如何自定义运算符，请参考 <a href="../chapter2/25_Advanced_Operators.html#custom_operators">自定义运算符</a> 和 <a href="05_Declarations.html#operator_declaration">运算符声明</a>。要学习如何重载运算符，请参考 <a href="../chapter2/25_Advanced_Operators.html#operator_functions">运算符函数</a>。</p>
<blockquote>
<p>运算符语法  </p>
</blockquote>
<p><a id="operator"></a></p>
<blockquote>
<p><em>运算符</em> → <a href="#operator-head"><em>头部运算符</em></a> <a href="#operator-characters"><em>运算符字符组</em></a><sub>可选</sub><br><em>运算符</em> → <a href="#dot-operator-head"><em>头部点运算符</em></a> <a href="#dot-operator-characters"><em>点运算符字符组</em></a><sub>可选</sub>    </p>
</blockquote>
<p><a id="operator-head"></a>    </p>
<blockquote>
<p><em>头部运算符</em> → <strong>/</strong> | <strong>=</strong> | <strong>-</strong> | <strong>+</strong> | <strong>!</strong> | <strong>*</strong> | <strong>%</strong> | <strong>&lt;</strong> | <strong>&gt;</strong> | <strong>&amp;</strong> | <strong>|</strong> | <strong>^</strong> | <strong>~</strong> | <strong>?</strong><br><em>头部运算符</em> → U+00A1–U+00A7<br><em>头部运算符</em> → U+00A9 或 U+00AB<br><em>头部运算符</em> → U+00AC 或 U+00AE<br><em>头部运算符</em> → U+00B0–U+00B1，U+00B6，U+00BB，U+00BF，U+00D7，或 U+00F7<br><em>头部运算符</em> → U+2016–U+2017 或 U+2020–U+2027<br><em>头部运算符</em> → U+2030–U+203E<br><em>头部运算符</em> → U+2041–U+2053<br><em>头部运算符</em> → U+2055–U+205E<br><em>头部运算符</em> → U+2190–U+23FF<br><em>头部运算符</em> → U+2500–U+2775<br><em>头部运算符</em> → U+2794–U+2BFF<br><em>头部运算符</em> → U+2E00–U+2E7F<br><em>头部运算符</em> → U+3001–U+3003<br><em>头部运算符</em> → U+3008–U+3030 </p>
</blockquote>
<p><a id="operator-character"></a>       </p>
<blockquote>
<p><em>运算符字符</em> → <a href="#operator-head"><em>头部运算符</em></a><br><em>运算符字符</em> → U+0300–U+036F<br><em>运算符字符</em> → U+1DC0–U+1DFF<br><em>运算符字符</em> → U+20D0–U+20FF<br><em>运算符字符</em> → U+FE00–U+FE0F<br><em>运算符字符</em> → U+FE20–U+FE2F<br><em>运算符字符</em> → U+E0100–U+E01EF<br><a id="operator-characters"></a><br><em>运算符字符组</em> → <a href="#operator-character"><em>运算符字符</em></a> <a href="#operator-characters"><em>运算符字符组</em></a><sub>可选</sub>    </p>
</blockquote>
<p><a id="dot-operator-head"></a>    </p>
<blockquote>
<p><em>头部点运算符</em> → <strong>..</strong><br><a id="dot-operator-character"></a><br><em>点运算符字符</em> → <strong>.</strong> | <a href="#operator-character"><em>运算符字符</em></a><br><a id="dot-operator-characters"></a><br><em>点运算符字符组</em> → <a href="#dot-operator-character"><em>点运算符字符</em></a> <a href="#dot-operator-characters"><em>点运算符字符组</em></a><sub>可选</sub></p>
</blockquote>
<p><a id="binary-operator"></a></p>
<blockquote>
<p><em>二元运算符</em> → <a href="#operator"><em>运算符</em></a><br><a id="prefix-operator"></a><br><em>前缀运算符</em> → <a href="#operator"><em>运算符</em></a><br><a id="postfix-operator"></a><br><em>后缀运算符</em> → <a href="#operator"><em>运算符</em></a>  </p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter3/03_Types/" itemprop="url">
                第三章-03类型（Types）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T11:00:18+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter3/03_Types/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter3/03_Types/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="类型（Types）">类型（Types）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/lyuka" target="_blank" rel="external">lyuka</a><br>校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>, <a href="https://github.com/stanzhai" target="_blank" rel="external">stanzhai</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/EudeMorgen" target="_blank" rel="external">EudeMorgen</a></p>
<p>2.1<br>翻译：<a href="https://github.com/mmoaay" target="_blank" rel="external">mmoaay</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#type_annotation">类型注解</a></li>
<li><a href="#type_identifier">类型标识符</a></li>
<li><a href="#tuple_type">元组类型</a></li>
<li><a href="#function_type">函数类型</a></li>
<li><a href="#array_type">数组类型</a></li>
<li><a href="#dictionary_type">字典类型</a></li>
<li><a href="#optional_type">可选类型</a></li>
<li><a href="#implicitly_unwrapped_optional_type">隐式解析可选类型</a></li>
<li><a href="#protocol_composition_type">协议合成类型</a></li>
<li><a href="#metatype_type">元类型</a></li>
<li><a href="#type_inheritance_clause">类型继承子句</a></li>
<li><a href="#type_inference">类型推断</a></li>
</ul>
<p>Swift 语言存在两种类型：命名型类型和复合型类型。命名型类型是指定义时可以给定名字的类型。命名型类型包括类、结构体、枚举和协议。比如，一个用户定义的类 MyClass 的实例拥有类型 MyClass。除了用户定义的命名型类型，Swift 标准库也定义了很多常用的命名型类型，包括那些表示数组、字典和可选值的类型。</p>
<p>那些通常被其它语言认为是基本或原始的数据型类型，比如表示数字、字符和字符串的类型，实际上就是命名型类型，这些类型在 Swift 标准库中是使用结构体来定义和实现的。因为它们是命名型类型，因此你可以按照 <a href="../chapter2/21_Extensions.html">扩展</a> 和 <a href="05_Declarations.html#extension_declaration">扩展声明</a> 中讨论的那样，声明一个扩展来增加它们的行为以满足你程序的需求。</p>
<p>复合型类型是没有名字的类型，它由 Swift 本身定义。Swift 存在两种复合型类型：函数类型和元组类型。一个复合型类型可以包含命名型类型和其它复合型类型。例如，元组类型 <code>(Int, (Int, Int))</code> 包含两个元素：第一个是命名型类型 <code>Int</code>，第二个是另一个复合型类型 <code>(Int, Int)</code>。</p>
<p>本节讨论 Swift 语言本身定义的类型，并描述 Swift 中的类型推断行为。</p>
<blockquote>
<p>类型语法<br><a name="type"></a><br><em>类型</em> → <a href="#array-type"><em>数组类型</em></a> | <a href="#dictionary-type"><em>字典类型</em></a> | <a href="#function-type"><em>函数类型</em></a> | <a href="#type-identifier"><em>类型标识</em></a> | <a href="#tuple-type"><em>元组类型</em></a> | <a href="#optional-type"><em>可选类型</em></a> | <a href="#implicitly-unwrapped-optional-type"><em>隐式解析可选类型</em></a> | <a href="#protocol-composition-type"><em>协议合成类型</em></a> | <a href="#metatype-type"><em>元型类型</em></a>  </p>
</blockquote>
<p><a name="type_annotation"></a></p>
<h2 id="类型注解">类型注解</h2><p>类型注解显式地指定一个变量或表达式的值。类型注解始于冒号 <code>:</code> 终于类型，比如下面两个例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someTuple: (<span class="type">Double</span>, <span class="type">Double</span>) = (<span class="number">3.14159</span>, <span class="number">2.71828</span>)</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">(a: Int)</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>在第一个例子中，表达式 <code>someTuple</code> 的类型被指定为 <code>(Double, Double)</code>。在第二个例子中，函数 <code>someFunction</code> 的参数 <code>a</code> 的类型被指定为 <code>Int</code>。</p>
<p>类型注解可以在类型之前包含一个类型特性的可选列表。</p>
<blockquote>
<p>类型注解语法<br><a name="type-annotation"></a><br><em>类型注解</em> → <strong>:</strong> <a href="06_Attributes.html#attributes"><em>特性列表</em></a><sub>可选</sub> <a href="#type"><em>类型</em></a>  </p>
</blockquote>
<p><a name="type_identifier"></a></p>
<h2 id="类型标识符">类型标识符</h2><p>类型标识符引用命名型类型，还可引用命名型或复合型类型的别名。</p>
<p>大多数情况下，类型标识符引用的是与之同名的命名型类型。例如类型标识符 <code>Int</code> 引用命名型类型 <code>Int</code>，同样，类型标识符 <code>Dictionary&lt;String, Int&gt;</code> 引用命名型类型 <code>Dictionary&lt;String, Int&gt;</code>。</p>
<p>在两种情况下类型标识符不引用同名的类型。情况一，类型标识符引用的是命名型或复合型类型的类型别名。比如，在下面的例子中，类型标识符使用 <code>Point</code> 来引用元组 <code>(Int, Int)</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">Point</span> = (<span class="type">Int</span>, <span class="type">Int</span>)</span><br><span class="line"><span class="keyword">let</span> origin: <span class="type">Point</span> = (<span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>情况二，类型标识符使用点语法（<code>.</code>）来表示在其它模块或其它类型嵌套内声明的命名型类型。例如，下面例子中的类型标识符引用在 <code>ExampleModule</code> 模块中声明的命名型类型 <code>MyType</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someValue: <span class="type">ExampleModule</span>.<span class="type">MyType</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>类型标识符语法<br><a name="type-identifier"></a><br><em>类型标识符</em> → <a href="#type-name"><em>类型名称</em></a> <a href="08_Generic_Parameters_and_Arguments.html#generic_argument_clause"><em>泛型参数子句</em></a><sub>可选</sub> | <a href="#type-name"><em>类型名称</em></a> <a href="08_Generic_Parameters_and_Arguments.html#generic_argument_clause"><em>泛型参数子句</em></a><sub>可选</sub> <strong>.</strong> <a href="#type-identifier"><em>类型标识符</em></a><br><a name="type-name"></a><br><em>类型名称</em> → <a href="02_Lexical_Structure.html#identifier"><em>标识符</em></a>  </p>
</blockquote>
<p><a name="tuple_type"></a></p>
<h2 id="元组类型">元组类型</h2><p>元组类型是使用括号括起来的零个或多个类型，类型间用逗号隔开。</p>
<p>你可以使用元组类型作为一个函数的返回类型，这样就可以使函数返回多个值。你也可以命名元组类型中的元素，然后用这些名字来引用每个元素的值。元素的名字由一个标识符紧跟一个冒号 <code>(:)</code> 组成。<a href="../chapter2/06_Functions.html#functions_with_multiple_return_values">函数和多返回值</a> 章节里有一个展示上述特性的例子。</p>
<p><code>Void</code> 是空元组类型 <code>()</code> 的别名。如果括号内只有一个元素，那么该类型就是括号内元素的类型。比如，<code>(Int)</code> 的类型是 <code>Int</code> 而不是 <code>(Int)</code>。所以，只有当元组类型包含的元素个数在两个及以上时才可以命名元组元素。</p>
<blockquote>
<p>元组类型语法<br><a name="tuple-type"></a><br><em>元组类型</em> → <strong>(</strong> <a href="#tuple-type-body"><em>元组类型主体</em></a><sub>可选</sub> <strong>)</strong><br><a name="tuple-type-body"></a><br><em>元组类型主体</em> → <a href="#tuple-type-element-list"><em>元组类型元素列表</em></a> <strong>…</strong><sub>可选</sub><br><a name="tuple-type-element-list"></a><br><em>元组类型元素列表</em> → <a href="#tuple-type-element"><em>元组类型元素</em></a> | <a href="#tuple-type-element"><em>元组类型元素</em></a> <strong>,</strong> <a href="#tuple-type-element-list"><em>元组类型元素列表</em></a><br><a name="tuple-type-element"></a><br><em>元组类型元素</em> → <a href="06_Attributes.html#attributes"><em>特性列表</em></a><sub>可选</sub> <strong>inout</strong><sub>可选</sub> <a href="#type"><em>类型</em></a> | <strong>inout</strong><sub>可选</sub> <a href="#element-name"><em>元素名</em></a> <a href="#type-annotation"><em>类型注解</em></a><br><a name="element-name"></a><br><em>元素名</em> → <a href="02_Lexical_Structure.html#identifier"><em>标识符</em></a>  </p>
</blockquote>
<p><a name="function_type"></a></p>
<h2 id="函数类型">函数类型</h2><p>函数类型表示一个函数、方法或闭包的类型，它由参数类型和返回值类型组成，中间用箭头（<code>-&gt;</code>）隔开：</p>
<blockquote>
<p><code>参数类型</code> -&gt; <code>返回值类型</code></p>
</blockquote>
<p>由于参数类型和返回值类型可以是元组类型，所以函数类型支持多参数与多返回值的函数与方法。</p>
<p>你可以对函数参数使用 <code>autoclosure</code> 特性。这会自动将参数表达式转化为闭包，表达式的结果即闭包返回值。这从语法结构上提供了一种便捷：延迟对表达式的求值，直到其值在函数体中被使用。以自动闭包做为参数的函数类型的例子详见 <a href="../chapter2/07_Closures.html#autoclosures">自动闭包</a> 。</p>
<p>函数类型可以拥有一个可变长参数作为参数类型中的最后一个参数。从语法角度上讲，可变长参数由一个基础类型名字紧随三个点（<code>...</code>）组成，如 <code>Int...</code>。可变长参数被认为是一个包含了基础类型元素的数组。即 <code>Int...</code> 就是 <code>[Int]</code>。关于使用可变长参数的例子，请参阅 <a href="../chapter2/06_Functions.html#variadic_parameters">可变参数</a>。</p>
<p>为了指定一个 <code>in-out</code> 参数，可以在参数类型前加 <code>inout</code> 前缀。但是你不可以对可变长参数或返回值类型使用 <code>inout</code>。关于这种参数的详细讲解请参阅 <a href="../chapter2/06_Functions.html#in_out_parameters">输入输出参数</a>。</p>
<p>柯里化函数的函数类型从右向左进行组合。例如，函数类型 <code>Int -&gt; Int -&gt; Int</code> 可以理解为 <code>Int -&gt; (Int -&gt; Int)</code>，也就是说，该函数类型的参数为 <code>Int</code> 类型，其返回类型是一个参数类型为 <code>Int</code>，返回类型为 <code>Int</code> 的函数类型。关于柯里化函数的讨论见章节 <a href="05_Declarations.html#curried_functions">柯里化函数</a>。</p>
<p>函数类型若要抛出错误就必须使用 <code>throws</code> 关键字来标记，若要重抛错误则必须使用 <code>rethrows</code> 关键字来标记。<code>throws</code> 关键字是函数类型的一部分，非抛出函数是抛出函数函数的一个子类型。因此，在使用抛出函数的地方也可以使用不抛出函数。对于柯里化函数，<code>throws</code> 关键字只应用于最里层的函数。抛出和重抛函数的相关描述见章节 <a href="05_Declarations.html#throwing_functions_and_methods">抛出函数与方法</a> 和 <a href="05_Declarations.html#rethrowing_functions_and_methods">重抛函数与方法</a>。</p>
<blockquote>
<p>函数类型语法<br><a name="function-type"></a><br><em>函数类型</em> → <a href="#type"><em>类型</em></a> <strong>throws</strong><sub>可选</sub> <strong>-&gt;</strong> <a href="#type"><em>类型</em></a><br><em>函数类型</em> → <a href="#type"><em>类型</em></a> <strong>rethrows</strong><sub>可选</sub> <strong>-&gt;</strong> <a href="#type"><em>类型</em></a>  </p>
</blockquote>
<p><a name="array_type"></a></p>
<h2 id="数组类型">数组类型</h2><p>Swift 语言为标准库中定义的 <code>Array&lt;Element&gt;</code> 类型提供了如下语法糖：</p>
<blockquote>
<p>[<code>类型</code>]</p>
</blockquote>
<p>换句话说，下面两个声明是等价的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someArray: <span class="type">Array</span>&lt;<span class="type">String</span>&gt; = [<span class="string">"Alex"</span>, <span class="string">"Brian"</span>, <span class="string">"Dave"</span>]</span><br><span class="line"><span class="keyword">let</span> someArray: [<span class="type">String</span>] = [<span class="string">"Alex"</span>, <span class="string">"Brian"</span>, <span class="string">"Dave"</span>]</span><br></pre></td></tr></table></figure>
<p>上面两种情况下，常量 <code>someArray</code> 都被声明为字符串数组。数组的元素也可以通过下标访问：<code>someArray[0]</code> 是指第 0 个元素 <code>&quot;Alex&quot;</code>。</p>
<p>你也可以嵌套多对方括号来创建多维数组，最里面的方括号中指明数组元素的基本类型。比如，下面例子中使用三对方括号创建三维整数数组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array3D: [[[<span class="type">Int</span>]]] = [[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], [[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]]]</span><br></pre></td></tr></table></figure>
<p>访问一个多维数组的元素时，最左边的下标指向最外层数组的相应位置元素。接下来往右的下标指向第一层嵌入的相应位置元素，依次类推。这就意味着，在上面的例子中，<code>array3D[0]</code> 是 <code>[[1, 2], [3, 4]]</code>，<code>array3D[0][1]</code> 是 <code>[3, 4]</code>，<code>array3D[0][1][1]</code> 则是 <code>4</code>。</p>
<p>关于 Swift 标准库中 <code>Array</code> 类型的详细讨论，请参阅 <a href="../chapter2/04_Collection_Types.html#arrays">数组</a>。</p>
<blockquote>
<p>数组类型语法<br><a name="array-type"></a><br><em>数组类型</em> → <strong>[</strong> <a href="#type"><em>类型</em></a> <strong>]</strong></p>
</blockquote>
<p><a name="dictionary_type"></a></p>
<h2 id="字典类型">字典类型</h2><p>Swift 语言为标准库中定义的 <code>Dictionary&lt;Key, Value&gt;</code> 类型提供了如下语法糖：</p>
<blockquote>
<p>[<code>键类型</code> : <code>值类型</code>]</p>
</blockquote>
<p>换句话说，下面两个声明是等价的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someDictionary: [<span class="type">String</span>: <span class="type">Int</span>] = [<span class="string">"Alex"</span>: <span class="number">31</span>, <span class="string">"Paul"</span>: <span class="number">39</span>]</span><br><span class="line"><span class="keyword">let</span> someDictionary: <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">Int</span>&gt; = [<span class="string">"Alex"</span>: <span class="number">31</span>, <span class="string">"Paul"</span>: <span class="number">39</span>]</span><br></pre></td></tr></table></figure>
<p>上面两种情况，常量 <code>someDictionary</code> 被声明为一个字典，其中键为 <code>String</code> 类型，值为 <code>Int</code> 类型。</p>
<p>字典中的值可以通过下标来访问，这个下标在方括号中指明了具体的键：<code>someDictionary[&quot;Alex&quot;]</code> 返回键 <code>Alex</code> 对应的值。如果键在字典中不存在的话，则这个下标返回 <code>nil</code>。</p>
<p>字典中键的类型必须符合 Swift 标准库中的 <code>Hashable</code> 协议。</p>
<p>关于 Swift 标准库中 <code>Dictionary</code> 类型的详细讨论，请参阅 <a href="../chapter2/04_Collection_Types.html#dictionaries">字典</a>。</p>
<blockquote>
<p>字典类型语法<br><a name="dictionary-type"></a><br><em>字典类型</em> → <strong>[</strong> <a href="#type"><em>类型</em></a> <strong>:</strong> <a href="#type"><em>类型</em></a> <strong>]</strong> </p>
</blockquote>
<p><a name="optional_type"></a></p>
<h2 id="可选类型">可选类型</h2><p>Swift 定义后缀 <code>?</code> 来作为标准库中的定义的命名型类型 <code>Optional&lt;Wrapped&gt;</code> 的语法糖。换句话说，下面两个声明是等价的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> optionalInteger: <span class="type">Int</span>?</span><br><span class="line"><span class="keyword">var</span> optionalInteger: <span class="type">Optional</span>&lt;<span class="type">Int</span>&gt;</span><br></pre></td></tr></table></figure>
<p>在上述两种情况下，变量 <code>optionalInteger</code> 都被声明为可选整型类型。注意在类型和 <code>?</code> 之间没有空格。</p>
<p>类型 <code>Optional&lt;Wrapped&gt;</code> 是一个枚举，有两个成员，<code>None</code> 和 <code>Some(Wrapped)</code>，用来表示可能有也可能没有的值。任意类型都可以被显式地声明（或隐式地转换）为可选类型。如果你在声明或定义可选变量或属性的时候没有提供初始值，它的值则会自动赋为默认值 <code>nil</code>。</p>
<p>如果一个可选类型的实例包含一个值，那么你就可以使用后缀运算符 <code>!</code> 来获取该值，正如下面描述的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">optionalInteger = <span class="number">42</span></span><br><span class="line">optionalInteger! <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>!</code> 运算符解包值为 <code>nil</code> 的可选值会导致运行错误。</p>
<p>你也可以使用可选链式调用和可选绑定来选择性地在可选表达式上执行操作。如果值为 <code>nil</code>，不会执行任何操作，因此也就没有运行错误产生。</p>
<p>更多细节以及更多如何使用可选类型的例子，请参阅 <a href="../chapter2/01_The_Basics.html#optionals">可选类型</a>。</p>
<blockquote>
<p>可选类型语法<br><a name="optional-type"></a><br><em>可选类型</em> → <a href="#type"><em>类型</em></a> <strong>?</strong>  </p>
</blockquote>
<p><a name="implicitly_unwrapped_optional_type"></a></p>
<h2 id="隐式解析可选类型">隐式解析可选类型</h2><p>Swift 语言定义后缀 <code>!</code> 作为标准库中命名类型 <code>ImplicitlyUnwrappedOptional&lt;Wrapped&gt;</code> 的语法糖。换句话说，下面两个声明等价：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> implicitlyUnwrappedString: <span class="type">String</span>!</span><br><span class="line"><span class="keyword">var</span> implicitlyUnwrappedString: <span class="type">ImplicitlyUnwrappedOptional</span>&lt;<span class="type">String</span>&gt;</span><br></pre></td></tr></table></figure>
<p>上述两种情况下，变量 <code>implicitlyUnwrappedString</code> 被声明为一个隐式解析可选类型的字符串。注意类型与 <code>!</code> 之间没有空格。</p>
<p>你可以在使用可选类型的地方使用隐式解析可选类型。比如，你可以将隐式解析可选类型的值赋给变量、常量和可选属性，反之亦然。</p>
<p>正如可选类型一样，你在声明隐式解析可选类型的变量或属性的时候也不用指定初始值，因为它有默认值 <code>nil</code>。</p>
<p>由于隐式解析可选类型的值会在使用时自动解析，所以没必要使用操作符 <code>!</code> 来解析它。也就是说，如果你使用值为 <code>nil</code> 的隐式解析可选类型，就会导致运行错误。</p>
<p>可以使用可选链式调用来在隐式解析可选表达式上选择性地执行操作。如果值为 <code>nil</code>，就不会执行任何操作，因此也不会产生运行错误。</p>
<p>关于隐式解析可选类型的更多细节，请参阅 <a href="../chapter2/01_The_Basics.html#implicityly_unwrapped_optionals">隐式解析可选类型</a>。</p>
<blockquote>
<p>隐式解析可选类型语法<br><a name="implicitly-unwrapped-optional-type"></a><br><em>隐式解析可选类型</em> → <a href="#type"><em>类型</em></a> <strong>!</strong>  </p>
</blockquote>
<p><a name="protocol_composition_type"></a></p>
<h2 id="协议合成类型">协议合成类型</h2><p>协议合成类型是一种符合协议列表中每个指定协议的类型。协议合成类型可能会用在类型注解和泛型参数中。</p>
<p>协议合成类型的形式如下：</p>
<blockquote>
<p>protocol&lt;<code>Protocol 1</code>, <code>Procotol 2</code>&gt;</p>
</blockquote>
<p>协议合成类型允许你指定一个值，其类型符合多个协议的要求且不需要定义一个新的命名型协议来继承它想要符合的各个协议。比如，协议合成类型 <code>protocol&lt;Protocol A, Protocol B, Protocol C&gt;</code> 等效于一个从 <code>Protocol A</code>，<code>Protocol B</code>， <code>Protocol C</code> 继承而来的新协议 <code>Protocol D</code>，很显然这样做有效率的多，甚至不需引入一个新名字。</p>
<p>协议合成列表中的每项必须是协议名或协议合成类型的类型别名。如果列表为空，它就会指定一个空协议合成列表，每个类型都符合它。</p>
<blockquote>
<p>协议合成类型语法<br><a name="protocol-composition-type"></a><br><em>协议合成类型</em> → <strong>protocol</strong> <strong>&lt;</strong> <a href="#protocol-identifier-list"><em>协议标识符列表</em></a><sub>可选</sub> <strong>&gt;</strong><br><a name="protocol-identifier-list"></a><br><em>协议标识符列表</em> → <a href="#protocol-identifier"><em>协议标识符</em></a> | <a href="#protocol-identifier"><em>协议标识符</em></a> <strong>,</strong> <a href="#protocol-identifier-list"><em>协议标识符列表</em></a><br><a name="protocol-identifier"></a><br><em>协议标识符</em> → <a href="#type-identifier"><em>类型标识符</em></a>  </p>
</blockquote>
<p><a name="metatype_type"></a></p>
<h2 id="元类型">元类型</h2><p>元类型是指类型的类型，包括类类型、结构体类型、枚举类型和协议类型。</p>
<p>类、结构体或枚举类型的元类型是相应的类型名紧跟 <code>.Type</code>。协议类型的元类型——并不是运行时符合该协议的具体类型——而是该协议名字紧跟 <code>.Protocol</code>。比如，类 <code>SomeClass</code> 的元类型就是 <code>SomeClass.Type</code>，协议 <code>SomeProtocol</code> 的元类型就是 <code>SomeProtocal.Protocol</code>。</p>
<p>你可以使用后缀 <code>self</code> 表达式来获取类型。比如，<code>SomeClass.self</code> 返回 <code>SomeClass</code> 本身，而不是 <code>SomeClass</code> 的一个实例。同样，<code>SomeProtocol.self</code> 返回 <code>SomeProtocol</code> 本身，而不是运行时符合 <code>SomeProtocol</code> 的某个类型的实例。还可以对类型的实例使用 <code>dynamicType</code> 表达式来获取该实例在运行阶段的类型，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeBaseClass</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">printClassName</span>() </span>&#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"SomeBaseClass"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeSubClass</span>: <span class="title">SomeBaseClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">printClassName</span>() </span>&#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"SomeSubClass"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> someInstance: <span class="type">SomeBaseClass</span> = <span class="type">SomeSubClass</span>()</span><br><span class="line"><span class="comment">// someInstance 在编译期是 SomeBaseClass 类型，</span></span><br><span class="line"><span class="comment">// 但是在运行期则是 SomeSubClass 类型</span></span><br><span class="line">someInstance.<span class="keyword">dynamicType</span>.printClassName()</span><br><span class="line"><span class="comment">// 打印 “SomeSubClass”</span></span><br></pre></td></tr></table></figure>
<p>可以使用恒等运算符（<code>===</code> 和 <code>!==</code>）来测试一个实例的运行时类型和它的编译时类型是否一致。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> someInstance.<span class="keyword">dynamicType</span> === <span class="type">SomeBaseClass</span>.<span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The dynamic type of someInstance is SomeBaseCass"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The dynamic type of someInstance isn't SomeBaseClass"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “The dynamic type of someInstance isn't SomeBaseClass”</span></span><br></pre></td></tr></table></figure>
<p>可以使用初始化表达式从某个类型的元类型构造出一个该类型的实例。对于类实例，被调用的构造器必须使用 <code>required</code> 关键字标记，或者整个类使用 <code>final</code> 关键字标记。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnotherSubClass</span>: <span class="title">SomeBaseClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> string: <span class="type">String</span></span><br><span class="line">    required <span class="keyword">init</span>(string: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.string = string</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">printClassName</span>() </span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"AnotherSubClass"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> metatype: <span class="type">AnotherSubClass</span>.<span class="type">Type</span> = <span class="type">AnotherSubClass</span>.<span class="keyword">self</span></span><br><span class="line"><span class="keyword">let</span> anotherInstance = metatype.<span class="keyword">init</span>(string: <span class="string">"some string"</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>元类型语法<br><a name="metatype-type"></a><br><em>元类型</em> → <a href="#type"><em>类型</em></a> <strong>.</strong> <strong>Type</strong> | <a href="#type"><em>类型</em></a> <strong>.</strong> <strong>Protocol</strong> </p>
</blockquote>
<p><a name="type_inheritance_clause"></a></p>
<h2 id="类型继承子句">类型继承子句</h2><p>类型继承子句被用来指定一个命名型类型继承自哪个类、采纳哪些协议。类型继承子句也用来指定一个类类型专属协议。类型继承子句开始于冒号 <code>:</code>，其后是类的超类或者一系列类型标识符。</p>
<p>类可以继承单个超类，采纳任意数量的协议。当定义一个类时，超类的名字必须出现在类型标识符列表首位，然后跟上该类需要采纳的任意数量的协议。如果一个类不是从其它类继承而来，那么列表可以以协议开头。关于类继承更多的讨论和例子，请参阅 <a href="../chapter2/13_Inheritance.html">继承</a>。</p>
<p>其它命名型类型可能只继承或采纳一系列协议。协议类型可以继承自任意数量的其他协议。当一个协议类型继承自其它协议时，其它协议中定义的要求会被整合在一起，然后从当前协议继承的任意类型必须符合所有这些条件。正如在 <a href="05_Declarations.html#protocol_declaration">协议声明</a> 中所讨论的那样，可以把 <code>class</code> 关键字放到协议类型的类型继承子句的首位，这样就可以声明一个类类型专属协议。</p>
<p>枚举定义中的类型继承子句可以是一系列协议，或是枚举的原始值类型的命名型类型。在枚举定义中使用类型继承子句来指定原始值类型的例子，请参阅 <a href="../chapter2/08_Enumerations.html#raw_values">原始值</a>。</p>
<blockquote>
<p>类型继承子句语法<br><a name="type_inheritance_clause"></a><br><em>类型继承子句</em> → <strong>:</strong> <a href="#class-requirement"><em>类要求</em></a> <strong>,</strong> <a href="#type-inheritance-list"><em>类型继承列表</em></a><br><em>类型继承子句</em> → <strong>:</strong> <a href="#class-requirement"><em>类要求</em></a><br><em>类型继承子句</em> → <strong>:</strong> <a href="#type-inheritance-list"><em>类型继承列表</em></a><br><a name="type-inheritance-list"></a><br><em>类型继承列表</em> → <a href="#type-identifier"><em>类型标识符</em></a> | <a href="#type-identifier"><em>类型标识符</em></a> <strong>,</strong> <a href="#type-inheritance-list"><em>类型继承列表</em></a><br><a name="class-requirement"></a><br><em>类要求</em> → <strong>class</strong></p>
</blockquote>
<p><a name="type_inference"></a></p>
<h2 id="类型推断">类型推断</h2><p>Swift 广泛使用类型推断，从而允许你省略代码中很多变量和表达式的类型或部分类型。比如，对于 <code>var x: Int = 0</code>，你可以完全省略类型而简写成 <code>var x = 0</code>，编译器会正确推断出 <code>x</code> 的类型 <code>Int</code>。类似的，当完整的类型可以从上下文推断出来时，你也可以省略类型的一部分。比如，如果你写了 <code>let dict: Dictionary = [&quot;A&quot; : 1]</code>，编译器能推断出 <code>dict</code> 的类型是 <code>Dictionary&lt;String, Int&gt;</code>。</p>
<p>在上面的两个例子中，类型信息从表达式树的叶子节点传向根节点。也就是说，<code>var x: Int = 0</code> 中 <code>x</code> 的类型首先根据 <code>0</code> 的类型进行推断，然后将该类型信息传递到根节点（变量 <code>x</code>）。</p>
<p>在 Swift 中，类型信息也可以反方向流动——从根节点传向叶子节点。在下面的例子中，常量 <code>eFloat</code> 上的显式类型注解（<code>: Float</code>）将导致数字字面量 <code>2.71828</code> 的类型是 <code>Float</code> 而非 <code>Double</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> e = <span class="number">2.71828</span> <span class="comment">// e 的类型会被推断为 Double</span></span><br><span class="line"><span class="keyword">let</span> eFloat: <span class="type">Float</span> = <span class="number">2.71828</span> <span class="comment">// eFloat 的类型为 Float</span></span><br></pre></td></tr></table></figure>
<p>Swift 中的类型推断在单独的表达式或语句上进行。这意味着所有用于类型推断的信息必须可以从表达式或其某个子表达式的类型检查中获取到。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter3/04_Expressions/" itemprop="url">
                第三章-04表达式（Expressions）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T11:00:17+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter3/04_Expressions/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter3/04_Expressions/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="表达式（Expressions）">表达式（Expressions）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/sg552" target="_blank" rel="external">sg552</a><br>校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>, <a href="https://github.com/stanzhai" target="_blank" rel="external">stanzhai</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/EudeMorgen" target="_blank" rel="external">EudeMorgen</a></p>
<p>2.1<br>翻译：<a href="https://github.com/mmoaay" target="_blank" rel="external">mmoaay</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#prefix_expressions">前缀表达式</a><ul>
<li><a href="#try_operator">try 运算符</a></li>
</ul>
</li>
<li><a href="#binary_expressions">二元表达式</a><ul>
<li><a href="#assignment_operator">赋值表达式</a></li>
<li><a href="#ternary_conditional_operator">三元条件运算符</a></li>
<li><a href="#type-casting_operators">类型转换运算符</a></li>
</ul>
</li>
<li><a href="#primary_expressions">基本表达式</a><ul>
<li><a href="#literal_expression">字面量表达式</a></li>
<li><a href="#self_expression">self 表达式</a></li>
<li><a href="#superclass_expression">超类表达式</a></li>
<li><a href="#closure_expression">闭包表达式</a></li>
<li><a href="#implicit_member_expression">隐式成员表达式</a></li>
<li><a href="#parenthesized_expression">圆括号表达式</a></li>
<li><a href="#wildcard_expression">通配符表达式</a></li>
</ul>
</li>
<li><a href="#postfix_expressions">后缀表达式</a><ul>
<li><a href="#function_call_expression">函数调用表达式</a> </li>
<li><a href="#initializer_expression">构造器表达式</a></li>
<li><a href="#explicit_member_expression">显式成员表达式</a></li>
<li><a href="#postfix_self_expression">后缀 self 表达式</a></li>
<li><a href="#dynamic_type_expression">dynamicType 表达式</a></li>
<li><a href="#subscript_expression">下标表达式</a></li>
<li><a href="#forced-Value_expression">强制取值表达式</a></li>
<li><a href="#optional-chaining_expression">可选链表达式</a></li>
</ul>
</li>
</ul>
<p>Swift 中存在四种表达式：前缀表达式，二元表达式，基本表达式和后缀表达式。表达式可以返回一个值，还可以执行某些代码。</p>
<p>前缀表达式和二元表达式就是对某些表达式使用各种运算符。基本表达式是最短小的表达式，它提供了获取值的一种途径。后缀表达式则允许你建立复杂的表达式，例如函数调用和成员访问。每种表达式都在下面有详细论述。</p>
<blockquote>
<p>表达式语法<br><a name="expression"></a><br><em>表达式</em> → <a href="#try-operator"><em>try运算符</em></a><sub>可选</sub> <a href="#prefix-expression"><em>前缀表达式</em></a> <a href="#binary-expressions"><em>二元表达式列表</em></a><sub>可选</sub><br><a name="expression-list"></a><br><em>表达式列表</em> → <a href="#expression"><em>表达式</em></a> | <a href="#expression"><em>表达式</em></a> <strong>,</strong> <a href="#expression-list"><em>表达式列表</em></a>  </p>
</blockquote>
<p><a name="prefix_expressions"></a></p>
<h2 id="前缀表达式">前缀表达式</h2><p>前缀表达式由可选的前缀运算符和表达式组成。前缀运算符只接收一个参数。</p>
<p>关于这些运算符的更多信息，请参阅 <a href="../chapter2/02_Basic_Operators.html">基本运算符</a> 和 <a href="../chapter2/25_Advanced_Operators.html">高级运算符</a>。</p>
<p>关于 Swift 标准库提供的运算符的更多信息，请参阅 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Reference/Swift_StandardLibrary_Operators/index.html#//apple_ref/doc/uid/TP40016054" target="_blank" rel="external"><em>Swift Standard Library Operators Reference</em></a>。</p>
<p>除了标准库运算符，你也可以对某个变量使用 <code>&amp;</code> 运算符，从而将其传递给函数的输入输出参数。 更多信息，请参阅 <a href="../chapter2/06_Functions.html#in_out_parameters">输入输出参数</a>。</p>
<blockquote>
<p>前缀表达式语法<br><a name="prefix-expression"></a><br><em>前缀表达式</em> → <a href="02_Lexical_Structure.html#prefix-operator"><em>前缀运算符</em></a><sub>可选</sub> <a href="#postfix-expression"><em>后缀表达式</em></a><br><em>前缀表达式</em> → <a href="#in-out-expression"><em>输入输出表达式</em></a><br><a name="in-out-expression"></a><br><em>输入输出表达式</em> → <strong>&amp;</strong> <a href="02_Lexical_Structure.html#identifier"><em>标识符</em></a>  </p>
</blockquote>
<p><a name="try_operator"></a></p>
<h3 id="try_运算符">try 运算符</h3><p>try 表达式由 <code>try</code> 运算符加上紧随其后的可抛出错误的表达式组成，形式如下：</p>
<blockquote>
<p>try <code>可抛出错误的表达式</code></p>
</blockquote>
<p>可选的 try 表达式由 <code>try?</code> 运算符加上紧随其后的可抛出错误的表达式组成，形式如下：</p>
<blockquote>
<p>try? <code>可抛出错误的表达式</code></p>
</blockquote>
<p>如果可抛出错误的表达式没有抛出错误，整个表达式返回的可选值将包含可抛出错误的表达式的返回值，否则，该可选值为 <code>nil</code>。</p>
<p>强制的 try 表达式由 <code>try!</code> 运算符加上紧随其后的可抛出错误的表达式组成，形式如下：</p>
<blockquote>
<p>try! <code>可抛出错误的表达式</code></p>
</blockquote>
<p>如果可抛出错误的表达式抛出了错误，将会引发运行时错误。</p>
<p>在二进制运算符左侧的表达式被标记上 <code>try</code>、<code>try?</code> 或者 <code>try!</code> 时，这个运算符对整个二进制表达式都产生作用。也就是说，你可以使用括号来明确运算符的作用范围。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum = try someThrowingFunction() + anotherThrowingFunction()   <span class="comment">// try 对两个方法调用都产生作用</span></span><br><span class="line">sum = try (someThrowingFunction() + anotherThrowingFunction()) <span class="comment">// try 对两个方法调用都产生作用</span></span><br><span class="line">sum = (try someThrowingFunction()) + anotherThrowingFunction() <span class="comment">// 错误：try 只对第一个方法调用产生作用</span></span><br></pre></td></tr></table></figure>
<p><code>try</code> 表达式不能出现在二进制运算符的的右侧，除非二进制运算符是赋值运算符或者 <code>try</code> 表达式是被圆括号括起来的。</p>
<p>关于 <code>try</code>、<code>try?</code> 和 <code>try!</code> 的更多信息，以及如何使用的例子，请参阅 <a href="../chapter2/18_Error_Handling.html">错误处理</a>。</p>
<blockquote>
<p>try 表达式语法<br><a name="try-operator"></a><br><em>try 运算符</em> → <strong>try</strong> | <strong>try?</strong> | <strong>try!</strong></p>
</blockquote>
<p><a name="binary_expressions"></a></p>
<h2 id="二元表达式">二元表达式</h2><p>二元表达式形式如下：</p>
<blockquote>
<p><code>左侧参数</code> <code>二元运算符</code> <code>右侧参数</code></p>
</blockquote>
<p>关于这些运算符的更多信息，请参阅 <a href="../chapter2/02_Basic_Operators.html">基本运算符</a> 和 <a href="../chapter2/25_Advanced_Operators.html">高级运算符</a>。</p>
<p>关于 Swift 标准库提供的运算符的更多信息，请参阅 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Reference/Swift_StandardLibrary_Operators/index.html#//apple_ref/doc/uid/TP40016054" target="_blank" rel="external"><em>Swift Standard Library Operators Reference</em></a>。</p>
<blockquote>
<p>注意<br>在解析时，一个二元表达式将作为一个简单列表表示，然后根据运算符的优先级，再进一步进行组合。例如，<code>2 + 3 * 5</code> 首先被看作具有五个元素的列表，即 <code>2</code>、<code>+</code>、<code>3</code>、<code>*</code>、<code>5</code>，随后根据运算符优先级组合为 <code>(2 + (3 * 5))</code>。</p>
</blockquote>
<p><a name="binary-expression"></a></p>
<blockquote>
<p>二元表达式语法<br><em>二元表达式</em> → <a href="02_Lexical_Structure.html#binary-operator"><em>二元运算符</em></a> <a href="#prefix-expression"><em>前缀表达式</em></a><br><em>二元表达式</em> → <a href="#assignment-operator"><em>赋值运算符</em></a> <a href="#try-operator"><em>try运算符</em></a><sub>可选</sub> <a href="#prefix-expression"><em>前缀表达式</em></a><br><em>二元表达式</em> → <a href="#conditional-operator"><em>条件运算符</em></a> <a href="#try-operator"><em>try运算符</em></a><sub>可选</sub> <a href="#prefix-expression"><em>前缀表达式</em></a><br><em>二元表达式</em> → <a href="#type-casting-operator"><em>类型转换运算符</em></a><br><a name="binary-expressions"></a><br><em>二元表达式列表</em> → <a href="#binary-expression"><em>二元表达式</em></a> <a href="#binary-expressions"><em>二元表达式列表</em></a><sub>可选</sub></p>
</blockquote>
<p><a name="assignment_operator"></a></p>
<h3 id="赋值表达式">赋值表达式</h3><p>赋值表达式会为某个给定的表达式赋值，形式如下；</p>
<blockquote>
<p><code>表达式</code> = <code>值</code></p>
</blockquote>
<p>右边的值会被赋值给左边的表达式。如果左边表达式是一个元组，那么右边必须是一个具有同样元素个数的元组。嵌套元组也是允许的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(a, <span class="number">_</span>, (b, <span class="built_in">c</span>)) = (<span class="string">"test"</span>, <span class="number">9.45</span>, (<span class="number">12</span>, <span class="number">3</span>))</span><br><span class="line"><span class="comment">// a 为 "test"，b 为 12，c 为 3，9.45 会被忽略</span></span><br></pre></td></tr></table></figure>
<p>赋值运算符不返回任何值。</p>
<blockquote>
<p>赋值运算符语法<br><a name="assignment-operator"></a><br><em>赋值运算符</em> → <strong>=</strong>  </p>
</blockquote>
<p><a name="ternary_conditional_operator"></a></p>
<h3 id="三元条件运算符">三元条件运算符</h3><p>三元条件运算符会根据条件来对两个给定表达式中的一个进行求值，形式如下：</p>
<blockquote>
<p><code>条件</code> ? <code>表达式（条件为真则使用）</code> : <code>表达式（条件为假则使用）</code></p>
</blockquote>
<p>如果条件为真，那么对第一个表达式进行求值并返回结果。否则，对第二个表达式进行求值并返回结果。未使用的表达式不会进行求值。</p>
<p>关于使用三元条件运算符的例子，请参阅 <a href="../chapter2/02_Basic_Operators.html#ternary_conditional_operator">三元条件运算符</a>。</p>
<blockquote>
<p>三元条件运算符语法<br><a name="conditional-operator"></a><br><em>三元条件运算符</em> → <strong>?</strong> <a href="#try-operator">try运算符</a><sub>可选</sub> <a href="#expression"><em>表达式</em></a> <strong>:</strong>  </p>
</blockquote>
<p><a name="type-casting_operators"></a></p>
<h3 id="类型转换运算符">类型转换运算符</h3><p>有 4 种类型转换运算符：<code>is</code>、<code>as</code>、<code>?</code>和<code>!</code>。它们有如下的形式：</p>
<blockquote>
<p><code>表达式</code> is <code>类型</code><br><code>表达式</code> as <code>类型</code><br><code>表达式</code> is? <code>类型</code><br><code>表达式</code> as! <code>类型</code>  </p>
</blockquote>
<p><code>is</code> 运算符在运行时检查表达式能否向下转化为指定的类型，如果可以则返回 <code>ture</code>，否则返回 <code>false</code>。</p>
<p><code>as</code> 运算符在编译时执行向上转换和桥接。向上转换可将表达式转换成超类的实例而无需使用任何中间变量。以下表达式是等价的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">f</span><span class="params">(any: Any)</span></span> &#123; <span class="built_in">print</span>(<span class="string">"Function for Any"</span>) &#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">f</span><span class="params">(int: Int)</span></span> &#123; <span class="built_in">print</span>(<span class="string">"Function for Int"</span>) &#125;</span><br><span class="line"><span class="keyword">let</span> x = <span class="number">10</span></span><br><span class="line">f(x)</span><br><span class="line"><span class="comment">// 打印 “Function for Int”</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> y: <span class="type">Any</span> = x</span><br><span class="line">f(y)</span><br><span class="line"><span class="comment">// 打印 “Function for Any”</span></span><br><span class="line"> </span><br><span class="line">f(x <span class="keyword">as</span> <span class="type">Any</span>)</span><br><span class="line"><span class="comment">// 打印 “Function for Any”</span></span><br></pre></td></tr></table></figure>
<p>桥接可将 Swift 标准库中的类型（例如 <code>String</code>）作为一个与之相关的 Foundation 类型（例如 <code>NSString</code>）来使用，而不需要新建一个实例。关于桥接的更多信息，请参阅 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216" target="_blank" rel="external"><em>Using Swift with Cocoa and Objective-C</em></a> 中的 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6" target="_blank" rel="external">Working with Cocoa Data Types</a>。</p>
<p><code>as?</code> 运算符有条件地执行类型转换，返回目标类型的可选值。在运行时，如果转换成功，返回的可选值将包含转换后的值，否则返回 <code>nil</code>。如果在编译时就能确定转换一定会成功或是失败，则会编译出错。</p>
<p><code>as!</code> 运算符执行强制类型转换，返回目标类型的非可选值。如果转换失败，则会导致运行时错误。表达式 <code>x as T</code> 效果等同于 <code>(x as? T)!</code>。</p>
<p>关于类型转换的更多内容和例子，请参阅 <a href="../chapter2/19_Type_Casting.html">类型转换</a>。</p>
<p><a name="type-casting-operator"></a></p>
<blockquote>
<p>类型转换运算符语法<br><em>类型转换运算符</em> → <strong>is</strong> <a href="03_Types.html#type"><em>类型</em></a><br><em>类型转换运算符</em> → <strong>as</strong> <a href="03_Types.html#type"><em>类型</em></a><br><em>类型转换运算符</em> → <strong>is</strong> <strong>?</strong> <a href="03_Types.html#type"><em>类型</em></a><br><em>类型转换运算符</em> → <strong>as</strong> <strong>!</strong> <a href="03_Types.html#type"><em>类型</em></a>   </p>
</blockquote>
<p><a name="primary_expressions"></a></p>
<h2 id="基本表达式">基本表达式</h2><p>基本表达式是最基本的表达式。 它们可以跟前缀表达式、二元表达式、后缀表达式以及其他基本表达式组合使用。</p>
<blockquote>
<p>基本表达式语法<br><a name="primary-expression"></a><br><em>基本表达式</em> → <a href="02_Lexical_Structure.md#identifier"><em>标识符</em></a> <a href="08_Generic_Parameters_and_Arguments.md#generic-argument-clause"><em>泛型实参子句</em></a><sub>可选</sub><br><em>基本表达式</em> → <a href="#literal-expression"><em>字面量表达式</em></a><br><em>基本表达式</em> → <a href="#self-expression"><em>self表达式</em></a><br><em>基本表达式</em> → <a href="#superclass-expression"><em>超类表达式</em></a><br><em>基本表达式</em> → <a href="#closure-expression"><em>闭包表达式</em></a><br><em>基本表达式</em> → <a href="#parenthesized-expression"><em>圆括号表达式</em></a><br><em>基本表达式</em> → <a href="#implicit-member-expression"><em>隐式成员表达式</em></a><br><em>基本表达式</em> → <a href="#wildcard-expression"><em>通配符表达式</em></a>  </p>
</blockquote>
<p><a name="literal_expression"></a></p>
<h3 id="字面量表达式">字面量表达式</h3><p>字面量表达式可由普通字面量（例如字符串或者数字），字典或者数组字面量，或者下面列表中的特殊字面量组成：</p>
<table>
<thead>
<tr>
<th style="text-align:left">字面量</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>__FILE__</code></td>
<td style="text-align:left"><code>String</code></td>
<td style="text-align:left">所在的文件名</td>
</tr>
<tr>
<td style="text-align:left"><code>__LINE__</code></td>
<td style="text-align:left"><code>Int</code></td>
<td style="text-align:left">所在的行数</td>
</tr>
<tr>
<td style="text-align:left"><code>__COLUMN__</code></td>
<td style="text-align:left"><code>Int</code></td>
<td style="text-align:left">所在的列数</td>
</tr>
<tr>
<td style="text-align:left"><code>__FUNCTION__</code></td>
<td style="text-align:left"><code>String</code></td>
<td style="text-align:left">所在的声明的名字</td>
</tr>
</tbody>
</table>
<p>对于 <code>__FUNCTION__</code>，在函数中会返回当前函数的名字，在方法中会返回当前方法的名字，在属性的存取器中会返回属性的名字，在特殊的成员如 <code>init</code> 或 <code>subscript</code> 中会返回这个关键字的名字，在某个文件中会返回当前模块的名字。</p>
<p><code>__FUNCTION__</code> 作为函数或者方法的默认参数值时，该字面量的值取决于函数或方法调用时所处的环境。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">logFunctionName</span><span class="params">(string: String = <span class="keyword">__FUNCTION__</span>)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(string)</span><br><span class="line">&#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">()</span></span> &#123;</span><br><span class="line">    logFunctionName() </span><br><span class="line">&#125;</span><br><span class="line">myFunction() <span class="comment">// 打印 “myFunction()”</span></span><br></pre></td></tr></table></figure>
<p>数组字面量是值的有序集合，形式如下：</p>
<blockquote>
<p>[<code>值 1</code>, <code>值 2</code>, <code>...</code>]</p>
</blockquote>
<p>数组中的最后一个表达式可以紧跟一个逗号。数组字面量的类型是 <code>[T]</code>，这个 <code>T</code> 就是数组中元素的类型。如果数组中包含多种类型，<code>T</code> 则是跟这些类型最接近的的公共父类型。空数组字面量由一组方括号定义，可用来创建特定类型的空数组。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emptyArray: [<span class="type">Double</span>] = []</span><br></pre></td></tr></table></figure>
<p>字典字面量是一个包含无序键值对的集合，形式如下：</p>
<blockquote>
<p>[<code>键 1</code> : <code>值 1</code>, <code>键 2</code> : <code>值 2</code>, <code>...</code>]</p>
</blockquote>
<p>字典中的最后一个表达式可以紧跟一个逗号。字典字面量的类型是 <code>[Key : Value]</code>，<code>Key</code> 表示键的类型，<code>Value</code> 表示值的类型。如果字典中包含多种类型，那么 <code>Key</code> 表示的类型则为所有键最接近的公共父类型，<code>Value</code> 也是同样如此。一个空的字典字面量由方括号中加一个冒号组成（<code>[:]</code>），从而与空数组字面量区分开，可以使用空字典字面量来创建特定类型的字典。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emptyDictionary: [<span class="type">String</span> : <span class="type">Double</span>] = [:]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>字面量表达式语法  </p>
</blockquote>
<p><a name="literal-expression"></a></p>
<blockquote>
<p><em>字面量表达式</em> → <a href="02_Lexical_Structure.md#literal"><em>字面量</em></a><br><em>字面量表达式</em> → <a href="#array-literal"><em>数组字面量</em></a> | <a href="#dictionary-literal"><em>字典字面量</em></a><br><em>字面量表达式</em> → <strong>__FILE__</strong> | <strong>__LINE__</strong> | <strong>__COLUMN__</strong> | <strong>__FUNCTION__</strong>  </p>
</blockquote>
<p><a name="array-literal"></a></p>
<blockquote>
<p><em>数组字面量</em> → <strong>[</strong> <a href="#array-literal-items"><em>数组字面量项列表</em></a><sub>可选</sub> <strong>]</strong><br><a name="array-literal-items"></a><br><em>数组字面量项列表</em> → <a href="#array-literal-item"><em>数组字面量项</em></a> <strong>,</strong><sub>可选</sub> | <a href="#array-literal-item"><em>数组字面量项</em></a> <strong>,</strong> <a href="#array-literal-items"><em>数组字面量项列表</em></a><br><a name="array-literal-item"></a><br><em>数组字面量项</em> → <a href="#expression"><em>表达式</em></a>  </p>
</blockquote>
<p><a name="dictionary-literal"></a></p>
<blockquote>
<p><em>字典字面量</em> → <strong>[</strong> <a href="#dictionary-literal-items"><em>字典字面量项列表</em></a> <strong>]</strong> | <strong>[</strong> <strong>:</strong> <strong>]</strong><br><a name="dictionary-literal-items"></a><br><em>字典字面量项列表</em> → <a href="#dictionary-literal-item"><em>字典字面量项</em></a> <strong>,</strong><sub>可选</sub> | <a href="#dictionary-literal-item"><em>字典字面量项</em></a> <strong>,</strong> <a href="#dictionary-literal-items"><em>字典字面量项列表</em></a><br><a name="dictionary-literal-item"></a><br><em>字典字面量项</em> → <a href="#expression"><em>表达式</em></a> <strong>:</strong> <a href="#expression"><em>表达式</em></a>  </p>
</blockquote>
<p><a name="self_expression"></a></p>
<h3 id="self_表达式">self 表达式</h3><p><code>self</code> 表达式是对当前类型或者当前实例的显式引用，它有如下形式：</p>
<blockquote>
<p>self<br>self.<code>成员名称</code><br>self[<code>下标索引</code>]<br>self(<code>构造器参数</code>)<br>self.init(<code>构造器参数</code>)</p>
</blockquote>
<p>如果在构造器、下标、实例方法中，<code>self</code> 引用的是当前类型的实例。在一个类型方法中，<code>self</code> 引用的是当前的类型。</p>
<p>当访问成员时，<code>self</code> 可用来区分重名变量，例如函数的参数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> greeting: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(greeting: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.greeting = greeting</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>mutating</code> 方法中，你可以对 <code>self</code> 重新赋值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">moveByX</span><span class="params">(deltaX: Double, y deltaY: Double)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span> = <span class="type">Point</span>(x: x + deltaX, y: y + deltaY)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>self 表达式语法<br><a name="self-expression"></a><br><em>self 表达式</em> → <strong>self</strong><br><em>self 表达式</em> → <strong>self</strong> <strong>.</strong> <a href="02_Lexical_Structure.md#identifier"><em>标识符</em></a><br><em>self 表达式</em> → <strong>self</strong> <strong>[</strong> <a href="#expression"><em>表达式</em></a> <strong>]</strong><br><em>self 表达式</em> → <strong>self</strong> <strong>.</strong> <strong>init</strong>  </p>
</blockquote>
<p><a name="superclass_expression"></a></p>
<h3 id="超类表达式">超类表达式</h3><p>超类表达式可以使我们在某个类中访问它的超类，它有如下形式：</p>
<blockquote>
<p>super.<code>成员名称</code><br>super[<code>下标索引</code>]<br>super.init(<code>构造器参数</code>)</p>
</blockquote>
<p>第一种形式用来访问超类的某个成员，第二种形式用来访问超类的下标，第三种形式用来访问超类的构造器。</p>
<p>子类可以通过超类表达式在它们的成员、下标和构造器中使用超类中的实现。</p>
<blockquote>
<p>超类表达式语法<br><a name="superclass-expression"></a><br><em>超类表达式</em> → <a href="#superclass-method-expression"><em>超类方法表达式</em></a> | <a href="#superclass-subscript-expression"><em>超类下标表达式</em></a> | <a href="#superclass-initializer-expression"><em>超类构造器表达式</em></a><br><a name="superclass-method-expression"></a><br><em>超类方法表达式</em> → <strong>super</strong> <strong>.</strong> <a href="02_Lexical_Structure.md#identifier"><em>标识符</em></a><br><a name="superclass-subscript-expression"></a><br><em>超类下标表达式</em> → <strong>super</strong> <strong>[</strong> <a href="#expression"><em>表达式</em></a> <strong>]</strong><br><a name="superclass-initializer-expression"></a><br><em>超类构造器表达式</em> → <strong>super</strong> <strong>.</strong> <strong>init</strong>  </p>
</blockquote>
<p><a name="closure_expression"></a></p>
<h3 id="闭包表达式">闭包表达式</h3><p>闭包表达式会创建一个闭包，在其他语言中也叫匿名函数。跟函数一样，闭包包含了待执行的代码，不同的是闭包还会捕获所在环境中的常量和变量。它的形式如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; (parameters) -&gt; <span class="keyword">return</span> type <span class="keyword">in</span>  </span><br><span class="line">    statements  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>闭包的参数声明形式跟函数一样，请参阅 <a href="05_Declarations.md#function_declaration">函数声明</a>。</p>
<p>闭包还有几种特殊的形式，能让闭包使用起来更加简洁：</p>
<ul>
<li>闭包可以省略它的参数和返回值的类型。如果省略了参数名和参数类型，也要省略 <code>in</code> 关键字。如果被省略的类型无法被编译器推断，那么就会导致编译错误。</li>
<li>闭包可以省略参数名，参数会被隐式命名为 <code>$</code> 跟上其索引位置，例如 <code>$0</code>、<code>$1</code>、<code>$2</code> 分别表示第一个、第二个、第三个参数，以此类推。</li>
<li>如果闭包中只包含一个表达式，那么该表达式的结果就会自动成为闭包的返回值。表达式结果的类型也会被推断为闭包的返回类型。</li>
</ul>
<p>下面几个闭包表达式是等价的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">myFunction &#123;</span><br><span class="line">    (x: <span class="type">Int</span>, y: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFunction &#123;</span><br><span class="line">    (x, y) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFunction &#123; <span class="keyword">return</span> $<span class="number">0</span> + $<span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line">myFunction &#123; $<span class="number">0</span> + $<span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>
<p>关于如何将闭包作为参数来传递的内容，请参阅 <a href="#function_call_expression">函数调用表达式</a>。</p>
<h4 id="捕获列表">捕获列表</h4><p>默认情况下，闭包会通过强引用捕获所在环境中的常量和变量。你可以通过一个捕获列表来显式指定它的捕获行为。</p>
<p>捕获列表在参数列表之前，由中括号括起来，里面是由逗号分隔的一系列表达式。一旦使用了捕获列表，就必须使用 <code>in</code> 关键字，即使省略了参数名、参数类型、返回类型。</p>
<p>捕获列表中的条目会在闭包创建时被初始化。每一个条目都会被闭包所在环境中的同名常量或者变量初始化。例如下面的代码示例中，捕获列表包含 <code>a</code> 而不包含 <code>b</code>，这将导致这两个变量具有不同的行为。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> closure = &#123; [a] <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line">closure()</span><br><span class="line"><span class="comment">// 打印 “0 10”</span></span><br></pre></td></tr></table></figure>
<p>在示例中，变量 <code>b</code> 只有一个，然而，变量 <code>a</code> 有两个，一个在闭包外，一个在闭包内。闭包内的变量 <code>a</code> 会在闭包创建时用闭包外的变量 <code>a</code> 的值来初始化，除此之外它们并无其他联系。这意味着在闭包创建后，改变某个 <code>a</code> 的值都不会对另一个 <code>a</code> 的值造成任何影响。与此相反，闭包内外都是同一个变量 <code>b</code>，因此在闭包外改变其值，闭包内的值也会受影响。</p>
<p>如果闭包捕获的值是引用语义，则又会有所不同。例如，下面示例中，有两个变量 <code>x</code>，一个在闭包外，一个在闭包内，由于它们的值是引用语义，虽然这是两个不同的变量，它们却都引用着同一实例。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="type">SimpleClass</span>()</span><br><span class="line"><span class="keyword">var</span> y = <span class="type">SimpleClass</span>()</span><br><span class="line"><span class="keyword">let</span> closure = &#123; [x] <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(x.value, y.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x.value = <span class="number">10</span></span><br><span class="line">y.value = <span class="number">10</span></span><br><span class="line">closure()</span><br><span class="line"><span class="comment">// 打印 “10 10”</span></span><br></pre></td></tr></table></figure>
<p>如果捕获列表中的值是类类型，你可以使用 <code>weak</code> 或者 <code>unowned</code> 来修饰它，闭包会分别用弱引用和无主引用来捕获该值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myFunction &#123; <span class="built_in">print</span>(<span class="keyword">self</span>.title) &#125;                   <span class="comment">// 以强引用捕获</span></span><br><span class="line">myFunction &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span> <span class="built_in">print</span>(<span class="keyword">self</span>!.title) &#125;   <span class="comment">// 以弱引用捕获</span></span><br><span class="line">myFunction &#123; [<span class="keyword">unowned</span> <span class="keyword">self</span>] <span class="keyword">in</span> <span class="built_in">print</span>(<span class="keyword">self</span>.title) &#125; <span class="comment">// 以无主引用捕获</span></span><br></pre></td></tr></table></figure>
<p>在捕获列表中，也可以使用任意表达式来赋值。该表达式会在闭包被创建时进行求值，闭包会按照指定的引用类型来捕获表达式的值。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以弱引用捕获 self.parent 并赋值给 parent</span></span><br><span class="line">myFunction &#123; [<span class="keyword">weak</span> parent = <span class="keyword">self</span>.parent] <span class="keyword">in</span> <span class="built_in">print</span>(parent!.title) &#125;</span><br></pre></td></tr></table></figure>
<p>关于闭包表达式的更多信息和例子，请参阅 <a href="../chapter2/07_Closures.md#closure_expressions">闭包表达式</a>。关于捕获列表的更多信息和例子，请参阅 <a href="../chapter2/16_Automatic_Reference_Counting.md#resolving_strong_reference_cycles_for_closures">解决闭包引起的循环强引用</a>。</p>
<blockquote>
<p>闭包表达式语法  </p>
</blockquote>
<p><a name="closure-expression"></a></p>
<blockquote>
<p><em>闭包表达式</em> → <strong>{</strong> <a href="#closure-signature"><em>闭包签名</em></a><sub>可选</sub> <a href="10_Statements.md#statements"><em>语句</em></a> <strong>}</strong>  </p>
</blockquote>
<p><a name="closure-signature"></a></p>
<blockquote>
<p><em>闭包签名</em> → <a href="05_Declarations.md#parameter-clause"><em>参数子句</em></a> <a href="05_Declarations.md#function-result"><em>函数结果</em></a><sub>可选</sub> <strong>in</strong><br><em>闭包签名</em> → <a href="02_Lexical_Structure.md#identifier-list"><em>标识符列表</em></a> <a href="05_Declarations.md#function-result"><em>函数结果</em></a><sub>可选</sub> <strong>in</strong><br><em>闭包签名</em> → <a href="#capture-list"><em>捕获列表</em></a> <a href="05_Declarations.md#parameter-clause"><em>参数子句</em></a> <a href="05_Declarations.md#function-result"><em>函数结果</em></a><sub>可选</sub> <strong>in</strong><br><em>闭包签名</em> → <a href="#capture-list"><em>捕获列表</em></a> <a href="02_Lexical_Structure.md#identifier-list"><em>标识符列表</em></a> <a href="05_Declarations.md#function-result"><em>函数结果</em></a><sub>可选</sub> <strong>in</strong><br><em>闭包签名</em> → <a href="#capture-list"><em>捕获列表</em></a> <strong>in</strong>  </p>
</blockquote>
<p><a name="capture-list"></a></p>
<blockquote>
<p><em>捕获列表</em> → <strong>[</strong> <a href="#capture-list-items"><em>捕获列表项列表</em></a> <strong>]</strong><br><a name="capture-list-items"></a><br><em>捕获列表项列表</em> → <a href="#capture-list-item"><em>捕获列表项</em></a> | <a href="#capture-list-item"><em>捕获列表项</em></a> <strong>,</strong> <a href="#capture-list-items"><em>捕获列表项列表</em></a><br><a name="capture-list-item"></a><br><em>捕获列表项</em> → <a href="#capture-specifier"><em>捕获说明符</em></a><sub>可选</sub> <a href="#expression"><em>表达式</em></a><br><a name="capture-specifier"></a><br><em>捕获说明符</em> → <strong>weak</strong> | <strong>unowned</strong> | <strong>unowned(safe)</strong> | <strong>unowned(unsafe)</strong>  </p>
</blockquote>
<p><a name="implicit_member_expression"></a></p>
<h3 id="隐式成员表达式">隐式成员表达式</h3><p>在可以判断出类型的上下文中，隐式成员表达式是访问某个类型的成员（例如某个枚举成员或某个类型方法）的简洁方法，形式如下：</p>
<blockquote>
<p>.<code>成员名称</code></p>
</blockquote>
<p>例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="type">MyEnumeration</span>.<span class="type">SomeValue</span></span><br><span class="line">x = .<span class="type">AnotherValue</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>隐式成员表达式语法<br><a name="implicit-member-expression"></a><br><em>隐式成员表达式</em> → <strong>.</strong> <a href="02_Lexical_Structure.md#identifier"><em>标识符</em></a>  </p>
</blockquote>
<p><a name="parenthesized_expression"></a></p>
<h3 id="圆括号表达式">圆括号表达式</h3><p>圆括号表达式由多个逗号分隔的子表达式组成。每个子表达式前面可以有一个标识符，用冒号隔开，其形式如下：</p>
<blockquote>
<p>(<code>标识符 1</code> : <code>表达式 1</code>, <code>标识符 2</code> : <code>表达式 2</code>, <code>...</code>)</p>
</blockquote>
<p>使用圆括号表达式来创建元组，然后将其作为参数传递给函数。如果某个圆括号表达式中只有一个子表达式，那么它的类型就是子表达式的类型。例如，表达式 <code>(1)</code> 的类型是 <code>Int</code>，而不是 <code>(Int)</code>。</p>
<blockquote>
<p>圆括号表达式语法<br><a name="parenthesized-expression"></a><br><em>圆括号表达式</em> → <strong>(</strong> <a href="#expression-element-list"><em>表达式元素列表</em></a><sub>可选</sub> <strong>)</strong><br><a name="expression-element-list"></a><br><em>表达式元素列表</em> → <a href="#expression-element"><em>表达式元素</em></a> | <a href="#expression-element"><em>表达式元素</em></a> <strong>,</strong> <a href="#expression-element-list"><em>表达式元素列表</em></a><br><a name="expression-element"></a><br><em>表达式元素</em> → <a href="#expression"><em>表达式</em></a> | <a href="02_Lexical_Structure.md#identifier"><em>标识符</em></a> <strong>:</strong> <a href="#expression"><em>表达式</em></a>  </p>
</blockquote>
<p><a name="wildcard_expression"></a></p>
<h3 id="通配符表达式">通配符表达式</h3><p>通配符表达式用来忽略传递进来的某个参数。例如，下面的代码中，<code>10</code> 被传递给 <code>x</code>，<code>20</code> 被忽略：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(x, <span class="number">_</span>) = (<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="comment">// x 为 10，20 被忽略</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>通配符表达式语法<br><a name="wildcard-expression"></a><br><em>通配符表达式</em> → <strong>_</strong>  </p>
</blockquote>
<p><a name="postfix_expressions"></a></p>
<h2 id="后缀表达式">后缀表达式</h2><p>后缀表达式就是在某个表达式的后面加上后缀运算符。严格地讲，每个基本表达式也是一个后缀表达式。</p>
<p>关于这些运算符的更多信息，请参阅 <a href="../chapter2/02_Basic_Operators.html">基本运算符</a> 和 <a href="../chapter2/25_Advanced_Operators.html">高级运算符</a>。</p>
<p>关于 Swift 标准库提供的运算符的更多信息，请参阅 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Reference/Swift_StandardLibrary_Operators/index.html#//apple_ref/doc/uid/TP40016054" target="_blank" rel="external"><em>Swift Standard Library Operators Reference</em></a>。</p>
<blockquote>
<p>后缀表达式语法<br><a name="postfix-expression"></a><br><em>后缀表达式</em> → <a href="#primary-expression"><em>基本表达式</em></a><br><em>后缀表达式</em> → <a href="#postfix-expression"><em>后缀表达式</em></a> <a href="02_Lexical_Structure.md#postfix-operator"><em>后缀运算符</em></a><br><em>后缀表达式</em> → <a href="#function-call-expression"><em>函数调用表达式</em></a><br><em>后缀表达式</em> → <a href="#initializer-expression"><em>构造器表达式</em></a><br><em>后缀表达式</em> → <a href="#explicit-member-expression"><em>显式成员表达式</em></a><br><em>后缀表达式</em> → <a href="#postfix-self-expression"><em>后缀 self 表达式</em></a><br><em>后缀表达式</em> → <a href="#dynamic-type-expression"><em>dynamicType 表达式</em></a><br><em>后缀表达式</em> → <a href="#subscript-expression"><em>下标表达式</em></a><br><em>后缀表达式</em> → <a href="#forced-value-expression"><em>强制取值表达式</em></a><br><em>后缀表达式</em> → <a href="#optional-chaining-expression"><em>可选链表达式</em></a></p>
</blockquote>
<p><a name="function_call_expression"></a></p>
<h3 id="函数调用表达式">函数调用表达式</h3><p>函数调用表达式由函数名和参数列表组成，形式如下：</p>
<blockquote>
<p><code>函数名</code>(<code>参数 1</code>, <code>参数 2</code>)</p>
</blockquote>
<p>函数名可以是值为函数类型的任意表达式。</p>
<p>如果函数声明中指定了参数的名字，那么在调用的时候也必须得写出来。这种函数调用表达式具有以下形式：</p>
<blockquote>
<p><code>函数名</code>(<code>参数名 1</code>: <code>参数 1</code>, <code>参数名 2</code>: <code>参数 2</code>)</p>
</blockquote>
<p>如果函数的最后一个参数是函数类型，可以在函数调用表达式的尾部（右圆括号之后）加上一个闭包，该闭包会作为函数的最后一个参数。如下两种写法是等价的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// someFunction 接受整数和闭包参数</span></span><br><span class="line">someFunction(x, f: &#123;$<span class="number">0</span> == <span class="number">13</span>&#125;)</span><br><span class="line">someFunction(x) &#123;$<span class="number">0</span> == <span class="number">13</span>&#125;</span><br></pre></td></tr></table></figure>
<p>如果闭包是该函数的唯一参数，那么圆括号可以省略。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// someFunction 只接受一个闭包参数</span></span><br><span class="line">myData.someMethod() &#123;$<span class="number">0</span> == <span class="number">13</span>&#125;</span><br><span class="line">myData.someMethod &#123;$<span class="number">0</span> == <span class="number">13</span>&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数调用表达式语法<br><a name="function-call-expression"></a><br><em>函数调用表达式</em> → <a href="#postfix-expression"><em>后缀表达式</em></a> <a href="#parenthesized-expression"><em>圆括号表达式</em></a><br><em>函数调用表达式</em> → <a href="#postfix-expression"><em>后缀表达式</em></a> <a href="#parenthesized-expression"><em>圆括号表达式</em></a><sub>可选</sub> <a href="#trailing-closure"><em>尾随闭包</em></a><br><a name="trailing-closure"></a><br><em>尾随闭包</em> → <a href="#closure-expression"><em>闭包表达式</em></a>  </p>
</blockquote>
<p><a name="initializer_expression"></a></p>
<h3 id="构造器表达式">构造器表达式</h3><p>构造器表达式用于访问某个类型的构造器，形式如下：</p>
<blockquote>
<p><code>表达式</code>.init(<code>构造器参数</code>)</p>
</blockquote>
<p>你可以在函数调用表达式中使用构造器表达式来初始化某个类型的新实例。也可以使用构造器表达式来代理到超类的构造器。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeSubClass</span>: <span class="title">SomeSuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 此处为子类构造过程</span></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和函数类似，构造器表达式可以作为一个值。 例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型注解是必须的，因为 String 类型有多种构造器</span></span><br><span class="line"><span class="keyword">let</span> initializer: <span class="type">Int</span> -&gt; <span class="type">String</span> = <span class="type">String</span>.<span class="keyword">init</span></span><br><span class="line"><span class="keyword">let</span> oneTwoThree = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="built_in">map</span>(initializer).<span class="built_in">reduce</span>(<span class="string">""</span>, combine: +)</span><br><span class="line"><span class="built_in">print</span>(oneTwoThree)</span><br><span class="line"><span class="comment">// 打印 “123”</span></span><br></pre></td></tr></table></figure>
<p>如果通过名字来指定某个类型，可以不用构造器表达式而直接使用类型的构造器。在其他情况下，你必须使用构造器表达式。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="type">SomeType</span>.<span class="keyword">init</span>(data: <span class="number">3</span>) <span class="comment">// 有效</span></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="type">SomeType</span>(data: <span class="number">1</span>)      <span class="comment">// 有效</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s4 = someValue.<span class="keyword">dynamicType</span>(data: <span class="number">5</span>)      <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">let</span> s3 = someValue.<span class="keyword">dynamicType</span>.<span class="keyword">init</span>(data: <span class="number">7</span>) <span class="comment">// 有效</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>构造器表达式语法<br><a name="initializer-expression"></a><br><em>构造器表达式</em> → <a href="postfix-expression"><em>后缀表达式</em></a> <strong>.</strong> <strong>init</strong>  </p>
</blockquote>
<p><a name="explicit_member_expression"></a></p>
<h3 id="显式成员表达式">显式成员表达式</h3><p>显式成员表达式允许我们访问命名类型、元组或者模块的成员，形式如下：</p>
<blockquote>
<p><code>表达式</code>.<code>成员名</code></p>
</blockquote>
<p>命名类型的某个成员在原始实现或者扩展中定义，例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> someProperty = <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = <span class="type">SomeClass</span>()</span><br><span class="line"><span class="keyword">let</span> y = <span class="built_in">c</span>.someProperty <span class="comment">// 访问成员</span></span><br></pre></td></tr></table></figure>
<p>元组的成员会根据表示它们出现顺序的整数来隐式命名，以 0 开始，例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t = (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line">t.<span class="number">0</span> = t.<span class="number">1</span></span><br><span class="line"><span class="comment">// 现在元组 t 为 (20, 20, 30)</span></span><br></pre></td></tr></table></figure>
<p>对于模块的成员来说，只能直接访问顶级声明中的成员。</p>
<blockquote>
<p>显式成员表达式语法<br><a name="explicit-member-expression"></a><br><em>显式成员表达式</em> → <a href="#postfix-expression"><em>后缀表达式</em></a> <strong>.</strong> <a href="02_Lexical_Structure.md#decimal-digit"><em>十进制数字</em></a><br><em>显式成员表达式</em> → <a href="#postfix-expression"><em>后缀表达式</em></a> <strong>.</strong> <a href="02_Lexical_Structure.html#identifier"><em>标识符</em></a> <a href="08_Generic_Parameters_and_Arguments.md#generic-argument-clause"><em>泛型实参子句</em></a><sub>可选</sub>  </p>
</blockquote>
<p><a name="postfix_self_expression"></a></p>
<h3 id="后缀_self_表达式">后缀 self 表达式</h3><p>后缀 <code>self</code> 表达式由某个表达式紧跟 <code>.self</code> 组成，形式如下：</p>
<blockquote>
<p><code>表达式</code>.self<br><code>类型</code>.self  </p>
</blockquote>
<p>第一种形式返回表达式的值。例如：<code>x.self</code> 返回 <code>x</code>。</p>
<p>第二种形式返回表示对应类型的值。我们可以用它来动态地获取某个实例的类型。例如，<code>SomeClass.self</code> 会返回 <code>SomeClass</code> 类型本身，你可以将其传递给相应函数或者方法作为参数。</p>
<blockquote>
<p>后缀 self 表达式语法<br><a name="postfix-self-expression"></a><br><em>后缀 self 表达式</em> → <a href="#postfix-expression"><em>后缀表达式</em></a> <strong>.</strong> <strong>self</strong>  </p>
</blockquote>
<p><a name="dynamic_type_expression"></a></p>
<h3 id="dynamicType_表达式">dynamicType 表达式</h3><p><code>dynamicType</code> 表达式由某个表达式紧跟 <code>.dynamicType</code> 组成，形式如下：</p>
<blockquote>
<p><code>表达式</code>.dynamicType</p>
</blockquote>
<p>上述形式中的表达式不能是类型名。<code>dynamicType</code> 表达式会返回某个实例在运行时的类型，具体请看下面的列子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeBaseClass</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">printClassName</span>() </span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"SomeBaseClass"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeSubClass</span>: <span class="title">SomeBaseClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">printClassName</span>() </span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"SomeSubClass"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> someInstance: <span class="type">SomeBaseClass</span> = <span class="type">SomeSubClass</span>()</span><br><span class="line"><span class="comment">// someInstance 在编译时的静态类型为 SomeBaseClass，</span></span><br><span class="line"><span class="comment">// 在运行时的动态类型为 SomeSubClass</span></span><br><span class="line">someInstance.<span class="keyword">dynamicType</span>.printClassName()</span><br><span class="line"><span class="comment">// 打印 “SomeSubClass”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>动态类型表达式语法<br><a name="dynamic-type-expression"></a><br><em>动态类型表达式</em> → <a href="#postfix-expression"><em>后缀表达式</em></a> <strong>.</strong> <strong>dynamicType</strong>  </p>
</blockquote>
<p><a name="subscript_expression"></a></p>
<h3 id="下标表达式">下标表达式</h3><p>可通过下标表达式访问相应的下标，形式如下：</p>
<blockquote>
<p><code>表达式</code>[<code>索引表达式</code>]</p>
</blockquote>
<p>要获取下标表达式的值，可将索引表达式作为下标表达式的参数，调用表达式类型的下标 getter。下标 setter 的调用方式与之一样。</p>
<p>关于下标的声明，请参阅 <a href="05_Declarations.md#protocol_subscript_declaration">协议下标声明</a>。</p>
<blockquote>
<p>下标表达式语法<br><a name="subscript-expression"></a><br><em>下标表达式</em> → <a href="#postfix-expression"><em>后缀表达式</em></a> <strong>[</strong> <a href="#expression-list"><em>表达式列表</em></a> <strong>]</strong>  </p>
</blockquote>
<p><a name="forced-Value_expression"></a></p>
<h3 id="强制取值表达式">强制取值表达式</h3><p>当你确定可选值不是 <code>nil</code> 时，可以使用强制取值表达式来强制解包，形式如下：</p>
<blockquote>
<p><code>表达式</code>!</p>
</blockquote>
<p>如果该表达式的值不是 <code>nil</code>，则返回解包后的值。否则，抛出运行时错误。</p>
<p>返回的值可以被修改，无论是修改值本身，还是修改值的成员。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x: <span class="type">Int</span>? = <span class="number">0</span></span><br><span class="line">x!++</span><br><span class="line"><span class="comment">// x 现在是 1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> someDictionary = [<span class="string">"a"</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">"b"</span>: [<span class="number">10</span>, <span class="number">20</span>]]</span><br><span class="line">someDictionary[<span class="string">"a"</span>]![<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line"><span class="comment">// someDictionary 现在是 [b: [10, 20], a: [100, 2, 3]]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>强制取值语法<br><a name="forced-value-expression"></a><br><em>强制取值表达式</em> → <a href="#postfix-expression"><em>后缀表达式</em></a> <strong>!</strong>  </p>
</blockquote>
<p><a name="optional-chaining_expression"></a></p>
<h3 id="可选链表达式">可选链表达式</h3><p>可选链表达式提供了一种使用可选值的便捷方法，形式如下：</p>
<blockquote>
<p><code>表达式</code>?</p>
</blockquote>
<p>后缀 <code>?</code> 根据表达式生成可选链表达式，而不会改变表达式的值。</p>
<p>如果某个后缀表达式包含可选链表达式，那么它的执行过程会比较特殊。如果该可选链表达式的值是 <code>nil</code>，整个后缀表达式会直接返回 <code>nil</code>。如果该可选链表达式的值不是 <code>nil</code>，则返回可选链表达式解包后的值，并用于后缀表达式中剩余的表达式。在这两种情况下，整个后缀表达式的值都会是可选类型。</p>
<p>如果某个后缀表达式中包含了可选链表达式，那么只有最外层的表达式会返回一个可选类型。例如，在下面的例子中，如果 <code>c</code> 不是 <code>nil</code>，那么它的值会被解包，然后通过 <code>.property</code> 访问它的属性，接着进一步通过 <code>.performAction()</code> 调用相应方法。整个 <code>c?.property.performAction()</code> 表达式返回一个可选类型的值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">c</span>: <span class="type">SomeClass</span>?</span><br><span class="line"><span class="keyword">var</span> result: <span class="type">Bool</span>? = <span class="built_in">c</span>?.property.performAction()</span><br></pre></td></tr></table></figure>
<p>上面的例子跟下面的不使用可选链表达式的例子等价：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result: <span class="type">Bool</span>? = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> unwrappedC = <span class="built_in">c</span> &#123;</span><br><span class="line">    result = unwrappedC.property.performAction()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可选链表达式解包后的值可以被修改，无论是修改值本身，还是修改值的成员。如果可选链表达式的值为 <code>nil</code>，则表达式右侧的赋值操作不会被执行。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">someFunctionWithSideEffects</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="comment">// 译者注：为了能看出此函数是否被执行，加上了一句打印</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"someFunctionWithSideEffects"</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> someDictionary = [<span class="string">"a"</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">"b"</span>: [<span class="number">10</span>, <span class="number">20</span>]]</span><br><span class="line"></span><br><span class="line">someDictionary[<span class="string">"not here"</span>]?[<span class="number">0</span>] = someFunctionWithSideEffects()</span><br><span class="line"><span class="comment">// someFunctionWithSideEffects 不会被执行</span></span><br><span class="line"><span class="comment">// someDictionary 依然是 ["b": [10, 20], "a": [1, 2, 3]]</span></span><br><span class="line"></span><br><span class="line">someDictionary[<span class="string">"a"</span>]?[<span class="number">0</span>] = someFunctionWithSideEffects()</span><br><span class="line"><span class="comment">// someFunctionWithSideEffects 被执行并返回 42</span></span><br><span class="line"><span class="comment">// someDictionary 现在是 ["b": [10, 20], "a": [42, 2, 3]]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>可选链表达式语法<br><a name="optional-chaining-expression"></a><br><em>可选链表达式</em> → <a href="#postfix-expression"><em>后缀表达式</em></a> <strong>?</strong>  </p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter3/05_Declarations/" itemprop="url">
                第三章-05声明（Declarations）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T11:00:16+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter3/05_Declarations/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter3/05_Declarations/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><a name="declarations"></a></p>
<h1 id="声明（Declarations）">声明（Declarations）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/marsprince" target="_blank" rel="external">marsprince</a> <a href="https://github.com/marsprince" target="_blank" rel="external">Lenhoon</a><a href="http://www.weibo.com/lenhoon" target="_blank" rel="external">(微博)</a><br>校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>, <a href="https://github.com/stanzhai" target="_blank" rel="external">stanzhai</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/Lenhoon" target="_blank" rel="external">Lenhoon</a>,<br><a href="https://github.com/WXGBridgeQ" target="_blank" rel="external">BridgeQ</a></p>
<p>2.1<br>翻译：<a href="https://github.com/mmoaay" target="_blank" rel="external">mmoaay</a>, <a href="http://codebuild.me" target="_blank" rel="external">shanks</a><br>校队：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#top-level_code">顶级代码</a></li>
<li><a href="#code_blocks">代码块</a></li>
<li><a href="#import_declaration">引入声明</a></li>
<li><a href="#constant_declaration">常量声明</a></li>
<li><a href="#variable_declaration">变量声明</a></li>
<li><a href="#type_alias_declaration">类型的别名声明</a></li>
<li><a href="#function_declaration">函数声明</a></li>
<li><a href="#enumeration_declaration">枚举声明</a></li>
<li><a href="#structure_declaration">结构体声明</a></li>
<li><a href="#class_declaration">类声明</a></li>
<li><a href="#protocol_declaration">协议声明</a></li>
<li><a href="#initializer_declaration">构造器声明</a></li>
<li><a href="#deinitializer_declaration">析构声明</a></li>
<li><a href="#extension_declaration">扩展声明</a></li>
<li><a href="#subscript_declaration">下标脚本声明</a></li>
<li><a href="#operator_declaration">运算符声明</a></li>
<li><a href="#declaration_modifiers">声明修饰符</a></li>
</ul>
<p>一条<em>声明(declaration)</em>可以在程序里引入新的名字或者构造。举例来说，可以使用声明来引入函数和方法，变量和常量，或者来定义新的命名好的枚举，结构，类和协议类型。可以使用一条声明来延长一个已经存在的命名好的类型的行为。或者在程序里引入在其它地方声明的符号。</p>
<p>在Swift中，大多数声明在某种意义上讲也是执行或同时声明它们的初始化定义。这意味着，因为协议和它们的成员不匹配，大多数协议成员需要单独的声明。为了方便起见，也因为这些区别在Swift里不是很重要，<em>声明语句(declaration)</em>同时包含了声明和定义。</p>
<blockquote>
<p>声明语法<br><em>声明</em> → <a href="#grammer_of_an_import_declaration"><em>导入声明</em></a><br><em>声明</em> → <a href="#grammer_of_a_constant_declaration"><em>常量声明</em></a><br><em>声明</em> → <a href="#grammer_of_a_variable_declaration"><em>变量声明</em></a><br><em>声明</em> → <a href="#grammer_of_a_type_alias_declaration"><em>类型别名声明</em></a><br><em>声明</em> → <a href="#grammer_of_a_function_declaration"><em>函数声明</em></a><br><em>声明</em> → <a href="#grammer_of_a_enumeration_declaration"><em>枚举声明</em></a><br><em>声明</em> → <a href="#grammer_of_a_structure_declaration"><em>结构体声明</em></a><br><em>声明</em> → <a href="#grammer_of_a_class_declaration"><em>类声明</em></a><br><em>声明</em> → <a href="#grammer_of_a_protocol_declaration"><em>协议声明</em></a><br><em>声明</em> → <a href="#grammer_of_an_initializer_declaration"><em>构造器声明</em></a><br><em>声明</em> → <a href="#grammer_of_a_deinitializer_declaration"><em>析构器声明</em></a><br><em>声明</em> → <a href="#grammer_of_an_extension_declaration"><em>扩展声明</em></a><br><em>声明</em> → <a href="#grammer_of_a_subscript_declaration"><em>附属脚本声明</em></a><br><em>声明</em> → <a href="#grammer_of_an_operator_declaration"><em>运算符声明</em></a><br><em>声明(Declarations)列表</em> → <a href="#declaration"><em>声明</em></a> <a href="#declarations"><em>声明(Declarations)列表</em></a> <em>可选</em>    </p>
</blockquote>
<p><a name="top-level_code"></a></p>
<p>##顶级代码</p>
<p>Swift 的源文件中的顶级代码由零个或多个语句，声明和表达式组成。默认情况下，在一个源文件的顶层声明的变量，常量和其他命名的声明语句可以被同一模块部分里的每一个源文件中的代码访问。可以通过使用一个访问级别修饰符来标记这个声明，从而重写这个默认行为，<a href="#access_control_levels">访问控制级别(Access Control Levels)</a>中有所介绍。</p>
<blockquote>
<p>顶级(Top Level) 声明语法<br><em>顶级声明</em> → <a href="../chapter3/04_Expressions.html"><em>多条语句(Statements)</em></a> <em>可选</em>  </p>
</blockquote>
<p><a name="code_blocks"></a></p>
<p>##代码块</p>
<p><em>代码块</em>用来将一些声明和控制结构的语句组织在一起。它有如下的形式：</p>
<blockquote>
<p>{<br>    <code>statements</code><br>}  </p>
</blockquote>
<p>代码块中的<em>语句(statements)</em>包括声明，表达式和各种其他类型的语句，它们按照在源码中的出现顺序被依次执行。</p>
<blockquote>
<p>代码块语法<br><em>代码块</em> → <strong>{</strong> <a href="../chapter3/04_Expressions.html"><em>多条语句(Statements)</em></a> <em>可选</em> <strong>}</strong>  </p>
</blockquote>
<p><a name="import_declaration"></a></p>
<p>##引入声明</p>
<p>可以使用在其他文件中声明的内容<em>引入声明(import declaration)</em>。引入语句的基本形式是引入整个代码模块；它由<code>import</code>关键字开始，后面<br>紧跟一个模块名：</p>
<blockquote>
<p>import <code>module</code></p>
</blockquote>
<p>可以提供更多的细节来限制引入的符号，如声明一个特殊的子模块或者在一个模块或子模块中做特殊的声明。（待改进）<br>当使用了这些细节后，在当前的程序汇总只有引入的符号是可用的（并不是声明的整个模块）。</p>
<blockquote>
<p>import <code>import kind</code> <code>module</code>.<code>symbol name</code><br>import <code>module</code>.<code>submodule</code>  </p>
</blockquote>
<p><a name="grammer_of_an_import_declaration"></a></p>
<blockquote>
<p>导入(Import)声明语法<br><em>导入声明</em> → <a href="../chapter3/06_Attributes.html"><em>特性(attributes)列表</em></a> <em>可选</em> <strong>import</strong> <a href="../chapter3/05_Declarations.html#import_kind"><em>导入类型</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#import_path"><em>导入路径</em></a><br><em>导入类型</em> → <strong>typealias</strong> | <strong>struct</strong> | <strong>class</strong> | <strong>enum</strong> | <strong>protocol</strong> | <strong>var</strong> | <strong>func</strong><br><em>导入路径</em> → <a href="../chapter3/05_Declarations.html#import_path_identifier"><em>导入路径标识符</em></a> | <a href="../chapter3/05_Declarations.html#import_path_identifier"><em>导入路径标识符</em></a> <strong>.</strong> <a href="../chapter3/05_Declarations.html#import_path"><em>导入路径</em></a><br><em>导入路径标识符</em> → <a href="../chapter3/02_Lexical_Structure.html"><em>标识符</em></a> | <a href="../chapter3/02_Lexical_Structure.html"><em>运算符</em></a>  </p>
</blockquote>
<p><a name="constant_declaration"></a></p>
<p>##常量声明</p>
<p><em>常量声明(constant declaration)</em>可以在程序里命名一个常量。常量以关键词<code>let</code>来声明，遵循如下的格式:</p>
<blockquote>
<p>let <code>constant name</code>: <code>type</code> = <code>expression</code></p>
</blockquote>
<p>当常量的值被给定后，常量就将<em>常量名称(constant name)</em>和<em>表达式(expression)</em>初始值不变的结合在了一起，而且不能更改。</p>
<p>这意味着如果常量以类的形式被初始化，类本身的内容是可以改变的，但是常量和类之间的结合关系是不能改变的。</p>
<p>当一个常量被声明为全局变量，它必须被给定一个初始值。当一个常量在类或者结构体中被声明时，它被认为是一个<em>常量属性(constant property)</em>。常量并不是可计算的属性，因此不包含getters和setters。</p>
<p>如果<em>常量名(constant name)</em>是一个元组形式，元组中的每一项初始化<em>表达式(expression)</em>中都要有对应的值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (firstNumber, secondNumber) = (<span class="number">10</span>, <span class="number">42</span>)</span><br></pre></td></tr></table></figure>
<p>在上例中，<code>firstNumber</code>是一个值为<code>10</code>的常量，<code>secnodeName</code>是一个值为<code>42</code>的常量。所有常量都可以独立的使用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println</span>(<span class="string">"The first number is /(firstNumber)."</span>)</span><br><span class="line"><span class="comment">// prints "The first number is 10."</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"The second number is /(secondNumber)."</span>)</span><br><span class="line"><span class="comment">// prints "The second number is 42."</span></span><br></pre></td></tr></table></figure>
<p>当<em>常量名称(constant name)</em>的类型可以被推断出时，类型标注<em>（:type）</em>在常量声明中是一个可选项，它可以用来描述在<a href="./03_Types.html#type_inference">类型推断(Type Inference)</a>中找到的类型。</p>
<p>声明一个常量类型属性要使用关键字<code>static</code>声明修饰符。类型属性在<a href="../chapter2/10_Properties.html#type_properties">类型属性(Type Properties)</a>中有介绍。</p>
<p>如果还想获得更多关于常量的信息或者想在使用中获得帮助，请查看<a href="../chapter2/01_The_Basics.html#constants_and_variables">常量和变量</a>和<a href="../chapter2/10_Properties.html#stored_properties">存储属性(Stored Properties)</a>等节。</p>
<p><a name="grammer_of_a_constant_declaration"></a></p>
<blockquote>
<p>常数声明语法<br><em>常量声明</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>特性(Attributes)列表</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#declaration_specifiers"><em>声明修饰符(Specifiers)列表</em></a> <em>可选</em> <strong>let</strong> <a href="../chapter3/05_Declarations.html#pattern_initializer_list"><em>模式构造器列表</em></a><br><em>模式构造器列表</em> → <a href="../chapter3/05_Declarations.html#pattern_initializer"><em>模式构造器</em></a> | <a href="../chapter3/05_Declarations.html#pattern_initializer"><em>模式构造器</em></a> <strong>,</strong> <a href="../chapter3/05_Declarations.html#pattern_initializer_list"><em>模式构造器列表</em></a><br><em>模式构造器</em> → <a href="../chapter3/07_Patterns.html#pattern"><em>模式</em></a> <a href="../chapter3/05_Declarations.html#initializer"><em>构造器</em></a> <em>可选</em><br><em>构造器</em> → <strong>=</strong> <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a>  </p>
</blockquote>
<p><a name="variable_declaration"></a></p>
<p>##变量声明</p>
<p><em>变量声明(variable declaration)</em>可以在程序里声明一个变量，它以关键字<code>var</code>来声明。</p>
<p>变量声明有几种不同的形式声明不同种类的命名值和计算型值，如存储和计算变量和属性，存储变量和属性监视，和静态变量属性。所使用的声明形式取决于变量所声明的范围和打算声明的变量类型。</p>
<blockquote>
<p>注意：<br>也可以在协议声明的上下文声明属性，详情参见<a href="./05_Declarations.html#protocol_declaration">协议属性声明(Protocal Property Declaration)</a>。</p>
</blockquote>
<p>可以重载一个子类中的属性，通过使用’override’声明修饰符来标记子类的属性声明，<a href="../chapter2/13_Inheritance.html#overriding">重写(Overriding)</a>中有所介绍。</p>
<p><a name="stored_variables_and_stored_variable_properties"></a></p>
<p>###存储型变量和存储型属性</p>
<p>下面的形式声明了一个存储型变量或存储型变量属性</p>
<blockquote>
<p>var <code>variable name</code>: <code>type</code> = <code>expression</code></p>
</blockquote>
<p>可以在全局，函数内，或者在类和结构体的声明(context)中使用这种形式来声明一个变量。当变量以这种形式<br>在全局或者一个函数内被声明时，它代表一个<em>存储型变量(stored variable)</em>。当它在类或者结构体中被声明时，它代表一个<em>存储型变量属性(stored variable property)</em>。</p>
<p>初始化的<em>表达式（expression）</em>不可以在协议的声明中出现，在其他情况下，初始化<em>表达式(expression)</em>是可选的（optional），如果没有初始化<em>表达式(expression)</em>，那么变量定义时必须显示包括类型标注（<em>:type</em>)</p>
<p>对于常量的定义，如果<em>变量名字（variable name）</em>是一个元组（tuple），元组中每一项的名称都要和初始化<em>表达式(expression)</em>中的相应值一致。</p>
<p>正如名字一样，存储型变量的值或存储型变量属性存储在内存中。</p>
<p><a name="computed_variables_and_computed_properties"></a></p>
<p>###计算型变量和计算型属性</p>
<p>如下形式声明一个一个存储型变量或存储型属性：</p>
<blockquote>
<p>var <code>variable name</code>: <code>type</code> {<br>get {<br>    <code>statements</code><br>}<br>set(<code>setter name</code>) {<br>    <code>statements</code><br>}<br>}  </p>
</blockquote>
<p>可以在全局，函数体内或者类，结构体，枚举，扩展声明的上下文中使用这种形式的声明。当变量以这种形式在全局或者一个函数内被声明时，它代表一个<em>计算型变量(computed variable)</em>。当它在类，结构体，枚举，扩展声明的上下文中中被声明时，它代表一个<em>计算型变量(computed variable)</em>。</p>
<p>getter用来读取变量值，setter用来写入变量值。setter子句是可选择的，只有getter是必需的，可以将这些语句<br>都省略，只是简单的直接返回请求值，正如在<a href="../chapter2/10_Properties.html#computed_properties">只读计算属性(Read-Only Computed Properties)</a>中描述的那样。但是如果提供了一个setter语句，也必需提供一个getter语句。</p>
<p>setter的名字和圆括号内的语句是可选的。如果写了一个setter名，它就会作为setter的参数被使用。如果不写setter名，setter的初始名为’newValue’，正如在<a href="../chapter2/10_Properties.html#shorthand_setter_declaration">便捷 setter 声明(Shorthand Setter Declaration)</a>中提到的那样。</p>
<p>不像存储型变量和存储型属性那样，计算型属性和计算型变量的值不存储在内存中。</p>
<p>获得更多信息，查看更多关于计算型属性的例子，请查看<a href="../chapter2/10_Properties.html#computed_properties">计算属性(Computed Properties)</a>一节。</p>
<p><a name="stored_variable_observers_and_property_observers"></a></p>
<p>###存储型变量监视器和属性监视器</p>
<p>可以用<code>willset</code>和<code>didset</code>监视器来声明一个存储型变量或属性。一个包含监视器的存储型变量或属性按如下的形式声明：</p>
<blockquote>
<p>var <code>variable name</code>: <code>type</code> = expression {<br>willSet(setter name) {<br>    <code>statements</code><br>}<br>didSet(<code>setter name</code>) {<br>    <code>statements</code><br>}<br>}  </p>
</blockquote>
<p>可以在全局，函数体内或者类，结构体，枚举，扩展声明的上下文中使用这种形式的声明。当变量以这种形式在全局或者一个函数内被声明时，监视器代表一个<em>存储型变量监视器(stored variable observers)</em>；当它在类，结构体，枚举，扩展声明的上下文中被声明时，监视器代表<em>属性监视器(property observers)</em>。</p>
<p>可以为适合的监视器添加任何存储型属性。也可以通过重写子类属性的方式为适合的监视器添加任何继承的属性<br>(无论是存储型还是计算型的)，参见<a href="../chapter2/13_Inheritance.html#overriding">重写属性监视器(Overriding Property Observers)</a>。</p>
<p>初始化<em>表达式(expression)</em>在一个类中或者结构体的声明中是可选的，但是在其他地方是必需的。当类型可以从初始化<em>表达式(expression)</em>中推断而来，那么这个<em>类型(type)</em>标注是可选的。</p>
<p>当变量或属性的值被改变时，<code>willset</code>和<code>didset</code>监视器提供了一个监视方法（适当的回应）。<br>监视器不会在变量或属性第一次初始化时运行，它们只有在值被外部初始化语句改变时才会被运行。</p>
<p><code>willset</code>监视器只有在变量或属性值被改变之前运行。新的值作为一个常量经过过<code>willset</code>监视器，因此不可以在<code>willset</code>语句中改变它。<code>didset</code>监视器在变量或属性值被改变后立即运行。和<code>willset</code>监视器相反，为了以防止仍然需要获得旧的数据，旧变量值或者属性会经过<code>didset</code>监视器。这意味着，如果在变量或属性自身的<code>didiset</code>监视器语句中设置了一个值，设置的新值会取代刚刚在<code>willset</code>监视器中经过的那个值。</p>
<p>在<code>willset</code>和<code>didset</code>语句中，<em>setter名(setter name)</em>和圆括号的语句是可选的。如果写了一个setter名，它就会作为<code>willset</code>和<code>didset</code>的参数被使用。如果不写setter名，<br><code>willset</code>监视器初始名为<code>newvalue</code>，<code>didset</code>监视器初始名为<code>oldvalue</code>。</p>
<p>当提供一个<code>willset</code>语句时，<code>didset</code>语句是可选的。同样的，在提供了一个<code>didset</code>语句时，<code>willset</code>语句是可选的。</p>
<p>获得更多信息，查看如何使用属性监视器的例子，请查看<a href="../chapter2/10_Properties.html#property_observers">属性监视器(Property Observers)</a>一节。<br>声明修饰符</p>
<p><a name="type_variable_properties"></a></p>
<p>###类型变量属性</p>
<p>声明一个类型变量属性，要用<code>static</code>声明修饰符标记该声明。类可能需要<code>class</code>声明修饰符去标记类的类型计算型属性从而允许子类可以重写超类的实现。类型属性在<a href="../chapter2/10_Properties.html#type_properties">类型属性(Type Properties)</a>章节讨论。</p>
<blockquote>
<blockquote>
<p>注意</p>
<p>在一个类声明中，关键字<code>static</code>与用声明修饰符<code>class</code>和<code>final</code>去标记一个声明的效果相同</p>
</blockquote>
</blockquote>
<p><a name="grammer_of_a_variable_declaration"></a></p>
<blockquote>
<p>变量声明语法<br><em>变量声明</em> → <a href="../chapter3/05_Declarations.html#variable_declaration_head"><em>变量声明头(Head)</em></a> <a href="../chapter3/05_Declarations.html#pattern_initializer_list"><em>模式构造器列表</em></a><br><em>变量声明</em> → <a href="../chapter3/05_Declarations.html#variable_declaration_head"><em>变量声明头(Head)</em></a> <a href="../chapter3/05_Declarations.html#variable_name"><em>变量名</em></a> <a href="../chapter3/03_Types.html#type_annotation"><em>类型标注</em></a> <a href="../chapter3/05_Declarations.html#code_block"><em>代码块</em></a><br><em>变量声明</em> → <a href="../chapter3/05_Declarations.html#variable_declaration_head"><em>变量声明头(Head)</em></a> <a href="../chapter3/05_Declarations.html#variable_name"><em>变量名</em></a> <a href="../chapter3/03_Types.html#type_annotation"><em>类型标注</em></a> <a href="../chapter3/05_Declarations.html#getter_setter_block"><em>getter-setter块</em></a><br><em>变量声明</em> → <a href="../chapter3/05_Declarations.html#variable_declaration_head"><em>变量声明头(Head)</em></a> <a href="../chapter3/05_Declarations.html#variable_name"><em>变量名</em></a> <a href="../chapter3/03_Types.html#type_annotation"><em>类型标注</em></a> <a href="../chapter3/05_Declarations.html#getter_setter_keyword_block"><em>getter-setter关键字(Keyword)块</em></a><br><em>变量声明</em> → <a href="../chapter3/05_Declarations.html#variable_declaration_head"><em>变量声明头(Head)</em></a> <a href="../chapter3/05_Declarations.html#variable_name"><em>变量名</em></a> <a href="../chapter3/05_Declarations.html#initializer"><em>构造器</em></a> <a href="../chapter3/05_Declarations.html#willSet_didSet_block"><em>willSet-didSet代码块</em></a><br><em>变量声明</em> → <a href="../chapter3/05_Declarations.html#variable_declaration_head"><em>变量声明头(Head)</em></a> <a href="../chapter3/05_Declarations.html#variable_name"><em>变量名</em></a> <a href="../chapter3/03_Types.html#type_annotation"><em>类型标注</em></a> <a href="../chapter3/05_Declarations.html#initializer"><em>构造器</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#willSet_didSet_block"><em>willSet-didSet代码块</em></a><br><em>变量声明头(Head)</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>特性(Attributes)列表</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#declaration_specifiers"><em>声明修饰符(Specifiers)列表</em></a> <em>可选</em> <strong>var</strong><br><em>变量名称</em> → <a href="LexicalStructure.html#identifier"><em>标识符</em></a><br><a name="getter-setter-block"></a><br><em>getter-setter块</em> → <strong>{</strong> <a href="../chapter3/05_Declarations.html#getter_clause"><em>getter子句</em></a> <a href="../chapter3/05_Declarations.html#setter_clause"><em>setter子句</em></a> <em>可选</em> <strong>}</strong><br><em>getter-setter块</em> → <strong>{</strong> <a href="../chapter3/05_Declarations.html#setter_clause"><em>setter子句</em></a> <a href="../chapter3/05_Declarations.html#getter_clause"><em>getter子句</em></a> <strong>}</strong><br><a name="getter-clause"></a><br><em>getter 子句</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>特性(Attributes)列表</em></a> <em>可选</em> <strong>get</strong> <a href="../chapter3/05_Declarations.html#code_block"><em>代码块</em></a><br><a name="setter-clause"></a><br><em>setter 子句</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>特性(Attributes)列表</em></a> <em>可选</em> <strong>set</strong> <a href="../chapter3/05_Declarations.html#setter_name"><em>setter名称</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#code_block"><em>代码块</em></a><br><em>setter名称</em> → <strong>(</strong> <a href="LexicalStructure.html#identifier"><em>标识符</em></a> <strong>)</strong><br><em>getter-setter关键字(Keyword)块</em> → <strong>{</strong> <a href="../chapter3/05_Declarations.html#getter_keyword_clause"><em>getter关键字(Keyword)子句</em></a> <a href="../chapter3/05_Declarations.html#setter_keyword_clause"><em>setter关键字(Keyword)子句</em></a> <em>可选</em> <strong>}</strong><br><em>getter-setter关键字(Keyword)块</em> → <strong>{</strong> <a href="../chapter3/05_Declarations.html#setter_keyword_clause"><em>setter关键字(Keyword)子句</em></a> <a href="../chapter3/05_Declarations.html#getter_keyword_clause"><em>getter关键字(Keyword)子句</em></a> <strong>}</strong><br><em>getter关键字(Keyword)子句</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>特性(Attributes)列表</em></a> <em>可选</em> <strong>get</strong><br><em>setter关键字(Keyword)子句</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>特性(Attributes)列表</em></a> <em>可选</em> <strong>set</strong><br><em>willSet-didSet代码块</em> → <strong>{</strong> <a href="../chapter3/05_Declarations.html#willSet_clause"><em>willSet子句</em></a> <a href="../chapter3/05_Declarations.html#didSet_clause"><em>didSet子句</em></a> <em>可选</em> <strong>}</strong><br><em>willSet-didSet代码块</em> → <strong>{</strong> <a href="../chapter3/05_Declarations.html#didSet_clause"><em>didSet子句</em></a> <a href="../chapter3/05_Declarations.html#willSet_clause"><em>willSet子句</em></a> <strong>}</strong><br><em>willSet子句</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>特性(Attributes)列表</em></a> <em>可选</em> <strong>willSet</strong> <a href="../chapter3/05_Declarations.html#setter_name"><em>setter名称</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#code_block"><em>代码块</em></a><br><em>didSet子句</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>特性(Attributes)列表</em></a> <em>可选</em> <strong>didSet</strong> <a href="../chapter3/05_Declarations.html#setter_name"><em>setter名称</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#code_block"><em>代码块</em></a>  </p>
</blockquote>
<p><a name="type_alias_declaration"></a></p>
<p>##类型的别名声明</p>
<p><em>类型别名声明(type alias declaration)</em>可以在程序里为一个已存在的类型声明一个别名。类型的别名声明语句使用关键字<code>typealias</code>声明，遵循如下的形式：</p>
<blockquote>
<p><code>typealias name</code> = <code>existing type</code></p>
</blockquote>
<p>当声明一个类型的别名后，可以在程序的任何地方使用别<em>名(name)</em>来代替<em>已存在的类型(existing type)</em>。已存在的类型可以是已经被命名的类型或者是混合类型。类型的别名不产生新的类型，它只是简单的和已存在的类型做名称替换。</p>
<p>查看更多<a href="./05_Declarations.html#protocol_associated_type_declaration">协议关联类型声明(Protocol Associated Type Declaration)</a>.</p>
<p><a name="grammer_of_a_type_alias_declaration"></a></p>
<blockquote>
<p>类型别名声明语法<br><em>类型别名声明</em> → <a href="../chapter3/05_Declarations.html#typealias_head"><em>类型别名头(Head)</em></a> <a href="../chapter3/05_Declarations.html#typealias_assignment"><em>类型别名赋值</em></a><br><em>类型别名头(Head)</em> → <a href="../chapter3/06_Attributes.html"><em>属性列表</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#declaration_modifiers"><em>访问级别修饰符</em></a> <em>可选</em> <strong>typealias</strong> <a href="../chapter3/05_Declarations.html#typealias_name"><em>类型别名名称</em></a><br><em>类型别名名称</em> → <a href="LexicalStructure.html#identifier"><em>标识符</em></a><br><em>类型别名赋值</em> → <strong>=</strong> <a href="../chapter3/03_Types.html#type"><em>类型</em></a>  </p>
</blockquote>
<p><a name="function_declaration"></a></p>
<p>##函数声明</p>
<p>使用<em>函数声明(function declaration)</em>在程序里引入新的函数或者方法。一个函数被声明在类的上下文，结构体，枚举，或者协议中，从而作为<em>方法(method)</em>被引用。<br>函数声明使用关键字<code>func</code>，遵循如下的形式：</p>
<blockquote>
<p>func <code>function name</code>(<code>parameters</code>) -&gt; <code>return type</code> {<br>    <code>statements</code><br>}  </p>
</blockquote>
<p>如果函数返回<code>Void</code>类型，返回类型可以被忽略，如下所示：</p>
<blockquote>
<p>func <code>function name</code>(<code>parameters</code>) {<br>    <code>statements</code><br>}  </p>
</blockquote>
<p>每个参数的类型都要标明，它们不能被推断出来。虽然函数的参数默认是常量，也可以使用参数名前使用<code>let</code>来强调这一行为。在这些参数前面添加<code>var</code>使它们成为变量，作用域内任何对变量的改变只在函数体内有效，或者用<code>inout</code>使的这些改变可以在调用域内生效。更多关于in-out参数的讨论，参见<a href="#">In-Out参数(In-Out Parameters)</a></p>
<p>函数可以使用元组类型作为返回值来返回多个变量。</p>
<p>函数定义可以出现在另一个函数声明内。这种函数被称作nested函数。更多关于<em>嵌套函数(Nested Functions)</em>的讨论，参见<a href="../chapter2/06_Functions.html#Nested_Functions">嵌套函数(Nested Functions)</a>。</p>
<p><a name="parameter_names"></a></p>
<p>###参数名</p>
<p>函数的参数是一个以逗号分隔的列表 。函数调用是的变量顺序必须和函数声明时的参数顺序一致。<br>最简单的参数列表有着如下的形式：</p>
<blockquote>
<p><code>parameter name</code>: <code>parameter type</code></p>
</blockquote>
<p>一个参数有一个内部名称，这个内部名称可以在函数体内被使用。同样也可以作为外部名称，当调用方法时这个外部名称被作为实参的标签来使用。默认情况下，第一个参数的外部名称省略不写，第二个和其之后的参数使用它们的内部名称作为它们的外部名称。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">f</span><span class="params">(x: Int, y: Int)</span></span> -&gt; <span class="type">Int</span>&#123; <span class="keyword">return</span> x + y&#125;</span><br><span class="line">f(<span class="number">1</span>, y: <span class="number">2</span>) <span class="comment">// y是有标记的，x没有</span></span><br></pre></td></tr></table></figure>
<p>可以按如下的一种形式，重写参数名被使用的默认过程：</p>
<blockquote>
<p><code>external parameter name</code> <code>local parameter name</code>: <code>parameter type</code><br>_ <code>local parameter name</code>: <code>parameter type</code>  </p>
</blockquote>
<p>在内部参数名前的名称赋予这个参数一个外部名称，这个名称可以和内部参数的名称不同。外部参数名在函数被调用时必须被使用。对应的参数在方法或函数被调用时必须有外部名 。</p>
<p>内部参数名前的强调字符下划线(_)使参数在函数被调用时没有名称。在函数或方法调用时，与其对应的语句必须没有名字。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">f</span><span class="params">(x x: Int, withY y: Int, _z: Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y + z &#125;</span><br><span class="line">f(x: <span class="number">1</span>, withY: <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// x和y是有标记的，z没有</span></span><br></pre></td></tr></table></figure>
<!--TODO：缺少in-out参数段落-->
<p><a name="special_kinds_of_parameters"></a></p>
<p>###特殊类型的参数</p>
<p>参数可以被忽略，参数的值的数量可变，并且还可以提供默认值，使用形式如下：</p>
<blockquote>
<p>_ : <code>parameter type</code>.<br><code>parameter name</code>: <code>parameter type</code>…<br><code>parameter name</code>: <code>parameter type</code> = <code>default argument value</code>  </p>
</blockquote>
<p>以下划线(_)命名的参数是明确忽略的，在函数体内不能被访问。</p>
<p>一个以基础类型名的参数，如果紧跟着三个点(<code>...</code>)，被理解为是可变参数。一个函数至多可以拥有一个可变参数，且必须是最后一个参数。可变参数被作为该基本类型名的数组来看待。举例来讲，可变参数<code>Int...</code>被看做是<code>[Int]</code>。查看可变参数的使用例子，详见<a href="../chapter2/06_Functions.html#Function_Parameters_and_Return_Values">可变参数(Variadic Parameters)</a>一节。</p>
<p>在参数的类型后面有一个以等号(<code>=</code>)连接的表达式，这样的参数被看做有着给定表达式的初始值。当函数被调用时，给定的表达式被求值。如果参数在函数调用时被省略了，就会使用初始值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">f</span><span class="params">(x: Int = <span class="number">42</span>)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> x&#125;</span><br><span class="line">f()  <span class="comment">// 有效的，使用默认值</span></span><br><span class="line">f(<span class="number">7</span>) <span class="comment">// 有效的，提供了值，没有提供值的名称</span></span><br><span class="line">f(x: <span class="number">7</span>) <span class="comment">//无效的，值和值的名称都提供了</span></span><br></pre></td></tr></table></figure>
<p><a name="special_kinds_of_methods"></a></p>
<p>###特殊方法</p>
<p>枚举或结构体的方法来修改<code>self</code>属性，必须以<code>mutating</code>声明修饰符标记。</p>
<p>子类方法重写超类中的方法必须以<code>override</code>声明修饰符标记。重写一个方法不使用<code>override</code>修饰符，或者使用了<code>override</code>修饰符却并没有重写超类方法都会产生一个编译时错误。</p>
<p>枚举或者结构体中的类型方法而不是实例方法，要以<code>static</code>声明修饰符标记，而对于类中的类型方法，要使用<code>class</code>声明修饰符标记。</p>
<p><a name="curried_functions"></a></p>
<p>###柯里化函数(Curried Functions)</p>
<p>可以重写一个带有多个参数的函数使它等同于一个只有一个参数并且返回一个函数的函数，这个返回函数携带下一个参数并且返回另外一个函数，一直持续到再没有剩余的参数，此时要返回的函数返回原来的多参函数要返回的原始值。这个重写的函数被称为<em>柯里化函数(curried function)</em>。例如，可以为<code>addTwoInts(a:b:)</code>重写一个等价的<code>addTwoIntsCurried(a:)(b:)</code>的函数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">addTwoInts</span><span class="params">(a: Int, b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">addTwoIntsCurried</span><span class="params">(a: Int)</span></span> -&gt; (<span class="type">Int</span> -&gt; <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">addTheOtherInt</span><span class="params">(b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addTheOtherInt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个<code>addTwoInts(a:b:)</code>函数带有两个整型值并且返回他们的和。<code>addTwoIntsCurried(a:)(b:)</code>函数带有一个整型值，并且返回另外一个带有第二个整型值的函数并使其和第一个整型值相加（这个内嵌的函数从包含它的函数中捕获第一个整型参数的值）。</p>
<p>在Swift中，可以通过以下语法非常简明的写一个柯里化函数：</p>
<blockquote>
<p>func <code>function name</code>(<code>parameter</code>)(<code>parameter</code>) -&gt; <code>return type</code> {<br><code>statements</code><br>}  </p>
</blockquote>
<p>举例来说，下面的两个声明是等价的:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">addTwoIntsCurried</span><span class="params">(a a: Int)</span></span>(b: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">addTwoIntsCurried</span><span class="params">(a a: Int)</span></span> -&gt; (<span class="type">Int</span> -&gt; <span class="type">Int</span>) </span><br><span class="line">			&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">addTheOtherInt</span><span class="params">(b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addTheOtherInt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了像使用非柯里化函数一样的方式使用<code>addTwoIntsCurried(a:)(b:)</code>函数，必须用第一个整型参数调用<code>addTwoIntsCurried(a:)(b:)</code>,紧接着用第二个整型参数调用其返回的函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addTwoInts(a: <span class="number">4</span>, b: <span class="number">5</span>)</span><br><span class="line"><span class="comment">//返回值为9</span></span><br><span class="line">addTwoIntsCurried(a: <span class="number">4</span>)(b: <span class="number">5</span>)</span><br><span class="line"><span class="comment">//返回值为9</span></span><br></pre></td></tr></table></figure>
<p>虽然在每次调用一个非柯里化函数时必须提供所有的参数，可以使用函数的柯里化形式把参数分配在多次函数调用中，称之为“<em>偏函数应用(partial function application)</em>”，例如可以为<code>addTwoIntsCurried(a:)(b:)</code>函数使用参数<code>1</code>然后把返回的结果赋值给常量<code>plusOne</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> plusOne = addTwoIntsCurried(a: <span class="number">1</span>)</span><br><span class="line"><span class="comment">// plusOne 是类型为 Int -&gt; Int的函数</span></span><br></pre></td></tr></table></figure>
<p>因为<code>plusOne</code>是函数<code>addTwoIntsCurried(a:)(b:)</code>绑定参数为<code>1</code>时结果，所以可以调用<code>plusOne</code>并且传入一个整型使其和<code>1</code>相加。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plusOne(<span class="number">10</span>)</span><br><span class="line"><span class="comment">// 返回值为11</span></span><br></pre></td></tr></table></figure>
<p><a name="throwing_functions_and_methods"></a></p>
<p>###抛出异常函数和抛出异常方法(Throwing Functions and Methods)</p>
<p>可以抛出一个错误的函数或方法必需使用<code>throws</code>关键字标记。这些函数和方法被称为<em>抛出异常函数(throwing functions)</em>和<em>抛出异常方法(throwing methods)</em>。它们有着下面的形式:</p>
<blockquote>
<p>   func <code>function name</code>(<code>parameters</code>) throws -&gt;<br>       <code>return type</code>    {<br>           <code>statements</code><br>       }</p>
</blockquote>
<p>调用一个抛出异常函数或抛出异常方法必需用一个<code>try</code>或者<code>try!</code>表达式来封装（也就是说，在一个范围内使用一个<code>try</code>或者<code>try!</code>运算符）。</p>
<p><code>throws</code>关键字是函数的类型的一部分，不抛出异常的函数是抛出异常函数的一个子类型。所以，可以在使用抛出异常函数的地方使用不抛出异常函数。对于柯里化函数，<code>throws</code>关键字仅运用于最内层的函数。</p>
<p>不能重写一个仅基于是否能抛出错误的函数。也就是说，可以重载一个基于函数<em>参数(parameter)</em>能否抛出一个错误的函数。</p>
<p>一个抛出异常的方法不能重写一个不能抛出异常的方法，而且一个异常抛出方法不能满足一个协议对于不抛出异常方法的需求。也就是说，一个不抛出异常的方法可以重写一个抛出异常的方法，而且一个不抛出异常的方法可以满足一个协议对于抛出异常的需求。</p>
<p><a name="rethrowing_functions_and_methods"></a></p>
<p>###重抛出异常函数和重抛出异常方法(Rethrowing Functions and Methods)</p>
<p>一个函数或方法可以使用<code>rethrows</code>关键字来声明，从而表明仅当这个函数或方法的一个函数参数抛出错误时这个函数或方法才抛出错误。这些函数和方法被称为<em>重抛出异常函数(rethrowing functions)</em>和<em>重抛出异常方法(rethrowing methods)</em>。重抛出异常函数或方法必需有至少一个抛出异常函数参数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">functionWithCallback</span><span class="params">(callback: <span class="params">()</span></span></span> throws -&gt; <span class="type">Int</span>) rethrows &#123;</span><br><span class="line">	try callback()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个抛出异常函数方法不能重写一个重抛出异常函数方法，一个抛出异常方法不能满足一个协议对于重抛出异常方法的需求。也就是说，一个重抛出异常方法可以重写一个抛出异常方法，而且一个重抛出异常方法可以满足一个协议对于抛出异常方法的需求。</p>
<p><a name="grammer_of_a_function_declaration"></a></p>
<blockquote>
<p>函数声明语法<br><em>函数声明</em> → <a href="../chapter3/05_Declarations.html#function_head"><em>函数头</em></a> <a href="../chapter3/05_Declarations.html#function_name"><em>函数名</em></a> <a href="GenericParametersAndArguments.html#generic_parameter_clause"><em>泛型参数子句</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#function_signature"><em>函数签名(Signature)</em></a> <a href="../chapter3/05_Declarations.html#function_body"><em>函数体</em></a><br><em>函数头</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>特性(Attributes)列表</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#declaration_specifiers"><em>声明修饰符(Specifiers)列表</em></a> <em>可选</em> <strong>func</strong><br><em>函数名</em> → <a href="LexicalStructure.html#identifier"><em>标识符</em></a> | <a href="LexicalStructure.html#operator"><em>运算符</em></a><br><em>函数签名(signature)</em> → <a href="../chapter3/05_Declarations.html#parameter_clauses"><em>parameter-clauses</em></a> <strong>throws</strong> <a href="../chapter3/05_Declarations.html#function_result"><em>函数结果</em></a> <em>可选</em><br><em>函数签名(signature)</em> → <a href="../chapter3/05_Declarations.html#parameter_clauses"><em>parameter-clauses</em></a> <strong>rethrows</strong> <a href="../chapter3/05_Declarations.html#function_result"><em>函数结果</em></a> <em>可选</em><br><em>函数结果</em> → <strong>-&gt;</strong> <a href="../chapter3/06_Attributes.html#attributes"><em>特性(Attributes)列表</em></a> <em>可选</em> <a href="../chapter3/03_Types.html#type"><em>类型</em></a><br><em>函数体</em> → <a href="../chapter3/05_Declarations.html#code_block"><em>代码块</em></a><br><em>parameter-clauses</em> → <a href="../chapter3/05_Declarations.html#parameter_clause"><em>参数子句</em></a> <a href="../chapter3/05_Declarations.html#parameter_clauses"><em>parameter-clauses</em></a> <em>可选</em><br><em>参数子句</em> → <strong>(</strong> <strong>)</strong> | <strong>(</strong> <a href="../chapter3/05_Declarations.html#parameter_list"><em>参数列表</em></a> <strong>…</strong> <em>可选</em> <strong>)</strong><br><em>参数列表</em> → <a href="../chapter3/05_Declarations.html#parameter"><em>参数</em></a> | <a href="../chapter3/05_Declarations.html#parameter"><em>参数</em></a> <strong>,</strong> <a href="../chapter3/05_Declarations.html#parameter_list"><em>参数列表</em></a><br><em>参数</em> → <strong>inout</strong> <em>可选</em> <strong>let</strong> <em>可选</em> <a href="../chapter3/05_Declarations.html#parameter_name"><em>外部参数名</em></a><em>可选</em> <a href="../chapter3/05_Declarations.html#local_parameter_name"><em>内部参数名</em></a> <a href="../chapter3/03_Types.html#type_annotation"><em>类型标注</em></a> <a href="../chapter3/05_Declarations.html#default_argument_clause"><em>默认参数子句</em></a> <em>可选</em><br><em>参数</em> → <strong>inout</strong> <em>可选</em> <strong>var</strong> <a href="../chapter3/05_Declarations.html#parameter_name"><em>外部参数名</em></a> <a href="../chapter3/05_Declarations.html#local_parameter_name"><em>内部参数名</em></a> <a href="../chapter3/03_Types.html#type_annotation"><em>类型标注</em></a> <a href="../chapter3/05_Declarations.html#default_argument_clause"><em>默认参数子句</em></a> <em>可选</em><br><em>参数</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>特性(Attributes)列表</em></a> <em>可选</em> <a href="../chapter3/03_Types.html#type"><em>类型</em></a><br><em>参数名</em> → <a href="LexicalStructure.html#identifier"><em>标识符</em></a> | <strong>_</strong><br><em>内部参数名</em> → <a href="LexicalStructure.html#identifier"><em>标识符</em></a> | <strong>_</strong><br><em>默认参数子句</em> → <strong>=</strong> <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a>  </p>
</blockquote>
<p><a name="enumeration_declaration"></a></p>
<p>##枚举声明</p>
<p>在程序里使用<em>枚举声明(enumeration)</em>来引入一个枚举类型。</p>
<p>枚举声明有两种基本的形式，使用关键字<code>enum</code>来声明。枚举声明体使用从零开始的变量——叫做<em>枚举用例(enumeration cases)</em>，和任意数量的声明，包括计算型属性，实例方法，类型方法，构造器，类型别名，甚至其他枚举，结构体，和类。枚举声明不能包含析构器或者协议声明。</p>
<p>枚举类型可以采用任何数量的协议，但是这些协议不能从类，结构体和其他的枚举继承。</p>
<p>不像类或者结构体。枚举类型并不提供隐式的初始构造器，所有构造器必须显式的声明。构造器可以委托枚举中的其他构造器，但是构造过程仅当构造器将一个枚举用例指定给<code>self</code>才全部完成。</p>
<p>和结构体类似但是和类不同，枚举是值类型：枚举实例在赋予变量或常量时，或者被函数调用时被复制。<br>更多关于值类型的信息，参见结构体和枚举都是<a href="../chapter2/09_Classes_and_Structures.html#structures_and_enumerations_are_value_types">值类型(Structures and Enumerations Are Value Types)</a>一节。</p>
<p>可以扩展枚举类型，正如在<a href="./05_Declarations.html#extension_declaration">扩展声明(Extension Declaration)</a>中讨论的一样。</p>
<p><a name="enumerations_with_cases_of_any_type"></a></p>
<p>###任意用例类型的枚举</p>
<p>如下的形式声明了一个包含任意类型枚举用例的枚举变量</p>
<blockquote>
<p>enum <code>enumeration name</code>: <code>adopted protocols</code>{<br>    case <code>enumeration case 1</code><br>    case <code>enumeration case 2</code>(<code>associated value types</code>)<br>}  </p>
</blockquote>
<p>这种形式的枚举声明在其他语言中有时被叫做<em>可识别联合(discrinminated)</em>。</p>
<p>这种形式中，每一个用例块由关键字<code>case</code>开始，后面紧接着一个或多个以逗号分隔的枚举用例。每一个用例名必须是独一无二的。每一个用例也可以指定它所存储的指定类型的值，这些类型在<em>关联值类型(associated values types)</em>的元组里被指定，立即书写在用例名后。</p>
<p>枚举用例也可以指定函数作为其存储的值，从而通过特定的关联值创建一个枚举实例。和真正的函数一样，你可以获取一个枚举用例的引用，然后在后续代码中调用它。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Integer</span>(<span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Real</span>(<span class="type">Double</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="type">Number</span>.<span class="type">Integer</span></span><br><span class="line"><span class="comment">// f is a function of type (Int) -&gt; Number</span></span><br><span class="line"><span class="comment">// f 是一个传入 Int 返回 Number 类型的函数</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Apply f to create an array of Number instances with integer values</span></span><br><span class="line"><span class="comment">// 利用函数 f 把一个整数数组转成 Number 数组</span></span><br><span class="line"><span class="keyword">let</span> evenInts: [<span class="type">Number</span>] = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>].<span class="built_in">map</span>(f)</span><br></pre></td></tr></table></figure>
<p>获得更多关于关联值类型的信息和例子，请查看<a href="../chapter2/08_Enumerations.html#associated_values">关联值(Associated Values)</a>一节。</p>
<p><a name="enumerations_with_indirection"></a></p>
<h3 id="间接的枚举">间接的枚举</h3><p>枚举有一个递归结构，就是说，枚举有着枚举类型自身实例的关联值的用例。然而，枚举类型的实例有值语义，意味着它们在内存中有着固定的位置。为了支持递归，编译器必需插入一个间接层。</p>
<p>为间接使用特殊的枚举用例，使用<code>indirect</code>声明修饰符标记。</p>
<blockquote>
<p>enum Tree&lt;T&gt; {<br>        case Empty<br>        indirect case Node(value: T, left: Tree, right:Tree)<br>}</p>
</blockquote>
<p>为了间接的使用一个枚举的所有用例，使用<code>indirect</code>修饰符标记整个枚举-当枚举有许多用例且每个用例都需要使用<code>indirect</code>修饰符标记的时候这将非常便利。</p>
<p>一个被<code>indirect</code>修饰符标记的枚举用例必需有一个关联值。一个使用<code>indirect</code>修饰符标记的枚举包含有着关联值的用例和没有关联值的用例的混合。就是说，它不能包含任何也使用<code>indirect</code>修饰符标记的用例。</p>
<p><a name="enumerations_with_cases_of_a_raw-value_type"></a></p>
<p>###使用原始值类型用例的枚举(Enumerations with Cases of a Raw-Value Type)</p>
<p>以下的形式声明了一个包含相同基础类型的枚举用例的枚举：</p>
<blockquote>
<pre><code><span class="class"><span class="keyword">enum</span> `<span class="title">enumeration</span> <span class="title">name</span>`: `<span class="title">raw</span> <span class="title">value</span> <span class="title">type</span>`, `<span class="title">adopted</span> <span class="title">protocols</span>`{  </span>
   <span class="keyword">case</span> <span class="string">`enumeration case 1`</span> = <span class="string">`raw value 1`</span>  
   <span class="keyword">case</span> <span class="string">`enumeration case 2`</span> = <span class="string">`raw value 2`</span>  
</code></pre><p>}  </p>
</blockquote>
<p>在这种形式中，每一个用例块由<code>case</code>关键字开始，后面紧接着一个或多个以逗号分隔的枚举用例。和第一种形式的枚举用例不同，这种形式的枚举用例包含一个同类型的基础值，叫做<em>原始值(raw value)</em>。这些值的类型在<em>原始值类型(raw-value type)</em>中被指定，必须表示一个整数，浮点数，字符串，或者一个字符。特别是<em>原始值类型(raw-value type)</em>必需遵守<code>Equatable</code>类型的协议和下列形式中的一种字面量构造协议(literal-convertible protocols):整型字面量有<code>IntergerLiteralConvertible</code>，浮点行字面量有<code>FloatingPointLiteralConvertible</code>，包含任意数量字符的字符串型字面量有<code>StringLiteralConvertible</code>，仅包含一个单一字符的字符串型字面量有<code>ExtendedGraphemeClusterLiteralConvertible</code>。每一个用例必须有唯一的名字，必须有一个唯一的初始值。</p>
<p>如果初始值类型被指定为<code>Int</code>，则不必为用例显式的指定值，它们会隐式的被标为值<code>0,1,2</code>等。每一个没有被赋值的<code>Int</code>类型时间会隐式的赋予一个初始值，它们是自动递增的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num <span class="type">ExampleEnum</span>: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">A</span>, <span class="type">B</span>, <span class="type">C</span> = <span class="number">5</span>, <span class="type">D</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>ExampleEnum.A</code>的值是<code>0</code>，<code>ExampleEnum.B</code>的值是<code>1</code>。因为<code>ExampleEnum.C</code>的值被显式的设定为<code>5</code>，因此<code>ExampleEnum.D</code>的值会自动增长为<code>6</code>。</p>
<p>如果原始值类型被指定为<code>String</code>类型，你不用明确的为用例指定值，每一个没有指定的用例会隐式地用与用例名字相同的字符串指定。</p>
<blockquote>
<p>enum WeekendDay: String {<br>        case Saturday, Sunday<br>}</p>
</blockquote>
<p>在上面这个例子中，<code>WeekendDay.Saturday</code>的原始值是<code>&quot;Saturday&quot;</code>,<code>WeekendDay.Sunday</code>的原始值是<code>&quot;Sunday&quot;</code>。</p>
<p>拥有多种用例的原始值类型的枚举含蓄地遵循定义在Swift标准库中的<code>RawRepresentable</code>协议。所以，它们拥有一个原始值(<code>rawValue</code>)属性和一个有着<code>init?(rawValue: RawValue)</code>签名的可失败构造器(a failable initializer)。可以使用原始值属性去取的枚举用例的原始值，就像在<code>ExampleEnum.B.rawValue</code>中一样。如果有一个用例符合，也可以使用原始值去找到一个符合的用例，通过调用枚举的可失败构造器，如<code>ExampleEnum(rawValue: 5)</code>,这个可失败构造器返回一个可选的用例。想得到更多的信息和关于原始值类型查看更多信息和获取初始值类型用例的信息，参阅初始值<a href="../chapter2/08_Enumerations.html#raw_values">原始值(Raw Values)</a>。</p>
<p><a name="accessing_enumeration_cases"></a></p>
<p>###获得枚举用例</p>
<p>使用点(.)来引用枚举类型的用例，如<code>EnumerationType.EnumerationCase</code>。当枚举类型可以上下文推断出时，可以省略它(.仍然需要)，参照枚举语法<a href="../chapter2/08_Enumerations.html#enumeration_syntax">(Enumeration Syntax)</a>和<a href="./04_Expressions.html#primary_expressions">显式成员表达(Implicit Member Expression)</a>。</p>
<p>使用<code>switch</code>语句来检验枚举用例的值，正如使用<a href="../chapter2/08_Enumerations.html#matching_enumeration_values_with_a_switch_statement">switch语句匹配枚举值（Matching Enumeration Values with a Switch Statement)</a>一节描述的那样。枚举类型是模式匹配(pattern-matched)的，和其相反的是<code>switch</code>语句case块中枚举用例匹配，在<a href="./07_Patterns.html#enumeration_case_pattern">枚举用例类型(Enumeration Case Pattern)</a>中有描述。</p>
<p><a name="grammer_of_an_enumeration_declaration"></a></p>
<blockquote>
<p>枚举声明语法<br><em>枚举声明</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>特性(Attributes)列表</em></a> <em>可选</em> <a href="TODO"><em>访问级别修饰符</em></a> <em>可选</em> <a href="TODO"><em>联合式枚举</em></a><br><em>枚举声明</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>特性(Attributes)列表</em></a> <em>可选</em> <a href="TODO"><em>访问级别修饰符</em></a>  <em>可选</em> <a href="../chapter3/05_Declarations.html#raw_value_style_enum"><em>原始值式枚举</em></a><br><em>联合式枚举</em> → <strong>indirect</strong> <em>可选</em> <strong>enum</strong> <a href="../chapter3/05_Declarations.html#enum_name"><em>枚举名</em></a> <a href="GenericParametersAndArguments.html#generic_parameter_clause"><em>泛型参数子句</em></a> <em>可选</em> <a href="TODO">类型继承子句</a><em>可选</em> <strong>{</strong> <a href="../chapter3/05_Declarations.html#union_style_enum_members"><em>union-style-enum-members</em></a> <em>可选</em> <strong>}</strong><br><em>union-style-enum-members</em> → <a href="../chapter3/05_Declarations.html#union_style_enum_member"><em>union-style-enum-member</em></a> <a href="../chapter3/05_Declarations.html#union_style_enum_members"><em>union-style-enum-members</em></a> <em>可选</em><br><em>union-style-enum-member</em> → <a href="../chapter3/05_Declarations.html#declaration"><em>声明</em></a> | <a href="../chapter3/05_Declarations.html#union_style_enum_case_clause"><em>联合式(Union Style)的枚举case子句</em></a><br><em>联合式(Union Style)的枚举case子句</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>特性(Attributes)列表</em></a> <em>可选</em> <strong>indirect</strong> <em>可选</em> <strong>case</strong> <a href="../chapter3/05_Declarations.html#union_style_enum_case_list"><em>联合式(Union Style)的枚举case列表</em></a><br><em>联合式(Union Style)的枚举case列表</em> → <a href="../chapter3/05_Declarations.html#union_style_enum_case"><em>联合式(Union Style)的case</em></a> | <a href="../chapter3/05_Declarations.html#union_style_enum_case"><em>联合式(Union Style)的case</em></a> <strong>,</strong> <a href="../chapter3/05_Declarations.html#union_style_enum_case_list"><em>联合式(Union Style)的枚举case列表</em></a><br><em>联合式(Union Style)的case</em> → <a href="../chapter3/05_Declarations.html#enum_case_name"><em>枚举的case名</em></a> <a href="../chapter3/03_Types.html#tuple_type"><em>元组类型</em></a> <em>可选</em><br><em>枚举名</em> → <a href="LexicalStructure.html#identifier"><em>标识符</em></a><br><em>枚举的case名</em> → <a href="LexicalStructure.html#identifier"><em>标识符</em></a><br><em>原始值式枚举</em> → <strong>enum</strong> <a href="../chapter3/05_Declarations.html#enum_name"><em>枚举名</em></a> <a href="GenericParametersAndArguments.html#generic_parameter_clause"><em>泛型参数子句</em></a> <em>可选</em> <a href="TODO"><em>类型继承子句</em></a> <strong>{</strong> <a href="../chapter3/05_Declarations.html#raw_value_style_enum_members"><em>原始值式枚举成员列表</em></a> <strong>}</strong><br><em>原始值式枚举成员列表</em> → <a href="../chapter3/05_Declarations.html#raw_value_style_enum_member"><em>原始值式枚举成员</em></a> <a href="../chapter3/05_Declarations.html#raw_value_style_enum_members"><em>原始值式枚举成员列表</em></a> <em>可选</em><br><em>原始值式枚举成员</em> → <a href="../chapter3/05_Declarations.html#declaration"><em>声明</em></a> | <a href="../chapter3/05_Declarations.html#raw_value_style_enum_case_clause"><em>原始值式枚举case子句</em></a><br><em>原始值式枚举case子句</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>特性(Attributes)列表</em></a> <em>可选</em> <strong>case</strong> <a href="../chapter3/05_Declarations.html#raw_value_style_enum_case_list"><em>原始值式枚举case列表</em></a><br><em>原始值式枚举case列表</em> → <a href="../chapter3/05_Declarations.html#raw_value_style_enum_case"><em>原始值式枚举case</em></a> | <a href="../chapter3/05_Declarations.html#raw_value_style_enum_case"><em>原始值式枚举case</em></a> <strong>,</strong> <a href="../chapter3/05_Declarations.html#raw_value_style_enum_case_list"><em>原始值式枚举case列表</em></a><br><em>原始值式枚举case</em> → <a href="../chapter3/05_Declarations.html#enum_case_name"><em>枚举的case名</em></a> <a href="../chapter3/05_Declarations.html#raw_value_assignment"><em>原始值赋值</em></a> <em>可选</em><br><em>原始值赋值</em> → <strong>=</strong> <a href="TODO"><em>原始值字面量</em></a><br><em>原始值字面量</em> → <a href="TODO">数字型字面量</a>|<a href="TODO">字符串型字面量</a>|<a href="TODO">布尔型字面量</a></p>
</blockquote>
<p><a name="structure_declaration"></a></p>
<p>##结构体声明</p>
<p>使用<em>结构体声明(strucre declaration)</em>可以在程序里引入一个结构体类型。结构体声明使用<code>struct</code>关键字，遵循如下的形式：</p>
<blockquote>
<p>struct <code>structure name</code>: <code>adopted protocols</code> {<br>    <code>declarations</code><br>}  </p>
</blockquote>
<p>结构体内包含零或多个声明<em>声明(declarations)</em>。这些<em>声明(declarations)</em>可以包括存储型和计算型属性，类型属性，实例方法，类型方法，构造器，下标脚本，类型别名，甚至其他结构体，类，和枚举声明。结构体声明不能包含析构器或者协议声明。详细讨论和包含多种结构体声明的实例，参见<a href="../chapter2/09_Classes_and_Structures.html">类和结构体(Classes and Structures)</a>一节。</p>
<p>结构体可以包含任意数量的协议，但是不能继承自类，枚举或者其他结构体。</p>
<p>有三种方法可以创建一个声明过的结构体实例：</p>
<ul>
<li><p>调用结构体内声明的构造器，参照<a href="../chapter2/14_Initialization.html#setting_initial_values_for_stored_properties">构造器(Initializers)</a>一节。</p>
</li>
<li><p>如果没有声明构造器，调用结构体的逐个构造器，详情参见<a href="../chapter2/14_Initialization.html#memberwise_initializers_for_structure_types">Memberwise Initializers for Structure Types</a>。</p>
</li>
<li><p>如果没有声明析构器，结构体的所有属性都有初始值，调用结构体的默认构造器，详情参见<a href="../chapter2/14_Initialization.html#default_initializers">默认构造器(Default Initializers)</a>。</p>
</li>
</ul>
<p>结构体的构造过程参见<a href="../chapter2/14_Initialization.html">构造过程(Initiaization)</a>一节。</p>
<p>结构体实例属性可以用点(.)来获得，详情参见<a href="../chapter2/09_Classes_and_Structures.html#comparing_classes_and_structures">属性访问(Accessing Properties)</a>一节。</p>
<p>结构体是值类型；结构体的实例在被赋予变量或常量，被函数调用时被复制。获得关于值类型更多信息，参见<br><a href="../chapter2/09_Classes_and_Structures.html#structures_and_enumerations_are_value_types">结构体和枚举是值类型(Structures and Enumerations Are Value Types)</a>一节。</p>
<p>可以使用扩展声明来扩展结构体类型的行为，参见<a href="../chapter3/05_Declarations.html#extension_declaration">扩展声明(Extension Declaration)</a>。</p>
<p><a name="grammer_of_a_structure_declaration"></a></p>
<blockquote>
<p>结构体声明语法<br><em>结构体声明</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>特性(Attributes)列表</em></a> <em>可选</em> <a href="TODO">访问级别修饰符</a><em>可选</em> <strong>struct</strong> <a href="../chapter3/05_Declarations.html#struct_name"><em>结构体名称</em></a> <a href="GenericParametersAndArguments.html#generic_parameter_clause"><em>泛型参数子句</em></a> <em>可选</em> <a href="../chapter3/03_Types.html#type_inheritance_clause"><em>类型继承子句</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#struct_body"><em>结构体主体</em></a><br><em>结构体名称</em> → <a href="LexicalStructure.html#identifier"><em>标识符</em></a><br><em>结构体主体</em> → <strong>{</strong> <a href="../chapter3/05_Declarations.html#declarations"><em>声明(Declarations)列表</em></a> <em>可选</em> <strong>}</strong>  </p>
</blockquote>
<p><a name="class_declaration"></a></p>
<p>##类声明</p>
<p>可以在程序中使用<em>类声明(class declaration)</em>来引入一个类。类声明使用关键字<code>class</code>，遵循如下的形式：</p>
<blockquote>
<p>class <code>class name</code>: <code>superclass</code>, <code>adopted protocols</code> {<br>    <code>declarations</code><br>}  </p>
</blockquote>
<p>一个类内包含零或多个<em>声明(declarations)</em>。这些<em>声明(declarations)</em>可以包括存储型和计算型属性，实例方法，类型方法，构造器，单独的析构器，下标脚本，类型别名，甚至其他结构体，类，和枚举声明。类声明不能包含协议声明。详细讨论和包含多种类声明的实例，参见<a href="../chapter2/09_Classes_and_Structures.html">类和结构体(Classes and Structures)</a>一节。</p>
<p>一个类只能继承一个父类，<em>超类(superclass)</em>，但是可以包含任意数量的协议。<em>超类(superclass)</em>第一次出现在<em>类名(class name)</em>和冒号后面，其后跟着<em>采用的协议(adopted protocols)</em>。泛型类可以继承其它类型类和非泛型类，但是非泛型类只能继承其它的非泛型类。当在冒号后面写泛型超类的名称时，必须写那个泛型类的全名，包括它的泛型参数子句。</p>
<p>正如在<a href="./chapter3/05_Declarations.html#initializer_declaration">初始化声明(Initializer Declaration)</a>谈及的那样，类可以有指定构造器和方便构造器。类的指定构造器必须初始化类所有的已声明的属性，它必须在超类构造器调用前被执行。</p>
<p>类可以重写属性，方法，下表脚本和它的超类构造器。重写的属性，方法，下标脚本，和指定构造器必须以<code>override</code>声明修饰符标记。</p>
<p>为了要求子类去实现超类的构造器，使用<code>required</code>声明修饰符去标记超类的构造器。在子类实现父类构造器时也必须使用<code>required</code>声明修饰符去标记。</p>
<p>虽然<em>超类(superclass)</em>的属性和方法声明可以被当前类继承，但是<em>超类(superclass)</em>声明的指定构造器却不能。这意味着，如果当前类重写了超类的所有指定构造器，它就继承了超类的方便构造器。Swift的类并不是继承自一个全局基础类。</p>
<p>有两种方法来创建已声明的类的实例：</p>
<ul>
<li><p>调用类的一个构造器，参见<a href="../chapter2/14_Initialization.html">构造器(Initializers)</a>。</p>
</li>
<li><p>如果没有声明构造器，而且类的所有属性都被赋予了初始值，调用类的默认构造器，参见<a href="../chapter2/14_Initialization.html#default_initializers">默认构造器(Default Initializers)</a>。</p>
</li>
</ul>
<p>类实例属性可以用点(.)来获得，详情参见<a href="../chapter2/09_Classes_and_Structures.html#comparing_classes_and_structures">属性访问(Accessing Properties)</a>一节。</p>
<p>类是引用类型；当被赋予常量或变量，函数调用时，类的实例是被引用，而不是复制。获得更多关于引用类型的信息，<a href="../chapter2/09_Classes_and_Structures.html#structures_and_enumerations_are_value_types">结构体和枚举都是值类型(Structures and Enumerations Are Value Types)</a>一节。</p>
<p>可以使用扩展声明来扩展类的行为，参见<a href="./05_Declarations.html#extension_declaration">扩展声明(Extension Declaration)</a>。</p>
<p><a name="grammer_of_a_class_declaration"></a></p>
<blockquote>
<p>类声明语法<br><em>类声明</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>特性(Attributes)列表</em></a> <em>可选</em> <a href="TODO">访问级别修饰符</a><strong>class</strong> <a href="../chapter3/05_Declarations.html#class_name"><em>类名</em></a> <a href="GenericParametersAndArguments.html#generic_parameter_clause"><em>泛型参数子句</em></a> <em>可选</em> <a href="../chapter3/03_Types.html#type_inheritance_clause"><em>类型继承子句</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#class_body"><em>类主体</em></a><br><em>类名</em> → <a href="LexicalStructure.html#identifier"><em>标识符</em></a><br><em>类主体</em> → <strong>{</strong> <a href="../chapter3/05_Declarations.html#declarations"><em>声明(Declarations)列表</em></a> <em>可选</em> <strong>}</strong>  </p>
</blockquote>
<p><a name="protocol_declaration"></a></p>
<p>##协议声明(translated by 小一)</p>
<p>一个<em>协议声明(protocol declaration)</em>为程序引入一个命名了的协议类型。协议声明在一个全局访问的区域使用 <code>protocol</code> 关键词来进行声明并有下面这样的形式：</p>
<blockquote>
<p>protocol <code>protocol name</code>: <code>inherited protocols</code> {<br>    <code>protocol member declarations</code><br>}  </p>
</blockquote>
<p>协议的主体包含零或多个<em>协议成员声明(protocol member declarations)</em>，这些成员描述了任何采用该协议必须满足的一致性要求。特别的，一个协议可以声明必须实现某些属性、方法、初始化程序及下标脚本的一致性类型。协议也可以声明专用种类的类型别名，叫做<em>关联类型(associated types)</em>，它可以指定协议的不同声明之间的关系。协议声明不包括类，结构体，枚举或者其它协议的声明。协议成员声明会在下面的详情里进行讨论。</p>
<p>协议类型可以从很多其它协议那继承。当一个协议类型从其它协议那继承的时候，来自其它协议的所有要求就集合了，而且从当前协议继承的任何类型必须符合所有的这些要求。对于如何使用协议继承的例子，查看<a href="../chapter2/21_Protocols.html#protocol_inheritance">协议继承(Protocol Inheritance)</a></p>
<blockquote>
<p>注意：<br>也可以使用协议合成类型集合多个协议的一致性要求，详情参见<a href="../chapter3/03_Types.html#protocol_composition_type">协议合成类型(Protocol Composition Type)</a>和<a href="../chapter2/21_Protocols.html#protocol_composition">协议合成(Protocol Composition)</a></p>
</blockquote>
<p>可以通过采用在类型的扩展声明中的协议来为之前声明的类型添加协议一致性。在扩展中必须实现所有采用协议的要求。如果该类型已经实现了所有的要求，可以让这个扩展声明的主题留空。</p>
<p>默认地，符合某一个协议的类型必须实现所有声明在协议中的属性、方法和下标脚本。也就是说，可以用<code>optional</code>声明修饰符标注这些协议成员声明以指定它们的一致性类型实现是可选的。<code>optional</code>修饰符仅仅可以用于使用<code>objc</code>属性标记过的协议。这样的结果就是仅仅类类型可以采用并符合包含可选成员要求的协议。更多关于如何使用<code>optional</code>属性的信息及如何访问可选协议成员的指导——比如当不能肯定是否一致性的类型实现了它们——参见<a href="../chapter2/21_Protocols.html#optional_protocol_requirements">可选协议要求(Optional Protocol Requirements)</a></p>
<p>为了限制协议的采用仅仅针对类类型，需要强制使用<code>class</code>来标记协议，通过将<code>class</code>关键在写在冒号后面的<em>继承协议列表(inherited protocols)</em>的第一个位置。例如，下面的协议形式只能被类类型采用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeProtocol</span>:<span class="title">class</span></span>&#123;</span><br><span class="line">	<span class="comment">/* Protocol member go here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任意继承自需要标记有<code>class</code>协议的协议都可以智能地仅能被类类型采用。</p>
<blockquote>
<p>注意：<br>如果协议已经用<code>object</code>属性标记了，<code>class</code>条件就隐性地应用于该协议；没有必要再明确地使用<code>class</code>条件来标记该协议了。</p>
</blockquote>
<p>协议是命名的类型，因此它们可以以另一个命名类型出现在代码的所有地方，就像<a href="../chapter2/21_Protocols.html#protocols_as_types">协议类型(Protocol as Types)</a>里讨论的那样。然而不能构造一个协议的实例，因为协议实际上不提供它们指定的要求的实现。</p>
<p>可以使用协议来声明一个类的代理的方法或者应该实现的结构，就像<a href="../chapter2/21_Protocols.html#delegation">委托(代理)模式(Delegation)</a>描述的那样。</p>
<p><a name="grammer_of_a_protocol_declaration"></a></p>
<blockquote>
<p>协议(Protocol)声明语法<br><em>协议声明</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>特性(Attributes)列表</em></a> <em>可选</em> <a href="TODO"><em>访问级别修饰符</em></a> <em>可选</em> <strong>protocol</strong> <a href="../chapter3/05_Declarations.html#protocol_name"><em>协议名</em></a> <a href="../chapter3/03_Types.html#type_inheritance_clause"><em>类型继承子句</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#protocol_body"><em>协议主体</em></a><br><em>协议名</em> → <a href="LexicalStructure.html#identifier"><em>标识符</em></a><br><em>协议主体</em> → <strong>{</strong> <a href="../chapter3/05_Declarations.html#protocol_member_declarations"><em>协议成员声明(Declarations)列表</em></a> <em>可选</em> <strong>}</strong><br><em>协议成员声明</em> → <a href="../chapter3/05_Declarations.html#protocol_property_declaration"><em>协议属性声明</em></a><br><em>协议成员声明</em> → <a href="../chapter3/05_Declarations.html#protocol_method_declaration"><em>协议方法声明</em></a><br><em>协议成员声明</em> → <a href="../chapter3/05_Declarations.html#protocol_initializer_declaration"><em>协议构造器声明</em></a><br><em>协议成员声明</em> → <a href="../chapter3/05_Declarations.html#protocol_subscript_declaration"><em>协议附属脚本声明</em></a><br><em>协议成员声明</em> → <a href="../chapter3/05_Declarations.html#protocol_associated_type_declaration"><em>协议关联类型声明</em></a><br><em>协议成员声明(Declarations)列表</em> → <a href="../chapter3/05_Declarations.html#protocol_member_declaration"><em>协议成员声明</em></a> <a href="../chapter3/05_Declarations.html#protocol_member_declarations"><em>协议成员声明(Declarations)列表</em></a> <em>可选</em>  </p>
</blockquote>
<p><a name="protocol_property_declaration"></a></p>
<p>###协议属性声明</p>
<p>协议声明了一致性类型必须在协议声明的主体里通过引入一个<em>协议属性声明(protocol property declaraion)</em>来实现一个属性。协议属性声明有一种特殊的类型声明形式：</p>
<blockquote>
<p>var <code>property name</code>: <code>type</code> { get set }</p>
</blockquote>
<p>同其它协议成员声明一样，这些属性声明仅仅针对符合该协议的类型声明了<code>getter</code>和<code>setter</code>要求。结果就是不需要在协议里它被声明的地方实现<code>getter</code>和<code>setter</code>。</p>
<p><code>getter</code>和<code>setter</code>要求可以通过一致性类型以各种方式满足。如果属性声明包含<code>get</code>和<code>set</code>关键词，一致性类型就可以用可读写（实现了<code>getter</code>和<code>setter</code>）的存储型变量属性或计算型属性，但是属性不能以常量属性或只读计算型属性实现。如果属性声明仅仅包含<code>get</code>关键词的话，它可以作为任意类型的属性被实现。比如说实现了协议的属性要求的一致性类型，参见<a href="../chapter2/21_Protocols.html#property_requirements">属性要求(Property Requirements)</a></p>
<p>更多参见<a href="../chapter3/05_Declarations.html#variable_declaration">变量声明(Variabel Declaration)</a></p>
<p><a name="grammer_of_an_import_declaration"></a></p>
<blockquote>
<p>协议属性声明语法<br><em>协议属性声明</em> → <a href="../chapter3/05_Declarations.html#variable_declaration_head"><em>变量声明头(Head)</em></a> <a href="../chapter3/05_Declarations.html#variable_name"><em>变量名</em></a> <a href="../chapter3/03_Types.html#type_annotation"><em>类型标注</em></a> <a href="../chapter3/05_Declarations.html#getter_setter_keyword_block"><em>getter-setter关键字(Keyword)块</em></a>  </p>
</blockquote>
<p><a name="protocol_method_declaration"></a></p>
<p>###协议方法声明</p>
<p>协议声明了一致性类型必须在协议声明的主体里通过引入一个协议方法声明来实现一个方法。协议方法声明和函数方法声明有着相同的形式，包含如下两条规则：它们不包括函数体，不能在类的声明内为它们的参数提供初始值.举例来说，符合的类型执行协议必需的方法。参见<a href="../chapter2/22_Protocols.html#method_requirements">必需方法(Method Requirements)</a>一节。</p>
<p>使用<code>static</code>声明修饰符可以在协议声明中声明一个类或必需的静态方法。执行这些方法的类用修饰符<code>class</code>声明。相反的，执行这些方法的结构体必须以<code>static</code>声明修饰符声明。如果想使用扩展方法，在扩展类时使用<code>class</code>修饰符，在扩展结构体时使用<code>static</code>修饰符。</p>
<p>更多请参阅<a href="../chapter3/05_Declarations.html#function_declaration">函数声明(Function Declaration)</a>。</p>
<p><a name="grammer_of_a_protocol_declaration"></a></p>
<blockquote>
<p>协议方法声明语法<br><em>协议方法声明</em> → <a href="../chapter3/05_Declarations.html#function_head"><em>函数头</em></a> <a href="../chapter3/05_Declarations.html#function_name"><em>函数名</em></a> <a href="GenericParametersAndArguments.html#generic_parameter_clause"><em>泛型参数子句</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#function_signature"><em>函数签名(Signature)</em></a>  </p>
</blockquote>
<p><a name="protocol_initializer_declaration"></a></p>
<p>###协议构造器声明</p>
<p>协议声明了一致性类型必须在协议声明的主体里通过引入一个协议构造器声明来实现一个构造器。协议构造器声明<br>除了不包含构造器体外，和构造器声明有着相同的形式。</p>
<p>一个一致性类型可以通过实现一个非可失败构造器或者<code>init!</code>可失败构造器去满足一个非可失败协议构造器的需求。一个一致性类型通过实现任意类型的构造器可以满足一个可失败协议构造器的需求。</p>
<p>当一个类去实现一个构造器去满足一个协议的构造器的需求，如果这个类还没有用<code>final</code>声明修饰符标记，这个构造器必需使用<code>required</code>声明修饰符去标记。</p>
<p>更多请参阅<a href="../chapter3/05_Declarations.html#initializer_declaration">构造器声明(Initializer Declaration)</a>。</p>
<p><a name="grammer_of_a_protocol_initializer_declaration"></a></p>
<blockquote>
<p>协议构造器声明语法<br><em>协议构造器声明</em> → <a href="../chapter3/05_Declarations.html#initializer_head"><em>构造器头(Head)</em></a> <a href="GenericParametersAndArguments.html#generic_parameter_clause"><em>泛型参数子句</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#parameter_clause"><em>参数子句</em></a>  </p>
</blockquote>
<p><a name="protocol_subscript_declaration"></a></p>
<p>###协议下标脚本声明</p>
<p>协议声明了一致性类型必须在协议声明的主体里通过引入一个协议下标脚本声明来实现一个下标脚本。协议下标脚本声明对下标脚本声明有一个特殊的形式：</p>
<blockquote>
<p>subscript (<code>parameters</code>) -&gt; <code>return type</code> { get set }</p>
</blockquote>
<p>下标脚本声明只为和协议一致的类型声明了必需的最小数量的的getter和setter。如果下标脚本申明包含get和set关键字，一致的类型也必须有一个getter和setter语句。如果下标脚本声明值包含get关键字，一致的类型必须<em>至少(at least)</em>包含一个getter语句，可以选择是否包含setter语句。</p>
<p>更多参阅<a href="../chapter3/05_Declarations.html#subscript_declaration">下标脚本声明(Subscript Declaration)</a>。</p>
<p><a name="grammer_of_a_protocol_subscript_declaration"></a></p>
<blockquote>
<p>协议附属脚本声明语法<br><em>协议附属脚本声明</em> → <a href="../chapter3/05_Declarations.html#subscript_head"><em>附属脚本头(Head)</em></a> <a href="../chapter3/05_Declarations.html#subscript_result"><em>附属脚本结果(Result)</em></a> <a href="../chapter3/05_Declarations.html#getter_setter_keyword_block"><em>getter-setter关键字(Keyword)块</em></a>  </p>
</blockquote>
<p><a name="protocol_associated_type_declaration"></a></p>
<p>###协议相关类型声明</p>
<p>协议声明相关类型使用关键字<code>typealias</code>。相关类型为作为协议声明的一部分的类型提供了一个别名。相关类型和参数语句中的类型参数很相似，但是它们在声明的协议中包含<code>self</code>关键字。在这些语句中，<code>self</code>指代和协议一致的可能的类型。获得更多信息和例子，查看<a href="../chapter2/23_Generics.html#associated_types">关联类型(Associated Types)</a>一节或<a href="../chapter3/05_Declarations.html#type_alias_declaration">类型别名声明(Type Alias Declaration)</a>一节。</p>
<p><a name="grammer_of_a_protocol_associated_type_declaration"></a></p>
<blockquote>
<p>协议关联类型声明语法<br><em>协议关联类型声明</em> → <a href="../chapter3/05_Declarations.html#typealias_head"><em>类型别名头(Head)</em></a> <a href="../chapter3/03_Types.html#type_inheritance_clause"><em>类型继承子句</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#typealias_assignment"><em>类型别名赋值</em></a> <em>可选</em>  </p>
</blockquote>
<p><a name="initializer_declaration"></a></p>
<p>##构造器声明</p>
<p><em>构造器(initializer)</em>声明会为程序内的类，结构体或枚举引入构造器。构造器使用关键字<code>init</code>来声明，遵循两条基本形式。</p>
<p>结构体，枚举，类可以有任意数量的构造器，但是类的构造器的规则和行为是不一样的。不像结构体和枚举那样，类有两种结构体，designed initializers 和convenience initializers，参见<a href="../chapter2/14_Initialization.html">构造过程(Initialization)</a>一节。</p>
<p>如下的形式声明了结构体，枚举和类的指定构造器：</p>
<blockquote>
<p>init(<code>parameters</code>) {<br>    <code>statements</code><br>}  </p>
</blockquote>
<p>类的指定构造器将类的所有属性直接初始化。如果类有超类，它不能调用该类的其他构造器,它只能调用超类的一个指定构造器。如果该类从它的超类处继承了任何属性，这些属性在当前类内被赋值或修饰时，必须调用一个超类的指定构造器。</p>
<p>指定构造器可以在类声明的上下文中声明，因此它不能用扩展声明的方法加入一个类中。</p>
<p>结构体和枚举的构造器可以调用其他的已声明的构造器，委托其中一个或所有的构造器进行初始化过程。</p>
<p>以<code>convenience</code>声明修饰符来标记构造器声明来声明一个类的便利构造器：</p>
<blockquote>
<p>convenience init(<code>parameters</code>) {<br>   <code>statements</code><br>}  </p>
</blockquote>
<p>便利构造器可以将初始化过程委托给另一个便利构造器或类的一个指定构造器。这意味着，类的初始化过程必须<br>以一个将所有类属性完全初始化的指定构造器的调用作为结束。便利构造器不能调用超类的构造器。</p>
<p>可以使用required声明修饰符，将便利构造器和指定构造器标记为每个子类的构造器都必须实现的。一个子类的关于这个构造器的实现也必须使用<code>required</code>声明修饰符标记。</p>
<p>默认情况下，声明在超类的构造器没有被子类继承。也就是说，如果一个子类使用默认的值去构造它所有的存储属性，而且没有定义任何自己的构造器，它将继承超类的构造器。如果子类重写所有超类的指定构造器，子类继承超类的便利构造器。</p>
<p>和方法，属性和下表脚本一样，需要使用<code>override</code>声明修饰符标记重写了的制定构造器。</p>
<blockquote>
<p>注意<br>如果使用<code>required</code>声明修饰符去标记一个构造器，当在子类中重写必要构造器时，也不要用<code>override</code>修饰符去标记构造器。</p>
</blockquote>
<p>查看更多关于不同声明方法的构造器的例子，参阅<a href="../chapter2/14_Initialization.html">构造过程(Initialization)</a>一节。</p>
<p><a name="failable_initializers"></a></p>
<p>###可失败构造器(Failable Initializers)</p>
<p><em>可失败构造器</em>是一种可以生成可选实例或者是一类构造器声明的隐式解析可选实例(an implicitly unwrapped optional instance)类型。所以，构造区通过返回<code>nil</code>来指明构造过程失败。</p>
<p>声明可以生成可选实例的可失败构造器，在构造器声明的<code>init</code>关键字后加追加一个问号(<code>init?</code>)。声明可生成隐式解析可选实例的可失败构造器，在构造器声明后追加一个叹号(<code>init!</code>)。使用<code>init?</code>可失败构造器生成结构体的一个可选实例的例子如下。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeStruct</span> </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> string: <span class="type">String</span></span><br><span class="line">	<span class="comment">//生成一个'SomeStruct'的可选实例</span></span><br><span class="line">	<span class="keyword">init</span>?(input: <span class="type">String</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> input.isEmpty &#123;</span><br><span class="line">			<span class="comment">// 弃用'self' 返回 'nil'</span></span><br><span class="line">		&#125;</span><br><span class="line">		string = input</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除非必需处理结果的可选性，可以使用调用非可失败构造器的方式调用<code>init?</code>可失败构造器。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> actualInstance = <span class="type">SomeStruct</span>(input: <span class="string">"Hello"</span>) &#123;</span><br><span class="line">	<span class="comment">//'SomeStruct'实例相关</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">//'SomeStruct'实例构造过程失败，构造器返回'nil'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实现构造体的任何时间，结构体或者枚举的可失败构造器可以返回<code>nil</code>。然而，类的可失败构造器，仅在类的所有存储属性被构造之后且<code>self.init</code>或<code>super.init</code>被调用之后才返回<code>nil</code>（就是说，构造器的委托被执行）。</p>
<p>可失败构造器可以委托任何种类的构造器。非可失败可以委托其它非可失败构造器或者<code>init!</code>可失败构造器。</p>
<p>构造过程的失败由构造器的委托产生。特别的，如果可失败构造器代理一个构造器失败且返回<code>nil</code>，那么之后被委托的构造器也会失败且隐式的返回<code>nil</code>。如果非可失败构造器代理<code>init!</code>可失败构造器失败了且返回<code>nil</code>，那么后出现一个运行时错误（如同使用<code>!</code>操作符去解析一个有着<code>nil</code>值的可选项）。</p>
<p>可失败指定构造器可以在子类中任何一种指定构造器重写。非可失败指定构造器在子类中仅能通过非可失败构造器被重写。</p>
<p>得到更多的信息并且了解更多关于可失败构造器的例子，请参阅<a href="。。/chapter2/14_Initialization.html#failable_initializers">可失败构造器(Failable Initializer)</a></p>
<p><a name="grammer_of_an_initializer_declaration"></a></p>
<blockquote>
<p>构造器声明语法<br><em>构造器声明</em> → <a href="../chapter3/05_Declarations.html#initializer_head"><em>构造器头(Head)</em></a> <a href="GenericParametersAndArguments.html#generic_parameter_clause"><em>泛型参数子句</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#parameter_clause"><em>参数子句</em></a> <a href="../chapter3/05_Declarations.html#initializer_body"><em>构造器主体</em></a><br><em>构造器头(Head)</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>特性(Attributes)列表</em></a> <em>可选</em> <a href="TODO"><em>声明修饰符列表(modifiers)</em></a> <em>可选</em> <strong>init</strong><br><em>构造器头(Head)</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>特性(Attributes)列表</em></a> <em>可选</em> <a href="TODO"><em>声明修饰符列表(modifiers)</em></a> <em>可选</em> <strong>init ?</strong><br><em>构造器头(Head)</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>特性(Attributes)列表</em></a> <em>可选</em> <a href="TODO"><em>声明修饰符列表(modifiers)</em></a> <em>可选</em> <strong>init !</strong><br><em>构造器主体</em> → <a href="../chapter3/05_Declarations.html#code_block"><em>代码块</em></a>  </p>
</blockquote>
<p><a name="deinitializer_declaration"></a></p>
<p>##析构声明</p>
<p><em>析构声明(deinitializer declaration)</em>为类声明了一个析构器。析构器没有参数，遵循如下的格式：</p>
<blockquote>
<p>deinit {<br>   <code>statements</code><br>}  </p>
</blockquote>
<p>当类没有任何语句时将要被释放时，析构器会自动的被调用。析构器在类的声明体内只能被声明一次——但是不能在<br>类的扩展声明内，每个类最多只能有一个。</p>
<p>子类继承了它的超类的析构器，在子类将要被释放时隐式的调用。子类在所有析构器被执行完毕前不会被释放。</p>
<p>析构器不会被直接调用。</p>
<p>查看例子和如何在类的声明中使用析构器，参见<a href="../chapter2/15_Deinitialization.html">析构过程Deinitialization</a>一节。</p>
<p><a name="grammer_of_a_deinitializer_declaration"></a></p>
<blockquote>
<p>析构器声明语法<br><em>析构器声明</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>特性(Attributes)列表</em></a> <em>可选</em> <strong>deinit</strong> <a href="../chapter3/05_Declarations.html#code_block"><em>代码块</em></a>  </p>
</blockquote>
<p><a name="extension_declaration"></a></p>
<p>##扩展声明</p>
<p><em>扩展声明(extension declaration)</em>用于扩展一个现存的类，结构体，枚举的行为。扩展声明使用关键字<code>extension</code>，遵循如下的规则：</p>
<blockquote>
<p>extension <code>type name</code>: <code>adopted protocols</code> {<br>   <code>declarations</code><br>}  </p>
</blockquote>
<p>一个扩展声明体包括零个或多个<em>声明语句(declarations)</em>。这些<em>声明语句(declarations)</em>可以包括计算型属性，计算型类型属性，实例方法，类型方法，构造器，下标脚本声明，甚至其他结构体，类，和枚举声明。扩展声明不能包含析构器，协议声明，存储型属性，属性监测器或其他的扩展属性。详细讨论和查看包含多种扩展声明的实例，参见<a href="../chapter2/21_Extensions.html">扩展(Extensions)</a>一节。</p>
<p>扩展声明可以向现存的类，结构体，枚举内添加<em>一致的协议(adopted protocols)</em>。扩展声明不能向一个类中添加继承的类，因此在<em>类型名称</em>的冒号后面仅能指定一个协议列表。</p>
<p>属性，方法，现存类型的构造器不能被它们类型的扩展所重写。</p>
<p>扩展声明可以包含构造器声明，这意味着，如果扩展的类型在其他模块中定义，构造器声明必须委托另一个在<br>那个模块里声明的构造器来恰当的初始化。</p>
<p><a name="grammer_of_an_extension_declaration"></a></p>
<blockquote>
<p>扩展(Extension)声明语法<br><em>扩展声明</em> → <a href="TODO">访问级别修饰符</a> <em>可选</em> <strong>extension</strong> <a href="../chapter3/03_Types.html#type_identifier"><em>类型标识</em></a> <a href="../chapter3/03_Types.html#type_inheritance_clause"><em>类型继承子句</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#extension_body"><em>extension-body</em></a><br><em>extension-body</em> → <strong>{</strong> <a href="../chapter3/05_Declarations.html#declarations"><em>声明(Declarations)列表</em></a> <em>可选</em> <strong>}</strong>  </p>
</blockquote>
<p><a name="subscript_declaration"></a></p>
<p>##下标脚本声明</p>
<p><em>下标脚本(subscript)</em>声明用于向特定类型添加附属脚本支持，通常为访问集合，列表和序列的元素时提供语法便利。附属脚本声明使用关键字<code>subscript</code>，声明形式如下：</p>
<blockquote>
<p>subscript (<code>parameter</code>) -&gt; (return type){<br>    get{<br>      <code>statements</code><br>    }<br>    set(<code>setter name</code>){<br>      <code>statements</code><br>    }<br>}    </p>
</blockquote>
<p>附属脚本声明只能在类，结构体，枚举，扩展和协议声明的上下文进行声明。</p>
<p><em>参数列表(parameters)</em>指定一个或多个用于在相关类型的下标脚本中访问元素的索引（例如，表达式<code>object[i]</code>中的<code>i</code>）。尽管用于元素访问的索引可以是任意类型的，但是每个变量必须包含一个用于指定每种索引类型的类型标注。<em>返回类型(return type)</em>指定被访问的元素的类型。</p>
<p>和计算性属性一样，下标脚本声明支持对访问元素的读写操作。getter用于读取值，setter用于写入值。setter子句是可选的，当仅需要一个getter子句时，可以将二者都忽略且直接返回请求的值即可。也就是说，如果使用了setter子句，就必须使用getter子句。</p>
<p><em>setter名称(setter name)</em>和封闭的括号是可选的。如果使用了setter名称，它会被当做传给setter的变量的名称。如果不使用setter名称，那么传给setter的变量的名称默认是<code>value</code>。<em>setter名称(setter name)</em>的类型必须与<em>返回类型(return type)</em>的类型相同。</p>
<p>可以在下标脚本声明的类型中，可以重载下标脚本，只要<em>参数列表(parameters)</em>或<em>返回类型(return type)</em>与先前的不同即可。也可以重写继承自超类的下标脚本声明。此时，必须使用<code>override</code>声明修饰符声明那个被重写的下标脚本。(待定)</p>
<p>同样可以在协议声明的上下文中声明下标脚本，<a href="../chapter3/05_Declarations.html#protocol_subscript_declaration">协议下标脚本声明(Protocol Subscript Declaration)</a>中有所描述。</p>
<p>更多关于下标脚本和下标脚本声明的例子，请参考<a href="../chapter2/12_Subscripts.html">下标脚本(Subscripts)</a>。</p>
<p><a name="grammer_of_a_subscript_declaration"></a></p>
<blockquote>
<p>附属脚本声明语法<br><em>附属脚本声明</em> → <a href="../chapter3/05_Declarations.html#subscript_head"><em>附属脚本头(Head)</em></a> <a href="../chapter3/05_Declarations.html#subscript_result"><em>附属脚本结果(Result)</em></a> <a href="../chapter3/05_Declarations.html#code_block"><em>代码块</em></a><br><em>附属脚本声明</em> → <a href="../chapter3/05_Declarations.html#subscript_head"><em>附属脚本头(Head)</em></a> <a href="../chapter3/05_Declarations.html#subscript_result"><em>附属脚本结果(Result)</em></a> <a href="../chapter3/05_Declarations.html#getter_setter_block"><em>getter-setter块</em></a><br><em>附属脚本声明</em> → <a href="../chapter3/05_Declarations.html#subscript_head"><em>附属脚本头(Head)</em></a> <a href="../chapter3/05_Declarations.html#subscript_result"><em>附属脚本结果(Result)</em></a> <a href="../chapter3/05_Declarations.html#getter_setter_keyword_block"><em>getter-setter关键字(Keyword)块</em></a><br><em>附属脚本头(Head)</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>特性(Attributes)列表</em></a> <em>可选</em> <a href="TODO"><em>声明修饰符列表(declaration-modifiers)</em></a> <em>可选</em> <strong>subscript</strong> <a href="../chapter3/05_Declarations.html#parameter_clause"><em>参数子句</em></a><br><em>附属脚本结果(Result)</em> → <strong>-&gt;</strong> <a href="../chapter3/06_Attributes.html#attributes"><em>特性(Attributes)列表</em></a> <em>可选</em> <a href="../chapter3/03_Types.html#type"><em>类型</em></a>   </p>
</blockquote>
<p><a name="operator_declaration"></a></p>
<p>##运算符声明(translated by 林)</p>
<p><em>运算符声明(operator declaration)</em>会向程序中引入中缀、前缀或后缀运算符，它使用关键字<code>operator</code>声明。</p>
<p>可以声明三种不同的缀性：中缀、前缀和后缀。操作符的<em>缀性(fixity)</em>描述了操作符与它的操作数的相对位置。</p>
<p>运算符声明有三种基本形式，每种缀性各一种。运算符的缀性通过在<code>operator</code>关键字之前添加声明修饰符<code>infix</code>，<code>prefix</code>或<code>postfix</code>来指定。每种形式中，运算符的名字只能包含<a href="../chapter3/02_Lexical_Structure.html#operators">运算符(Operators)</a>中定义的运算符字符。</p>
<p>下面的这种形式声明了一个新的中缀运算符：</p>
<blockquote>
<pre><code><span class="keyword">infix</span> <span class="keyword">operator</span> `<span class="keyword">operator</span> name` {  
<span class="keyword">precedence</span> `<span class="keyword">precedence</span> level`  
<span class="keyword">associativity</span> `<span class="keyword">associativity</span>`  
</code></pre><p>}  </p>
</blockquote>
<p><em>中缀运算符(infix operator)</em>是二元运算符，它可以被置于两个操作数之间，比如表达式<code>1 + 2</code> 中的加法运算符(<code>+</code>)。</p>
<p>中缀运算符可以可选地指定优先级，结合性，或两者同时指定。</p>
<p>运算符的<em>优先级(precedence)</em>可以指定在没有括号包围的情况下，运算符与它的操作数如何紧密绑定的。可以使用上下文关键字<code>precedence</code>并<em>优先级(precedence level)</em>一起来指定一个运算符的优先级。<em>优先级(precedence level)</em>可以是0到255之间的任何一个数字(十进制整数)；与十进制整数字面量不同的是，它不可以包含任何下划线字符。尽管优先级是一个特定的数字，但它仅用作与另一个运算符比较(大小)。也就是说，一个操作数可以同时被两个运算符使用时，例如<code>2 + 3 * 5</code>，优先级更高的运算符将优先与操作数绑定。</p>
<p>运算符的<em>结合性(associativit)</em>可以指定在没有括号包围的情况下，优先级相同的运算符以何种顺序被分组的。可以使用上下文关键字<code>associativity</code>并<em>结合性(associativity)</em>一起来指定一个运算符的结合性，其中<em>结合性</em>可以说是上下文关键字<code>left</code>，<code>right</code>或<code>none</code>中的任何一个。左结合运算符以从左到右的形式分组。例如，减法运算符(<code>-</code>)具有左结合性，因此<code>4 - 5 - 6</code>被以<code>(4 - 5) - 6</code>的形式分组，其结果为<code>-7</code>。<br>右结合运算符以从右到左的形式分组，对于设置为<code>none</code>的非结合运算符，它们不以任何形式分组。具有相同优先级的非结合运算符，不可以互相邻接。例如，表达式<code>1 &lt; 2 &lt; 3</code>非法的。</p>
<p>声明时不指定任何优先级或结合性的中缀运算符，它们的优先级会被初始化为100，结合性被初始化为<code>none</code>。</p>
<p>下面的这种形式声明了一个新的前缀运算符：</p>
<blockquote>
<p>prefix operator <code>operator name</code>{}  </p>
</blockquote>
<p>紧跟在操作数前边的<em>前缀运算符(prefix operator)</em>是一元运算符，例如表达式<code>++i</code>中的前缀递增运算符(<code>++</code>)。</p>
<p>前缀运算符的声明中不指定优先级。前缀运算符是非结合的。</p>
<p>下面的这种形式声明了一个新的后缀运算符：</p>
<blockquote>
<p>postfix operator <code>operator name</code>{}  </p>
</blockquote>
<p>紧跟在操作数后边的<em>后缀运算符(postfix operator)</em>是一元运算符，例如表达式<code>i++</code>中的前缀递增运算符(<code>++</code>)。</p>
<p>和前缀运算符一样，后缀运算符的声明中不指定优先级。后缀运算符是非结合的。</p>
<p>声明了一个新的运算符以后，需要声明一个跟这个运算符同名的函数来实现这个运算符。如果在实现一个前缀或者后缀操作符，也必须使用相符的<code>prefix</code>或者<code>postfix</code>声明修饰符标记函数声明。如果实现中缀操作符，不需要使用<code>infix</code>声明修饰符标记函数声明。如何实现一个新的运算符，请参考<a href="../chapter2/25_Advanced_Operators.html#custom_operators">Custom Operators</a>。</p>
<p><a name="grammer_of_an_operator_declaration"></a></p>
<blockquote>
<p>运算符声明语法<br><em>运算符声明</em> → <a href="../chapter3/05_Declarations.html#prefix_operator_declaration"><em>前置运算符声明</em></a> | <a href="../chapter3/05_Declarations.html#postfix_operator_declaration"><em>后置运算符声明</em></a> | <a href="../chapter3/05_Declarations.html#infix_operator_declaration"><em>中置运算符声明</em></a><br><em>前置运算符声明</em> → <strong>prefix</strong> <strong>运算符</strong> <a href="LexicalStructure.html#operator"><em>运算符</em></a> <strong>{</strong> <strong>}</strong><br><em>后置运算符声明</em> → <strong>postfix</strong> <strong>运算符</strong> <a href="LexicalStructure.html#operator"><em>运算符</em></a> <strong>{</strong> <strong>}</strong><br><em>中置运算符声明</em> → <strong>infix</strong> <strong>运算符</strong> <a href="LexicalStructure.html#operator"><em>运算符</em></a> <strong>{</strong> <a href="../chapter3/05_Declarations.html#infix_operator_attributes"><em>中置运算符属性</em></a> <em>可选</em> <strong>}</strong><br><em>中置运算符属性</em> → <a href="../chapter3/05_Declarations.html#precedence_clause"><em>优先级子句</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#associativity_clause"><em>结和性子句</em></a> <em>可选</em><br><em>优先级子句</em> → <strong>precedence</strong> <a href="../chapter3/05_Declarations.html#precedence_level"><em>优先级水平</em></a><br><em>优先级水平</em> → 十进制整数 0 到 255<br><em>结和性子句</em> → <strong>associativity</strong> <a href="../chapter3/05_Declarations.html#associativity"><em>结和性</em></a><br><em>结和性</em> → <strong>left</strong> | <strong>right</strong> | <strong>none</strong>  </p>
</blockquote>
<p><a name="declaration_modifiers"></a></p>
<h2 id="声明修饰符">声明修饰符</h2><p><em>声明修饰符(Declaration modifiers)</em>是关键字或者说是上下文相关的关键字，它可以修改一个声明的行为或者含义。可以在一个声明的特性和引进该声明的关键字之间，指定一个声明修饰符，并写下它的关键字或上下文相关的关键字。</p>
<p><code>dynamic</code><br>可以将该修饰符用于任何可以出现在Objective-C中的类成员上。当将<code>dynamic</code>修饰符用于一个成员声明上时，对该成员的访问总是由Objective-C的实时系统动态地安排，而永远不会由编译器内联或去虚拟化。<br>因为当一个声明被标识<code>dynamic</code>修饰符时，会由Objective-C的实时系统动态地安排，所以他们是被隐式的标识了<code>objc</code>特性的。</p>
<p><code>final</code></p>
<p>该修饰符用于修饰一个类或类中的属性，方法，以及下标成员。如果用它修饰一个类，那么这个类则不能被继承。如果用它修饰类中的属性，方法或下标，则表示在子类中，它们不能被重写。</p>
<p><code>lazy</code></p>
<p>该修饰符用于修饰类或结构体中的存储型变量属性，表示该属性的初始值最多只被计算和存储一次，且发生在第一次访问它时。如何使用<code>lazy</code>特性的一个例子，请见：<a href="../chapter2/10_Properties.html#lazy_stored_properties">惰性存储型属性(Lazy Stored Properties)</a>。</p>
<p><code>optional</code></p>
<p>该修饰符用于修饰一个类或类中的属性，方法，以及下标成员,表示遵循类型没有被要求实现这些成员。<br>只能将<code>optional</code>修饰符用于被<code>objc</code>标识的协议。这样一来，只有类类型可以适配或遵循拥有可选成员需求的协议。关于如何使用<code>optional</code>修饰符,以及如何访问可选协议成员的指导(比如，不确定遵循类型是否已经实现了这些可选成员)，可以参见<a href="../chapter2/22_Protocols.html#optional_protocol_requirements">对可选协议的规定(Optional Protocol Requirements)</a>一章</p>
<p><code>required</code></p>
<p>该修饰符用于修饰一个类的特定构造器或便捷构造器,表示该类所有的子类都需要实现该构造器。在子类实现该构造器时，同样必须使用<code>required</code>修饰符修饰该构造器。</p>
<p><code>weak</code></p>
<p><code>weak</code>修饰符用于修饰一个变量或一个存储型变量属性，表示该变量或属性通过一个弱引用指向存储其值的对象。该变量或属性的类型必须是一个可选类类型。通过<code>weak</code>修饰符可避免强引用循环。关于<code>weak</code>修饰符的例子和更多信息，可以参见<a href="../chapter2/16_Automatic_Reference_Counting.html#resolving_strong_reference_cycles_between_class_instances">弱引用(Weak References)</a>一章</p>
<p><a name="access_control_levels"></a></p>
<h3 id="访问控制级别">访问控制级别</h3><p>Swift提供了三个级别的权限控制：<code>public</code>, <code>internal</code>, 和 <code>private</code>。可以给声明标识以下访问级别修饰符中的一个以指定声明的权限级别。访问控制在<a href="../chapter2/24_Access_Control.html">访问控制(Access Control)</a>一章有详细说明。</p>
<p><code>public</code></p>
<p>修饰符用于修饰声明时，表示该声明可被同一个模块中的代码访问。被<code>public</code>权限级别修饰符修饰的声明，还可被其他模块的代码访问，只要该模块注入了该声明所在的模块。</p>
<p><code>internal</code></p>
<p>修饰符用于修饰声明时，表示该声明只能被同一模块中的代码访问。默认的，绝大多数声明会被隐式的标识上<code>internal</code>权限级别修饰符</p>
<p><code>private</code></p>
<p>修饰符用于修饰声明时，表示该声明只能被同一源文件中的代码访问。</p>
<p>以上的任意一个权限级别修饰符都可以有选择的带上一个参数，该参数由关键字<code>set</code>和一对括号组成（比如，<code>private(set)</code>）。当想要指明一个变量或下标脚注的setter的访问级别要低于或等于该变量或下标脚注的实际访问级别时，使用这种格式的权限级别修饰符，就像<a href="../chapter2/24_Access_Control.html#getters_and_setters">Getters and Setters</a>一章中讨论的一样。</p>
<p><a name="grammer_of_a_declaration_modifier"></a></p>
<blockquote>
<p>声明修饰符的语法</p>
<p>声明修饰符 → <strong>class</strong>­ | <strong>convenience­</strong>| <strong>dynamic</strong>­ | <strong>final</strong>­ | <strong>infix</strong>­ | <strong>lazy­</strong> | <strong>mutating</strong>­ | <strong>nonmutating</strong>­ | <strong>optional</strong>­ | <strong>override</strong>­ | <strong>postfix</strong>|­ <strong>prefix­</strong> | <strong>required­</strong> | <strong>static</strong>­ | <strong>unowned­</strong> | <strong>unowned­(­safe­)</strong>­ | <strong>unowned­(­unsafe­)­</strong> | <strong>weak</strong>­</p>
<p>声明修饰符 → 权限级别修饰符­</p>
<p>访问级别修饰符 → <strong>internal</strong>­ | <strong>internal­(­set­)­</strong></p>
<p>访问级别修饰符 → <strong>private­</strong> | <strong>private­(­set­)­</strong></p>
<p>访问级别修饰符 → <strong>public­</strong> | <strong>public­(­set­)­</strong></p>
<p>访问级别修饰符 → <a href="#">访问级别修饰符(access-level-modeifier)</a> <a href="#">访问级别修饰符列表(access-level-modeifiers)</a> <em>可选</em><br>­</p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter3/06_Attributes/" itemprop="url">
                第三章-06特性（Attributes）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T11:00:15+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter3/06_Attributes/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter3/06_Attributes/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="特性（Attributes）">特性（Attributes）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/Hawstein" target="_blank" rel="external">Hawstein</a><br>校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>, <a href="https://github.com/stanzhai" target="_blank" rel="external">stanzhai</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/KYawn" target="_blank" rel="external">KYawn</a></p>
<p>2.1<br>翻译：<a href="https://github.com/kevin833752" target="_blank" rel="external">小铁匠Linus</a></p>
</blockquote>
<p>本页内容包括：</p>
<ul>
<li><a href="#declaration_attributes">声明特性</a></li>
<li><a href="#type_attributes">类型特性</a></li>
</ul>
<p>特性提供了关于声明和类型的更多信息。在Swift中有两类特性，用于修饰声明的以及用于修饰类型的。</p>
<p>通过以下方式指定一个特性：符号<code>@</code>后面跟特性名，如果包含参数，则把参数带上：</p>
<blockquote>
<p>@<code>attribute name</code><br>@<code>attribute name</code>(<code>attribute arguments</code>)  </p>
</blockquote>
<p>有些声明特性通过接收参数来指定特性的更多信息以及它是如何修饰一个特定的声明的。这些特性的参数写在小括号内，它们的格式由它们所属的特性来定义。</p>
<p><a name="declaration_attributes"></a></p>
<h2 id="声明特性">声明特性</h2><p>声明特性只能应用于声明。然而，你也可以将<code>noreturn</code>特性应用于函数或方法类型。</p>
<p><code>autoclosure</code></p>
<p>这个特性通过把表达式自动封装成无参数的闭包来延迟表达式的计算。它可以声明返回表达式自身类型的没有参数的方法类型，也可以用于函数参数的声明。含有<code>autoclosure</code>特性的声明同时也具有<code>noescape</code>的特性，除非传递可选参数<code>escaping</code>.关于怎样使用<code>autoclosure</code>特性的例子，参见<a href="./03_Types.html#function_type">函数类型</a>.</p>
<p><code>available</code></p>
<p>将<code>available</code>特性用于声明时，意味着该声明的生命周期会依赖于特定的平台和操作系统版本。</p>
<p><code>available</code>特性经常与参数列表一同出现，该参数列表至少有两个参数，参数之间由逗号分隔。这些参数由以下这些平台名字中的一个起头：</p>
<ul>
<li><code>iOS</code></li>
<li><code>iOSApplicationExtension</code></li>
<li><code>OSX</code></li>
<li><code>OSXApplicationExtension</code></li>
<li><code>watchOS</code></li>
</ul>
<p>当然，你也可以用一个星号(*)来表示，该声明在上面提到的所有平台上都是有效的。</p>
<p>剩下的参数，可以以任何顺序出现，并且可以添加关于声明生命周期的附加信息，包括重要的里程碑。</p>
<ul>
<li><p><code>unavailable</code>参数表示：该声明在特定的平台上是无效的</p>
</li>
<li><p><code>introduced</code>参数表示：该声明第一次被引入时所在平台的版本。格式如下：<br></p><p><code>introduced=version number</code></p><p>这里的<code>version number</code>由一个正的十进制整数或浮点数构成。</p>
</li>
<li><p><code>deprecated</code>参数表示：该声明第一次被建议弃用时所在平台的版本。格式如下：<br></p><p><code>deprecated=version number</code></p><p>这里的<code>version number</code>由一个正的十进制整数或浮点数构成。</p>
</li>
<li><p><code>obsoleted</code>参数表示：该声明第一次被弃用时所在平台的版本。当一个声明被弃用时，它就从此平台中被移除，不能再被使用。格式如下：<br></p><p><code>obsoleted=version number</code></p><p>这里的<code>version number</code>由一个正的十进制整数或浮点数构成。</p>
</li>
<li><p><code>message</code>参数用来提供文本信息。当使用建议弃用或者被弃用的声明时，编译器会抛出错误或警告信息。格式如下：<br></p><p><code>message=message</code></p><p>这里的<code>message</code>由一个字符串文字构成。</p>
</li>
<li><p><code>renamed</code>参数用来提供文本信息，用以表示被重命名的声明的新名字。当使用这个重命名的声明遇到错误时，编译器会显示出该新名字。格式如下：<br></p><p><code>renamed=new name</code></p><p>这里的<code>new name</code>由一个字符串文字构成。</p>
</li>
</ul>
<p>你可以将<code>renamed</code>参数和<code>unavailable</code>参数以及类型别名声明组合使用，以向用户表示：在你的代码中，一个声明已经被重命名。当一个声明的名字在一个框架或者库的不同发布版本间发生变化时，这会相当有用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// First release</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MyProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">// protocol definition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Subsequent release renames MyProtocol</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MyRenamedProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">// protocol definition</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@available(*, unavailable, renamed=<span class="string">"MyRenamedProtocol"</span>)</span><br><span class="line"><span class="keyword">typealias</span> <span class="type">MyProtocol</span> = <span class="type">MyRenamedProtocol</span></span><br></pre></td></tr></table></figure>
<p>你可以在一个单独的声明上使用多个<code>available</code>特性，以详细说明该声明在不同平台上的有效性。编译器只有在当前的目标平台和<code>available</code>特性中指定的平台匹配时，才会使用<code>available</code>特性。</p>
<p>如果<code>available</code>特性除了平台名称参数外，只指定了一个<code>introduced</code>参数，那么可以使用以下简写语法代替：</p>
<p>@available(<code>platform name</code> <code>version number</code>, *)</p>
<p><code>available</code>特性的简写语法可以简明地表达出多个平台的可用性。尽管这两种形式在功能上是相同的，但请尽可能地使用简明语法形式。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@available(iOS <span class="number">8.0</span>, <span class="type">OSX</span> <span class="number">10.10</span>, *)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class definition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>objc</code></p>
<p>该特性用于修饰任何可以在Objective-C中表示的声明。比如，非嵌套类、协议、非泛型枚举（仅限整型值类型）、类和协议的属性和方法（包括<code>getter</code>和<code>setter</code>）、构造器、析构器以及下标。<code>objc</code>特性告诉编译器这个声明可以在Objective-C代码中使用。</p>
<p>标有<code>objc</code>特性的类必须继承自Objective-C中定义的类。如果你将<code>objc</code>特性应用于一个类或协议，它也会隐式地应用于那个类的成员或协议。对于标记了<code>objc</code>特性的类，编译器会隐式地为它的子类添加<code>objc</code>特性。标记了<code>objc</code>特性的协议不能继承没有标记<code>objc</code>的协议。</p>
<p>如果你将<code>objc</code>特性应用于枚举，每一个枚举的<code>case</code>都会以枚举名称和<code>case</code>名称组合的方式暴露在Objective-C代码中。例如：一个名为<code>Venus</code>的<code>case</code>在<code>Planet</code>枚举中，这个<code>case</code>暴露在Objective-C代码中时叫做<code>PlanetVenus</code>。</p>
<p><code>objc</code>特性有一个可选的参数，由标记符组成。当你想把<code>objc</code>所修饰的实体以一个不同的名字暴露给Objective-C时，你就可以使用这个特性参数。你可以使用这个参数来命名类，协议，方法，getters，setters，以及构造器。下面的例子把<code>ExampleClass</code>中<code>enabled</code>属性的getter暴露给Objective-C，名字是<code>isEnabled</code>，而不是它原来的属性名。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">@objc</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleClass</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> enabled: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="preprocessor">@objc</span>(isEnabled) <span class="keyword">get</span> &#123;</span><br><span class="line">        <span class="comment">// Return the appropriate value</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>noescape</code></p>
<p>在函数或者方法声明上使用该特性，它表示参数将不会被存储用作后续的计算，其用来确保不会超出函数调用的生命周期。对于其属性或方法来说，使用<code>noescape</code>声明属性的函数类型不需要显式的使用<code>self.</code>。</p>
<p><code>nonobjc</code></p>
<p>该特性用于方法、属性、下标、或构造器的声明，这些声明本是可以在Objective-C代码中表示的。使用<code>nonobjc</code>特性告诉编译器这个声明不能在Objective-C代码中使用。</p>
<p>可以使用<code>nonobjc</code>特性解决标有<code>objc</code>的类中桥接方法的循环问题，该特性还允许标有<code>objc</code>的类的构造器和方法进行重载(overload)。</p>
<p>标有<code>nonobjc</code>特性的方法不能重写(override)一个标有<code>objc</code>特性的方法。然而，标有<code>objc</code>特性的方法可以重写标有<code>nonobjc</code>特性的方法。同样，标有<code>nonobjc</code>特性的方法不能满足一个需要标有<code>@objc</code>特性的方法的协议。</p>
<p><code>noreturn</code></p>
<p>该特性用于修饰函数或方法声明，表明该函数或方法的对应类型，<code>T</code>，是<code>@noreturn T</code>。你可以用这个特性修饰函数或方法的类型，这样一来，函数或方法就不会返回到它的调用者中去。</p>
<p>对于一个没有用<code>noreturn</code>特性标记的函数或方法，你可以将它重写为用该特性标记的。相反，对于一个已经用<code>noreturn</code>特性标记的函数或方法，你则不可以将它重写为没使用该特性标记的。当你在一个comforming类型中实现一个协议方法时，该规则同样适用。</p>
<p><code>NSApplicationMain</code></p>
<p>在类上使用该特性表示该类是应用程序委托类，使用该特性与调用<code>NSApplicationMain(_:_:)</code>函数并且把该类的名字作为委托类的名字传递给函数的效果相同。</p>
<p>如果你不想使用这个特性，可以提供一个<code>main.swift</code>文件，并且提供一个<code>main()</code>函数去调用<code>NSApplicationMain(_:_:)</code>函数。比如，如果你的应用程序使用一个派生于<code>NSApplication</code>的自定义子类作为主要类，你可以调用<code>NSApplicationMain</code>函数而不是使用该特性。</p>
<p><code>NSCopying</code></p>
<p>该特性用于修饰一个类的存储型变量属性。该特性将使属性的setter与属性值的一个副本合成，这个值由<code>copyWithZone(_:)</code>方法返回，而不是属性本身的值。该属性的类型必需遵循<code>NSCopying</code>协议。</p>
<p><code>NSCopying</code>特性的原理与Objective-C中的<code>copy</code>特性相似。</p>
<p><code>NSManaged</code></p>
<p>该特性用于修饰<code>NSManagedObject</code>子类中的实例方法或存储型变量属性，表明属性的存储和实现由Core Data在运行时基于相关实体描述动态提供。对于标记了<code>NSManaged</code>特性的属性，Core Data也会在运行时提供存储。</p>
<p><code>testable</code></p>
<p>该特性用于<code>import</code>声明可以测试的编译模块，它能访问任何标有<code>internal</code>权限标识符的实体，这和将它声明为<code>public</code>权限标识符有同样的效果。</p>
<p><code>UIApplicationMain</code></p>
<p>在类上使用该特性表示该类是应用程序委托类，使用该特性与调用<code>UIApplicationMain(_:_:)</code>函数并且把该类的名字作为委托类的名字传递给函数的效果相同。</p>
<p>如果你不想使用这个特性，可以提供一个<code>main.swift</code>文件，并且提供一个<code>main</code>函数去调用<code>UIApplicationMain(_:_:)</code>函数。比如，如果你的应用程序使用一个派生于<code>UIApplication</code>的自定义子类作为主要类，你可以调用<code>UIApplicationMain</code>函数而不是使用该特性。</p>
<p><code>warn_unused_result</code></p>
<p>该特性应用于方法或函数声明，当方法或函数被调用，但其结果未被使用时，该特性会让编译器会产生警告。</p>
<p>你可以使用这个特性提供一个警告信息，这个警告信息是关于不正确地使用未变异的方法，这个方法也有一个对应的变异方法。</p>
<p><code>warn_unused_result</code>特性会有选择地采用下面两个参数之一。</p>
<ul>
<li><p><code>message</code>参数用来提供警告信息。在当方法或函数被调用，但其结果未被使用时，会显示警告信息。格式如下：<br></p><p><code>message=message</code></p><p>这里的<code>message</code>由一个字符串文字构成。</p>
</li>
<li><p><code>mutable_variant</code>参数用于提供变异方法的名称，如果未变异方法以一个可变的值被调用而且其结果并未被使用时，应该使用此变异方法。格式如下（方法名有字符串构成）：</p><p><code>mutable_variant=method name</code></p><p><br>比如，Swift标准库同时提供了变异方法<code>sortInPlace()</code>和未变异方法<code>sort()</code>集合，它们的元素生成器符合<code>Comparable</code>协议。如果你调用了<code>sort()</code>方法，而没有使用它的结果，其实很有可能，你是打算使用变异方法<code>sortInPlace()</code>。</p>
</li>
</ul>
<h3 id="Interface_Builder使用的声明特性">Interface Builder使用的声明特性</h3><p>Interface Builder特性是Interface Builder用来与Xcode同步的声明特性。Swift提供了以下的Interface Builder特性：<code>IBAction</code>，<code>IBDesignable</code>，<code>IBInspectable</code>，以及<code>IBOutlet</code>。这些特性与Objective-C中对应的特性在概念上是相同的。</p>
<p><code>IBOutlet</code>和<code>IBInspectable</code>用于修饰一个类的属性声明；<code>IBAction</code>特性用于修饰一个类的方法声明；<code>IBDesignable</code>用于修饰类的声明。</p>
<p><a name="type_attributes"></a></p>
<h2 id="类型特性">类型特性</h2><p>类型特性只能用于修饰类型。然而，你也可以用<code>noreturn</code>特性去修饰函数或方法声明。</p>
<p><code>convention</code></p>
<p>该特性用于函数的类型，它指出函数调用的约定。</p>
<p><code>convention</code>特性总是与下面的参数之一一起出现。</p>
<ul>
<li><p><code>swift</code>参数用于表明一个Swift函数引用。这是Swift中标准的函数值调用约定。</p>
</li>
<li><p><code>block</code>参数用于表明一个Objective-C兼容的块引用。函数值表示为一个块对象的引用，这是一个<code>id-</code>兼容的Objective-C对象，对象中嵌入了调用函数。调用函数使用C的调用约定。</p>
</li>
<li><p><code>c</code>参数用于表明一个C函数引用。函数值没有上下文，这个函数也使用C的调用约定。</p>
</li>
</ul>
<p>使用C函数调用约定的函数也可用作使用Objective-C块调用约定的函数，同时使用Objective-C块调用约定的函数也可用作使用Swift函数调用约定的函数。然而，只有非泛型的全局函数和本地函数或者不使用任何本地变量的闭包可以被用作使用C函数调用约定的函数。</p>
<p><code>noreturn</code></p>
<p>该特性用于修饰函数或方法的类型，表明该函数或方法不会返回到它的调用者中去。你也可以用它标记函数或方法的声明，表示函数或方法的相应类型，<code>T</code>，是<code>@noreturn T</code>。</p>
<blockquote>
<p>特性语法<br><em>特性</em> → <strong>@</strong> <a href="#attribute_name"><em>特性名</em></a> <a href="#attribute_argument_clause"><em>特性参数子句</em></a> (可选)<br><em>特性名</em> → <a href="02_Lexical_Structure.html#identifiers"><em>标识符</em></a><br><em>特性参数子句</em> → <strong>(</strong> <a href="#balanced_tokens"><em>平衡令牌列表</em></a> (可选) <strong>)</strong><br><em>特性(Attributes)列表</em> → <a href="#attribute"><em>特色</em></a> <a href="#attributes"><em>特性(Attributes)列表</em></a> (可选)<br><em>平衡令牌列表</em> → <a href="#balanced_token"><em>平衡令牌</em></a> <a href="#balanced_tokens"><em>平衡令牌列表</em></a> (可选)<br><em>平衡令牌</em> → <strong>(</strong> <a href="#balanced_tokens"><em>平衡令牌列表</em></a> (可选) <strong>)</strong><br><em>平衡令牌</em> → <strong>[</strong> <a href="#balanced_tokens"><em>平衡令牌列表</em></a> (可选) <strong>]</strong><br><em>平衡令牌</em> → <strong>{</strong> <a href="#balanced_tokens"><em>平衡令牌列表</em></a> (可选) <strong>}</strong><br><em>平衡令牌</em> → <strong>任意标识符, 关键字, 字面量或运算符</strong><br><em>平衡令牌</em> → <strong>任意标点除了(, ), [, ], {, 或 }</strong></p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/">&laquo;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/8/">&raquo;</a>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="https://avatars2.githubusercontent.com/u/14305708?v=3&s=460" alt="terry" itemprop="image"/>
          <p class="site-author-name" itemprop="name">terry</p>
        </div>
        <p class="site-description motion-element" itemprop="description">terry yang's blog | java | scala | bi</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">135</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">11</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-next-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yangwei8888" target="_blank">github</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/microsoftgoogles" target="_blank">weibo</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/run-zhi-38" target="_blank">zhihu</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">terry</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  

    <script type="text/javascript">
      var disqus_shortname = 'yangwei888';
      var disqus_identifier = 'page/7/index.html';
      var disqus_title = '';
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
