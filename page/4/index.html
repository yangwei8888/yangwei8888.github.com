<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="terry yang's blog | java | scala | bi" />



  <meta name="keywords" content="Hexo,next" />



  <link rel="alternate" href="/atom.xml" title="yosita" type="application/atom+xml" />



  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="terry yang&apos;s blog | java | scala | bi">
<meta property="og:type" content="website">
<meta property="og:title" content="yosita">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="yosita">
<meta property="og:description" content="terry yang&apos;s blog | java | scala | bi">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="yosita">
<meta name="twitter:description" content="terry yang&apos;s blog | java | scala | bi">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>

  <title> yosita </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  

  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?7e8961fdae021b7bf62f2c767bb18c23";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">yosita</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/02_Basic_Operators/" itemprop="url">
                第二章-02基本运算符（Basic Operators）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:25+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/02_Basic_Operators/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/02_Basic_Operators/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="基本运算符（Basic_Operators）">基本运算符（Basic Operators）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/xielingwang" target="_blank" rel="external">XieLingWang</a><br>校对：<a href="https://github.com/Evilcome" target="_blank" rel="external">EvilCome</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/AlanMelody" target="_blank" rel="external">JackAlan</a></p>
<p>2.1<br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#terminology">术语</a></li>
<li><a href="#assignment_operator">赋值运算符</a></li>
<li><a href="#arithmetic_operators">算术运算符</a></li>
<li><a href="#compound_assignment_operators">组合赋值运算符（Compound Assignment Operators）</a></li>
<li><a href="#comparison_operators">比较运算符</a></li>
<li><a href="#ternary_conditional_operator">三目运算符（Ternary Conditional Operator）</a></li>
<li><a href="#nil_coalescing_operator">空合运算符</a></li>
<li><a href="#range_operators">区间运算符</a></li>
<li><a href="#logical_operators">逻辑运算符</a></li>
</ul>
<p>运算符是检查、改变、合并值的特殊符号或短语。例如，加号<code>+</code>将两个数相加（如<code>let i = 1 + 2</code>）。更复杂的运算例子包括逻辑与运算符<code>&amp;&amp;</code>（如<code>if enteredDoorCode &amp;&amp; passedRetinaScan</code>），或让 i 值加1的便捷自增运算符<code>++i</code>等。</p>
<p>Swift 支持大部分标准 C 语言的运算符，且改进许多特性来减少常规编码错误。如：赋值符（<code>=</code>）不返回值，以防止把想要判断相等运算符（<code>==</code>）的地方写成赋值符导致的错误。算术运算符（<code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>%</code>等）会检测并不允许值溢出，以此来避免保存变量时由于变量大于或小于其类型所能承载的范围时导致的异常结果。当然允许你使用 Swift 的溢出运算符来实现溢出。详情参见<a href="../chapter2/25_Advanced_Operators.html#overflow_operators">溢出运算符</a>。</p>
<p>区别于 C 语言，在 Swift 中你可以对浮点数进行取余运算（<code>%</code>），Swift 还提供了 C 语言没有的表达两数之间的值的区间运算符（<code>a..&lt;b</code>和<code>a...b</code>），这方便我们表达一个区间内的数值。</p>
<p>本章节只描述了 Swift 中的基本运算符，<a href="../chapter2/25_Advanced_Operators.html">高级运算符</a>包含了高级运算符，及如何自定义运算符，及如何进行自定义类型的运算符重载。</p>
<p><a name="terminology"></a></p>
<h2 id="术语">术语</h2><p>运算符有一元、二元和三元运算符。</p>
<ul>
<li>一元运算符对单一操作对象操作（如<code>-a</code>）。一元运算符分前置运算符和后置运算符，前置运算符需紧跟在操作对象之前（如<code>!b</code>），后置运算符需紧跟在操作对象之后（如<code>i++</code>）。</li>
<li>二元运算符操作两个操作对象（如<code>2 + 3</code>），是中置的，因为它们出现在两个操作对象之间。</li>
<li>三元运算符操作三个操作对象，和 C 语言一样，Swift 只有一个三元运算符，就是三目运算符（<code>a ? b : c</code>）。</li>
</ul>
<p>受运算符影响的值叫操作数，在表达式<code>1 + 2</code>中，加号<code>+</code>是二元运算符，它的两个操作数是值<code>1</code>和<code>2</code>。</p>
<p><a name="assignment_operator"></a></p>
<h2 id="赋值运算符">赋值运算符</h2><p>赋值运算（<code>a = b</code>），表示用<code>b</code>的值来初始化或更新<code>a</code>的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">5</span></span><br><span class="line">a = b</span><br><span class="line"><span class="comment">// a 现在等于 10</span></span><br></pre></td></tr></table></figure>
<p>如果赋值的右边是一个多元组，它的元素可以马上被分解成多个常量或变量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (x, y) = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 现在 x 等于 1, y 等于 2</span></span><br></pre></td></tr></table></figure>
<p>与 C 语言和 Objective-C 不同，Swift 的赋值操作并不返回任何值。所以以下代码是错误的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x = y &#123;</span><br><span class="line">	<span class="comment">// 此句错误, 因为 x = y 并不返回任何值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个特性使你无法把（<code>==</code>）错写成（<code>=</code>），由于<code>if x = y</code>是错误代码，Swift帮你避免此类错误的的发生。</p>
<p><a name="arithmetic_operators"></a></p>
<h2 id="算术运算符">算术运算符</h2><p>Swift 中所有数值类型都支持了基本的四则算术运算：</p>
<ul>
<li>加法（<code>+</code>）</li>
<li>减法（<code>-</code>）</li>
<li>乘法（<code>*</code>）</li>
<li>除法（<code>/</code>）</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">2</span>       <span class="comment">// 等于 3</span></span><br><span class="line"><span class="number">5</span> - <span class="number">3</span>       <span class="comment">// 等于 2</span></span><br><span class="line"><span class="number">2</span> * <span class="number">3</span>       <span class="comment">// 等于 6</span></span><br><span class="line"><span class="number">10.0</span> / <span class="number">2.5</span>  <span class="comment">// 等于 4.0</span></span><br></pre></td></tr></table></figure>
<p>与 C 语言和 Objective-C 不同的是，Swift 默认情况下不允许在数值运算中出现溢出情况。但是你可以使用 Swift 的溢出运算符来实现溢出运算（如<code>a &amp;+ b</code>）。详情参见<a href="../chapter2/25_Advanced_Operators.html#overflow_operators">溢出运算符</a>。</p>
<p>加法运算符也可用于<code>String</code>的拼接：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"hello, "</span> + <span class="string">"world"</span>  <span class="comment">// 等于 "hello, world"</span></span><br></pre></td></tr></table></figure>
<h3 id="求余运算符">求余运算符</h3><p>求余运算（<code>a % b</code>）是计算<code>b</code>的多少倍刚刚好可以容入<code>a</code>，返回多出来的那部分（余数）。</p>
<blockquote>
<p>注意：<br>求余运算（<code>%</code>）在其他语言也叫取模运算。然而严格说来，我们看该运算符对负数的操作结果，”求余”比”取模”更合适些。</p>
</blockquote>
<p>我们来谈谈取余是怎么回事，计算<code>9 % 4</code>，你先计算出<code>4</code>的多少倍会刚好可以容入<code>9</code>中：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/remainderInteger_2x.png" alt="Art/remainderInteger_2x.png" title="Art/remainderInteger_2x.png"></p>
<p>2倍，非常好，那余数是1（用橙色标出）</p>
<p>在 Swift 中可以表达为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span> % <span class="number">4</span>    <span class="comment">// 等于 1</span></span><br></pre></td></tr></table></figure>
<p>为了得到<code>a % b</code>的结果，<code>%</code>计算了以下等式，并输出<code>余数</code>作为结果：</p>
<pre><code><span class="tag">a</span> = (<span class="tag">b</span> × 倍数) + 余数
</code></pre><p>当<code>倍数</code>取最大值的时候，就会刚好可以容入<code>a</code>中。</p>
<p>把<code>9</code>和<code>4</code>代入等式中，我们得<code>1</code>：</p>
<pre><code><span class="number">9</span> = (<span class="number">4</span> × <span class="number">2</span>) + <span class="number">1</span>
</code></pre><p>同样的方法，我们来计算 <code>-9 % 4</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">9</span> % <span class="number">4</span>   <span class="comment">// 等于 -1</span></span><br></pre></td></tr></table></figure>
<p>把<code>-9</code>和<code>4</code>代入等式，<code>-2</code>是取到的最大整数：</p>
<pre><code>-<span class="number">9</span> = (<span class="number">4</span> × -<span class="number">2</span>) + -<span class="number">1</span>
</code></pre><p>余数是<code>-1</code>。</p>
<p>在对负数<code>b</code>求余时，<code>b</code>的符号会被忽略。这意味着 <code>a % b</code> 和 <code>a % -b</code>的结果是相同的。</p>
<h3 id="浮点数求余计算">浮点数求余计算</h3><p>不同于 C 语言和 Objective-C，Swift 中是可以对浮点数进行求余的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span> % <span class="number">2.5</span>   <span class="comment">// 等于 0.5</span></span><br></pre></td></tr></table></figure>
<p>这个例子中，<code>8</code>除于<code>2.5</code>等于<code>3</code>余<code>0.5</code>，所以结果是一个<code>Double</code>值<code>0.5</code>。</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/remainderFloat_2x.png" alt="Art/remainderFloat_2x.png" title="Art/remainderFloat_2x.png"></p>
<h3 id="自增和自减运算">自增和自减运算</h3><p>和 C 语言一样，Swift 也提供了对变量本身加1或减1的自增（<code>++</code>）和自减（<code>--</code>）的缩略算符。其操作对象可以是整形和浮点型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">++i      <span class="comment">// 现在 i = 1</span></span><br></pre></td></tr></table></figure>
<p>每调用一次<code>++i</code>，<code>i</code>的值就会加1。实际上，<code>++i</code>是<code>i = i + 1</code>的简写，而<code>--i</code>是<code>i = i - 1</code>的简写。</p>
<p><code>++</code>和<code>--</code>既可以用作前置运算又可以用作后置运算。<code>++i</code>，<code>i++</code>，<code>--i</code>和<code>i--</code>都是有效的写法。</p>
<p>我们需要注意的是这些运算符即可修改了<code>i</code>的值也可以返回<code>i</code>的值。如果你只想修改<code>i</code>的值，那你就可以忽略这个返回值。但如果你想使用返回值，你就需要留意前置和后置操作的返回值是不同的，她们遵循以下原则：</p>
<ul>
<li>当<code>++</code>前置的时候，先自増再返回。</li>
<li>当<code>++</code>后置的时候，先返回再自增。</li>
</ul>
<p>例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> b = ++a <span class="comment">// a 和 b 现在都是 1</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = a++ <span class="comment">// a 现在 2, 但 c 是 a 自增前的值 1</span></span><br></pre></td></tr></table></figure>
<p>上述例子，<code>let b = ++a</code>先把<code>a</code>加1了再返回<code>a</code>的值。所以<code>a</code>和<code>b</code>都是新值<code>1</code>。</p>
<p>而<code>let c = a++</code>，是先返回了<code>a</code>的值，然后<code>a</code>才加1。所以<code>c</code>得到了<code>a</code>的旧值1，而<code>a</code>加1后变成2。</p>
<p>除非你需要使用<code>i++</code>的特性，不然推荐你使用<code>++i</code>和<code>--i</code>，因为先修改后返回这样的行为更符合我们的逻辑。</p>
<h3 id="一元负号运算符">一元负号运算符</h3><p>数值的正负号可以使用前缀<code>-</code>（即一元负号）来切换：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> three = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> minusThree = -three       <span class="comment">// minusThree 等于 -3</span></span><br><span class="line"><span class="keyword">let</span> plusThree = -minusThree   <span class="comment">// plusThree 等于 3, 或 "负负3"</span></span><br></pre></td></tr></table></figure>
<p>一元负号（<code>-</code>）写在操作数之前，中间没有空格。</p>
<h3 id="一元正号运算符">一元正号运算符</h3><p>一元正号（<code>+</code>）不做任何改变地返回操作数的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> minusSix = -<span class="number">6</span></span><br><span class="line"><span class="keyword">let</span> alsoMinusSix = +minusSix  <span class="comment">// alsoMinusSix 等于 -6</span></span><br></pre></td></tr></table></figure>
<p>虽然一元<code>+</code>什么都不会改变，但当你在使用一元负号来表达负数时，你可以使用一元正号来表达正数，如此你的代码会具有对称美。</p>
<p><a name="compound_assignment_operators"></a></p>
<h2 id="组合赋值运算符（Compound_Assignment_Operators）">组合赋值运算符（Compound Assignment Operators）</h2><p>如同 C 语言，Swift 也提供把其他运算符和赋值运算（<code>=</code>）组合的组合赋值运算符，组合加运算（<code>+=</code>）是其中一个例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">a += <span class="number">2</span> <span class="comment">// a 现在是 3</span></span><br></pre></td></tr></table></figure>
<p>表达式<code>a += 2</code>是<code>a = a + 2</code>的简写，一个组合加运算就是把加法运算和赋值运算组合成进一个运算符里，同时完成两个运算任务。</p>
<blockquote>
<p>注意：<br>复合赋值运算没有返回值，<code>let b = a += 2</code>这类代码是错误。这不同于上面提到的自增和自减运算符。</p>
</blockquote>
<p>在<a href="../chapter3/04_Expressions.html">表达式</a>章节里有复合运算符的完整列表。<br>‌<br><a name="comparison_operators"></a></p>
<h2 id="比较运算符">比较运算符</h2><p>所有标准 C 语言中的比较运算都可以在 Swift 中使用：</p>
<ul>
<li>等于（<code>a == b</code>）</li>
<li>不等于（<code>a != b</code>）</li>
<li>大于（<code>a &gt; b</code>）</li>
<li>小于（<code>a &lt; b</code>）</li>
<li>大于等于（<code>a &gt;= b</code>）</li>
<li>小于等于（<code>a &lt;= b</code>）</li>
</ul>
<blockquote>
<p>注意：<br>Swift 也提供恒等<code>===</code>和不恒等<code>!==</code>这两个比较符来判断两个对象是否引用同一个对象实例。更多细节在<a href="../chapter2/09_Classes_and_Structures.html">类与结构</a>。</p>
</blockquote>
<p>每个比较运算都返回了一个标识表达式是否成立的布尔值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> == <span class="number">1</span>   <span class="comment">// true, 因为 1 等于 1</span></span><br><span class="line"><span class="number">2</span> != <span class="number">1</span>   <span class="comment">// true, 因为 2 不等于 1</span></span><br><span class="line"><span class="number">2</span> &gt; <span class="number">1</span>    <span class="comment">// true, 因为 2 大于 1</span></span><br><span class="line"><span class="number">1</span> &lt; <span class="number">2</span>    <span class="comment">// true, 因为 1 小于2</span></span><br><span class="line"><span class="number">1</span> &gt;= <span class="number">1</span>   <span class="comment">// true, 因为 1 大于等于 1</span></span><br><span class="line"><span class="number">2</span> &lt;= <span class="number">1</span>   <span class="comment">// false, 因为 2 并不小于等于 1</span></span><br></pre></td></tr></table></figure>
<p>比较运算多用于条件语句，如<code>if</code>条件：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">"world"</span></span><br><span class="line"><span class="keyword">if</span> name == <span class="string">"world"</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"hello, world"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"I'm sorry <span class="subst">\(name)</span>, but I don't recognize you"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "hello, world", 因为 `name` 就是等于 "world"</span></span><br></pre></td></tr></table></figure>
<p>关于<code>if</code>语句，请看<a href="../chapter2/05_Control_Flow.html">控制流</a>。</p>
<p><a name="ternary_conditional_operator"></a></p>
<h2 id="三目运算符(Ternary_Conditional_Operator)">三目运算符(Ternary Conditional Operator)</h2><p>三目运算符的特殊在于它是有三个操作数的运算符，它的原型是 <code>问题 ? 答案1 : 答案2</code>。它简洁地表达根据<code>问题</code>成立与否作出二选一的操作。如果<code>问题</code>成立，返回<code>答案1</code>的结果; 如果不成立，返回<code>答案2</code>的结果。</p>
<p>三目运算符是以下代码的缩写形式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> question &#123;</span><br><span class="line">	answer1</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	answer2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有个计算表格行高的例子。如果有表头，那行高应比内容高度要高出50点；如果没有表头，只需高出20点：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> contentHeight = <span class="number">40</span></span><br><span class="line"><span class="keyword">let</span> hasHeader = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> rowHeight = contentHeight + (hasHeader ? <span class="number">50</span> : <span class="number">20</span>)</span><br><span class="line"><span class="comment">// rowHeight 现在是 90</span></span><br></pre></td></tr></table></figure>
<p>上面的写法比下面的代码更简洁：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> contentHeight = <span class="number">40</span></span><br><span class="line"><span class="keyword">let</span> hasHeader = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> rowHeight = contentHeight</span><br><span class="line"><span class="keyword">if</span> hasHeader &#123;</span><br><span class="line">	rowHeight = rowHeight + <span class="number">50</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	rowHeight = rowHeight + <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// rowHeight 现在是 90</span></span><br></pre></td></tr></table></figure>
<p>第一段代码例子使用了三目运算，所以一行代码就能让我们得到正确答案。这比第二段代码简洁得多，无需将<code>rowHeight</code>定义成变量，因为它的值无需在<code>if</code>语句中改变。</p>
<p>三目运算提供有效率且便捷的方式来表达二选一的选择。需要注意的事，过度使用三目运算符会使简洁的代码变的难懂。我们应避免在一个组合语句中使用多个三目运算符。</p>
<p><a name="nil_coalescing_operator"></a></p>
<h2 id="空合运算符(Nil_Coalescing_Operator)">空合运算符(Nil Coalescing Operator)</h2><p>空合运算符(<code>a ?? b</code>)将对可选类型<code>a</code>进行空判断，如果<code>a</code>包含一个值就进行解封，否则就返回一个默认值<code>b</code>.这个运算符有两个条件:</p>
<ul>
<li>表达式<code>a</code>必须是Optional类型</li>
<li>默认值<code>b</code>的类型必须要和<code>a</code>存储值的类型保持一致</li>
</ul>
<p>空合运算符是对以下代码的简短表达方法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a != <span class="literal">nil</span> ? a! : b</span><br></pre></td></tr></table></figure>
<p>上述代码使用了三目运算符。当可选类型<code>a</code>的值不为空时，进行强制解封(<code>a!</code>)访问<code>a</code>中值，反之当<code>a</code>中值为空时，返回默认值b。无疑空合运算符(<code>??</code>)提供了一种更为优雅的方式去封装条件判断和解封两种行为，显得简洁以及更具可读性。</p>
<blockquote>
<p>注意：<br>如果<code>a</code>为非空值(<code>non-nil</code>),那么值<code>b</code>将不会被估值。这也就是所谓的短路求值。</p>
</blockquote>
<p>下文例子采用空合运算符，实现了在默认颜色名和可选自定义颜色名之间抉择：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> defaultColorName = <span class="string">"red"</span></span><br><span class="line"><span class="keyword">var</span> userDefinedColorName: <span class="type">String</span>?   <span class="comment">//默认值为 nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colorNameToUse = userDefinedColorName ?? defaultColorName</span><br><span class="line"><span class="comment">// userDefinedColorName 的值为空，所以 colorNameToUse 的值为 "red"</span></span><br></pre></td></tr></table></figure>
<p><code>userDefinedColorName</code>变量被定义为一个可选<code>String</code>类型，默认值为<code>nil</code>。由于<code>userDefinedColorName</code>是一个可选类型，我们可以使用空合运算符去判断其值。在上一个例子中，通过空合运算符为一个名为<code>colorNameToUse</code>的变量赋予一个字符串类型初始值。<br>由于<code>userDefinedColorName</code>值为空，因此表达式<code>userDefinedColorName ?? defaultColorName</code>返回<code>defaultColorName</code>的值，即<code>red</code>。</p>
<p>另一种情况，分配一个非空值(<code>non-nil</code>)给<code>userDefinedColorName</code>，再次执行空合运算，运算结果为封包在<code>userDefaultColorName</code>中的值，而非默认值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userDefinedColorName = <span class="string">"green"</span></span><br><span class="line">colorNameToUse = userDefinedColorName ?? defaultColorName</span><br><span class="line"><span class="comment">// userDefinedColorName 非空，因此 colorNameToUse 的值为 "green"</span></span><br></pre></td></tr></table></figure>
<p><a name="range_operators"></a></p>
<h2 id="区间运算符">区间运算符</h2><p>Swift 提供了两个方便表达一个区间的值的运算符。</p>
<h3 id="闭区间运算符">闭区间运算符</h3><p>闭区间运算符（<code>a...b</code>）定义一个包含从<code>a</code>到<code>b</code>(包括<code>a</code>和<code>b</code>)的所有值的区间，<code>b</code>必须大于等于<code>a</code>。<br>‌<br>闭区间运算符在迭代一个区间的所有值时是非常有用的，如在<code>for-in</code>循环中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span>...<span class="number">5</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"<span class="subst">\(index)</span> * 5 = <span class="subst">\(index * <span class="number">5</span>)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 * 5 = 5</span></span><br><span class="line"><span class="comment">// 2 * 5 = 10</span></span><br><span class="line"><span class="comment">// 3 * 5 = 15</span></span><br><span class="line"><span class="comment">// 4 * 5 = 20</span></span><br><span class="line"><span class="comment">// 5 * 5 = 25</span></span><br></pre></td></tr></table></figure>
<p>关于<code>for-in</code>，请看<a href="../chapter2/05_Control_Flow.html">控制流</a>。</p>
<h3 id="半开区间运算符">半开区间运算符</h3><p>半开区间（<code>a..&lt;b</code>）定义一个从<code>a</code>到<code>b</code>但不包括<code>b</code>的区间。<br>之所以称为半开区间，是因为该区间包含第一个值而不包括最后的值。</p>
<p>半开区间的实用性在于当你使用一个从0开始的列表(如数组)时，非常方便地从0数到列表的长度。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [<span class="string">"Anna"</span>, <span class="string">"Alex"</span>, <span class="string">"Brian"</span>, <span class="string">"Jack"</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="built_in">count</span> = names.<span class="built_in">count</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="built_in">count</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"第 <span class="subst">\(i + <span class="number">1</span>)</span> 个人叫 <span class="subst">\(names[i])</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第 1 个人叫 Anna</span></span><br><span class="line"><span class="comment">// 第 2 个人叫 Alex</span></span><br><span class="line"><span class="comment">// 第 3 个人叫 Brian</span></span><br><span class="line"><span class="comment">// 第 4 个人叫 Jack</span></span><br></pre></td></tr></table></figure>
<p>数组有4个元素，但<code>0..&lt;count</code>只数到3(最后一个元素的下标)，因为它是半开区间。关于数组，请查阅<a href="../chapter2/04_Collection_Types.html#arrays">数组</a>。</p>
<p><a name="logical_operators"></a></p>
<h2 id="逻辑运算">逻辑运算</h2><p>逻辑运算的操作对象是逻辑布尔值。Swift 支持基于 C 语言的三个标准逻辑运算。</p>
<ul>
<li>逻辑非（<code>!a</code>）</li>
<li>逻辑与（<code>a &amp;&amp; b</code>）</li>
<li>逻辑或（<code>a || b</code>）</li>
</ul>
<h3 id="逻辑非">逻辑非</h3><p>逻辑非运算（<code>!a</code>）对一个布尔值取反，使得<code>true</code>变<code>false</code>，<code>false</code>变<code>true</code>。</p>
<p>它是一个前置运算符，需紧跟在操作数之前，且不加空格。读作<code>非 a</code>，例子如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> allowedEntry = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> !allowedEntry &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"ACCESS DENIED"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "ACCESS DENIED"</span></span><br></pre></td></tr></table></figure>
<p><code>if !allowedEntry</code>语句可以读作“如果非 allowedEntry。”，接下一行代码只有在“非 allowedEntry”为<code>true</code>，即<code>allowEntry</code>为<code>false</code>时被执行。</p>
<p>在示例代码中，小心地选择布尔常量或变量有助于代码的可读性，并且避免使用双重逻辑非运算，或混乱的逻辑语句。</p>
<h3 id="逻辑与">逻辑与</h3><p>逻辑与（<code>a &amp;&amp; b</code>）表达了只有<code>a</code>和<code>b</code>的值都为<code>true</code>时，整个表达式的值才会是<code>true</code>。</p>
<p>只要任意一个值为<code>false</code>，整个表达式的值就为<code>false</code>。事实上，如果第一个值为<code>false</code>，那么是不去计算第二个值的，因为它已经不可能影响整个表达式的结果了。这被称做“短路计算（short-circuit evaluation）”。</p>
<p>以下例子，只有两个<code>Bool</code>值都为<code>true</code>的时候才允许进入：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> enteredDoorCode = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> passedRetinaScan = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> enteredDoorCode &amp;&amp; passedRetinaScan &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Welcome!"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"ACCESS DENIED"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "ACCESS DENIED"</span></span><br></pre></td></tr></table></figure>
<h3 id="逻辑或">逻辑或</h3><p>逻辑或（<code>a || b</code>）是一个由两个连续的<code>|</code>组成的中置运算符。它表示了两个逻辑表达式的其中一个为<code>true</code>，整个表达式就为<code>true</code>。</p>
<p>同逻辑与运算类似，逻辑或也是“短路计算”的，当左端的表达式为<code>true</code>时，将不计算右边的表达式了，因为它不可能改变整个表达式的值了。</p>
<p>以下示例代码中，第一个布尔值（<code>hasDoorKey</code>）为<code>false</code>，但第二个值（<code>knowsOverridePassword</code>）为<code>true</code>，所以整个表达是<code>true</code>，于是允许进入：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hasDoorKey = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> knowsOverridePassword = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> hasDoorKey || knowsOverridePassword &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Welcome!"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"ACCESS DENIED"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "Welcome!"</span></span><br></pre></td></tr></table></figure>
<h3 id="逻辑运算符组合计算">逻辑运算符组合计算</h3><p>我们可以组合多个逻辑运算来表达一个复合逻辑：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> enteredDoorCode &amp;&amp; passedRetinaScan || hasDoorKey || knowsOverridePassword &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Welcome!"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"ACCESS DENIED"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "Welcome!"</span></span><br></pre></td></tr></table></figure>
<p>这个例子使用了含多个<code>&amp;&amp;</code>和<code>||</code>的复合逻辑。但无论怎样，<code>&amp;&amp;</code>和<code>||</code>始终只能操作两个值。所以这实际是三个简单逻辑连续操作的结果。我们来解读一下：</p>
<p>如果我们输入了正确的密码并通过了视网膜扫描，或者我们有一把有效的钥匙，又或者我们知道紧急情况下重置的密码，我们就能把门打开进入。</p>
<p>前两种情况，我们都不满足，所以前两个简单逻辑的结果是<code>false</code>，但是我们是知道紧急情况下重置的密码的，所以整个复杂表达式的值还是<code>true</code>。</p>
<blockquote>
<p>注意：<br>Swift 逻辑操作符<code>&amp;&amp;</code>和<code>||</code>是左结合的，这意味着拥有多元逻辑操作符的复合表达式优先计算最左边的子表达式。</p>
</blockquote>
<h3 id="使用括号来明确优先级">使用括号来明确优先级</h3><p>为了一个复杂表达式更容易读懂，在合适的地方使用括号来明确优先级是很有效的，虽然它并非必要的。在上个关于门的权限的例子中，我们给第一个部分加个括号，使它看起来逻辑更明确：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (enteredDoorCode &amp;&amp; passedRetinaScan) || hasDoorKey || knowsOverridePassword &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Welcome!"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"ACCESS DENIED"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "Welcome!"</span></span><br></pre></td></tr></table></figure>
<p>这括号使得前两个值被看成整个逻辑表达中独立的一个部分。虽然有括号和没括号的输出结果是一样的，但对于读代码的人来说有括号的代码更清晰。可读性比简洁性更重要，请在可以让你代码变清晰的地方加个括号吧！</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/03_Strings_and_Characters/" itemprop="url">
                第二章-03字符串和字符（Strings and Characters）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:24+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/03_Strings_and_Characters/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/03_Strings_and_Characters/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="字符串和字符（Strings_and_Characters）">字符串和字符（Strings and Characters）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/wh1100717" target="_blank" rel="external">wh1100717</a><br>校对：<a href="https://github.com/Hawstein" target="_blank" rel="external">Hawstein</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/DianQK" target="_blank" rel="external">DianQK</a></p>
<p>2.1<br>翻译：<a href="https://github.com/DianQK" target="_blank" rel="external">DianQK</a><br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#string_literals">字符串字面量</a></li>
<li><a href="#initializing_an_empty_string">初始化空字符串</a></li>
<li><a href="#string_mutability">字符串可变性</a></li>
<li><a href="#strings_are_value_types">字符串是值类型</a></li>
<li><a href="#working_with_characters">使用字符</a></li>
<li><a href="#concatenating_strings_and_characters">连接字符串和字符</a></li>
<li><a href="#string_interpolation">字符串插值</a></li>
<li><a href="#unicode">Unicode</a></li>
<li><a href="#counting_characters">计算字符数量</a></li>
<li><a href="#accessing_and_modifying_a_string">访问和修改字符串</a></li>
<li><a href="#comparing_strings">比较字符串</a></li>
<li><a href="#unicode_representations_of_strings">字符串的 Unicode 表示形式</a></li>
</ul>
<p><code>String</code>是例如”hello, world”，”albatross”这样的有序的<code>Character</code>（字符）类型的值的集合。通过<code>String</code>类型来表示。<br>一个<code>String</code>的内容可以用变量的方式读取，它包括一个<code>Character</code>值的集合。<br>创建和操作字符串的语法与 C 语言中字符串操作相似，轻量并且易读。<br>字符串连接操作只需要简单地通过<code>+</code>符号将两个字符串相连即可。与 Swift 中其他值一样，能否更改字符串的值，取决于其被定义为常量还是变量。你也可以在字符串内插过程中使用字符串插入常量、变量、字面量表达成更长的字符串，这样可以很容易的创建自定义的字符串值，进行展示、存储以及打印。<br>尽管语法简易，但<code>String</code>类型是一种快速、现代化的字符串实现。<br>每一个字符串都是由编码无关的 Unicode 字符组成，并支持访问字符的多种 Unicode 表示形式（representations）。</p>
<blockquote>
<p>注意：<br>Swift 的<code>String</code>类型与 Foundation <code>NSString</code>类进行了无缝桥接。就像 <a href="./19_Type_Casting.html#anyobject"><code>AnyObject</code>类型</a> 中提到的一样，在使用 Cocoa 中的 Foundation 框架时，您可以将创建的任何字符串的值转换成<code>NSString</code>，并调用任意的<code>NSString</code> API。您也可以在任意要求传入<code>NSString</code>实例作为参数的 API 中用<code>String</code>类型的值代替。<br>更多关于在 Foundation 和 Cocoa 中使用<code>String</code>的信息请查看 <em><a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216" target="_blank" rel="external">Using Swift with Cocoa and Objective-C (Swift 2.1)</a></em>。</p>
</blockquote>
<p><a name="string_literals"></a></p>
<h2 id="字符串字面量（String_Literals）">字符串字面量（String Literals）</h2><p>您可以在您的代码中包含一段预定义的字符串值作为字符串字面量。字符串字面量是由双引号 (<code>&quot;&quot;</code>) 包裹着的具有固定顺序的文本字符集。<br>字符串字面量可以用于为常量和变量提供初始值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someString = <span class="string">"Some string literal value"</span></span><br></pre></td></tr></table></figure>
<p>注意<code>someString</code>常量通过字符串字面量进行初始化，Swift 会推断该常量为<code>String</code>类型。</p>
<blockquote>
<p>注意：<br>更多关于在字符串字面量中使用特殊字符的信息，请查看 <a href="#special_characters_in_string_literals">字符串字面量的特殊字符</a> 。</p>
</blockquote>
<p><a name="initializing_an_empty_string"></a></p>
<h2 id="初始化空字符串_(Initializing_an_Empty_String)">初始化空字符串 (Initializing an Empty String)</h2><p>要创建一个空字符串作为初始值，可以将空的字符串字面量赋值给变量，也可以初始化一个新的<code>String</code>实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emptyString = <span class="string">""</span>               <span class="comment">// 空字符串字面量</span></span><br><span class="line"><span class="keyword">var</span> anotherEmptyString = <span class="type">String</span>()  <span class="comment">// 初始化方法</span></span><br><span class="line"><span class="comment">// 两个字符串均为空并等价。</span></span><br></pre></td></tr></table></figure>
<p>您可以通过检查其<code>Boolean</code>类型的<code>isEmpty</code>属性来判断该字符串是否为空：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> emptyString.isEmpty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Nothing to see here"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印输出："Nothing to see here"</span></span><br></pre></td></tr></table></figure>
<p><a name="string_mutability"></a></p>
<h2 id="字符串可变性_(String_Mutability)">字符串可变性 (String Mutability)</h2><p>您可以通过将一个特定字符串分配给一个变量来对其进行修改，或者分配给一个常量来保证其不会被修改：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> variableString = <span class="string">"Horse"</span></span><br><span class="line">variableString += <span class="string">" and carriage"</span></span><br><span class="line"><span class="comment">// variableString 现在为 "Horse and carriage"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> constantString = <span class="string">"Highlander"</span></span><br><span class="line">constantString += <span class="string">" and another Highlander"</span></span><br><span class="line"><span class="comment">// 这会报告一个编译错误 (compile-time error) - 常量字符串不可以被修改。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>在 Objective-C 和 Cocoa 中，您需要通过选择两个不同的类(<code>NSString</code>和<code>NSMutableString</code>)来指定字符串是否可以被修改。</p>
</blockquote>
<p><a name="strings_are_value_types"></a></p>
<h2 id="字符串是值类型（Strings_Are_Value_Types）">字符串是值类型（Strings Are Value Types）</h2><p>Swift 的<code>String</code>类型是值类型。<br>如果您创建了一个新的字符串，那么当其进行常量、变量赋值操作，或在函数/方法中传递时，会进行值拷贝。<br>任何情况下，都会对已有字符串值创建新副本，并对该新副本进行传递或赋值操作。<br>值类型在 <a href="./09_Classes_and_Structures.html#structures_and_enumerations_are_value_types">结构体和枚举是值类型</a> 中进行了详细描述。</p>
<p>Swift 默认字符串拷贝的方式保证了在函数/方法中传递的是字符串的值。<br>很明显无论该值来自于哪里，都是您独自拥有的。<br>您可以确信传递的字符串不会被修改，除非你自己去修改它。</p>
<p>在实际编译时，Swift 编译器会优化字符串的使用，使实际的复制只发生在绝对必要的情况下，这意味着您将字符串作为值类型的同时可以获得极高的性能。</p>
<p><a name="working_with_characters"></a></p>
<h2 id="使用字符（Working_with_Characters）">使用字符（Working with Characters）</h2><p>您可通过<code>for-in</code>循环来遍历字符串中的<code>characters</code>属性来获取每一个字符的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> character <span class="keyword">in</span> <span class="string">"Dog!🐶"</span>.characters &#123;</span><br><span class="line">    <span class="built_in">print</span>(character)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// D</span></span><br><span class="line"><span class="comment">// o</span></span><br><span class="line"><span class="comment">// g</span></span><br><span class="line"><span class="comment">// !</span></span><br><span class="line"><span class="comment">// 🐶</span></span><br></pre></td></tr></table></figure>
<p><code>for-in</code>循环在 <a href="./05_Control_Flow.html#for_loops">For 循环</a> 中进行了详细描述。</p>
<p>另外，通过标明一个<code>Character</code>类型并用字符字面量进行赋值，可以建立一个独立的字符常量或变量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> exclamationMark: <span class="type">Character</span> = <span class="string">"!"</span></span><br></pre></td></tr></table></figure>
<p>字符串可以通过传递一个值类型为<code>Character</code>的数组作为自变量来初始化：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> catCharacters: [<span class="type">Character</span>] = [<span class="string">"C"</span>, <span class="string">"a"</span>, <span class="string">"t"</span>, <span class="string">"!"</span>, <span class="string">"🐱"</span>]</span><br><span class="line"><span class="keyword">let</span> catString = <span class="type">String</span>(catCharacters)</span><br><span class="line"><span class="built_in">print</span>(catString)</span><br><span class="line"><span class="comment">// 打印输出："Cat!🐱"</span></span><br></pre></td></tr></table></figure>
<p><a name="concatenating_strings_and_characters"></a></p>
<h2 id="连接字符串和字符_(Concatenating_Strings_and_Characters)">连接字符串和字符 (Concatenating Strings and Characters)</h2><p>字符串可以通过加法运算符（<code>+</code>）相加在一起（或称“连接”）创建一个新的字符串：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> string1 = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">let</span> string2 = <span class="string">" there"</span></span><br><span class="line"><span class="keyword">var</span> welcome = string1 + string2</span><br><span class="line"><span class="comment">// welcome 现在等于 "hello there"</span></span><br></pre></td></tr></table></figure>
<p>您也可以通过加法赋值运算符 (<code>+=</code>) 将一个字符串添加到一个已经存在字符串变量上：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instruction = <span class="string">"look over"</span></span><br><span class="line">instruction += string2</span><br><span class="line"><span class="comment">// instruction 现在等于 "look over there"</span></span><br></pre></td></tr></table></figure>
<p>您可以用<code>append()</code>方法将一个字符附加到一个字符串变量的尾部：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> exclamationMark: <span class="type">Character</span> = <span class="string">"!"</span></span><br><span class="line">welcome.append(exclamationMark)</span><br><span class="line"><span class="comment">// welcome 现在等于 "hello there!"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>您不能将一个字符串或者字符添加到一个已经存在的字符变量上，因为字符变量只能包含一个字符。</p>
</blockquote>
<p><a name="string_interpolation"></a></p>
<h2 id="字符串插值_(String_Interpolation)">字符串插值 (String Interpolation)</h2><p>字符串插值是一种构建新字符串的方式，可以在其中包含常量、变量、字面量和表达式。<br>您插入的字符串字面量的每一项都在以反斜线为前缀的圆括号中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> multiplier = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> message = <span class="string">"<span class="subst">\(multiplier)</span> times 2.5 is <span class="subst">\(Double(multiplier)</span> * 2.5)"</span></span><br><span class="line"><span class="comment">// message is "3 times 2.5 is 7.5"</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>multiplier</code>作为<code>\(multiplier)</code>被插入到一个字符串常量量中。<br>当创建字符串执行插值计算时此占位符会被替换为<code>multiplier</code>实际的值。</p>
<p><code>multiplier</code>的值也作为字符串中后面表达式的一部分。<br>该表达式计算<code>Double(multiplier) * 2.5</code>的值并将结果 (<code>7.5</code>) 插入到字符串中。<br>在这个例子中，表达式写为<code>\(Double(multiplier) * 2.5)</code>并包含在字符串字面量中。</p>
<blockquote>
<p>注意：<br>插值字符串中写在括号中的表达式不能包含非转义反斜杠 (<code>\</code>)，并且不能包含回车或换行符。不过，插值字符串可以包含其他字面量。</p>
</blockquote>
<p><a name="unicode"></a></p>
<h2 id="Unicode">Unicode</h2><p>Unicode 是一个国际标准，用于文本的编码和表示。<br>它使您可以用标准格式表示来自任意语言几乎所有的字符，并能够对文本文件或网页这样的外部资源中的字符进行读写操作。<br>Swift 的<code>String</code>和<code>Character</code>类型是完全兼容 Unicode 标准的。</p>
<p><a name="unicode_scalars"></a></p>
<h3 id="Unicode_标量（Unicode_Scalars）">Unicode 标量（Unicode Scalars）</h3><p>Swift 的<code>String</code>类型是基于 <em>Unicode 标量</em> 建立的。<br>Unicode 标量是对应字符或者修饰符的唯一的21位数字，例如<code>U+0061</code>表示小写的拉丁字母(<code>LATIN SMALL LETTER A</code>)(“<code>a</code>“)，<code>U+1F425</code>表示小鸡表情(<code>FRONT-FACING BABY CHICK</code>) (“<code>🐥</code>“)。</p>
<blockquote>
<p>注意：<br>Unicode <em>码位(code poing)</em> 的范围是<code>U+0000</code>到<code>U+D7FF</code>或者<code>U+E000</code>到<code>U+10FFFF</code>。Unicode 标量不包括 Unicode <em>代理项(surrogate pair)</em> 码位，其码位范围是<code>U+D800</code>到<code>U+DFFF</code>。</p>
</blockquote>
<p>注意不是所有的21位 Unicode 标量都代表一个字符，因为有一些标量是留作未来分配的。已经代表一个典型字符的标量都有自己的名字，例如上面例子中的<code>LATIN SMALL LETTER A</code>和<code>FRONT-FACING BABY CHICK</code>。</p>
<p><a name="special_characters_in_string_literals"></a></p>
<h3 id="字符串字面量的特殊字符_(Special_Characters_in_String_Literals)">字符串字面量的特殊字符 (Special Characters in String Literals)</h3><p>字符串字面量可以包含以下特殊字符：</p>
<ul>
<li>转义字符<code>\0</code>(空字符)、<code>\\</code>(反斜线)、<code>\t</code>(水平制表符)、<code>\n</code>(换行符)、<code>\r</code>(回车符)、<code>\&quot;</code>(双引号)、<code>\&#39;</code>(单引号)。</li>
<li>Unicode 标量，写成<code>\u{n}</code>(u为小写)，其中<code>n</code>为任意一到八位十六进制数且可用的 Unicode 位码。</li>
</ul>
<p>下面的代码为各种特殊字符的使用示例。<br><code>wiseWords</code>常量包含了两个双引号。<br><code>dollarSign</code>、<code>blackHeart</code>和<code>sparklingHeart</code>常量演示了三种不同格式的 Unicode 标量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wiseWords = <span class="string">"\"Imagination is more important than knowledge\" - Einstein"</span></span><br><span class="line"><span class="comment">// "Imageination is more important than knowledge" - Enistein</span></span><br><span class="line"><span class="keyword">let</span> dollarSign = <span class="string">"\u&#123;24&#125;"</span>             <span class="comment">// $, Unicode 标量 U+0024</span></span><br><span class="line"><span class="keyword">let</span> blackHeart = <span class="string">"\u&#123;2665&#125;"</span>           <span class="comment">// ♥, Unicode 标量 U+2665</span></span><br><span class="line"><span class="keyword">let</span> sparklingHeart = <span class="string">"\u&#123;1F496&#125;"</span>      <span class="comment">// 💖, Unicode 标量 U+1F496</span></span><br></pre></td></tr></table></figure>
<p><a name="extended_grapheme_clusters"></a></p>
<h3 id="可扩展的字形群集(Extended_Grapheme_Clusters)">可扩展的字形群集(Extended Grapheme Clusters)</h3><p>每一个 Swift 的<code>Character</code>类型代表一个可扩展的字形群。<br>一个可扩展的字形群是一个或多个可生成人类可读的字符 Unicode 标量的有序排列。<br>举个例子，字母<code>é</code>可以用单一的 Unicode 标量<code>é</code>(<code>LATIN SMALL LETTER E WITH ACUTE</code>, 或者<code>U+00E9</code>)来表示。然而一个标准的字母<code>e</code>(<code>LATIN SMALL LETTER E</code>或者<code>U+0065</code>) 加上一个急促重音(<code>COMBINING ACTUE ACCENT</code>)的标量(<code>U+0301</code>)，这样一对标量就表示了同样的字母<code>é</code>。<br>这个急促重音的标量形象的将<code>e</code>转换成了<code>é</code>。</p>
<p>在这两种情况中，字母<code>é</code>代表了一个单一的 Swift 的<code>Character</code>值，同时代表了一个可扩展的字形群。<br>在第一种情况，这个字形群包含一个单一标量；而在第二种情况，它是包含两个标量的字形群：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> eAcute: <span class="type">Character</span> = <span class="string">"\u&#123;E9&#125;"</span>                         <span class="comment">// é</span></span><br><span class="line"><span class="keyword">let</span> combinedEAcute: <span class="type">Character</span> = <span class="string">"\u&#123;65&#125;\u&#123;301&#125;"</span>          <span class="comment">// e 后面加上  ́</span></span><br><span class="line"><span class="comment">// eAcute 是 é, combinedEAcute 是 é</span></span><br></pre></td></tr></table></figure>
<p>可扩展的字符群集是一个灵活的方法，用许多复杂的脚本字符表示单一的<code>Character</code>值。<br>例如，来自朝鲜语字母表的韩语音节能表示为组合或分解的有序排列。<br>在 Swift 都会表示为同一个单一的<code>Character</code>值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> precomposed: <span class="type">Character</span> = <span class="string">"\u&#123;D55C&#125;"</span>                  <span class="comment">// 한</span></span><br><span class="line"><span class="keyword">let</span> decomposed: <span class="type">Character</span> = <span class="string">"\u&#123;1112&#125;\u&#123;1161&#125;\u&#123;11AB&#125;"</span>   <span class="comment">// ᄒ, ᅡ, ᆫ</span></span><br><span class="line"><span class="comment">// precomposed 是 한, decomposed 是 한</span></span><br></pre></td></tr></table></figure>
<p>可拓展的字符群集可以使包围记号(例如<code>COMBINING ENCLOSING CIRCLE</code>或者<code>U+20DD</code>)的标量包围其他 Unicode 标量，作为一个单一的<code>Character</code>值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> enclosedEAcute: <span class="type">Character</span> = <span class="string">"\u&#123;E9&#125;\u&#123;20DD&#125;"</span></span><br><span class="line"><span class="comment">// enclosedEAcute 是 é⃝</span></span><br></pre></td></tr></table></figure>
<p>局部的指示符号的 Unicode 标量可以组合成一个单一的<code>Character</code>值，例如<code>REGIONAL INDICATOR SYMBOL LETTER U</code>(<code>U+1F1FA</code>)和<code>REGIONAL INDICATOR SYMBOL LETTER S</code>(<code>U+1F1F8</code>)：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regionalIndicatorForUS: <span class="type">Character</span> = <span class="string">"\u&#123;1F1FA&#125;\u&#123;1F1F8&#125;"</span></span><br><span class="line"><span class="comment">// regionalIndicatorForUS 是 🇺🇸</span></span><br></pre></td></tr></table></figure>
<p><a name="counting_characters"></a></p>
<h2 id="计算字符数量_(Counting_Characters)">计算字符数量 (Counting Characters)</h2><p>如果想要获得一个字符串中<code>Character</code>值的数量，可以使用字符串的<code>characters</code>属性的<code>count</code>属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unusualMenagerie = <span class="string">"Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"unusualMenagerie has <span class="subst">\(unusualMenagerie.characters.<span class="built_in">count</span>)</span> characters"</span>)</span><br><span class="line"><span class="comment">// 打印输出 "unusualMenagerie has 40 characters"</span></span><br></pre></td></tr></table></figure>
<p>注意在 Swift 中，使用可拓展的字符群集作为<code>Character</code>值来连接或改变字符串时，并不一定会更改字符串的字符数量。</p>
<p>例如，如果你用四个字符的单词<code>cafe</code>初始化一个新的字符串，然后添加一个<code>COMBINING ACTUE ACCENT</code>(<code>U+0301</code>)作为字符串的结尾。最终这个字符串的字符数量仍然是<code>4</code>，因为第四个字符是<code>é</code>，而不是<code>e</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> word = <span class="string">"cafe"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"the number of characters in <span class="subst">\(word)</span> is <span class="subst">\(word.characters.<span class="built_in">count</span>)</span>"</span>)</span><br><span class="line"><span class="comment">// 打印输出 "the number of characters in cafe is 4"</span></span><br><span class="line"></span><br><span class="line">word += <span class="string">"\u&#123;301&#125;"</span>    <span class="comment">// COMBINING ACUTE ACCENT, U+0301</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"the number of characters in <span class="subst">\(word)</span> is <span class="subst">\(word.characters.<span class="built_in">count</span>)</span>"</span>)</span><br><span class="line"><span class="comment">// 打印输出 "the number of characters in café is 4"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>可扩展的字符群集可以组成一个或者多个 Unicode 标量。这意味着不同的字符以及相同字符的不同表示方式可能需要不同数量的内存空间来存储。所以 Swift 中的字符在一个字符串中并不一定占用相同的内存空间数量。因此在没有获取字符串的可扩展的字符群的范围时候，就不能计算出字符串的字符数量。如果您正在处理一个长字符串，需要注意<code>characters</code>属性必须遍历全部的 Unicode 标量，来确定字符串的字符数量。</p>
<p>另外需要注意的是通过<code>characters</code>属性返回的字符数量并不总是与包含相同字符的<code>NSString</code>的<code>length</code>属性相同。<code>NSString</code>的<code>length</code>属性是利用 UTF-16 表示的十六位代码单元数字，而不是 Unicode 可扩展的字符群集。作为佐证，当一个<code>NSString</code>的<code>length</code>属性被一个Swift的<code>String</code>值访问时，实际上是调用了<code>utf16Count</code>。</p>
</blockquote>
<p><a name="accessing_and_modifying_a_string"></a></p>
<h2 id="访问和修改字符串_(Accessing_and_Modifying_a_String)">访问和修改字符串 (Accessing and Modifying a String)</h2><p>你可以通字符串的属性和方法来访问和读取它，当然也可以用下标语法完成。</p>
<p><a name="string_indices"></a></p>
<h3 id="字符串索引_(String_Indices)">字符串索引 (String Indices)</h3><p>每一个<code>String</code>值都有一个关联的索引(<em>index</em>)类型，<code>String.Index</code>，它对应着字符串中的每一个<code>Character</code>的位置。</p>
<p>前面提到，不同的字符可能会占用不同数量的内存空间，所以要知道<code>Character</code>的确定位置，就必须从<code>String</code>开头遍历每一个 Unicode 标量直到结尾。因此，Swift 的字符串不能用整数(integer)做索引。</p>
<p>使用<code>startIndex</code>属性可以获取一个<code>String</code>的第一个<code>Character</code>的索引。使用<code>endIndex</code>属性可以获取最后一个<code>Character</code>的后一个位置的索引。因此，<code>endIndex</code>属性不能作为一个字符串的有效下标。如果<code>String</code>是空串，<code>startIndex</code>和<code>endIndex</code>是相等的。</p>
<p>通过调用<code>String.Index</code>的<code>predecessor()</code>方法，可以立即得到前面一个索引，调用<code>successor()</code>方法可以立即得到后面一个索引。任何一个<code>String</code>的索引都可以通过锁链作用的这些方法来获取另一个索引，也可以调用<code>advancedBy(_:)</code>方法来获取。但如果尝试获取出界的字符串索引，就会抛出一个运行时错误。</p>
<p>你可以使用下标语法来访问<code>String</code>特定索引的<code>Character</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting = <span class="string">"Guten Tag!"</span></span><br><span class="line">greeting[greeting.startIndex]</span><br><span class="line"><span class="comment">// G</span></span><br><span class="line">greeting[greeting.endIndex.predecessor()]</span><br><span class="line"><span class="comment">// !</span></span><br><span class="line">greeting[greeting.startIndex.successor()]</span><br><span class="line"><span class="comment">// u</span></span><br><span class="line"><span class="keyword">let</span> index = greeting.startIndex.advancedBy(<span class="number">7</span>)</span><br><span class="line">greeting[index]</span><br><span class="line"><span class="comment">// a</span></span><br></pre></td></tr></table></figure>
<p>试图获取越界索引对应的<code>Character</code>，将引发一个运行时错误。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">greeting[greeting.endIndex] <span class="comment">// error</span></span><br><span class="line">greeting.endIndex.successor() <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<p>使用<code>characters</code>属性的<code>indices</code>属性会创建一个包含全部索引的范围(<code>Range</code>)，用来在一个字符串中访问单个字符。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> greeting.characters.<span class="built_in">indices</span> &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"<span class="subst">\(greeting[index])</span> "</span>, terminator: <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印输出 "G u t e n   T a g !"</span></span><br></pre></td></tr></table></figure>
<p><a name="inserting_and_removing"></a></p>
<h3 id="插入和删除_(Inserting_and_Removing)">插入和删除 (Inserting and Removing)</h3><p>调用<code>insert(_:atIndex:)</code>方法可以在一个字符串的指定索引插入一个字符。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> welcome = <span class="string">"hello"</span></span><br><span class="line">welcome.insert(<span class="string">"!"</span>, atIndex: welcome.endIndex)</span><br><span class="line"><span class="comment">// welcome now 现在等于 "hello!"</span></span><br></pre></td></tr></table></figure>
<p>调用<code>insertContentsOf(_:at:)</code>方法可以在一个字符串的指定索引插入一个字符串。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">welcome.insertContentsOf(<span class="string">" there"</span>.characters, at: welcome.endIndex.predecessor())</span><br><span class="line"><span class="comment">// welcome 现在等于 "hello there!"</span></span><br></pre></td></tr></table></figure>
<p>调用<code>removeAtIndex(_:)</code>方法可以在一个字符串的指定索引删除一个字符。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">welcome.removeAtIndex(welcome.endIndex.predecessor())</span><br><span class="line"><span class="comment">// welcome 现在等于 "hello there"</span></span><br></pre></td></tr></table></figure>
<p>调用<code>removeRange(_:)</code>方法可以在一个字符串的指定索引删除一个子字符串。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> range = welcome.endIndex.advancedBy(-<span class="number">6</span>)..&lt;welcome.endIndex</span><br><span class="line">welcome.removeRange(range)</span><br><span class="line"><span class="comment">// welcome 现在等于 "hello"</span></span><br></pre></td></tr></table></figure>
<p><a name="comparing_strings"></a></p>
<h2 id="比较字符串_(Comparing_Strings)">比较字符串 (Comparing Strings)</h2><p>Swift 提供了三种方式来比较文本值：字符串字符相等、前缀相等和后缀相等。</p>
<p><a name="string_and_character_equality"></a></p>
<h3 id="字符串/字符相等_(String_and_Character_Equality)">字符串/字符相等 (String and Character Equality)</h3><p>字符串/字符可以用等于操作符(<code>==</code>)和不等于操作符(<code>!=</code>)，详细描述在<a href="./02_Basic_Operators.html#comparison_operators">比较运算符</a>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> quotation = <span class="string">"We're a lot alike, you and I."</span></span><br><span class="line"><span class="keyword">let</span> sameQuotation = <span class="string">"We're a lot alike, you and I."</span></span><br><span class="line"><span class="keyword">if</span> quotation == sameQuotation &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"These two strings are considered equal"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印输出 "These two strings are considered equal"</span></span><br></pre></td></tr></table></figure>
<p>如果两个字符串（或者两个字符）的可扩展的字形群集是标准相等的，那就认为它们是相等的。在这个情况下，即使可扩展的字形群集是有不同的 Unicode 标量构成的，只要它们有同样的语言意义和外观，就认为它们标准相等。</p>
<p>例如，<code>LATIN SMALL LETTER E WITH ACUTE</code>(<code>U+00E9</code>)就是标准相等于<code>LATIN SMALL LETTER E</code>(<code>U+0065</code>)后面加上<code>COMBINING ACUTE ACCENT</code>(<code>U+0301</code>)。这两个字符群集都是表示字符<code>é</code>的有效方式，所以它们被认为是标准相等的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// "Voulez-vous un café?" 使用 LATIN SMALL LETTER E WITH ACUTE</span></span><br><span class="line"><span class="keyword">let</span> eAcuteQuestion = <span class="string">"Voulez-vous un caf\u&#123;E9&#125;?"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// "Voulez-vous un café?" 使用 LATIN SMALL LETTER E and COMBINING ACUTE ACCENT</span></span><br><span class="line"><span class="keyword">let</span> combinedEAcuteQuestion = <span class="string">"Voulez-vous un caf\u&#123;65&#125;\u&#123;301&#125;?"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> eAcuteQuestion == combinedEAcuteQuestion &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"These two strings are considered equal"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印输出 "These two strings are considered equal"</span></span><br></pre></td></tr></table></figure>
<p>相反，英语中的<code>LATIN CAPITAL LETTER A</code>(<code>U+0041</code>，或者<code>A</code>)不等于俄语中的<code>CYRILLIC CAPITAL LETTER A</code>(<code>U+0410</code>，或者<code>A</code>)。两个字符看着是一样的，但却有不同的语言意义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> latinCapitalLetterA: <span class="type">Character</span> = <span class="string">"\u&#123;41&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cyrillicCapitalLetterA: <span class="type">Character</span> = <span class="string">"\u&#123;0410&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> latinCapitalLetterA != cyrillicCapitalLetterA &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"These two characters are not equivalent"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "These two characters are not equivalent"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>在 Swift 中，字符串和字符并不区分区域。</p>
</blockquote>
<p><a name="prefix_and_suffix_equality"></a></p>
<h3 id="前缀/后缀相等_(Prefix_and_Suffix_Equality)">前缀/后缀相等 (Prefix and Suffix Equality)</h3><p>通过调用字符串的<code>hasPrefix(_:)</code>/<code>hasSuffix(_:)</code>方法来检查字符串是否拥有特定前缀/后缀，两个方法均接收一个<code>String</code>类型的参数，并返回一个布尔值。</p>
<p>下面的例子以一个字符串数组表示莎士比亚话剧《罗密欧与朱丽叶》中前两场的场景位置：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> romeoAndJuliet = [</span><br><span class="line">    <span class="string">"Act 1 Scene 1: Verona, A public place"</span>,</span><br><span class="line">    <span class="string">"Act 1 Scene 2: Capulet's mansion"</span>,</span><br><span class="line">    <span class="string">"Act 1 Scene 3: A room in Capulet's mansion"</span>,</span><br><span class="line">    <span class="string">"Act 1 Scene 4: A street outside Capulet's mansion"</span>,</span><br><span class="line">    <span class="string">"Act 1 Scene 5: The Great Hall in Capulet's mansion"</span>,</span><br><span class="line">    <span class="string">"Act 2 Scene 1: Outside Capulet's mansion"</span>,</span><br><span class="line">    <span class="string">"Act 2 Scene 2: Capulet's orchard"</span>,</span><br><span class="line">    <span class="string">"Act 2 Scene 3: Outside Friar Lawrence's cell"</span>,</span><br><span class="line">    <span class="string">"Act 2 Scene 4: A street in Verona"</span>,</span><br><span class="line">    <span class="string">"Act 2 Scene 5: Capulet's mansion"</span>,</span><br><span class="line">    <span class="string">"Act 2 Scene 6: Friar Lawrence's cell"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>您可以调用<code>hasPrefix(_:)</code>方法来计算话剧中第一幕的场景数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> act1SceneCount = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> scene <span class="keyword">in</span> romeoAndJuliet &#123;</span><br><span class="line">    <span class="keyword">if</span> scene.hasPrefix(<span class="string">"Act 1 "</span>) &#123;</span><br><span class="line">        ++act1SceneCount</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"There are <span class="subst">\(act1SceneCount)</span> scenes in Act 1"</span>)</span><br><span class="line"><span class="comment">// 打印输出 "There are 5 scenes in Act 1"</span></span><br></pre></td></tr></table></figure>
<p>相似地，您可以用<code>hasSuffix(_:)</code>方法来计算发生在不同地方的场景数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mansionCount = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> cellCount = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> scene <span class="keyword">in</span> romeoAndJuliet &#123;</span><br><span class="line">    <span class="keyword">if</span> scene.hasSuffix(<span class="string">"Capulet's mansion"</span>) &#123;</span><br><span class="line">        ++mansionCount</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> scene.hasSuffix(<span class="string">"Friar Lawrence's cell"</span>) &#123;</span><br><span class="line">        ++cellCount</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(mansionCount)</span> mansion scenes; <span class="subst">\(cellCount)</span> cell scenes"</span>)</span><br><span class="line"><span class="comment">// 打印输出 "6 mansion scenes; 2 cell scenes"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br><code>hasPrefix(_:)</code>和<code>hasSuffix(_:)</code>方法都是在每个字符串中逐字符比较其可扩展的字符群集是否标准相等，详细描述在<a href="#string_and_character_equality">字符串/字符相等</a>。</p>
</blockquote>
<p><a name="unicode_representations_of_strings"></a></p>
<h2 id="字符串的_Unicode_表示形式（Unicode_Representations_of_Strings）">字符串的 Unicode 表示形式（Unicode Representations of Strings）</h2><p>当一个 Unicode 字符串被写进文本文件或者其他储存时，字符串中的 Unicode 标量会用 Unicode 定义的几种编码格式编码。每一个字符串中的小块编码都被称为代码单元。这些包括 UTF-8 编码格式（编码字符串为8位的代码单元）， UTF-16 编码格式（编码字符串位16位的代码单元），以及 UTF-32 编码格式（编码字符串32位的代码单元）。</p>
<p>Swift 提供了几种不同的方式来访问字符串的 Unicode 表示形式。<br>您可以利用<code>for-in</code>来对字符串进行遍历，从而以 Unicode 可扩展的字符群集的方式访问每一个<code>Character</code>值。<br>该过程在 <a href="#working_with_characters">使用字符</a> 中进行了描述。</p>
<p>另外，能够以其他三种 Unicode 兼容的方式访问字符串的值：</p>
<ul>
<li>UTF-8 代码单元集合 (利用字符串的<code>utf8</code>属性进行访问)</li>
<li>UTF-16 代码单元集合 (利用字符串的<code>utf16</code>属性进行访问)</li>
<li>21位的 Unicode 标量值集合，也就是字符串的 UTF-32 编码格式 (利用字符串的<code>unicodeScalars</code>属性进行访问)</li>
</ul>
<p>下面由<code>D``o``g``‼</code>(<code>DOUBLE EXCLAMATION MARK</code>, Unicode 标量 <code>U+203C</code>)和<code>�</code>(<code>DOG FACE</code>，Unicode 标量为<code>U+1F436</code>)组成的字符串中的每一个字符代表着一种不同的表示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dogString = <span class="string">"Dog‼🐶"</span></span><br></pre></td></tr></table></figure>
<p><a name="UTF-8_representation"></a></p>
<h3 id="UTF-8_表示">UTF-8 表示</h3><p>您可以通过遍历<code>String</code>的<code>utf8</code>属性来访问它的<code>UTF-8</code>表示。<br>其为<code>String.UTF8View</code>类型的属性，<code>UTF8View</code>是无符号8位 (<code>UInt8</code>) 值的集合，每一个<code>UInt8</code>值都是一个字符的 UTF-8 表示：</p>
<table style="text-align:center"><br> <tr height="77"><br>  <td>Character</td><br>  <td>D<br>U+0044</td><br>  <td>o<br>U+006F</td><br>  <td>g<br>U+0067</td><br>  <td colspan="3">‼<br>U+203C</td><br>  <td colspan="4">🐶<br>U+1F436</td><br> </tr><br> <tr height="77"><br>  <td height="77">UTF-8<br>Code Unit</td><br>  <td>68</td><br>  <td>111</td><br>  <td>103</td><br>  <td>226</td><br>  <td>128</td><br>  <td>188</td><br>  <td>240</td><br>  <td>159</td><br>  <td>144</td><br>  <td>182</td><br> </tr><br> <tr><br>  <td height="77">Position</td><br>  <td>0</td><br>  <td>1</td><br>  <td>2</td><br>  <td>3</td><br>  <td>4</td><br>  <td>5</td><br>  <td>6</td><br>  <td>7</td><br>  <td>8</td><br>  <td>9</td><br> </tr><br></table>


<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> codeUnit <span class="keyword">in</span> dogString.utf8 &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(codeUnit)</span> "</span>, terminator: <span class="string">""</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">""</span>)</span><br><span class="line"><span class="comment">// 68 111 103 226 128 188 240 159 144 182</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，前三个10进制<code>codeUnit</code>值 (<code>68</code>, <code>111</code>, <code>103</code>) 代表了字符<code>D</code>、<code>o</code>和 <code>g</code>，它们的 UTF-8 表示与 ASCII 表示相同。<br>接下来的三个10进制<code>codeUnit</code>值 (<code>226</code>, <code>128</code>, <code>188</code>) 是<code>DOUBLE EXCLAMATION MARK</code>的3字节 UTF-8 表示。<br>最后的四个<code>codeUnit</code>值 (<code>240</code>, <code>159</code>, <code>144</code>, <code>182</code>) 是<code>DOG FACE</code>的4字节 UTF-8 表示。</p>
<p><a name="UTF-16_representation"></a></p>
<h3 id="UTF-16_表示">UTF-16 表示</h3><p>您可以通过遍历<code>String</code>的<code>utf16</code>属性来访问它的<code>UTF-16</code>表示。<br>其为<code>String.UTF16View</code>类型的属性，<code>UTF16View</code>是无符号16位 (<code>UInt16</code>) 值的集合，每一个<code>UInt16</code>都是一个字符的 UTF-16 表示：</p>
<table style="text-align:center"><br> <tr height="77"><br>  <td>Character</td><br>  <td>D<br>U+0044</td><br>  <td>o<br>U+006F</td><br>  <td>g<br>U+0067</td><br>  <td>‼<br>U+203C</td><br>  <td colspan="2">🐶<br>U+1F436</td><br> </tr><br> <tr height="77"><br>  <td height="77">UTF-16<br>Code Unit</td><br>  <td>68</td><br>  <td>111</td><br>  <td>103</td><br>  <td>8252</td><br>  <td>55357</td><br>  <td>56374</td><br> </tr><br> <tr><br>  <td height="77">Position</td><br>  <td>0</td><br>  <td>1</td><br>  <td>2</td><br>  <td>3</td><br>  <td>4</td><br>  <td>5</td><br> </tr><br></table>


<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> codeUnit <span class="keyword">in</span> dogString.utf16 &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(codeUnit)</span> "</span>, terminator: <span class="string">""</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">""</span>)</span><br><span class="line"><span class="comment">// 68 111 103 8252 55357 56374</span></span><br></pre></td></tr></table></figure>
<p>同样，前三个<code>codeUnit</code>值 (<code>68</code>, <code>111</code>, <code>103</code>) 代表了字符<code>D</code>、<code>o</code>和<code>g</code>，它们的 UTF-16 代码单元和 UTF-8 完全相同（因为这些 Unicode 标量表示 ASCII 字符）。</p>
<p>第四个<code>codeUnit</code>值 (<code>8252</code>) 是一个等于十六进制<code>203C</code>的的十进制值。这个代表了<code>DOUBLE EXCLAMATION MARK</code>字符的 Unicode 标量值<code>U+203C</code>。这个字符在 UTF-16 中可以用一个代码单元表示。</p>
<p>第五和第六个<code>codeUnit</code>值 (<code>55357</code>和<code>56374</code>) 是<code>DOG FACE</code>字符的 UTF-16 表示。<br>第一个值为<code>U+D83D</code>(十进制值为<code>55357</code>)，第二个值为<code>U+DC36</code>(十进制值为<code>56374</code>)。</p>
<p><a name="unicode_scalars_representation"></a></p>
<h3 id="Unicode_标量表示_(Unicode_Scalars_Representation)">Unicode 标量表示 (Unicode Scalars Representation)</h3><p>您可以通过遍历<code>String</code>值的<code>unicodeScalars</code>属性来访问它的 Unicode 标量表示。<br>其为<code>UnicodeScalarView</code>类型的属性，<code>UnicodeScalarView</code>是<code>UnicodeScalar</code>的集合。<br><code>UnicodeScalar</code>是21位的 Unicode 代码点。</p>
<p>每一个<code>UnicodeScalar</code>拥有一个<code>value</code>属性，可以返回对应的21位数值，用<code>UInt32</code>来表示：</p>
<table style="text-align:center"><br> <tr height="77"><br>  <td>Character</td><br>  <td>D<br>U+0044</td><br>  <td>o<br>U+006F</td><br>  <td>g<br>U+0067</td><br>  <td>‼<br>U+203C</td><br>  <td>🐶<br>U+1F436</td><br> </tr><br> <tr height="77"><br>  <td height="77">UTF-16<br>Code Unit</td><br>  <td>68</td><br>  <td>111</td><br>  <td>103</td><br>  <td>8252</td><br>  <td>128054</td><br> </tr><br> <tr><br>  <td height="77">Position</td><br>  <td>0</td><br>  <td>1</td><br>  <td>2</td><br>  <td>3</td><br>  <td>4</td><br> </tr><br></table>


<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> scalar <span class="keyword">in</span> dogString.unicodeScalars &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(scalar.value)</span> "</span>, terminator: <span class="string">""</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">""</span>)</span><br><span class="line"><span class="comment">// 68 111 103 8252 128054</span></span><br></pre></td></tr></table></figure>
<p>前三个<code>UnicodeScalar</code>值(<code>68</code>, <code>111</code>, <code>103</code>)的<code>value</code>属性仍然代表字符<code>D</code>、<code>o</code>和<code>g</code>。<br>第四个<code>codeUnit</code>值(<code>8252</code>)仍然是一个等于十六进制<code>203C</code>的十进制值。这个代表了<code>DOUBLE EXCLAMATION MARK</code>字符的 Unicode 标量<code>U+203C</code>。</p>
<p>第五个<code>UnicodeScalar</code>值的<code>value</code>属性，<code>128054</code>，是一个十六进制<code>1F436</code>的十进制表示。其等同于<code>DOG FACE</code>的 Unicode 标量<code>U+1F436</code>。</p>
<p>作为查询它们的<code>value</code>属性的一种替代方法，每个<code>UnicodeScalar</code>值也可以用来构建一个新的<code>String</code>值，比如在字符串插值中使用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> scalar <span class="keyword">in</span> dogString.unicodeScalars &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(scalar)</span> "</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// D</span></span><br><span class="line"><span class="comment">// o</span></span><br><span class="line"><span class="comment">// g</span></span><br><span class="line"><span class="comment">// ‼</span></span><br><span class="line"><span class="comment">// 🐶</span></span><br></pre></td></tr></table></figure>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/04_Collection_Types/" itemprop="url">
                第二章-04集合类型 (Collection Types)
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:23+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/04_Collection_Types/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/04_Collection_Types/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="集合类型_(Collection_Types)">集合类型 (Collection Types)</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/zqp" target="_blank" rel="external">zqp</a><br>校对：<a href="https://github.com/shinyzhu" target="_blank" rel="external">shinyzhu</a>, <a href="https://github.com/stanzhai" target="_blank" rel="external">stanzhai</a>, <a href="https://github.com/feiin" target="_blank" rel="external">feiin</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/AlanMelody" target="_blank" rel="external">JackAlan</a></p>
<p>2.1<br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#mutability_of_collections">集合的可变性（Mutability of Collections）</a></li>
<li><a href="#arrays">数组（Arrays）</a></li>
<li><a href="#sets">集合（Sets）</a></li>
<li><a href="#dictionaries">字典（Dictionaries）</a></li>
</ul>
<p>Swift 语言提供<code>Arrays</code>、<code>Sets</code>和<code>Dictionaries</code>三种基本的集合类型用来存储集合数据。数组（Arrays）是有序数据的集。集合（Sets）是无序无重复数据的集。字典（Dictionaries）是无序的键值对的集。</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/CollectionTypes_intro_2x.png" alt=""></p>
<p>Swift 语言中的<code>Arrays</code>、<code>Sets</code>和<code>Dictionaries</code>中存储的数据值类型必须明确。这意味着我们不能把不正确的数据类型插入其中。同时这也说明我们完全可以对取回值的类型非常自信。</p>
<blockquote>
<p>注意：<br>Swift 的<code>Arrays</code>、<code>Sets</code>和<code>Dictionaries</code>类型被实现为<em>泛型集合</em>。更多关于泛型类型和集合，参见 <a href="./23_Generics.html">泛型</a>章节。</p>
</blockquote>
<p><a name="mutability_of_collections"></a></p>
<h2 id="集合的可变性">集合的可变性</h2><p>如果创建一个<code>Arrays</code>、<code>Sets</code>或<code>Dictionaries</code>并且把它分配成一个变量，这个集合将会是<em>可变的</em>。这意味着我们可以在创建之后添加更多或移除已存在的数据项，或者改变集合中的数据项。如果我们把<code>Arrays</code>、<code>Sets</code>或<code>Dictionaries</code>分配成常量，那么它就是<em>不可变的</em>，它的大小和内容都不能被改变。</p>
<blockquote>
<p>注意：<br>在我们不需要改变集合的时候创建不可变集合是很好的实践。如此 Swift 编译器可以优化我们创建的集合。</p>
</blockquote>
<p><a name="arrays"></a></p>
<h2 id="数组(Arrays)">数组(Arrays)</h2><p>数组使用有序列表存储同一类型的多个值。相同的值可以多次出现在一个数组的不同位置中。</p>
<blockquote>
<p>注意:<br> Swift 的<code>Array</code>类型被桥接到<code>Foundation</code>中的<code>NSArray</code>类。<br> 更多关于在<code>Foundation</code>和<code>Cocoa</code>中使用<code>Array</code>的信息，参见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216" target="_blank" rel="external"><em>Using Swift with Cocoa and Obejective-C</em></a> 一书。</p>
</blockquote>
<p><a name="array_type_shorthand_syntax"></a></p>
<h3 id="数组的简单语法">数组的简单语法</h3><p>写 Swift 数组应该遵循像<code>Array&lt;Element&gt;</code>这样的形式，其中<code>Element</code>是这个数组中唯一允许存在的数据类型。我们也可以使用像<code>[Element]</code>这样的简单语法。尽管两种形式在功能上是一样的，但是推荐较短的那种，而且在本文中都会使用这种形式来使用数组。</p>
<p><a name="creating_an_empty_array"></a></p>
<h3 id="创建一个空数组">创建一个空数组</h3><p>我们可以使用构造语法来创建一个由特定数据类型构成的空数组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someInts = [<span class="type">Int</span>]()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"someInts is of type [Int] with <span class="subst">\(someInts.<span class="built_in">count</span>)</span> items."</span>)</span><br><span class="line"><span class="comment">// 打印 "someInts is of type [Int] with 0 items."</span></span><br></pre></td></tr></table></figure>
<p>注意，通过构造函数的类型，<code>someInts</code>的值类型被推断为<code>[Int]</code>。</p>
<p>或者，如果代码上下文中已经提供了类型信息，例如一个函数参数或者一个已经定义好类型的常量或者变量，我们可以使用空数组语句创建一个空数组，它的写法很简单：<code>[]</code>（一对空方括号）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">someInts.append(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// someInts 现在包含一个 Int 值</span></span><br><span class="line">someInts = []</span><br><span class="line"><span class="comment">// someInts 现在是空数组，但是仍然是 [Int] 类型的。</span></span><br></pre></td></tr></table></figure>
<p><a name="creating_an_array_with_a_default_value"></a></p>
<h3 id="创建一个带有默认值的数组">创建一个带有默认值的数组</h3><p>Swift 中的<code>Array</code>类型还提供一个可以创建特定大小并且所有数据都被默认的构造方法。我们可以把准备加入新数组的数据项数量（<code>count</code>）和适当类型的初始值（<code>repeatedValue</code>）传入数组构造函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> threeDoubles = [<span class="type">Double</span>](<span class="built_in">count</span>: <span class="number">3</span>, repeatedValue:<span class="number">0.0</span>)</span><br><span class="line"><span class="comment">// threeDoubles 是一种 [Double] 数组，等价于 [0.0, 0.0, 0.0]</span></span><br></pre></td></tr></table></figure>
<p><a name="creating_an_array_by_adding_two_arrays_together"></a></p>
<h3 id="通过两个数组相加创建一个数组">通过两个数组相加创建一个数组</h3><p>我们可以使用加法操作符（<code>+</code>）来组合两种已存在的相同类型数组。新数组的数据类型会被从两个数组的数据类型中推断出来：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anotherThreeDoubles = <span class="type">Array</span>(<span class="built_in">count</span>: <span class="number">3</span>, repeatedValue: <span class="number">2.5</span>)</span><br><span class="line"><span class="comment">// anotherThreeDoubles 被推断为 [Double]，等价于 [2.5, 2.5, 2.5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sixDoubles = threeDoubles + anotherThreeDoubles</span><br><span class="line"><span class="comment">// sixDoubles 被推断为 [Double]，等价于 [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]</span></span><br></pre></td></tr></table></figure>
<p><a name="creating_an_array_with_an_array_literals"></a></p>
<h3 id="用字面量构造数组">用字面量构造数组</h3><p>我们可以使用字面量来进行数组构造，这是一种用一个或者多个数值构造数组的简单方法。字面量是一系列由逗号分割并由方括号包含的数值：</p>
<p><code>[value 1, value 2, value 3]</code>。</p>
<p>下面这个例子创建了一个叫做<code>shoppingList</code>并且存储<code>String</code>的数组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shoppingList: [<span class="type">String</span>] = [<span class="string">"Eggs"</span>, <span class="string">"Milk"</span>]</span><br><span class="line"><span class="comment">// shoppingList 已经被构造并且拥有两个初始项。</span></span><br></pre></td></tr></table></figure>
<p><code>shoppingList</code>变量被声明为“字符串值类型的数组“，记作<code>[String]</code>。 因为这个数组被规定只有<code>String</code>一种数据结构，所以只有<code>String</code>类型可以在其中被存取。 在这里，<code>shoppinglist</code>数组由两个<code>String</code>值（<code>&quot;Eggs&quot;</code> 和<code>&quot;Milk&quot;</code>）构造，并且由字面量定义。</p>
<blockquote>
<p>注意：<br><code>Shoppinglist</code>数组被声明为变量（<code>var</code>关键字创建）而不是常量（<code>let</code>创建）是因为以后可能会有更多的数据项被插入其中。</p>
</blockquote>
<p>在这个例子中，字面量仅仅包含两个<code>String</code>值。匹配了该数组的变量声明（只能包含<code>String</code>的数组），所以这个字面量的分配过程可以作为用两个初始项来构造<code>shoppinglist</code>的一种方式。</p>
<p>由于 Swift 的类型推断机制，当我们用字面量构造只拥有相同类型值数组的时候，我们不必把数组的类型定义清楚。 <code>shoppinglist</code>的构造也可以这样写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shoppingList = [<span class="string">"Eggs"</span>, <span class="string">"Milk"</span>]</span><br></pre></td></tr></table></figure>
<p>因为所有字面量中的值都是相同的类型，Swift 可以推断出<code>[String]</code>是<code>shoppinglist</code>中变量的正确类型。</p>
<p><a name="accessing_and_modifying_an_array"></a></p>
<h3 id="访问和修改数组">访问和修改数组</h3><p>我们可以通过数组的方法和属性来访问和修改数组，或者使用下标语法。</p>
<p>可以使用数组的只读属性<code>count</code>来获取数组中的数据项数量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"The shopping list contains <span class="subst">\(shoppingList.<span class="built_in">count</span>)</span> items."</span>)</span><br><span class="line"><span class="comment">// 输出 "The shopping list contains 2 items."（这个数组有2个项）</span></span><br></pre></td></tr></table></figure>
<p>使用布尔值属性<code>isEmpty</code>作为检查<code>count</code>属性的值是否为 0 的捷径：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> shoppingList.isEmpty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The shopping list is empty."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The shopping list is not empty."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "The shopping list is not empty."（shoppinglist 不是空的）</span></span><br></pre></td></tr></table></figure>
<p>也可以使用<code>append(_:)</code>方法在数组后面添加新的数据项：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shoppingList.append(<span class="string">"Flour"</span>)</span><br><span class="line"><span class="comment">// shoppingList 现在有3个数据项，有人在摊煎饼</span></span><br></pre></td></tr></table></figure>
<p>除此之外，使用加法赋值运算符（<code>+=</code>）也可以直接在数组后面添加一个或多个拥有相同类型的数据项：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shoppingList += [<span class="string">"Baking Powder"</span>]</span><br><span class="line"><span class="comment">// shoppingList 现在有四项了</span></span><br><span class="line">shoppingList += [<span class="string">"Chocolate Spread"</span>, <span class="string">"Cheese"</span>, <span class="string">"Butter"</span>]</span><br><span class="line"><span class="comment">// shoppingList 现在有七项了</span></span><br></pre></td></tr></table></figure>
<p>可以直接使用下标语法来获取数组中的数据项，把我们需要的数据项的索引值放在直接放在数组名称的方括号中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstItem = shoppingList[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 第一项是 "Eggs"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>第一项在数组中的索引值是<code>0</code>而不是<code>1</code>。 Swift 中的数组索引总是从零开始。</p>
</blockquote>
<p>我们也可以用下标来改变某个已有索引值对应的数据值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shoppingList[<span class="number">0</span>] = <span class="string">"Six eggs"</span></span><br><span class="line"><span class="comment">// 其中的第一项现在是 "Six eggs" 而不是 "Eggs"</span></span><br></pre></td></tr></table></figure>
<p>还可以利用下标来一次改变一系列数据值，即使新数据和原有数据的数量是不一样的。下面的例子把<code>&quot;Chocolate Spread&quot;</code>，<code>&quot;Cheese&quot;</code>，和<code>&quot;Butter&quot;</code>替换为<code>&quot;Bananas&quot;</code>和 <code>&quot;Apples&quot;</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shoppingList[<span class="number">4</span>...<span class="number">6</span>] = [<span class="string">"Bananas"</span>, <span class="string">"Apples"</span>]</span><br><span class="line"><span class="comment">// shoppingList 现在有6项</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>不可以用下标访问的形式去在数组尾部添加新项。</p>
</blockquote>
<p>调用数组的<code>insert(_:atIndex:)</code>方法来在某个具体索引值之前添加数据项：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shoppingList.insert(<span class="string">"Maple Syrup"</span>, atIndex: <span class="number">0</span>)</span><br><span class="line"><span class="comment">// shoppingList 现在有7项</span></span><br><span class="line"><span class="comment">// "Maple Syrup" 现在是这个列表中的第一项</span></span><br></pre></td></tr></table></figure>
<p>这次<code>insert(_:atIndex:)</code>方法调用把值为<code>&quot;Maple Syrup&quot;</code>的新数据项插入列表的最开始位置，并且使用<code>0</code>作为索引值。</p>
<p>类似的我们可以使用<code>removeAtIndex(_:)</code>方法来移除数组中的某一项。这个方法把数组在特定索引值中存储的数据项移除并且返回这个被移除的数据项（我们不需要的时候就可以无视它）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mapleSyrup = shoppingList.removeAtIndex(<span class="number">0</span>)</span><br><span class="line"><span class="comment">// 索引值为0的数据项被移除</span></span><br><span class="line"><span class="comment">// shoppingList 现在只有6项，而且不包括 Maple Syrup</span></span><br><span class="line"><span class="comment">// mapleSyrup 常量的值等于被移除数据项的值 "Maple Syrup"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>如果我们试着对索引越界的数据进行检索或者设置新值的操作，会引发一个运行期错误。我们可以使用索引值和数组的<code>count</code>属性进行比较来在使用某个索引之前先检验是否有效。除了当<code>count</code>等于 0 时（说明这是个空数组），最大索引值一直是<code>count - 1</code>，因为数组都是零起索引。</p>
</blockquote>
<p>数据项被移除后数组中的空出项会被自动填补，所以现在索引值为<code>0</code>的数据项的值再次等于<code>&quot;Six eggs&quot;</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firstItem = shoppingList[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// firstItem 现在等于 "Six eggs"</span></span><br></pre></td></tr></table></figure>
<p>如果我们只想把数组中的最后一项移除，可以使用<code>removeLast()</code>方法而不是<code>removeAtIndex(_:)</code>方法来避免我们需要获取数组的<code>count</code>属性。就像后者一样，前者也会返回被移除的数据项：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> apples = shoppingList.removeLast()</span><br><span class="line"><span class="comment">// 数组的最后一项被移除了</span></span><br><span class="line"><span class="comment">// shoppingList 现在只有5项，不包括 cheese</span></span><br><span class="line"><span class="comment">// apples 常量的值现在等于 "Apples" 字符串</span></span><br></pre></td></tr></table></figure>
<p><a name="iterating_over_an_array"></a></p>
<h3 id="数组的遍历">数组的遍历</h3><p>我们可以使用<code>for-in</code>循环来遍历所有数组中的数据项：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> shoppingList &#123;</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Six eggs</span></span><br><span class="line"><span class="comment">// Milk</span></span><br><span class="line"><span class="comment">// Flour</span></span><br><span class="line"><span class="comment">// Baking Powder</span></span><br><span class="line"><span class="comment">// Bananas</span></span><br></pre></td></tr></table></figure>
<p>如果我们同时需要每个数据项的值和索引值，可以使用<code>enumerate()</code>方法来进行数组遍历。<code>enumerate()</code>返回一个由每一个数据项索引值和数据值组成的元组。我们可以把这个元组分解成临时常量或者变量来进行遍历：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (index, value) <span class="keyword">in</span> shoppingList.<span class="built_in">enumerate</span>() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Item <span class="subst">\(String(index + <span class="number">1</span>)</span>): <span class="subst">\(value)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Item 1: Six eggs</span></span><br><span class="line"><span class="comment">// Item 2: Milk</span></span><br><span class="line"><span class="comment">// Item 3: Flour</span></span><br><span class="line"><span class="comment">// Item 4: Baking Powder</span></span><br><span class="line"><span class="comment">// Item 5: Bananas</span></span><br></pre></td></tr></table></figure>
<p>更多关于<code>for-in</code>循环的介绍请参见<a href="05_Control_Flow.html#for_loops">for 循环</a>。</p>
<p><a name="sets"></a></p>
<h2 id="集合（Sets）">集合（Sets）</h2><p><em>集合(Set)</em>用来存储相同类型并且没有确定顺序的值。当集合元素顺序不重要时或者希望确保每个元素只出现一次时可以使用集合而不是数组。</p>
<blockquote>
<p>注意：<br>Swift的<code>Set</code>类型被桥接到<code>Foundation</code>中的<code>NSSet</code>类。<br>关于使用<code>Foundation</code>和<code>Cocoa</code>中<code>Set</code>的知识，请看 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216" target="_blank" rel="external"><em>Using Swift with Cocoa and Objective-C</em></a>。</p>
</blockquote>
<p><a name="hash_values_for_set_types"></a></p>
<h4 id="集合类型的哈希值">集合类型的哈希值</h4><p>一个类型为了存储在集合中，该类型必须是可哈希化的–也就是说，该类型必须提供一个方法来计算它的哈希值。一个哈希值是<code>Int</code>类型的，相等的对象哈希值必须相同，比如<code>a==b</code>,因此必须<code>a.hashValue == b.hashValue</code>。</p>
<p>Swift 的所有基本类型(比如<code>String</code>,<code>Int</code>,<code>Double</code>和<code>Bool</code>)默认都是可哈希化的，可以作为集合的值的类型或者字典的键的类型。没有关联值的枚举成员值(在<a href="./08_Enumerations.html">枚举</a>有讲述)默认也是可哈希化的。</p>
<blockquote>
<p>注意：<br>你可以使用你自定义的类型作为集合的值的类型或者是字典的键的类型，但你需要使你的自定义类型符合 Swift 标准库中的<code>Hashable</code>协议。符合<code>Hashable</code>协议的类型需要提供一个类型为<code>Int</code>的可读属性<code>hashValue</code>。由类型的<code>hashValue</code>属性返回的值不需要在同一程序的不同执行周期或者不同程序之间保持相同。  </p>
<p>因为<code>Hashable</code>协议符合<code>Equatable</code>协议，所以符合该协议的类型也必须提供一个”是否相等”运算符(<code>==</code>)的实现。这个<code>Equatable</code>协议要求任何符合<code>==</code>实现的实例间都是一种相等的关系。也就是说，对于<code>a,b,c</code>三个值来说，<code>==</code>的实现必须满足下面三种情况：</p>
<ul>
<li><code>a == a</code>(自反性)</li>
<li><code>a == b</code>意味着<code>b == a</code>(对称性)</li>
<li><code>a == b &amp;&amp; b == c</code>意味着<code>a == c</code>(传递性)</li>
</ul>
</blockquote>
<p>关于符合协议的更多信息，请看<a href="./22_Protocols.html">协议</a>。</p>
<p><a name="set_type_syntax"></a></p>
<h3 id="集合类型语法">集合类型语法</h3><p>Swift 中的<code>Set</code>类型被写为<code>Set&lt;Element&gt;</code>，这里的<code>Element</code>表示<code>Set</code>中允许存储的类型，和数组不同的是，集合没有等价的简化形式。</p>
<p><a name="creating_and_initalizing_an_empty_set"></a></p>
<h3 id="创建和构造一个空的集合">创建和构造一个空的集合</h3><p>你可以通过构造器语法创建一个特定类型的空集合：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> letters = <span class="type">Set</span>&lt;<span class="type">Character</span>&gt;()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"letters is of type Set&lt;Character&gt; with <span class="subst">\(letters.<span class="built_in">count</span>)</span> items."</span>)</span><br><span class="line"><span class="comment">// 打印 "letters is of type Set&lt;Character&gt; with 0 items."</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>通过构造器，这里的<code>letters</code>变量的类型被推断为<code>Set&lt;Character&gt;</code>。</p>
</blockquote>
<p>此外，如果上下文提供了类型信息，比如作为函数的参数或者已知类型的变量或常量，我们可以通过一个空的数组字面量创建一个空的<code>Set</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">letters.insert(<span class="string">"a"</span>)</span><br><span class="line"><span class="comment">// letters 现在含有1个 Character 类型的值</span></span><br><span class="line">letters = []</span><br><span class="line"><span class="comment">// letters 现在是一个空的 Set, 但是它依然是 Set&lt;Character&gt; 类型</span></span><br></pre></td></tr></table></figure>
<p><a name="creating_a_set_with_an_array_literal"></a></p>
<h3 id="用数组字面量创建集合">用数组字面量创建集合</h3><p>你可以使用数组字面量来构造集合，并且可以使用简化形式写一个或者多个值作为集合元素。</p>
<p>下面的例子创建一个称之为<code>favoriteGenres</code>的集合来存储<code>String</code>类型的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> favoriteGenres: <span class="type">Set</span>&lt;<span class="type">String</span>&gt; = [<span class="string">"Rock"</span>, <span class="string">"Classical"</span>, <span class="string">"Hip hop"</span>]</span><br><span class="line"><span class="comment">// favoriteGenres 被构造成含有三个初始值的集合</span></span><br></pre></td></tr></table></figure>
<p>这个<code>favoriteGenres</code>变量被声明为“一个<code>String</code>值的集合”，写为<code>Set&lt;String&gt;</code>。由于这个特定的集合含有指定<code>String</code>类型的值，所以它只允许存储<code>String</code>类型值。这里的<code>favoriteGenres</code>变量有三个<code>String</code>类型的初始值(<code>&quot;Rock&quot;</code>，<code>&quot;Classical&quot;</code>和<code>&quot;Hip hop&quot;</code>)，并以数组字面量的方式出现。</p>
<blockquote>
<p>注意：<br><code>favoriteGenres</code>被声明为一个变量(拥有<code>var</code>标示符)而不是一个常量(拥有<code>let</code>标示符),因为它里面的元素将会在下面的例子中被增加或者移除。</p>
</blockquote>
<p>一个<code>Set</code>类型不能从数组字面量中被单独推断出来，因此<code>Set</code>类型必须显式声明。然而，由于 Swift 的类型推断功能，如果你想使用一个数组字面量构造一个<code>Set</code>并且该数组字面量中的所有元素类型相同，那么你无须写出<code>Set</code>的具体类型。<code>favoriteGenres</code>的构造形式可以采用简化的方式代替：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> favoriteGenres: <span class="type">Set</span> = [<span class="string">"Rock"</span>, <span class="string">"Classical"</span>, <span class="string">"Hip hop"</span>]</span><br></pre></td></tr></table></figure>
<p>由于数组字面量中的所有元素类型相同，Swift 可以推断出<code>Set&lt;String&gt;</code>作为<code>favoriteGenres</code>变量的正确类型。</p>
<p><a name="accesing_and_modifying_a_set"></a></p>
<h3 id="访问和修改一个集合">访问和修改一个集合</h3><p>你可以通过<code>Set</code>的属性和方法来访问和修改一个<code>Set</code>。</p>
<p>为了找出一个<code>Set</code>中元素的数量，可以使用其只读属性<code>count</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"I have <span class="subst">\(favoriteGenres.<span class="built_in">count</span>)</span> favorite music genres."</span>)</span><br><span class="line"><span class="comment">// 打印 "I have 3 favorite music genres."</span></span><br></pre></td></tr></table></figure>
<p>使用布尔属性<code>isEmpty</code>作为一个缩写形式去检查<code>count</code>属性是否为<code>0</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> favoriteGenres.isEmpty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"As far as music goes, I'm not picky."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I have particular music preferences."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "I have particular music preferences."</span></span><br></pre></td></tr></table></figure>
<p>你可以通过调用<code>Set</code>的<code>insert(_:)</code>方法来添加一个新元素：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">favoriteGenres.insert(<span class="string">"Jazz"</span>)</span><br><span class="line"><span class="comment">// favoriteGenres 现在包含4个元素</span></span><br></pre></td></tr></table></figure>
<p>你可以通过调用<code>Set</code>的<code>remove(_:)</code>方法去删除一个元素，如果该值是该<code>Set</code>的一个元素则删除该元素并且返回被删除的元素值，否则如果该<code>Set</code>不包含该值，则返回<code>nil</code>。另外，<code>Set</code>中的所有元素可以通过它的<code>removeAll()</code>方法删除。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> removedGenre = favoriteGenres.remove(<span class="string">"Rock"</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(removedGenre)</span>? I'm over it."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I never much cared for that."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "Rock? I'm over it."</span></span><br></pre></td></tr></table></figure>
<p>使用<code>contains(_:)</code>方法去检查<code>Set</code>中是否包含一个特定的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> favoriteGenres.<span class="built_in">contains</span>(<span class="string">"Funk"</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I get up on the good foot."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"It's too funky in here."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "It's too funky in here."</span></span><br></pre></td></tr></table></figure>
<p><a name="iterating_over_a_set"></a></p>
<h3 id="遍历一个集合">遍历一个集合</h3><p>你可以在一个<code>for-in</code>循环中遍历一个<code>Set</code>中的所有值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> genre <span class="keyword">in</span> favoriteGenres &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(genre)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Classical</span></span><br><span class="line"><span class="comment">// Jazz</span></span><br><span class="line"><span class="comment">// Hip hop</span></span><br></pre></td></tr></table></figure>
<p>更多关于<code>for-in</code>循环的信息，参见<a href="./05_Control_Flow.html#for_loops">For 循环</a>。</p>
<p>Swift 的<code>Set</code>类型没有确定的顺序，为了按照特定顺序来遍历一个<code>Set</code>中的值可以使用<code>sort()</code>方法，它将根据提供的序列返回一个有序集合.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> genre <span class="keyword">in</span> favoriteGenres.<span class="built_in">sort</span>() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(genre)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// prints "Classical"</span></span><br><span class="line"><span class="comment">// prints "Hip hop"</span></span><br><span class="line"><span class="comment">// prints "Jazz</span></span><br></pre></td></tr></table></figure>
<p><a name="performing_set_operations"></a></p>
<h3 id="集合操作">集合操作</h3><p>你可以高效地完成<code>Set</code>的一些基本操作，比如把两个集合组合到一起，判断两个集合共有元素，或者判断两个集合是否全包含，部分包含或者不相交。</p>
<p><a name="fundamental_set_operations"></a></p>
<h4 id="基本集合操作">基本集合操作</h4><p>下面的插图描述了两个集合-<code>a</code>和<code>b</code>-以及通过阴影部分的区域显示集合各种操作的结果。</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/setVennDiagram_2x.png" alt=""></p>
<ul>
<li>使用<code>intersect(_:)</code>方法根据两个集合中都包含的值创建的一个新的集合。</li>
<li>使用<code>exclusiveOr(_:)</code>方法根据在一个集合中但不在两个集合中的值创建一个新的集合。</li>
<li>使用<code>union(_:)</code>方法根据两个集合的值创建一个新的集合。</li>
<li>使用<code>subtract(_:)</code>方法根据不在该集合中的值创建一个新的集合。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oddDigits: <span class="type">Set</span> = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">let</span> evenDigits: <span class="type">Set</span> = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"><span class="keyword">let</span> singleDigitPrimeNumbers: <span class="type">Set</span> = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">oddDigits.union(evenDigits).<span class="built_in">sort</span>()</span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line">oddDigits.intersect(evenDigits).<span class="built_in">sort</span>()</span><br><span class="line"><span class="comment">// []</span></span><br><span class="line">oddDigits.subtract(singleDigitPrimeNumbers).<span class="built_in">sort</span>()</span><br><span class="line"><span class="comment">// [1, 9]</span></span><br><span class="line">oddDigits.exclusiveOr(singleDigitPrimeNumbers).<span class="built_in">sort</span>()</span><br><span class="line"><span class="comment">// [1, 2, 9]</span></span><br></pre></td></tr></table></figure>
<p><a name="set_membership_and_equality"></a></p>
<h4 id="集合成员关系和相等">集合成员关系和相等</h4><p>下面的插图描述了三个集合-<code>a</code>,<code>b</code>和<code>c</code>,以及通过重叠区域表述集合间共享的元素。集合<code>a</code>是集合<code>b</code>的父集合，因为<code>a</code>包含了<code>b</code>中所有的元素，相反的，集合<code>b</code>是集合<code>a</code>的子集合，因为属于<code>b</code>的元素也被<code>a</code>包含。集合<code>b</code>和集合<code>c</code>彼此不关联，因为它们之间没有共同的元素。</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/setEulerDiagram_2x.png" alt=""></p>
<ul>
<li>使用“是否相等”运算符(<code>==</code>)来判断两个集合是否包含全部相同的值。</li>
<li>使用<code>isSubsetOf(_:)</code>方法来判断一个集合中的值是否也被包含在另外一个集合中。</li>
<li>使用<code>isSupersetOf(_:)</code>方法来判断一个集合中包含另一个集合中所有的值。</li>
<li>使用<code>isStrictSubsetOf(_:)</code>或者<code>isStrictSupersetOf(_:)</code>方法来判断一个集合是否是另外一个集合的子集合或者父集合并且两个集合并不相等。</li>
<li>使用<code>isDisjointWith(_:)</code>方法来判断两个集合是否不含有相同的值。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> houseAnimals: <span class="type">Set</span> = [<span class="string">"🐶"</span>, <span class="string">"🐱"</span>]</span><br><span class="line"><span class="keyword">let</span> farmAnimals: <span class="type">Set</span> = [<span class="string">"🐮"</span>, <span class="string">"🐔"</span>, <span class="string">"🐑"</span>, <span class="string">"🐶"</span>, <span class="string">"🐱"</span>]</span><br><span class="line"><span class="keyword">let</span> cityAnimals: <span class="type">Set</span> = [<span class="string">"🐦"</span>, <span class="string">"🐭"</span>]</span><br><span class="line"></span><br><span class="line">houseAnimals.isSubsetOf(farmAnimals)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">farmAnimals.isSupersetOf(houseAnimals)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">farmAnimals.isDisjointWith(cityAnimals)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><a name="dictionaries"></a></p>
<h2 id="字典">字典</h2><p><em>字典</em>是一种存储多个相同类型的值的容器。每个值（value）都关联唯一的键（key），键作为字典中的这个值数据的标识符。和数组中的数据项不同，字典中的数据项并没有具体顺序。我们在需要通过标识符（键）访问数据的时候使用字典，这种方法很大程度上和我们在现实世界中使用字典查字义的方法一样。</p>
<blockquote>
<p>注意：<br>Swift 的<code>Dictionary</code>类型被桥接到<code>Foundation</code>的<code>NSDictionary</code>类。<br>更多关于在<code>Foundation</code>和<code>Cocoa</code>中使用<code>Dictionary</code>类型的信息，参见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216" target="_blank" rel="external"><em>Using Swift with Cocoa and Objective-C (Swift 2.1)</em></a> 一书。</p>
</blockquote>
<p><a name="dictionary_type_shorthand_syntax"></a></p>
<h2 id="字典类型快捷语法">字典类型快捷语法</h2><p>Swift 的字典使用<code>Dictionary&lt;Key, Value&gt;</code>定义，其中<code>Key</code>是字典中键的数据类型，<code>Value</code>是字典中对应于这些键所存储值的数据类型。</p>
<blockquote>
<p>注意：<br>一个字典的<code>Key</code>类型必须遵循<code>Hashable</code>协议，就像<code>Set</code>的值类型。</p>
</blockquote>
<p>我们也可以用<code>[Key: Value]</code>这样快捷的形式去创建一个字典类型。虽然这两种形式功能上相同，但是后者是首选，并且这本指导书涉及到字典类型时通篇采用后者。</p>
<p><a name="creating_an_empty_dictionary"></a></p>
<h3 id="创建一个空字典">创建一个空字典</h3><p>我们可以像数组一样使用构造语法创建一个拥有确定类型的空字典：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> namesOfIntegers = [<span class="type">Int</span>: <span class="type">String</span>]()</span><br><span class="line"><span class="comment">// namesOfIntegers 是一个空的 [Int: String] 字典</span></span><br></pre></td></tr></table></figure>
<p>这个例子创建了一个<code>[Int: String]</code>类型的空字典来储存整数的英语命名。它的键是<code>Int</code>型，值是<code>String</code>型。</p>
<p>如果上下文已经提供了类型信息，我们可以使用空字典字面量来创建一个空字典，记作<code>[:]</code>（中括号中放一个冒号）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">namesOfIntegers[<span class="number">16</span>] = <span class="string">"sixteen"</span></span><br><span class="line"><span class="comment">// namesOfIntegers 现在包含一个键值对</span></span><br><span class="line">namesOfIntegers = [:]</span><br><span class="line"><span class="comment">// namesOfIntegers 又成为了一个 [Int: String] 类型的空字典</span></span><br></pre></td></tr></table></figure>
<p><a name="creating_a_dictionary_with_a_dictionary_literal"></a></p>
<h2 id="用字典字面量创建字典">用字典字面量创建字典</h2><p>我们可以使用字典字面量来构造字典，这和我们刚才介绍过的数组字面量拥有相似语法。字典字面量是一种将一个或多个键值对写作<code>Dictionary</code>集合的快捷途径。</p>
<p>一个键值对是一个<code>key</code>和一个<code>value</code>的结合体。在字典字面量中，每一个键值对的键和值都由冒号分割。这些键值对构成一个列表，其中这些键值对由方括号包含、由逗号分割：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[key <span class="number">1</span>: value <span class="number">1</span>, key <span class="number">2</span>: value <span class="number">2</span>, key <span class="number">3</span>: value <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>下面的例子创建了一个存储国际机场名称的字典。在这个字典中键是三个字母的国际航空运输相关代码，值是机场名称：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> airports: [<span class="type">String</span>: <span class="type">String</span>] = [<span class="string">"YYZ"</span>: <span class="string">"Toronto Pearson"</span>, <span class="string">"DUB"</span>: <span class="string">"Dublin"</span>]</span><br></pre></td></tr></table></figure>
<p><code>airports</code>字典被声明为一种<code>[String: String]</code>类型，这意味着这个字典的键和值都是<code>String</code>类型。</p>
<blockquote>
<p>注意：<br><code>airports</code>字典被声明为变量（用<code>var</code>关键字）而不是常量（<code>let</code>关键字）因为后来更多的机场信息会被添加到这个示例字典中。</p>
</blockquote>
<p><code>airports</code>字典使用字典字面量初始化，包含两个键值对。第一对的键是<code>YYZ</code>，值是<code>Toronto Pearson</code>。第二对的键是<code>DUB</code>，值是<code>Dublin</code>。</p>
<p>这个字典语句包含了两个<code>String: String</code>类型的键值对。它们对应<code>airports</code>变量声明的类型（一个只有<code>String</code>键和<code>String</code>值的字典）所以这个字典字面量的任务是构造拥有两个初始数据项的<code>airport</code>字典。</p>
<p>和数组一样，我们在用字典字面量构造字典时，如果它的键和值都有各自一致的类型，那么就不必写出字典的类型。<br><code>airports</code>字典也可以用这种简短方式定义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> airports = [<span class="string">"YYZ"</span>: <span class="string">"Toronto Pearson"</span>, <span class="string">"DUB"</span>: <span class="string">"Dublin"</span>]</span><br></pre></td></tr></table></figure>
<p>因为这个语句中所有的键和值都各自拥有相同的数据类型，Swift 可以推断出<code>Dictionary&lt;String, String&gt;</code>是<code>airports</code>字典的正确类型。</p>
<p><a name="accessing_and_modifying_a_dictionary"></a></p>
<h3 id="访问和修改字典">访问和修改字典</h3><p>我们可以通过字典的方法和属性来访问和修改字典，或者通过使用下标语法。</p>
<p>和数组一样，我们可以通过字典的只读属性<code>count</code>来获取某个字典的数据项数量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"The dictionary of airports contains <span class="subst">\(airports.<span class="built_in">count</span>)</span> items."</span>)</span><br><span class="line"><span class="comment">// 打印 "The dictionary of airports contains 2 items."（这个字典有两个数据项）</span></span><br></pre></td></tr></table></figure>
<p>使用布尔属性<code>isEmpty</code>来快捷地检查字典的<code>count</code>属性是否等于0：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> airports.isEmpty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The airports dictionary is empty."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The airports dictionary is not empty."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "The airports dictionary is not empty."</span></span><br></pre></td></tr></table></figure>
<p>我们也可以在字典中使用下标语法来添加新的数据项。可以使用一个恰当类型的键作为下标索引，并且分配恰当类型的新值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">airports[<span class="string">"LHR"</span>] = <span class="string">"London"</span></span><br><span class="line"><span class="comment">// airports 字典现在有三个数据项</span></span><br></pre></td></tr></table></figure>
<p>我们也可以使用下标语法来改变特定键对应的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">airports[<span class="string">"LHR"</span>] = <span class="string">"London Heathrow"</span></span><br><span class="line"><span class="comment">// "LHR"对应的值 被改为 "London Heathrow</span></span><br></pre></td></tr></table></figure>
<p>作为另一种下标方法，字典的<code>updateValue(_:forKey:)</code>方法可以设置或者更新特定键对应的值。就像上面所示的下标示例，<code>updateValue(_:forKey:)</code>方法在这个键不存在对应值的时候会设置新值或者在存在时更新已存在的值。和上面的下标方法不同的，<code>updateValue(_:forKey:)</code>这个方法返回更新值之前的原值。这样使得我们可以检查更新是否成功。</p>
<p><code>updateValue(_:forKey:)</code>方法会返回对应值的类型的可选值。举例来说：对于存储<code>String</code>值的字典，这个函数会返回一个<code>String?</code>或者“可选 <code>String</code>”类型的值。</p>
<p>如果有值存在于更新前，则这个可选值包含了旧值，否则它将会是<code>nil</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> oldValue = airports.updateValue(<span class="string">"Dublin Airport"</span>, forKey: <span class="string">"DUB"</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The old value for DUB was <span class="subst">\(oldValue)</span>."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "The old value for DUB was Dublin."</span></span><br></pre></td></tr></table></figure>
<p>我们也可以使用下标语法来在字典中检索特定键对应的值。因为有可能请求的键没有对应的值存在，字典的下标访问会返回对应值的类型的可选值。如果这个字典包含请求键所对应的值，下标会返回一个包含这个存在值的可选值，否则将返回<code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> airportName = airports[<span class="string">"DUB"</span>] &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The name of the airport is <span class="subst">\(airportName)</span>."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"That airport is not in the airports dictionary."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "The name of the airport is Dublin Airport."</span></span><br></pre></td></tr></table></figure>
<p>我们还可以使用下标语法来通过给某个键的对应值赋值为<code>nil</code>来从字典里移除一个键值对：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">airports[<span class="string">"APL"</span>] = <span class="string">"Apple Internation"</span></span><br><span class="line"><span class="comment">// "Apple Internation" 不是真的 APL 机场, 删除它</span></span><br><span class="line">airports[<span class="string">"APL"</span>] = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// APL 现在被移除了</span></span><br></pre></td></tr></table></figure>
<p>此外，<code>removeValueForKey(_:)</code>方法也可以用来在字典中移除键值对。这个方法在键值对存在的情况下会移除该键值对并且返回被移除的值或者在没有值的情况下返回<code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> removedValue = airports.removeValueForKey(<span class="string">"DUB"</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The removed airport's name is <span class="subst">\(removedValue)</span>."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The airports dictionary does not contain a value for DUB."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// prints "The removed airport's name is Dublin Airport."</span></span><br></pre></td></tr></table></figure>
<p><a name="iterating_over_a_dictionary"></a></p>
<h3 id="字典遍历">字典遍历</h3><p>我们可以使用<code>for-in</code>循环来遍历某个字典中的键值对。每一个字典中的数据项都以<code>(key, value)</code>元组形式返回，并且我们可以使用临时常量或者变量来分解这些元组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (airportCode, airportName) <span class="keyword">in</span> airports &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(airportCode)</span>: <span class="subst">\(airportName)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// YYZ: Toronto Pearson</span></span><br><span class="line"><span class="comment">// LHR: London Heathrow</span></span><br></pre></td></tr></table></figure>
<p>更多关于<code>for-in</code>循环的信息，参见<a href="./05_Control_Flow.html#for_loops">For 循环</a>。</p>
<p>通过访问<code>keys</code>或者<code>values</code>属性，我们也可以遍历字典的键或者值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> airportCode <span class="keyword">in</span> airports.keys &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Airport code: <span class="subst">\(airportCode)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Airport code: YYZ</span></span><br><span class="line"><span class="comment">// Airport code: LHR</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> airportName <span class="keyword">in</span> airports.values &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Airport name: <span class="subst">\(airportName)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Airport name: Toronto Pearson</span></span><br><span class="line"><span class="comment">// Airport name: London Heathrow</span></span><br></pre></td></tr></table></figure>
<p>如果我们只是需要使用某个字典的键集合或者值集合来作为某个接受<code>Array</code>实例的 API 的参数，可以直接使用<code>keys</code>或者<code>values</code>属性构造一个新数组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> airportCodes = [<span class="type">String</span>](airports.keys)</span><br><span class="line"><span class="comment">// airportCodes 是 ["YYZ", "LHR"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> airportNames = [<span class="type">String</span>](airports.values)</span><br><span class="line"><span class="comment">// airportNames 是 ["Toronto Pearson", "London Heathrow"]</span></span><br></pre></td></tr></table></figure>
<p>Swift 的字典类型是无序集合类型。为了以特定的顺序遍历字典的键或值，可以对字典的<code>keys</code>或<code>values</code>属性使用<code>sort()</code>方法。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/05_Control_Flow/" itemprop="url">
                第二章-05控制流（Control Flow）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:22+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/05_Control_Flow/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/05_Control_Flow/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="控制流（Control_Flow）">控制流（Control Flow）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/vclwei" target="_blank" rel="external">vclwei</a>, <a href="https://github.com/coverxit" target="_blank" rel="external">coverxit</a>, <a href="https://github.com/NicePiao" target="_blank" rel="external">NicePiao</a><br>校对：<a href="https://github.com/coverxit" target="_blank" rel="external">coverxit</a>, <a href="https://github.com/stanzhai" target="_blank" rel="external">stanzhai</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/AlanMelody" target="_blank" rel="external">JackAlan</a></p>
<p>2.1<br>翻译：<a href="https://github.com/futantan" target="_blank" rel="external">Prayer</a><br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#for_loops">For 循环</a></li>
<li><a href="#while_loops">While 循环</a></li>
<li><a href="#conditional_statement">条件语句</a></li>
<li><a href="#control_transfer_statements">控制转移语句（Control Transfer Statements）</a></li>
<li><a href="#early_exit">提前退出</a></li>
<li><a href="#checking_api_availability">检测API可用性</a></li>
</ul>
<p>Swift 提供了类似 C 语言的流程控制结构，包括可以多次执行任务的<code>for</code>和<code>while</code>循环，基于特定条件选择执行不同代码分支的<code>if</code>、<code>guard</code>和<code>switch</code>语句，还有控制流程跳转到其他代码的<code>break</code>和<code>continue</code>语句。</p>
<p>除了 C 语言里面传统的 for 循环，Swift 还增加了<code>for-in</code>循环，用来更简单地遍历数组（array），字典（dictionary），区间（range），字符串（string）和其他序列类型。</p>
<p>Swift 的<code>switch</code>语句比 C 语言中更加强大。在 C 语言中，如果某个 case 不小心漏写了<code>break</code>，这个 case 就会贯穿至下一个 case，Swift 无需写<code>break</code>，所以不会发生这种贯穿的情况。case 还可以匹配更多的类型模式，包括区间匹配（range matching），元组（tuple）和特定类型的描述。<code>switch</code>的 case 语句中匹配的值可以是由 case 体内部临时的常量或者变量决定，也可以由<code>where</code>分句描述更复杂的匹配条件。</p>
<p><a name="for_loops"></a></p>
<h2 id="For_循环">For 循环</h2><p>Swift 提供两种<code>for</code>循环形式以来按照指定的次数多次执行一系列语句：</p>
<ul>
<li><code>for-in</code>循环对一个集合里面的每个元素执行一系列语句。</li>
<li>for 循环，用来重复执行一系列语句直到达成特定条件达成，一般通过在每次循环完成后增加计数器的值来实现。</li>
</ul>
<p><a name="for_in"></a></p>
<h3 id="For-In">For-In</h3><p>你可以使用<code>for-in</code>循环来遍历一个集合里面的所有元素，例如由数字表示的区间、数组中的元素、字符串中的字符。</p>
<p>下面的例子用来输出乘 5 乘法表前面一部分内容：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span>...<span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(index)</span> times 5 is <span class="subst">\(index * <span class="number">5</span>)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 times 5 is 5</span></span><br><span class="line"><span class="comment">// 2 times 5 is 10</span></span><br><span class="line"><span class="comment">// 3 times 5 is 15</span></span><br><span class="line"><span class="comment">// 4 times 5 is 20</span></span><br><span class="line"><span class="comment">// 5 times 5 is 25</span></span><br></pre></td></tr></table></figure>
<p>例子中用来进行遍历的元素是一组使用闭区间操作符（<code>...</code>）表示的从<code>1</code>到<code>5</code>的数字。<code>index</code>被赋值为闭区间中的第一个数字（<code>1</code>），然后循环中的语句被执行一次。在本例中，这个循环只包含一个语句，用来输出当前<code>index</code>值所对应的乘 5 乘法表结果。该语句执行后，<code>index</code>的值被更新为闭区间中的第二个数字（<code>2</code>），之后<code>print(_:separator:terminator:)</code>函数会再执行一次。整个过程会进行到闭区间结尾为止。</p>
<p>上面的例子中，<code>index</code>是一个每次循环遍历开始时被自动赋值的常量。这种情况下，<code>index</code>在使用前不需要声明，只需要将它包含在循环的声明中，就可以对其进行隐式声明，而无需使用<code>let</code>关键字声明。</p>
<p>如果你不需要知道区间序列内每一项的值，你可以使用下划线（<code>_</code>）替代变量名来忽略对值的访问：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> base = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> power = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> answer = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>...power &#123;</span><br><span class="line">    answer *= base</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(base)</span> to the power of <span class="subst">\(power)</span> is <span class="subst">\(answer)</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "3 to the power of 10 is 59049"</span></span><br></pre></td></tr></table></figure>
<p>这个例子计算 base 这个数的 power 次幂（本例中，是<code>3</code>的<code>10</code>次幂），从<code>1</code>（<code>3</code>的<code>0</code>次幂）开始做<code>3</code>的乘法， 进行<code>10</code>次，使用<code>1</code>到<code>10</code>的闭区间循环。这个计算并不需要知道每一次循环中计数器具体的值，只需要执行了正确的循环次数即可。下划线符号<code>_</code>（替代循环中的变量）能够忽略具体的值，并且不提供循环遍历时对值的访问。</p>
<p>使用<code>for-in</code>遍历一个数组所有元素：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [<span class="string">"Anna"</span>, <span class="string">"Alex"</span>, <span class="string">"Brian"</span>, <span class="string">"Jack"</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello, <span class="subst">\(name)</span>!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Hello, Anna!</span></span><br><span class="line"><span class="comment">// Hello, Alex!</span></span><br><span class="line"><span class="comment">// Hello, Brian!</span></span><br><span class="line"><span class="comment">// Hello, Jack!</span></span><br></pre></td></tr></table></figure>
<p>你也可以通过遍历一个字典来访问它的键值对。遍历字典时，字典的每项元素会以<code>(key, value)</code>元组的形式返回，你可以在<code>for-in</code>循环中使用显式的常量名称来解读<code>(key, value)</code>元组。下面的例子中，字典的键（key）解读为常量<code>animalName</code>，字典的值会被解读为常量<code>legCount</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numberOfLegs = [<span class="string">"spider"</span>: <span class="number">8</span>, <span class="string">"ant"</span>: <span class="number">6</span>, <span class="string">"cat"</span>: <span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> (animalName, legCount) <span class="keyword">in</span> numberOfLegs &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(animalName)</span>s have <span class="subst">\(legCount)</span> legs"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ants have 6 legs</span></span><br><span class="line"><span class="comment">// cats have 4 legs</span></span><br><span class="line"><span class="comment">// spiders have 8 legs</span></span><br></pre></td></tr></table></figure>
<p>字典元素的遍历顺序和插入顺序可能不同，字典的内容在内部是无序的，所以遍历元素时不能保证顺序。关于数组和字典，详情参见<a href="./04_Collection_Types.html">集合类型</a>。</p>
<p><a name="for"></a></p>
<h3 id="For">For</h3><p>除了<code>for-in</code>循环，Swift 提供使用条件判断和递增方法的标准 C 样式<code>for</code>循环:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">var</span> index = <span class="number">0</span>; index &lt; <span class="number">3</span>; ++index &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"index is <span class="subst">\(index)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index is 0</span></span><br><span class="line"><span class="comment">// index is 1</span></span><br><span class="line"><span class="comment">// index is 2</span></span><br></pre></td></tr></table></figure>
<p>下面是一般情况下这种循环方式的格式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> initialization; condition; increment &#123;</span><br><span class="line">	statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和 C 语言中一样，分号将循环的定义分为 3 个部分，不同的是，Swift 不需要使用圆括号将“initialization; condition; increment”包括起来。</p>
<p>这个循环执行流程如下：</p>
<ol>
<li>循环首次启动时，<em>初始化表达式（ initialization expression ）</em>被调用一次，用来初始化循环所需的所有常量和变量。</li>
<li><em>条件表达式（condition expression）</em>被调用，如果表达式调用结果为<code>false</code>，循环结束，继续执行<code>for</code>循环关闭大括号（<code>}</code>）之后的代码。如果表达式调用结果为<code>true</code>，则会执行大括号内部的代码。</li>
<li>执行所有语句之后，执行<em>递增表达式（increment expression）</em>。通常会增加或减少计数器的值，或者根据语句输出来修改某一个初始化的变量。当递增表达式运行完成后，重复执行第 2 步，条件表达式会再次执行。</li>
</ol>
<p>在初始化表达式中声明的常量和变量（比如<code>var index = 0</code>）只在<code>for</code>循环的生命周期里有效。如果想在循环结束后访问<code>index</code>的值，你必须要在循环生命周期开始前声明<code>index</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> index: <span class="type">Int</span></span><br><span class="line"><span class="keyword">for</span> index = <span class="number">0</span>; index &lt; <span class="number">3</span>; ++index &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"index is <span class="subst">\(index)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index is 0</span></span><br><span class="line"><span class="comment">// index is 1</span></span><br><span class="line"><span class="comment">// index is 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The loop statements were executed <span class="subst">\(index)</span> times"</span>)</span><br><span class="line"><span class="comment">// 输出 "The loop statements were executed 3 times</span></span><br></pre></td></tr></table></figure>
<p>注意<code>index</code>在循环结束后最终的值是<code>3</code>而不是<code>2</code>。最后一次调用递增表达式<code>++index</code>会将<code>index</code>设置为<code>3</code>，从而导致<code>index &lt; 3</code>条件为<code>false</code>，并终止循环。</p>
<p><a name="while_loops"></a></p>
<h2 id="While_循环">While 循环</h2><p><code>while</code>循环运行一系列语句直到条件变成<code>false</code>。这类循环适合使用在第一次迭代前迭代次数未知的情况下。Swift 提供两种<code>while</code>循环形式：</p>
<ul>
<li><code>while</code>循环，每次在循环开始时计算条件是否符合；</li>
<li><code>repeat-while</code>循环，每次在循环结束时计算条件是否符合。</li>
</ul>
<p><a name="while"></a></p>
<p>###While</p>
<p><code>while</code>循环从计算单一条件开始。如果条件为<code>true</code>，会重复运行一系列语句，直到条件变为<code>false</code>。</p>
<p>下面是一般情况下 <code>while</code> 循环格式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> condition &#123;  </span><br><span class="line">	statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的例子来玩一个叫做蛇和梯子的小游戏，也叫做滑道和梯子：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/snakesAndLadders_2x.png" alt="image"></p>
<p>游戏的规则如下：</p>
<ul>
<li>游戏盘面包括 25 个方格，游戏目标是达到或者超过第 25 个方格；</li>
<li>每一轮，你通过掷一个 6 边的骰子来确定你移动方块的步数，移动的路线由上图中横向的虚线所示；</li>
<li>如果在某轮结束，你移动到了梯子的底部，可以顺着梯子爬上去；</li>
<li>如果在某轮结束，你移动到了蛇的头部，你会顺着蛇的身体滑下去。</li>
</ul>
<p>游戏盘面可以使用一个<code>Int</code>数组来表达。数组的长度由一个<code>finalSquare</code>常量储存，用来初始化数组和检测最终胜利条件。游戏盘面由 26 个 <code>Int</code> 0 值初始化，而不是 25 个（由<code>0</code>到<code>25</code>，一共 26 个）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> finalSquare = <span class="number">25</span></span><br><span class="line"><span class="keyword">var</span> board = [<span class="type">Int</span>](<span class="built_in">count</span>: finalSquare + <span class="number">1</span>, repeatedValue: <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>一些方块被设置成有蛇或者梯子的指定值。梯子底部的方块是一个正值，使你可以向上移动，蛇头处的方块是一个负值，会让你向下移动：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">board[<span class="number">03</span>] = +<span class="number">08</span>; board[<span class="number">06</span>] = +<span class="number">11</span>; board[<span class="number">09</span>] = +<span class="number">09</span>; board[<span class="number">10</span>] = +<span class="number">02</span></span><br><span class="line">board[<span class="number">14</span>] = -<span class="number">10</span>; board[<span class="number">19</span>] = -<span class="number">11</span>; board[<span class="number">22</span>] = -<span class="number">02</span>; board[<span class="number">24</span>] = -<span class="number">08</span></span><br></pre></td></tr></table></figure>
<p>3 号方块是梯子的底部，会让你向上移动到 11 号方格，我们使用<code>board[03]</code>等于<code>+08</code>（来表示<code>11</code>和<code>3</code>之间的差值）。使用一元加运算符（<code>+i</code>）是为了和一元减运算符（<code>-i</code>）对称，为了让盘面代码整齐，小于 10 的数字都使用 0 补齐（这些风格上的调整都不是必须的，只是为了让代码看起来更加整洁）。</p>
<p>玩家由左下角编号为 0 的方格开始游戏。一般来说玩家第一次掷骰子后才会进入游戏盘面：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> square = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> diceRoll = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> square &lt; finalSquare &#123;</span><br><span class="line">    <span class="comment">// 掷骰子</span></span><br><span class="line">    <span class="keyword">if</span> ++diceRoll == <span class="number">7</span> &#123; diceRoll = <span class="number">1</span> &#125;</span><br><span class="line">    <span class="comment">// 根据点数移动</span></span><br><span class="line">    square += diceRoll</span><br><span class="line">    <span class="keyword">if</span> square &lt; board.<span class="built_in">count</span> &#123;</span><br><span class="line">        <span class="comment">// 如果玩家还在棋盘上，顺着梯子爬上去或者顺着蛇滑下去</span></span><br><span class="line">        square += board[square]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Game over!"</span>)</span><br></pre></td></tr></table></figure>
<p>本例中使用了最简单的方法来模拟掷骰子。 <code>diceRoll</code>的值并不是一个随机数，而是以<code>0</code>为初始值，之后每一次<code>while</code>循环，<code>diceRoll</code>的值使用前置自增操作符(<code>++i</code>)来自增 1 ，然后检测是否超出了最大值。<code>++diceRoll</code>调用完成<em>后</em>，返回值等于<code>diceRoll</code>自增后的值。任何时候如果<code>diceRoll</code>的值等于7时，就超过了骰子的最大值，会被重置为<code>1</code>。所以<code>diceRoll</code>的取值顺序会一直是<code>1</code>，<code>2</code>，<code>3</code>，<code>4</code>，<code>5</code>，<code>6</code>，<code>1</code>，<code>2</code>。</p>
<p>掷完骰子后，玩家向前移动<code>diceRoll</code>个方格，如果玩家移动超过了第 25 个方格，这个时候游戏结束，相应地，代码会在<code>square</code>增加<code>board[square]</code>的值向前或向后移动（遇到了梯子或者蛇）之前，检测<code>square</code>的值是否小于<code>board</code>的<code>count</code>属性。</p>
<p>如果没有这个检测（<code>square &lt; board.count</code>），<code>board[square]</code>可能会越界访问<code>board</code>数组，导致错误。例如如果<code>square</code>等于<code>26</code>， 代码会去尝试访问<code>board[26]</code>，超过数组的长度。</p>
<p>当本轮<code>while</code>循环运行完毕，会再检测循环条件是否需要再运行一次循环。如果玩家移动到或者超过第 25 个方格，循环条件结果为<code>false</code>，此时游戏结束。</p>
<p><code>while</code> 循环比较适合本例中的这种情况，因为在 <code>while</code> 循环开始时，我们并不知道游戏的长度或者循环的次数，只有在达成指定条件时循环才会结束。</p>
<p><a name="repeat_while"></a></p>
<p>###Repeat-While</p>
<p><code>while</code>循环的另外一种形式是<code>repeat-while</code>，它和<code>while</code>的区别是在判断循环条件之前，先执行一次循环的代码块，然后重复循环直到条件为<code>false</code>。</p>
<blockquote>
<p>注意：<br>Swift语言的<code>repeat-while</code>循环合其他语言中的<code>do-while</code>循环是类似的。</p>
</blockquote>
<p>下面是一般情况下 <code>repeat-while</code>循环的格式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">repeat &#123;</span><br><span class="line">	statements</span><br><span class="line">&#125; <span class="keyword">while</span> condition</span><br></pre></td></tr></table></figure>
<p>还是蛇和梯子的游戏，使用<code>repeat-while</code>循环来替代<code>while</code>循环。<code>finalSquare</code>、<code>board</code>、<code>square</code>和<code>diceRoll</code>的值初始化同<code>while</code>循环一样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> finalSquare = <span class="number">25</span></span><br><span class="line"><span class="keyword">var</span> board = [<span class="type">Int</span>](<span class="built_in">count</span>: finalSquare + <span class="number">1</span>, repeatedValue: <span class="number">0</span>)</span><br><span class="line">board[<span class="number">03</span>] = +<span class="number">08</span>; board[<span class="number">06</span>] = +<span class="number">11</span>; board[<span class="number">09</span>] = +<span class="number">09</span>; board[<span class="number">10</span>] = +<span class="number">02</span></span><br><span class="line">board[<span class="number">14</span>] = -<span class="number">10</span>; board[<span class="number">19</span>] = -<span class="number">11</span>; board[<span class="number">22</span>] = -<span class="number">02</span>; board[<span class="number">24</span>] = -<span class="number">08</span></span><br><span class="line"><span class="keyword">var</span> square = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> diceRoll = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><code>repeat-while</code>的循环版本，循环中<em>第一步</em>就需要去检测是否在梯子或者蛇的方块上。没有梯子会让玩家直接上到第 25 个方格，所以玩家不会通过梯子直接赢得游戏。这样在循环开始时先检测是否踩在梯子或者蛇上是安全的。</p>
<p>游戏开始时，玩家在第 0 个方格上，<code>board[0]</code>一直等于 0， 不会有什么影响：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">repeat &#123;</span><br><span class="line">    <span class="comment">// 顺着梯子爬上去或者顺着蛇滑下去</span></span><br><span class="line">    square += board[square]</span><br><span class="line">    <span class="comment">// 掷骰子</span></span><br><span class="line">    <span class="keyword">if</span> ++diceRoll == <span class="number">7</span> &#123; diceRoll = <span class="number">1</span> &#125;</span><br><span class="line">    <span class="comment">// 根据点数移动</span></span><br><span class="line">    square += diceRoll</span><br><span class="line">&#125; <span class="keyword">while</span> square &lt; finalSquare</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Game over!"</span>)</span><br></pre></td></tr></table></figure>
<p>检测完玩家是否踩在梯子或者蛇上之后，开始掷骰子，然后玩家向前移动<code>diceRoll</code>个方格，本轮循环结束。</p>
<p>循环条件（<code>while square &lt; finalSquare</code>）和<code>while</code>方式相同，但是只会在循环结束后进行计算。在这个游戏中，<code>repeat-while</code>表现得比<code>while</code>循环更好。<code>repeat-while</code>方式会在条件判断<code>square</code>没有超出后直接运行<code>square += board[square]</code>，这种方式可以去掉<code>while</code>版本中的数组越界判断。</p>
<p><a name="conditional_statement"></a></p>
<h2 id="条件语句">条件语句</h2><p>根据特定的条件执行特定的代码通常是十分有用的，例如：当错误发生时，你可能想运行额外的代码；或者，当输入的值太大或太小时，向用户显示一条消息等。要实现这些功能，你就需要使用<em>条件语句</em>。</p>
<p>Swift 提供两种类型的条件语句：<code>if</code>语句和<code>switch</code>语句。通常，当条件较为简单且可能的情况很少时，使用<code>if</code>语句。而<code>switch</code>语句更适用于条件较复杂、可能情况较多且需要用到模式匹配（pattern-matching）的情境。</p>
<p><a name="if"></a></p>
<h3 id="If">If</h3><p><code>if</code>语句最简单的形式就是只包含一个条件，当且仅当该条件为<code>true</code>时，才执行相关代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> temperatureInFahrenheit = <span class="number">30</span></span><br><span class="line"><span class="keyword">if</span> temperatureInFahrenheit &lt;= <span class="number">32</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"It's very cold. Consider wearing a scarf."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "It's very cold. Consider wearing a scarf."</span></span><br></pre></td></tr></table></figure>
<p>上面的例子会判断温度是否小于等于 32 华氏度（水的冰点）。如果是，则打印一条消息；否则，不打印任何消息，继续执行<code>if</code>块后面的代码。</p>
<p>当然，<code>if</code>语句允许二选一，也就是当条件为<code>false</code>时，执行 <em>else 语句</em>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">temperatureInFahrenheit = <span class="number">40</span></span><br><span class="line"><span class="keyword">if</span> temperatureInFahrenheit &lt;= <span class="number">32</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"It's very cold. Consider wearing a scarf."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"It's not that cold. Wear a t-shirt."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "It's not that cold. Wear a t-shirt."</span></span><br></pre></td></tr></table></figure>
<p>显然，这两条分支中总有一条会被执行。由于温度已升至 40 华氏度，不算太冷，没必要再围围巾——因此，<code>else</code>分支就被触发了。</p>
<p>你可以把多个<code>if</code>语句链接在一起，像下面这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">temperatureInFahrenheit = <span class="number">90</span></span><br><span class="line"><span class="keyword">if</span> temperatureInFahrenheit &lt;= <span class="number">32</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"It's very cold. Consider wearing a scarf."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> temperatureInFahrenheit &gt;= <span class="number">86</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"It's really warm. Don't forget to wear sunscreen."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"It's not that cold. Wear a t-shirt."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "It's really warm. Don't forget to wear sunscreen."</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，额外的<code>if</code>语句用于判断是不是特别热。而最后的<code>else</code>语句被保留了下来，用于打印既不冷也不热时的消息。</p>
<p>实际上，最后的<code>else</code>语句是可选的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">temperatureInFahrenheit = <span class="number">72</span></span><br><span class="line"><span class="keyword">if</span> temperatureInFahrenheit &lt;= <span class="number">32</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"It's very cold. Consider wearing a scarf."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> temperatureInFahrenheit &gt;= <span class="number">86</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"It's really warm. Don't forget to wear sunscreen."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，由于既不冷也不热，所以不会触发<code>if</code>或<code>else if</code>分支，也就不会打印任何消息。</p>
<p><a name="switch"></a></p>
<h3 id="Switch">Switch</h3><p><code>switch</code>语句会尝试把某个值与若干个模式（pattern）进行匹配。根据第一个匹配成功的模式，<code>switch</code>语句会执行对应的代码。当有可能的情况较多时，通常用<code>switch</code>语句替换<code>if</code>语句。</p>
<p><code>switch</code>语句最简单的形式就是把某个值与一个或若干个相同类型的值作比较：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> some value to consider &#123;</span><br><span class="line"><span class="keyword">case</span> value <span class="number">1</span>:</span><br><span class="line">    respond to value <span class="number">1</span></span><br><span class="line"><span class="keyword">case</span> value <span class="number">2</span>, value <span class="number">3</span>:</span><br><span class="line">    respond to value <span class="number">2</span> or <span class="number">3</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    otherwise, <span class="keyword">do</span> something <span class="keyword">else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>switch</code>语句都由<em>多个 case</em> 构成。为了匹配某些更特定的值，Swift 提供了几种更复杂的匹配模式，这些模式将在本节的稍后部分提到。</p>
<p>每一个 case 都是代码执行的一条分支，这与<code>if</code>语句类似。与之不同的是，<code>switch</code>语句会决定哪一条分支应该被执行。</p>
<p><code>switch</code>语句必须是完备的。这就是说，每一个可能的值都必须至少有一个 case 分支与之对应。在某些不可能涵盖所有值的情况下，你可以使用默认（<code>default</code>）分支满足该要求，这个默认分支必须在<code>switch</code>语句的最后面。</p>
<p>下面的例子使用<code>switch</code>语句来匹配一个名为<code>someCharacter</code>的小写字符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someCharacter: <span class="type">Character</span> = <span class="string">"e"</span></span><br><span class="line"><span class="keyword">switch</span> someCharacter &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"a"</span>, <span class="string">"e"</span>, <span class="string">"i"</span>, <span class="string">"o"</span>, <span class="string">"u"</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(someCharacter)</span> is a vowel"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"f"</span>, <span class="string">"g"</span>, <span class="string">"h"</span>, <span class="string">"j"</span>, <span class="string">"k"</span>, <span class="string">"l"</span>, <span class="string">"m"</span>,</span><br><span class="line"><span class="string">"n"</span>, <span class="string">"p"</span>, <span class="string">"q"</span>, <span class="string">"r"</span>, <span class="string">"s"</span>, <span class="string">"t"</span>, <span class="string">"v"</span>, <span class="string">"w"</span>, <span class="string">"x"</span>, <span class="string">"y"</span>, <span class="string">"z"</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(someCharacter)</span> is a consonant"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(someCharacter)</span> is not a vowel or a consonant"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "e is a vowel"</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，第一个 case 分支用于匹配五个元音，第二个 case 分支用于匹配所有的辅音。</p>
<p>由于为其它可能的字符写 case 分支没有实际的意义，因此在这个例子中使用了默认分支来处理剩下的既不是元音也不是辅音的字符——这就保证了<code>switch</code>语句的完备性。</p>
<p><a name="no_implicit_fallthrough"></a></p>
<h4 id="不存在隐式的贯穿（No_Implicit_Fallthrough）">不存在隐式的贯穿（No Implicit Fallthrough）</h4><p>与 C 语言和 Objective-C 中的<code>switch</code>语句不同，在 Swift 中，当匹配的 case 分支中的代码执行完毕后，程序会终止<code>switch</code>语句，而不会继续执行下一个 case 分支。这也就是说，不需要在 case 分支中显式地使用<code>break</code>语句。这使得<code>switch</code>语句更安全、更易用，也避免了因忘记写<code>break</code>语句而产生的错误。</p>
<blockquote>
<p>注意：<br>虽然在Swift中<code>break</code>不是必须的，但你依然可以在 case 分支中的代码执行完毕前使用<code>break</code>跳出，详情请参见<a href="#break_in_a_switch_statement">Switch 语句中的 break</a>。</p>
</blockquote>
<p>每一个 case 分支都<em>必须</em>包含至少一条语句。像下面这样书写代码是无效的，因为第一个 case 分支是空的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherCharacter: <span class="type">Character</span> = <span class="string">"a"</span></span><br><span class="line"><span class="keyword">switch</span> anotherCharacter &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"a"</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">"A"</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The letter A"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Not the letter A"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// this will report a compile-time error</span></span><br></pre></td></tr></table></figure>
<p>不像 C 语言里的<code>switch</code>语句，在 Swift 中，<code>switch</code>语句不会同时匹配<code>&quot;a&quot;</code>和<code>&quot;A&quot;</code>。相反的，上面的代码会引起编译期错误：<code>case &quot;a&quot;: does not contain any executable statements</code>——这就避免了意外地从一个 case 分支贯穿到另外一个，使得代码更安全、也更直观。</p>
<p>一个 case 也可以包含多个模式，用逗号把它们分开（如果太长了也可以分行写）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> some value to consider &#123;</span><br><span class="line"><span class="keyword">case</span> value <span class="number">1</span>, value <span class="number">2</span>:</span><br><span class="line">	statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>如果想要贯穿至特定的 case 分支中，请使用<code>fallthrough</code>语句，详情请参考<a href="#fallthrough">贯穿（Fallthrough）</a>。</p>
</blockquote>
<p><a name="interval_matching"></a></p>
<h4 id="区间匹配">区间匹配</h4><p>case 分支的模式也可以是一个值的区间。下面的例子展示了如何使用区间匹配来输出任意数字对应的自然语言格式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> approximateCount = <span class="number">62</span></span><br><span class="line"><span class="keyword">let</span> countedThings = <span class="string">"moons orbiting Saturn"</span></span><br><span class="line"><span class="keyword">var</span> naturalCount: <span class="type">String</span></span><br><span class="line"><span class="keyword">switch</span> approximateCount &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    naturalCount = <span class="string">"no"</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>..&lt;<span class="number">5</span>:</span><br><span class="line">    naturalCount = <span class="string">"a few"</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>..&lt;<span class="number">12</span>:</span><br><span class="line">    naturalCount = <span class="string">"several"</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">12</span>..&lt;<span class="number">100</span>:</span><br><span class="line">    naturalCount = <span class="string">"dozens of"</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">100</span>..&lt;<span class="number">1000</span>:</span><br><span class="line">    naturalCount = <span class="string">"hundreds of"</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    naturalCount = <span class="string">"many"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"There are <span class="subst">\(naturalCount)</span> <span class="subst">\(countedThings)</span>."</span>)</span><br><span class="line"><span class="comment">// 输出 "There are dozens of moons orbiting Saturn."</span></span><br></pre></td></tr></table></figure>
<p>在上例中，<code>approximateCount</code>在一个<code>switch</code>声明中被估值。每一个<code>case</code>都与之进行比较。因为<code>approximateCount</code>落在了12到100的区间，所以<code>naturalCount</code>等于<code>&quot;dozens of&quot;</code>值，并且此后这段执行跳出了<code>switch</code>声明。</p>
<blockquote>
<p>注意：<br>闭区间操作符(<code>...</code>)以及半开区间操作符(<code>..&lt;</code>)功能被重载去返回<code>IntervalType</code>或<code>Range</code>。一个区间可以决定他是否包含特定的元素，就像当匹配一个<code>switch</code>声明的<code>case</code>一样。区间是一个连续值的集合，可以用<code>for-in</code>语句遍历它。</p>
</blockquote>
<p><a name="tuples"></a></p>
<h4 id="元组（Tuple）">元组（Tuple）</h4><p>我们可以使用元组在同一个<code>switch</code>语句中测试多个值。元组中的元素可以是值，也可以是区间。另外，使用下划线（<code>_</code>）来匹配所有可能的值。</p>
<p>下面的例子展示了如何使用一个<code>(Int, Int)</code>类型的元组来分类下图中的点(x, y)：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> somePoint = (<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">switch</span> somePoint &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"(0, 0) is at the origin"</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="number">_</span>, <span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"(<span class="subst">\(somePoint.<span class="number">0</span>)</span>, 0) is on the x-axis"</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="number">_</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"(0, <span class="subst">\(somePoint.<span class="number">1</span>)</span>) is on the y-axis"</span>)</span><br><span class="line"><span class="keyword">case</span> (-<span class="number">2</span>...<span class="number">2</span>, -<span class="number">2</span>...<span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"(<span class="subst">\(somePoint.<span class="number">0</span>)</span>, <span class="subst">\(somePoint.<span class="number">1</span>)</span>) is inside the box"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"(<span class="subst">\(somePoint.<span class="number">0</span>)</span>, <span class="subst">\(somePoint.<span class="number">1</span>)</span>) is outside of the box"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "(1, 1) is inside the box"</span></span><br></pre></td></tr></table></figure>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/coordinateGraphSimple_2x.png" alt="image"></p>
<p>在上面的例子中，<code>switch</code>语句会判断某个点是否是原点(0, 0)，是否在红色的x轴上，是否在黄色y轴上，是否在一个以原点为中心的4x4的矩形里，或者在这个矩形外面。</p>
<p>不像 C 语言，Swift 允许多个 case 匹配同一个值。实际上，在这个例子中，点(0, 0)可以匹配所有<em>四个 case</em>。但是，如果存在多个匹配，那么只会执行第一个被匹配到的 case 分支。考虑点(0, 0)会首先匹配<code>case (0, 0)</code>，因此剩下的能够匹配(0, 0)的 case 分支都会被忽视掉。</p>
<p><a name="value_bindings"></a></p>
<h4 id="值绑定（Value_Bindings）">值绑定（Value Bindings）</h4><p>case 分支的模式允许将匹配的值绑定到一个临时的常量或变量，这些常量或变量在该 case 分支里就可以被引用了——这种行为被称为<em>值绑定</em>（value binding）。</p>
<p>下面的例子展示了如何在一个<code>(Int, Int)</code>类型的元组中使用值绑定来分类下图中的点(x, y)：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherPoint = (<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">switch</span> anotherPoint &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="keyword">let</span> x, <span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"on the x-axis with an x value of <span class="subst">\(x)</span>"</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="keyword">let</span> y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"on the y-axis with a y value of <span class="subst">\(y)</span>"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"somewhere else at (<span class="subst">\(x)</span>, <span class="subst">\(y)</span>)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "on the x-axis with an x value of 2"</span></span><br></pre></td></tr></table></figure>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/coordinateGraphMedium_2x.png" alt="image"></p>
<p>在上面的例子中，<code>switch</code>语句会判断某个点是否在红色的x轴上，是否在黄色y轴上，或者不在坐标轴上。</p>
<p>这三个 case 都声明了常量<code>x</code>和<code>y</code>的占位符，用于临时获取元组<code>anotherPoint</code>的一个或两个值。第一个 case ——<code>case (let x, 0)</code>将匹配一个纵坐标为<code>0</code>的点，并把这个点的横坐标赋给临时的常量<code>x</code>。类似的，第二个 case ——<code>case (0, let y)</code>将匹配一个横坐标为<code>0</code>的点，并把这个点的纵坐标赋给临时的常量<code>y</code>。</p>
<p>一旦声明了这些临时的常量，它们就可以在其对应的 case 分支里引用。在这个例子中，它们用于简化<code>print(_:separator:terminator:)</code>的书写。</p>
<p>请注意，这个<code>switch</code>语句不包含默认分支。这是因为最后一个 case ——<code>case let(x, y)</code>声明了一个可以匹配余下所有值的元组。这使得<code>switch</code>语句已经完备了，因此不需要再书写默认分支。</p>
<p>在上面的例子中，<code>x</code>和<code>y</code>是常量，这是因为没有必要在其对应的 case 分支中修改它们的值。然而，它们也可以是变量——程序将会创建临时变量，并用相应的值初始化它。修改这些变量只会影响其对应的 case 分支。</p>
<p><a name="where"></a></p>
<h4 id="Where">Where</h4><p>case 分支的模式可以使用<code>where</code>语句来判断额外的条件。</p>
<p>下面的例子把下图中的点(x, y)进行了分类：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> yetAnotherPoint = (<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line"><span class="keyword">switch</span> yetAnotherPoint &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">where</span> x == y:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"(<span class="subst">\(x)</span>, <span class="subst">\(y)</span>) is on the line x == y"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">where</span> x == -y:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"(<span class="subst">\(x)</span>, <span class="subst">\(y)</span>) is on the line x == -y"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"(<span class="subst">\(x)</span>, <span class="subst">\(y)</span>) is just some arbitrary point"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "(1, -1) is on the line x == -y"</span></span><br></pre></td></tr></table></figure>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/coordinateGraphComplex_2x.png" alt="image"></p>
<p>在上面的例子中，<code>switch</code>语句会判断某个点是否在绿色的对角线<code>x == y</code>上，是否在紫色的对角线<code>x == -y</code>上，或者不在对角线上。</p>
<p>这三个 case 都声明了常量<code>x</code>和<code>y</code>的占位符，用于临时获取元组<code>yetAnotherPoint</code>的两个值。这些常量被用作<code>where</code>语句的一部分，从而创建一个动态的过滤器(filter)。当且仅当<code>where</code>语句的条件为<code>true</code>时，匹配到的 case 分支才会被执行。</p>
<p>就像是值绑定中的例子，由于最后一个 case 分支匹配了余下所有可能的值，<code>switch</code>语句就已经完备了，因此不需要再书写默认分支。</p>
<p><a name="control_transfer_statements"></a></p>
<h2 id="控制转移语句（Control_Transfer_Statements）">控制转移语句（Control Transfer Statements）</h2><p>控制转移语句改变你代码的执行顺序，通过它你可以实现代码的跳转。Swift 有五种控制转移语句：</p>
<ul>
<li><code>continue</code></li>
<li><code>break</code></li>
<li><code>fallthrough</code></li>
<li><code>return</code></li>
<li><code>throw</code></li>
</ul>
<p>我们将会在下面讨论<code>continue</code>、<code>break</code>和<code>fallthrough</code>语句。<code>return</code>语句将会在<a href="./06_Functions.html">函数</a>章节讨论，<code>throw</code>语句会在<a href="./18_Error_Handling.html#throwing_errors">错误抛出</a>章节讨论。</p>
<p><a name="continue"></a></p>
<h3 id="Continue">Continue</h3><p><code>continue</code>语句告诉一个循环体立刻停止本次循环迭代，重新开始下次循环迭代。就好像在说“本次循环迭代我已经执行完了”，但是并不会离开整个循环体。</p>
<blockquote>
<p>注意：<br>在一个带有条件和递增的for循环体中，调用<code>continue</code>语句后，迭代增量仍然会被计算求值。循环体继续像往常一样工作，仅仅只是循环体中的执行代码会被跳过。</p>
</blockquote>
<p>下面的例子把一个小写字符串中的元音字母和空格字符移除，生成了一个含义模糊的短句：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> puzzleInput = <span class="string">"great minds think alike"</span></span><br><span class="line"><span class="keyword">var</span> puzzleOutput = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> character <span class="keyword">in</span> puzzleInput.characters &#123;</span><br><span class="line">    <span class="keyword">switch</span> character &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"a"</span>, <span class="string">"e"</span>, <span class="string">"i"</span>, <span class="string">"o"</span>, <span class="string">"u"</span>, <span class="string">" "</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        puzzleOutput.append(character)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(puzzleOutput)</span><br><span class="line"><span class="comment">// 输出 "grtmndsthnklk"</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，只要匹配到元音字母或者空格字符，就调用<code>continue</code>语句，使本次循环迭代结束，从新开始下次循环迭代。这种行为使<code>switch</code>匹配到元音字母和空格字符时不做处理，而不是让每一个匹配到的字符都被打印。</p>
<p><a name="break"></a></p>
<h3 id="Break">Break</h3><p><code>break</code>语句会立刻结束整个控制流的执行。当你想要更早的结束一个<code>switch</code>代码块或者一个循环体时，你都可以使用<code>break</code>语句。</p>
<p><a name="break_in_a_loop_statement"></a></p>
<h4 id="循环语句中的_break">循环语句中的 break</h4><p>当在一个循环体中使用<code>break</code>时，会立刻中断该循环体的执行，然后跳转到表示循环体结束的大括号(<code>}</code>)后的第一行代码。不会再有本次循环迭代的代码被执行，也不会再有下次的循环迭代产生。</p>
<p><a name="break_in_a_switch_statement"></a></p>
<h4 id="Switch_语句中的_break">Switch 语句中的 break</h4><p>当在一个<code>switch</code>代码块中使用<code>break</code>时，会立即中断该<code>switch</code>代码块的执行，并且跳转到表示<code>switch</code>代码块结束的大括号(<code>}</code>)后的第一行代码。</p>
<p>这种特性可以被用来匹配或者忽略一个或多个分支。因为 Swift 的<code>switch</code>需要包含所有的分支而且不允许有为空的分支，有时为了使你的意图更明显，需要特意匹配或者忽略某个分支。那么当你想忽略某个分支时，可以在该分支内写上<code>break</code>语句。当那个分支被匹配到时，分支内的<code>break</code>语句立即结束<code>switch</code>代码块。</p>
<blockquote>
<p>注意：<br>当一个<code>switch</code>分支仅仅包含注释时，会被报编译时错误。注释不是代码语句而且也不能让<code>switch</code>分支达到被忽略的效果。你总是可以使用<code>break</code>来忽略某个分支。</p>
</blockquote>
<p>下面的例子通过<code>switch</code>来判断一个<code>Character</code>值是否代表下面四种语言之一。为了简洁，多个值被包含在了同一个分支情况中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numberSymbol: <span class="type">Character</span> = <span class="string">"三"</span>  <span class="comment">// 简体中文里的数字 3</span></span><br><span class="line"><span class="keyword">var</span> possibleIntegerValue: <span class="type">Int</span>?</span><br><span class="line"><span class="keyword">switch</span> numberSymbol &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"1"</span>, <span class="string">"١"</span>, <span class="string">"一"</span>, <span class="string">"๑"</span>:</span><br><span class="line">    possibleIntegerValue = <span class="number">1</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"2"</span>, <span class="string">"٢"</span>, <span class="string">"二"</span>, <span class="string">"๒"</span>:</span><br><span class="line">    possibleIntegerValue = <span class="number">2</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"3"</span>, <span class="string">"٣"</span>, <span class="string">"三"</span>, <span class="string">"๓"</span>:</span><br><span class="line">    possibleIntegerValue = <span class="number">3</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"4"</span>, <span class="string">"٤"</span>, <span class="string">"四"</span>, <span class="string">"๔"</span>:</span><br><span class="line">    possibleIntegerValue = <span class="number">4</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> integerValue = possibleIntegerValue &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The integer value of <span class="subst">\(numberSymbol)</span> is <span class="subst">\(integerValue)</span>."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"An integer value could not be found for <span class="subst">\(numberSymbol)</span>."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "The integer value of 三 is 3."</span></span><br></pre></td></tr></table></figure>
<p>这个例子检查<code>numberSymbol</code>是否是拉丁，阿拉伯，中文或者泰语中的<code>1</code>到<code>4</code>之一。如果被匹配到，该<code>switch</code>分支语句给<code>Int?</code>类型变量<code>possibleIntegerValue</code>设置一个整数值。</p>
<p>当<code>switch</code>代码块执行完后，接下来的代码通过使用可选绑定来判断<code>possibleIntegerValue</code>是否曾经被设置过值。因为是可选类型的缘故，<code>possibleIntegerValue</code>有一个隐式的初始值<code>nil</code>，所以仅仅当<code>possibleIntegerValue</code>曾被<code>switch</code>代码块的前四个分支中的某个设置过一个值时，可选的绑定将会被判定为成功。</p>
<p>在上面的例子中，想要把<code>Character</code>所有的的可能性都枚举出来是不现实的，所以使用<code>default</code>分支来包含所有上面没有匹配到字符的情况。由于这个<code>default</code>分支不需要执行任何动作，所以它只写了一条<code>break</code>语句。一旦落入到<code>default</code>分支中后，<code>break</code>语句就完成了该分支的所有代码操作，代码继续向下，开始执行<code>if let</code>语句。</p>
<p><a name="fallthrough"></a></p>
<h3 id="贯穿（Fallthrough）">贯穿（Fallthrough）</h3><p>Swift 中的<code>switch</code>不会从上一个 case 分支落入到下一个 case 分支中。相反，只要第一个匹配到的 case 分支完成了它需要执行的语句，整个<code>switch</code>代码块完成了它的执行。相比之下，C 语言要求你显式地插入<code>break</code>语句到每个<code>switch</code>分支的末尾来阻止自动落入到下一个 case 分支中。Swift 的这种避免默认落入到下一个分支中的特性意味着它的<code>switch</code> 功能要比 C 语言的更加清晰和可预测，可以避免无意识地执行多个 case 分支从而引发的错误。</p>
<p>如果你确实需要 C 风格的贯穿的特性，你可以在每个需要该特性的 case 分支中使用<code>fallthrough</code>关键字。下面的例子使用<code>fallthrough</code>来创建一个数字的描述语句。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> integerToDescribe = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> description = <span class="string">"The number <span class="subst">\(integerToDescribe)</span> is"</span></span><br><span class="line"><span class="keyword">switch</span> integerToDescribe &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>:</span><br><span class="line">    description += <span class="string">" a prime number, and also"</span></span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    description += <span class="string">" an integer."</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(description)</span><br><span class="line"><span class="comment">// 输出 "The number 5 is a prime number, and also an integer."</span></span><br></pre></td></tr></table></figure>
<p>这个例子定义了一个<code>String</code>类型的变量<code>description</code>并且给它设置了一个初始值。函数使用<code>switch</code>逻辑来判断<code>integerToDescribe</code>变量的值。当<code>integerToDescribe</code>的值属于列表中的质数之一时，该函数添加一段文字在<code>description</code>后，来表明这个是数字是一个质数。然后它使用<code>fallthrough</code>关键字来“贯穿”到<code>default</code>分支中。<code>default</code>分支添加一段额外的文字在<code>description</code>的最后，至此<code>switch</code>代码块执行完了。</p>
<p>如果<code>integerToDescribe</code>的值不属于列表中的任何质数，那么它不会匹配到第一个<code>switch</code>分支。而这里没有其他特别的分支情况，所以<code>integerToDescribe</code>匹配到包含所有的<code>default</code>分支中。</p>
<p>当<code>switch</code>代码块执行完后，使用<code>print(_:separator:terminator:)</code>函数打印该数字的描述。在这个例子中，数字<code>5</code>被准确的识别为了一个质数。</p>
<blockquote>
<p>注意：<br><code>fallthrough</code>关键字不会检查它下一个将会落入执行的 case 中的匹配条件。<code>fallthrough</code>简单地使代码执行继续连接到下一个 case 中的执行代码，这和 C 语言标准中的<code>switch</code>语句特性是一样的。</p>
</blockquote>
<p><a name="labeled_statements"></a></p>
<h3 id="带标签的语句">带标签的语句</h3><p>在 Swift 中，你可以在循环体和<code>switch</code>代码块中嵌套循环体和<code>switch</code>代码块来创造复杂的控制流结构。然而，循环体和<code>switch</code>代码块两者都可以使用<code>break</code>语句来提前结束整个方法体。因此，显式地指明<code>break</code>语句想要终止的是哪个循环体或者<code>switch</code>代码块，会很有用。类似地，如果你有许多嵌套的循环体，显式指明<code>continue</code>语句想要影响哪一个循环体也会非常有用。</p>
<p>为了实现这个目的，你可以使用标签来标记一个循环体或者<code>switch</code>代码块，当使用<code>break</code>或者<code>continue</code>时，带上这个标签，可以控制该标签代表对象的中断或者执行。</p>
<p>产生一个带标签的语句是通过在该语句的关键词的同一行前面放置一个标签，并且该标签后面还需带着一个冒号。下面是一个<code>while</code>循环体的语法，同样的规则适用于所有的循环体和<code>switch</code>代码块。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">label name: <span class="keyword">while</span> condition &#123;</span><br><span class="line">	statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的例子是在一个带有标签的<code>while</code>循环体中调用<code>break</code>和<code>continue</code>语句，该循环体是前面章节中<em>蛇和梯子</em>的改编版本。这次，游戏增加了一条额外的规则：</p>
<ul>
<li>为了获胜，你必须<em>刚好</em>落在第 25 个方块中。</li>
</ul>
<p>如果某次掷骰子使你的移动超出第 25 个方块，你必须重新掷骰子，直到你掷出的骰子数刚好使你能落在第 25 个方块中。</p>
<p>游戏的棋盘和之前一样：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/snakesAndLadders_2x.png" alt="image"></p>
<p><code>finalSquare</code>、<code>board</code>、<code>square</code>和<code>diceRoll</code>值被和之前一样的方式初始化：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> finalSquare = <span class="number">25</span></span><br><span class="line"><span class="keyword">var</span> board = [<span class="type">Int</span>](<span class="built_in">count</span>: finalSquare + <span class="number">1</span>, repeatedValue: <span class="number">0</span>)</span><br><span class="line">board[<span class="number">03</span>] = +<span class="number">08</span>; board[<span class="number">06</span>] = +<span class="number">11</span>; board[<span class="number">09</span>] = +<span class="number">09</span>; board[<span class="number">10</span>] = +<span class="number">02</span></span><br><span class="line">board[<span class="number">14</span>] = -<span class="number">10</span>; board[<span class="number">19</span>] = -<span class="number">11</span>; board[<span class="number">22</span>] = -<span class="number">02</span>; board[<span class="number">24</span>] = -<span class="number">08</span></span><br><span class="line"><span class="keyword">var</span> square = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> diceRoll = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这个版本的游戏使用<code>while</code>循环体和<code>switch</code>方法块来实现游戏的逻辑。<code>while</code>循环体有一个标签名<code>gameLoop</code>，来表明它是蛇与梯子的主循环。</p>
<p>该<code>while</code>循环体的条件判断语句是<code>while square !=finalSquare</code>，这表明你必须刚好落在方格25中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">gameLoop: <span class="keyword">while</span> square != finalSquare &#123;</span><br><span class="line">    <span class="keyword">if</span> ++diceRoll == <span class="number">7</span> &#123; diceRoll = <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">switch</span> square + diceRoll &#123;</span><br><span class="line">    <span class="keyword">case</span> finalSquare:</span><br><span class="line">        <span class="comment">// 到达最后一个方块，游戏结束</span></span><br><span class="line">        <span class="keyword">break</span> gameLoop</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> newSquare <span class="keyword">where</span> newSquare &gt; finalSquare:</span><br><span class="line">        <span class="comment">// 超出最后一个方块，再掷一次骰子</span></span><br><span class="line">        <span class="keyword">continue</span> gameLoop</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 本次移动有效</span></span><br><span class="line">        square += diceRoll</span><br><span class="line">        square += board[square]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Game over!"</span>)</span><br></pre></td></tr></table></figure>
<p>每次循环迭代开始时掷骰子。与之前玩家掷完骰子就立即移动不同，这里使用了<code>switch</code>来考虑每次移动可能产生的结果，从而决定玩家本次是否能够移动。</p>
<ul>
<li>如果骰子数刚好使玩家移动到最终的方格里，游戏结束。<code>break gameLoop</code>语句跳转控制去执行<code>while</code>循环体后的第一行代码，游戏结束。</li>
<li>如果骰子数将会使玩家的移动超出最后的方格，那么这种移动是不合法的，玩家需要重新掷骰子。<code>continue gameLoop</code>语句结束本次<code>while</code>循环的迭代，开始下一次循环迭代。</li>
<li>在剩余的所有情况中，骰子数产生的都是合法的移动。玩家向前移动骰子数个方格，然后游戏逻辑再处理玩家当前是否处于蛇头或者梯子的底部。本次循环迭代结束，控制跳转到<code>while</code>循环体的条件判断语句处，再决定是否能够继续执行下次循环迭代。</li>
</ul>
<blockquote>
<p>注意：<br>如果上述的<code>break</code>语句没有使用<code>gameLoop</code>标签，那么它将会中断<code>switch</code>代码块而不是<code>while</code>循环体。使用<code>gameLoop</code>标签清晰的表明了<code>break</code>想要中断的是哪个代码块。<br>同时请注意，当调用<code>continue gameLoop</code>去跳转到下一次循环迭代时，这里使用<code>gameLoop</code>标签并不是严格必须的。因为在这个游戏中，只有一个循环体，所以<code>continue</code>语句会影响到哪个循环体是没有歧义的。然而，<code>continue</code>语句使用<code>gameLoop</code>标签也是没有危害的。这样做符合标签的使用规则，同时参照旁边的<code>break gameLoop</code>，能够使游戏的逻辑更加清晰和易于理解。</p>
</blockquote>
<p><a name="early_exit"></a></p>
<h2 id="提前退出">提前退出</h2><p>像<code>if</code>语句一样，<code>guard</code>的执行取决于一个表达式的布尔值。我们可以使用<code>guard</code>语句来要求条件必须为真时，以执行<code>guard</code>语句后的代码。不同于<code>if</code>语句，一个<code>guard</code>语句总是有一个<code>else</code>分句，如果条件不为真则执行<code>else</code>分句中的代码。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(person: [String: String])</span></span> &#123;</span><br><span class="line">	guard <span class="keyword">let</span> name = person[<span class="string">"name"</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Hello <span class="subst">\(name)</span>"</span>)</span><br><span class="line"></span><br><span class="line">	guard <span class="keyword">let</span> location = person[<span class="string">"location"</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"I hope the weather is nice near you."</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"I hope the weather is nice in <span class="subst">\(location)</span>."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet([<span class="string">"name"</span>: <span class="string">"John"</span>])</span><br><span class="line"><span class="comment">// prints "Hello John!"</span></span><br><span class="line"><span class="comment">// prints "I hope the weather is nice near you."</span></span><br><span class="line">greet([<span class="string">"name"</span>: <span class="string">"Jane"</span>, <span class="string">"location"</span>: <span class="string">"Cupertino"</span>])</span><br><span class="line"><span class="comment">// prints "Hello Jane!"</span></span><br><span class="line"><span class="comment">// prints "I hope the weather is nice in Cupertino."</span></span><br></pre></td></tr></table></figure>
<p>如果<code>guard</code>语句的条件被满足，则在保护语句的封闭大括号结束后继续执行代码。任何使用了可选绑定作为条件的一部分并被分配了值的变量或常量对于剩下的保护语句出现的代码段是可用的。</p>
<p>如果条件不被满足，在<code>else</code>分支上的代码就会被执行。这个分支必须转移控制以退出<code>guard</code>语句出现的代码段。它可以用控制转移语句如<code>return</code>,<code>break</code>,<code>continue</code>或者<code>throw</code>做这件事，或者调用一个不返回的方法或函数，例如<code>fatalError()</code>。</p>
<p>相比于可以实现同样功能的<code>if</code>语句，按需使用<code>guard</code>语句会提升我们代码的可靠性。<br>它可以使你的代码连贯的被执行而不需要将它包在<code>else</code>块中，它可以使你处理违反要求的代码使其接近要求。</p>
<p><a name="checking_api_availability"></a></p>
<h2 id="检测_API_可用性">检测 API 可用性</h2><p>Swift 有检查 API 可用性的内置支持，这可以确保我们不会不小心地使用对于当前部署目标不可用的 API。</p>
<p>编译器使用 SDK 中的可用信息来验证我们的代码中使用的所有 API 在项目指定的部署目标上是否可用。如果我们尝试使用一个不可用的 API，Swift 会在编译期报错。</p>
<p>我们使用一个可用性条件在一个<code>if</code>或<code>guard</code>语句中去有条件的执行一段代码，这取决于我们想要使用的 API 是否在运行时是可用的。编译器使用从可用性条件语句中获取的信息去验证在代码块中调用的 API 是否都可用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> #available(iOS <span class="number">9</span>, <span class="type">OSX</span> <span class="number">10.10</span>, *) &#123;</span><br><span class="line">    <span class="comment">// 在 iOS 使用 iOS 9 的 API, 在 OS X 使用 OS X v10.10 的 API</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 使用先前版本的 iOS 和 OS X 的 API</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上可用性条件指定了在 iOS 系统上，<code>if</code>段的代码仅会在 iOS 9 及更高版本的系统上执行；在 OS X，仅会在 OS X v10.10 及更高版本的系统上执行。最后一个参数，<code>*</code>，是必须写的，用于处理未来潜在的平台。</p>
<p>在它的一般形式中，可用性条件获取了一系列平台名字和版本。平台名字可以是<code>iOS</code>，<code>OSX</code>或<code>watchOS</code>。除了特定的主板本号像 iOS 8，我们可以指定较小的版本号像 iOS 8.3 以及 OS X v10.10.3。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> #available(platform name version, ..., *) &#123;</span><br><span class="line">	statements to execute <span class="keyword">if</span> the <span class="type">APIs</span> are available</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fallback statements to execute <span class="keyword">if</span> the <span class="type">APIs</span> are unavailable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/06_Functions/" itemprop="url">
                第二章-06函数（Functions）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:21+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/06_Functions/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/06_Functions/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="函数（Functions）">函数（Functions）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/honghaoz" target="_blank" rel="external">honghaoz</a><br>校对：<a href="https://github.com/LunaticM" target="_blank" rel="external">LunaticM</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/dreamkidd" target="_blank" rel="external">dreamkidd</a></p>
<p>2.1<br>翻译：<a href="https://github.com/DianQK" target="_blank" rel="external">DianQK</a><br>定稿：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#Defining_and_Calling_Functions">函数定义与调用（Defining and Calling Functions）</a></li>
<li><a href="#Function_Parameters_and_Return_Values">函数参数与返回值（Function Parameters and Return Values）</a></li>
<li><a href="#Function_Parameter_Names">函数参数名称（Function Parameter Names）</a></li>
<li><a href="#Function_Types">函数类型（Function Types）</a></li>
<li><a href="#Nested_Functions">嵌套函数（Nested Functions）</a></li>
</ul>
<p><em>函数</em>是用来完成特定任务的独立的代码块。你给一个函数起一个合适的名字，用来标识函数做什么，并且当函数需要执行的时候，这个名字会被用于“调用”函数。</p>
<p>Swift 统一的函数语法足够灵活，可以用来表示任何函数，包括从最简单的没有参数名字的 C 风格函数，到复杂的带局部和外部参数名的 Objective-C 风格函数。参数可以提供默认值，以简化函数调用。参数也可以既当做传入参数，也当做传出参数，也就是说，一旦函数执行结束，传入的参数值可以被修改。</p>
<p>在 Swift 中，每个函数都有一种类型，包括函数的参数值类型和返回值类型。你可以把函数类型当做任何其他普通变量类型一样处理，这样就可以更简单地把函数当做别的函数的参数，也可以从其他函数中返回函数。函数的定义可以写在在其他函数定义中，这样可以在嵌套函数范围内实现功能封装。</p>
<p><a name="Defining_and_Calling_Functions"></a></p>
<h2 id="函数的定义与调用（Defining_and_Calling_Functions）">函数的定义与调用（Defining and Calling Functions）</h2><p>当你定义一个函数时，你可以定义一个或多个有名字和类型的值，作为函数的输入（称为<em>参数，parameters</em>），也可以定义某种类型的值作为函数执行结束的输出（称为<em>返回类型，return type</em>）。</p>
<p>每个函数有个<em>函数名</em>，用来描述函数执行的任务。要使用一个函数时，你用函数名“调用”，并传给它匹配的输入值（称作<em>实参，arguments</em>）。一个函数的实参必须与函数参数表里参数的顺序一致。</p>
<p>在下面例子中的函数叫做<code>&quot;sayHello(_:)&quot;</code>，之所以叫这个名字,是因为这个函数用一个人的名字当做输入，并返回给这个人的问候语。为了完成这个任务，你定义一个输入参数-一个叫做 <code>personName</code> 的 <code>String</code> 值，和一个包含给这个人问候语的 <code>String</code> 类型的返回值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(personName: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> greeting = <span class="string">"Hello, "</span> + personName + <span class="string">"!"</span></span><br><span class="line">    <span class="keyword">return</span> greeting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的这些信息汇总起来成为函数的<em>定义</em>，并以 <code>func</code> 作为前缀。指定函数返回类型时，用返回箭头 <code>-&gt;</code>（一个连字符后跟一个右尖括号）后跟返回类型的名称的方式来表示。</p>
<p>该定义描述了函数做什么，它期望接收什么和执行结束时它返回的结果是什么类型。这样的定义使得函数可以在别的地方以一种清晰的方式被调用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(sayHello(<span class="string">"Anna"</span>))</span><br><span class="line"><span class="comment">// prints "Hello, Anna!"</span></span><br><span class="line"><span class="built_in">print</span>(sayHello(<span class="string">"Brian"</span>))</span><br><span class="line"><span class="comment">// prints "Hello, Brian!"</span></span><br></pre></td></tr></table></figure>
<p>调用 <code>sayHello(_:)</code> 函数时，在圆括号中传给它一个 <code>String</code> 类型的实参，例如 <code>sayHello(&quot;Anna&quot;)</code>。因为这个函数返回一个 <code>String</code> 类型的值，<code>sayHello</code> 可以被包含在 <code>print(_:separator:terminator:)</code> 的调用中，用来输出这个函数的返回值，正如上面所示。</p>
<p>在 <code>sayHello(_:)</code> 的函数体中，先定义了一个新的名为 <code>greeting</code> 的 <code>String</code> 常量，同时赋值了给 <code>personName</code> 的一个简单问候消息。然后用 <code>return</code> 关键字把这个问候返回出去。一旦 <code>return greeting</code> 被调用，该函数结束它的执行并返回 <code>greeting</code> 的当前值。</p>
<p>你可以用不同的输入值多次调用 <code>sayHello(_:)</code>。上面的例子展示的是用<code>&quot;Anna&quot;</code>和<code>&quot;Brian&quot;</code>调用的结果，该函数分别返回了不同的结果。</p>
<p>为了简化这个函数的定义，可以将问候消息的创建和返回写成一句：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">sayHelloAgain</span><span class="params">(personName: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello again, "</span> + personName + <span class="string">"!"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(sayHelloAgain(<span class="string">"Anna"</span>))</span><br><span class="line"><span class="comment">// prints "Hello again, Anna!"</span></span><br></pre></td></tr></table></figure>
<p><a name="Function_Parameters_and_Return_Values"></a></p>
<h2 id="函数参数与返回值（Function_Parameters_and_Return_Values）">函数参数与返回值（Function Parameters and Return Values）</h2><p>函数参数与返回值在 Swift 中极为灵活。你可以定义任何类型的函数，包括从只带一个未名参数的简单函数到复杂的带有表达性参数名和不同参数选项的复杂函数。</p>
<h3 id="无参函数（Functions_Without_Parameters）">无参函数（Functions Without Parameters）</h3><p>函数可以没有参数。下面这个函数就是一个无参函数，当被调用时，它返回固定的 <code>String</code> 消息：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">sayHelloWorld</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello, world"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(sayHelloWorld())</span><br><span class="line"><span class="comment">// prints "hello, world"</span></span><br></pre></td></tr></table></figure>
<p>尽管这个函数没有参数，但是定义中在函数名后还是需要一对圆括号。当被调用时，也需要在函数名后写一对圆括号。</p>
<h3 id="多参数函数_(Functions_With_Multiple_Parameters)">多参数函数 (Functions With Multiple Parameters)</h3><p>函数可以有多种输入参数，这些参数被包含在函数的括号之中，以逗号分隔。</p>
<p>这个函数取得一个人的名字和是否被招呼作为输入，并对那个人返回适当的问候语:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(personName: String, alreadyGreeted: Bool)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> alreadyGreeted &#123;</span><br><span class="line">        <span class="keyword">return</span> sayHelloAgain(personName)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sayHello(personName)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(sayHello(<span class="string">"Tim"</span>, alreadyGreeted: <span class="literal">true</span>))</span><br><span class="line"><span class="comment">// prints "Hello again, Tim!"</span></span><br></pre></td></tr></table></figure>
<p>你通过在括号内传递一个<code>String</code>参数值和一个标识为<code>alreadyGreeted</code>的<code>Bool</code>值，使用逗号分隔来调用<code>sayHello(_:alreadyGreeted:)</code>函数。</p>
<p>当调用超过一个参数的函数时，第一个参数后的参数根据其对应的参数名称标记，函数参数命名在<a href="#Function_Parameter_Names">函数参数名称（Function Parameter Names）</a>有更详细的描述。</p>
<p><a name="functions_without_return_values"></a></p>
<h3 id="无返回值函数（Functions_Without_Return_Values）">无返回值函数（Functions Without Return Values）</h3><p>函数可以没有返回值。下面是 <code>sayHello(_:)</code> 函数的另一个版本，叫 <code>sayGoodbye(_:)</code>，这个函数直接输出 <code>String</code> 值，而不是返回它：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">sayGoodbye</span><span class="params">(personName: String)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Goodbye, <span class="subst">\(personName)</span>!"</span>)</span><br><span class="line">&#125;</span><br><span class="line">sayGoodbye(<span class="string">"Dave"</span>)</span><br><span class="line"><span class="comment">// prints "Goodbye, Dave!"</span></span><br></pre></td></tr></table></figure>
<p>因为这个函数不需要返回值，所以这个函数的定义中没有返回箭头（-&gt;）和返回类型。</p>
<blockquote>
<p>注意<br>严格上来说，虽然没有返回值被定义，<code>sayGoodbye(_:)</code> 函数依然返回了值。没有定义返回类型的函数会返回特殊的值，叫 <code>Void</code>。它其实是一个空的元组（tuple），没有任何元素，可以写成<code>()</code>。</p>
</blockquote>
<p>被调用时，一个函数的返回值可以被忽略：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">printAndCount</span><span class="params">(stringToPrint: String)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(stringToPrint)</span><br><span class="line">    <span class="keyword">return</span> stringToPrint.characters.<span class="built_in">count</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">printWithoutCounting</span><span class="params">(stringToPrint: String)</span></span> &#123;</span><br><span class="line">    printAndCount(stringToPrint)</span><br><span class="line">&#125;</span><br><span class="line">printAndCount(<span class="string">"hello, world"</span>)</span><br><span class="line"><span class="comment">// prints "hello, world" and returns a value of 12</span></span><br><span class="line">printWithoutCounting(<span class="string">"hello, world"</span>)</span><br><span class="line"><span class="comment">// prints "hello, world" but does not return a value</span></span><br></pre></td></tr></table></figure>
<p>第一个函数 <code>printAndCount(_:)</code>，输出一个字符串并返回 <code>Int</code> 类型的字符数。第二个函数 <code>printWithoutCounting</code>调用了第一个函数，但是忽略了它的返回值。当第二个函数被调用时，消息依然会由第一个函数输出，但是返回值不会被用到。</p>
<blockquote>
<p>注意<br>返回值可以被忽略，但定义了有返回值的函数必须返回一个值，如果在函数定义底部没有返回任何值，将导致编译错误（compile-time error）。</p>
</blockquote>
<p><a name="functions_with_multiple_return_values"></a></p>
<h3 id="多重返回值函数（Functions_with_Multiple_Return_Values）">多重返回值函数（Functions with Multiple Return Values）</h3><p>你可以用元组（tuple）类型让多个值作为一个复合值从函数中返回。</p>
<p>下面的这个例子中，定义了一个名为<code>minMax(_:)</code>的函数，作用是在一个<code>Int</code>数组中找出最小值与最大值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">minMax</span><span class="params">(array: [Int])</span></span> -&gt; (<span class="built_in">min</span>: <span class="type">Int</span>, <span class="built_in">max</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> currentMin = array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> currentMax = array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> array[<span class="number">1</span>..&lt;array.<span class="built_in">count</span>] &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; currentMin &#123;</span><br><span class="line">            currentMin = value</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value &gt; currentMax &#123;</span><br><span class="line">            currentMax = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (currentMin, currentMax)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>minMax(_:)</code>函数返回一个包含两个<code>Int</code>值的元组，这些值被标记为<code>min</code>和<code>max</code>，以便查询函数的返回值时可以通过名字访问它们。</p>
<p><code>minMax(_:)</code>的函数体中，在开始的时候设置两个工作变量<code>currentMin</code>和<code>currentMax</code>的值为数组中的第一个数。然后函数会遍历数组中剩余的值并检查该值是否比<code>currentMin</code>和<code>currentMax</code>更小或更大。最后数组中的最小值与最大值作为一个包含两个<code>Int</code>值的元组返回。</p>
<p>因为元组的成员值已被命名，因此可以通过点语法来检索找到的最小值与最大值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bounds = minMax([<span class="number">8</span>, -<span class="number">6</span>, <span class="number">2</span>, <span class="number">109</span>, <span class="number">3</span>, <span class="number">71</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"min is <span class="subst">\(bounds.<span class="built_in">min</span>)</span> and max is <span class="subst">\(bounds.<span class="built_in">max</span>)</span>"</span>)</span><br><span class="line"><span class="comment">// prints "min is -6 and max is 109"</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，元组的成员不需要在元组从函数中返回时命名，因为它们的名字已经在函数返回类型中指定了。</p>
<p><a name="optional_tuple_return_types"></a></p>
<p>###可选元组返回类型(Optional Tuple Return Types)</p>
<p>如果函数返回的元组类型有可能整个元组都“没有值”，你可以使用<em>可选的（Optional）</em> 元组返回类型反映整个元组可以是<code>nil</code>的事实。你可以通过在元组类型的右括号后放置一个问号来定义一个可选元组，例如<code>(Int, Int)?</code>或<code>(String, Int, Bool)?</code></p>
<blockquote>
<p>注意<br>可选元组类型如<code>(Int, Int)?</code>与元组包含可选类型如<code>(Int?, Int?)</code>是不同的.可选的元组类型，整个元组是可选的，而不只是元组中的每个元素值。</p>
</blockquote>
<p>前面的<code>minMax(_:)</code>函数返回了一个包含两个<code>Int</code>值的元组。但是函数不会对传入的数组执行任何安全检查，如果<code>array</code>参数是一个空数组，如上定义的<code>minMax(_:)</code>在试图访问<code>array[0]</code>时会触发一个运行时错误。</p>
<p>为了安全地处理这个“空数组”问题，将<code>minMax(_:)</code>函数改写为使用可选元组返回类型，并且当数组为空时返回<code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">minMax</span><span class="params">(array: [Int])</span></span> -&gt; (<span class="built_in">min</span>: <span class="type">Int</span>, <span class="built_in">max</span>: <span class="type">Int</span>)? &#123;</span><br><span class="line">    <span class="keyword">if</span> array.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> currentMin = array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> currentMax = array[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> array[<span class="number">1</span>..&lt;array.<span class="built_in">count</span>] &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; currentMin &#123;</span><br><span class="line">            currentMin = value</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value &gt; currentMax &#123;</span><br><span class="line">            currentMax = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (currentMin, currentMax)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以使用可选绑定来检查<code>minMax(_:)</code>函数返回的是一个实际的元组值还是<code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> bounds = minMax([<span class="number">8</span>, -<span class="number">6</span>, <span class="number">2</span>, <span class="number">109</span>, <span class="number">3</span>, <span class="number">71</span>]) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"min is <span class="subst">\(bounds.<span class="built_in">min</span>)</span> and max is <span class="subst">\(bounds.<span class="built_in">max</span>)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// prints "min is -6 and max is 109"</span></span><br></pre></td></tr></table></figure>
<p><a name="Function_Parameter_Names"></a></p>
<h2 id="函数参数名称（Function_Parameter_Names）">函数参数名称（Function Parameter Names）</h2><p>函数参数都有一个<em>外部参数名（external parameter name）</em>和一个<em>局部参数名（local parameter name）</em>。外部参数名用于在函数调用时标注传递给函数的参数，局部参数名在函数的实现内部使用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">(firstParameterName: Int, secondParameterName: Int)</span></span> &#123;</span><br><span class="line">    <span class="comment">// function body goes here</span></span><br><span class="line">    <span class="comment">// firstParameterName and secondParameterName refer to</span></span><br><span class="line">    <span class="comment">// the argument values for the first and second parameters</span></span><br><span class="line">&#125;</span><br><span class="line">someFunction(<span class="number">1</span>, secondParameterName: <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>一般情况下，第一个参数省略其外部参数名，第二个以及随后的参数使用其局部参数名作为外部参数名。所有参数必须有独一无二的局部参数名。尽管多个参数可以有相同的外部参数名，但不同的外部参数名能让你的代码更有可读性。</p>
<p><a name="specifying_external_parameter_names"></a></p>
<h3 id="指定外部参数名（Specifying_External_Parameter_Names）">指定外部参数名（Specifying External Parameter Names）</h3><p>你可以在局部参数名前指定外部参数名，中间以空格分隔：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">(externalParameterName localParameterName: Int)</span></span> &#123;</span><br><span class="line">    <span class="comment">// function body goes here, and can use localParameterName</span></span><br><span class="line">    <span class="comment">// to refer to the argument value for that parameter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>如果你提供了外部参数名，那么函数在被调用时，必须使用外部参数名。</p>
</blockquote>
<p>这个版本的<code>sayHello(_:)</code>函数，接收两个人的名字，会同时返回对他俩的问候：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(to person: String, and anotherPerson: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello <span class="subst">\(person)</span> and <span class="subst">\(anotherPerson)</span>!"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(sayHello(to: <span class="string">"Bill"</span>, and: <span class="string">"Ted"</span>))</span><br><span class="line"><span class="comment">// prints "Hello Bill and Ted!"</span></span><br></pre></td></tr></table></figure>
<p>为每个参数指定外部参数名后，在你调用<code>sayHello(to:and:)</code>函数时两个外部参数名都必须写出来。</p>
<p>使用外部函数名可以使函数以一种更富有表达性的类似句子的方式调用，并使函数体意图清晰，更具可读性。</p>
<h3 id="忽略外部参数名（Omitting_External_Parameter_Names）">忽略外部参数名（Omitting External Parameter Names）</h3><p>如果你不想为第二个及后续的参数设置外部参数名，用一个下划线（<code>_</code>）代替一个明确的参数名。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">(firstParameterName: Int, <span class="number">_</span> secondParameterName: Int)</span></span> &#123;</span><br><span class="line">    <span class="comment">// function body goes here</span></span><br><span class="line">    <span class="comment">// firstParameterName and secondParameterName refer to</span></span><br><span class="line">    <span class="comment">// the argument values for the first and second parameters</span></span><br><span class="line">&#125;</span><br><span class="line">someFunction(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>因为第一个参数默认忽略其外部参数名称，显式地写下划线是多余的。</p>
</blockquote>
<p><a name="default_parameter_values"></a></p>
<h3 id="默认参数值（Default_Parameter_Values）">默认参数值（Default Parameter Values）</h3><p>你可以在函数体中为每个参数定义<code>默认值（Deafult Values）</code>。当默认值被定义后，调用这个函数时可以忽略这个参数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">(parameterWithDefault: Int = <span class="number">12</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// function body goes here</span></span><br><span class="line">    <span class="comment">// if no arguments are passed to the function call,</span></span><br><span class="line">    <span class="comment">// value of parameterWithDefault is 12</span></span><br><span class="line">&#125;</span><br><span class="line">someFunction(<span class="number">6</span>) <span class="comment">// parameterWithDefault is 6</span></span><br><span class="line">someFunction() <span class="comment">// parameterWithDefault is 12</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>将带有默认值的参数放在函数参数列表的最后。这样可以保证在函数调用时，非默认参数的顺序是一致的，同时使得相同的函数在不同情况下调用时显得更为清晰。</p>
</blockquote>
<p><a name="variadic_parameters"></a></p>
<h3 id="可变参数（Variadic_Parameters）">可变参数（Variadic Parameters）</h3><p>一个<code>可变参数（variadic parameter）</code>可以接受零个或多个值。函数调用时，你可以用可变参数来指定函数参数可以被传入不确定数量的输入值。通过在变量类型名后面加入<code>（...）</code>的方式来定义可变参数。</p>
<p>可变参数的传入值在函数体中变为此类型的一个数组。例如，一个叫做 <code>numbers</code> 的 <code>Double...</code> 型可变参数，在函数体内可以当做一个叫 <code>numbers</code> 的 <code>[Double]</code> 型的数组常量。</p>
<p>下面的这个函数用来计算一组任意长度数字的<code>算术平均数（arithmetic mean）</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">arithmeticMean</span><span class="params">(numbers: Double...)</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> total: <span class="type">Double</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        total += number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total / <span class="type">Double</span>(numbers.<span class="built_in">count</span>)</span><br><span class="line">&#125;</span><br><span class="line">arithmeticMean(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// returns 3.0, which is the arithmetic mean of these five numbers</span></span><br><span class="line">arithmeticMean(<span class="number">3</span>, <span class="number">8.25</span>, <span class="number">18.75</span>)</span><br><span class="line"><span class="comment">// returns 10.0, which is the arithmetic mean of these three numbers</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>一个函数最多只能有一个可变参数。</p>
</blockquote>
<p>如果函数有一个或多个带默认值的参数，而且还有一个可变参数，那么把可变参数放在参数表的最后。</p>
<p><a name="constant_and_variable_parameters"></a></p>
<h3 id="常量参数和变量参数（Constant_and_Variable_Parameters）">常量参数和变量参数（Constant and Variable Parameters）</h3><p>函数参数默认是常量。试图在函数体中更改参数值将会导致编译错误。这意味着你不能错误地更改参数值。</p>
<p>但是，有时候，如果函数中有传入参数的变量值副本将是很有用的。你可以通过指定一个或多个参数为变量参数，从而避免自己在函数中定义新的变量。变量参数不是常量，你可以在函数中把它当做新的可修改副本来使用。</p>
<p>通过在参数名前加关键字 <code>var</code> 来定义变量参数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">alignRight</span><span class="params">(<span class="keyword">var</span> string: String, totalLength: Int, pad: Character)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> amountToPad = totalLength - string.characters.<span class="built_in">count</span></span><br><span class="line">    <span class="keyword">if</span> amountToPad &lt; <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> string</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> padString = <span class="type">String</span>(pad)</span><br><span class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>...amountToPad &#123;</span><br><span class="line">        string = padString + string</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> string</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> originalString = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">let</span> paddedString = alignRight(originalString, totalLength: <span class="number">10</span>, pad: <span class="string">"-"</span>)</span><br><span class="line"><span class="comment">// paddedString is equal to "-----hello"</span></span><br><span class="line"><span class="comment">// originalString is still equal to "hello"</span></span><br></pre></td></tr></table></figure>
<p>这个例子中定义了一个叫做 <code>alignRight(_:totalLength:pad:)</code> 的新函数，用来将输入的字符串对齐到更长的输出字符串的右边缘。左侧空余的地方用指定的填充字符填充。这个例子中，字符串<code>&quot;hello&quot;</code>被转换成了<code>&quot;-----hello&quot;</code>。</p>
<p><code>alignRight(_:totalLength:pad:)</code> 函数将输入参数 <code>string</code> 定义为变量参数。这意味着 <code>string</code> 现在可以作为一个局部变量，被传入的字符串值初始化，并且可以在函数体中进行操作。</p>
<p>函数首先计算出有多少字符需要被添加到<code>string</code>的左边，从而将其在整个字符串中右对齐。这个值存储在一个称为<code>amountToPad</code>的本地常量。如果不需要填充（也就是说，如果<code>amountToPad</code>小于1），该函数简单地返回没有任何填充的输入值<code>string</code>。</p>
<p>否则，该函数用<code>pad</code>字符创建一个叫做<code>padString</code>的临时<code>String</code>常量，并将<code>amountToPad</code>个 <code>padString</code>添加到现有字符串的左边。（一个<code>String</code>值不能被添加到一个<code>Character</code>值上，所以<code>padString</code>常量用于确保<code>+</code>操作符两侧都是<code>String</code>值）。</p>
<blockquote>
<p>注意<br>对变量参数所进行的修改在函数调用结束后便消失了，并且对于函数体外是不可见的。变量参数仅仅存在于函数调用的生命周期中。</p>
</blockquote>
<p><a name="in_out_parameters"></a></p>
<h3 id="输入输出参数（In-Out_Parameters）">输入输出参数（In-Out Parameters）</h3><p>变量参数，正如上面所述，仅仅能在函数体内被更改。如果你想要一个函数可以修改参数的值，并且想要在这些修改在函数调用结束后仍然存在，那么就应该把这个参数定义为输入输出参数（In-Out Parameters）。</p>
<p>定义一个输入输出参数时，在参数定义前加 <code>inout</code> 关键字。一个输入输出参数有传入函数的值，这个值被函数修改，然后被传出函数，替换原来的值。想获取更多的关于输入输出参数的细节和相关的编译器优化，请查看<a href="../chapter3/05_Declarations.html#function_declaration">输入输出参数</a>一节。</p>
<!--上面的链接对应的内容没有更新翻译-->
<p>你只能传递变量给输入输出参数。你不能传入常量或者字面量（literal value），因为这些量是不能被修改的。当传入的参数作为输入输出参数时，需要在参数名前加<code>&amp;</code>符，表示这个值可以被函数修改。</p>
<blockquote>
<p>注意<br>输入输出参数不能有默认值，而且可变参数不能用 <code>inout</code> 标记。如果你用 <code>inout</code> 标记一个参数，这个参数不能被 <code>var</code> 或者 <code>let</code> 标记。</p>
</blockquote>
<p>下面是例子，<code>swapTwoInts(_:_:)</code> 函数，有两个分别叫做 <code>a</code> 和 <code>b</code> 的输入输出参数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">swapTwoInts</span><span class="params">(<span class="keyword">inout</span> a: Int, <span class="keyword">inout</span> <span class="number">_</span> b: Int)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA = a</span><br><span class="line">    a = b</span><br><span class="line">    b = temporaryA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 <code>swapTwoInts(_:_:)</code> 函数简单地交换 <code>a</code> 与 <code>b</code> 的值。该函数先将 <code>a</code> 的值存到一个临时常量 <code>temporaryA</code> 中，然后将 <code>b</code> 的值赋给 <code>a</code>，最后将 <code>temporaryA</code> 赋值给 <code>b</code>。</p>
<p>你可以用两个 <code>Int</code> 型的变量来调用 <code>swapTwoInts(_:_:)</code>。需要注意的是，<code>someInt</code> 和 <code>anotherInt</code> 在传入 <code>swapTwoInts(_:_:)</code> 函数前，都加了 <code>&amp;</code> 的前缀：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someInt = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> anotherInt = <span class="number">107</span></span><br><span class="line">swapTwoInts(&amp;someInt, &amp;anotherInt)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"someInt is now <span class="subst">\(someInt)</span>, and anotherInt is now <span class="subst">\(anotherInt)</span>"</span>)</span><br><span class="line"><span class="comment">// prints "someInt is now 107, and anotherInt is now 3"</span></span><br></pre></td></tr></table></figure>
<p>从上面这个例子中，我们可以看到 <code>someInt</code> 和 <code>anotherInt</code> 的原始值在 <code>swapTwoInts(_:_:)</code> 函数中被修改，尽管它们的定义在函数体外。</p>
<blockquote>
<p>注意<br>输入输出参数和返回值是不一样的。上面的 <code>swapTwoInts</code> 函数并没有定义任何返回值，但仍然修改了 <code>someInt</code> 和 <code>anotherInt</code> 的值。输入输出参数是函数对函数体外产生影响的另一种方式。</p>
</blockquote>
<p><a name="Function_Types"></a></p>
<h2 id="函数类型（Function_Types）">函数类型（Function Types）</h2><p>每个函数都有种特定的函数类型，由函数的参数类型和返回类型组成。</p>
<p>例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">addTwoInts</span><span class="params">(a: Int, <span class="number">_</span> b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">multiplyTwoInts</span><span class="params">(a: Int, <span class="number">_</span> b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中定义了两个简单的数学函数：<code>addTwoInts</code> 和 <code>multiplyTwoInts</code>。这两个函数都接受两个 <code>Int</code> 值， 返回一个<code>Int</code>值。</p>
<p>这两个函数的类型是 <code>(Int, Int) -&gt; Int</code>，可以解读为“这个函数类型有两个 <code>Int</code> 型的参数并返回一个 <code>Int</code> 型的值。”。</p>
<p>下面是另一个例子，一个没有参数，也没有返回值的函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">printHelloWorld</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"hello, world"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的类型是：<code>() -&gt; void</code>，或者叫“没有参数，并返回 <code>Void</code> 类型的函数”。</p>
<p><a name="using_function_types"></a></p>
<h3 id="使用函数类型（Using_Function_Types）">使用函数类型（Using Function Types）</h3><p>在 Swift 中，使用函数类型就像使用其他类型一样。例如，你可以定义一个类型为函数的常量或变量，并将适当的函数赋值给它：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mathFunction: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span> = addTwoInts</span><br></pre></td></tr></table></figure>
<p>这个可以解读为：</p>
<p>“定义一个叫做 <code>mathFunction</code> 的变量，类型是‘一个有两个 <code>Int</code> 型的参数并返回一个 <code>Int</code> 型的值的函数’，并让这个新变量指向 <code>addTwoInts</code> 函数”。</p>
<p><code>addTwoInts</code> 和 <code>mathFunction</code> 有同样的类型，所以这个赋值过程在 Swift 类型检查中是允许的。</p>
<p>现在，你可以用 <code>mathFunction</code> 来调用被赋值的函数了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Result: <span class="subst">\(mathFunction(<span class="number">2</span>, <span class="number">3</span>)</span>)"</span>)</span><br><span class="line"><span class="comment">// prints "Result: 5"</span></span><br></pre></td></tr></table></figure>
<p>有相同匹配类型的不同函数可以被赋值给同一个变量，就像非函数类型的变量一样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mathFunction = multiplyTwoInts</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Result: <span class="subst">\(mathFunction(<span class="number">2</span>, <span class="number">3</span>)</span>)"</span>)</span><br><span class="line"><span class="comment">// prints "Result: 6"</span></span><br></pre></td></tr></table></figure>
<p>就像其他类型一样，当赋值一个函数给常量或变量时，你可以让 Swift 来推断其函数类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherMathFunction = addTwoInts</span><br><span class="line"><span class="comment">// anotherMathFunction is inferred to be of type (Int, Int) -&gt; Int</span></span><br></pre></td></tr></table></figure>
<p><a name="function_types_as_parameter_types"></a></p>
<h3 id="函数类型作为参数类型（Function_Types_as_Parameter_Types）">函数类型作为参数类型（Function Types as Parameter Types）</h3><p>你可以用<code>(Int, Int) -&gt; Int</code>这样的函数类型作为另一个函数的参数类型。这样你可以将函数的一部分实现留给函数的调用者来提供。</p>
<p>下面是另一个例子，正如上面的函数一样，同样是输出某种数学运算结果：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">printMathResult</span><span class="params">(mathFunction: <span class="params">(Int, Int)</span></span></span> -&gt; <span class="type">Int</span>, <span class="number">_</span> a: <span class="type">Int</span>, <span class="number">_</span> b: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Result: <span class="subst">\(mathFunction(a, b)</span>)"</span>)</span><br><span class="line">&#125;</span><br><span class="line">printMathResult(addTwoInts, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// prints "Result: 8"</span></span><br></pre></td></tr></table></figure>
<p>这个例子定义了 <code>printMathResult(_:_:_:)</code> 函数，它有三个参数：第一个参数叫 <code>mathFunction</code>，类型是<code>(Int, Int) -&gt; Int</code>，你可以传入任何这种类型的函数；第二个和第三个参数叫 <code>a</code> 和 <code>b</code>，它们的类型都是 <code>Int</code>，这两个值作为已给出的函数的输入值。</p>
<p>当 <code>printMathResult(_:_:_:)</code> 被调用时，它被传入 <code>addTwoInts</code> 函数和整数<code>3</code>和<code>5</code>。它用传入<code>3</code>和<code>5</code>调用 <code>addTwoInts</code>，并输出结果：<code>8</code>。</p>
<p><code>printMathResult(_:_:_:)</code> 函数的作用就是输出另一个适当类型的数学函数的调用结果。它不关心传入函数是如何实现的，它只关心这个传入的函数类型是正确的。这使得 <code>printMathResult(_:_:_:)</code> 能以一种类型安全（type-safe）的方式将一部分功能转给调用者实现。</p>
<p><a name="function_types_as_return_types"></a></p>
<h3 id="函数类型作为返回类型（Function_Types_as_Return_Types）">函数类型作为返回类型（Function Types as Return Types）</h3><p>你可以用函数类型作为另一个函数的返回类型。你需要做的是在返回箭头（<code>-&gt;</code>）后写一个完整的函数类型。</p>
<p>下面的这个例子中定义了两个简单函数，分别是 <code>stepForward</code> 和<code>stepBackward</code>。<code>stepForward</code> 函数返回一个比输入值大一的值。<code>stepBackward</code> 函数返回一个比输入值小一的值。这两个函数的类型都是 <code>(Int) -&gt; Int</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">stepForward</span><span class="params">(input: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> input + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">stepBackward</span><span class="params">(input: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> input - <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面这个叫做 <code>chooseStepFunction(_:)</code> 的函数，它的返回类型是 <code>(Int) -&gt; Int</code> 类型的函数。<code>chooseStepFunction(_:)</code> 根据布尔值 <code>backwards</code> 来返回 <code>stepForward(_:)</code> 函数或 <code>stepBackward(_:)</code> 函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">chooseStepFunction</span><span class="params">(backwards: Bool)</span></span> -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> backwards ? stepBackward : stepForward</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你现在可以用 <code>chooseStepFunction(_:)</code> 来获得两个函数其中的一个：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> currentValue = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> moveNearerToZero = chooseStepFunction(currentValue &gt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// moveNearerToZero now refers to the stepBackward() function</span></span><br></pre></td></tr></table></figure>
<p>上面这个例子中计算出从 <code>currentValue</code> 逐渐接近到<code>0</code>是需要向正数走还是向负数走。<code>currentValue</code> 的初始值是<code>3</code>，这意味着 <code>currentValue &gt; 0</code> 是真的（<code>true</code>），这将使得 <code>chooseStepFunction(_:)</code> 返回 <code>stepBackward(_:)</code> 函数。一个指向返回的函数的引用保存在了 <code>moveNearerToZero</code> 常量中。</p>
<p>现在，<code>moveNearerToZero</code> 指向了正确的函数，它可以被用来数到<code>0</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Counting to zero:"</span>)</span><br><span class="line"><span class="comment">// Counting to zero:</span></span><br><span class="line"><span class="keyword">while</span> currentValue != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(currentValue)</span>... "</span>)</span><br><span class="line">    currentValue = moveNearerToZero(currentValue)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"zero!"</span>)</span><br><span class="line"><span class="comment">// 3...</span></span><br><span class="line"><span class="comment">// 2...</span></span><br><span class="line"><span class="comment">// 1...</span></span><br><span class="line"><span class="comment">// zero!</span></span><br></pre></td></tr></table></figure>
<p><a name="Nested_Functions"></a></p>
<h2 id="嵌套函数（Nested_Functions）">嵌套函数（Nested Functions）</h2><p>这章中你所见到的所有函数都叫全局函数（global functions），它们定义在全局域中。你也可以把函数定义在别的函数体中，称作嵌套函数（nested functions）。</p>
<p>默认情况下，嵌套函数是对外界不可见的，但是可以被它们的外围函数（enclosing function）调用。一个外围函数也可以返回它的某一个嵌套函数，使得这个函数可以在其他域中被使用。</p>
<p>你可以用返回嵌套函数的方式重写 <code>chooseStepFunction(_:)</code> 函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">chooseStepFunction</span><span class="params">(backwards: Bool)</span></span> -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">stepForward</span><span class="params">(input: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> input + <span class="number">1</span> &#125;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">stepBackward</span><span class="params">(input: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> input - <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> backwards ? stepBackward : stepForward</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> currentValue = -<span class="number">4</span></span><br><span class="line"><span class="keyword">let</span> moveNearerToZero = chooseStepFunction(currentValue &gt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// moveNearerToZero now refers to the nested stepForward() function</span></span><br><span class="line"><span class="keyword">while</span> currentValue != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(currentValue)</span>... "</span>)</span><br><span class="line">    currentValue = moveNearerToZero(currentValue)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"zero!"</span>)</span><br><span class="line"><span class="comment">// -4...</span></span><br><span class="line"><span class="comment">// -3...</span></span><br><span class="line"><span class="comment">// -2...</span></span><br><span class="line"><span class="comment">// -1...</span></span><br><span class="line"><span class="comment">// zero!</span></span><br></pre></td></tr></table></figure>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/07_Closures/" itemprop="url">
                第二章-07闭包（Closures）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:20+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/07_Closures/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/07_Closures/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="闭包（Closures）">闭包（Closures）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/wh1100717" target="_blank" rel="external">wh1100717</a><br>校对：<a href="https://github.com/lyuka" target="_blank" rel="external">lyuka</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/100mango" target="_blank" rel="external">100mango</a></p>
<p>2.1<br>翻译：<a href="https://github.com/100mango" target="_blank" rel="external">100mango</a>, <a href="https://github.com/magicdict" target="_blank" rel="external">magicdict</a><br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#closure_expressions">闭包表达式（Closure Expressions）</a></li>
<li><a href="#trailing_closures">尾随闭包（Trailing Closures）</a></li>
<li><a href="#capturing_values">值捕获（Capturing Values）</a></li>
<li><a href="#closures_are_reference_types">闭包是引用类型（Closures Are Reference Types）</a></li>
<li><a href="#nonescaping_closures">非逃逸闭包(Nonescaping Closures) </a></li>
<li><a href="#autoclosures">自动闭包（Autoclosures）</a></li>
</ul>
<p>闭包是自包含的函数代码块，可以在代码中被传递和使用。Swift 中的闭包与 C 和 Objective-C 中的代码块（blocks）以及其他一些编程语言中的匿名函数比较相似。</p>
<p>闭包可以捕获和存储其所在上下文中任意常量和变量的引用。这就是所谓的闭合并包裹着这些常量和变量，俗称闭包。Swift 会为您管理在捕获过程中涉及到的所有内存操作。</p>
<blockquote>
<p>注意<br>如果您不熟悉捕获（capturing）这个概念也不用担心，您可以在<a href="#capturing_values">值捕获</a>章节对其进行详细了解。</p>
</blockquote>
<p>在<a href="./06_Functions.html">函数</a>章节中介绍的全局和嵌套函数实际上也是特殊的闭包，闭包采取如下三种形式之一：</p>
<ul>
<li>全局函数是一个有名字但不会捕获任何值的闭包</li>
<li>嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包</li>
<li>闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包</li>
</ul>
<p>Swift 的闭包表达式拥有简洁的风格，并鼓励在常见场景中进行语法优化，主要优化如下：</p>
<ul>
<li>利用上下文推断参数和返回值类型</li>
<li>隐式返回单表达式闭包，即单表达式闭包可以省略<code>return</code>关键字</li>
<li>参数名称缩写</li>
<li>尾随（Trailing）闭包语法</li>
</ul>
<p><a name="closure_expressions"></a></p>
<h2 id="闭包表达式（Closure_Expressions）">闭包表达式（Closure Expressions）</h2><p><a href="./06_Functions.html#nested_function">嵌套函数</a>是一个在较复杂函数中方便进行命名和定义自包含代码模块的方式。当然，有时候撰写小巧的没有完整定义和命名的类函数结构也是很有用处的，尤其是在您处理一些函数并需要将另外一些函数作为该函数的参数时。</p>
<p>闭包表达式是一种利用简洁语法构建内联闭包的方式。闭包表达式提供了一些语法优化，使得撰写闭包变得简单明了。下面闭包表达式的例子通过使用几次迭代展示了<code>sort(_:)</code>方法定义和语法优化的方式。每一次迭代都用更简洁的方式描述了相同的功能。</p>
<p><a name="the_sorted_function"></a></p>
<h3 id="sort_方法（The_Sort_Method）">sort 方法（The Sort Method）</h3><p>Swift 标准库提供了名为<code>sort</code>的方法，会根据您提供的用于排序的闭包函数将已知类型数组中的值进行排序。一旦排序完成，<code>sort(_:)</code>方法会返回一个与原数组大小相同,包含同类型元素且元素已正确排序的新数组。原数组不会被<code>sort(_:)</code>方法修改。</p>
<p>下面的闭包表达式示例使用<code>sort(_:)</code>方法对一个<code>String</code>类型的数组进行字母逆序排序.以下是初始数组值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [<span class="string">"Chris"</span>, <span class="string">"Alex"</span>, <span class="string">"Ewa"</span>, <span class="string">"Barry"</span>, <span class="string">"Daniella"</span>]</span><br></pre></td></tr></table></figure>
<p><code>sort(_:)</code>方法接受一个闭包，该闭包函数需要传入与数组元素类型相同的两个值，并返回一个布尔类型值来表明当排序结束后传入的第一个参数排在第二个参数前面还是后面。如果第一个参数值出现在第二个参数值前面，排序闭包函数需要返回<code>true</code>，反之返回<code>false</code>。</p>
<p>该例子对一个<code>String</code>类型的数组进行排序，因此排序闭包函数类型需为<code>(String, String) -&gt; Bool</code>。</p>
<p>提供排序闭包函数的一种方式是撰写一个符合其类型要求的普通函数，并将其作为<code>sort(_:)</code>方法的参数传入：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">backwards</span><span class="params">(s1: String, s2: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s1 &gt; s2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> reversed = names.<span class="built_in">sort</span>(backwards)</span><br><span class="line"><span class="comment">// reversed 为 ["Ewa", "Daniella", "Chris", "Barry", "Alex"]</span></span><br></pre></td></tr></table></figure>
<p>如果第一个字符串（<code>s1</code>）大于第二个字符串（<code>s2</code>），<code>backwards(_:_:)</code>函数返回<code>true</code>，表示在新的数组中<code>s1</code>应该出现在<code>s2</code>前。对于字符串中的字符来说，“大于”表示“按照字母顺序较晚出现”。这意味着字母<code>&quot;B&quot;</code>大于字母<code>&quot;A&quot;</code>，字符串<code>&quot;Tom&quot;</code>大于字符串<code>&quot;Tim&quot;</code>。该闭包将进行字母逆序排序，<code>&quot;Barry&quot;</code>将会排在<code>&quot;Alex&quot;</code>之前。</p>
<p>然而，这是一个相当冗长的方式，本质上只是写了一个单表达式函数 (<code>a &gt; b</code>)。在下面的例子中，利用闭合表达式语法可以更好地构造一个内联排序闭包。</p>
<p><a name="closure_expression_syntax"></a></p>
<h3 id="闭包表达式语法（Closure_Expression_Syntax）">闭包表达式语法（Closure Expression Syntax）</h3><p>闭包表达式语法有如下一般形式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; (parameters) -&gt; returnType <span class="keyword">in</span></span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>闭包表达式语法可以使用常量、变量和<code>inout</code>类型作为参数，不能提供默认值。也可以在参数列表的最后使用可变参数。元组也可以作为参数和返回值。</p>
<p>下面的例子展示了之前<code>backwards(_:_:)</code>函数对应的闭包表达式版本的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reversed = names.<span class="built_in">sort</span>(&#123; (s1: <span class="type">String</span>, s2: <span class="type">String</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> s1 &gt; s2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>需要注意的是内联闭包参数和返回值类型声明与<code>backwards(_:_:)</code>函数类型声明相同。在这两种方式中，都写成了<code>(s1: String, s2: String) -&gt; Bool</code>。然而在内联闭包表达式中，函数和返回值类型都写在大括号内，而不是大括号外。</p>
<p>闭包的函数体部分由关键字<code>in</code>引入。该关键字表示闭包的参数和返回值类型定义已经完成，闭包函数体即将开始。</p>
<p>由于这个闭包的函数体部分如此短，以至于可以将其改写成一行代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversed = names.<span class="built_in">sort</span>( &#123; (s1: <span class="type">String</span>, s2: <span class="type">String</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span> <span class="keyword">return</span> s1 &gt; s2 &#125; )</span><br></pre></td></tr></table></figure>
<p>该例中<code>sort(_:)</code>方法的整体调用保持不变，一对圆括号仍然包裹住了方法的整个参数。然而，参数现在变成了内联闭包。</p>
<p><a name="inferring_type_from_context"></a></p>
<h3 id="根据上下文推断类型（Inferring_Type_From_Context）">根据上下文推断类型（Inferring Type From Context）</h3><p>因为排序闭包函数是作为<code>sort(_:)</code>方法的参数传入的，Swift 可以推断其参数和返回值的类型。<code>sort(_:)</code>方法被一个字符串数组调用，因此其参数必须是<code>(String, String) -&gt; Bool</code>类型的函数。这意味着<code>(String, String)</code>和<code>Bool</code>类型并不需要作为闭包表达式定义的一部分。因为所有的类型都可以被正确推断，返回箭头（<code>-&gt;</code>）和围绕在参数周围的括号也可以被省略：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversed = names.<span class="built_in">sort</span>( &#123; s1, s2 <span class="keyword">in</span> <span class="keyword">return</span> s1 &gt; s2 &#125; )</span><br></pre></td></tr></table></figure>
<p>实际上任何情况下，通过内联闭包表达式构造的闭包作为参数传递给函数或方法时，都可以推断出闭包的参数和返回值类型。<br>这意味着闭包作为函数或者方法的参数时，您几乎不需要利用完整格式构造内联闭包。</p>
<p>尽管如此，您仍然可以明确写出有着完整格式的闭包。如果完整格式的闭包能够提高代码的可读性，则可以采用完整格式的闭包。而在<code>sort(_:)</code>方法这个例子里，闭包的目的就是排序。由于这个闭包是为了处理字符串数组的排序，因此读者能够推测出这个闭包是用于字符串处理的。</p>
<p><a name="implicit_returns_from_single_expression_closures"></a></p>
<h3 id="单表达式闭包隐式返回（Implicit_Return_From_Single-Expression_Clossures）">单表达式闭包隐式返回（Implicit Return From Single-Expression Clossures）</h3><p>单行表达式闭包可以通过省略<code>return</code>关键字来隐式返回单行表达式的结果，如上版本的例子可以改写为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversed = names.<span class="built_in">sort</span>( &#123; s1, s2 <span class="keyword">in</span> s1 &gt; s2 &#125; )</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>sort(_:)</code>方法的第二个参数函数类型明确了闭包必须返回一个<code>Bool</code>类型值。因为闭包函数体只包含了一个单一表达式（<code>s1 &gt; s2</code>），该表达式返回<code>Bool</code>类型值，因此这里没有歧义，<code>return</code>关键字可以省略。</p>
<p><a name="shorthand_argument_names"></a></p>
<h3 id="参数名称缩写（Shorthand_Argument_Names）">参数名称缩写（Shorthand Argument Names）</h3><p>Swift 自动为内联闭包提供了参数名称缩写功能，您可以直接通过<code>$0</code>，<code>$1</code>，<code>$2</code>来顺序调用闭包的参数，以此类推。</p>
<p>如果您在闭包表达式中使用参数名称缩写，您可以在闭包参数列表中省略对其的定义，并且对应参数名称缩写的类型会通过函数类型进行推断。<code>in</code>关键字也同样可以被省略，因为此时闭包表达式完全由闭包函数体构成：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversed = names.<span class="built_in">sort</span>( &#123; $<span class="number">0</span> &gt; $<span class="number">1</span> &#125; )</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>$0</code>和<code>$1</code>表示闭包中第一个和第二个<code>String</code>类型的参数。</p>
<p><a name="operator_functions"></a></p>
<h3 id="运算符函数（Operator_Functions）">运算符函数（Operator Functions）</h3><p>实际上还有一种更简短的方式来撰写上面例子中的闭包表达式。Swift 的<code>String</code>类型定义了关于大于号（<code>&gt;</code>）的字符串实现，其作为一个函数接受两个<code>String</code>类型的参数并返回<code>Bool</code>类型的值。而这正好与<code>sort(_:)</code>方法的第二个参数需要的函数类型相符合。因此，您可以简单地传递一个大于号，Swift 可以自动推断出您想使用大于号的字符串函数实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversed = names.<span class="built_in">sort</span>(&gt;)</span><br></pre></td></tr></table></figure>
<p>更多关于运算符表达式的内容请查看<a href="./25_Advanced_Operators.html#operator_functions">运算符函数</a>。</p>
<p><a name="trailing_closures"></a></p>
<h2 id="尾随闭包（Trailing_Closures）">尾随闭包（Trailing Closures）</h2><p>如果您需要将一个很长的闭包表达式作为最后一个参数传递给函数，可以使用<em>尾随闭包</em>来增强函数的可读性。尾随闭包是一个书写在函数括号之后的闭包表达式，函数支持将其作为最后一个参数调用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">someFunctionThatTakesAClosure</span><span class="params">(closure: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="comment">// 函数体部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是不使用尾随闭包进行函数调用</span></span><br><span class="line">someFunctionThatTakesAClosure(&#123;</span><br><span class="line">    <span class="comment">// 闭包主体部分</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是使用尾随闭包进行函数调用</span></span><br><span class="line">someFunctionThatTakesAClosure() &#123;</span><br><span class="line">    <span class="comment">// 闭包主体部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<a href="#closure_expression_syntax">闭包表达式语法</a>一节中作为<code>sort(_:)</code>方法参数的字符串排序闭包可以改写为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversed = names.<span class="built_in">sort</span>() &#123; $<span class="number">0</span> &gt; $<span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>
<p>如果函数只需要闭包表达式一个参数，当您使用尾随闭包时，您甚至可以把<code>()</code>省略掉：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversed = names.<span class="built_in">sort</span> &#123; $<span class="number">0</span> &gt; $<span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>
<p>当闭包非常长以至于不能在一行中进行书写时，尾随闭包变得非常有用。举例来说，Swift 的<code>Array</code>类型有一个<code>map(_:)</code>方法，其获取一个闭包表达式作为其唯一参数。该闭包函数会为数组中的每一个元素调用一次，并返回该元素所映射的值。具体的映射方式和返回值类型由闭包来指定。</p>
<p>当提供给数组的闭包应用于每个数组元素后，<code>map(_:)</code>方法将返回一个新的数组，数组中包含了与原数组中的元素一一对应的映射后的值。</p>
<p>下例介绍了如何在<code>map(_:)</code>方法中使用尾随闭包将<code>Int</code>类型数组<code>[16, 58, 510]</code>转换为包含对应<code>String</code>类型的值的数组<code>[&quot;OneSix&quot;, &quot;FiveEight&quot;, &quot;FiveOneZero&quot;]</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> digitNames = [</span><br><span class="line">    <span class="number">0</span>: <span class="string">"Zero"</span>, <span class="number">1</span>: <span class="string">"One"</span>, <span class="number">2</span>: <span class="string">"Two"</span>,   <span class="number">3</span>: <span class="string">"Three"</span>, <span class="number">4</span>: <span class="string">"Four"</span>,</span><br><span class="line">    <span class="number">5</span>: <span class="string">"Five"</span>, <span class="number">6</span>: <span class="string">"Six"</span>, <span class="number">7</span>: <span class="string">"Seven"</span>, <span class="number">8</span>: <span class="string">"Eight"</span>, <span class="number">9</span>: <span class="string">"Nine"</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">16</span>, <span class="number">58</span>, <span class="number">510</span>]</span><br></pre></td></tr></table></figure>
<p>如上代码创建了一个数字位和它们英文版本名字相映射的字典。同时还定义了一个准备转换为字符串数组的整型数组。</p>
<p>您现在可以通过传递一个尾随闭包给<code>numbers</code>的<code>map(_:)</code>方法来创建对应的字符串版本数组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> strings = numbers.<span class="built_in">map</span> &#123;</span><br><span class="line">    (<span class="keyword">var</span> number) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">var</span> output = <span class="string">""</span></span><br><span class="line">    <span class="keyword">while</span> number &gt; <span class="number">0</span> &#123;</span><br><span class="line">        output = digitNames[number % <span class="number">10</span>]! + output</span><br><span class="line">        number /= <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// strings 常量被推断为字符串类型数组，即 [String]</span></span><br><span class="line"><span class="comment">// 其值为 ["OneSix", "FiveEight", "FiveOneZero"]</span></span><br></pre></td></tr></table></figure>
<p><code>map(_:)</code>为数组中每一个元素调用了闭包表达式。您不需要指定闭包的输入参数<code>number</code>的类型，因为可以通过要映射的数组类型进行推断。</p>
<p>在该例中，闭包<code>number</code>参数被声明为一个变量参数（变量的具体描述请参看<a href="./06_Functions.html#constant_and_variable_parameters">常量参数和变量参数</a>），因此可以在闭包函数体内对其进行修改，而不用再定义一个新的局部变量并将<code>number</code>的值赋值给它。闭包表达式指定了返回类型为<code>String</code>，以表明存储映射值的新数组类型为<code>String</code>。</p>
<p>闭包表达式在每次被调用的时候创建了一个叫做<code>output</code>的字符串并返回。其使用求余运算符（<code>number % 10</code>）计算最后一位数字并利用<code>digitNames</code>字典获取所映射的字符串。</p>
<blockquote>
<p>注意<br>字典<code>digitNames</code>下标后跟着一个叹号（<code>!</code>），因为字典下标返回一个可选值（optional value），表明该键不存在时会查找失败。在上例中，由于可以确定<code>number % 10</code>总是<code>digitNames</code>字典的有效下标，因此叹号可以用于强制解包 (force-unwrap) 存储在下标的可选类型的返回值中的<code>String</code>类型的值。</p>
</blockquote>
<p>从<code>digitNames</code>字典中获取的字符串被添加到<code>output</code>的前部，逆序建立了一个字符串版本的数字。（在表达式<code>number % 10</code>中，如果<code>number</code>为<code>16</code>，则返回<code>6</code>，<code>58</code>返回<code>8</code>，<code>510</code>返回<code>0</code>。）</p>
<p><code>number</code>变量之后除以<code>10</code>。因为其是整数，在计算过程中未除尽部分被忽略。因此<code>16</code>变成了<code>1</code>，<code>58</code>变成了<code>5</code>，<code>510</code>变成了<code>51</code>。</p>
<p>整个过程重复进行，直到<code>number /= 10</code>为<code>0</code>，这时闭包会将字符串<code>output</code>返回，而<code>map(_:)</code>方法则会将字符串添加到所映射的数组中。</p>
<p>在上面的例子中，通过尾随闭包语法，优雅地在函数后封装了闭包的具体功能，而不再需要将整个闭包包裹在<code>map(_:)</code>方法的括号内。</p>
<p><a name="capturing_values"></a></p>
<h2 id="捕获值（Capturing_Values）">捕获值（Capturing Values）</h2><p>闭包可以在其被定义的上下文中<em>捕获</em>常量或变量。即使定义这些常量和变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。</p>
<p>Swift 中，可以捕获值的闭包的最简单形式是嵌套函数，也就是定义在其他函数的函数体内的函数。嵌套函数可以捕获其外部函数所有的参数以及定义的常量和变量。</p>
<p>举个例子，这有一个叫做<code>makeIncrementor</code>的函数，其包含了一个叫做<code>incrementor</code>的嵌套函数。嵌套函数<code>incrementor()</code>从上下文中捕获了两个值，<code>runningTotal</code>和<code>amount</code>。捕获这些值之后，<code>makeIncrementor</code>将<code>incrementor</code>作为闭包返回。每次调用<code>incrementor</code>时，其会以<code>amount</code>作为增量增加<code>runningTotal</code>的值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">makeIncrementor</span><span class="params">(forIncrement amount: Int)</span></span> -&gt; () -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> runningTotal = <span class="number">0</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">incrementor</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        runningTotal += amount</span><br><span class="line">        <span class="keyword">return</span> runningTotal</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> incrementor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>makeIncrementor</code>返回类型为<code>() -&gt; Int</code>。这意味着其返回的是一个函数，而不是一个简单类型的值。该函数在每次调用时不接受参数，只返回一个<code>Int</code>类型的值。关于函数返回其他函数的内容，请查看<a href="./06_Functions.html#function_types_as_return_types">函数类型作为返回类型</a>。</p>
<p><code>makeIncrementer(forIncrement:)</code>函数定义了一个初始值为<code>0</code>的整型变量<code>runningTotal</code>，用来存储当前跑步总数。该值通过<code>incrementor</code>返回。</p>
<p><code>makeIncrementer(forIncrement:)</code>有一个<code>Int</code>类型的参数，其外部参数名为<code>forIncrement</code>，内部参数名为<code>amount</code>，该参数表示每次<code>incrementor</code>被调用时<code>runningTotal</code>将要增加的量。</p>
<p>嵌套函数<code>incrementor</code>用来执行实际的增加操作。该函数简单地使<code>runningTotal</code>增加<code>amount</code>，并将其返回。</p>
<p>如果我们单独看这个函数，会发现看上去不同寻常：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">incrementor</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    runningTotal += amount</span><br><span class="line">    <span class="keyword">return</span> runningTotal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>incrementer()</code>函数并没有任何参数，但是在函数体内访问了<code>runningTotal</code>和<code>amount</code>变量。这是因为它从外围函数捕获了<code>runningTotal</code>和<code>amount</code>变量的引用。捕获引用保证了<code>runningTotal</code>和<code>amount</code>变量在调用完<code>makeIncrementer</code>后不会消失，并且保证了在下一次执行<code>incrementer</code>函数时，<code>runningTotal</code>依旧存在。</p>
<blockquote>
<p>注意<br>为了优化，如果一个值是不可变的，Swift 可能会改为捕获并保存一份对值的拷贝。<br>Swift 也会负责被捕获变量的所有内存管理工作，包括释放不再需要的变量。</p>
</blockquote>
<p>下面是一个使用<code>makeIncrementor</code>的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> incrementByTen = makeIncrementor(forIncrement: <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>该例子定义了一个叫做<code>incrementByTen</code>的常量，该常量指向一个每次调用会将<code>runningTotal</code>变量增加<code>10</code>的<code>incrementor</code>函数。调用这个函数多次可以得到以下结果：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">incrementByTen()</span><br><span class="line"><span class="comment">// 返回的值为10</span></span><br><span class="line">incrementByTen()</span><br><span class="line"><span class="comment">// 返回的值为20</span></span><br><span class="line">incrementByTen()</span><br><span class="line"><span class="comment">// 返回的值为30</span></span><br></pre></td></tr></table></figure>
<p>如果您创建了另一个<code>incrementor</code>，它会有属于它自己的一个全新、独立的<code>runningTotal</code>变量的引用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> incrementBySeven = makeIncrementor(forIncrement: <span class="number">7</span>)</span><br><span class="line">incrementBySeven()</span><br><span class="line"><span class="comment">// 返回的值为7</span></span><br></pre></td></tr></table></figure>
<p>再次调用原来的<code>incrementByTen</code>会在原来的变量<code>runningTotal</code>上继续增加值，该变量和<code>incrementBySeven</code>中捕获的变量没有任何联系：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">incrementByTen()</span><br><span class="line"><span class="comment">// 返回的值为40</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>如果您将闭包赋值给一个类实例的属性，并且该闭包通过访问该实例或其成员而捕获了该实例，您将创建一个在闭包和该实例间的循环强引用。Swift 使用捕获列表来打破这种循环强引用。更多信息，请参考<a href="./16_Automatic_Reference_Counting.html#strong_reference_cycles_for_closures">闭包引起的循环强引用</a>。</p>
</blockquote>
<p><a name="closures_are_reference_types"></a></p>
<h2 id="闭包是引用类型（Closures_Are_Reference_Types）">闭包是引用类型（Closures Are Reference Types）</h2><p>上面的例子中，<code>incrementBySeven</code>和<code>incrementByTen</code>是常量，但是这些常量指向的闭包仍然可以增加其捕获的变量的值。这是因为函数和闭包都是<em>引用类型</em>。</p>
<p>无论您将函数或闭包赋值给一个常量还是变量，您实际上都是将常量或变量的值设置为对应函数或闭包的引用。上面的例子中，指向闭包的引用<code>incrementByTen</code>是一个常量，而并非闭包内容本身。</p>
<p>这也意味着如果您将闭包赋值给了两个不同的常量或变量，两个值都会指向同一个闭包：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> alsoIncrementByTen = incrementByTen</span><br><span class="line">alsoIncrementByTen()</span><br><span class="line"><span class="comment">// 返回的值为50</span></span><br></pre></td></tr></table></figure>
<p><a name="nonescaping_closures"></a></p>
<h2 id="非逃逸闭包(Nonescaping_Closures)">非逃逸闭包(Nonescaping Closures)</h2><p>当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行，我们称该闭包从函数中<em>逃逸</em>。当你定义接受闭包作为参数的函数时，你可以在参数名之前标注<code>@noescape</code>，用来指明这个闭包是不允许“逃逸”出这个函数的。将闭包标注<code>@noescape</code>能使编译器知道这个闭包的生命周期（译者注：闭包只能在函数体中被执行，不能脱离函数体执行，所以编译器明确知道运行时的上下文），从而可以进行一些比较激进的优化。   </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">someFunctionWithNoescapeClosure</span><span class="params">(@noescape closure: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    closure()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举个例子，<code>sort(_:)</code>方法接受一个用来进行元素比较的闭包作为参数。这个参数被标注了<code>@noescape</code>，因为它确保自己在排序结束之后就没用了。</p>
<p>一种能使闭包“逃逸”出函数的方法是，将这个闭包保存在一个函数外部定义的变量中。举个例子，很多启动异步操作的函数接受一个闭包参数作为 completion handler。这类函数会在异步操作开始之后立刻返回，但是闭包直到异步操作结束后才会被调用。在这种情况下，闭包需要“逃逸”出函数，因为闭包需要在函数返回之后被调用。例如： </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> completionHandlers: [() -&gt; <span class="type">Void</span>] = []</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">someFunctionWithEscapingClosure</span><span class="params">(completionHandler: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    completionHandlers.append(completionHandler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>someFunctionWithEscapingClosure(_:)</code>函数接受一个闭包作为参数，该闭包被添加到一个函数外定义的数组中。如果你试图将这个参数标注为<code>@noescape</code>，你将会获得一个编译错误。</p>
<p>将闭包标注为<code>@noescape</code>使你能在闭包中隐式地引用<code>self</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">        someFunctionWithEscapingClosure &#123; <span class="keyword">self</span>.x = <span class="number">100</span> &#125;</span><br><span class="line">        someFunctionWithNoescapeClosure &#123; x = <span class="number">200</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> instance = <span class="type">SomeClass</span>()</span><br><span class="line">instance.doSomething()</span><br><span class="line"><span class="built_in">print</span>(instance.x)</span><br><span class="line"><span class="comment">// prints "200"</span></span><br><span class="line"> </span><br><span class="line">completionHandlers.first?()</span><br><span class="line"><span class="built_in">print</span>(instance.x)</span><br><span class="line"><span class="comment">// prints "100"</span></span><br></pre></td></tr></table></figure>
<p><a name="autoclosures"></a></p>
<h2 id="自动闭包（Autoclosures）">自动闭包（Autoclosures）</h2><p><em>自动闭包</em>是一种自动创建的闭包，用于包装传递给函数作为参数的表达式。这种闭包不接受任何参数，当它被调用的时候，会返回被包装在其中的表达式的值。这种便利语法让你能够用一个普通的表达式来代替显式的闭包，从而省略闭包的花括号。</p>
<p>我们经常会调用一个接受闭包作为参数的函数，但是很少实现那样的函数。举个例子来说，<code>assert(condition:message:file:line:)</code>函数接受闭包作为它的<code>condition</code>参数和<code>message</code>参数；它的<code>condition</code>参数仅会在 debug 模式下被求值，它的<code>message</code>参数仅当<code>condition</code>参数为<code>false</code>时被计算求值。</p>
<p>自动闭包让你能够延迟求值，因为代码段不会被执行直到你调用这个闭包。延迟求值对于那些有副作用（Side Effect）和代价昂贵的代码来说是很有益处的，因为你能控制代码什么时候执行。下面的代码展示了闭包如何延时求值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> customersInLine = [<span class="string">"Chris"</span>, <span class="string">"Alex"</span>, <span class="string">"Ewa"</span>, <span class="string">"Barry"</span>, <span class="string">"Daniella"</span>]</span><br><span class="line"><span class="built_in">print</span>(customersInLine.<span class="built_in">count</span>)</span><br><span class="line"><span class="comment">// prints "5"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> customerProvider = &#123; customersInLine.removeAtIndex(<span class="number">0</span>) &#125;</span><br><span class="line"><span class="built_in">print</span>(customersInLine.<span class="built_in">count</span>)</span><br><span class="line"><span class="comment">// prints "5"</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Now serving <span class="subst">\(customerProvider()</span>)!"</span>)</span><br><span class="line"><span class="comment">// prints "Now serving Chris!"</span></span><br><span class="line"><span class="built_in">print</span>(customersInLine.<span class="built_in">count</span>)</span><br><span class="line"><span class="comment">// prints "4"</span></span><br></pre></td></tr></table></figure>
<p>尽管在闭包的代码中，<code>customersInLine</code>的第一个元素被移除了，不过在闭包被调用之前，这个元素是不会被移除的。如果这个闭包永远不被调用，那么在闭包里面的表达式将永远不会执行，那意味着列表中的元素永远不会被移除。请注意，<code>customerProvider</code>的类型不是<code>String</code>，而是<code>() -&gt; String</code>，一个没有参数且返回值为<code>String</code>的函数。</p>
<p>将闭包作为参数传递给函数时，你能获得同样的延时求值行为。    </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// customersInLine is ["Alex", "Ewa", "Barry", "Daniella"]</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">serveCustomer</span><span class="params">(customerProvider: <span class="params">()</span></span></span> -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Now serving <span class="subst">\(customerProvider()</span>)!"</span>)</span><br><span class="line">&#125;</span><br><span class="line">serveCustomer( &#123; customersInLine.removeAtIndex(<span class="number">0</span>) &#125; )</span><br><span class="line"><span class="comment">// prints "Now serving Alex!"</span></span><br></pre></td></tr></table></figure>
<p><code>serveCustomer(_:)</code>接受一个返回顾客名字的显式的闭包。下面这个版本的<code>serveCustomer(_:)</code>完成了相同的操作，不过它并没有接受一个显式的闭包，而是通过将参数标记为<code>@autoclosure</code>来接收一个自动闭包。现在你可以将该函数当做接受<code>String</code>类型参数的函数来调用。<code>customerProvider</code>参数将自动转化为一个闭包，因为该参数被标记了<code>@autoclosure</code>特性。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// customersInLine is ["Ewa", "Barry", "Daniella"]</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">serveCustomer</span><span class="params">(@autoclosure customerProvider: <span class="params">()</span></span></span> -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Now serving <span class="subst">\(customerProvider()</span>)!"</span>)</span><br><span class="line">&#125;</span><br><span class="line">serveCustomer(customersInLine.removeAtIndex(<span class="number">0</span>))</span><br><span class="line"><span class="comment">// prints "Now serving Ewa!"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>过度使用<code>autoclosures</code>会让你的代码变得难以理解。上下文和函数名应该能够清晰地表明求值是被延迟执行的。</p>
</blockquote>
<p><code>@autoclosure</code>特性暗含了<code>@noescape</code>特性，这个特性在<a href="#nonescaping_closures">非逃逸闭包</a>一节中有描述。如果你想让这个闭包可以“逃逸”，则应该使用<code>@autoclosure(escaping)</code>特性.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// customersInLine is ["Barry", "Daniella"]</span></span><br><span class="line"><span class="keyword">var</span> customerProviders: [() -&gt; <span class="type">String</span>] = []</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">collectCustomerProviders</span><span class="params">(@autoclosure<span class="params">(escaping)</span></span></span> customerProvider: () -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    customerProviders.append(customerProvider)</span><br><span class="line">&#125;</span><br><span class="line">collectCustomerProviders(customersInLine.removeAtIndex(<span class="number">0</span>))</span><br><span class="line">collectCustomerProviders(customersInLine.removeAtIndex(<span class="number">0</span>))</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Collected <span class="subst">\(customerProviders.<span class="built_in">count</span>)</span> closures."</span>)</span><br><span class="line"><span class="comment">// prints "Collected 2 closures."</span></span><br><span class="line"><span class="keyword">for</span> customerProvider <span class="keyword">in</span> customerProviders &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Now serving <span class="subst">\(customerProvider()</span>)!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// prints "Now serving Barry!"</span></span><br><span class="line"><span class="comment">// prints "Now serving Daniella!"</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，<code>collectCustomerProviders(_:)</code>函数并没有调用传入的<code>customerProvider</code>闭包，而是将闭包追加到了<code>customerProviders</code>数组中。这个数组定义在函数作用域范围外，这意味着数组内的闭包将会在函数返回之后被调用。因此，<code>customerProvider</code>参数必须允许“逃逸”出函数作用域。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/08_Enumerations/" itemprop="url">
                第二章-08枚举（Enumerations）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:19+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/08_Enumerations/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/08_Enumerations/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="枚举（Enumerations）">枚举（Enumerations）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/yankuangshi" target="_blank" rel="external">yankuangshi</a><br>校对：<a href="https://github.com/shinyzhu" target="_blank" rel="external">shinyzhu</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/futantan" target="_blank" rel="external">futantan</a></p>
<p>2.1<br>翻译：<a href="https://github.com/Channe" target="_blank" rel="external">Channe</a><br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a></p>
</blockquote>
<p>本页内容包含：</p>
<ul>
<li><a href="#enumeration_syntax">枚举语法（Enumeration Syntax）</a></li>
<li><a href="#matching_enumeration_values_with_a_switch_statement">使用 Switch 语句匹配枚举值（Matching Enumeration Values with a Switch Statement）</a></li>
<li><a href="#associated_values">关联值（Associated Values）</a></li>
<li><a href="#raw_values">原始值（Raw Values）</a></li>
<li><a href="#recursive_enumerations">递归枚举（Recursive Enumerations）</a></li>
</ul>
<p><em>枚举</em>为一组相关的值定义了一个共同的类型，使你可以在你的代码中以类型安全的方式来使用这些值。</p>
<p>如果你熟悉 C 语言，你会知道在 C 语言中，枚举会为一组整型值分配相关联的名称。Swift 中的枚举更加灵活，不必给每一个枚举成员提供一个值。如果给枚举成员提供一个值（称为“原始”值），则该值的类型可以是字符串，字符，或是一个整型值或浮点数。</p>
<p>此外，枚举成员可以指定任意类型的关联值存储到枚举成员中，就像其他语言中的联合体（unions）和变体（variants）。每一个枚举成员都可以有适当类型的关联值。</p>
<p>在 Swift 中，枚举类型是一等（first-class）类型。它们采用了很多在传统上只被类（class）所支持的特性，例如计算型属性（computed properties），用于提供枚举值的附加信息，实例方法（instance methods），用于提供和枚举值相关联的功能。枚举也可以定义构造函数（initializers）来提供一个初始值；可以在原始实现的基础上扩展它们的功能；还可以遵守协议（protocols）来提供标准的功能。</p>
<p>欲了解更多相关信息，请参见<a href="./10_Properties.html">属性（Properties）</a>，<a href="./11_Methods.html">方法（Methods）</a>，<a href="./14_Initialization.html">构造过程（Initialization）</a>，<a href="./21_Extensions.html">扩展（Extensions）</a>和<a href="./22_Protocols.html">协议（Protocols）</a>。</p>
<p><a name="enumeration_syntax"></a></p>
<h2 id="枚举语法">枚举语法</h2><p>使用<code>enum</code>关键词来创建枚举并且把它们的整个定义放在一对大括号内：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SomeEnumeration</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 枚举定义放在这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是用枚举表示指南针四个方向的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CompassPoint</span> </span>&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">North</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">South</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">East</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">West</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举中定义的值（如 <code>North</code>，<code>South</code>，<code>East</code>和<code>West</code>）是这个枚举的<em>成员值</em>（或<em>成员</em>）。你使用<code>case</code>关键字来定义一个新的枚举成员值。</p>
<blockquote>
<p>注意<br>与 C 和 Objective-C 不同，Swift 的枚举成员在被创建时不会被赋予一个默认的整型值。在上面的<code>CompassPoint</code>例子中，<code>North</code>，<code>South</code>，<code>East</code>和<code>West</code>不会被隐式地赋值为<code>0</code>，<code>1</code>，<code>2</code>和<code>3</code>。相反，这些枚举成员本身就是完备的值，这些值的类型是已经明确定义好的<code>CompassPoint</code>类型。</p>
</blockquote>
<p>多个成员值可以出现在同一行上，用逗号隔开：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Planet</span> </span>&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Mercury</span>, <span class="type">Venus</span>, <span class="type">Earth</span>, <span class="type">Mars</span>, <span class="type">Jupiter</span>, <span class="type">Saturn</span>, <span class="type">Uranus</span>, <span class="type">Neptune</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个枚举定义了一个全新的类型。像 Swift 中其他类型一样，它们的名字（例如<code>CompassPoint</code>和<code>Planet</code>）应该以一个大写字母开头。给枚举类型起一个单数名字而不是复数名字，以便于读起来更加容易理解：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> directionToHead = <span class="type">CompassPoint</span>.<span class="type">West</span></span><br></pre></td></tr></table></figure>
<p><code>directionToHead</code>的类型可以在它被<code>CompassPoint</code>的某个值初始化时推断出来。一旦<code>directionToHead</code>被声明为<code>CompassPoint</code>类型，你可以使用更简短的点语法将其设置为另一个<code>CompassPoint</code>的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">directionToHead = .<span class="type">East</span></span><br></pre></td></tr></table></figure>
<p>当<code>directionToHead</code>的类型已知时，再次为其赋值可以省略枚举类型名。在使用具有显式类型的枚举值时，这种写法让代码具有更好的可读性。</p>
<p><a name="matching_enumeration_values_with_a_switch_statement"></a></p>
<h2 id="使用_Switch_语句匹配枚举值">使用 Switch 语句匹配枚举值</h2><p>你可以使用<code>switch</code>语句匹配单个枚举值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">directionToHead = .<span class="type">South</span></span><br><span class="line"><span class="keyword">switch</span> directionToHead &#123;</span><br><span class="line">	<span class="keyword">case</span> .<span class="type">North</span>:</span><br><span class="line">	    <span class="built_in">print</span>(<span class="string">"Lots of planets have a north"</span>)</span><br><span class="line">	<span class="keyword">case</span> .<span class="type">South</span>:</span><br><span class="line">	    <span class="built_in">print</span>(<span class="string">"Watch out for penguins"</span>)</span><br><span class="line">	<span class="keyword">case</span> .<span class="type">East</span>:</span><br><span class="line">	    <span class="built_in">print</span>(<span class="string">"Where the sun rises"</span>)</span><br><span class="line">	<span class="keyword">case</span> .<span class="type">West</span>:</span><br><span class="line">	    <span class="built_in">print</span>(<span class="string">"Where the skies are blue"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "Watch out for penguins”</span></span><br></pre></td></tr></table></figure>
<p>你可以这样理解这段代码：</p>
<p>“判断<code>directionToHead</code>的值。当它等于<code>.North</code>，打印<code>“Lots of planets have a north”</code>。当它等于<code>.South</code>，打印<code>“Watch out for penguins”</code>。”</p>
<p>……以此类推。</p>
<p>正如在<a href="./05_Control_Flow.html">控制流（Control Flow）</a>中介绍的那样，在判断一个枚举类型的值时，<code>switch</code>语句必须穷举所有情况。如果忽略了<code>.West</code>这种情况，上面那段代码将无法通过编译，因为它没有考虑到<code>CompassPoint</code>的全部成员。强制穷举确保了枚举成员不会被意外遗漏。</p>
<p>当不需要匹配每个枚举成员的时候，你可以提供一个<code>default</code>分支来涵盖所有未明确处理的枚举成员：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> somePlanet = <span class="type">Planet</span>.<span class="type">Earth</span></span><br><span class="line"><span class="keyword">switch</span> somePlanet &#123;</span><br><span class="line"><span class="keyword">case</span> .<span class="type">Earth</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Mostly harmless"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Not a safe place for humans"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "Mostly harmless”</span></span><br></pre></td></tr></table></figure>
<p><a name="associated_values"></a></p>
<h2 id="关联值（Associated_Values）">关联值（Associated Values）</h2><p>上一小节的例子演示了如何定义和分类枚举的成员。你可以为<code>Planet.Earth</code>设置一个常量或者变量，并在赋值之后查看这个值。然而，有时候能够把其他类型的<em>关联值</em>和成员值一起存储起来会很有用。这能让你连同成员值一起存储额外的自定义信息，并且你每次在代码中使用该枚举成员时，还可以修改这个关联值。</p>
<p>你可以定义 Swift 枚举来存储任意类型的关联值，如果需要的话，每个枚举成员的关联值类型可以各不相同。枚举的这种特性跟其他语言中的可识别联合（discriminated unions），标签联合（tagged unions），或者变体（variants）相似。</p>
<p>例如，假设一个库存跟踪系统需要利用两种不同类型的条形码来跟踪商品。有些商品上标有使用<code>0</code>到<code>9</code>的数字的 UPC-A 格式的一维条形码。每一个条形码都有一个代表“数字系统”的数字，该数字后接五位代表“厂商代码”的数字，接下来是五位代表“产品代码”的数字。最后一个数字是“检查”位，用来验证代码是否被正确扫描：</p>
<p><img width="252" height="120" alt="" src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/barcode_UPC_2x.png"></p>
<p>其他商品上标有 QR 码格式的二维码，它可以使用任何 ISO 8859-1 字符，并且可以编码一个最多拥有 2,953 个字符的字符串：</p>
<p><img width="169" height="169" alt="" src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/barcode_QR_2x.png"></p>
<p>这便于库存跟踪系统用包含四个整型值的元组存储 UPC-A 码，以及用任意长度的字符串储存 QR 码。</p>
<p>在 Swift 中，使用如下方式定义表示两种商品条形码的枚举：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Barcode</span> </span>&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">UPCA</span>(<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="type">QRCode</span>(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码可以这么理解：</p>
<p>“定义一个名为<code>Barcode</code>的枚举类型，它的一个成员值是具有<code>(Int，Int，Int，Int)</code>类型关联值的<code>UPCA</code>，另一个成员值是具有<code>String</code>类型关联值的<code>QRCode</code>。”</p>
<p>这个定义不提供任何<code>Int</code>或<code>String</code>类型的关联值，它只是定义了，当<code>Barcode</code>常量和变量等于<code>Barcode.UPCA</code>或<code>Barcode.QRCode</code>时，可以存储的关联值的类型。</p>
<p>然后可以使用任意一种条形码类型创建新的条形码，例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> productBarcode = <span class="type">Barcode</span>.<span class="type">UPCA</span>(<span class="number">8</span>, <span class="number">85909</span>, <span class="number">51226</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>上面的例子创建了一个名为<code>productBarcode</code>的变量，并将<code>Barcode.UPCA</code>赋值给它，关联的元组值为<code>(8, 85909, 51226, 3)</code>。</p>
<p>同一个商品可以被分配一个不同类型的条形码，例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">productBarcode = .<span class="type">QRCode</span>(<span class="string">"ABCDEFGHIJKLMNOP"</span>)</span><br></pre></td></tr></table></figure>
<p>这时，原始的<code>Barcode.UPCA</code>和其整数关联值被新的<code>Barcode.QRCode</code>和其字符串关联值所替代。<code>Barcode</code>类型的常量和变量可以存储一个<code>.UPCA</code>或者一个<code>.QRCode</code>（连同它们的关联值），但是在同一时间只能存储这两个值中的一个。</p>
<p>像先前那样，可以使用一个 switch 语句来检查不同的条形码类型。然而，这一次，关联值可以被提取出来作为 switch 语句的一部分。你可以在<code>switch</code>的 case 分支代码中提取每个关联值作为一个常量（用<code>let</code>前缀）或者作为一个变量（用<code>var</code>前缀）来使用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> productBarcode &#123;</span><br><span class="line"><span class="keyword">case</span> .<span class="type">UPCA</span>(<span class="keyword">let</span> numberSystem, <span class="keyword">let</span> manufacturer, <span class="keyword">let</span> product, <span class="keyword">let</span> check):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"UPC-A: <span class="subst">\(numberSystem)</span>, <span class="subst">\(manufacturer)</span>, <span class="subst">\(product)</span>, <span class="subst">\(check)</span>."</span>)</span><br><span class="line"><span class="keyword">case</span> .<span class="type">QRCode</span>(<span class="keyword">let</span> productCode):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"QR code: <span class="subst">\(productCode)</span>."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "QR code: ABCDEFGHIJKLMNOP."</span></span><br></pre></td></tr></table></figure>
<p>如果一个枚举成员的所有关联值都被提取为常量，或者都被提取为变量，为了简洁，你可以只在成员名称前标注一个<code>let</code>或者<code>var</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> productBarcode &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">UPCA</span>(numberSystem, manufacturer, product, check):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"UPC-A: <span class="subst">\(numberSystem)</span>, <span class="subst">\(manufacturer)</span>, <span class="subst">\(product)</span>, <span class="subst">\(check)</span>."</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">QRCode</span>(productCode):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"QR code: <span class="subst">\(productCode)</span>."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "QR code: ABCDEFGHIJKLMNOP."</span></span><br></pre></td></tr></table></figure>
<p><a name="raw_values"></a></p>
<h2 id="原始值（Raw_Values）">原始值（Raw Values）</h2><p>在<a href="#associated_values">关联值</a>小节的条形码例子中，演示了如何声明存储不同类型关联值的枚举成员。作为关联值的替代选择，枚举成员可以被默认值（称为<em>原始值</em>）预填充，这些原始值的类型必须相同。</p>
<p>这是一个使用 ASCII 码作为原始值的枚举：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ASCIIControlCharacter</span>: <span class="title">Character</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Tab</span> = <span class="string">"\t"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">LineFeed</span> = <span class="string">"\n"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">CarriageReturn</span> = <span class="string">"\r"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举类型<code>ASCIIControlCharacter</code>的原始值类型被定义为<code>Character</code>，并设置了一些比较常见的 ASCII 控制字符。<code>Character</code>的描述详见<a href="./03_Strings_and_Characters.html">字符串和字符</a>部分。</p>
<p>原始值可以是字符串，字符，或者任意整型值或浮点型值。每个原始值在枚举声明中必须是唯一的。</p>
<blockquote>
<p>注意<br>原始值和关联值是不同的。原始值是在定义枚举时被预先填充的值，像上述三个 ASCII 码。对于一个特定的枚举成员，它的原始值始终不变。关联值是创建一个基于枚举成员的常量或变量时才设置的值，枚举成员的关联值可以变化。</p>
</blockquote>
<p><a name="implicitly_assigned_raw_values"></a></p>
<h3 id="原始值的隐式赋值（Implicitly_Assigned_Raw_Values）">原始值的隐式赋值（Implicitly Assigned Raw Values）</h3><p>在使用原始值为整数或者字符串类型的枚举时，不需要显式地为每一个枚举成员设置原始值，Swift 将会自动为你赋值。</p>
<p>例如，当使用整数作为原始值时，隐式赋值的值依次递增<code>1</code>。如果第一个枚举成员没有设置原始值，其原始值将为<code>0</code>。</p>
<p>下面的枚举是对之前<code>Planet</code>这个枚举的一个细化，利用整型的原始值来表示每个行星在太阳系中的顺序：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Planet</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Mercury</span> = <span class="number">1</span>, <span class="type">Venus</span>, <span class="type">Earth</span>, <span class="type">Mars</span>, <span class="type">Jupiter</span>, <span class="type">Saturn</span>, <span class="type">Uranus</span>, <span class="type">Neptune</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>Plant.Mercury</code>的显式原始值为<code>1</code>，<code>Planet.Venus</code>的隐式原始值为<code>2</code>，依次类推。</p>
<p>当使用字符串作为枚举类型的原始值时，每个枚举成员的隐式原始值为该枚举成员的名称。</p>
<p>下面的例子是<code>CompassPoint</code>枚举的细化，使用字符串类型的原始值来表示各个方向的名称：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CompassPoint</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">North</span>, <span class="type">South</span>, <span class="type">East</span>, <span class="type">West</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>CompassPoint.South</code>拥有隐式原始值<code>South</code>，依次类推。</p>
<p>使用枚举成员的<code>rawValue</code>属性可以访问该枚举成员的原始值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> earthsOrder = <span class="type">Planet</span>.<span class="type">Earth</span>.rawValue</span><br><span class="line"><span class="comment">// earthsOrder 值为 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sunsetDirection = <span class="type">CompassPoint</span>.<span class="type">West</span>.rawValue</span><br><span class="line"><span class="comment">// sunsetDirection 值为 "West"</span></span><br></pre></td></tr></table></figure>
<p><a name="initializing_from_a_raw_value"></a></p>
<h3 id="使用原始值初始化枚举实例（Initializing_from_a_Raw_Value）">使用原始值初始化枚举实例（Initializing from a Raw Value）</h3><p>如果在定义枚举类型的时候使用了原始值，那么将会自动获得一个初始化方法，这个方法接收一个叫做<code>rawValue</code>的参数，参数类型即为原始值类型，返回值则是枚举成员或<code>nil</code>。你可以使用这个初始化方法来创建一个新的枚举实例。</p>
<p>这个例子利用原始值<code>7</code>创建了枚举成员<code>Uranus</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> possiblePlanet = <span class="type">Planet</span>(rawValue: <span class="number">7</span>)</span><br><span class="line"><span class="comment">// possiblePlanet 类型为 Planet? 值为 Planet.Uranus</span></span><br></pre></td></tr></table></figure>
<p>然而，并非所有<code>Int</code>值都可以找到一个匹配的行星。因此，原始值构造器总是返回一个<em>可选</em>的枚举成员。在上面的例子中，<code>possiblePlanet</code>是<code>Planet?</code>类型，或者说“可选的<code>Planet</code>”。</p>
<blockquote>
<p>注意<br>原始值构造器是一个可失败构造器，因为并不是每一个原始值都有与之对应的枚举成员。更多信息请参见<a href="../chapter3/05_Declarations.html#failable_initializers">可失败构造器</a></p>
</blockquote>
<p>如果你试图寻找一个位置为<code>9</code>的行星，通过原始值构造器返回的可选<code>Planet</code>值将是<code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> positionToFind = <span class="number">9</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> somePlanet = <span class="type">Planet</span>(rawValue: positionToFind) &#123;</span><br><span class="line">    <span class="keyword">switch</span> somePlanet &#123;</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Earth</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Mostly harmless"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Not a safe place for humans"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"There isn't a planet at position <span class="subst">\(positionToFind)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "There isn't a planet at position 9</span></span><br></pre></td></tr></table></figure>
<p>这个例子使用了可选绑定（optional binding），试图通过原始值<code>9</code>来访问一个行星。<code>if let somePlanet = Planet(rawValue: 9)</code>语句创建了一个可选<code>Planet</code>，如果可选<code>Planet</code>的值存在，就会赋值给<code>somePlanet</code>。在这个例子中，无法检索到位置为<code>9</code>的行星，所以<code>else</code>分支被执行。</p>
<p><a name="recursive_enumerations"></a></p>
<h2 id="递归枚举（Recursive_Enumerations）">递归枚举（Recursive Enumerations）</h2><p>当各种可能的情况可以被穷举时，非常适合使用枚举进行数据建模，例如可以用枚举来表示用于简单整数运算的操作符。这些操作符让你可以将简单的算术表达式，例如整数<code>5</code>，结合为更为复杂的表达式，例如<code>5 + 4</code>。</p>
<p>算术表达式的一个重要特性是，表达式可以嵌套使用。例如，表达式<code>(5 + 4) * 2</code>，乘号右边是一个数字，左边则是另一个表达式。因为数据是嵌套的，因而用来存储数据的枚举类型也需要支持这种嵌套——这意味着枚举类型需要支持递归。</p>
<p><em>递归枚举（recursive enumeration）</em>是一种枚举类型，它有一个或多个枚举成员使用该枚举类型的实例作为关联值。使用递归枚举时，编译器会插入一个间接层。你可以在枚举成员前加上<code>indirect</code>来表示该成员可递归。</p>
<p>例如，下面的例子中，枚举类型存储了简单的算术表达式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ArithmeticExpression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Number</span>(<span class="type">Int</span>)</span><br><span class="line">    indirect <span class="keyword">case</span> <span class="type">Addition</span>(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">    indirect <span class="keyword">case</span> <span class="type">Multiplication</span>(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以在枚举类型开头加上<code>indirect</code>关键字来表明它的所有成员都是可递归的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">indirect <span class="class"><span class="keyword">enum</span> <span class="title">ArithmeticExpression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Number</span>(<span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Addition</span>(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Multiplication</span>(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面定义的枚举类型可以存储三种算术表达式：纯数字、两个表达式相加、两个表达式相乘。枚举成员<code>Addition</code>和<code>Multiplication</code>的关联值也是算术表达式——这些关联值使得嵌套表达式成为可能。</p>
<p>要操作具有递归性质的数据结构，使用递归函数是一种直截了当的方式。例如，下面是一个对算术表达式求值的函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">evaluate</span><span class="params">(expression: ArithmeticExpression)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> expression &#123;</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Number</span>(<span class="keyword">let</span> value):</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Addition</span>(<span class="keyword">let</span> <span class="keyword">left</span>, <span class="keyword">let</span> <span class="keyword">right</span>):</span><br><span class="line">        <span class="keyword">return</span> evaluate(<span class="keyword">left</span>) + evaluate(<span class="keyword">right</span>)</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Multiplication</span>(<span class="keyword">let</span> <span class="keyword">left</span>, <span class="keyword">let</span> <span class="keyword">right</span>):</span><br><span class="line">        <span class="keyword">return</span> evaluate(<span class="keyword">left</span>) * evaluate(<span class="keyword">right</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 计算 (5 + 4) * 2</span></span><br><span class="line"><span class="keyword">let</span> five = <span class="type">ArithmeticExpression</span>.<span class="type">Number</span>(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">let</span> four = <span class="type">ArithmeticExpression</span>.<span class="type">Number</span>(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">let</span> sum = <span class="type">ArithmeticExpression</span>.<span class="type">Addition</span>(five, four)</span><br><span class="line"><span class="keyword">let</span> product = <span class="type">ArithmeticExpression</span>.<span class="type">Multiplication</span>(sum, <span class="type">ArithmeticExpression</span>.<span class="type">Number</span>(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(evaluate(product))</span><br><span class="line"><span class="comment">// 输出 "18"</span></span><br></pre></td></tr></table></figure>
<p>该函数如果遇到纯数字，就直接返回该数字的值。如果遇到的是加法或乘法运算，则分别计算左边表达式和右边表达式的值，然后相加或相乘。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/09_Classes_and_Structures/" itemprop="url">
                第二章-09类和结构体（Classes and Structures）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:18+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/09_Classes_and_Structures/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/09_Classes_and_Structures/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="类和结构体（Classes_and_Structures）">类和结构体（Classes and Structures）</h1><blockquote>
<p>1.0<br>翻译：<a href="https://github.com/JaySurplus" target="_blank" rel="external">JaySurplus</a><br>校对：<a href="https://github.com/sg552" target="_blank" rel="external">sg552</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/SkyJean" target="_blank" rel="external">SkyJean</a></p>
<p>2.1<br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a>，2015-10-29</p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#comparing_classes_and_structures">类和结构体对比</a></li>
<li><a href="#structures_and_enumerations_are_value_types">结构体和枚举是值类型</a></li>
<li><a href="#classes_are_reference_types">类是引用类型</a></li>
<li><a href="#choosing_between_classes_and_structures">类和结构体的选择</a></li>
<li><a href="#assignment_and_copy_behavior_for_strings_arrays_and_dictionaries">字符串(String)、数组(Array)、和字典(Dictionary)类型的赋值与复制行为</a></li>
</ul>
<p><em>类</em>和<em>结构体</em>是人们构建代码所用的一种通用且灵活的构造体。我们可以使用完全相同的语法规则来为类和结构体定义属性（常量、变量）和添加方法，从而扩展类和结构体的功能。</p>
<p>与其他编程语言所不同的是，Swift 并不要求你为自定义类和结构去创建独立的接口和实现文件。你所要做的是在一个单一文件中定义一个类或者结构体，系统将会自动生成面向其它代码的外部接口。</p>
<blockquote>
<p>注意<br>通常一个<code>类</code>的实例被称为<code>对象</code>。然而在 Swift 中，类和结构体的关系要比在其他语言中更加的密切，本章中所讨论的大部分功能都可以用在类和结构体上。因此，我们会主要使用<code>实例</code>而不是<code>对象</code>。</p>
</blockquote>
<p><a name="comparing_classes_and_structures"></a></p>
<p>###类和结构体对比</p>
<p>Swift 中类和结构体有很多共同点。共同处在于：</p>
<ul>
<li>定义属性用于存储值</li>
<li>定义方法用于提供功能</li>
<li>定义附属脚本用于访问值</li>
<li>定义构造器用于生成初始化值</li>
<li>通过扩展以增加默认实现的功能</li>
<li>实现协议以提供某种标准功能</li>
</ul>
<p>更多信息请参见<a href="./10_Properties.html">属性</a>，<a href="./11_Methods.html">方法</a>，<a href="./12_Subscripts.html">下标脚本</a>，<a href="./14_Initialization.html">构造过程</a>，<a href="./21_Extensions.html">扩展</a>，和<a href="./22_Protocols.html">协议</a>。</p>
<p>与结构体相比，类还有如下的附加功能：</p>
<ul>
<li>继承允许一个类继承另一个类的特征</li>
<li>类型转换允许在运行时检查和解释一个类实例的类型</li>
<li>解构器允许一个类实例释放任何其所被分配的资源</li>
<li>引用计数允许对一个类的多次引用</li>
</ul>
<p>更多信息请参见<a href="./13_Inheritance.html">继承</a>，<a href="./19_Type_Casting.html">类型转换</a>，<a href="./15_Deinitialization.html">析构过程</a>，和<a href="./16_Automatic_Reference_Counting.html">自动引用计数</a>。</p>
<blockquote>
<p>注意<br>结构体总是通过被复制的方式在代码中传递，不使用引用计数。</p>
</blockquote>
<p><a name="definition_syntax"></a></p>
<h3 id="定义语法">定义语法</h3><p>类和结构体有着类似的定义方式。我们通过关键字<code>class</code>和<code>struct</code>来分别表示类和结构体，并在一对大括号中定义它们的具体内容：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">	<span class="comment">// class definition goes here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeStructure</span> </span>&#123;</span><br><span class="line">	<span class="comment">// structure definition goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>在你每次定义一个新类或者结构体的时候，实际上你是定义了一个新的 Swift 类型。因此请使用<code>UpperCamelCase</code>这种方式来命名（如<code>SomeClass</code>和<code>SomeStructure</code>等），以便符合标准 Swift 类型的大写命名风格（如<code>String</code>，<code>Int</code>和<code>Bool</code>）。相反的，请使用<code>lowerCamelCase</code>这种方式为属性和方法命名（如<code>framerate</code>和<code>incrementCount</code>），以便和类型名区分。</p>
</blockquote>
<p>以下是定义结构体和定义类的示例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Resolution</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> width = <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> height = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoMode</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> resolution = <span class="type">Resolution</span>()</span><br><span class="line">	<span class="keyword">var</span> interlaced = <span class="literal">false</span></span><br><span class="line">	<span class="keyword">var</span> frameRate = <span class="number">0.0</span></span><br><span class="line">	<span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中我们定义了一个名为<code>Resolution</code>的结构体，用来描述一个显示器的像素分辨率。这个结构体包含了两个名为<code>width</code>和<code>height</code>的存储属性。存储属性是被捆绑和存储在类或结构体中的常量或变量。当这两个属性被初始化为整数<code>0</code>的时候，它们会被推断为<code>Int</code>类型。</p>
<p>在上面的示例中我们还定义了一个名为<code>VideoMode</code>的类，用来描述一个视频显示器的特定模式。这个类包含了四个变量存储属性。第一个是<code>分辨率</code>，它被初始化为一个新的<code>Resolution</code>结构体的实例，属性类型被推断为<code>Resolution</code>。新<code>VideoMode</code>实例同时还会初始化其它三个属性，它们分别是，初始值为<code>false</code>的<code>interlaced</code>，初始值为<code>0.0</code>的<code>frameRate</code>，以及值为可选<code>String</code>的<code>name</code>。<code>name</code>属性会被自动赋予一个默认值<code>nil</code>，意为“没有<code>name</code>值”，因为它是一个可选类型。</p>
<p><a name="class_and_structure_instances"></a></p>
<h3 id="类和结构体实例">类和结构体实例</h3><p><code>Resolution</code>结构体和<code>VideoMode</code>类的定义仅描述了什么是<code>Resolution</code>和<code>VideoMode</code>。它们并没有描述一个特定的分辨率（resolution）或者视频模式（video mode）。为了描述一个特定的分辨率或者视频模式，我们需要生成一个它们的实例。</p>
<p>生成结构体和类实例的语法非常相似：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someResolution = <span class="type">Resolution</span>()</span><br><span class="line"><span class="keyword">let</span> someVideoMode = <span class="type">VideoMode</span>()</span><br></pre></td></tr></table></figure>
<p>结构体和类都使用构造器语法来生成新的实例。构造器语法的最简单形式是在结构体或者类的类型名称后跟随一对空括号，如<code>Resolution()</code>或<code>VideoMode()</code>。通过这种方式所创建的类或者结构体实例，其属性均会被初始化为默认值。<a href="./14_Initialization.html">构造过程</a>章节会对类和结构体的初始化进行更详细的讨论。</p>
<p><a name="accessing_properties"></a></p>
<h3 id="属性访问">属性访问</h3><p>通过使用<em>点语法</em>（<em>dot syntax</em>），你可以访问实例的属性。其语法规则是，实例名后面紧跟属性名，两者通过点号(<code>.</code>)连接：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"The width of someResolution is <span class="subst">\(someResolution.width)</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "The width of someResolution is 0"</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>someResolution.width</code>引用<code>someResolution</code>的<code>width</code>属性，返回<code>width</code>的初始值<code>0</code>。</p>
<p>你也可以访问子属性，如<code>VideoMode</code>中<code>Resolution</code>属性的<code>width</code>属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"The width of someVideoMode is <span class="subst">\(someVideoMode.resolution.width)</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "The width of someVideoMode is 0"</span></span><br></pre></td></tr></table></figure>
<p>你也可以使用点语法为变量属性赋值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">someVideoMode.resolution.width = <span class="number">1280</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The width of someVideoMode is now <span class="subst">\(someVideoMode.resolution.width)</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "The width of someVideoMode is now 1280"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>与 Objective-C 语言不同的是，Swift 允许直接设置结构体属性的子属性。上面的最后一个例子，就是直接设置了<code>someVideoMode</code>中<code>resolution</code>属性的<code>width</code>这个子属性，以上操作并不需要重新为整个<code>resolution</code>属性设置新值。</p>
</blockquote>
<p><a name="memberwise_initializers_for_structure_types"></a></p>
<h3 id="结构体类型的成员逐一构造器（Memberwise_Initializers_for_Structure_Types）">结构体类型的成员逐一构造器（Memberwise Initializers for Structure Types）</h3><p>所有结构体都有一个自动生成的<em>成员逐一构造器</em>，用于初始化新结构体实例中成员的属性。新实例中各个属性的初始值可以通过属性的名称传递到成员逐一构造器之中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vga = <span class="type">Resolution</span>(width:<span class="number">640</span>, height: <span class="number">480</span>)</span><br></pre></td></tr></table></figure>
<p>与结构体不同，类实例没有默认的成员逐一构造器。<a href="./14_Initialization.html">构造过程</a>章节会对构造器进行更详细的讨论。</p>
<p><a name="structures_and_enumerations_are_value_types"></a></p>
<h2 id="结构体和枚举是值类型">结构体和枚举是值类型</h2><p><em>值类型</em>被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被<em>拷贝</em>。</p>
<p>在之前的章节中，我们已经大量使用了值类型。实际上，在 Swift 中，所有的基本类型：整数（Integer）、浮点数（floating-point）、布尔值（Boolean）、字符串（string)、数组（array）和字典（dictionary），都是值类型，并且在底层都是以结构体的形式所实现。</p>
<p>在 Swift 中，所有的结构体和枚举类型都是值类型。这意味着它们的实例，以及实例中所包含的任何值类型属性，在代码中传递的时候都会被复制。</p>
<p>请看下面这个示例，其使用了前一个示例中的<code>Resolution</code>结构体：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hd = <span class="type">Resolution</span>(width: <span class="number">1920</span>, height: <span class="number">1080</span>)</span><br><span class="line"><span class="keyword">var</span> cinema = hd</span><br></pre></td></tr></table></figure>
<p>在以上示例中，声明了一个名为<code>hd</code>的常量，其值为一个初始化为全高清视频分辨率（<code>1920</code> 像素宽，<code>1080</code> 像素高）的<code>Resolution</code>实例。</p>
<p>然后示例中又声明了一个名为<code>cinema</code>的变量，并将<code>hd</code>赋值给它。因为<code>Resolution</code>是一个结构体，所以<code>cinema</code>的值其实是<code>hd</code>的一个拷贝副本，而不是<code>hd</code>本身。尽管<code>hd</code>和<code>cinema</code>有着相同的宽（width）和高（height），但是在幕后它们是两个完全不同的实例。</p>
<p>下面，为了符合数码影院放映的需求（<code>2048</code> 像素宽，<code>1080</code> 像素高），<code>cinema</code>的<code>width</code>属性需要作如下修改：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cinema.width = <span class="number">2048</span></span><br></pre></td></tr></table></figure>
<p>这里，将会显示<code>cinema</code>的<code>width</code>属性确已改为了<code>2048</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"cinema is now  <span class="subst">\(cinema.width)</span> pixels wide"</span>)</span><br><span class="line"><span class="comment">// 输出 "cinema is now 2048 pixels wide"</span></span><br></pre></td></tr></table></figure>
<p>然而，初始的<code>hd</code>实例中<code>width</code>属性还是<code>1920</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"hd is still <span class="subst">\(hd.width)</span> pixels wide"</span>)</span><br><span class="line"><span class="comment">// 输出 "hd is still 1920 pixels wide"</span></span><br></pre></td></tr></table></figure>
<p>在将<code>hd</code>赋予给<code>cinema</code>的时候，实际上是将<code>hd</code>中所存储的值进行拷贝，然后将拷贝的数据存储到新的<code>cinema</code>实例中。结果就是两个完全独立的实例碰巧包含有相同的数值。由于两者相互独立，因此将<code>cinema</code>的<code>width</code>修改为<code>2048</code>并不会影响<code>hd</code>中的<code>width</code>的值。</p>
<p>枚举也遵循相同的行为准则：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CompassPoint</span> </span>&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">North</span>, <span class="type">South</span>, <span class="type">East</span>, <span class="type">West</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> currentDirection = <span class="type">CompassPoint</span>.<span class="type">West</span></span><br><span class="line"><span class="keyword">let</span> rememberedDirection = currentDirection</span><br><span class="line">currentDirection = .<span class="type">East</span></span><br><span class="line"><span class="keyword">if</span> rememberedDirection == .<span class="type">West</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"The remembered direction is still .West"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "The remembered direction is still .West"</span></span><br></pre></td></tr></table></figure>
<p>上例中<code>rememberedDirection</code>被赋予了<code>currentDirection</code>的值，实际上它被赋予的是值的一个拷贝。赋值过程结束后再修改<code>currentDirection</code>的值并不影响<code>rememberedDirection</code>所储存的原始值的拷贝。</p>
<p><a name="classes_are_reference_types"></a></p>
<h2 id="类是引用类型">类是引用类型</h2><p>与值类型不同，引用类型在被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。因此，引用的是已存在的实例本身而不是其拷贝。</p>
<p>请看下面这个示例，其使用了之前定义的<code>VideoMode</code>类：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tenEighty = <span class="type">VideoMode</span>()</span><br><span class="line">tenEighty.resolution = hd</span><br><span class="line">tenEighty.interlaced = <span class="literal">true</span></span><br><span class="line">tenEighty.name = <span class="string">"1080i"</span></span><br><span class="line">tenEighty.frameRate = <span class="number">25.0</span></span><br></pre></td></tr></table></figure>
<p>以上示例中，声明了一个名为<code>tenEighty</code>的常量，其引用了一个<code>VideoMode</code>类的新实例。在之前的示例中，这个视频模式（video mode）被赋予了HD分辨率（<code>1920</code>*<code>1080</code>）的一个拷贝（即<code>hd</code>实例）。同时设置为<code>interlaced</code>，命名为<code>“1080i”</code>。最后，其帧率是<code>25.0</code>帧每秒。</p>
<p>然后，<code>tenEighty</code>被赋予名为<code>alsoTenEighty</code>的新常量，同时对<code>alsoTenEighty</code>的帧率进行修改：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> alsoTenEighty = tenEighty</span><br><span class="line">alsoTenEighty.frameRate = <span class="number">30.0</span></span><br></pre></td></tr></table></figure>
<p>因为类是引用类型，所以<code>tenEight</code>和<code>alsoTenEight</code>实际上引用的是相同的<code>VideoMode</code>实例。换句话说，它们是同一个实例的两种叫法。</p>
<p>下面，通过查看<code>tenEighty</code>的<code>frameRate</code>属性，我们会发现它正确的显示了所引用的<code>VideoMode</code>实例的新帧率，其值为<code>30.0</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"The frameRate property of tenEighty is now <span class="subst">\(tenEighty.frameRate)</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "The frameRate property of theEighty is now 30.0"</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是<code>tenEighty</code>和<code>alsoTenEighty</code>被声明为常量而不是变量。然而你依然可以改变<code>tenEighty.frameRate</code>和<code>alsoTenEighty.frameRate</code>，因为<code>tenEighty</code>和<code>alsoTenEighty</code>这两个常量的值并未改变。它们并不“存储”这个<code>VideoMode</code>实例，而仅仅是对<code>VideoMode</code>实例的引用。所以，改变的是被引用的<code>VideoMode</code>的<code>frameRate</code>属性，而不是引用<code>VideoMode</code>的常量的值。</p>
<p><a name="identity_operators"></a></p>
<h3 id="恒等运算符">恒等运算符</h3><p>因为类是引用类型，有可能有多个常量和变量在幕后同时引用同一个类实例。（对于结构体和枚举来说，这并不成立。因为它们作为值类型，在被赋予到常量、变量或者传递到函数时，其值总是会被拷贝。）</p>
<p>如果能够判定两个常量或者变量是否引用同一个类实例将会很有帮助。为了达到这个目的，Swift 内建了两个恒等运算符：</p>
<ul>
<li>等价于（<code>===</code>）</li>
<li>不等价于（<code>!==</code>）</li>
</ul>
<p>运用这两个运算符检测两个常量或者变量是否引用同一个实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> tenEighty === alsoTenEighty &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"tenEighty and alsoTenEighty refer to the same Resolution instance."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出 "tenEighty and alsoTenEighty refer to the same Resolution instance."</span></span><br></pre></td></tr></table></figure>
<p>请注意，“等价于”（用三个等号表示，<code>===</code>）与“等于”（用两个等号表示，<code>==</code>）的不同：</p>
<ul>
<li>“等价于”表示两个类类型（class type）的常量或者变量引用同一个类实例。</li>
<li>“等于”表示两个实例的值“相等”或“相同”，判定时要遵照设计者定义的评判标准，因此相对于“相等”来说，这是一种更加合适的叫法。</li>
</ul>
<p>当你在定义你的自定义类和结构体的时候，你有义务来决定判定两个实例“相等”的标准。在章节<a href="./25_Advanced_Operators.html#equivalence_operators">等价操作符</a>中将会详细介绍实现自定义“等于”和“不等于”运算符的流程。</p>
<p><a name="pointers"></a></p>
<h3 id="指针">指针</h3><p>如果你有 C，C++ 或者 Objective-C 语言的经验，那么你也许会知道这些语言使用<em>指针</em>来引用内存中的地址。一个引用某个引用类型实例的 Swift 常量或者变量，与 C 语言中的指针类似，但是并不直接指向某个内存地址，也不要求你使用星号（<code>*</code>）来表明你在创建一个引用。Swift 中的这些引用与其它的常量或变量的定义方式相同。</p>
<p><a name="choosing_between_classes_and_structures"></a></p>
<h2 id="类和结构体的选择">类和结构体的选择</h2><p>在你的代码中，你可以使用类和结构体来定义你的自定义数据类型。</p>
<p>然而，结构体实例总是通过值传递，类实例总是通过引用传递。这意味两者适用不同的任务。当你在考虑一个工程项目的数据结构和功能的时候，你需要决定每个数据结构是定义成类还是结构体。</p>
<p>按照通用的准则，当符合一条或多条以下条件时，请考虑构建结构体：</p>
<ul>
<li>该数据结构的主要目的是用来封装少量相关简单数据值。</li>
<li>有理由预计该数据结构的实例在被赋值或传递时，封装的数据将会被拷贝而不是被引用。</li>
<li>该数据结构中储存的值类型属性，也应该被拷贝，而不是被引用。</li>
<li>该数据结构不需要去继承另一个既有类型的属性或者行为。</li>
</ul>
<p>举例来说，以下情境中适合使用结构体：</p>
<ul>
<li>几何形状的大小，封装一个<code>width</code>属性和<code>height</code>属性，两者均为<code>Double</code>类型。</li>
<li>一定范围内的路径，封装一个<code>start</code>属性和<code>length</code>属性，两者均为<code>Int</code>类型。</li>
<li>三维坐标系内一点，封装<code>x</code>，<code>y</code>和<code>z</code>属性，三者均为<code>Double</code>类型。</li>
</ul>
<p>在所有其它案例中，定义一个类，生成一个它的实例，并通过引用来管理和传递。实际中，这意味着绝大部分的自定义数据构造都应该是类，而非结构体。</p>
<p><a name="assignment_and_copy_behavior_for_strings_arrays_and_dictionaries"></a></p>
<h2 id="字符串(String)、数组(Array)、和字典(Dictionary)类型的赋值与复制行为">字符串(String)、数组(Array)、和字典(Dictionary)类型的赋值与复制行为</h2><p>Swift 中，许多基本类型，诸如<code>String</code>，<code>Array</code>和<code>Dictionary</code>类型均以结构体的形式实现。这意味着被赋值给新的常量或变量，或者被传入函数或方法中时，它们的值会被拷贝。</p>
<p>Objective-C 中<code>NSString</code>，<code>NSArray</code>和<code>NSDictionary</code>类型均以类的形式实现，而并非结构体。它们在被赋值或者被传入函数或方法时，不会发生值拷贝，而是传递现有实例的引用。</p>
<blockquote>
<p>注意<br>以上是对字符串、数组、字典的“拷贝”行为的描述。在你的代码中，拷贝行为看起来似乎总会发生。然而，Swift 在幕后只在绝对必要时才执行实际的拷贝。Swift 管理所有的值拷贝以确保性能最优化，所以你没必要去回避赋值来保证性能最优化。</p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/10_Properties/" itemprop="url">
                第二章-10属性 (Properties)
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:17+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/10_Properties/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/10_Properties/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="属性_(Properties)">属性 (Properties)</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/shinyzhu" target="_blank" rel="external">shinyzhu</a><br>校对：<a href="https://github.com/pp-prog" target="_blank" rel="external">pp-prog</a> <a href="https://github.com/yangsiy" target="_blank" rel="external">yangsiy</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/yangsiy" target="_blank" rel="external">yangsiy</a></p>
<p>2.1<br>翻译：<a href="https://github.com/buginux" target="_blank" rel="external">buginux</a><br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a>，2015-10-29</p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#stored_properties">存储属性（Stored Properties）</a></li>
<li><a href="#computed_properties">计算属性（Computed Properties）</a></li>
<li><a href="#property_observers">属性观察器（Property Observers）</a></li>
<li><a href="#global_and_local_variables">全局变量和局部变量（Global and Local Variables）</a></li>
<li><a href="#type_properties">类型属性（Type Properties）</a></li>
</ul>
<p><em>属性</em>将值跟特定的类、结构或枚举关联。存储属性存储常量或变量作为实例的一部分，而计算属性计算（不是存储）一个值。计算属性可以用于类、结构体和枚举，存储属性只能用于类和结构体。</p>
<p>存储属性和计算属性通常与特定类型的实例关联。但是，属性也可以直接作用于类型本身，这种属性称为类型属性。</p>
<p>另外，还可以定义属性观察器来监控属性值的变化，以此来触发一个自定义的操作。属性观察器可以添加到自己定义的存储属性上，也可以添加到从父类继承的属性上。</p>
<p><a name="stored_properties"></a></p>
<h2 id="存储属性">存储属性</h2><p>简单来说，一个存储属性就是存储在特定类或结构体的实例里的一个常量或变量。存储属性可以是<em>变量存储属性</em>（用关键字<code>var</code>定义），也可以是<em>常量存储属性</em>（用关键字<code>let</code>定义）。</p>
<p>可以在定义存储属性的时候指定默认值，请参考<a href="./14_Initialization.html#default_initializers">默认构造器</a>一节。也可以在构造过程中设置或修改存储属性的值，甚至修改常量存储属性的值，请参考<a href="./14_Initialization.html#assigning_constant_properties_during_initialization">构造过程中常量属性的修改</a>一节。</p>
<p>下面的例子定义了一个名为<code>FixedLengthRange</code>的结构体，它描述了一个在创建后无法修改值域宽度的区间：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FixedLengthRange</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> firstValue: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> length: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> rangeOfThreeItems = <span class="type">FixedLengthRange</span>(firstValue: <span class="number">0</span>, length: <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 该区间表示整数0，1，2</span></span><br><span class="line">rangeOfThreeItems.firstValue = <span class="number">6</span></span><br><span class="line"><span class="comment">// 该区间现在表示整数6，7，8</span></span><br></pre></td></tr></table></figure>
<p><code>FixedLengthRange</code>的实例包含一个名为<code>firstValue</code>的变量存储属性和一个名为<code>length</code>的常量存储属性。在上面的例子中，<code>length</code>在创建实例的时候被初始化，因为它是一个常量存储属性，所以之后无法修改它的值。</p>
<p><a name="stored_properties_of_constant_structure_instances"></a></p>
<h3 id="常量结构体的存储属性">常量结构体的存储属性</h3><p>如果创建了一个结构体的实例并将其赋值给一个常量，则无法修改该实例的任何属性，即使定义了变量存储属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rangeOfFourItems = <span class="type">FixedLengthRange</span>(firstValue: <span class="number">0</span>, length: <span class="number">4</span>)</span><br><span class="line"><span class="comment">// 该区间表示整数0，1，2，3</span></span><br><span class="line">rangeOfFourItems.firstValue = <span class="number">6</span></span><br><span class="line"><span class="comment">// 尽管 firstValue 是个变量属性，这里还是会报错</span></span><br></pre></td></tr></table></figure>
<p>因为<code>rangeOfFourItems</code>被声明成了常量（用<code>let</code>关键字），即使<code>firstValue</code>是一个变量属性，也无法再修改它了。</p>
<p>这种行为是由于结构体（struct）属于<em>值类型</em>。当值类型的实例被声明为常量的时候，它的所有属性也就成了常量。</p>
<p>属于<em>引用类型</em>的类（class）则不一样。把一个引用类型的实例赋给一个常量后，仍然可以修改该实例的变量属性。</p>
<p><a name="lazy_stored_properties"></a></p>
<h3 id="延迟存储属性">延迟存储属性</h3><p>延迟存储属性是指当第一次被调用的时候才会计算其初始值的属性。在属性声明前使用<code>lazy</code>来标示一个延迟存储属性。</p>
<blockquote>
<p>注意<br>必须将延迟存储属性声明成变量（使用<code>var</code>关键字），因为属性的初始值可能在实例构造完成之后才会得到。而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性。  </p>
</blockquote>
<p>延迟属性很有用，当属性的值依赖于在实例的构造过程结束后才会知道具体值的外部因素时，或者当获得属性的初始值需要复杂或大量计算时，可以只在需要的时候计算它。</p>
<p>下面的例子使用了延迟存储属性来避免复杂类中不必要的初始化。例子中定义了<code>DataImporter</code>和<code>DataManager</code>两个类，下面是部分代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataImporter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">    DataImporter 是一个负责将外部文件中的数据导入的类。</span><br><span class="line">    这个类的初始化会消耗不少时间。</span><br><span class="line">    */</span></span><br><span class="line">    <span class="keyword">var</span> fileName = <span class="string">"data.txt"</span></span><br><span class="line">    <span class="comment">// 这里会提供数据导入功能</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataManager</span> </span>&#123;</span><br><span class="line">    lazy <span class="keyword">var</span> importer = <span class="type">DataImporter</span>()</span><br><span class="line">    <span class="keyword">var</span> data = [<span class="type">String</span>]()</span><br><span class="line">    <span class="comment">// 这里会提供数据管理功能</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> manager = <span class="type">DataManager</span>()</span><br><span class="line">manager.data.append(<span class="string">"Some data"</span>)</span><br><span class="line">manager.data.append(<span class="string">"Some more data"</span>)</span><br><span class="line"><span class="comment">// DataImporter 实例的 importer 属性还没有被创建</span></span><br></pre></td></tr></table></figure>
<p><code>DataManager</code>类包含一个名为<code>data</code>的存储属性，初始值是一个空的字符串（<code>String</code>）数组。这里没有给出全部代码，只需知道<code>DataManager</code>类的目的是管理和提供对这个字符串数组的访问即可。</p>
<p><code>DataManager</code>的一个功能是从文件导入数据。该功能由<code>DataImporter</code>类提供，<code>DataImporter</code>完成初始化需要消耗不少时间：因为它的实例在初始化时可能要打开文件，还要读取文件内容到内存。</p>
<p><code>DataManager</code>管理数据时也可能不从文件中导入数据。所以当<code>DataManager</code>的实例被创建时，没必要创建一个<code>DataImporter</code>的实例，更明智的做法是第一次用到<code>DataImporter</code>的时候才去创建它。</p>
<p>由于使用了<code>lazy</code>，<code>importer</code>属性只有在第一次被访问的时候才被创建。比如访问它的属性<code>fileName</code>时：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(manager.importer.fileName)</span><br><span class="line"><span class="comment">// DataImporter 实例的 importer 属性现在被创建了</span></span><br><span class="line"><span class="comment">// 输出 "data.txt”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>如果一个被标记为<code>lazy</code>的属性在没有初始化时就同时被多个线程访问，则无法保证该属性只会被初始化一次。</p>
</blockquote>
<p><a name="stored_properties_and_instance_variables"></a></p>
<h3 id="存储属性和实例变量">存储属性和实例变量</h3><p>如果您有过 Objective-C 经验，应该知道 Objective-C 为类实例存储值和引用提供两种方法。除了属性之外，还可以使用实例变量作为属性值的后端存储。</p>
<p>Swift 编程语言中把这些理论统一用属性来实现。Swift 中的属性没有对应的实例变量，属性的后端存储也无法直接访问。这就避免了不同场景下访问方式的困扰，同时也将属性的定义简化成一个语句。属性的全部信息——包括命名、类型和内存管理特征——都在唯一一个地方（类型定义中）定义。</p>
<p><a name="computed_properties"></a></p>
<h2 id="计算属性">计算属性</h2><p>除存储属性外，类、结构体和枚举可以定义<em>计算属性</em>。计算属性不直接存储值，而是提供一个 getter 和一个可选的 setter，来间接获取和设置其他属性或变量的值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span>, height = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> origin = <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size = <span class="type">Size</span>()</span><br><span class="line">    <span class="keyword">var</span> center: <span class="type">Point</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> centerX = origin.x + (size.width / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">let</span> centerY = origin.y + (size.height / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Point</span>(x: centerX, y: centerY)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>(newCenter) &#123;</span><br><span class="line">            origin.x = newCenter.x - (size.width / <span class="number">2</span>)</span><br><span class="line">            origin.y = newCenter.y - (size.height / <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> square = <span class="type">Rect</span>(origin: <span class="type">Point</span>(x: <span class="number">0.0</span>, y: <span class="number">0.0</span>),</span><br><span class="line">    size: <span class="type">Size</span>(width: <span class="number">10.0</span>, height: <span class="number">10.0</span>))</span><br><span class="line"><span class="keyword">let</span> initialSquareCenter = square.center</span><br><span class="line">square.center = <span class="type">Point</span>(x: <span class="number">15.0</span>, y: <span class="number">15.0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"square.origin is now at (<span class="subst">\(square.origin.x)</span>, <span class="subst">\(square.origin.y)</span>)"</span>)</span><br><span class="line"><span class="comment">// 输出 "square.origin is now at (10.0, 10.0)”</span></span><br></pre></td></tr></table></figure>
<p>这个例子定义了 3 个结构体来描述几何形状：</p>
<ul>
<li><code>Point</code>封装了一个<code>(x, y)</code>的坐标</li>
<li><code>Size</code>封装了一个<code>width</code>和一个<code>height</code></li>
<li><code>Rect</code>表示一个有原点和尺寸的矩形</li>
</ul>
<p><code>Rect</code>也提供了一个名为<code>center</code>的计算属性。一个矩形的中心点可以从原点（<code>origin</code>）和尺寸（<code>size</code>）算出，所以不需要将它以显式声明的<code>Point</code>来保存。<code>Rect</code>的计算属性<code>center</code>提供了自定义的 getter 和 setter 来获取和设置矩形的中心点，就像它有一个存储属性一样。</p>
<p>上述例子中创建了一个名为<code>square</code>的<code>Rect</code>实例，初始值原点是<code>(0, 0)</code>，宽度高度都是<code>10</code>。如下图中蓝色正方形所示。</p>
<p><code>square</code>的<code>center</code>属性可以通过点运算符（<code>square.center</code>）来访问，这会调用该属性的 getter 来获取它的值。跟直接返回已经存在的值不同，getter 实际上通过计算然后返回一个新的<code>Point</code>来表示<code>square</code>的中心点。如代码所示，它正确返回了中心点<code>(5, 5)</code>。</p>
<p><code>center</code>属性之后被设置了一个新的值<code>(15, 15)</code>，表示向右上方移动正方形到如下图橙色正方形所示的位置。设置属性<code>center</code>的值会调用它的 setter 来修改属性<code>origin</code>的<code>x</code>和<code>y</code>的值，从而实现移动正方形到新的位置。</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/computedProperties_2x.png" alt="Computed Properties sample" width="388" height="387"></p>
<p><a name="shorthand_setter_declaration"></a></p>
<h3 id="便捷_setter_声明">便捷 setter 声明</h3><p>如果计算属性的 setter 没有定义表示新值的参数名，则可以使用默认名称<code>newValue</code>。下面是使用了便捷 setter 声明的<code>Rect</code>结构体代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AlternativeRect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> origin = <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size = <span class="type">Size</span>()</span><br><span class="line">    <span class="keyword">var</span> center: <span class="type">Point</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> centerX = origin.x + (size.width / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">let</span> centerY = origin.y + (size.height / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Point</span>(x: centerX, y: centerY)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            origin.x = newValue.x - (size.width / <span class="number">2</span>)</span><br><span class="line">            origin.y = newValue.y - (size.height / <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="readonly_computed_properties"></a></p>
<h3 id="只读计算属性">只读计算属性</h3><p>只有 getter 没有 setter 的计算属性就是<em>只读计算属性</em>。只读计算属性总是返回一个值，可以通过点运算符访问，但不能设置新的值。</p>
<blockquote>
<p>注意<br>必须使用<code>var</code>关键字定义计算属性，包括只读计算属性，因为它们的值不是固定的。<code>let</code>关键字只用来声明常量属性，表示初始化后再也无法修改的值。</p>
</blockquote>
<p>只读计算属性的声明可以去掉<code>get</code>关键字和花括号：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cuboid</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span>, height = <span class="number">0.0</span>, depth = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> volume: <span class="type">Double</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> width * height * depth</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fourByFiveByTwo = <span class="type">Cuboid</span>(width: <span class="number">4.0</span>, height: <span class="number">5.0</span>, depth: <span class="number">2.0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"the volume of fourByFiveByTwo is <span class="subst">\(fourByFiveByTwo.volume)</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "the volume of fourByFiveByTwo is 40.0"</span></span><br></pre></td></tr></table></figure>
<p>这个例子定义了一个名为<code>Cuboid</code>的结构体，表示三维空间的立方体，包含<code>width</code>、<code>height</code>和<code>depth</code>属性。结构体还有一个名为<code>volume</code>的只读计算属性用来返回立方体的体积。为<code>volume</code>提供 setter 毫无意义，因为无法确定如何修改<code>width</code>、<code>height</code>和<code>depth</code>三者的值来匹配新的<code>volume</code>。然而，<code>Cuboid</code>提供一个只读计算属性来让外部用户直接获取体积是很有用的。</p>
<p><a name="property_observers"></a></p>
<h2 id="属性观察器">属性观察器</h2><p><em>属性观察器</em>监控和响应属性值的变化，每次属性被设置值的时候都会调用属性观察器，甚至新值和当前值相同的时候也不例外。</p>
<p>可以为除了延迟存储属性之外的其他存储属性添加属性观察器，也可以通过重写属性的方式为继承的属性（包括存储属性和计算属性）添加属性观察器。属性重写请参考<a href="./13_Inheritance.html#overriding">重写</a>。</p>
<blockquote>
<p>注意<br>不需要为非重写的计算属性添加属性观察器，因为可以通过它的 setter 直接监控和响应值的变化。  </p>
</blockquote>
<p>可以为属性添加如下的一个或全部观察器：</p>
<ul>
<li><code>willSet</code>在新的值被设置之前调用</li>
<li><code>didSet</code>在新的值被设置之后立即调用</li>
</ul>
<p><code>willSet</code>观察器会将新的属性值作为常量参数传入，在<code>willSet</code>的实现代码中可以为这个参数指定一个名称，如果不指定则参数仍然可用，这时使用默认名称<code>newValue</code>表示。</p>
<p>类似地，<code>didSet</code>观察器会将旧的属性值作为参数传入，可以为该参数命名或者使用默认参数名<code>oldValue</code>。</p>
<blockquote>
<p>注意<br>父类的属性在子类的构造器中被赋值时，它在父类中的<code>willSet</code>和<code>didSet</code>观察器会被调用。<br>有关构造器代理的更多信息，请参考<a href="./14_Initialization.html#initializer_delegation_for_value_types">值类型的构造器代理</a>和<a href="./14_Initialization.html#initializer_delegation_for_class_types">类的构造器代理规则</a>。</p>
</blockquote>
<p>这里是一个<code>willSet</code>和<code>didSet</code>的实际例子，其中定义了一个名为<code>StepCounter</code>的类，用来统计一个人步行时的总步数。这个类可以跟计步器或其他日常锻炼的统计装置的输入数据配合使用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StepCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> totalSteps: <span class="type">Int</span> = <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span>(newTotalSteps) &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"About to set totalSteps to <span class="subst">\(newTotalSteps)</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> totalSteps &gt; oldValue  &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Added <span class="subst">\(totalSteps - oldValue)</span> steps"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> stepCounter = <span class="type">StepCounter</span>()</span><br><span class="line">stepCounter.totalSteps = <span class="number">200</span></span><br><span class="line"><span class="comment">// About to set totalSteps to 200</span></span><br><span class="line"><span class="comment">// Added 200 steps</span></span><br><span class="line">stepCounter.totalSteps = <span class="number">360</span></span><br><span class="line"><span class="comment">// About to set totalSteps to 360</span></span><br><span class="line"><span class="comment">// Added 160 steps</span></span><br><span class="line">stepCounter.totalSteps = <span class="number">896</span></span><br><span class="line"><span class="comment">// About to set totalSteps to 896</span></span><br><span class="line"><span class="comment">// Added 536 steps</span></span><br></pre></td></tr></table></figure>
<p><code>StepCounter</code>类定义了一个<code>Int</code>类型的属性<code>totalSteps</code>，它是一个存储属性，包含<code>willSet</code>和<code>didSet</code>观察器。</p>
<p>当<code>totalSteps</code>被设置新值的时候，它的<code>willSet</code>和<code>didSet</code>观察器都会被调用，甚至新值和当前值完全相同时也会被调用。</p>
<p>例子中的<code>willSet</code>观察器将表示新值的参数自定义为<code>newTotalSteps</code>，这个观察器只是简单的将新的值输出。</p>
<p><code>didSet</code>观察器在<code>totalSteps</code>的值改变后被调用，它把新值和旧值进行对比，如果总步数增加了，就输出一个消息表示增加了多少步。<code>didSet</code>没有为旧值提供自定义名称，所以默认值<code>oldValue</code>表示旧值的参数名。</p>
<blockquote>
<p>注意<br>如果在一个属性的<code>didSet</code>观察器里为它赋值，这个值会替换之前设置的值。  </p>
</blockquote>
<p><a name="global_and_local_variables"></a></p>
<p>##全局变量和局部变量</p>
<p>计算属性和属性观察器所描述的功能也可以用于<em>全局变量</em>和<em>局部变量</em>。全局变量是在函数、方法、闭包或任何类型之外定义的变量。局部变量是在函数、方法或闭包内部定义的变量。</p>
<p>前面章节提到的全局或局部变量都属于存储型变量，跟存储属性类似，它为特定类型的值提供存储空间，并允许读取和写入。</p>
<p>另外，在全局或局部范围都可以定义计算型变量和为存储型变量定义观察器。计算型变量跟计算属性一样，返回一个计算结果而不是存储值，声明格式也完全一样。</p>
<blockquote>
<p>注意<br>全局的常量或变量都是延迟计算的，跟<a href="#lazy_stored_properties">延迟存储属性</a>相似，不同的地方在于，全局的常量或变量不需要标记<code>lazy</code>修饰符。<br>局部范围的常量或变量从不延迟计算。  </p>
</blockquote>
<p><a name="type_properties"></a></p>
<p>##类型属性</p>
<p>实例属性属于一个特定类型的实例，每创建一个实例，实例都拥有属于自己的一套属性值，实例之间的属性相互独立。</p>
<p>也可以为类型本身定义属性，无论创建了多少个该类型的实例，这些属性都只有唯一一份。这种属性就是<em>类型属性</em>。</p>
<p>类型属性用于定义某个类型所有实例共享的数据，比如所有实例都能用的一个常量（就像 C 语言中的静态常量），或者所有实例都能访问的一个变量（就像 C 语言中的静态变量）。</p>
<p>存储型类型属性可以是变量或常量，计算型类型属性跟实例的计算型属性一样只能定义成变量属性。</p>
<blockquote>
<p>注意<br>跟实例的存储型属性不同，必须给存储型类型属性指定默认值，因为类型本身没有构造器，也就无法在初始化过程中使用构造器给类型属性赋值。<br>存储型类型属性是延迟初始化的，它们只有在第一次被访问的时候才会被初始化。即使它们被多个线程同时访问，系统也保证只会对其进行一次初始化，并且不需要对其使用<code>lazy</code>修饰符。</p>
</blockquote>
<p><a name="type_property_syntax"></a></p>
<p>###类型属性语法</p>
<p>在 C 或 Objective-C 中，与某个类型关联的静态常量和静态变量，是作为全局（<em>global</em>）静态变量定义的。但是在 Swift 中，类型属性是作为类型定义的一部分写在类型最外层的花括号内，因此它的作用范围也就在类型支持的范围内。</p>
<p>使用关键字<code>static</code>来定义类型属性。在为类定义计算型类型属性时，可以改用关键字<code>class</code>来支持子类对父类的实现进行重写。下面的例子演示了存储型和计算型类型属性的语法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeStructure</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty = <span class="string">"Some value."</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SomeEnumeration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty = <span class="string">"Some value."</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty = <span class="string">"Some value."</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">27</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">overrideableComputedTypeProperty</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">107</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>例子中的计算型类型属性是只读的，但也可以定义可读可写的计算型类型属性，跟计算型实例属性的语法相同。  </p>
</blockquote>
<p><a name="querying_and_setting_type_properties"></a></p>
<p>###获取和设置类型属性的值</p>
<p>跟实例属性一样，类型属性也是通过点运算符来访问。但是，类型属性是通过类型本身来访问，而不是通过实例。比如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="type">SomeStructure</span>.storedTypeProperty)</span><br><span class="line"><span class="comment">// 输出 "Some value."</span></span><br><span class="line"><span class="type">SomeStructure</span>.storedTypeProperty = <span class="string">"Another value."</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">SomeStructure</span>.storedTypeProperty)</span><br><span class="line"><span class="comment">// 输出 "Another value.”</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">SomeEnumeration</span>.computedTypeProperty)</span><br><span class="line"><span class="comment">// 输出 "6"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">SomeClass</span>.computedTypeProperty)</span><br><span class="line"><span class="comment">// 输出 "27"</span></span><br></pre></td></tr></table></figure>
<p>下面的例子定义了一个结构体，使用两个存储型类型属性来表示两个声道的音量，每个声道具有<code>0</code>到<code>10</code>之间的整数音量。</p>
<p>下图展示了如何把两个声道结合来模拟立体声的音量。当声道的音量是<code>0</code>，没有一个灯会亮；当声道的音量是<code>10</code>，所有灯点亮。本图中，左声道的音量是<code>9</code>，右声道的音量是<code>7</code>：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/staticPropertiesVUMeter_2x.png" alt="Static Properties VUMeter" width="243" height="357"></p>
<p>上面所描述的声道模型使用<code>AudioChannel</code>结构体的实例来表示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AudioChannel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> thresholdLevel = <span class="number">10</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> maxInputLevelForAllChannels = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> currentLevel: <span class="type">Int</span> = <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> currentLevel &gt; <span class="type">AudioChannel</span>.thresholdLevel &#123;</span><br><span class="line">                <span class="comment">// 将当前音量限制在阀值之内</span></span><br><span class="line">                currentLevel = <span class="type">AudioChannel</span>.thresholdLevel</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> currentLevel &gt; <span class="type">AudioChannel</span>.maxInputLevelForAllChannels &#123;</span><br><span class="line">                <span class="comment">// 存储当前音量作为新的最大输入音量</span></span><br><span class="line">                <span class="type">AudioChannel</span>.maxInputLevelForAllChannels = currentLevel</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构<code>AudioChannel</code>定义了 2 个存储型类型属性来实现上述功能。第一个是<code>thresholdLevel</code>，表示音量的最大上限阈值，它是一个值为<code>10</code>的常量，对所有实例都可见，如果音量高于<code>10</code>，则取最大上限值<code>10</code>（见后面描述）。</p>
<p>第二个类型属性是变量存储型属性<code>maxInputLevelForAllChannels</code>，它用来表示所有<code>AudioChannel</code>实例的最大音量，初始值是<code>0</code>。</p>
<p><code>AudioChannel</code>也定义了一个名为<code>currentLevel</code>的存储型实例属性，表示当前声道现在的音量，取值为<code>0</code>到<code>10</code>。</p>
<p>属性<code>currentLevel</code>包含<code>didSet</code>属性观察器来检查每次设置后的属性值，它做如下两个检查：</p>
<ul>
<li>如果<code>currentLevel</code>的新值大于允许的阈值<code>thresholdLevel</code>，属性观察器将<code>currentLevel</code>的值限定为阈值<code>thresholdLevel</code>。</li>
<li>如果修正后的<code>currentLevel</code>值大于静态类型属性<code>maxInputLevelForAllChannels</code>的值，属性观察器就将新值保存在<code>maxInputLevelForAllChannels</code>中。</li>
</ul>
<blockquote>
<p>注意<br>在第一个检查过程中，<code>didSet</code>属性观察器将<code>currentLevel</code>设置成了不同的值，但这不会造成属性观察器被再次调用。  </p>
</blockquote>
<p>可以使用结构体<code>AudioChannel</code>创建两个声道<code>leftChannel</code>和<code>rightChannel</code>，用以表示立体声系统的音量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> leftChannel = <span class="type">AudioChannel</span>()</span><br><span class="line"><span class="keyword">var</span> rightChannel = <span class="type">AudioChannel</span>()</span><br></pre></td></tr></table></figure>
<p>如果将左声道的<code>currentLevel</code>设置成<code>7</code>，类型属性<code>maxInputLevelForAllChannels</code>也会更新成<code>7</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">leftChannel.currentLevel = <span class="number">7</span></span><br><span class="line"><span class="built_in">print</span>(leftChannel.currentLevel)</span><br><span class="line"><span class="comment">// 输出 "7"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">AudioChannel</span>.maxInputLevelForAllChannels)</span><br><span class="line"><span class="comment">// 输出 "7"</span></span><br></pre></td></tr></table></figure>
<p>如果试图将右声道的<code>currentLevel</code>设置成<code>11</code>，它会被修正到最大值<code>10</code>，同时<code>maxInputLevelForAllChannels</code>的值也会更新到<code>10</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rightChannel.currentLevel = <span class="number">11</span></span><br><span class="line"><span class="built_in">print</span>(rightChannel.currentLevel)</span><br><span class="line"><span class="comment">// 输出 "10"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">AudioChannel</span>.maxInputLevelForAllChannels)</span><br><span class="line"><span class="comment">// 输出 "10"</span></span><br></pre></td></tr></table></figure>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/11_Methods/" itemprop="url">
                第二章-11方法（Methods）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:16+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/11_Methods/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/11_Methods/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="方法（Methods）">方法（Methods）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/pp-prog" target="_blank" rel="external">pp-prog</a><br>校对：<a href="https://github.com/zqp" target="_blank" rel="external">zqp</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/DianQK" target="_blank" rel="external">DianQK</a></p>
<p>2.1<br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a>，2015-10-29</p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#instance_methods">实例方法(Instance Methods)</a></li>
<li><a href="#type_methods">类型方法(Type Methods)</a></li>
</ul>
<p><strong>方法</strong>是与某些特定类型相关联的函数。类、结构体、枚举都可以定义实例方法；实例方法为给定类型的实例封装了具体的任务与功能。类、结构体、枚举也可以定义类型方法；类型方法与类型本身相关联。类型方法与 Objective-C 中的类方法（class methods）相似。</p>
<p>结构体和枚举能够定义方法是 Swift 与 C/Objective-C 的主要区别之一。在 Objective-C 中，类是唯一能定义方法的类型。但在 Swift 中，你不仅能选择是否要定义一个类/结构体/枚举，还能灵活地在你创建的类型（类/结构体/枚举）上定义方法。</p>
<p><a name="instance_methods"></a></p>
<h2 id="实例方法_(Instance_Methods)">实例方法 (Instance Methods)</h2><p><strong>实例方法</strong>是属于某个特定类、结构体或者枚举类型实例的方法。实例方法提供访问和修改实例属性的方法或提供与实例目的相关的功能，并以此来支撑实例的功能。实例方法的语法与函数完全一致，详情参见<a href="./06_Functions.md">函数</a>。</p>
<p>实例方法要写在它所属的类型的前后大括号之间。实例方法能够隐式访问它所属类型的所有的其他实例方法和属性。实例方法只能被它所属的类的某个特定实例调用。实例方法不能脱离于现存的实例而被调用。</p>
<p>下面的例子，定义一个很简单的<code>Counter</code>类，<code>Counter</code>能被用来对一个动作发生的次数进行计数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">increment</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ++<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">incrementBy</span><span class="params">(amount: Int)</span></span> &#123;</span><br><span class="line">        <span class="built_in">count</span> += amount</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">reset</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Counter</code>类定义了三个实例方法：</p>
<ul>
<li><code>increment</code>让计数器按一递增；</li>
<li><code>incrementBy(amount: Int)</code>让计数器按一个指定的整数值递增；</li>
<li><code>reset</code>将计数器重置为0。</li>
</ul>
<p><code>Counter</code>这个类还声明了一个可变属性<code>count</code>，用它来保持对当前计数器值的追踪。</p>
<p>和调用属性一样，用点语法（dot syntax）调用实例方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> counter = <span class="type">Counter</span>()</span><br><span class="line"><span class="comment">// 初始计数值是0</span></span><br><span class="line">counter.increment()</span><br><span class="line"><span class="comment">// 计数值现在是1</span></span><br><span class="line">counter.incrementBy(<span class="number">5</span>)</span><br><span class="line"><span class="comment">// 计数值现在是6</span></span><br><span class="line">counter.reset()</span><br><span class="line"><span class="comment">// 计数值现在是0</span></span><br></pre></td></tr></table></figure>
<p><a name="local_and_external_parameter"></a></p>
<h3 id="方法的局部参数名称和外部参数名称_(Local_and_External_Parameter_Names_for_Methods)">方法的局部参数名称和外部参数名称 (Local and External Parameter Names for Methods)</h3><p>函数参数可以同时有一个局部名称（在函数体内部使用）和一个外部名称（在调用函数时使用），详情参见<a href="./06_Functions.html#specifying_external_parameter_names">指定外部参数名</a>。方法参数也一样（因为方法就是函数，只是这个函数与某个类型相关联了）。</p>
<p>Swift 中的方法和 Objective-C 中的方法极其相似。像在 Objective-C 中一样，Swift 中方法的名称通常用一个介词指向方法的第一个参数，比如：<code>with</code>，<code>for</code>，<code>by</code>等等。前面的<code>Counter</code>类的例子中<code>incrementBy(_:)</code>方法就是这样的。介词的使用让方法在被调用时能像一个句子一样被解读。</p>
<p>具体来说，Swift 默认仅给方法的第一个参数名称一个局部参数名称；默认同时给第二个和后续的参数名称局部参数名称和外部参数名称。这个约定与典型的命名和调用约定相适应，与你在写 Objective-C 的方法时很相似。这个约定还让富于表达性的方法在调用时不需要再限定参数名称。</p>
<p>看看下面这个<code>Counter</code>的另一个版本（它定义了一个更复杂的<code>incrementBy(_:)</code>方法）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">incrementBy</span><span class="params">(amount: Int, numberOfTimes: Int)</span></span> &#123;</span><br><span class="line">        <span class="built_in">count</span> += amount * numberOfTimes</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>incrementBy(_:numverOfTimes:)</code>方法有两个参数： <code>amount</code>和<code>numberOfTimes</code>。默认情况下，Swift 只把<code>amount</code>当作一个局部名称，但是把<code>numberOfTimes</code>即看作局部名称又看作外部名称。下面调用这个方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> counter = <span class="type">Counter</span>()</span><br><span class="line">counter.incrementBy(<span class="number">5</span>, numberOfTimes: <span class="number">3</span>)</span><br><span class="line"><span class="comment">// counter 的值现在是 15</span></span><br></pre></td></tr></table></figure>
<p>你不必为第一个参数值再定义一个外部变量名：因为从函数名<code>incrementBy(_numberOfTimes:)</code>已经能很清楚地看出它的作用。但是第二个参数，就要被一个外部参数名称所限定，以便在方法被调用时明确它的作用。</p>
<p>上面描述的这种默认行为意味着在 Swift 中，定义方法使用了与 Objective-C 同样的语法风格，并且方法将以自然且富于表达性的方式被调用。</p>
<p><a name="modifying_external_parameter_name_behavior_for_methods"></a></p>
<h3 id="修改方法的外部参数名称(Modifying_External_Parameter_Name_Behavior_for_Methods)">修改方法的外部参数名称(Modifying External Parameter Name Behavior for Methods)</h3><p>有时为方法的第一个参数提供一个外部参数名称是非常有用的，尽管这不是默认的行为。你自己可以为第一个参数添加一个显式的外部名称。</p>
<p>相反，如果你不想为方法的第二个及后续的参数提供一个外部名称，可以通过使用下划线（<code>_</code>）作为该参数的显式外部名称，这样做将覆盖默认行为。</p>
<p><a name="the_self_property"></a></p>
<h3 id="self_属性(The_self_Property)">self 属性(The self Property)</h3><p>类型的每一个实例都有一个隐含属性叫做<code>self</code>，<code>self</code>完全等同于该实例本身。你可以在一个实例的实例方法中使用这个隐含的<code>self</code>属性来引用当前实例。</p>
<p>上面例子中的<code>increment</code>方法还可以这样写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">increment</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.<span class="built_in">count</span>++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，你不必在你的代码里面经常写<code>self</code>。不论何时，只要在一个方法中使用一个已知的属性或者方法名称，如果你没有明确地写<code>self</code>，Swift 假定你是指当前实例的属性或者方法。这种假定在上面的<code>Counter</code>中已经示范了：<code>Counter</code>中的三个实例方法中都使用的是<code>count</code>（而不是<code>self.count</code>）。</p>
<p>使用这条规则的主要场景是实例方法的某个参数名称与实例的某个属性名称相同的时候。在这种情况下，参数名称享有优先权，并且在引用属性时必须使用一种更严格的方式。这时你可以使用<code>self</code>属性来区分参数名称和属性名称。</p>
<p>下面的例子中，<code>self</code>消除方法参数<code>x</code>和实例属性<code>x</code>之间的歧义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">isToTheRightOfX</span><span class="params">(x: Double)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.x &gt; x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> somePoint = <span class="type">Point</span>(x: <span class="number">4.0</span>, y: <span class="number">5.0</span>)</span><br><span class="line"><span class="keyword">if</span> somePoint.isToTheRightOfX(<span class="number">1.0</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"This point is to the right of the line where x == 1.0"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印输出: This point is to the right of the line where x == 1.0</span></span><br></pre></td></tr></table></figure>
<p>如果不使用<code>self</code>前缀，Swift 就认为两次使用的<code>x</code>都指的是名称为<code>x</code>的函数参数。</p>
<p><a name="modifying_value_types_from_within_instance_methods"></a></p>
<h3 id="在实例方法中修改值类型(Modifying_Value_Types_from_Within_Instance_Methods)">在实例方法中修改值类型(Modifying Value Types from Within Instance Methods)</h3><p>结构体和枚举是<strong>值类型</strong>。一般情况下，值类型的属性不能在它的实例方法中被修改。</p>
<p>但是，如果你确实需要在某个特定的方法中修改结构体或者枚举的属性，你可以选择<code>变异(mutating)</code>这个方法，然后方法就可以从方法内部改变它的属性；并且它做的任何改变在方法结束时还会保留在原始结构中。方法还可以给它隐含的<code>self</code>属性赋值一个全新的实例，这个新实例在方法结束后将替换原来的实例。</p>
<p>要使用<code>变异</code>方法，将关键字<code>mutating</code> 放到方法的<code>func</code>关键字之前就可以了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">moveByX</span><span class="params">(deltaX: Double, y deltaY: Double)</span></span> &#123;</span><br><span class="line">        x += deltaX</span><br><span class="line">        y += deltaY</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> somePoint = <span class="type">Point</span>(x: <span class="number">1.0</span>, y: <span class="number">1.0</span>)</span><br><span class="line">somePoint.moveByX(<span class="number">2.0</span>, y: <span class="number">3.0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The point is now at (<span class="subst">\(somePoint.x)</span>, <span class="subst">\(somePoint.y)</span>)"</span>)</span><br><span class="line"><span class="comment">// 打印输出: "The point is now at (3.0, 4.0)"</span></span><br></pre></td></tr></table></figure>
<p>上面的<code>Point</code>结构体定义了一个可变方法（mutating method）<code>moveByX(_:y:)</code>用来移动点。该方法在被调用时修改了这个点，而不是返回一个新的点。方法定义时加上了<code>mutating</code>关键字，从而可以修改属性。</p>
<p>注意，不能在结构体类型的常量上调用可变方法，因为其属性不能被改变，即使属性是变量属性，详情参见<a href="./10_Properties.html#stored_properties_of_constant_structure_instances">常量结构体的存储属性</a>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fixedPoint = <span class="type">Point</span>(x: <span class="number">3.0</span>, y: <span class="number">3.0</span>)</span><br><span class="line">fixedPoint.moveByX(<span class="number">2.0</span>, y: <span class="number">3.0</span>)</span><br><span class="line"><span class="comment">// 这里将会报告一个错误</span></span><br></pre></td></tr></table></figure>
<p><a name="assigning_to_self_within_a_mutating_method"></a></p>
<h3 id="在可变方法中给_self_赋值(Assigning_to_self_Within_a_Mutating_Method)">在可变方法中给 self 赋值(Assigning to self Within a Mutating Method)</h3><p>可变方法能够赋给隐含属性<code>self</code>一个全新的实例。上面<code>Point</code>的例子可以用下面的方式改写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">moveByX</span><span class="params">(deltaX: Double, y deltaY: Double)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span> = <span class="type">Point</span>(x: x + deltaX, y: y + deltaY)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新版的可变方法<code>moveByX(_:y:)</code>创建了一个新的结构（它的 x 和 y 的值都被设定为目标值）。调用这个版本的方法和调用上个版本的最终结果是一样的。</p>
<p>枚举的可变方法可以把<code>self</code>设置为同一枚举类型中不同的成员：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TriStateSwitch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Off</span>, <span class="type">Low</span>, <span class="type">High</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Off</span>:</span><br><span class="line">            <span class="keyword">self</span> = <span class="type">Low</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Low</span>:</span><br><span class="line">            <span class="keyword">self</span> = <span class="type">High</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">High</span>:</span><br><span class="line">            <span class="keyword">self</span> = <span class="type">Off</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ovenLight = <span class="type">TriStateSwitch</span>.<span class="type">Low</span></span><br><span class="line">ovenLight.next()</span><br><span class="line"><span class="comment">// ovenLight 现在等于 .High</span></span><br><span class="line">ovenLight.next()</span><br><span class="line"><span class="comment">// ovenLight 现在等于 .Off</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中定义了一个三态开关的枚举。每次调用<code>next()</code>方法时，开关在不同的电源状态（<code>Off</code>，<code>Low</code>，<code>High</code>）之间循环切换。</p>
<p><a name="type_methods"></a></p>
<h2 id="类型方法_(Type_Methods)">类型方法 (Type Methods)</h2><p>实例方法是被类型的某个实例调用的方法。你也可以定义类型本身调用的方法，这种方法就叫做<strong>类型方法</strong>。声明结构体和枚举的类型方法，在方法的<code>func</code>关键字之前加上关键字<code>static</code>。类可能会用关键字<code>class</code>来允许子类重写父类的方法实现。</p>
<blockquote>
<p>注意<br>在 Objective-C 中，你只能为 Objective-C 的类定义类型方法（type-level methods）。在 Swift 中，你可以为所有的类、结构体和枚举定义类型方法。每一个类型方法都被它所支持的类型显式包含。  </p>
</blockquote>
<p>类型方法和实例方法一样用点语法调用。但是，你是在类型层面上调用这个方法，而不是在实例层面上调用。下面是如何在<code>SomeClass</code>类上调用类型方法的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">someTypeMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// type method implementation goes here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">SomeClass</span>.someTypeMethod()</span><br></pre></td></tr></table></figure>
<p>在类型方法的方法体（body）中，<code>self</code>指向这个类型本身，而不是类型的某个实例。这意味着你可以用<code>self</code>来消除类型属性和类型方法参数之间的歧义（类似于我们在前面处理实例属性和实例方法参数时做的那样）。</p>
<p>一般来说，在类型方法的方法体中，任何未限定的方法和属性名称，将会指代本类中其他类型方法和类型属性。一个类型方法可以通过类型方法的名称调用本类中的类型方法，而无需在方法名称前面加上类型名称前缀。同样，也能够直接通过类型属性的名称访问本类中的类型属性，而不需要类型名称前缀。</p>
<p>下面的例子定义了一个名为<code>LevelTracker</code>结构体。它监测玩家的游戏发展情况（游戏的不同层次或阶段）。这是一个单人游戏，但也可以存储多个玩家在同一设备上的游戏信息。</p>
<p>游戏初始时，所有的游戏等级（除了等级 1）都被锁定。每次有玩家完成一个等级，这个等级就对这个设备上的所有玩家解锁。<code>LevelTracker</code>结构体用类型属性和方法监测游戏的哪个等级已经被解锁。它还监测每个玩家的当前等级。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LevelTracker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> highestUnlockedLevel = <span class="number">1</span></span><br><span class="line">    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">unlockLevel</span><span class="params">(level: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> level &gt; highestUnlockedLevel &#123; highestUnlockedLevel = level &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">levelIsUnlocked</span><span class="params">(level: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> level &lt;= highestUnlockedLevel</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> currentLevel = <span class="number">1</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">advanceToLevel</span><span class="params">(level: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="type">LevelTracker</span>.levelIsUnlocked(level) &#123;</span><br><span class="line">            currentLevel = level</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LevelTracker</code>监测玩家已解锁的最高等级。这个值被存储在类型属性<code>highestUnlockedLevel</code>中。</p>
<p><code>LevelTracker</code>还定义了两个类型方法与<code>highestUnlockedLevel</code>配合工作。第一个类型方法是<code>unlockLevel</code>，一旦新等级被解锁，它会更新<code>highestUnlockedLevel</code>的值。第二个类型方法是<code>levelIsUnlocked</code>，如果某个给定的等级已经被解锁，它将返回<code>true</code>。（注意，尽管我们没有使用类似<code>LevelTracker.highestUnlockedLevel</code>的写法，这个类型方法还是能够访问类型属性<code>highestUnlockedLevel</code>）</p>
<p>除了类型属性和类型方法，<code>LevelTracker</code>还监测每个玩家的进度。它用实例属性<code>currentLevel</code>来监测玩家当前的等级。</p>
<p>为了便于管理<code>currentLevel</code>属性，<code>LevelTracker</code>定义了实例方法<code>advanceToLevel</code>。这个方法会在更新<code>currentLevel</code>之前检查所请求的新等级是否已经解锁。<code>advanceToLevel</code>方法返回布尔值以指示是否能够设置<code>currentLevel</code>。</p>
<p>下面，<code>Player</code>类使用<code>LevelTracker</code>来监测和更新每个玩家的发展进度：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tracker = <span class="type">LevelTracker</span>()</span><br><span class="line">    <span class="keyword">let</span> playerName: <span class="type">String</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">completedLevel</span><span class="params">(level: Int)</span></span> &#123;</span><br><span class="line">        <span class="type">LevelTracker</span>.unlockLevel(level + <span class="number">1</span>)</span><br><span class="line">        tracker.advanceToLevel(level + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        playerName = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Player</code>类创建一个新的<code>LevelTracker</code>实例来监测这个用户的进度。它提供了<code>completedLevel</code>方法，一旦玩家完成某个指定等级就调用它。这个方法为所有玩家解锁下一等级，并且将当前玩家的进度更新为下一等级。（我们忽略了<code>advanceToLevel</code>返回的布尔值，因为之前调用<code>LevelTracker.unlockLevel</code>时就知道了这个等级已经被解锁了）。</p>
<p>你还可以为一个新的玩家创建一个<code>Player</code>的实例，然后看这个玩家完成等级一时发生了什么：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> player = <span class="type">Player</span>(name: <span class="string">"Argyrios"</span>)</span><br><span class="line">player.completedLevel(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"highest unlocked level is now <span class="subst">\(LevelTracker.highestUnlockedLevel)</span>"</span>)</span><br><span class="line"><span class="comment">// 打印输出：highest unlocked level is now 2</span></span><br></pre></td></tr></table></figure>
<p>如果你创建了第二个玩家，并尝试让他开始一个没有被任何玩家解锁的等级，那么试图设置玩家当前等级将会失败：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">player = <span class="type">Player</span>(name: <span class="string">"Beto"</span>)</span><br><span class="line"><span class="keyword">if</span> player.tracker.advanceToLevel(<span class="number">6</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"player is now on level 6"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"level 6 has not yet been unlocked"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印输出：level 6 has not yet been unlocked</span></span><br></pre></td></tr></table></figure>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/">&laquo;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/5/">&raquo;</a>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="https://avatars2.githubusercontent.com/u/14305708?v=3&s=460" alt="terry" itemprop="image"/>
          <p class="site-author-name" itemprop="name">terry</p>
        </div>
        <p class="site-description motion-element" itemprop="description">terry yang's blog | java | scala | bi</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">130</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">11</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-next-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yangwei8888" target="_blank">github</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/microsoftgoogles" target="_blank">weibo</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/run-zhi-38" target="_blank">zhihu</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">terry</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  

    <script type="text/javascript">
      var disqus_shortname = 'yangwei888';
      var disqus_identifier = 'page/4/index.html';
      var disqus_title = '';
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
