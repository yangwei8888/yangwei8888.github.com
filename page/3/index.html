<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="terry yang's blog | java | scala | bi" />



  <meta name="keywords" content="Hexo,next" />



  <link rel="alternate" href="/atom.xml" title="yosita" type="application/atom+xml" />



  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="terry yang&apos;s blog | java | scala | bi">
<meta property="og:type" content="website">
<meta property="og:title" content="yosita">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="yosita">
<meta property="og:description" content="terry yang&apos;s blog | java | scala | bi">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="yosita">
<meta name="twitter:description" content="terry yang&apos;s blog | java | scala | bi">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>

  <title> yosita </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  

  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?7e8961fdae021b7bf62f2c767bb18c23";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">yosita</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/09_Classes_and_Structures/" itemprop="url">
                第二章-09类和结构体（Classes and Structures）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:18+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/09_Classes_and_Structures/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/09_Classes_and_Structures/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="类和结构体（Classes_and_Structures）">类和结构体（Classes and Structures）</h1><blockquote>
<p>1.0<br>翻译：<a href="https://github.com/JaySurplus" target="_blank" rel="external">JaySurplus</a><br>校对：<a href="https://github.com/sg552" target="_blank" rel="external">sg552</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/SkyJean" target="_blank" rel="external">SkyJean</a></p>
<p>2.1<br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a>，2015-10-29</p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#comparing_classes_and_structures">类和结构体对比</a></li>
<li><a href="#structures_and_enumerations_are_value_types">结构体和枚举是值类型</a></li>
<li><a href="#classes_are_reference_types">类是引用类型</a></li>
<li><a href="#choosing_between_classes_and_structures">类和结构体的选择</a></li>
<li><a href="#assignment_and_copy_behavior_for_strings_arrays_and_dictionaries">字符串(String)、数组(Array)、和字典(Dictionary)类型的赋值与复制行为</a></li>
</ul>
<p><em>类</em>和<em>结构体</em>是人们构建代码所用的一种通用且灵活的构造体。我们可以使用完全相同的语法规则来为类和结构体定义属性（常量、变量）和添加方法，从而扩展类和结构体的功能。</p>
<p>与其他编程语言所不同的是，Swift 并不要求你为自定义类和结构去创建独立的接口和实现文件。你所要做的是在一个单一文件中定义一个类或者结构体，系统将会自动生成面向其它代码的外部接口。</p>
<blockquote>
<p>注意<br>通常一个<code>类</code>的实例被称为<code>对象</code>。然而在 Swift 中，类和结构体的关系要比在其他语言中更加的密切，本章中所讨论的大部分功能都可以用在类和结构体上。因此，我们会主要使用<code>实例</code>而不是<code>对象</code>。</p>
</blockquote>
<p><a name="comparing_classes_and_structures"></a></p>
<p>###类和结构体对比</p>
<p>Swift 中类和结构体有很多共同点。共同处在于：</p>
<ul>
<li>定义属性用于存储值</li>
<li>定义方法用于提供功能</li>
<li>定义附属脚本用于访问值</li>
<li>定义构造器用于生成初始化值</li>
<li>通过扩展以增加默认实现的功能</li>
<li>实现协议以提供某种标准功能</li>
</ul>
<p>更多信息请参见<a href="./10_Properties.html">属性</a>，<a href="./11_Methods.html">方法</a>，<a href="./12_Subscripts.html">下标脚本</a>，<a href="./14_Initialization.html">构造过程</a>，<a href="./21_Extensions.html">扩展</a>，和<a href="./22_Protocols.html">协议</a>。</p>
<p>与结构体相比，类还有如下的附加功能：</p>
<ul>
<li>继承允许一个类继承另一个类的特征</li>
<li>类型转换允许在运行时检查和解释一个类实例的类型</li>
<li>解构器允许一个类实例释放任何其所被分配的资源</li>
<li>引用计数允许对一个类的多次引用</li>
</ul>
<p>更多信息请参见<a href="./13_Inheritance.html">继承</a>，<a href="./19_Type_Casting.html">类型转换</a>，<a href="./15_Deinitialization.html">析构过程</a>，和<a href="./16_Automatic_Reference_Counting.html">自动引用计数</a>。</p>
<blockquote>
<p>注意<br>结构体总是通过被复制的方式在代码中传递，不使用引用计数。</p>
</blockquote>
<p><a name="definition_syntax"></a></p>
<h3 id="定义语法">定义语法</h3><p>类和结构体有着类似的定义方式。我们通过关键字<code>class</code>和<code>struct</code>来分别表示类和结构体，并在一对大括号中定义它们的具体内容：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">	<span class="comment">// class definition goes here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeStructure</span> </span>&#123;</span><br><span class="line">	<span class="comment">// structure definition goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>在你每次定义一个新类或者结构体的时候，实际上你是定义了一个新的 Swift 类型。因此请使用<code>UpperCamelCase</code>这种方式来命名（如<code>SomeClass</code>和<code>SomeStructure</code>等），以便符合标准 Swift 类型的大写命名风格（如<code>String</code>，<code>Int</code>和<code>Bool</code>）。相反的，请使用<code>lowerCamelCase</code>这种方式为属性和方法命名（如<code>framerate</code>和<code>incrementCount</code>），以便和类型名区分。</p>
</blockquote>
<p>以下是定义结构体和定义类的示例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Resolution</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> width = <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> height = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoMode</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> resolution = <span class="type">Resolution</span>()</span><br><span class="line">	<span class="keyword">var</span> interlaced = <span class="literal">false</span></span><br><span class="line">	<span class="keyword">var</span> frameRate = <span class="number">0.0</span></span><br><span class="line">	<span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中我们定义了一个名为<code>Resolution</code>的结构体，用来描述一个显示器的像素分辨率。这个结构体包含了两个名为<code>width</code>和<code>height</code>的存储属性。存储属性是被捆绑和存储在类或结构体中的常量或变量。当这两个属性被初始化为整数<code>0</code>的时候，它们会被推断为<code>Int</code>类型。</p>
<p>在上面的示例中我们还定义了一个名为<code>VideoMode</code>的类，用来描述一个视频显示器的特定模式。这个类包含了四个变量存储属性。第一个是<code>分辨率</code>，它被初始化为一个新的<code>Resolution</code>结构体的实例，属性类型被推断为<code>Resolution</code>。新<code>VideoMode</code>实例同时还会初始化其它三个属性，它们分别是，初始值为<code>false</code>的<code>interlaced</code>，初始值为<code>0.0</code>的<code>frameRate</code>，以及值为可选<code>String</code>的<code>name</code>。<code>name</code>属性会被自动赋予一个默认值<code>nil</code>，意为“没有<code>name</code>值”，因为它是一个可选类型。</p>
<p><a name="class_and_structure_instances"></a></p>
<h3 id="类和结构体实例">类和结构体实例</h3><p><code>Resolution</code>结构体和<code>VideoMode</code>类的定义仅描述了什么是<code>Resolution</code>和<code>VideoMode</code>。它们并没有描述一个特定的分辨率（resolution）或者视频模式（video mode）。为了描述一个特定的分辨率或者视频模式，我们需要生成一个它们的实例。</p>
<p>生成结构体和类实例的语法非常相似：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someResolution = <span class="type">Resolution</span>()</span><br><span class="line"><span class="keyword">let</span> someVideoMode = <span class="type">VideoMode</span>()</span><br></pre></td></tr></table></figure>
<p>结构体和类都使用构造器语法来生成新的实例。构造器语法的最简单形式是在结构体或者类的类型名称后跟随一对空括号，如<code>Resolution()</code>或<code>VideoMode()</code>。通过这种方式所创建的类或者结构体实例，其属性均会被初始化为默认值。<a href="./14_Initialization.html">构造过程</a>章节会对类和结构体的初始化进行更详细的讨论。</p>
<p><a name="accessing_properties"></a></p>
<h3 id="属性访问">属性访问</h3><p>通过使用<em>点语法</em>（<em>dot syntax</em>），你可以访问实例的属性。其语法规则是，实例名后面紧跟属性名，两者通过点号(<code>.</code>)连接：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"The width of someResolution is <span class="subst">\(someResolution.width)</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "The width of someResolution is 0"</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>someResolution.width</code>引用<code>someResolution</code>的<code>width</code>属性，返回<code>width</code>的初始值<code>0</code>。</p>
<p>你也可以访问子属性，如<code>VideoMode</code>中<code>Resolution</code>属性的<code>width</code>属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"The width of someVideoMode is <span class="subst">\(someVideoMode.resolution.width)</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "The width of someVideoMode is 0"</span></span><br></pre></td></tr></table></figure>
<p>你也可以使用点语法为变量属性赋值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">someVideoMode.resolution.width = <span class="number">1280</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The width of someVideoMode is now <span class="subst">\(someVideoMode.resolution.width)</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "The width of someVideoMode is now 1280"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>与 Objective-C 语言不同的是，Swift 允许直接设置结构体属性的子属性。上面的最后一个例子，就是直接设置了<code>someVideoMode</code>中<code>resolution</code>属性的<code>width</code>这个子属性，以上操作并不需要重新为整个<code>resolution</code>属性设置新值。</p>
</blockquote>
<p><a name="memberwise_initializers_for_structure_types"></a></p>
<h3 id="结构体类型的成员逐一构造器（Memberwise_Initializers_for_Structure_Types）">结构体类型的成员逐一构造器（Memberwise Initializers for Structure Types）</h3><p>所有结构体都有一个自动生成的<em>成员逐一构造器</em>，用于初始化新结构体实例中成员的属性。新实例中各个属性的初始值可以通过属性的名称传递到成员逐一构造器之中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vga = <span class="type">Resolution</span>(width:<span class="number">640</span>, height: <span class="number">480</span>)</span><br></pre></td></tr></table></figure>
<p>与结构体不同，类实例没有默认的成员逐一构造器。<a href="./14_Initialization.html">构造过程</a>章节会对构造器进行更详细的讨论。</p>
<p><a name="structures_and_enumerations_are_value_types"></a></p>
<h2 id="结构体和枚举是值类型">结构体和枚举是值类型</h2><p><em>值类型</em>被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被<em>拷贝</em>。</p>
<p>在之前的章节中，我们已经大量使用了值类型。实际上，在 Swift 中，所有的基本类型：整数（Integer）、浮点数（floating-point）、布尔值（Boolean）、字符串（string)、数组（array）和字典（dictionary），都是值类型，并且在底层都是以结构体的形式所实现。</p>
<p>在 Swift 中，所有的结构体和枚举类型都是值类型。这意味着它们的实例，以及实例中所包含的任何值类型属性，在代码中传递的时候都会被复制。</p>
<p>请看下面这个示例，其使用了前一个示例中的<code>Resolution</code>结构体：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hd = <span class="type">Resolution</span>(width: <span class="number">1920</span>, height: <span class="number">1080</span>)</span><br><span class="line"><span class="keyword">var</span> cinema = hd</span><br></pre></td></tr></table></figure>
<p>在以上示例中，声明了一个名为<code>hd</code>的常量，其值为一个初始化为全高清视频分辨率（<code>1920</code> 像素宽，<code>1080</code> 像素高）的<code>Resolution</code>实例。</p>
<p>然后示例中又声明了一个名为<code>cinema</code>的变量，并将<code>hd</code>赋值给它。因为<code>Resolution</code>是一个结构体，所以<code>cinema</code>的值其实是<code>hd</code>的一个拷贝副本，而不是<code>hd</code>本身。尽管<code>hd</code>和<code>cinema</code>有着相同的宽（width）和高（height），但是在幕后它们是两个完全不同的实例。</p>
<p>下面，为了符合数码影院放映的需求（<code>2048</code> 像素宽，<code>1080</code> 像素高），<code>cinema</code>的<code>width</code>属性需要作如下修改：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cinema.width = <span class="number">2048</span></span><br></pre></td></tr></table></figure>
<p>这里，将会显示<code>cinema</code>的<code>width</code>属性确已改为了<code>2048</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"cinema is now  <span class="subst">\(cinema.width)</span> pixels wide"</span>)</span><br><span class="line"><span class="comment">// 输出 "cinema is now 2048 pixels wide"</span></span><br></pre></td></tr></table></figure>
<p>然而，初始的<code>hd</code>实例中<code>width</code>属性还是<code>1920</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"hd is still <span class="subst">\(hd.width)</span> pixels wide"</span>)</span><br><span class="line"><span class="comment">// 输出 "hd is still 1920 pixels wide"</span></span><br></pre></td></tr></table></figure>
<p>在将<code>hd</code>赋予给<code>cinema</code>的时候，实际上是将<code>hd</code>中所存储的值进行拷贝，然后将拷贝的数据存储到新的<code>cinema</code>实例中。结果就是两个完全独立的实例碰巧包含有相同的数值。由于两者相互独立，因此将<code>cinema</code>的<code>width</code>修改为<code>2048</code>并不会影响<code>hd</code>中的<code>width</code>的值。</p>
<p>枚举也遵循相同的行为准则：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CompassPoint</span> </span>&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">North</span>, <span class="type">South</span>, <span class="type">East</span>, <span class="type">West</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> currentDirection = <span class="type">CompassPoint</span>.<span class="type">West</span></span><br><span class="line"><span class="keyword">let</span> rememberedDirection = currentDirection</span><br><span class="line">currentDirection = .<span class="type">East</span></span><br><span class="line"><span class="keyword">if</span> rememberedDirection == .<span class="type">West</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"The remembered direction is still .West"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "The remembered direction is still .West"</span></span><br></pre></td></tr></table></figure>
<p>上例中<code>rememberedDirection</code>被赋予了<code>currentDirection</code>的值，实际上它被赋予的是值的一个拷贝。赋值过程结束后再修改<code>currentDirection</code>的值并不影响<code>rememberedDirection</code>所储存的原始值的拷贝。</p>
<p><a name="classes_are_reference_types"></a></p>
<h2 id="类是引用类型">类是引用类型</h2><p>与值类型不同，引用类型在被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。因此，引用的是已存在的实例本身而不是其拷贝。</p>
<p>请看下面这个示例，其使用了之前定义的<code>VideoMode</code>类：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tenEighty = <span class="type">VideoMode</span>()</span><br><span class="line">tenEighty.resolution = hd</span><br><span class="line">tenEighty.interlaced = <span class="literal">true</span></span><br><span class="line">tenEighty.name = <span class="string">"1080i"</span></span><br><span class="line">tenEighty.frameRate = <span class="number">25.0</span></span><br></pre></td></tr></table></figure>
<p>以上示例中，声明了一个名为<code>tenEighty</code>的常量，其引用了一个<code>VideoMode</code>类的新实例。在之前的示例中，这个视频模式（video mode）被赋予了HD分辨率（<code>1920</code>*<code>1080</code>）的一个拷贝（即<code>hd</code>实例）。同时设置为<code>interlaced</code>，命名为<code>“1080i”</code>。最后，其帧率是<code>25.0</code>帧每秒。</p>
<p>然后，<code>tenEighty</code>被赋予名为<code>alsoTenEighty</code>的新常量，同时对<code>alsoTenEighty</code>的帧率进行修改：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> alsoTenEighty = tenEighty</span><br><span class="line">alsoTenEighty.frameRate = <span class="number">30.0</span></span><br></pre></td></tr></table></figure>
<p>因为类是引用类型，所以<code>tenEight</code>和<code>alsoTenEight</code>实际上引用的是相同的<code>VideoMode</code>实例。换句话说，它们是同一个实例的两种叫法。</p>
<p>下面，通过查看<code>tenEighty</code>的<code>frameRate</code>属性，我们会发现它正确的显示了所引用的<code>VideoMode</code>实例的新帧率，其值为<code>30.0</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"The frameRate property of tenEighty is now <span class="subst">\(tenEighty.frameRate)</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "The frameRate property of theEighty is now 30.0"</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是<code>tenEighty</code>和<code>alsoTenEighty</code>被声明为常量而不是变量。然而你依然可以改变<code>tenEighty.frameRate</code>和<code>alsoTenEighty.frameRate</code>，因为<code>tenEighty</code>和<code>alsoTenEighty</code>这两个常量的值并未改变。它们并不“存储”这个<code>VideoMode</code>实例，而仅仅是对<code>VideoMode</code>实例的引用。所以，改变的是被引用的<code>VideoMode</code>的<code>frameRate</code>属性，而不是引用<code>VideoMode</code>的常量的值。</p>
<p><a name="identity_operators"></a></p>
<h3 id="恒等运算符">恒等运算符</h3><p>因为类是引用类型，有可能有多个常量和变量在幕后同时引用同一个类实例。（对于结构体和枚举来说，这并不成立。因为它们作为值类型，在被赋予到常量、变量或者传递到函数时，其值总是会被拷贝。）</p>
<p>如果能够判定两个常量或者变量是否引用同一个类实例将会很有帮助。为了达到这个目的，Swift 内建了两个恒等运算符：</p>
<ul>
<li>等价于（<code>===</code>）</li>
<li>不等价于（<code>!==</code>）</li>
</ul>
<p>运用这两个运算符检测两个常量或者变量是否引用同一个实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> tenEighty === alsoTenEighty &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"tenEighty and alsoTenEighty refer to the same Resolution instance."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出 "tenEighty and alsoTenEighty refer to the same Resolution instance."</span></span><br></pre></td></tr></table></figure>
<p>请注意，“等价于”（用三个等号表示，<code>===</code>）与“等于”（用两个等号表示，<code>==</code>）的不同：</p>
<ul>
<li>“等价于”表示两个类类型（class type）的常量或者变量引用同一个类实例。</li>
<li>“等于”表示两个实例的值“相等”或“相同”，判定时要遵照设计者定义的评判标准，因此相对于“相等”来说，这是一种更加合适的叫法。</li>
</ul>
<p>当你在定义你的自定义类和结构体的时候，你有义务来决定判定两个实例“相等”的标准。在章节<a href="./25_Advanced_Operators.html#equivalence_operators">等价操作符</a>中将会详细介绍实现自定义“等于”和“不等于”运算符的流程。</p>
<p><a name="pointers"></a></p>
<h3 id="指针">指针</h3><p>如果你有 C，C++ 或者 Objective-C 语言的经验，那么你也许会知道这些语言使用<em>指针</em>来引用内存中的地址。一个引用某个引用类型实例的 Swift 常量或者变量，与 C 语言中的指针类似，但是并不直接指向某个内存地址，也不要求你使用星号（<code>*</code>）来表明你在创建一个引用。Swift 中的这些引用与其它的常量或变量的定义方式相同。</p>
<p><a name="choosing_between_classes_and_structures"></a></p>
<h2 id="类和结构体的选择">类和结构体的选择</h2><p>在你的代码中，你可以使用类和结构体来定义你的自定义数据类型。</p>
<p>然而，结构体实例总是通过值传递，类实例总是通过引用传递。这意味两者适用不同的任务。当你在考虑一个工程项目的数据结构和功能的时候，你需要决定每个数据结构是定义成类还是结构体。</p>
<p>按照通用的准则，当符合一条或多条以下条件时，请考虑构建结构体：</p>
<ul>
<li>该数据结构的主要目的是用来封装少量相关简单数据值。</li>
<li>有理由预计该数据结构的实例在被赋值或传递时，封装的数据将会被拷贝而不是被引用。</li>
<li>该数据结构中储存的值类型属性，也应该被拷贝，而不是被引用。</li>
<li>该数据结构不需要去继承另一个既有类型的属性或者行为。</li>
</ul>
<p>举例来说，以下情境中适合使用结构体：</p>
<ul>
<li>几何形状的大小，封装一个<code>width</code>属性和<code>height</code>属性，两者均为<code>Double</code>类型。</li>
<li>一定范围内的路径，封装一个<code>start</code>属性和<code>length</code>属性，两者均为<code>Int</code>类型。</li>
<li>三维坐标系内一点，封装<code>x</code>，<code>y</code>和<code>z</code>属性，三者均为<code>Double</code>类型。</li>
</ul>
<p>在所有其它案例中，定义一个类，生成一个它的实例，并通过引用来管理和传递。实际中，这意味着绝大部分的自定义数据构造都应该是类，而非结构体。</p>
<p><a name="assignment_and_copy_behavior_for_strings_arrays_and_dictionaries"></a></p>
<h2 id="字符串(String)、数组(Array)、和字典(Dictionary)类型的赋值与复制行为">字符串(String)、数组(Array)、和字典(Dictionary)类型的赋值与复制行为</h2><p>Swift 中，许多基本类型，诸如<code>String</code>，<code>Array</code>和<code>Dictionary</code>类型均以结构体的形式实现。这意味着被赋值给新的常量或变量，或者被传入函数或方法中时，它们的值会被拷贝。</p>
<p>Objective-C 中<code>NSString</code>，<code>NSArray</code>和<code>NSDictionary</code>类型均以类的形式实现，而并非结构体。它们在被赋值或者被传入函数或方法时，不会发生值拷贝，而是传递现有实例的引用。</p>
<blockquote>
<p>注意<br>以上是对字符串、数组、字典的“拷贝”行为的描述。在你的代码中，拷贝行为看起来似乎总会发生。然而，Swift 在幕后只在绝对必要时才执行实际的拷贝。Swift 管理所有的值拷贝以确保性能最优化，所以你没必要去回避赋值来保证性能最优化。</p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/10_Properties/" itemprop="url">
                第二章-10属性 (Properties)
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:17+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/10_Properties/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/10_Properties/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="属性_(Properties)">属性 (Properties)</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/shinyzhu" target="_blank" rel="external">shinyzhu</a><br>校对：<a href="https://github.com/pp-prog" target="_blank" rel="external">pp-prog</a> <a href="https://github.com/yangsiy" target="_blank" rel="external">yangsiy</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/yangsiy" target="_blank" rel="external">yangsiy</a></p>
<p>2.1<br>翻译：<a href="https://github.com/buginux" target="_blank" rel="external">buginux</a><br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a>，2015-10-29</p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#stored_properties">存储属性（Stored Properties）</a></li>
<li><a href="#computed_properties">计算属性（Computed Properties）</a></li>
<li><a href="#property_observers">属性观察器（Property Observers）</a></li>
<li><a href="#global_and_local_variables">全局变量和局部变量（Global and Local Variables）</a></li>
<li><a href="#type_properties">类型属性（Type Properties）</a></li>
</ul>
<p><em>属性</em>将值跟特定的类、结构或枚举关联。存储属性存储常量或变量作为实例的一部分，而计算属性计算（不是存储）一个值。计算属性可以用于类、结构体和枚举，存储属性只能用于类和结构体。</p>
<p>存储属性和计算属性通常与特定类型的实例关联。但是，属性也可以直接作用于类型本身，这种属性称为类型属性。</p>
<p>另外，还可以定义属性观察器来监控属性值的变化，以此来触发一个自定义的操作。属性观察器可以添加到自己定义的存储属性上，也可以添加到从父类继承的属性上。</p>
<p><a name="stored_properties"></a></p>
<h2 id="存储属性">存储属性</h2><p>简单来说，一个存储属性就是存储在特定类或结构体的实例里的一个常量或变量。存储属性可以是<em>变量存储属性</em>（用关键字<code>var</code>定义），也可以是<em>常量存储属性</em>（用关键字<code>let</code>定义）。</p>
<p>可以在定义存储属性的时候指定默认值，请参考<a href="./14_Initialization.html#default_initializers">默认构造器</a>一节。也可以在构造过程中设置或修改存储属性的值，甚至修改常量存储属性的值，请参考<a href="./14_Initialization.html#assigning_constant_properties_during_initialization">构造过程中常量属性的修改</a>一节。</p>
<p>下面的例子定义了一个名为<code>FixedLengthRange</code>的结构体，它描述了一个在创建后无法修改值域宽度的区间：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FixedLengthRange</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> firstValue: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> length: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> rangeOfThreeItems = <span class="type">FixedLengthRange</span>(firstValue: <span class="number">0</span>, length: <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 该区间表示整数0，1，2</span></span><br><span class="line">rangeOfThreeItems.firstValue = <span class="number">6</span></span><br><span class="line"><span class="comment">// 该区间现在表示整数6，7，8</span></span><br></pre></td></tr></table></figure>
<p><code>FixedLengthRange</code>的实例包含一个名为<code>firstValue</code>的变量存储属性和一个名为<code>length</code>的常量存储属性。在上面的例子中，<code>length</code>在创建实例的时候被初始化，因为它是一个常量存储属性，所以之后无法修改它的值。</p>
<p><a name="stored_properties_of_constant_structure_instances"></a></p>
<h3 id="常量结构体的存储属性">常量结构体的存储属性</h3><p>如果创建了一个结构体的实例并将其赋值给一个常量，则无法修改该实例的任何属性，即使定义了变量存储属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rangeOfFourItems = <span class="type">FixedLengthRange</span>(firstValue: <span class="number">0</span>, length: <span class="number">4</span>)</span><br><span class="line"><span class="comment">// 该区间表示整数0，1，2，3</span></span><br><span class="line">rangeOfFourItems.firstValue = <span class="number">6</span></span><br><span class="line"><span class="comment">// 尽管 firstValue 是个变量属性，这里还是会报错</span></span><br></pre></td></tr></table></figure>
<p>因为<code>rangeOfFourItems</code>被声明成了常量（用<code>let</code>关键字），即使<code>firstValue</code>是一个变量属性，也无法再修改它了。</p>
<p>这种行为是由于结构体（struct）属于<em>值类型</em>。当值类型的实例被声明为常量的时候，它的所有属性也就成了常量。</p>
<p>属于<em>引用类型</em>的类（class）则不一样。把一个引用类型的实例赋给一个常量后，仍然可以修改该实例的变量属性。</p>
<p><a name="lazy_stored_properties"></a></p>
<h3 id="延迟存储属性">延迟存储属性</h3><p>延迟存储属性是指当第一次被调用的时候才会计算其初始值的属性。在属性声明前使用<code>lazy</code>来标示一个延迟存储属性。</p>
<blockquote>
<p>注意<br>必须将延迟存储属性声明成变量（使用<code>var</code>关键字），因为属性的初始值可能在实例构造完成之后才会得到。而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性。  </p>
</blockquote>
<p>延迟属性很有用，当属性的值依赖于在实例的构造过程结束后才会知道具体值的外部因素时，或者当获得属性的初始值需要复杂或大量计算时，可以只在需要的时候计算它。</p>
<p>下面的例子使用了延迟存储属性来避免复杂类中不必要的初始化。例子中定义了<code>DataImporter</code>和<code>DataManager</code>两个类，下面是部分代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataImporter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">    DataImporter 是一个负责将外部文件中的数据导入的类。</span><br><span class="line">    这个类的初始化会消耗不少时间。</span><br><span class="line">    */</span></span><br><span class="line">    <span class="keyword">var</span> fileName = <span class="string">"data.txt"</span></span><br><span class="line">    <span class="comment">// 这里会提供数据导入功能</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataManager</span> </span>&#123;</span><br><span class="line">    lazy <span class="keyword">var</span> importer = <span class="type">DataImporter</span>()</span><br><span class="line">    <span class="keyword">var</span> data = [<span class="type">String</span>]()</span><br><span class="line">    <span class="comment">// 这里会提供数据管理功能</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> manager = <span class="type">DataManager</span>()</span><br><span class="line">manager.data.append(<span class="string">"Some data"</span>)</span><br><span class="line">manager.data.append(<span class="string">"Some more data"</span>)</span><br><span class="line"><span class="comment">// DataImporter 实例的 importer 属性还没有被创建</span></span><br></pre></td></tr></table></figure>
<p><code>DataManager</code>类包含一个名为<code>data</code>的存储属性，初始值是一个空的字符串（<code>String</code>）数组。这里没有给出全部代码，只需知道<code>DataManager</code>类的目的是管理和提供对这个字符串数组的访问即可。</p>
<p><code>DataManager</code>的一个功能是从文件导入数据。该功能由<code>DataImporter</code>类提供，<code>DataImporter</code>完成初始化需要消耗不少时间：因为它的实例在初始化时可能要打开文件，还要读取文件内容到内存。</p>
<p><code>DataManager</code>管理数据时也可能不从文件中导入数据。所以当<code>DataManager</code>的实例被创建时，没必要创建一个<code>DataImporter</code>的实例，更明智的做法是第一次用到<code>DataImporter</code>的时候才去创建它。</p>
<p>由于使用了<code>lazy</code>，<code>importer</code>属性只有在第一次被访问的时候才被创建。比如访问它的属性<code>fileName</code>时：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(manager.importer.fileName)</span><br><span class="line"><span class="comment">// DataImporter 实例的 importer 属性现在被创建了</span></span><br><span class="line"><span class="comment">// 输出 "data.txt”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>如果一个被标记为<code>lazy</code>的属性在没有初始化时就同时被多个线程访问，则无法保证该属性只会被初始化一次。</p>
</blockquote>
<p><a name="stored_properties_and_instance_variables"></a></p>
<h3 id="存储属性和实例变量">存储属性和实例变量</h3><p>如果您有过 Objective-C 经验，应该知道 Objective-C 为类实例存储值和引用提供两种方法。除了属性之外，还可以使用实例变量作为属性值的后端存储。</p>
<p>Swift 编程语言中把这些理论统一用属性来实现。Swift 中的属性没有对应的实例变量，属性的后端存储也无法直接访问。这就避免了不同场景下访问方式的困扰，同时也将属性的定义简化成一个语句。属性的全部信息——包括命名、类型和内存管理特征——都在唯一一个地方（类型定义中）定义。</p>
<p><a name="computed_properties"></a></p>
<h2 id="计算属性">计算属性</h2><p>除存储属性外，类、结构体和枚举可以定义<em>计算属性</em>。计算属性不直接存储值，而是提供一个 getter 和一个可选的 setter，来间接获取和设置其他属性或变量的值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span>, height = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> origin = <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size = <span class="type">Size</span>()</span><br><span class="line">    <span class="keyword">var</span> center: <span class="type">Point</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> centerX = origin.x + (size.width / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">let</span> centerY = origin.y + (size.height / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Point</span>(x: centerX, y: centerY)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>(newCenter) &#123;</span><br><span class="line">            origin.x = newCenter.x - (size.width / <span class="number">2</span>)</span><br><span class="line">            origin.y = newCenter.y - (size.height / <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> square = <span class="type">Rect</span>(origin: <span class="type">Point</span>(x: <span class="number">0.0</span>, y: <span class="number">0.0</span>),</span><br><span class="line">    size: <span class="type">Size</span>(width: <span class="number">10.0</span>, height: <span class="number">10.0</span>))</span><br><span class="line"><span class="keyword">let</span> initialSquareCenter = square.center</span><br><span class="line">square.center = <span class="type">Point</span>(x: <span class="number">15.0</span>, y: <span class="number">15.0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"square.origin is now at (<span class="subst">\(square.origin.x)</span>, <span class="subst">\(square.origin.y)</span>)"</span>)</span><br><span class="line"><span class="comment">// 输出 "square.origin is now at (10.0, 10.0)”</span></span><br></pre></td></tr></table></figure>
<p>这个例子定义了 3 个结构体来描述几何形状：</p>
<ul>
<li><code>Point</code>封装了一个<code>(x, y)</code>的坐标</li>
<li><code>Size</code>封装了一个<code>width</code>和一个<code>height</code></li>
<li><code>Rect</code>表示一个有原点和尺寸的矩形</li>
</ul>
<p><code>Rect</code>也提供了一个名为<code>center</code>的计算属性。一个矩形的中心点可以从原点（<code>origin</code>）和尺寸（<code>size</code>）算出，所以不需要将它以显式声明的<code>Point</code>来保存。<code>Rect</code>的计算属性<code>center</code>提供了自定义的 getter 和 setter 来获取和设置矩形的中心点，就像它有一个存储属性一样。</p>
<p>上述例子中创建了一个名为<code>square</code>的<code>Rect</code>实例，初始值原点是<code>(0, 0)</code>，宽度高度都是<code>10</code>。如下图中蓝色正方形所示。</p>
<p><code>square</code>的<code>center</code>属性可以通过点运算符（<code>square.center</code>）来访问，这会调用该属性的 getter 来获取它的值。跟直接返回已经存在的值不同，getter 实际上通过计算然后返回一个新的<code>Point</code>来表示<code>square</code>的中心点。如代码所示，它正确返回了中心点<code>(5, 5)</code>。</p>
<p><code>center</code>属性之后被设置了一个新的值<code>(15, 15)</code>，表示向右上方移动正方形到如下图橙色正方形所示的位置。设置属性<code>center</code>的值会调用它的 setter 来修改属性<code>origin</code>的<code>x</code>和<code>y</code>的值，从而实现移动正方形到新的位置。</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/computedProperties_2x.png" alt="Computed Properties sample" width="388" height="387"></p>
<p><a name="shorthand_setter_declaration"></a></p>
<h3 id="便捷_setter_声明">便捷 setter 声明</h3><p>如果计算属性的 setter 没有定义表示新值的参数名，则可以使用默认名称<code>newValue</code>。下面是使用了便捷 setter 声明的<code>Rect</code>结构体代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AlternativeRect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> origin = <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size = <span class="type">Size</span>()</span><br><span class="line">    <span class="keyword">var</span> center: <span class="type">Point</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> centerX = origin.x + (size.width / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">let</span> centerY = origin.y + (size.height / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Point</span>(x: centerX, y: centerY)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            origin.x = newValue.x - (size.width / <span class="number">2</span>)</span><br><span class="line">            origin.y = newValue.y - (size.height / <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="readonly_computed_properties"></a></p>
<h3 id="只读计算属性">只读计算属性</h3><p>只有 getter 没有 setter 的计算属性就是<em>只读计算属性</em>。只读计算属性总是返回一个值，可以通过点运算符访问，但不能设置新的值。</p>
<blockquote>
<p>注意<br>必须使用<code>var</code>关键字定义计算属性，包括只读计算属性，因为它们的值不是固定的。<code>let</code>关键字只用来声明常量属性，表示初始化后再也无法修改的值。</p>
</blockquote>
<p>只读计算属性的声明可以去掉<code>get</code>关键字和花括号：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cuboid</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span>, height = <span class="number">0.0</span>, depth = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> volume: <span class="type">Double</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> width * height * depth</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fourByFiveByTwo = <span class="type">Cuboid</span>(width: <span class="number">4.0</span>, height: <span class="number">5.0</span>, depth: <span class="number">2.0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"the volume of fourByFiveByTwo is <span class="subst">\(fourByFiveByTwo.volume)</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "the volume of fourByFiveByTwo is 40.0"</span></span><br></pre></td></tr></table></figure>
<p>这个例子定义了一个名为<code>Cuboid</code>的结构体，表示三维空间的立方体，包含<code>width</code>、<code>height</code>和<code>depth</code>属性。结构体还有一个名为<code>volume</code>的只读计算属性用来返回立方体的体积。为<code>volume</code>提供 setter 毫无意义，因为无法确定如何修改<code>width</code>、<code>height</code>和<code>depth</code>三者的值来匹配新的<code>volume</code>。然而，<code>Cuboid</code>提供一个只读计算属性来让外部用户直接获取体积是很有用的。</p>
<p><a name="property_observers"></a></p>
<h2 id="属性观察器">属性观察器</h2><p><em>属性观察器</em>监控和响应属性值的变化，每次属性被设置值的时候都会调用属性观察器，甚至新值和当前值相同的时候也不例外。</p>
<p>可以为除了延迟存储属性之外的其他存储属性添加属性观察器，也可以通过重写属性的方式为继承的属性（包括存储属性和计算属性）添加属性观察器。属性重写请参考<a href="./13_Inheritance.html#overriding">重写</a>。</p>
<blockquote>
<p>注意<br>不需要为非重写的计算属性添加属性观察器，因为可以通过它的 setter 直接监控和响应值的变化。  </p>
</blockquote>
<p>可以为属性添加如下的一个或全部观察器：</p>
<ul>
<li><code>willSet</code>在新的值被设置之前调用</li>
<li><code>didSet</code>在新的值被设置之后立即调用</li>
</ul>
<p><code>willSet</code>观察器会将新的属性值作为常量参数传入，在<code>willSet</code>的实现代码中可以为这个参数指定一个名称，如果不指定则参数仍然可用，这时使用默认名称<code>newValue</code>表示。</p>
<p>类似地，<code>didSet</code>观察器会将旧的属性值作为参数传入，可以为该参数命名或者使用默认参数名<code>oldValue</code>。</p>
<blockquote>
<p>注意<br>父类的属性在子类的构造器中被赋值时，它在父类中的<code>willSet</code>和<code>didSet</code>观察器会被调用。<br>有关构造器代理的更多信息，请参考<a href="./14_Initialization.html#initializer_delegation_for_value_types">值类型的构造器代理</a>和<a href="./14_Initialization.html#initializer_delegation_for_class_types">类的构造器代理规则</a>。</p>
</blockquote>
<p>这里是一个<code>willSet</code>和<code>didSet</code>的实际例子，其中定义了一个名为<code>StepCounter</code>的类，用来统计一个人步行时的总步数。这个类可以跟计步器或其他日常锻炼的统计装置的输入数据配合使用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StepCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> totalSteps: <span class="type">Int</span> = <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span>(newTotalSteps) &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"About to set totalSteps to <span class="subst">\(newTotalSteps)</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> totalSteps &gt; oldValue  &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Added <span class="subst">\(totalSteps - oldValue)</span> steps"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> stepCounter = <span class="type">StepCounter</span>()</span><br><span class="line">stepCounter.totalSteps = <span class="number">200</span></span><br><span class="line"><span class="comment">// About to set totalSteps to 200</span></span><br><span class="line"><span class="comment">// Added 200 steps</span></span><br><span class="line">stepCounter.totalSteps = <span class="number">360</span></span><br><span class="line"><span class="comment">// About to set totalSteps to 360</span></span><br><span class="line"><span class="comment">// Added 160 steps</span></span><br><span class="line">stepCounter.totalSteps = <span class="number">896</span></span><br><span class="line"><span class="comment">// About to set totalSteps to 896</span></span><br><span class="line"><span class="comment">// Added 536 steps</span></span><br></pre></td></tr></table></figure>
<p><code>StepCounter</code>类定义了一个<code>Int</code>类型的属性<code>totalSteps</code>，它是一个存储属性，包含<code>willSet</code>和<code>didSet</code>观察器。</p>
<p>当<code>totalSteps</code>被设置新值的时候，它的<code>willSet</code>和<code>didSet</code>观察器都会被调用，甚至新值和当前值完全相同时也会被调用。</p>
<p>例子中的<code>willSet</code>观察器将表示新值的参数自定义为<code>newTotalSteps</code>，这个观察器只是简单的将新的值输出。</p>
<p><code>didSet</code>观察器在<code>totalSteps</code>的值改变后被调用，它把新值和旧值进行对比，如果总步数增加了，就输出一个消息表示增加了多少步。<code>didSet</code>没有为旧值提供自定义名称，所以默认值<code>oldValue</code>表示旧值的参数名。</p>
<blockquote>
<p>注意<br>如果在一个属性的<code>didSet</code>观察器里为它赋值，这个值会替换之前设置的值。  </p>
</blockquote>
<p><a name="global_and_local_variables"></a></p>
<p>##全局变量和局部变量</p>
<p>计算属性和属性观察器所描述的功能也可以用于<em>全局变量</em>和<em>局部变量</em>。全局变量是在函数、方法、闭包或任何类型之外定义的变量。局部变量是在函数、方法或闭包内部定义的变量。</p>
<p>前面章节提到的全局或局部变量都属于存储型变量，跟存储属性类似，它为特定类型的值提供存储空间，并允许读取和写入。</p>
<p>另外，在全局或局部范围都可以定义计算型变量和为存储型变量定义观察器。计算型变量跟计算属性一样，返回一个计算结果而不是存储值，声明格式也完全一样。</p>
<blockquote>
<p>注意<br>全局的常量或变量都是延迟计算的，跟<a href="#lazy_stored_properties">延迟存储属性</a>相似，不同的地方在于，全局的常量或变量不需要标记<code>lazy</code>修饰符。<br>局部范围的常量或变量从不延迟计算。  </p>
</blockquote>
<p><a name="type_properties"></a></p>
<p>##类型属性</p>
<p>实例属性属于一个特定类型的实例，每创建一个实例，实例都拥有属于自己的一套属性值，实例之间的属性相互独立。</p>
<p>也可以为类型本身定义属性，无论创建了多少个该类型的实例，这些属性都只有唯一一份。这种属性就是<em>类型属性</em>。</p>
<p>类型属性用于定义某个类型所有实例共享的数据，比如所有实例都能用的一个常量（就像 C 语言中的静态常量），或者所有实例都能访问的一个变量（就像 C 语言中的静态变量）。</p>
<p>存储型类型属性可以是变量或常量，计算型类型属性跟实例的计算型属性一样只能定义成变量属性。</p>
<blockquote>
<p>注意<br>跟实例的存储型属性不同，必须给存储型类型属性指定默认值，因为类型本身没有构造器，也就无法在初始化过程中使用构造器给类型属性赋值。<br>存储型类型属性是延迟初始化的，它们只有在第一次被访问的时候才会被初始化。即使它们被多个线程同时访问，系统也保证只会对其进行一次初始化，并且不需要对其使用<code>lazy</code>修饰符。</p>
</blockquote>
<p><a name="type_property_syntax"></a></p>
<p>###类型属性语法</p>
<p>在 C 或 Objective-C 中，与某个类型关联的静态常量和静态变量，是作为全局（<em>global</em>）静态变量定义的。但是在 Swift 中，类型属性是作为类型定义的一部分写在类型最外层的花括号内，因此它的作用范围也就在类型支持的范围内。</p>
<p>使用关键字<code>static</code>来定义类型属性。在为类定义计算型类型属性时，可以改用关键字<code>class</code>来支持子类对父类的实现进行重写。下面的例子演示了存储型和计算型类型属性的语法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeStructure</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty = <span class="string">"Some value."</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SomeEnumeration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty = <span class="string">"Some value."</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty = <span class="string">"Some value."</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">27</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">overrideableComputedTypeProperty</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">107</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>例子中的计算型类型属性是只读的，但也可以定义可读可写的计算型类型属性，跟计算型实例属性的语法相同。  </p>
</blockquote>
<p><a name="querying_and_setting_type_properties"></a></p>
<p>###获取和设置类型属性的值</p>
<p>跟实例属性一样，类型属性也是通过点运算符来访问。但是，类型属性是通过类型本身来访问，而不是通过实例。比如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="type">SomeStructure</span>.storedTypeProperty)</span><br><span class="line"><span class="comment">// 输出 "Some value."</span></span><br><span class="line"><span class="type">SomeStructure</span>.storedTypeProperty = <span class="string">"Another value."</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">SomeStructure</span>.storedTypeProperty)</span><br><span class="line"><span class="comment">// 输出 "Another value.”</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">SomeEnumeration</span>.computedTypeProperty)</span><br><span class="line"><span class="comment">// 输出 "6"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">SomeClass</span>.computedTypeProperty)</span><br><span class="line"><span class="comment">// 输出 "27"</span></span><br></pre></td></tr></table></figure>
<p>下面的例子定义了一个结构体，使用两个存储型类型属性来表示两个声道的音量，每个声道具有<code>0</code>到<code>10</code>之间的整数音量。</p>
<p>下图展示了如何把两个声道结合来模拟立体声的音量。当声道的音量是<code>0</code>，没有一个灯会亮；当声道的音量是<code>10</code>，所有灯点亮。本图中，左声道的音量是<code>9</code>，右声道的音量是<code>7</code>：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/staticPropertiesVUMeter_2x.png" alt="Static Properties VUMeter" width="243" height="357"></p>
<p>上面所描述的声道模型使用<code>AudioChannel</code>结构体的实例来表示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AudioChannel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> thresholdLevel = <span class="number">10</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> maxInputLevelForAllChannels = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> currentLevel: <span class="type">Int</span> = <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> currentLevel &gt; <span class="type">AudioChannel</span>.thresholdLevel &#123;</span><br><span class="line">                <span class="comment">// 将当前音量限制在阀值之内</span></span><br><span class="line">                currentLevel = <span class="type">AudioChannel</span>.thresholdLevel</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> currentLevel &gt; <span class="type">AudioChannel</span>.maxInputLevelForAllChannels &#123;</span><br><span class="line">                <span class="comment">// 存储当前音量作为新的最大输入音量</span></span><br><span class="line">                <span class="type">AudioChannel</span>.maxInputLevelForAllChannels = currentLevel</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构<code>AudioChannel</code>定义了 2 个存储型类型属性来实现上述功能。第一个是<code>thresholdLevel</code>，表示音量的最大上限阈值，它是一个值为<code>10</code>的常量，对所有实例都可见，如果音量高于<code>10</code>，则取最大上限值<code>10</code>（见后面描述）。</p>
<p>第二个类型属性是变量存储型属性<code>maxInputLevelForAllChannels</code>，它用来表示所有<code>AudioChannel</code>实例的最大音量，初始值是<code>0</code>。</p>
<p><code>AudioChannel</code>也定义了一个名为<code>currentLevel</code>的存储型实例属性，表示当前声道现在的音量，取值为<code>0</code>到<code>10</code>。</p>
<p>属性<code>currentLevel</code>包含<code>didSet</code>属性观察器来检查每次设置后的属性值，它做如下两个检查：</p>
<ul>
<li>如果<code>currentLevel</code>的新值大于允许的阈值<code>thresholdLevel</code>，属性观察器将<code>currentLevel</code>的值限定为阈值<code>thresholdLevel</code>。</li>
<li>如果修正后的<code>currentLevel</code>值大于静态类型属性<code>maxInputLevelForAllChannels</code>的值，属性观察器就将新值保存在<code>maxInputLevelForAllChannels</code>中。</li>
</ul>
<blockquote>
<p>注意<br>在第一个检查过程中，<code>didSet</code>属性观察器将<code>currentLevel</code>设置成了不同的值，但这不会造成属性观察器被再次调用。  </p>
</blockquote>
<p>可以使用结构体<code>AudioChannel</code>创建两个声道<code>leftChannel</code>和<code>rightChannel</code>，用以表示立体声系统的音量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> leftChannel = <span class="type">AudioChannel</span>()</span><br><span class="line"><span class="keyword">var</span> rightChannel = <span class="type">AudioChannel</span>()</span><br></pre></td></tr></table></figure>
<p>如果将左声道的<code>currentLevel</code>设置成<code>7</code>，类型属性<code>maxInputLevelForAllChannels</code>也会更新成<code>7</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">leftChannel.currentLevel = <span class="number">7</span></span><br><span class="line"><span class="built_in">print</span>(leftChannel.currentLevel)</span><br><span class="line"><span class="comment">// 输出 "7"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">AudioChannel</span>.maxInputLevelForAllChannels)</span><br><span class="line"><span class="comment">// 输出 "7"</span></span><br></pre></td></tr></table></figure>
<p>如果试图将右声道的<code>currentLevel</code>设置成<code>11</code>，它会被修正到最大值<code>10</code>，同时<code>maxInputLevelForAllChannels</code>的值也会更新到<code>10</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rightChannel.currentLevel = <span class="number">11</span></span><br><span class="line"><span class="built_in">print</span>(rightChannel.currentLevel)</span><br><span class="line"><span class="comment">// 输出 "10"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">AudioChannel</span>.maxInputLevelForAllChannels)</span><br><span class="line"><span class="comment">// 输出 "10"</span></span><br></pre></td></tr></table></figure>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/11_Methods/" itemprop="url">
                第二章-11方法（Methods）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:16+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/11_Methods/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/11_Methods/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="方法（Methods）">方法（Methods）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/pp-prog" target="_blank" rel="external">pp-prog</a><br>校对：<a href="https://github.com/zqp" target="_blank" rel="external">zqp</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/DianQK" target="_blank" rel="external">DianQK</a></p>
<p>2.1<br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a>，2015-10-29</p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#instance_methods">实例方法(Instance Methods)</a></li>
<li><a href="#type_methods">类型方法(Type Methods)</a></li>
</ul>
<p><strong>方法</strong>是与某些特定类型相关联的函数。类、结构体、枚举都可以定义实例方法；实例方法为给定类型的实例封装了具体的任务与功能。类、结构体、枚举也可以定义类型方法；类型方法与类型本身相关联。类型方法与 Objective-C 中的类方法（class methods）相似。</p>
<p>结构体和枚举能够定义方法是 Swift 与 C/Objective-C 的主要区别之一。在 Objective-C 中，类是唯一能定义方法的类型。但在 Swift 中，你不仅能选择是否要定义一个类/结构体/枚举，还能灵活地在你创建的类型（类/结构体/枚举）上定义方法。</p>
<p><a name="instance_methods"></a></p>
<h2 id="实例方法_(Instance_Methods)">实例方法 (Instance Methods)</h2><p><strong>实例方法</strong>是属于某个特定类、结构体或者枚举类型实例的方法。实例方法提供访问和修改实例属性的方法或提供与实例目的相关的功能，并以此来支撑实例的功能。实例方法的语法与函数完全一致，详情参见<a href="./06_Functions.md">函数</a>。</p>
<p>实例方法要写在它所属的类型的前后大括号之间。实例方法能够隐式访问它所属类型的所有的其他实例方法和属性。实例方法只能被它所属的类的某个特定实例调用。实例方法不能脱离于现存的实例而被调用。</p>
<p>下面的例子，定义一个很简单的<code>Counter</code>类，<code>Counter</code>能被用来对一个动作发生的次数进行计数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">increment</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ++<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">incrementBy</span><span class="params">(amount: Int)</span></span> &#123;</span><br><span class="line">        <span class="built_in">count</span> += amount</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">reset</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Counter</code>类定义了三个实例方法：</p>
<ul>
<li><code>increment</code>让计数器按一递增；</li>
<li><code>incrementBy(amount: Int)</code>让计数器按一个指定的整数值递增；</li>
<li><code>reset</code>将计数器重置为0。</li>
</ul>
<p><code>Counter</code>这个类还声明了一个可变属性<code>count</code>，用它来保持对当前计数器值的追踪。</p>
<p>和调用属性一样，用点语法（dot syntax）调用实例方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> counter = <span class="type">Counter</span>()</span><br><span class="line"><span class="comment">// 初始计数值是0</span></span><br><span class="line">counter.increment()</span><br><span class="line"><span class="comment">// 计数值现在是1</span></span><br><span class="line">counter.incrementBy(<span class="number">5</span>)</span><br><span class="line"><span class="comment">// 计数值现在是6</span></span><br><span class="line">counter.reset()</span><br><span class="line"><span class="comment">// 计数值现在是0</span></span><br></pre></td></tr></table></figure>
<p><a name="local_and_external_parameter"></a></p>
<h3 id="方法的局部参数名称和外部参数名称_(Local_and_External_Parameter_Names_for_Methods)">方法的局部参数名称和外部参数名称 (Local and External Parameter Names for Methods)</h3><p>函数参数可以同时有一个局部名称（在函数体内部使用）和一个外部名称（在调用函数时使用），详情参见<a href="./06_Functions.html#specifying_external_parameter_names">指定外部参数名</a>。方法参数也一样（因为方法就是函数，只是这个函数与某个类型相关联了）。</p>
<p>Swift 中的方法和 Objective-C 中的方法极其相似。像在 Objective-C 中一样，Swift 中方法的名称通常用一个介词指向方法的第一个参数，比如：<code>with</code>，<code>for</code>，<code>by</code>等等。前面的<code>Counter</code>类的例子中<code>incrementBy(_:)</code>方法就是这样的。介词的使用让方法在被调用时能像一个句子一样被解读。</p>
<p>具体来说，Swift 默认仅给方法的第一个参数名称一个局部参数名称；默认同时给第二个和后续的参数名称局部参数名称和外部参数名称。这个约定与典型的命名和调用约定相适应，与你在写 Objective-C 的方法时很相似。这个约定还让富于表达性的方法在调用时不需要再限定参数名称。</p>
<p>看看下面这个<code>Counter</code>的另一个版本（它定义了一个更复杂的<code>incrementBy(_:)</code>方法）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">incrementBy</span><span class="params">(amount: Int, numberOfTimes: Int)</span></span> &#123;</span><br><span class="line">        <span class="built_in">count</span> += amount * numberOfTimes</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>incrementBy(_:numverOfTimes:)</code>方法有两个参数： <code>amount</code>和<code>numberOfTimes</code>。默认情况下，Swift 只把<code>amount</code>当作一个局部名称，但是把<code>numberOfTimes</code>即看作局部名称又看作外部名称。下面调用这个方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> counter = <span class="type">Counter</span>()</span><br><span class="line">counter.incrementBy(<span class="number">5</span>, numberOfTimes: <span class="number">3</span>)</span><br><span class="line"><span class="comment">// counter 的值现在是 15</span></span><br></pre></td></tr></table></figure>
<p>你不必为第一个参数值再定义一个外部变量名：因为从函数名<code>incrementBy(_numberOfTimes:)</code>已经能很清楚地看出它的作用。但是第二个参数，就要被一个外部参数名称所限定，以便在方法被调用时明确它的作用。</p>
<p>上面描述的这种默认行为意味着在 Swift 中，定义方法使用了与 Objective-C 同样的语法风格，并且方法将以自然且富于表达性的方式被调用。</p>
<p><a name="modifying_external_parameter_name_behavior_for_methods"></a></p>
<h3 id="修改方法的外部参数名称(Modifying_External_Parameter_Name_Behavior_for_Methods)">修改方法的外部参数名称(Modifying External Parameter Name Behavior for Methods)</h3><p>有时为方法的第一个参数提供一个外部参数名称是非常有用的，尽管这不是默认的行为。你自己可以为第一个参数添加一个显式的外部名称。</p>
<p>相反，如果你不想为方法的第二个及后续的参数提供一个外部名称，可以通过使用下划线（<code>_</code>）作为该参数的显式外部名称，这样做将覆盖默认行为。</p>
<p><a name="the_self_property"></a></p>
<h3 id="self_属性(The_self_Property)">self 属性(The self Property)</h3><p>类型的每一个实例都有一个隐含属性叫做<code>self</code>，<code>self</code>完全等同于该实例本身。你可以在一个实例的实例方法中使用这个隐含的<code>self</code>属性来引用当前实例。</p>
<p>上面例子中的<code>increment</code>方法还可以这样写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">increment</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.<span class="built_in">count</span>++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，你不必在你的代码里面经常写<code>self</code>。不论何时，只要在一个方法中使用一个已知的属性或者方法名称，如果你没有明确地写<code>self</code>，Swift 假定你是指当前实例的属性或者方法。这种假定在上面的<code>Counter</code>中已经示范了：<code>Counter</code>中的三个实例方法中都使用的是<code>count</code>（而不是<code>self.count</code>）。</p>
<p>使用这条规则的主要场景是实例方法的某个参数名称与实例的某个属性名称相同的时候。在这种情况下，参数名称享有优先权，并且在引用属性时必须使用一种更严格的方式。这时你可以使用<code>self</code>属性来区分参数名称和属性名称。</p>
<p>下面的例子中，<code>self</code>消除方法参数<code>x</code>和实例属性<code>x</code>之间的歧义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">isToTheRightOfX</span><span class="params">(x: Double)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.x &gt; x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> somePoint = <span class="type">Point</span>(x: <span class="number">4.0</span>, y: <span class="number">5.0</span>)</span><br><span class="line"><span class="keyword">if</span> somePoint.isToTheRightOfX(<span class="number">1.0</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"This point is to the right of the line where x == 1.0"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印输出: This point is to the right of the line where x == 1.0</span></span><br></pre></td></tr></table></figure>
<p>如果不使用<code>self</code>前缀，Swift 就认为两次使用的<code>x</code>都指的是名称为<code>x</code>的函数参数。</p>
<p><a name="modifying_value_types_from_within_instance_methods"></a></p>
<h3 id="在实例方法中修改值类型(Modifying_Value_Types_from_Within_Instance_Methods)">在实例方法中修改值类型(Modifying Value Types from Within Instance Methods)</h3><p>结构体和枚举是<strong>值类型</strong>。一般情况下，值类型的属性不能在它的实例方法中被修改。</p>
<p>但是，如果你确实需要在某个特定的方法中修改结构体或者枚举的属性，你可以选择<code>变异(mutating)</code>这个方法，然后方法就可以从方法内部改变它的属性；并且它做的任何改变在方法结束时还会保留在原始结构中。方法还可以给它隐含的<code>self</code>属性赋值一个全新的实例，这个新实例在方法结束后将替换原来的实例。</p>
<p>要使用<code>变异</code>方法，将关键字<code>mutating</code> 放到方法的<code>func</code>关键字之前就可以了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">moveByX</span><span class="params">(deltaX: Double, y deltaY: Double)</span></span> &#123;</span><br><span class="line">        x += deltaX</span><br><span class="line">        y += deltaY</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> somePoint = <span class="type">Point</span>(x: <span class="number">1.0</span>, y: <span class="number">1.0</span>)</span><br><span class="line">somePoint.moveByX(<span class="number">2.0</span>, y: <span class="number">3.0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The point is now at (<span class="subst">\(somePoint.x)</span>, <span class="subst">\(somePoint.y)</span>)"</span>)</span><br><span class="line"><span class="comment">// 打印输出: "The point is now at (3.0, 4.0)"</span></span><br></pre></td></tr></table></figure>
<p>上面的<code>Point</code>结构体定义了一个可变方法（mutating method）<code>moveByX(_:y:)</code>用来移动点。该方法在被调用时修改了这个点，而不是返回一个新的点。方法定义时加上了<code>mutating</code>关键字，从而可以修改属性。</p>
<p>注意，不能在结构体类型的常量上调用可变方法，因为其属性不能被改变，即使属性是变量属性，详情参见<a href="./10_Properties.html#stored_properties_of_constant_structure_instances">常量结构体的存储属性</a>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fixedPoint = <span class="type">Point</span>(x: <span class="number">3.0</span>, y: <span class="number">3.0</span>)</span><br><span class="line">fixedPoint.moveByX(<span class="number">2.0</span>, y: <span class="number">3.0</span>)</span><br><span class="line"><span class="comment">// 这里将会报告一个错误</span></span><br></pre></td></tr></table></figure>
<p><a name="assigning_to_self_within_a_mutating_method"></a></p>
<h3 id="在可变方法中给_self_赋值(Assigning_to_self_Within_a_Mutating_Method)">在可变方法中给 self 赋值(Assigning to self Within a Mutating Method)</h3><p>可变方法能够赋给隐含属性<code>self</code>一个全新的实例。上面<code>Point</code>的例子可以用下面的方式改写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">moveByX</span><span class="params">(deltaX: Double, y deltaY: Double)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span> = <span class="type">Point</span>(x: x + deltaX, y: y + deltaY)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新版的可变方法<code>moveByX(_:y:)</code>创建了一个新的结构（它的 x 和 y 的值都被设定为目标值）。调用这个版本的方法和调用上个版本的最终结果是一样的。</p>
<p>枚举的可变方法可以把<code>self</code>设置为同一枚举类型中不同的成员：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TriStateSwitch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Off</span>, <span class="type">Low</span>, <span class="type">High</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Off</span>:</span><br><span class="line">            <span class="keyword">self</span> = <span class="type">Low</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Low</span>:</span><br><span class="line">            <span class="keyword">self</span> = <span class="type">High</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">High</span>:</span><br><span class="line">            <span class="keyword">self</span> = <span class="type">Off</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ovenLight = <span class="type">TriStateSwitch</span>.<span class="type">Low</span></span><br><span class="line">ovenLight.next()</span><br><span class="line"><span class="comment">// ovenLight 现在等于 .High</span></span><br><span class="line">ovenLight.next()</span><br><span class="line"><span class="comment">// ovenLight 现在等于 .Off</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中定义了一个三态开关的枚举。每次调用<code>next()</code>方法时，开关在不同的电源状态（<code>Off</code>，<code>Low</code>，<code>High</code>）之间循环切换。</p>
<p><a name="type_methods"></a></p>
<h2 id="类型方法_(Type_Methods)">类型方法 (Type Methods)</h2><p>实例方法是被类型的某个实例调用的方法。你也可以定义类型本身调用的方法，这种方法就叫做<strong>类型方法</strong>。声明结构体和枚举的类型方法，在方法的<code>func</code>关键字之前加上关键字<code>static</code>。类可能会用关键字<code>class</code>来允许子类重写父类的方法实现。</p>
<blockquote>
<p>注意<br>在 Objective-C 中，你只能为 Objective-C 的类定义类型方法（type-level methods）。在 Swift 中，你可以为所有的类、结构体和枚举定义类型方法。每一个类型方法都被它所支持的类型显式包含。  </p>
</blockquote>
<p>类型方法和实例方法一样用点语法调用。但是，你是在类型层面上调用这个方法，而不是在实例层面上调用。下面是如何在<code>SomeClass</code>类上调用类型方法的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">someTypeMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// type method implementation goes here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">SomeClass</span>.someTypeMethod()</span><br></pre></td></tr></table></figure>
<p>在类型方法的方法体（body）中，<code>self</code>指向这个类型本身，而不是类型的某个实例。这意味着你可以用<code>self</code>来消除类型属性和类型方法参数之间的歧义（类似于我们在前面处理实例属性和实例方法参数时做的那样）。</p>
<p>一般来说，在类型方法的方法体中，任何未限定的方法和属性名称，将会指代本类中其他类型方法和类型属性。一个类型方法可以通过类型方法的名称调用本类中的类型方法，而无需在方法名称前面加上类型名称前缀。同样，也能够直接通过类型属性的名称访问本类中的类型属性，而不需要类型名称前缀。</p>
<p>下面的例子定义了一个名为<code>LevelTracker</code>结构体。它监测玩家的游戏发展情况（游戏的不同层次或阶段）。这是一个单人游戏，但也可以存储多个玩家在同一设备上的游戏信息。</p>
<p>游戏初始时，所有的游戏等级（除了等级 1）都被锁定。每次有玩家完成一个等级，这个等级就对这个设备上的所有玩家解锁。<code>LevelTracker</code>结构体用类型属性和方法监测游戏的哪个等级已经被解锁。它还监测每个玩家的当前等级。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LevelTracker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> highestUnlockedLevel = <span class="number">1</span></span><br><span class="line">    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">unlockLevel</span><span class="params">(level: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> level &gt; highestUnlockedLevel &#123; highestUnlockedLevel = level &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">levelIsUnlocked</span><span class="params">(level: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> level &lt;= highestUnlockedLevel</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> currentLevel = <span class="number">1</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">advanceToLevel</span><span class="params">(level: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="type">LevelTracker</span>.levelIsUnlocked(level) &#123;</span><br><span class="line">            currentLevel = level</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LevelTracker</code>监测玩家已解锁的最高等级。这个值被存储在类型属性<code>highestUnlockedLevel</code>中。</p>
<p><code>LevelTracker</code>还定义了两个类型方法与<code>highestUnlockedLevel</code>配合工作。第一个类型方法是<code>unlockLevel</code>，一旦新等级被解锁，它会更新<code>highestUnlockedLevel</code>的值。第二个类型方法是<code>levelIsUnlocked</code>，如果某个给定的等级已经被解锁，它将返回<code>true</code>。（注意，尽管我们没有使用类似<code>LevelTracker.highestUnlockedLevel</code>的写法，这个类型方法还是能够访问类型属性<code>highestUnlockedLevel</code>）</p>
<p>除了类型属性和类型方法，<code>LevelTracker</code>还监测每个玩家的进度。它用实例属性<code>currentLevel</code>来监测玩家当前的等级。</p>
<p>为了便于管理<code>currentLevel</code>属性，<code>LevelTracker</code>定义了实例方法<code>advanceToLevel</code>。这个方法会在更新<code>currentLevel</code>之前检查所请求的新等级是否已经解锁。<code>advanceToLevel</code>方法返回布尔值以指示是否能够设置<code>currentLevel</code>。</p>
<p>下面，<code>Player</code>类使用<code>LevelTracker</code>来监测和更新每个玩家的发展进度：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tracker = <span class="type">LevelTracker</span>()</span><br><span class="line">    <span class="keyword">let</span> playerName: <span class="type">String</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">completedLevel</span><span class="params">(level: Int)</span></span> &#123;</span><br><span class="line">        <span class="type">LevelTracker</span>.unlockLevel(level + <span class="number">1</span>)</span><br><span class="line">        tracker.advanceToLevel(level + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        playerName = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Player</code>类创建一个新的<code>LevelTracker</code>实例来监测这个用户的进度。它提供了<code>completedLevel</code>方法，一旦玩家完成某个指定等级就调用它。这个方法为所有玩家解锁下一等级，并且将当前玩家的进度更新为下一等级。（我们忽略了<code>advanceToLevel</code>返回的布尔值，因为之前调用<code>LevelTracker.unlockLevel</code>时就知道了这个等级已经被解锁了）。</p>
<p>你还可以为一个新的玩家创建一个<code>Player</code>的实例，然后看这个玩家完成等级一时发生了什么：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> player = <span class="type">Player</span>(name: <span class="string">"Argyrios"</span>)</span><br><span class="line">player.completedLevel(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"highest unlocked level is now <span class="subst">\(LevelTracker.highestUnlockedLevel)</span>"</span>)</span><br><span class="line"><span class="comment">// 打印输出：highest unlocked level is now 2</span></span><br></pre></td></tr></table></figure>
<p>如果你创建了第二个玩家，并尝试让他开始一个没有被任何玩家解锁的等级，那么试图设置玩家当前等级将会失败：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">player = <span class="type">Player</span>(name: <span class="string">"Beto"</span>)</span><br><span class="line"><span class="keyword">if</span> player.tracker.advanceToLevel(<span class="number">6</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"player is now on level 6"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"level 6 has not yet been unlocked"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印输出：level 6 has not yet been unlocked</span></span><br></pre></td></tr></table></figure>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/12_Subscripts/" itemprop="url">
                第二章-12下标脚本（Subscripts）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:15+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/12_Subscripts/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/12_Subscripts/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="下标脚本（Subscripts）">下标脚本（Subscripts）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/siemenliu" target="_blank" rel="external">siemenliu</a><br>校对：<a href="https://github.com/zq54zquan" target="_blank" rel="external">zq54zquan</a></p>
<p>2.0,2.1<br>翻译+校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a>，2015-10-29</p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#subscript_syntax">下标脚本语法</a></li>
<li><a href="#subscript_usage">下标脚本用法</a></li>
<li><a href="#subscript_options">下标脚本选项</a></li>
</ul>
<p><em>下标脚本</em> 可以定义在类（Class）、结构体（structure）和枚举（enumeration）中，是访问集合（collection），列表（list）或序列（sequence）中元素的快捷方式。可以使用下标脚本的索引设置和获取值，不需要再调用对应的存取方法。举例来说，用下标脚本访问一个<code>Array</code>实例中的元素可以写作<code>someArray[index]</code>，访问<code>Dictionary</code>实例中的元素可以写作<code>someDictionary[key]</code>。</p>
<p>一个类型可以定义多个下标脚本，通过不同索引类型进行重载。下标脚本不限于一维，你可以定义具有多个入参的下标脚本满足自定义类型的需求。</p>
<p><a name="subscript_syntax"></a></p>
<h2 id="下标脚本语法">下标脚本语法</h2><p>下标脚本允许你通过在实例名称后面的方括号中传入一个或者多个索引值来对实例进行存取。语法类似于实例方法语法和计算型属性语法的混合。与定义实例方法类似，定义下标脚本使用<code>subscript</code>关键字，指定一个或多个入参和返回类型。与实例方法不同的是，下标脚本可以设定为读写或只读。这种行为由 getter 和 setter 实现，有点类似计算型属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">subscript</span>(index: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">      <span class="comment">// 返回一个适当的 Int 类型的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span>(newValue) &#123;</span><br><span class="line">      <span class="comment">// 执行适当的赋值操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>newValue</code>的类型和下标脚本的返回类型相同。如同计算型属性，可以不指定 setter 的参数（<code>newValue</code>）。如果不指定参数，setter 会提供一个名为<code>newValue</code>的默认参数。</p>
<p>如同只读计算型属性，可以省略只读下标脚本的<code>get</code>关键字：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">subscript</span>(index: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="comment">// 返回一个适当的 Int 类型的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面代码演示了只读下标脚本的实现，这里定义了一个<code>TimesTable</code>结构体，用来表示传入整数的乘法表：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TimesTable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> multiplier: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">subscript</span>(index: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> multiplier * index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> threeTimesTable = <span class="type">TimesTable</span>(multiplier: <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"six times three is <span class="subst">\(threeTimesTable[<span class="number">6</span>])</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "six times three is 18"</span></span><br></pre></td></tr></table></figure>
<p>在上例中，创建了一个<code>TimesTable</code>实例，用来表示整数<code>3</code>的乘法表。数值<code>3</code>被传递给结构体的构造函数，作为实例成员<code>multiplier</code>的值。</p>
<p>你可以通过下标脚本访问<code>threeTimesTable</code>实例，例如上面演示的<code>threeTimesTable[6]</code>。这条语句查询了<code>3</code>的乘法表中的第六个元素，返回<code>3</code>的<code>6</code>倍即<code>18</code>。</p>
<blockquote>
<p>注意<br><code>TimesTable</code>例子基于一个固定的数学公式，对<code>threeTimesTable[someIndex]</code>进行赋值操作并不合适，因此下标脚本定义为只读的。  </p>
</blockquote>
<p><a name="subscript_usage"></a></p>
<h2 id="下标脚本用法">下标脚本用法</h2><p>下标脚本的确切含义取决于使用场景。下标脚本通常作为访问集合（collection），列表（list）或序列（sequence）中元素的快捷方式。你可以针对自己特定的类或结构体的功能来自由地以最恰当的方式实现下标脚本。</p>
<p>例如，Swift 的<code>Dictionary</code>类型实现下标脚本用于对其实例中储存的值进行存取操作。为字典设值时，在下标脚本中使用和字典的键类型相同的键，并把一个和字典的值类型相同的值赋给这个下标脚本：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numberOfLegs = [<span class="string">"spider"</span>: <span class="number">8</span>, <span class="string">"ant"</span>: <span class="number">6</span>, <span class="string">"cat"</span>: <span class="number">4</span>]</span><br><span class="line">numberOfLegs[<span class="string">"bird"</span>] = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>上例定义一个名为<code>numberOfLegs</code>的变量，并用一个包含三对键值的字典字面量初始化它。<code>numberOfLegs</code>字典的类型被推断为<code>[String: Int]</code>。字典创建完成后，该例子通过下标脚本将<code>String</code>类型的键<code>bird</code>和<code>Int</code>类型的值<code>2</code>添加到字典中。</p>
<p>更多关于<code>Dictionary</code>下标脚本的信息请参考<a href="./04_Collection_Types.html#accessing_and_modifying_a_dictionary">读取和修改字典</a></p>
<blockquote>
<p>注意<br>Swift 的<code>Dictionary</code>类型的下标脚本接受并返回可选类型的值。上例中的<code>numberOfLegs</code>字典通过下标脚本返回的是一个<code>Int?</code>或者说“可选的int”。<code>Dictionary</code>类型之所以如此实现下标脚本，是因为不是每个键都有个对应的值，同时这也提供了一种通过键删除对应值的方式，只需将键对应的值赋值为<code>nil</code>即可。  </p>
</blockquote>
<p><a name="subscript_options"></a></p>
<h2 id="下标脚本选项">下标脚本选项</h2><p>下标脚本可以接受任意数量的入参，并且这些入参可以是任意类型。下标脚本的返回值也可以是任意类型。下标脚本可以使用变量参数和可变参数，但不能使用输入输出参数，也不能给参数设置默认值。</p>
<p>一个类或结构体可以根据自身需要提供多个下标脚本实现，使用下标脚本时将通过入参的数量和类型进行区分，自动匹配合适的下标脚本，这就是<em>下标脚本的重载</em>。</p>
<p>虽然接受单一入参的下标脚本是最常见的，但也可以根据情况定义接受多个入参的下标脚本。例如下例定义了一个<code>Matrix</code>结构体，用于表示一个<code>Double</code>类型的二维矩阵。<code>Matrix</code>结构体的下标脚本接受两个整型参数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> rows: <span class="type">Int</span>, columns: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> grid: [<span class="type">Double</span>]</span><br><span class="line">    <span class="keyword">init</span>(rows: <span class="type">Int</span>, columns: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.rows = rows</span><br><span class="line">        <span class="keyword">self</span>.columns = columns</span><br><span class="line">        grid = <span class="type">Array</span>(<span class="built_in">count</span>: rows * columns, repeatedValue: <span class="number">0.0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">indexIsValidForRow</span><span class="params">(row: Int, column: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> row &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; column &gt;= <span class="number">0</span> &amp;&amp; column &lt; columns</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(row: <span class="type">Int</span>, column: <span class="type">Int</span>) -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="built_in">assert</span>(indexIsValidForRow(row, column: column), <span class="string">"Index out of range"</span>)</span><br><span class="line">            <span class="keyword">return</span> grid[(row * columns) + column]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="built_in">assert</span>(indexIsValidForRow(row, column: column), <span class="string">"Index out of range"</span>)</span><br><span class="line">            grid[(row * columns) + column] = newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Matrix</code>提供了一个接受两个入参的构造方法，入参分别是<code>rows</code>和<code>columns</code>，创建了一个足够容纳<code>rows * columns</code>个<code>Double</code>类型的值的数组。通过传入数组长度和初始值<code>0.0</code>到数组的构造器，将矩阵中每个位置的值初始化为<code>0.0</code>。关于数组的这种构造方法请参考<a href="./04_Collection_Types.html#creating_an_empty_array">创建一个空数组</a>。</p>
<p>你可以通过传入合适的<code>row</code>和<code>column</code>的数量来构造一个新的<code>Matrix</code>实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> matrix = <span class="type">Matrix</span>(rows: <span class="number">2</span>, columns: <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>上例中创建了一个<code>Matrix</code>实例来表示两行两列的矩阵。该<code>Matrix</code>实例的<code>grid</code>数组按照从左上到右下的阅读顺序将矩阵扁平化存储：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/subscriptMatrix01_2x.png" alt=""></p>
<p>将<code>row</code>和<code>column</code>的值传入下标脚本来为矩阵设值，下标脚本的入参使用逗号分隔：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">matrix[<span class="number">0</span>, <span class="number">1</span>] = <span class="number">1.5</span></span><br><span class="line">matrix[<span class="number">1</span>, <span class="number">0</span>] = <span class="number">3.2</span></span><br></pre></td></tr></table></figure>
<p>上面两条语句分别调用下标脚本的 setter 将矩阵右上角位置（即<code>row</code>为<code>0</code>、<code>column</code>为<code>1</code>的位置）的值设置为<code>1.5</code>，将矩阵左下角位置（即<code>row</code>为<code>1</code>、<code>column</code>为<code>0</code>的位置）的值设置为<code>3.2</code>：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/subscriptMatrix02_2x.png" alt=""></p>
<p><code>Matrix</code>下标脚本的 getter 和 setter 中都含有断言，用来检查下标脚本入参<code>row</code>和<code>column</code>的值是否有效。为了方便进行断言，<code>Matrix</code>包含了一个名为<code>indexIsValidForRow(_:column:)</code>的便利方法，用来检查入参<code>row</code>和<code>column</code>的值是否在矩阵范围内：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">indexIsValidForRow</span><span class="params">(row: Int, column: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> row &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; column &gt;= <span class="number">0</span> &amp;&amp; column &lt; columns</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>断言在下标脚本越界时触发：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue = matrix[<span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line"><span class="comment">// 断言将会触发，因为 [2, 2] 已经超过了 matrix 的范围</span></span><br></pre></td></tr></table></figure>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/13_Inheritance/" itemprop="url">
                第二章-13继承（Inheritance）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:14+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/13_Inheritance/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/13_Inheritance/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="继承（Inheritance）">继承（Inheritance）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/Hawstein" target="_blank" rel="external">Hawstein</a><br>校对：<a href="https://github.com/menlongsheng" target="_blank" rel="external">menlongsheng</a></p>
<p>2.0，2.1<br>翻译+校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#defining_a_base_class">定义一个基类（Base class）</a></li>
<li><a href="#subclassing">子类生成（Subclassing）</a></li>
<li><a href="#overriding">重写（Overriding）</a></li>
<li><a href="#preventing_overrides">防止重写（Preventing Overrides）</a></li>
</ul>
<p>一个类可以<em>继承（inherit）</em>另一个类的方法（methods），属性（properties）和其它特性。当一个类继承其它类时，继承类叫<em>子类（subclass）</em>，被继承类叫<em>超类（或父类，superclass）</em>。在 Swift 中，继承是区分「类」与其它类型的一个基本特征。</p>
<p>在 Swift 中，类可以调用和访问超类的方法，属性和下标脚本（subscripts），并且可以重写（override）这些方法，属性和下标脚本来优化或修改它们的行为。Swift 会检查你的重写定义在超类中是否有匹配的定义，以此确保你的重写行为是正确的。</p>
<p>可以为类中继承来的属性添加属性观察器（property observers），这样一来，当属性值改变时，类就会被通知到。可以为任何属性添加属性观察器，无论它原本被定义为存储型属性（stored property）还是计算型属性（computed property）。</p>
<p><a name="defining_a_base_class"></a></p>
<h2 id="定义一个基类（Base_class）">定义一个基类（Base class）</h2><p>不继承于其它类的类，称之为<em>基类（base calss）</em>。</p>
<blockquote>
<p>注意<br>Swift 中的类并不是从一个通用的基类继承而来。如果你不为你定义的类指定一个超类的话，这个类就自动成为基类。</p>
</blockquote>
<p>下面的例子定义了一个叫<code>Vehicle</code>的基类。这个基类声明了一个名为<code>currentSpeed</code>，默认值是<code>0.0</code>的存储属性（属性类型推断为<code>Double</code>）。<code>currentSpeed</code>属性的值被一个<code>String</code>类型的只读计算型属性<code>description</code>使用，用来创建车辆的描述。</p>
<p><code>Vehicle</code>基类也定义了一个名为<code>makeNoise</code>的方法。这个方法实际上不为<code>Vehicle</code>实例做任何事，但之后将会被<code>Vehicle</code>的子类定制：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> currentSpeed = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"traveling at <span class="subst">\(currentSpeed)</span> miles per hour"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">makeNoise</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 什么也不做-因为车辆不一定会有噪音</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以用初始化语法创建一个<code>Vehicle</code>的新实例，即类名后面跟一个空括号：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someVehicle = <span class="type">Vehicle</span>()</span><br></pre></td></tr></table></figure>
<p>现在已经创建了一个<code>Vehicle</code>的新实例，你可以访问它的<code>description</code>属性来打印车辆的当前速度：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Vehicle: <span class="subst">\(someVehicle.description)</span>"</span>)</span><br><span class="line"><span class="comment">// Vehicle: traveling at 0.0 miles per hour</span></span><br></pre></td></tr></table></figure>
<p><code>Vehicle</code>类定义了一个通用特性的车辆类，实际上没什么用处。为了让它变得更加有用，需要完善它从而能够描述一个更加具体类型的车辆。</p>
<p><a name="subclassing"></a></p>
<h2 id="子类生成（Subclassing）">子类生成（Subclassing）</h2><p><em>子类生成（Subclassing）</em>指的是在一个已有类的基础上创建一个新的类。子类继承超类的特性，并且可以进一步完善。你还可以为子类添加新的特性。</p>
<p>为了指明某个类的超类，将超类名写在子类名的后面，用冒号分隔：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>: <span class="title">SomeSuperclass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里是子类的定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一个例子，定义一个叫<code>Bicycle</code>的子类，继承成父类<code>Vehicle</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bicycle</span>: <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hasBasket = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新的<code>Bicycle</code>类自动获得<code>Vehicle</code>类的所有特性，比如<code>currentSpeed</code>和<code>description</code>属性，还有它的<code>makeNoise()</code>方法。</p>
<p>除了它所继承的特性，<code>Bicycle</code>类还定义了一个默认值为<code>false</code>的存储型属性<code>hasBasket</code>（属性推断为<code>Bool</code>）。</p>
<p>默认情况下，你创建任何新的<code>Bicycle</code>实例将不会有一个篮子（即<code>hasBasket</code>属性默认为<code>false</code>），创建该实例之后，你可以为特定的<code>Bicycle</code>实例设置<code>hasBasket</code>属性为<code>ture</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bicycle = <span class="type">Bicycle</span>()</span><br><span class="line">bicycle.hasBasket = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>你还可以修改<code>Bicycle</code>实例所继承的<code>currentSpeed</code>属性，和查询实例所继承的<code>description</code>属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bicycle.currentSpeed = <span class="number">15.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Bicycle: <span class="subst">\(bicycle.description)</span>"</span>)</span><br><span class="line"><span class="comment">// Bicycle: traveling at 15.0 miles per hour</span></span><br></pre></td></tr></table></figure>
<p>子类还可以继续被其它类继承，下面的示例为<code>Bicycle</code>创建了一个名为<code>Tandem</code>（双人自行车）的子类：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tandem</span>: <span class="title">Bicycle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> currentNumberOfPassengers = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Tandem</code>从<code>Bicycle</code>继承了所有的属性与方法，这又使它同时继承了<code>Vehicle</code>的所有属性与方法。<code>Tandem</code>也增加了一个新的叫做<code>currentNumberOfPassengers</code>的存储型属性，默认值为<code>0</code>。</p>
<p>如果你创建了一个<code>Tandem</code>的实例，你可以使用它所有的新属性和继承的属性，还能查询从<code>Vehicle</code>继承来的只读属性<code>description</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tandem = <span class="type">Tandem</span>()</span><br><span class="line">tandem.hasBasket = <span class="literal">true</span></span><br><span class="line">tandem.currentNumberOfPassengers = <span class="number">2</span></span><br><span class="line">tandem.currentSpeed = <span class="number">22.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Tandem: <span class="subst">\(tandem.description)</span>"</span>)</span><br><span class="line"><span class="comment">// Tandem: traveling at 22.0 miles per hour</span></span><br></pre></td></tr></table></figure>
<p><a name="overriding"></a></p>
<h2 id="重写（Overriding）">重写（Overriding）</h2><p>子类可以为继承来的实例方法（instance method），类方法（class method），实例属性（instance property），或下标脚本（subscript）提供自己定制的实现（implementation）。我们把这种行为叫<em>重写（overriding）</em>。</p>
<p>如果要重写某个特性，你需要在重写定义的前面加上<code>override</code>关键字。这么做，你就表明了你是想提供一个重写版本，而非错误地提供了一个相同的定义。意外的重写行为可能会导致不可预知的错误，任何缺少<code>override</code>关键字的重写都会在编译时被诊断为错误。</p>
<p><code>override</code>关键字会提醒 Swift 编译器去检查该类的超类（或其中一个父类）是否有匹配重写版本的声明。这个检查可以确保你的重写定义是正确的。</p>
<h3 id="访问超类的方法，属性及下标脚本">访问超类的方法，属性及下标脚本</h3><p>当你在子类中重写超类的方法，属性或下标脚本时，有时在你的重写版本中使用已经存在的超类实现会大有裨益。比如，你可以完善已有实现的行为，或在一个继承来的变量中存储一个修改过的值。</p>
<p>在合适的地方，你可以通过使用<code>super</code>前缀来访问超类版本的方法，属性或下标脚本：</p>
<ul>
<li>在方法<code>someMethod()</code>的重写实现中，可以通过<code>super.someMethod()</code>来调用超类版本的<code>someMethod()</code>方法。</li>
<li>在属性<code>someProperty</code>的 getter 或 setter 的重写实现中，可以通过<code>super.someProperty</code>来访问超类版本的<code>someProperty</code>属性。</li>
<li>在下标脚本的重写实现中，可以通过<code>super[someIndex]</code>来访问超类版本中的相同下标脚本。</li>
</ul>
<h3 id="重写方法">重写方法</h3><p>在子类中，你可以重写继承来的实例方法或类方法，提供一个定制或替代的方法实现。</p>
<p>下面的例子定义了<code>Vehicle</code>的一个新的子类，叫<code>Train</code>，它重写了从<code>Vehicle</code>类继承来的<code>makeNoise()</code>方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Train</span>: <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">makeNoise</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Choo Choo"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你创建一个<code>Train</code>的新实例，并调用了它的<code>makeNoise()</code>方法，你就会发现<code>Train</code>版本的方法被调用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> train = <span class="type">Train</span>()</span><br><span class="line">train.makeNoise()</span><br><span class="line"><span class="comment">// 打印 "Choo Choo"</span></span><br></pre></td></tr></table></figure>
<h3 id="重写属性">重写属性</h3><p>你可以重写继承来的实例属性或类型属性，提供自己定制的 getter 和 setter，或添加属性观察器使重写的属性可以观察属性值什么时候发生改变。</p>
<h4 id="重写属性的_Getters_和_Setters">重写属性的 Getters 和 Setters</h4><p>你可以提供定制的 getter（或 setter）来重写任意继承来的属性，无论继承来的属性是存储型的还是计算型的属性。子类并不知道继承来的属性是存储型的还是计算型的，它只知道继承来的属性会有一个名字和类型。你在重写一个属性时，必需将它的名字和类型都写出来。这样才能使编译器去检查你重写的属性是与超类中同名同类型的属性相匹配的。</p>
<p>你可以将一个继承来的只读属性重写为一个读写属性，只需要在重写版本的属性里提供 getter 和 setter 即可。但是，你不可以将一个继承来的读写属性重写为一个只读属性。</p>
<blockquote>
<p>注意<br>如果你在重写属性中提供了 setter，那么你也一定要提供 getter。如果你不想在重写版本中的 getter 里修改继承来的属性值，你可以直接通过<code>super.someProperty</code>来返回继承来的值，其中<code>someProperty</code>是你要重写的属性的名字。</p>
</blockquote>
<p>以下的例子定义了一个新类，叫<code>Car</code>，它是<code>Vehicle</code>的子类。这个类引入了一个新的存储型属性叫做<code>gear</code>，默认值为整数<code>1</code>。<code>Car</code>类重写了继承自<code>Vehicle</code>的<code>description</code>属性，提供包含当前档位的自定义描述：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>: <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> gear = <span class="number">1</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.description + <span class="string">" in gear <span class="subst">\(gear)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重写的<code>description</code>属性首先要调用<code>super.description</code>返回<code>Vehicle</code>类的<code>description</code>属性。之后，<code>Car</code>类版本的<code>description</code>在末尾增加了一些额外的文本来提供关于当前档位的信息。</p>
<p>如果你创建了<code>Car</code>的实例并且设置了它的<code>gear</code>和<code>currentSpeed</code>属性，你可以看到它的<code>description</code>返回了<code>Car</code>中的自定义描述：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> car = <span class="type">Car</span>()</span><br><span class="line">car.currentSpeed = <span class="number">25.0</span></span><br><span class="line">car.gear = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Car: <span class="subst">\(car.description)</span>"</span>)</span><br><span class="line"><span class="comment">// Car: traveling at 25.0 miles per hour in gear 3</span></span><br></pre></td></tr></table></figure>
<h4 id="重写属性观察器（Property_Observer）">重写属性观察器（Property Observer）</h4><p>你可以通过重写属性为一个继承来的属性添加属性观察器。这样一来，当继承来的属性值发生改变时，你就会被通知到，无论那个属性原本是如何实现的。关于属性观察器的更多内容，请看<a href="../chapter2/10_Properties.html#property_observers">属性观察器</a>。</p>
<blockquote>
<p>注意<br>你不可以为继承来的常量存储型属性或继承来的只读计算型属性添加属性观察器。这些属性的值是不可以被设置的，所以，为它们提供<code>willSet</code>或<code>didSet</code>实现是不恰当。<br>此外还要注意，你不可以同时提供重写的 setter 和重写的属性观察器。如果你想观察属性值的变化，并且你已经为那个属性提供了定制的 setter，那么你在 setter 中就可以观察到任何值变化了。</p>
</blockquote>
<p>下面的例子定义了一个新类叫<code>AutomaticCar</code>，它是<code>Car</code>的子类。<code>AutomaticCar</code>表示自动挡汽车，它可以根据当前的速度自动选择合适的挡位:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutomaticCar</span>: <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> currentSpeed: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            gear = <span class="type">Int</span>(currentSpeed / <span class="number">10.0</span>) + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你设置<code>AutomaticCar</code>的<code>currentSpeed</code>属性，属性的<code>didSet</code>观察器就会自动地设置<code>gear</code>属性，为新的速度选择一个合适的挡位。具体来说就是，属性观察器将新的速度值除以<code>10</code>，然后向下取得最接近的整数值，最后加<code>1</code>来得到档位<code>gear</code>的值。例如，速度为<code>35.0</code>时，挡位为<code>4</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> automatic = <span class="type">AutomaticCar</span>()</span><br><span class="line">automatic.currentSpeed = <span class="number">35.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"AutomaticCar: <span class="subst">\(automatic.description)</span>"</span>)</span><br><span class="line"><span class="comment">// AutomaticCar: traveling at 35.0 miles per hour in gear 4</span></span><br></pre></td></tr></table></figure>
<p><a name="preventing_overrides"></a></p>
<h2 id="防止重写">防止重写</h2><p>你可以通过把方法，属性或下标脚本标记为<em><code>final</code></em>来防止它们被重写，只需要在声明关键字前加上<code>final</code>修饰符即可（例如：<code>final var</code>，<code>final func</code>，<code>final class func</code>，以及<code>final subscript</code>）。</p>
<p>如果你重写了<code>final</code>方法，属性或下标脚本，在编译时会报错。在类扩展中的方法，属性或下标脚本也可以在扩展的定义里标记为 final 的。</p>
<p>你可以通过在关键字<code>class</code>前添加<code>final</code>修饰符（<code>final class</code>）来将整个类标记为 final 的。这样的类是不可被继承的，试图继承这样的类会导致编译报错。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/14_Initialization/" itemprop="url">
                第二章-14构造过程（Initialization）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:13+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/14_Initialization/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/14_Initialization/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="构造过程（Initialization）">构造过程（Initialization）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/lifedim" target="_blank" rel="external">lifedim</a><br>校对：<a href="https://github.com/lifedim" target="_blank" rel="external">lifedim</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/chenmingbiao" target="_blank" rel="external">chenmingbiao</a></p>
<p>2.1<br>翻译：<a href="https://github.com/Channe" target="_blank" rel="external">Channe</a><br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a>，2015-10-30</p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#setting_initial_values_for_stored_properties">存储属性的初始赋值</a></li>
<li><a href="#customizing_initialization">自定义构造过程</a></li>
<li><a href="#default_initializers">默认构造器</a></li>
<li><a href="#initializer_delegation_for_value_types">值类型的构造器代理</a></li>
<li><a href="#class_inheritance_and_initialization">类的继承和构造过程</a></li>
<li><a href="#failable_initializers">可失败构造器</a></li>
<li><a href="#required_initializers">必要构造器</a></li>
<li><a href="#setting_a_default_property_value_with_a_closure_or_function">通过闭包或函数设置属性的默认值</a></li>
</ul>
<p>构造过程是使用类、结构体或枚举类型的实例之前的准备过程。在新实例可用前必须执行这个过程，具体操作包括设置实例中每个存储型属性的初始值和执行其他必须的设置或初始化工作。</p>
<p>通过定义构造器（<code>Initializers</code>）来实现构造过程，这些构造器可以看做是用来创建特定类型新实例的特殊方法。与 Objective-C 中的构造器不同，Swift 的构造器无需返回值，它们的主要任务是保证新实例在第一次使用前完成正确的初始化。</p>
<p>类的实例也可以通过定义析构器（<code>deinitializer</code>）在实例释放之前执行特定的清除工作。想了解更多关于析构器的内容，请参考<a href="./15_Deinitialization.html">析构过程</a>。</p>
<p><a name="setting_initial_values_for_stored_properties"></a></p>
<h2 id="存储属性的初始赋值">存储属性的初始赋值</h2><p>类和结构体在创建实例时，必须为所有存储型属性设置合适的初始值。存储型属性的值不能处于一个未知的状态。</p>
<p>你可以在构造器中为存储型属性赋初值，也可以在定义属性时为其设置默认值。以下小节将详细介绍这两种方法。</p>
<blockquote>
<p>注意<br>当你为存储型属性设置默认值或者在构造器中为其赋值时，它们的值是被直接设置的，不会触发任何属性观察者（<code>property observers</code>）。</p>
</blockquote>
<p><a name="initializers"></a></p>
<h3 id="构造器">构造器</h3><p>构造器在创建某个特定类型的新实例时被调用。它的最简形式类似于一个不带任何参数的实例方法，以关键字<code>init</code>命名：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>() &#123;</span><br><span class="line">    <span class="comment">// 在此处执行构造过程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面例子中定义了一个用来保存华氏温度的结构体<code>Fahrenheit</code>，它拥有一个<code>Double</code>类型的存储型属性<code>temperature</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fahrenheit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temperature: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        temperature = <span class="number">32.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="type">Fahrenheit</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The default temperature is <span class="subst">\(f.temperature)</span>° Fahrenheit"</span>)</span><br><span class="line"><span class="comment">// 输出 "The default temperature is 32.0° Fahrenheit”</span></span><br></pre></td></tr></table></figure>
<p>这个结构体定义了一个不带参数的构造器<code>init</code>，并在里面将存储型属性<code>temperature</code>的值初始化为<code>32.0</code>（华氏温度下水的冰点）。</p>
<p><a name="default_property_values"></a></p>
<h3 id="默认属性值">默认属性值</h3><p>如前所述，你可以在构造器中为存储型属性设置初始值。同样，你也可以在属性声明时为其设置默认值。</p>
<blockquote>
<p>注意<br>如果一个属性总是使用相同的初始值，那么为其设置一个默认值比每次都在构造器中赋值要好。两种方法的效果是一样的，只不过使用默认值让属性的初始化和声明结合得更紧密。使用默认值能让你的构造器更简洁、更清晰，且能通过默认值自动推导出属性的类型；同时，它也能让你充分利用默认构造器、构造器继承等特性（后续章节将讲到）。</p>
</blockquote>
<p>你可以使用更简单的方式在定义结构体<code>Fahrenheit</code>时为属性<code>temperature</code>设置默认值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fahrenheit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temperature = <span class="number">32.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="customizing_initialization"></a></p>
<h2 id="自定义构造过程">自定义构造过程</h2><p>你可以通过输入参数和可选类型的属性来自定义构造过程，也可以在构造过程中修改常量属性。这些都将在后面章节中提到。</p>
<p><a name="initialization_parameters"></a></p>
<h3 id="构造参数">构造参数</h3><p>自定义<code>构造过程</code>时，可以在定义中提供构造参数，指定所需值的类型和名字。构造参数的功能和语法跟函数和方法的参数相同。</p>
<p>下面例子中定义了一个包含摄氏度温度的结构体<code>Celsius</code>。它定义了两个不同的构造器：<code>init(fromFahrenheit:)</code>和<code>init(fromKelvin:)</code>，二者分别通过接受不同温标下的温度值来创建新的实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Celsius</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temperatureInCelsius: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">init</span>(fromFahrenheit fahrenheit: <span class="type">Double</span>) &#123;</span><br><span class="line">        temperatureInCelsius = (fahrenheit - <span class="number">32.0</span>) / <span class="number">1.8</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(fromKelvin kelvin: <span class="type">Double</span>) &#123;</span><br><span class="line">        temperatureInCelsius = kelvin - <span class="number">273.15</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> boilingPointOfWater = <span class="type">Celsius</span>(fromFahrenheit: <span class="number">212.0</span>)</span><br><span class="line"><span class="comment">// boilingPointOfWater.temperatureInCelsius 是 100.0</span></span><br><span class="line"><span class="keyword">let</span> freezingPointOfWater = <span class="type">Celsius</span>(fromKelvin: <span class="number">273.15</span>)</span><br><span class="line"><span class="comment">// freezingPointOfWater.temperatureInCelsius 是 0.0”</span></span><br></pre></td></tr></table></figure>
<p>第一个构造器拥有一个构造参数，其外部名字为<code>fromFahrenheit</code>，内部名字为<code>fahrenheit</code>；第二个构造器也拥有一个构造参数，其外部名字为<code>fromKelvin</code>，内部名字为<code>kelvin</code>。这两个构造器都将唯一的参数值转换成摄氏温度值，并保存在属性<code>temperatureInCelsius</code>中。</p>
<p><a name="local_and_external_parameter_names"></a></p>
<h3 id="参数的内部名称和外部名称">参数的内部名称和外部名称</h3><p>跟函数和方法参数相同，构造参数也拥有一个在构造器内部使用的参数名字和一个在调用构造器时使用的外部参数名字。</p>
<p>然而，构造器并不像函数和方法那样在括号前有一个可辨别的名字。因此在调用构造器时，主要通过构造器中的参数名和类型来确定应该被调用的构造器。正因为参数如此重要，如果你在定义构造器时没有提供参数的外部名字，Swift 会为每个构造器的参数自动生成一个跟内部名字相同的外部名。</p>
<p>以下例子中定义了一个结构体<code>Color</code>，它包含了三个常量：<code>red</code>、<code>green</code>和<code>blue</code>。这些属性可以存储<code>0.0</code>到<code>1.0</code>之间的值，用来指示颜色中红、绿、蓝成分的含量。</p>
<p><code>Color</code>提供了一个构造器，其中包含三个<code>Double</code>类型的构造参数。<code>Color</code>也可以提供第二个构造器，它只包含名为<code>white</code>的<code>Double</code>类型的参数，它被用于给上述三个构造参数赋予同样的值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> red, green, blue: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">init</span>(red: <span class="type">Double</span>, green: <span class="type">Double</span>, blue: <span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.red   = red</span><br><span class="line">        <span class="keyword">self</span>.green = green</span><br><span class="line">        <span class="keyword">self</span>.blue  = blue</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(white: <span class="type">Double</span>) &#123;</span><br><span class="line">        red   = white</span><br><span class="line">        green = white</span><br><span class="line">        blue  = white</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种构造器都能用于创建一个新的<code>Color</code>实例，你需要为构造器每个外部参数传值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> magenta = <span class="type">Color</span>(red: <span class="number">1.0</span>, green: <span class="number">0.0</span>, blue: <span class="number">1.0</span>)</span><br><span class="line"><span class="keyword">let</span> halfGray = <span class="type">Color</span>(white: <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<p>注意，如果不通过外部参数名字传值，你是没法调用这个构造器的。只要构造器定义了某个外部参数名，你就必须使用它，忽略它将导致编译错误：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> veryGreen = <span class="type">Color</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>)</span><br><span class="line"><span class="comment">// 报编译时错误，需要外部名称</span></span><br></pre></td></tr></table></figure>
<p><a name="initializer_parameters_without_external_names"></a></p>
<h3 id="不带外部名的构造器参数">不带外部名的构造器参数</h3><p>如果你不希望为构造器的某个参数提供外部名字，你可以使用下划线(<code>_</code>)来显式描述它的外部名，以此重写上面所说的默认行为。</p>
<p>下面是之前<code>Celsius</code>例子的扩展，跟之前相比添加了一个带有<code>Double</code>类型参数的构造器，其外部名用<code>_</code>代替：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Celsius</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temperatureInCelsius: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">init</span>(fromFahrenheit fahrenheit: <span class="type">Double</span>) &#123;</span><br><span class="line">        temperatureInCelsius = (fahrenheit - <span class="number">32.0</span>) / <span class="number">1.8</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(fromKelvin kelvin: <span class="type">Double</span>) &#123;</span><br><span class="line">        temperatureInCelsius = kelvin - <span class="number">273.15</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> celsius: <span class="type">Double</span>)&#123;</span><br><span class="line">        temperatureInCelsius = celsius</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bodyTemperature = <span class="type">Celsius</span>(<span class="number">37.0</span>)</span><br><span class="line"><span class="comment">// bodyTemperature.temperatureInCelsius 为 37.0</span></span><br></pre></td></tr></table></figure>
<p>调用<code>Celsius(37.0)</code>意图明确，不需要外部参数名称。因此适合使用<code>init(_ celsius: Double)</code>这样的构造器，从而可以通过提供<code>Double</code>类型的参数值调用构造器，而不需要加上外部名。</p>
<p><a name="optional_property_types"></a></p>
<h3 id="可选属性类型">可选属性类型</h3><p>如果你定制的类型包含一个逻辑上允许取值为空的存储型属性——无论是因为它无法在初始化时赋值，还是因为它在之后某个时间点可以赋值为空——你都需要将它定义为可选类型<code>optional type</code>。可选类型的属性将自动初始化为<code>nil</code>，表示这个属性是有意在初始化时设置为空的。</p>
<p>下面例子中定义了类<code>SurveyQuestion</code>，它包含一个可选字符串属性<code>response</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SurveyQuestion</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> response: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">init</span>(text: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.text = text</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">ask</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(text)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cheeseQuestion = <span class="type">SurveyQuestion</span>(text: <span class="string">"Do you like cheese?"</span>)</span><br><span class="line">cheeseQuestion.ask()</span><br><span class="line"><span class="comment">// 输出 "Do you like cheese?"</span></span><br><span class="line">cheeseQuestion.response = <span class="string">"Yes, I do like cheese."</span></span><br></pre></td></tr></table></figure>
<p>调查问题的答案在回答前是无法确定的，因此我们将属性<code>response</code>声明为<code>String?</code>类型，或者说是可选字符串类型<code>optional String</code>。当<code>SurveyQuestion</code>实例化时，它将自动赋值为<code>nil</code>，表明此字符串暂时还没有值。</p>
<p><a name="assigning_constant_properties_during_initialization"></a></p>
<h3 id="构造过程中常量属性的修改">构造过程中常量属性的修改</h3><p>你可以在构造过程中的任意时间点修改常量属性的值，只要在构造过程结束时是一个确定的值。一旦常量属性被赋值，它将永远不可更改。</p>
<blockquote>
<p>注意<br>对于类的实例来说，它的常量属性只能在定义它的类的构造过程中修改；不能在子类中修改。</p>
</blockquote>
<p>你可以修改上面的<code>SurveyQuestion</code>示例，用常量属性替代变量属性<code>text</code>，表示问题内容<code>text</code>在<code>SurveyQuestion</code>的实例被创建之后不会再被修改。尽管<code>text</code>属性现在是常量，我们仍然可以在类的构造器中设置它的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SurveyQuestion</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> text: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> response: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">init</span>(text: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.text = text</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">ask</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(text)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> beetsQuestion = <span class="type">SurveyQuestion</span>(text: <span class="string">"How about beets?"</span>)</span><br><span class="line">beetsQuestion.ask()</span><br><span class="line"><span class="comment">// 输出 "How about beets?"</span></span><br><span class="line">beetsQuestion.response = <span class="string">"I also like beets. (But not with cheese.)"</span></span><br></pre></td></tr></table></figure>
<p><a name="default_initializers"></a></p>
<h2 id="默认构造器">默认构造器</h2><p>如果结构体或类的所有属性都有默认值，同时没有自定义的构造器，那么 Swift 会给这些结构体或类提供一个默认构造器。这个默认构造器将简单地创建一个所有属性值都设置为默认值的实例。</p>
<p>下面例子中创建了一个类<code>ShoppingListItem</code>，它封装了购物清单中的某一物品的属性：名字（<code>name</code>）、数量（<code>quantity</code>）和购买状态 <code>purchase state</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingListItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> quantity = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> purchased = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> item = <span class="type">ShoppingListItem</span>()</span><br></pre></td></tr></table></figure>
<p>由于<code>ShoppingListItem</code>类中的所有属性都有默认值，且它是没有父类的基类，它将自动获得一个可以为所有属性设置默认值的默认构造器（尽管代码中没有显式为<code>name</code>属性设置默认值，但由于<code>name</code>是可选字符串类型，它将默认设置为<code>nil</code>）。上面例子中使用默认构造器创造了一个<code>ShoppingListItem</code>类的实例（使用<code>ShoppingListItem()</code>形式的构造器语法），并将其赋值给变量<code>item</code>。</p>
<p><a name="memberwise_initializers_for_structure_types"></a></p>
<h3 id="结构体的逐一成员构造器">结构体的逐一成员构造器</h3><p>除了上面提到的默认构造器，如果结构体没有提供自定义的构造器，它们将自动获得一个逐一成员构造器，即使结构体的存储型属性没有默认值。</p>
<p>逐一成员构造器是用来初始化结构体新实例里成员属性的快捷方法。我们在调用逐一成员构造器时，通过与成员属性名相同的参数名进行传值来完成对成员属性的初始赋值。</p>
<p>下面例子中定义了一个结构体<code>Size</code>，它包含两个属性<code>width</code>和<code>height</code>。Swift 可以根据这两个属性的初始赋值<code>0.0</code>自动推导出它们的类型为<code>Double</code>。</p>
<p>由于这两个存储型属性都有默认值，结构体<code>Size</code>自动获得了一个逐一成员构造器<code>init(width:height:)</code>。你可以用它来为<code>Size</code>创建新的实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span>, height = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> twoByTwo = <span class="type">Size</span>(width: <span class="number">2.0</span>, height: <span class="number">2.0</span>)</span><br></pre></td></tr></table></figure>
<p><a name="initializer_delegation_for_value_types"></a></p>
<h2 id="值类型的构造器代理">值类型的构造器代理</h2><p>构造器可以通过调用其它构造器来完成实例的部分构造过程。这一过程称为构造器代理，它能减少多个构造器间的代码重复。</p>
<p>构造器代理的实现规则和形式在值类型和类类型中有所不同。值类型（结构体和枚举类型）不支持继承，所以构造器代理的过程相对简单，因为它们只能代理给提供给它的构造器。类则不同，它可以继承自其它类（请参考<a href="./13_Inheritance.html">继承</a>），这意味着类有责任保证其所有继承的存储型属性在构造时也能正确的初始化。这些责任将在后续章节<a href="#class_inheritance_and_initialization">类的继承和构造过程</a>中介绍。</p>
<p>对于值类型，你可以使用<code>self.init</code>在自定义的构造器中引用类型中的其它构造器。并且你只能在构造器内部调用<code>self.init</code>。</p>
<p>如果你为某个值类型定义了一个自定义的构造器，你将无法访问到默认构造器（如果是结构体，还将无法访问逐一成员构造器）。这个限制可以防止你为值类型定义了一个进行额外必要设置的复杂构造器之后，别人还是错误地使用了一个自动生成的构造器。</p>
<blockquote>
<p>注意<br>假如你希望默认构造器、逐一成员构造器以及你自己的自定义构造器都能用来创建实例，可以将自定义的构造器写到扩展（<code>extension</code>）中，而不是写在值类型的原始定义中。想查看更多内容，请查看<a href="./21_Extensions.html">扩展</a>章节。</p>
</blockquote>
<p>下面例子将定义一个结构体<code>Rect</code>，用来代表几何矩形。这个例子需要两个辅助的结构体<code>Size</code>和<code>Point</code>，它们各自为其所有的属性提供了初始值<code>0.0</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span>, height = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以通过以下三种方式为<code>Rect</code>创建实例——使用被初始化为默认值的<code>origin</code>和<code>size</code>属性来初始化；提供指定的<code>origin</code>和<code>size</code>实例来初始化；提供指定的<code>center</code>和<code>size</code>来初始化。在下面<code>Rect</code>结构体定义中，我们为这三种方式提供了三个自定义的构造器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> origin = <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size = <span class="type">Size</span>()</span><br><span class="line">    <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">init</span>(origin: <span class="type">Point</span>, size: <span class="type">Size</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.origin = origin</span><br><span class="line">        <span class="keyword">self</span>.size = size</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(center: <span class="type">Point</span>, size: <span class="type">Size</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> originX = center.x - (size.width / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">let</span> originY = center.y - (size.height / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(origin: <span class="type">Point</span>(x: originX, y: originY), size: size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个<code>Rect</code>构造器<code>init()</code>，在功能上跟没有自定义构造器时自动获得的默认构造器是一样的。这个构造器是一个空函数，使用一对大括号<code>{}</code>来表示，它没有执行任何构造过程。调用这个构造器将返回一个<code>Rect</code>实例，它的<code>origin</code>和<code>size</code>属性都使用定义时的默认值<code>Point(x: 0.0, y: 0.0)</code>和<code>Size(width: 0.0, height: 0.0)</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> basicRect = <span class="type">Rect</span>()</span><br><span class="line"><span class="comment">// basicRect 的 origin 是 (0.0, 0.0)，size 是 (0.0, 0.0)</span></span><br></pre></td></tr></table></figure>
<p>第二个<code>Rect</code>构造器<code>init(origin:size:)</code>，在功能上跟结构体在没有自定义构造器时获得的逐一成员构造器是一样的。这个构造器只是简单地将<code>origin</code>和<code>size</code>的参数值赋给对应的存储型属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> originRect = <span class="type">Rect</span>(origin: <span class="type">Point</span>(x: <span class="number">2.0</span>, y: <span class="number">2.0</span>),</span><br><span class="line">    size: <span class="type">Size</span>(width: <span class="number">5.0</span>, height: <span class="number">5.0</span>))</span><br><span class="line"><span class="comment">// originRect 的 origin 是 (2.0, 2.0)，size 是 (5.0, 5.0)</span></span><br></pre></td></tr></table></figure>
<p>第三个<code>Rect</code>构造器<code>init(center:size:)</code>稍微复杂一点。它先通过<code>center</code>和<code>size</code>的值计算出<code>origin</code>的坐标，然后再调用（或者说代理给）<code>init(origin:size:)</code>构造器来将新的<code>origin</code>和<code>size</code>值赋值到对应的属性中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> centerRect = <span class="type">Rect</span>(center: <span class="type">Point</span>(x: <span class="number">4.0</span>, y: <span class="number">4.0</span>),</span><br><span class="line">    size: <span class="type">Size</span>(width: <span class="number">3.0</span>, height: <span class="number">3.0</span>))</span><br><span class="line"><span class="comment">// centerRect 的 origin 是 (2.5, 2.5)，size 是 (3.0, 3.0)</span></span><br></pre></td></tr></table></figure>
<p>构造器<code>init(center:size:)</code>可以直接将<code>origin</code>和<code>size</code>的新值赋值到对应的属性中。然而，利用恰好提供了相关功能的现有构造器会更为方便，构造器<code>init(center:size:)</code>的意图也会更加清晰。</p>
<blockquote>
<p>注意<br>如果你想用另外一种不需要自己定义<code>init()</code>和<code>init(origin:size:)</code>的方式来实现这个例子，请参考<a href="./21_Extensions.html">扩展</a>。</p>
</blockquote>
<p><a name="class_inheritance_and_initialization"></a></p>
<h2 id="类的继承和构造过程">类的继承和构造过程</h2><p>类里面的所有存储型属性——包括所有继承自父类的属性——都必须在构造过程中设置初始值。</p>
<p>Swift 为类类型提供了两种构造器来确保实例中所有存储型属性都能获得初始值，它们分别是指定构造器和便利构造器。</p>
<p><a name="designated_initializers_and_convenience_initializers"></a></p>
<h3 id="指定构造器和便利构造器">指定构造器和便利构造器</h3><p><em>指定构造器</em>是类中最主要的构造器。一个指定构造器将初始化类中提供的所有属性，并根据父类链往上调用父类的构造器来实现父类的初始化。</p>
<p>每一个类都必须拥有至少一个指定构造器。在某些情况下，许多类通过继承了父类中的指定构造器而满足了这个条件。具体内容请参考后续章节<a href="#automatic_initializer_inheritance">构造器的自动继承</a>。</p>
<p><em>便利构造器</em>是类中比较次要的、辅助型的构造器。你可以定义便利构造器来调用同一个类中的指定构造器，并为其参数提供默认值。你也可以定义便利构造器来创建一个特殊用途或特定输入值的实例。</p>
<p>你应当只在必要的时候为类提供便利构造器，比方说某种情况下通过使用便利构造器来快捷调用某个指定构造器，能够节省更多开发时间并让类的构造过程更清晰明了。</p>
<p><a name="syntax_for_designated_and_convenience_initializers"></a></p>
<h3 id="指定构造器和便利构造器的语法">指定构造器和便利构造器的语法</h3><p>类的指定构造器的写法跟值类型简单构造器一样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>(parameters) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>便利构造器也采用相同样式的写法，但需要在<code>init</code>关键字之前放置<code>convenience</code>关键字，并使用空格将它们俩分开：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">convenience <span class="keyword">init</span>(parameters) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="initializer_delegation_for_class_types"></a></p>
<h3 id="类的构造器代理规则">类的构造器代理规则</h3><p>为了简化指定构造器和便利构造器之间的调用关系，Swift 采用以下三条规则来限制构造器之间的代理调用：</p>
<h5 id="规则_1">规则 1</h5><p>指定构造器必须调用其直接父类的的指定构造器。</p>
<h5 id="规则_2">规则 2</h5><p>便利构造器必须调用同一类中定义的其它构造器。</p>
<h5 id="规则_3">规则 3</h5><p>便利构造器必须最终导致一个指定构造器被调用。</p>
<p>一个更方便记忆的方法是：</p>
<ul>
<li>指定构造器必须总是向上代理</li>
<li>便利构造器必须总是横向代理</li>
</ul>
<p>这些规则可以通过下面图例来说明：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializerDelegation01_2x.png" alt="构造器代理图"></p>
<p>如图所示，父类中包含一个指定构造器和两个便利构造器。其中一个便利构造器调用了另外一个便利构造器，而后者又调用了唯一的指定构造器。这满足了上面提到的规则 2 和 3。这个父类没有自己的父类，所以规则 1 没有用到。</p>
<p>子类中包含两个指定构造器和一个便利构造器。便利构造器必须调用两个指定构造器中的任意一个，因为它只能调用同一个类里的其他构造器。这满足了上面提到的规则 2 和 3。而两个指定构造器必须调用父类中唯一的指定构造器，这满足了规则 1。</p>
<blockquote>
<p>注意<br>这些规则不会影响类的实例如何创建。任何上图中展示的构造器都可以用来创建完全初始化的实例。这些规则只影响类定义如何实现。</p>
</blockquote>
<p>下面图例中展示了一种涉及四个类的更复杂的类层级结构。它演示了指定构造器是如何在类层级中充当“管道”的作用，在类的构造器链上简化了类之间的相互关系。</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializerDelegation02_2x.png" alt="复杂构造器代理图"></p>
<p><a name="two_phase_initialization"></a></p>
<h3 id="两段式构造过程">两段式构造过程</h3><p>Swift 中类的构造过程包含两个阶段。第一个阶段，每个存储型属性通过引入它们的类的构造器来设置初始值。当每一个存储型属性值被确定后，第二阶段开始，它给每个类一次机会在新实例准备使用之前进一步定制它们的存储型属性。</p>
<p>两段式构造过程的使用让构造过程更安全，同时在整个类层级结构中给予了每个类完全的灵活性。两段式构造过程可以防止属性值在初始化之前被访问，也可以防止属性被另外一个构造器意外地赋予不同的值。</p>
<blockquote>
<p>注意<br>Swift 的两段式构造过程跟 Objective-C 中的构造过程类似。最主要的区别在于阶段 1，Objective-C 给每一个属性赋值<code>0</code>或空值（比如说<code>0</code>或<code>nil</code>）。Swift  的构造流程则更加灵活，它允许你设置定制的初始值，并自如应对某些属性不能以<code>0</code>或<code>nil</code>作为合法默认值的情况。</p>
</blockquote>
<p>Swift 编译器将执行 4 种有效的安全检查，以确保两段式构造过程能顺利完成：</p>
<h5 id="安全检查_1">安全检查 1</h5><p>指定构造器必须保证它所在类引入的所有属性都必须先初始化完成，之后才能将其它构造任务向上代理给父类中的构造器。</p>
<p>如上所述，一个对象的内存只有在其所有存储型属性确定之后才能完全初始化。为了满足这一规则，指定构造器必须保证它所在类引入的属性在它往上代理之前先完成初始化。</p>
<h5 id="安全检查_2">安全检查 2</h5><p>指定构造器必须先向上代理调用父类构造器，然后再为继承的属性设置新值。如果没这么做，指定构造器赋予的新值将被父类中的构造器所覆盖。</p>
<h5 id="安全检查_3">安全检查 3</h5><p>便利构造器必须先代理调用同一类中的其它构造器，然后再为任意属性赋新值。如果没这么做，便利构造器赋予的新值将被同一类中其它指定构造器所覆盖。</p>
<h5 id="安全检查_4">安全检查 4</h5><p>构造器在第一阶段构造完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用<code>self</code>作为一个值。</p>
<p>类实例在第一阶段结束以前并不是完全有效的。只有第一阶段完成后，该实例才会成为有效实例，才能访问属性和调用方法。</p>
<p>以下是两段式构造过程中基于上述安全检查的构造流程展示：</p>
<h5 id="阶段_1">阶段 1</h5><ul>
<li>某个指定构造器或便利构造器被调用。</li>
<li>完成新实例内存的分配，但此时内存还没有被初始化。</li>
<li>指定构造器确保其所在类引入的所有存储型属性都已赋初值。存储型属性所属的内存完成初始化。</li>
<li>指定构造器将调用父类的构造器，完成父类属性的初始化。</li>
<li>这个调用父类构造器的过程沿着构造器链一直往上执行，直到到达构造器链的最顶部。</li>
<li>当到达了构造器链最顶部，且已确保所有实例包含的存储型属性都已经赋值，这个实例的内存被认为已经完全初始化。此时阶段 1 完成。</li>
</ul>
<h5 id="阶段_2">阶段 2</h5><ul>
<li>从顶部构造器链一直往下，每个构造器链中类的指定构造器都有机会进一步定制实例。构造器此时可以访问<code>self</code>、修改它的属性并调用实例方法等等。</li>
<li>最终，任意构造器链中的便利构造器可以有机会定制实例和使用<code>self</code>。</li>
</ul>
<p>下图展示了在假定的子类和父类之间的构造阶段 1：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/twoPhaseInitialization01_2x.png" alt="构建过程阶段1"></p>
<p>在这个例子中，构造过程从对子类中一个便利构造器的调用开始。这个便利构造器此时没法修改任何属性，它把构造任务代理给同一类中的指定构造器。</p>
<p>如安全检查 1 所示，指定构造器将确保所有子类的属性都有值。然后它将调用父类的指定构造器，并沿着构造器链一直往上完成父类的构造过程。</p>
<p>父类中的指定构造器确保所有父类的属性都有值。由于没有更多的父类需要初始化，也就无需继续向上代理。</p>
<p>一旦父类中所有属性都有了初始值，实例的内存被认为是完全初始化，阶段 1 完成。</p>
<p>以下展示了相同构造过程的阶段 2：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/twoPhaseInitialization02_2x.png" alt="构建过程阶段2"></p>
<p>父类中的指定构造器现在有机会进一步来定制实例（尽管这不是必须的）。</p>
<p>一旦父类中的指定构造器完成调用，子类中的指定构造器可以执行更多的定制操作（这也不是必须的）。</p>
<p>最终，一旦子类的指定构造器完成调用，最开始被调用的便利构造器可以执行更多的定制操作。</p>
<p><a name="initializer_inheritance_and_overriding"></a></p>
<h3 id="构造器的继承和重写">构造器的继承和重写</h3><p>跟 Objective-C 中的子类不同，Swift 中的子类默认情况下不会继承父类的构造器。Swift 的这种机制可以防止一个父类的简单构造器被一个更专业的子类继承，并被错误地用来创建子类的实例。</p>
<blockquote>
<p>注意<br>父类的构造器仅会在安全和适当的情况下被继承。具体内容请参考后续章节<a href="#automatic_initializer_inheritance">构造器的自动继承</a>。</p>
</blockquote>
<p>假如你希望自定义的子类中能提供一个或多个跟父类相同的构造器，你可以在子类中提供这些构造器的自定义实现。</p>
<p>当你在编写一个和父类中指定构造器相匹配的子类构造器时，你实际上是在重写父类的这个指定构造器。因此，你必须在定义子类构造器时带上<code>override</code>修饰符。即使你重写的是系统自动提供的默认构造器，也需要带上<code>override</code>修饰符，具体内容请参考<a href="#default_initializers">默认构造器</a>。</p>
<p>正如重写属性，方法或者是下标脚本，<code>override</code>修饰符会让编译器去检查父类中是否有相匹配的指定构造器，并验证构造器参数是否正确。</p>
<blockquote>
<p>注意<br>当你重写一个父类的指定构造器时，你总是需要写<code>override</code>修饰符，即使你的子类将父类的指定构造器重写为了便利构造器。</p>
</blockquote>
<p>相反，如果你编写了一个和父类便利构造器相匹配的子类构造器，由于子类不能直接调用父类的便利构造器（每个规则都在上文<a href="#initializer_delegation_for_class_types">类的构造器代理规则</a>有所描述），因此，严格意义上来讲，你的子类并未对一个父类构造器提供重写。最后的结果就是，你在子类中“重写”一个父类便利构造器时，不需要加<code>override</code>前缀。</p>
<p>在下面的例子中定义了一个叫<code>Vehicle</code>的基类。基类中声明了一个存储型属性<code>numberOfWheels</code>，它是值为<code>0</code>的<code>Int</code>类型的存储型属性。<code>numberOfWheels</code>属性用于创建名为<code>descrpiption</code>的<code>String</code>类型的计算型属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfWheels = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"<span class="subst">\(numberOfWheels)</span> wheel(s)"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Vehicle</code>类只为存储型属性提供默认值，而不自定义构造器。因此，它会自动获得一个默认构造器，具体内容请参考<a href="#default_initializers">默认构造器</a>。自动获得的默认构造器总会是类中的指定构造器，它可以用于创建<code>numberOfWheels</code>为<code>0</code>的<code>Vehicle</code>实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vehicle = <span class="type">Vehicle</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Vehicle: <span class="subst">\(vehicle.description)</span>"</span>)</span><br><span class="line"><span class="comment">// Vehicle: 0 wheel(s)</span></span><br></pre></td></tr></table></figure>
<p>下面例子中定义了一个<code>Vehicle</code>的子类<code>Bicycle</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bicycle</span>: <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        numberOfWheels = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类<code>Bicycle</code>定义了一个自定义指定构造器<code>init()</code>。这个指定构造器和父类的指定构造器相匹配，所以<code>Bicycle</code>中的指定构造器需要带上<code>override</code>修饰符。</p>
<p><code>Bicycle</code>的构造器<code>init()</code>以调用<code>super.init()</code>方法开始，这个方法的作用是调用<code>Bicycle</code>的父类<code>Vehicle</code>的默认构造器。这样可以确保<code>Bicycle</code>在修改属性之前，它所继承的属性<code>numberOfWheels</code>能被<code>Vehicle</code>类初始化。在调用<code>super.init()</code>之后，属性<code>numberOfWheels</code>的原值被新值<code>2</code>替换。</p>
<p>如果你创建一个<code>Bicycle</code>实例，你可以调用继承的<code>description</code>计算型属性去查看属性<code>numberOfWheels</code>是否有改变：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bicycle = <span class="type">Bicycle</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Bicycle: <span class="subst">\(bicycle.description)</span>"</span>)</span><br><span class="line"><span class="comment">// Bicycle: 2 wheel(s)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>子类可以在初始化时修改继承来的变量属性，但是不能修改继承来的常量属性。</p>
</blockquote>
<p><a name="automatic_initializer_inheritance"></a></p>
<h3 id="构造器的自动继承">构造器的自动继承</h3><p>如上所述，子类在默认情况下不会继承父类的构造器。但是如果满足特定条件，父类构造器是可以被自动继承的。在实践中，这意味着对于许多常见场景你不必重写父类的构造器，并且可以在安全的情况下以最小的代价继承父类的构造器。</p>
<p>假设你为子类中引入的所有新属性都提供了默认值，以下 2 个规则适用：</p>
<h5 id="规则_1-1">规则 1</h5><p>如果子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。</p>
<h5 id="规则_2-1">规则 2</h5><p>如果子类提供了所有父类指定构造器的实现——无论是通过规则 1 继承过来的，还是提供了自定义实现——它将自动继承所有父类的便利构造器。（即使属性没有默认值，只要实现了父类的所有指定构造器，就会自动继承父类的所有便利构造器）</p>
<p>即使你在子类中添加了更多的便利构造器，这两条规则仍然适用。</p>
<blockquote>
<p>注意<br>对于规则 2，子类可以将父类的指定构造器实现为便利构造器。</p>
</blockquote>
<p><a name="designated_and_convenience_initializers_in_action"></a></p>
<h3 id="指定构造器和便利构造器实践">指定构造器和便利构造器实践</h3><p>接下来的例子将在实践中展示指定构造器、便利构造器以及构造器的自动继承。这个例子定义了包含三个类<code>Food</code>、<code>RecipeIngredient</code>以及<code>ShoppingListItem</code>的类层次结构，并将演示它们的构造器是如何相互作用的。</p>
<p>类层次中的基类是<code>Food</code>，它是一个简单的用来封装食物名字的类。<code>Food</code>类引入了一个叫做<code>name</code>的<code>String</code>类型的属性，并且提供了两个构造器来创建<code>Food</code>实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    convenience <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name: <span class="string">"[Unnamed]"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图中展示了<code>Food</code>的构造器链：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializersExample01_2x.png" alt="Food构造器链"></p>
<p>类类型没有默认的逐一成员构造器，所以<code>Food</code>类提供了一个接受单一参数<code>name</code>的指定构造器。这个构造器可以使用一个特定的名字来创建新的<code>Food</code>实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> namedMeat = <span class="type">Food</span>(name: <span class="string">"Bacon"</span>)</span><br><span class="line"><span class="comment">// namedMeat 的名字是 "Bacon”</span></span><br></pre></td></tr></table></figure>
<p><code>Food</code>类中的构造器<code>init(name: String)</code>被定义为一个指定构造器，因为它能确保<code>Food</code>实例的所有存储型属性都被初始化。<code>Food</code>类没有父类，所以<code>init(name: String)</code>构造器不需要调用<code>super.init()</code>来完成构造过程。</p>
<p><code>Food</code>类同样提供了一个没有参数的便利构造器<code>init()</code>。这个<code>init()</code>构造器为新食物提供了一个默认的占位名字，通过横向代理到指定构造器<code>init(name: String)</code>并给参数<code>name</code>传值<code>[Unnamed]</code>来实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mysteryMeat = <span class="type">Food</span>()</span><br><span class="line"><span class="comment">// mysteryMeat 的名字是 [Unnamed]</span></span><br></pre></td></tr></table></figure>
<p>类层级中的第二个类是<code>Food</code>的子类<code>RecipeIngredient</code>。<code>RecipeIngredient</code>类构建了食谱中的一味调味剂。它引入了<code>Int</code>类型的属性<code>quantity</code>（以及从<code>Food</code>继承过来的<code>name</code>属性），并且定义了两个构造器来创建<code>RecipeIngredient</code>实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecipeIngredient</span>: <span class="title">Food</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> quantity: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, quantity: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.quantity = quantity</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> convenience <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name: name, quantity: <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图中展示了<code>RecipeIngredient</code>类的构造器链：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializersExample02_2x.png" alt="RecipeIngredient构造器"></p>
<p><code>RecipeIngredient</code>类拥有一个指定构造器<code>init(name: String, quantity: Int)</code>，它可以用来填充<code>RecipeIngredient</code>实例的所有属性值。这个构造器一开始先将传入的<code>quantity</code>参数赋值给<code>quantity</code>属性，这个属性也是唯一在<code>RecipeIngredient</code>中新引入的属性。随后，构造器向上代理到父类<code>Food</code>的<code>init(name: String)</code>。这个过程满足<a href="#two_phase_initialization">两段式构造过程</a>中的安全检查 1。</p>
<p><code>RecipeIngredient</code>还定义了一个便利构造器<code>init(name: String)</code>，它只通过<code>name</code>来创建<code>RecipeIngredient</code>的实例。这个便利构造器假设任意<code>RecipeIngredient</code>实例的<code>quantity</code>为<code>1</code>，所以不需要显式指明数量即可创建出实例。这个便利构造器的定义可以更加方便和快捷地创建实例，并且避免了创建多个<code>quantity</code>为<code>1</code>的<code>RecipeIngredient</code>实例时的代码重复。这个便利构造器只是简单地横向代理到类中的指定构造器，并为<code>quantity</code>参数传递<code>1</code>。</p>
<p>注意，<code>RecipeIngredient</code>的便利构造器<code>init(name: String)</code>使用了跟<code>Food</code>中指定构造器<code>init(name: String)</code>相同的参数。由于这个便利构造器重写了父类的指定构造器<code>init(name: String)</code>，因此必须在前面使用<code>override</code>修饰符（参见<a href="#initializer_inheritance_and_overriding">构造器的继承和重写</a>）。</p>
<p>尽管<code>RecipeIngredient</code>将父类的指定构造器重写为了便利构造器，它依然提供了父类的所有指定构造器的实现。因此，<code>RecipeIngredient</code>会自动继承父类的所有便利构造器。</p>
<p>在这个例子中，<code>RecipeIngredient</code>的父类是<code>Food</code>，它有一个便利构造器<code>init()</code>。这个便利构造器会被<code>RecipeIngredient</code>继承。这个继承版本的<code>init()</code>在功能上跟<code>Food</code>提供的版本是一样的，只是它会代理到<code>RecipeIngredient</code>版本的<code>init(name: String)</code>而不是<code>Food</code>提供的版本。</p>
<p>所有的这三种构造器都可以用来创建新的<code>RecipeIngredient</code>实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oneMysteryItem = <span class="type">RecipeIngredient</span>()</span><br><span class="line"><span class="keyword">let</span> oneBacon = <span class="type">RecipeIngredient</span>(name: <span class="string">"Bacon"</span>)</span><br><span class="line"><span class="keyword">let</span> sixEggs = <span class="type">RecipeIngredient</span>(name: <span class="string">"Eggs"</span>, quantity: <span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>类层级中第三个也是最后一个类是<code>RecipeIngredient</code>的子类，叫做<code>ShoppingListItem</code>。这个类构建了购物单中出现的某一种调味料。</p>
<p>购物单中的每一项总是从未购买状态开始的。为了呈现这一事实，<code>ShoppingListItem</code>引入了一个布尔类型的属性<code>purchased</code>，它的默认值是<code>false</code>。<code>ShoppingListItem</code>还添加了一个计算型属性<code>description</code>，它提供了关于<code>ShoppingListItem</code>实例的一些文字描述：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingListItem</span>: <span class="title">RecipeIngredient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> purchased = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> output = <span class="string">"<span class="subst">\(quantity)</span> x <span class="subst">\(name)</span>"</span></span><br><span class="line">        output += purchased ? <span class="string">" ✔"</span> : <span class="string">" ✘"</span></span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br><code>ShoppingListItem</code>没有定义构造器来为<code>purchased</code>提供初始值，因为添加到购物单的物品的初始状态总是未购买。</p>
</blockquote>
<p>由于它为自己引入的所有属性都提供了默认值，并且自己没有定义任何构造器，<code>ShoppingListItem</code>将自动继承所有父类中的指定构造器和便利构造器。</p>
<p>下图展示了这三个类的构造器链：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializersExample03_2x.png" alt="三类构造器图"></p>
<p>你可以使用全部三个继承来的构造器来创建<code>ShoppingListItem</code>的新实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> breakfastList = [</span><br><span class="line">    <span class="type">ShoppingListItem</span>(),</span><br><span class="line">    <span class="type">ShoppingListItem</span>(name: <span class="string">"Bacon"</span>),</span><br><span class="line">    <span class="type">ShoppingListItem</span>(name: <span class="string">"Eggs"</span>, quantity: <span class="number">6</span>),</span><br><span class="line">]</span><br><span class="line">breakfastList[<span class="number">0</span>].name = <span class="string">"Orange juice"</span></span><br><span class="line">breakfastList[<span class="number">0</span>].purchased = <span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> breakfastList &#123;</span><br><span class="line">    <span class="built_in">print</span>(item.description)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 x orange juice ✔</span></span><br><span class="line"><span class="comment">// 1 x bacon ✘</span></span><br><span class="line"><span class="comment">// 6 x eggs ✘</span></span><br></pre></td></tr></table></figure>
<p>如上所述，例子中通过字面量方式创建了一个数组<code>breakfastList</code>，它包含了三个<code>ShoppingListItem</code>实例，因此数组的类型也能被自动推导为<code>[ShoppingListItem]</code>。在数组创建完之后，数组中第一个<code>ShoppingListItem</code>实例的名字从<code>[Unnamed]</code>更改为<code>Orange juice</code>，并标记为已购买。打印数组中每个元素的描述显示了它们都已按照预期被赋值。</p>
<p><a name="failable_initializers"></a></p>
<h2 id="可失败构造器">可失败构造器</h2><p>如果一个类、结构体或枚举类型的对象，在构造过程中有可能失败，则为其定义一个可失败构造器。这里所指的“失败”是指，如给构造器传入无效的参数值，或缺少某种所需的外部资源，又或是不满足某种必要的条件等。</p>
<p>为了妥善处理这种构造过程中可能会失败的情况。你可以在一个类，结构体或是枚举类型的定义中，添加一个或多个可失败构造器。其语法为在<code>init</code>关键字后面加添问号<code>(init?)</code>。</p>
<blockquote>
<p>注意<br>可失败构造器的参数名和参数类型，不能与其它非可失败构造器的参数名，及其参数类型相同。</p>
</blockquote>
<p>可失败构造器会创建一个类型为自身类型的可选类型的对象。你通过<code>return nil</code>语句来表明可失败构造器在何种情况下应该“失败”。</p>
<blockquote>
<p>注意<br>严格来说，构造器都不支持返回值。因为构造器本身的作用，只是为了确保对象能被正确构造。因此你只是用<code>return nil</code>表明可失败构造器构造失败，而不要用关键字<code>return</code>来表明构造成功。</p>
</blockquote>
<p>下例中，定义了一个名为<code>Animal</code>的结构体，其中有一个名为<code>species</code>的<code>String</code>类型的常量属性。同时该结构体还定义了一个接受一个名为<code>species</code>的<code>String</code>类型参数的可失败构造器。这个可失败构造器检查传入的参数是否为一个空字符串。如果为空字符串，则构造失败。否则，<code>species</code>属性被赋值，构造成功。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> species: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>?(species: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> species.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">self</span>.species = species</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以通过该可失败构造器来构建一个<code>Animal</code>的实例，并检查构造过程是否成功：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someCreature = <span class="type">Animal</span>(species: <span class="string">"Giraffe"</span>)</span><br><span class="line"><span class="comment">// someCreature 的类型是 Animal? 而不是 Animal</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> giraffe = someCreature &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"An animal was initialized with a species of <span class="subst">\(giraffe.species)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "An animal was initialized with a species of Giraffe"</span></span><br></pre></td></tr></table></figure>
<p>如果你给该可失败构造器传入一个空字符串作为其参数，则会导致构造失败：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anonymousCreature = <span class="type">Animal</span>(species: <span class="string">""</span>)</span><br><span class="line"><span class="comment">// anonymousCreature 的类型是 Animal?, 而不是 Animal</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> anonymousCreature == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The anonymous creature could not be initialized"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "The anonymous creature could not be initialized"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>空字符串（如<code>&quot;&quot;</code>，而不是<code>&quot;Giraffe&quot;</code>）和一个值为<code>nil</code>的可选类型的字符串是两个完全不同的概念。上例中的空字符串（<code>&quot;&quot;</code>）其实是一个有效的，非可选类型的字符串。这里我们之所以让<code>Animal</code>的可失败构造器构造失败，只是因为对于<code>Animal</code>这个类的<code>species</code>属性来说，它更适合有一个具体的值，而不是空字符串。</p>
</blockquote>
<p><a name="failable_nitializers_for_enumerations"></a></p>
<h3 id="枚举类型的可失败构造器">枚举类型的可失败构造器</h3><p>你可以通过一个带一个或多个参数的可失败构造器来获取枚举类型中特定的枚举成员。如果提供的参数无法匹配任何枚举成员，则构造失败。</p>
<p>下例中，定义了一个名为<code>TemperatureUnit</code>的枚举类型。其中包含了三个可能的枚举成员(<code>Kelvin</code>，<code>Celsius</code>，和<code>Fahrenheit</code>)，以及一个根据<code>Character</code>值找出所对应的枚举成员的可失败构造器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TemperatureUnit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Kelvin</span>, <span class="type">Celsius</span>, <span class="type">Fahrenheit</span></span><br><span class="line">    <span class="keyword">init</span>?(symbol: <span class="type">Character</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> symbol &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"K"</span>:</span><br><span class="line">            <span class="keyword">self</span> = .<span class="type">Kelvin</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">"C"</span>:</span><br><span class="line">            <span class="keyword">self</span> = .<span class="type">Celsius</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">"F"</span>:</span><br><span class="line">            <span class="keyword">self</span> = .<span class="type">Fahrenheit</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以利用该可失败构造器在三个枚举成员中获取一个相匹配的枚举成员，当参数的值不能与任何枚举成员相匹配时，则构造失败：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fahrenheitUnit = <span class="type">TemperatureUnit</span>(symbol: <span class="string">"F"</span>)</span><br><span class="line"><span class="keyword">if</span> fahrenheitUnit != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"This is a defined temperature unit, so initialization succeeded."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "This is a defined temperature unit, so initialization succeeded."</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> unknownUnit = <span class="type">TemperatureUnit</span>(symbol: <span class="string">"X"</span>)</span><br><span class="line"><span class="keyword">if</span> unknownUnit == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"This is not a defined temperature unit, so initialization failed."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "This is not a defined temperature unit, so initialization failed."</span></span><br></pre></td></tr></table></figure>
<p><a name="failable_initializers_for_enumerations_with_raw_values"></a></p>
<h3 id="带原始值的枚举类型的可失败构造器">带原始值的枚举类型的可失败构造器</h3><p>带原始值的枚举类型会自带一个可失败构造器<code>init?(rawValue:)</code>，该可失败构造器有一个名为<code>rawValue</code>的参数，其类型和枚举类型的原始值类型一致，如果该参数的值能够和某个枚举成员的原始值匹配，则该构造器会构造相应的枚举成员，否则构造失败。</p>
<p>因此上面的<code>TemperatureUnit</code>的例子可以重写为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TemperatureUnit</span>: <span class="title">Character</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Kelvin</span> = <span class="string">"K"</span>, <span class="type">Celsius</span> = <span class="string">"C"</span>, <span class="type">Fahrenheit</span> = <span class="string">"F"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fahrenheitUnit = <span class="type">TemperatureUnit</span>(rawValue: <span class="string">"F"</span>)</span><br><span class="line"><span class="keyword">if</span> fahrenheitUnit != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"This is a defined temperature unit, so initialization succeeded."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "This is a defined temperature unit, so initialization succeeded."</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> unknownUnit = <span class="type">TemperatureUnit</span>(rawValue: <span class="string">"X"</span>)</span><br><span class="line"><span class="keyword">if</span> unknownUnit == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"This is not a defined temperature unit, so initialization failed."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "This is not a defined temperature unit, so initialization failed."</span></span><br></pre></td></tr></table></figure>
<p><a name="failable_initializers_for_classes"></a></p>
<h3 id="类的可失败构造器">类的可失败构造器</h3><p>值类型（也就是结构体或枚举）的可失败构造器，可以在构造过程中的任意时间点触发构造失败。比如在前面的例子中，结构体<code>Animal</code>的可失败构造器在构造过程一开始就触发了构造失败，甚至在<code>species</code>属性被初始化前。</p>
<p>而对类而言，可失败构造器只能在类引入的所有存储型属性被初始化后，以及构造器代理调用完成后，才能触发构造失败。</p>
<p>下面例子展示了如何在类的可失败构造器中使用隐式解包可选类型来满足上述要求：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span>!</span><br><span class="line">    <span class="keyword">init</span>?(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">if</span> name.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面定义的<code>Product</code>类和之前的<code>Animal</code>结构体很相似。<code>Product</code>类有一个不能为空字符串的常量属性<code>name</code>。为了强制这个要求，<code>Product</code>类使用了可失败构造器确保这个属性的值不是空字符串后，才允许构造成功。</p>
<p>毕竟，<code>Product</code>是一个类而不是结构体，这意味着不同于<code>Animal</code>，<code>Product</code>类的所有可失败构造器必须给<code>name</code>属性一个初始值，然后才能触发构造失败。</p>
<p>上面的例子中，<code>Product</code>类的<code>name</code>属性被定义为隐式解包可选字符串类型（<code>String!</code>）。因为它是一个可选类型，所以它在构造过程中被赋值前，具有默认值<code>nil</code>。这个默认值<code>nil</code>意味着<code>Product</code>类引入的所有存储型属性都有一个有效的初始值。因此，一旦传入一个空字符串，该可失败构造器可以在<code>name</code>属性被赋值前触发构造失败。</p>
<blockquote>
<p>译者注<br>上面的示例代码和描述并不相符，根据描述，<code>if name.isEmpty { return nil }</code>这句代码应该在<code>self.name = name</code>之前，而这却会导致编译错误<code>error: all stored properties of a class instance must be initialized before returning nil from an initializer</code>，除非将<code>let name: String!</code>改为<code>var name: String!</code>。</p>
</blockquote>
<p>因为<code>name</code>属性是一个常量，所以一旦构造成功，<code>name</code>属性肯定有一个非<code>nil</code>的值。即使它被定义为隐式解包可选类型，也完全可以放心大胆地直接访问，而不用检查<code>name</code>属性的值是否为<code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> bowTie = <span class="type">Product</span>(name: <span class="string">"bow tie"</span>) &#123;</span><br><span class="line">    <span class="comment">// 不需要检查 bowTie.name 是否为 nil</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The product's name is <span class="subst">\(bowTie.name)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "The product's name is bow tie"</span></span><br></pre></td></tr></table></figure>
<p><a name="propagation_of_initialization_failure"></a></p>
<h3 id="构造失败的传递">构造失败的传递</h3><p>类，结构体，枚举的可失败构造器可以横向代理到类型中的其他可失败构造器。类似的，子类的可失败构造器也能向上代理到父类的可失败构造器。</p>
<p>无论是向上代理还是横向代理，如果你代理到的其他可失败构造器触发构造失败，整个构造过程将立即终止，接下来的任何构造代码不会再被执行。</p>
<blockquote>
<p>注意<br>可失败构造器也可以代理到其它的非可失败构造器。通过这种方式，你可以增加一个可能的失败状态到现有的构造过程中。</p>
</blockquote>
<p>下面这个例子，定义了一个名为<code>CartItem</code>的<code>Product</code>类的子类。这个类建立了一个在线购物车中的物品的模型，它有一个名为<code>quantity</code>的常量存储型属性，并确保该属性的值至少为<code>1</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CartItem</span>: <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> quantity: <span class="type">Int</span>!</span><br><span class="line">    <span class="keyword">init</span>?(name: <span class="type">String</span>, quantity: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.quantity = quantity</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">        <span class="keyword">if</span> quantity &lt; <span class="number">1</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和<code>Product</code>类中的<code>name</code>属性类似，<code>CartItem</code>类中的<code>quantity</code>属性也是隐式解包可选类型。这意味着在构造过程中，该属性在被赋予特定的值之前能有一个默认的初始值<code>nil</code>。</p>
<p>该可失败构造器以向上代理到父类的可失败构造器<code>init(name:)</code>开始。这满足了可失败构造器在触发构造失败前必须总是完成构造器代理调用这个条件。</p>
<p>如果由于<code>name</code>的值为空字符串而导致父类的可失败构造器构造失败，则<code>CartIem</code>类的整个构造过程都将立即失败，之后的构造代码将不会再被执行。如果父类构造成功，<code>CartIem</code>的可失败构造器会进一步验证<code>quantity</code>的值是否不小于<code>1</code>。</p>
<blockquote>
<p>译者注<br>上面的示例代码和描述也不相符，根据描述，<code>self.quantity = quantity</code>这句代码应该放在最后一行，而这却会导致编译错误<code>error: property &#39;self.quantity&#39; not initialized at super.init call</code>，除非将<code>let quantity: Int!</code>改为<code>var quantity: Int!</code>。</p>
</blockquote>
<p>如果你构造一个<code>name</code>的值为非空字符串，<code>quantity</code>的值不小于<code>1</code>的<code>CartItem</code>实例，则可成功构造：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> twoSocks = <span class="type">CartItem</span>(name: <span class="string">"sock"</span>, quantity: <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Item: <span class="subst">\(twoSocks.name)</span>, quantity: <span class="subst">\(twoSocks.quantity)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "Item: sock, quantity: 2"</span></span><br></pre></td></tr></table></figure>
<p>如果你试图构造一个<code>quantity</code>的值为<code>0</code>的<code>CartItem</code>实例, 则<code>CartItem</code>的可失败构造器会触发构造失败：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> zeroShirts = <span class="type">CartItem</span>(name: <span class="string">"shirt"</span>, quantity: <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Item: <span class="subst">\(zeroShirts.name)</span>, quantity: <span class="subst">\(zeroShirts.quantity)</span>"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Unable to initialize zero shirts"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "Unable to initialize zero shirts"</span></span><br></pre></td></tr></table></figure>
<p>类似的，如果你试图构造一个<code>name</code>的值为空字符串的<code>CartItem</code>实例，则父类<code>Product</code>的可失败构造器会触发构造失败：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> oneUnnamed = <span class="type">CartItem</span>(name: <span class="string">""</span>, quantity: <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Item: <span class="subst">\(oneUnnamed.name)</span>, quantity: <span class="subst">\(oneUnnamed.quantity)</span>"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Unable to initialize one unnamed product"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "Unable to initialize one unnamed product"</span></span><br></pre></td></tr></table></figure>
<p><a name="overriding_a_failable_initializer"></a></p>
<h3 id="重写一个可失败构造器">重写一个可失败构造器</h3><p>如同其它的构造器，你可以在子类中重写父类的可失败构造器。或者你也可以用子类的非可失败构造器重写一个父类的可失败构造器。这使你可以定义一个不会构造失败的子类，即使父类的构造器允许构造失败。</p>
<p>注意，当你用子类的非可失败构造器重写父类的可失败构造器时，向上代理到父类的可失败构造器的唯一方式是对父类的可失败构造器的返回值进行强制解包。</p>
<blockquote>
<p>注意<br>你可以用非可失败构造器重写可失败构造器，但反过来却不行。</p>
</blockquote>
<p>下例定义了一个名为<code>Document</code>的类，<code>name</code>属性的值必须为一个非空字符串或<code>nil</code>，但不能是一个空字符串：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Document</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">    <span class="comment">// 该构造器创建了一个 name 属性的值为 nil 的 document 实例</span></span><br><span class="line">    <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">    <span class="comment">// 该构造器创建了一个 name 属性的值为非空字符串的 document 实例</span></span><br><span class="line">    <span class="keyword">init</span>?(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">if</span> name.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面这个例子，定义了一个<code>Document</code>类的子类<code>AutomaticallyNamedDocument</code>。这个子类重写了父类的两个指定构造器，确保了无论是使用<code>init()</code>构造器，还是使用<code>init(name:)</code>构造器并为参数传递空字符串，生成的实例中的<code>name</code>属性总有初始<code>&quot;[Untitled]&quot;</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutomaticallyNamedDocument</span>: <span class="title">Document</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">self</span>.name = <span class="string">"[Untitled]"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">if</span> name.isEmpty &#123;</span><br><span class="line">            <span class="keyword">self</span>.name = <span class="string">"[Untitled]"</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.name = name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AutomaticallyNamedDocument</code>用一个非可失败构造器<code>init(name:)</code>重写了父类的可失败构造器<code>init?(name:)</code>。因为子类用另一种方式处理了空字符串的情况，所以不再需要一个可失败构造器，因此子类用一个非可失败构造器代替了父类的可失败构造器。</p>
<p>你可以在子类的非可失败构造器中使用强制解包来调用父类的可失败构造器。比如，下面的<code>UntitledDocument</code>子类的<code>name</code>属性的值总是<code>&quot;[Untitled]&quot;</code>，它在构造过程中使用了父类的可失败构造器<code>init?(name:)</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UntitledDocument</span>: <span class="title">Document</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: <span class="string">"[Untitled]"</span>)!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，如果在调用父类的可失败构造器<code>init?(name:)</code>时传入的是空字符串，那么强制解包操作会引发运行时错误。不过，因为这里是通过非空的字符串常量来调用它，所以并不会发生运行时错误。</p>
<p><a name="the_init!_failable_initializer"></a></p>
<h3 id="可失败构造器_init!">可失败构造器 init!</h3><p>通常来说我们通过在<code>init</code>关键字后添加问号的方式（<code>init?</code>）来定义一个可失败构造器，但你也可以通过在<code>init</code>后面添加惊叹号的方式来定义一个可失败构造器（<code>(init!)</code>），该可失败构造器将会构建一个对应类型的隐式解包可选类型的对象。</p>
<p>你可以在<code>init?</code>中代理到<code>init!</code>，反之亦然。你也可以用<code>init?</code>重写<code>init!</code>，反之亦然。你还可以用<code>init</code>代理到<code>init!</code>，不过，一旦<code>init!</code>构造失败，则会触发一个断言。</p>
<p><a name="required_initializers"></a></p>
<h2 id="必要构造器">必要构造器</h2><p>在类的构造器前添加<code>required</code>修饰符表明所有该类的子类都必须实现该构造器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    required <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 构造器的实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在子类重写父类的必要构造器时，必须在子类的构造器前也添加<code>required</code>修饰符，表明该构造器要求也应用于继承链后面的子类。在重写父类中必要的指定构造器时，不需要添加<code>override</code>修饰符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeSubclass</span>: <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    required <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 构造器的实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>如果子类继承的构造器能满足必要构造器的要求，则无须在子类中显式提供必要构造器的实现。</p>
</blockquote>
<p><a name="setting_a_default_property_value_with_a_closure_or_function"></a></p>
<h2 id="通过闭包或函数设置属性的默认值">通过闭包或函数设置属性的默认值</h2><p>如果某个存储型属性的默认值需要一些定制或设置，你可以使用闭包或全局函数为其提供定制的默认值。每当某个属性所在类型的新实例被创建时，对应的闭包或函数会被调用，而它们的返回值会当做默认值赋值给这个属性。</p>
<p>这种类型的闭包或函数通常会创建一个跟属性类型相同的临时变量，然后修改它的值以满足预期的初始状态，最后返回这个临时变量，作为属性的默认值。</p>
<p>下面介绍了如何用闭包为属性提供默认值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> someProperty: <span class="type">SomeType</span> = &#123;</span><br><span class="line">        <span class="comment">// 在这个闭包中给 someProperty 创建一个默认值</span></span><br><span class="line">        <span class="comment">// someValue 必须和 SomeType 类型相同</span></span><br><span class="line">        <span class="keyword">return</span> someValue</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意闭包结尾的大括号后面接了一对空的小括号。这用来告诉 Swift 立即执行此闭包。如果你忽略了这对括号，相当于将闭包本身作为值赋值给了属性，而不是将闭包的返回值赋值给属性。</p>
<blockquote>
<p>注意<br>如果你使用闭包来初始化属性，请记住在闭包执行时，实例的其它部分都还没有初始化。这意味着你不能在闭包里访问其它属性，即使这些属性有默认值。同样，你也不能使用隐式的<code>self</code>属性，或者调用任何实例方法。</p>
</blockquote>
<p>下面例子中定义了一个结构体<code>Checkerboard</code>，它构建了西洋跳棋游戏的棋盘：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/checkersBoard_2x.png" alt="西洋跳棋棋盘"></p>
<p>西洋跳棋游戏在一副黑白格交替的<code>10x10</code>的棋盘中进行。为了呈现这副游戏棋盘，<code>Checkerboard</code>结构体定义了一个属性<code>boardColors</code>，它是一个包含<code>100</code>个<code>Bool</code>值的数组。在数组中，值为<code>true</code>的元素表示一个黑格，值为<code>false</code>的元素表示一个白格。数组中第一个元素代表棋盘上左上角的格子，最后一个元素代表棋盘上右下角的格子。</p>
<p><code>boardColor</code>数组是通过一个闭包来初始化并设置颜色值的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Checkerboard</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> boardColors: [<span class="type">Bool</span>] = &#123;</span><br><span class="line">        <span class="keyword">var</span> temporaryBoard = [<span class="type">Bool</span>]()</span><br><span class="line">        <span class="keyword">var</span> isBlack = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> &#123;</span><br><span class="line">                temporaryBoard.append(isBlack)</span><br><span class="line">                isBlack = !isBlack</span><br><span class="line">            &#125;</span><br><span class="line">            isBlack = !isBlack</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temporaryBoard</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">squareIsBlackAtRow</span><span class="params">(row: Int, column: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> boardColors[(row * <span class="number">10</span>) + column]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每当一个新的<code>Checkerboard</code>实例被创建时，赋值闭包会被执行，<code>boardColors</code>的默认值会被计算出来并返回。上面例子中描述的闭包将计算出棋盘中每个格子对应的颜色，并将这些值保存到一个临时数组<code>temporaryBoard</code>中，最后在构建完成时将此数组作为闭包返回值返回。这个返回的数组会保存到<code>boardColors</code>中，并可以通过工具函数<code>squareIsBlackAtRow</code>来查询：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> board = <span class="type">Checkerboard</span>()</span><br><span class="line"><span class="built_in">print</span>(board.squareIsBlackAtRow(<span class="number">0</span>, column: <span class="number">1</span>))</span><br><span class="line"><span class="comment">// 打印 "true"</span></span><br><span class="line"><span class="built_in">print</span>(board.squareIsBlackAtRow(<span class="number">9</span>, column: <span class="number">9</span>))</span><br><span class="line"><span class="comment">// 打印 "false"</span></span><br></pre></td></tr></table></figure>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/15_Deinitialization/" itemprop="url">
                第二章-15析构过程（Deinitialization）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:12+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/15_Deinitialization/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/15_Deinitialization/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="析构过程（Deinitialization）">析构过程（Deinitialization）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/bruce0505" target="_blank" rel="external">bruce0505</a><br>校对：<a href="https://github.com/fd5788" target="_blank" rel="external">fd5788</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/chenmingbiao" target="_blank" rel="external">chenmingbiao</a></p>
<p>2.1<br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a>，2015-10-31</p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#how_deinitialization_works">析构过程原理</a></li>
<li><a href="#deinitializers_in_action">析构器实践</a></li>
</ul>
<p><em>析构器</em>只适用于类类型，当一个类的实例被释放之前，析构器会被立即调用。析构器用关键字<code>deinit</code>来标示，类似于构造器要用<code>init</code>来标示。</p>
<p><a name="how_deinitialization_works"></a></p>
<p>##析构过程原理</p>
<p>Swift 会自动释放不再需要的实例以释放资源。如<a href="./16_Automatic_Reference_Counting.html">自动引用计数</a>章节中所讲述，Swift 通过<code>自动引用计数（ARC）</code>处理实例的内存管理。通常当你的实例被释放时不需要手动地去清理。但是，当使用自己的资源时，你可能需要进行一些额外的清理。例如，如果创建了一个自定义的类来打开一个文件，并写入一些数据，你可能需要在类实例被释放之前手动去关闭该文件。</p>
<p>在类的定义中，每个类最多只能有一个析构器，而且析构器不带任何参数，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">deinit</span> &#123;</span><br><span class="line">    <span class="comment">// 执行析构过程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>析构器是在实例释放发生前被自动调用。你不能主动调用析构器。子类继承了父类的析构器，并且在子类析构器实现的最后，父类的析构器会被自动调用。即使子类没有提供自己的析构器，父类的析构器也同样会被调用。</p>
<p>因为直到实例的析构器被调用后，实例才会被释放，所以析构器可以访问实例的所有属性，并且可以根据那些属性可以修改它的行为（比如查找一个需要被关闭的文件）。</p>
<p><a name="deinitializers_in_action"></a></p>
<p>##析构器实践</p>
<p>这是一个析构器实践的例子。这个例子描述了一个简单的游戏，这里定义了两种新类型，分别是<code>Bank</code>和<code>Player</code>。<code>Bank</code>类管理一种虚拟硬币，确保流通的硬币数量永远不可能超过 10,000。在游戏中有且只能有一个<code>Bank</code>存在，因此<code>Bank</code>用类来实现，并使用静态属性和静态方法来存储和管理其当前状态。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> coinsInBank = <span class="number">10_000</span></span><br><span class="line">    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">vendCoins</span><span class="params">(<span class="keyword">var</span> numberOfCoinsToVend: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        numberOfCoinsToVend = <span class="built_in">min</span>(numberOfCoinsToVend, coinsInBank)</span><br><span class="line">        coinsInBank -= numberOfCoinsToVend</span><br><span class="line">        <span class="keyword">return</span> numberOfCoinsToVend</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">receiveCoins</span><span class="params">(coins: Int)</span></span> &#123;</span><br><span class="line">        coinsInBank += coins</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Bank</code>使用<code>coinsInBank</code>属性来跟踪它当前拥有的硬币数量。<code>Bank</code>还提供了两个方法，<code>vendCoins(_:)</code>和<code>receiveCoins(_:)</code>，分别用来处理硬币的分发和收集。</p>
<p><code>vendCoins(_:)</code>方法在<code>Bank</code>对象分发硬币之前检查是否有足够的硬币。如果硬币不足，<code>Bank</code>对象会返回一个比请求时小的数字（如果<code>Bank</code>对象中没有硬币了就返回<code>0</code>）。<code>vendCoins</code>方法声明<code>numberOfCoinsToVend</code>为一个变量参数，这样就可以在方法体内部修改分发的硬币数量，而不需要定义一个新的变量。<code>vendCoins</code>方法返回一个整型值，表示提供的硬币的实际数量。</p>
<p><code>receiveCoins(_:)</code>方法只是将<code>Bank</code>对象接收到的硬币数目加回硬币存储中。</p>
<p><code>Player</code>类描述了游戏中的一个玩家。每一个玩家在任意时间都有一定数量的硬币存储在他们的钱包中。这通过玩家的<code>coinsInPurse</code>属性来表示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> coinsInPurse: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(coins: <span class="type">Int</span>) &#123;</span><br><span class="line">        coinsInPurse = <span class="type">Bank</span>.vendCoins(coins)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">winCoins</span><span class="params">(coins: Int)</span></span> &#123;</span><br><span class="line">        coinsInPurse += <span class="type">Bank</span>.vendCoins(coins)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="type">Bank</span>.receiveCoins(coinsInPurse)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个<code>Player</code>实例在初始化的过程中，都从<code>Bank</code>对象获取指定数量的硬币。如果没有足够的硬币可用，<code>Player</code>实例可能会收到比指定数量少的硬币.</p>
<p><code>Player</code>类定义了一个<code>winCoins(_:)</code>方法，该方法从<code>Bank</code>对象获取一定数量的硬币，并把它们添加到玩家的钱包。<code>Player</code>类还实现了一个析构器，这个析构器在<code>Player</code>实例释放前被调用。在这里，析构器的作用只是将玩家的所有硬币都返还给<code>Bank</code>对象：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> playerOne: <span class="type">Player</span>? = <span class="type">Player</span>(coins: <span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"A new player has joined the game with <span class="subst">\(playerOne!.coinsInPurse)</span> coins"</span>)</span><br><span class="line"><span class="comment">// 打印 "A new player has joined the game with 100 coins"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"There are now <span class="subst">\(Bank.coinsInBank)</span> coins left in the bank"</span>)</span><br><span class="line"><span class="comment">// 打印 "There are now 9900 coins left in the bank"</span></span><br></pre></td></tr></table></figure>
<p>创建一个<code>Player</code>实例的时候，会向<code>Bank</code>对象请求 100 个硬币，如果有足够的硬币可用的话。这个<code>Player</code>实例存储在一个名为<code>playerOne</code>的可选类型的变量中。这里使用了一个可选类型的变量，因为玩家可以随时离开游戏，设置为可选使你可以追踪玩家当前是否在游戏中。</p>
<p>因为<code>playerOne</code>是可选的，所以访问其<code>coinsInPurse</code>属性来打印钱包中的硬币数量时，使用感叹号（<code>!</code>）来解包：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">playerOne!.winCoins(<span class="number">2_000</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"PlayerOne won 2000 coins &amp; now has <span class="subst">\(playerOne!.coinsInPurse)</span> coins"</span>)</span><br><span class="line"><span class="comment">// 输出 "PlayerOne won 2000 coins &amp; now has 2100 coins"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The bank now only has <span class="subst">\(Bank.coinsInBank)</span> coins left"</span>)</span><br><span class="line"><span class="comment">// 输出 "The bank now only has 7900 coins left"</span></span><br></pre></td></tr></table></figure>
<p>这里，玩家已经赢得了 2,000 枚硬币，所以玩家的钱包中现在有 2,100 枚硬币，而<code>Bank</code>对象只剩余 7,900 枚硬币。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">playerOne = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"PlayerOne has left the game"</span>)</span><br><span class="line"><span class="comment">// 打印 "PlayerOne has left the game"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The bank now has <span class="subst">\(Bank.coinsInBank)</span> coins"</span>)</span><br><span class="line"><span class="comment">// 打印 "The bank now has 10000 coins"</span></span><br></pre></td></tr></table></figure>
<p>玩家现在已经离开了游戏。这通过将可选类型的<code>playerOne</code>变量设置为<code>nil</code>来表示，意味着“没有<code>Player</code>实例”。当这一切发生时，<code>playerOne</code>变量对<code>Player</code>实例的引用被破坏了。没有其它属性或者变量引用<code>Player</code>实例，因此该实例会被释放，以便回收内存。在这之前，该实例的析构器被自动调用，玩家的硬币被返还给银行。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/16_Automatic_Reference_Counting/" itemprop="url">
                第二章-16自动引用计数（Automatic Reference Counting）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:11+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/16_Automatic_Reference_Counting/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/16_Automatic_Reference_Counting/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="自动引用计数（Automatic_Reference_Counting）">自动引用计数（Automatic Reference Counting）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/TimothyYe" target="_blank" rel="external">TimothyYe</a><br>校对：<a href="https://github.com/Hawstein" target="_blank" rel="external">Hawstein</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/Channe" target="_blank" rel="external">Channe</a></p>
<p>2.1<br>翻译：<a href="https://github.com/Channe" target="_blank" rel="external">Channe</a><br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a>，2015-10-31</p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#how_arc_works">自动引用计数的工作机制</a></li>
<li><a href="#arc_in_action">自动引用计数实践</a></li>
<li><a href="#strong_reference_cycles_between_class_instances">类实例之间的循环强引用</a></li>
<li><a href="#resolving_strong_reference_cycles_between_class_instances">解决实例之间的循环强引用</a></li>
<li><a href="#strong_reference_cycles_for_closures">闭包引起的循环强引用</a></li>
<li><a href="#resolving_strong_reference_cycles_for_closures">解决闭包引起的循环强引用</a></li>
</ul>
<p>Swift 使用自动引用计数（ARC）机制来跟踪和管理你的应用程序的内存。通常情况下，Swift 内存管理机制会一直起作用，你无须自己来考虑内存的管理。ARC 会在类的实例不再被使用时，自动释放其占用的内存。</p>
<p>然而，在少数情况下，ARC 为了能帮助你管理内存，需要更多的关于你的代码之间关系的信息。本章描述了这些情况，并且为你示范怎样启用 ARC 来管理你的应用程序的内存。</p>
<blockquote>
<p>注意<br>引用计数仅仅应用于类的实例。结构体和枚举类型是值类型，不是引用类型，也不是通过引用的方式存储和传递。</p>
</blockquote>
<p><a name="how_arc_works"></a></p>
<h2 id="自动引用计数的工作机制">自动引用计数的工作机制</h2><p>当你每次创建一个类的新的实例的时候，ARC 会分配一大块内存用来储存实例的信息。内存中会包含实例的类型信息，以及这个实例所有相关属性的值。</p>
<p>此外，当实例不再被使用时，ARC 释放实例所占用的内存，并让释放的内存能挪作他用。这确保了不再被使用的实例，不会一直占用内存空间。</p>
<p>然而，当 ARC 收回和释放了正在被使用中的实例，该实例的属性和方法将不能再被访问和调用。实际上，如果你试图访问这个实例，你的应用程序很可能会崩溃。</p>
<p>为了确保使用中的实例不会被销毁，ARC 会跟踪和计算每一个实例正在被多少属性，常量和变量所引用。哪怕实例的引用数为1，ARC都不会销毁这个实例。</p>
<p>为了使上述成为可能，无论你将实例赋值给属性、常量或变量，它们都会创建此实例的强引用。之所以称之为“强”引用，是因为它会将实例牢牢地保持住，只要强引用还在，实例是不允许被销毁的。</p>
<p><a name="arc_in_action"></a></p>
<h2 id="自动引用计数实践">自动引用计数实践</h2><p>下面的例子展示了自动引用计数的工作机制。例子以一个简单的<code>Person</code>类开始，并定义了一个叫<code>name</code>的常量属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span> is being initialized"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span> is being deinitialized"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Person</code>类有一个构造函数，此构造函数为实例的<code>name</code>属性赋值，并打印一条消息以表明初始化过程生效。<code>Person</code>类也拥有一个析构函数，这个析构函数会在实例被销毁时打印一条消息。</p>
<p>接下来的代码片段定义了三个类型为<code>Person?</code>的变量，用来按照代码片段中的顺序，为新的<code>Person</code>实例建立多个引用。由于这些变量是被定义为可选类型（<code>Person?</code>，而不是<code>Person</code>），它们的值会被自动初始化为<code>nil</code>，目前还不会引用到<code>Person</code>类的实例。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reference1: <span class="type">Person</span>?</span><br><span class="line"><span class="keyword">var</span> reference2: <span class="type">Person</span>?</span><br><span class="line"><span class="keyword">var</span> reference3: <span class="type">Person</span>?</span><br></pre></td></tr></table></figure>
<p>现在你可以创建<code>Person</code>类的新实例，并且将它赋值给三个变量中的一个：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reference1 = <span class="type">Person</span>(name: <span class="string">"John Appleseed"</span>)</span><br><span class="line"><span class="comment">// prints "John Appleseed is being initialized”</span></span><br></pre></td></tr></table></figure>
<p>应当注意到当你调用<code>Person</code>类的构造函数的时候，<code>“John Appleseed is being initialized”</code>会被打印出来。由此可以确定构造函数被执行。</p>
<p>由于<code>Person</code>类的新实例被赋值给了<code>reference1</code>变量，所以<code>reference1</code>到<code>Person</code>类的新实例之间建立了一个强引用。正是因为这一个强引用，ARC 会保证<code>Person</code>实例被保持在内存中不被销毁。</p>
<p>如果你将同一个<code>Person</code>实例也赋值给其他两个变量，该实例又会多出两个强引用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reference2 = reference1</span><br><span class="line">reference3 = reference1</span><br></pre></td></tr></table></figure>
<p>现在这一个<code>Person</code>实例已经有三个强引用了。</p>
<p>如果你通过给其中两个变量赋值<code>nil</code>的方式断开两个强引用（包括最先的那个强引用），只留下一个强引用，<code>Person</code>实例不会被销毁：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reference1 = <span class="literal">nil</span></span><br><span class="line">reference2 = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>在你清楚地表明不再使用这个<code>Person</code>实例时，即第三个也就是最后一个强引用被断开时，ARC 会销毁它：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reference3 = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// 打印 “John Appleseed is being deinitialized”</span></span><br></pre></td></tr></table></figure>
<p><a name="strong_reference_cycles_between_class_instances"></a></p>
<h2 id="类实例之间的循环强引用">类实例之间的循环强引用</h2><p>在上面的例子中，ARC 会跟踪你所新创建的<code>Person</code>实例的引用数量，并且会在<code>Person</code>实例不再被需要时销毁它。</p>
<p>然而，我们可能会写出一个类实例的强引用数永远不能变成<code>0</code>的代码。如果两个类实例互相持有对方的强引用，因而每个实例都让对方一直存在，就是这种情况。这就是所谓的循环强引用。</p>
<p>你可以通过定义类之间的关系为弱引用或无主引用，以替代强引用，从而解决循环强引用的问题。具体的过程在<a href="#resolving_strong_reference_cycles_between_class_instances">解决类实例之间的循环强引用</a>中有描述。不管怎样，在你学习怎样解决循环强引用之前，很有必要了解一下它是怎样产生的。</p>
<p>下面展示了一个不经意产生循环强引用的例子。例子定义了两个类：<code>Person</code>和<code>Apartment</code>，用来建模公寓和它其中的居民：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123; <span class="keyword">self</span>.name = name &#125;</span><br><span class="line">    <span class="keyword">var</span> apartment: <span class="type">Apartment</span>?</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span> is being deinitialized"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apartment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> unit: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(unit: <span class="type">String</span>) &#123; <span class="keyword">self</span>.unit = unit &#125;</span><br><span class="line">    <span class="keyword">var</span> tenant: <span class="type">Person</span>?</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"Apartment <span class="subst">\(unit)</span> is being deinitialized"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一个<code>Person</code>实例有一个类型为<code>String</code>，名字为<code>name</code>的属性，并有一个可选的初始化为<code>nil</code>的<code>apartment</code>属性。<code>apartment</code>属性是可选的，因为一个人并不总是拥有公寓。</p>
<p>类似的，每个<code>Apartment</code>实例有一个叫<code>number</code>，类型为<code>Int</code>的属性，并有一个可选的初始化为<code>nil</code>的<code>tenant</code>属性。<code>tenant</code>属性是可选的，因为一栋公寓并不总是有居民。</p>
<p>这两个类都定义了析构函数，用以在类实例被析构的时候输出信息。这让你能够知晓<code>Person</code>和<code>Apartment</code>的实例是否像预期的那样被销毁。</p>
<p>接下来的代码片段定义了两个可选类型的变量<code>john</code>和<code>unit4A</code>，并分别被设定为下面的<code>Apartment</code>和<code>Person</code>的实例。这两个变量都被初始化为<code>nil</code>，这正是可选的优点：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> john: <span class="type">Person</span>?</span><br><span class="line"><span class="keyword">var</span> unit4A: <span class="type">Apartment</span>?</span><br></pre></td></tr></table></figure>
<p>现在你可以创建特定的<code>Person</code>和<code>Apartment</code>实例并将赋值给<code>john</code>和<code>unit4A</code>变量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">john = <span class="type">Person</span>(name: <span class="string">"John Appleseed"</span>)</span><br><span class="line">unit4A = <span class="type">Apartment</span>(unit: <span class="string">"4A"</span>)</span><br></pre></td></tr></table></figure>
<p>在两个实例被创建和赋值后，下图表现了强引用的关系。变量<code>john</code>现在有一个指向<code>Person</code>实例的强引用，而变量<code>unit4A</code>有一个指向<code>Apartment</code>实例的强引用：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle01_2x.png" alt=""></p>
<p>现在你能够将这两个实例关联在一起，这样人就能有公寓住了，而公寓也有了房客。注意感叹号是用来展开和访问可选变量<code>john</code>和<code>unit4A</code>中的实例，这样实例的属性才能被赋值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">john!.apartment = unit4A</span><br><span class="line">unit4A!.tenant = john</span><br></pre></td></tr></table></figure>
<p>在将两个实例联系在一起之后，强引用的关系如图所示：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle02_2x.png" alt=""></p>
<p>不幸的是，这两个实例关联后会产生一个循环强引用。<code>Person</code>实例现在有了一个指向<code>Apartment</code>实例的强引用，而<code>Apartment</code>实例也有了一个指向<code>Person</code>实例的强引用。因此，当你断开<code>john</code>和<code>unit4A</code>变量所持有的强引用时，引用计数并不会降为<code>0</code>，实例也不会被 ARC 销毁：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">john = <span class="literal">nil</span></span><br><span class="line">unit4A = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>注意，当你把这两个变量设为<code>nil</code>时，没有任何一个析构函数被调用。循环强引用会一直阻止<code>Person</code>和<code>Apartment</code>类实例的销毁，这就在你的应用程序中造成了内存泄漏。</p>
<p>在你将<code>john</code>和<code>unit4A</code>赋值为<code>nil</code>后，强引用关系如下图：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle03_2x.png" alt=""></p>
<p><code>Person</code>和<code>Apartment</code>实例之间的强引用关系保留了下来并且不会被断开。</p>
<p><a name="resolving_strong_reference_cycles_between_class_instances"></a></p>
<h2 id="解决实例之间的循环强引用">解决实例之间的循环强引用</h2><p>Swift 提供了两种办法用来解决你在使用类的属性时所遇到的循环强引用问题：弱引用（weak reference）和无主引用（unowned reference）。</p>
<p>弱引用和无主引用允许循环引用中的一个实例引用另外一个实例而不保持强引用。这样实例能够互相引用而不产生循环强引用。</p>
<p>对于生命周期中会变为<code>nil</code>的实例使用弱引用。相反地，对于初始化赋值后再也不会被赋值为<code>nil</code>的实例，使用无主引用。</p>
<p><a name="weak_references"></a></p>
<h3 id="弱引用">弱引用</h3><p>弱引用不会对其引用的实例保持强引用，因而不会阻止 ARC 销毁被引用的实例。这个特性阻止了引用变为循环强引用。声明属性或者变量时，在前面加上<code>weak</code>关键字表明这是一个弱引用。</p>
<p>在实例的生命周期中，如果某些时候引用没有值，那么弱引用可以避免循环强引用。如果引用总是有值，则可以使用无主引用，在<a href="#unowned_references">无主引用</a>中有描述。在上面<code>Apartment</code>的例子中，一个公寓的生命周期中，有时是没有“居民”的，因此适合使用弱引用来解决循环强引用。</p>
<blockquote>
<p>注意<br>弱引用必须被声明为变量，表明其值能在运行时被修改。弱引用不能被声明为常量。  </p>
</blockquote>
<p>因为弱引用可以没有值，你必须将每一个弱引用声明为可选类型。在 Swift 中，推荐使用可选类型描述可能没有值的类型。</p>
<p>因为弱引用不会保持所引用的实例，即使引用存在，实例也有可能被销毁。因此，ARC 会在引用的实例被销毁后自动将其赋值为<code>nil</code>。你可以像其他可选值一样，检查弱引用的值是否存在，你将永远不会访问已销毁的实例的引用。</p>
<p>下面的例子跟上面<code>Person</code>和<code>Apartment</code>的例子一致，但是有一个重要的区别。这一次，<code>Apartment</code>的<code>tenant</code>属性被声明为弱引用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123; <span class="keyword">self</span>.name = name &#125;</span><br><span class="line">    <span class="keyword">var</span> apartment: <span class="type">Apartment</span>?</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span> is being deinitialized"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apartment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> unit: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(unit: <span class="type">String</span>) &#123; <span class="keyword">self</span>.unit = unit &#125;</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> tenant: <span class="type">Person</span>?</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"Apartment <span class="subst">\(unit)</span> is being deinitialized"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后跟之前一样，建立两个变量（<code>john</code>和<code>unit4A</code>）之间的强引用，并关联两个实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> john: <span class="type">Person</span>?</span><br><span class="line"><span class="keyword">var</span> unit4A: <span class="type">Apartment</span>?</span><br><span class="line"></span><br><span class="line">john = <span class="type">Person</span>(name: <span class="string">"John Appleseed"</span>)</span><br><span class="line">unit4A = <span class="type">Apartment</span>(unit: <span class="string">"4A"</span>)</span><br><span class="line"></span><br><span class="line">john!.apartment = unit4A</span><br><span class="line">unit4A!.tenant = john</span><br></pre></td></tr></table></figure>
<p>现在，两个关联在一起的实例的引用关系如下图所示：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference01_2x.png" alt=""></p>
<p><code>Person</code>实例依然保持对<code>Apartment</code>实例的强引用，但是<code>Apartment</code>实例只持有对<code>Person</code>实例的弱引用。这意味着当你断开<code>john</code>变量所保持的强引用时，再也没有指向<code>Person</code>实例的强引用了：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference02_2x.png" alt=""></p>
<p>由于再也没有指向<code>Person</code>实例的强引用，该实例会被销毁：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">john = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// 打印 “John Appleseed is being deinitialized”</span></span><br></pre></td></tr></table></figure>
<p>唯一剩下的指向<code>Apartment</code>实例的强引用来自于变量<code>unit4A</code>。如果你断开这个强引用，再也没有指向<code>Apartment</code>实例的强引用了：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference03_2x.png" alt=""></p>
<p>由于再也没有指向<code>Apartment</code>实例的强引用，该实例也会被销毁：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unit4A = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// 打印 “Apartment 4A is being deinitialized”</span></span><br></pre></td></tr></table></figure>
<p>上面的两段代码展示了变量<code>john</code>和<code>unit4A</code>在被赋值为<code>nil</code>后，<code>Person</code>实例和<code>Apartment</code>实例的析构函数都打印出“销毁”的信息。这证明了引用循环被打破了。</p>
<blockquote>
<p>注意<br> 在使用垃圾收集的系统里，弱指针有时用来实现简单的缓冲机制，因为没有强引用的对象只会在内存压力触发垃圾收集时才被销毁。但是在 ARC 中，一旦值的最后一个强引用被移除，就会被立即销毁，这导致弱引用并不适合上面的用途。</p>
</blockquote>
<p><a name="unowned_references"></a></p>
<h3 id="无主引用">无主引用</h3><p>和弱引用类似，无主引用不会牢牢保持住引用的实例。和弱引用不同的是，无主引用是永远有值的。因此，无主引用总是被定义为非可选类型（non-optional type）。你可以在声明属性或者变量时，在前面加上关键字<code>unowned</code>表示这是一个无主引用。</p>
<p>由于无主引用是非可选类型，你不需要在使用它的时候将它展开。无主引用总是可以被直接访问。不过 ARC 无法在实例被销毁后将无主引用设为<code>nil</code>，因为非可选类型的变量不允许被赋值为<code>nil</code>。</p>
<blockquote>
<p>注意<br>如果你试图在实例被销毁后，访问该实例的无主引用，会触发运行时错误。使用无主引用，你必须确保引用始终指向一个未销毁的实例。<br>还需要注意的是如果你试图访问实例已经被销毁的无主引用，Swift 确保程序会直接崩溃，而不会发生无法预期的行为。所以你应当避免这样的事情发生。  </p>
</blockquote>
<p>下面的例子定义了两个类，<code>Customer</code>和<code>CreditCard</code>，模拟了银行客户和客户的信用卡。这两个类中，每一个都将另外一个类的实例作为自身的属性。这种关系可能会造成循环强引用。</p>
<p><code>Customer</code>和<code>CreditCard</code>之间的关系与前面弱引用例子中<code>Apartment</code>和<code>Person</code>的关系略微不同。在这个数据模型中，一个客户可能有或者没有信用卡，但是一张信用卡总是关联着一个客户。为了表示这种关系，<code>Customer</code>类有一个可选类型的<code>card</code>属性，但是<code>CreditCard</code>类有一个非可选类型的<code>customer</code>属性。</p>
<p>此外，只能通过将一个<code>number</code>值和<code>customer</code>实例传递给<code>CreditCard</code>构造函数的方式来创建<code>CreditCard</code>实例。这样可以确保当创建<code>CreditCard</code>实例时总是有一个<code>customer</code>实例与之关联。</p>
<p>由于信用卡总是关联着一个客户，因此将<code>customer</code>属性定义为无主引用，用以避免循环强引用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> card: <span class="type">CreditCard</span>?</span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span> is being deinitialized"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditCard</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> number: <span class="type">UInt64</span></span><br><span class="line">    <span class="keyword">unowned</span> <span class="keyword">let</span> customer: <span class="type">Customer</span></span><br><span class="line">    <span class="keyword">init</span>(number: <span class="type">UInt64</span>, customer: <span class="type">Customer</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.number = number</span><br><span class="line">        <span class="keyword">self</span>.customer = customer</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"Card #<span class="subst">\(number)</span> is being deinitialized"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br><code>CreditCard</code>类的<code>number</code>属性被定义为<code>UInt64</code>类型而不是<code>Int</code>类型，以确保<code>number</code>属性的存储量在 32 位和 64 位系统上都能足够容纳 16 位的卡号。</p>
</blockquote>
<p>下面的代码片段定义了一个叫<code>john</code>的可选类型<code>Customer</code>变量，用来保存某个特定客户的引用。由于是可选类型，所以变量被初始化为<code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> john: <span class="type">Customer</span>?</span><br></pre></td></tr></table></figure>
<p>现在你可以创建<code>Customer</code>类的实例，用它初始化<code>CreditCard</code>实例，并将新创建的<code>CreditCard</code>实例赋值为客户的<code>card</code>属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">john = <span class="type">Customer</span>(name: <span class="string">"John Appleseed"</span>)</span><br><span class="line">john!.card = <span class="type">CreditCard</span>(number: <span class="number">1234_5678_9012_3456</span>, customer: john!)</span><br></pre></td></tr></table></figure>
<p>在你关联两个实例后，它们的引用关系如下图所示：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/unownedReference01_2x.png" alt=""></p>
<p><code>Customer</code>实例持有对<code>CreditCard</code>实例的强引用，而<code>CreditCard</code>实例持有对<code>Customer</code>实例的无主引用。</p>
<p>由于<code>customer</code>的无主引用，当你断开<code>john</code>变量持有的强引用时，再也没有指向<code>Customer</code>实例的强引用了：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/unownedReference02_2x.png" alt=""></p>
<p>由于再也没有指向<code>Customer</code>实例的强引用，该实例被销毁了。其后，再也没有指向<code>CreditCard</code>实例的强引用，该实例也随之被销毁了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">john = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// 打印 “John Appleseed is being deinitialized”</span></span><br><span class="line"><span class="comment">// 打印 ”Card #1234567890123456 is being deinitialized”</span></span><br></pre></td></tr></table></figure>
<p>最后的代码展示了在<code>john</code>变量被设为<code>nil</code>后<code>Customer</code>实例和<code>CreditCard</code>实例的构造函数都打印出了“销毁”的信息。</p>
<p><a name="unowned_references_and_implicitly_unwrapped_optional_properties"></a></p>
<p>###无主引用以及隐式解析可选属性</p>
<p>上面弱引用和无主引用的例子涵盖了两种常用的需要打破循环强引用的场景。</p>
<p><code>Person</code>和<code>Apartment</code>的例子展示了两个属性的值都允许为<code>nil</code>，并会潜在的产生循环强引用。这种场景最适合用弱引用来解决。</p>
<p><code>Customer</code>和<code>CreditCard</code>的例子展示了一个属性的值允许为<code>nil</code>，而另一个属性的值不允许为<code>nil</code>，这也可能会产生循环强引用。这种场景最适合通过无主引用来解决。</p>
<p>然而，存在着第三种场景，在这种场景中，两个属性都必须有值，并且初始化完成后永远不会为<code>nil</code>。在这种场景中，需要一个类使用无主属性，而另外一个类使用隐式解析可选属性。</p>
<p>这使两个属性在初始化完成后能被直接访问（不需要可选展开），同时避免了循环引用。这一节将为你展示如何建立这种关系。</p>
<p>下面的例子定义了两个类，<code>Country</code>和<code>City</code>，每个类将另外一个类的实例保存为属性。在这个模型中，每个国家必须有首都，每个城市必须属于一个国家。为了实现这种关系，<code>Country</code>类拥有一个<code>capitalCity</code>属性，而<code>City</code>类有一个<code>country</code>属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Country</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> capitalCity: <span class="type">City</span>!</span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, capitalName: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.capitalCity = <span class="type">City</span>(name: capitalName, country: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">City</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">unowned</span> <span class="keyword">let</span> country: <span class="type">Country</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, country: <span class="type">Country</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.country = country</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了建立两个类的依赖关系，<code>City</code>的构造函数接受一个<code>Country</code>实例作为参数，并且将实例保存到<code>country</code>属性。</p>
<p><code>Country</code>的构造函数调用了<code>City</code>的构造函数。然而，只有<code>Country</code>的实例完全初始化后，<code>Country</code>的构造函数才能把<code>self</code>传给<code>City</code>的构造函数。（在<a href="./14_Initialization.html#two_phase_initialization">两段式构造过程</a>中有具体描述）</p>
<p>为了满足这种需求，通过在类型结尾处加上感叹号（<code>City!</code>）的方式，将<code>Country</code>的<code>capitalCity</code>属性声明为隐式解析可选类型的属性。这意味着像其他可选类型一样，<code>capitalCity</code>属性的默认值为<code>nil</code>，但是不需要展开它的值就能访问它。（在<a href="./01_The_Basics.html#implicityly_unwrapped_optionals">隐式解析可选类型</a>中有描述）</p>
<p>由于<code>capitalCity</code>默认值为<code>nil</code>，一旦<code>Country</code>的实例在构造函数中给<code>name</code>属性赋值后，整个初始化过程就完成了。这意味着一旦<code>name</code>属性被赋值后，<code>Country</code>的构造函数就能引用并传递隐式的<code>self</code>。<code>Country</code>的构造函数在赋值<code>capitalCity</code>时，就能将<code>self</code>作为参数传递给<code>City</code>的构造函数。</p>
<p>以上的意义在于你可以通过一条语句同时创建<code>Country</code>和<code>City</code>的实例，而不产生循环强引用，并且<code>capitalCity</code>的属性能被直接访问，而不需要通过感叹号来展开它的可选值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> country = <span class="type">Country</span>(name: <span class="string">"Canada"</span>, capitalName: <span class="string">"Ottawa"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(country.name)</span>'s capital city is called <span class="subst">\(country.capitalCity.name)</span>"</span>)</span><br><span class="line"><span class="comment">// 打印 “Canada's capital city is called Ottawa”</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，使用隐式解析可选值意味着满足了类的构造函数的两个构造阶段的要求。<code>capitalCity</code>属性在初始化完成后，能像非可选值一样使用和存取，同时还避免了循环强引用。</p>
<p><a name="strong_reference_cycles_for_closures"></a></p>
<p>##闭包引起的循环强引用</p>
<p>前面我们看到了循环强引用是在两个类实例属性互相保持对方的强引用时产生的，还知道了如何用弱引用和无主引用来打破这些循环强引用。</p>
<p>循环强引用还会发生在当你将一个闭包赋值给类实例的某个属性，并且这个闭包体中又使用了这个类实例时。这个闭包体中可能访问了实例的某个属性，例如<code>self.someProperty</code>，或者闭包中调用了实例的某个方法，例如<code>self.someMethod()</code>。这两种情况都导致了闭包“捕获”<code>self</code>，从而产生了循环强引用。</p>
<p>循环强引用的产生，是因为闭包和类相似，都是引用类型。当你把一个闭包赋值给某个属性时，你是将这个闭包的引用赋值给了属性。实质上，这跟之前的问题是一样的——两个强引用让彼此一直有效。但是，和两个类实例不同，这次一个是类实例，另一个是闭包。</p>
<p>Swift 提供了一种优雅的方法来解决这个问题，称之为闭包捕获列表（closuer capture list）。同样的，在学习如何用闭包捕获列表破坏循环强引用之前，先来了解一下这里的循环强引用是如何产生的，这对我们很有帮助。</p>
<p>下面的例子为你展示了当一个闭包引用了<code>self</code>后是如何产生一个循环强引用的。例子中定义了一个叫<code>HTMLElement</code>的类，用一种简单的模型表示 HTML 文档中的一个单独的元素：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> text: <span class="type">String</span>?</span><br><span class="line"></span><br><span class="line">    lazy <span class="keyword">var</span> asHTML: <span class="type">Void</span> -&gt; <span class="type">String</span> = &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> text = <span class="keyword">self</span>.text &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"&lt;<span class="subst">\(<span class="keyword">self</span>.name)</span>&gt;<span class="subst">\(text)</span>&lt;/<span class="subst">\(<span class="keyword">self</span>.name)</span>&gt;"</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"&lt;<span class="subst">\(<span class="keyword">self</span>.name)</span> /&gt;"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, text: <span class="type">String</span>? = <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.text = text</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span> is being deinitialized"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>HTMLElement</code>类定义了一个<code>name</code>属性来表示这个元素的名称，例如代表段落的<code>“p”</code>，或者代表换行的<code>“br”</code>。<code>HTMLElement</code>还定义了一个可选属性<code>text</code>，用来设置 HTML 元素呈现的文本。</p>
<p>除了上面的两个属性，<code>HTMLElement</code>还定义了一个<code>lazy</code>属性<code>asHTML</code>。这个属性引用了一个将<code>name</code>和<code>text</code>组合成 HTML 字符串片段的闭包。该属性是<code>Void -&gt; String</code>类型，或者可以理解为“一个没有参数，返回<code>String</code>的函数”。</p>
<p>默认情况下，闭包赋值给了<code>asHTML</code>属性，这个闭包返回一个代表 HTML 标签的字符串。如果<code>text</code>值存在，该标签就包含可选值<code>text</code>；如果<code>text</code>不存在，该标签就不包含文本。对于段落元素，根据<code>text</code>是<code>“some text”</code>还是<code>nil</code>，闭包会返回<code>&quot;&lt;p&gt;some text&lt;/p&gt;&quot;</code>或者<code>&quot;&lt;p /&gt;&quot;</code>。</p>
<p>可以像实例方法那样去命名、使用<code>asHTML</code>属性。然而，由于<code>asHTML</code>是闭包而不是实例方法，如果你想改变特定 HTML 元素的处理方式的话，可以用自定义的闭包来取代默认值。</p>
<p>例如，可以将一个闭包赋值给<code>asHTML</code>属性，这个闭包能在<code>text</code>属性是<code>nil</code>时使用默认文本，这是为了避免返回一个空的 HTML 标签：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> heading = <span class="type">HTMLElement</span>(name: <span class="string">"h1"</span>)</span><br><span class="line"><span class="keyword">let</span> defaultText = <span class="string">"some default text"</span></span><br><span class="line">heading.asHTML = &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&lt;<span class="subst">\(heading.name)</span>&gt;<span class="subst">\(heading.text ?? defaultText)</span>&lt;/<span class="subst">\(heading.name)</span>&gt;"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(heading.asHTML())</span><br><span class="line"><span class="comment">// 打印 “&lt;h1&gt;some default text&lt;/h1&gt;”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br><code>asHTML</code>声明为<code>lazy</code>属性，因为只有当元素确实需要被处理为 HTML 输出的字符串时，才需要使用<code>asHTML</code>。也就是说，在默认的闭包中可以使用<code>self</code>，因为只有当初始化完成以及<code>self</code>确实存在后，才能访问<code>lazy</code>属性。</p>
</blockquote>
<p><code>HTMLElement</code>类只提供了一个构造函数，通过<code>name</code>和<code>text</code>（如果有的话）参数来初始化一个新元素。该类也定义了一个析构函数，当<code>HTMLElement</code>实例被销毁时，打印一条消息。</p>
<p>下面的代码展示了如何用<code>HTMLElement</code>类创建实例并打印消息：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> paragraph: <span class="type">HTMLElement</span>? = <span class="type">HTMLElement</span>(name: <span class="string">"p"</span>, text: <span class="string">"hello, world"</span>)</span><br><span class="line"><span class="built_in">print</span>(paragraph!.asHTML())</span><br><span class="line"><span class="comment">// 打印 “hello, world”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>上面的<code>paragraph</code>变量定义为可选类型的<code>HTMLElement</code>，因此我们可以赋值<code>nil</code>给它来演示循环强引用。</p>
</blockquote>
<p>不幸的是，上面写的<code>HTMLElement</code>类产生了类实例和作为<code>asHTML</code>默认值的闭包之间的循环强引用。循环强引用如下图所示：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/closureReferenceCycle01_2x.png" alt=""></p>
<p>实例的<code>asHTML</code>属性持有闭包的强引用。但是，闭包在其闭包体内使用了<code>self</code>（引用了<code>self.name</code>和<code>self.text</code>），因此闭包捕获了<code>self</code>，这意味着闭包又反过来持有了<code>HTMLElement</code>实例的强引用。这样两个对象就产生了循环强引用。（更多关于闭包捕获值的信息，请参考<a href="./07_Closures.html#capturing_values">值捕获</a>）。</p>
<blockquote>
<p>注意<br>虽然闭包多次使用了<code>self</code>，它只捕获<code>HTMLElement</code>实例的一个强引用。</p>
</blockquote>
<p>如果设置<code>paragraph</code>变量为<code>nil</code>，打破它持有的<code>HTMLElement</code>实例的强引用，<code>HTMLElement</code>实例和它的闭包都不会被销毁，也是因为循环强引用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paragraph = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>HTMLElement</code>的析构函数中的消息并没有被打印，证明了<code>HTMLElement</code>实例并没有被销毁。</p>
<p><a name="resolving_strong_reference_cycles_for_closures"></a></p>
<p>##解决闭包引起的循环强引用</p>
<p>在定义闭包时同时定义捕获列表作为闭包的一部分，通过这种方式可以解决闭包和类实例之间的循环强引用。捕获列表定义了闭包体内捕获一个或者多个引用类型的规则。跟解决两个类实例间的循环强引用一样，声明每个捕获的引用为弱引用或无主引用，而不是强引用。应当根据代码关系来决定使用弱引用还是无主引用。</p>
<blockquote>
<p>注意<br>Swift 有如下要求：只要在闭包内使用<code>self</code>的成员，就要用<code>self.someProperty</code>或者<code>self.someMethod()</code>（而不只是<code>someProperty</code>或<code>someMethod()</code>）。这提醒你可能会一不小心就捕获了<code>self</code>。</p>
</blockquote>
<p><a name="defining_a_capture_list"></a></p>
<p>###定义捕获列表</p>
<p>捕获列表中的每一项都由一对元素组成，一个元素是<code>weak</code>或<code>unowned</code>关键字，另一个元素是类实例的引用（例如<code>self</code>）或初始化过的变量（如<code>delegate = self.delegate!</code>）。这些项在方括号中用逗号分开。</p>
<p>如果闭包有参数列表和返回类型，把捕获列表放在它们前面：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lazy <span class="keyword">var</span> someClosure: (<span class="type">Int</span>, <span class="type">String</span>) -&gt; <span class="type">String</span> = &#123;</span><br><span class="line">    [<span class="keyword">unowned</span> <span class="keyword">self</span>, <span class="keyword">weak</span> delegate = <span class="keyword">self</span>.delegate!] (index: <span class="type">Int</span>, stringToProcess: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// 这里是闭包的函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果闭包没有指明参数列表或者返回类型，即它们会通过上下文推断，那么可以把捕获列表和关键字<code>in</code>放在闭包最开始的地方：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lazy <span class="keyword">var</span> someClosure: <span class="type">Void</span> -&gt; <span class="type">String</span> = &#123;</span><br><span class="line">    [<span class="keyword">unowned</span> <span class="keyword">self</span>, <span class="keyword">weak</span> delegate = <span class="keyword">self</span>.delegate!] <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// 这里是闭包的函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="weak_and_unowned_references"></a></p>
<p>###弱引用和无主引用</p>
<p>在闭包和捕获的实例总是互相引用并且总是同时销毁时，将闭包内的捕获定义为无主引用。</p>
<p>相反的，在被捕获的引用可能会变为<code>nil</code>时，将闭包内的捕获定义为弱引用。弱引用总是可选类型，并且当引用的实例被销毁后，弱引用的值会自动置为<code>nil</code>。这使我们可以在闭包体内检查它们是否存在。</p>
<blockquote>
<p>注意<br>如果被捕获的引用绝对不会变为<code>nil</code>，应该用无主引用，而不是弱引用。</p>
</blockquote>
<p>前面的<code>HTMLElement</code>例子中，无主引用是正确的解决循环强引用的方法。这样编写<code>HTMLElement</code>类来避免循环强引用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> text: <span class="type">String</span>?</span><br><span class="line"></span><br><span class="line">    lazy <span class="keyword">var</span> asHTML: <span class="type">Void</span> -&gt; <span class="type">String</span> = &#123;</span><br><span class="line">        [<span class="keyword">unowned</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> text = <span class="keyword">self</span>.text &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"&lt;<span class="subst">\(<span class="keyword">self</span>.name)</span>&gt;<span class="subst">\(text)</span>&lt;/<span class="subst">\(<span class="keyword">self</span>.name)</span>&gt;"</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"&lt;<span class="subst">\(<span class="keyword">self</span>.name)</span> /&gt;"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, text: <span class="type">String</span>? = <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.text = text</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span> is being deinitialized"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的<code>HTMLElement</code>实现和之前的实现一致，除了在<code>asHTML</code>闭包中多了一个捕获列表。这里，捕获列表是<code>[unowned self]</code>，表示“将<code>self</code>捕获为无主引用而不是强引用”。</p>
<p>和之前一样，我们可以创建并打印<code>HTMLElement</code>实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> paragraph: <span class="type">HTMLElement</span>? = <span class="type">HTMLElement</span>(name: <span class="string">"p"</span>, text: <span class="string">"hello, world"</span>)</span><br><span class="line"><span class="built_in">print</span>(paragraph!.asHTML())</span><br><span class="line"><span class="comment">// 打印 “&lt;p&gt;hello, world&lt;/p&gt;”</span></span><br></pre></td></tr></table></figure>
<p>使用捕获列表后引用关系如下图所示：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/closureReferenceCycle02_2x.png" alt=""></p>
<p>这一次，闭包以无主引用的形式捕获<code>self</code>，并不会持有<code>HTMLElement</code>实例的强引用。如果将<code>paragraph</code>赋值为<code>nil</code>，<code>HTMLElement</code>实例将会被销毁，并能看到它的析构函数打印出的消息：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">paragraph = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// 打印 “p is being deinitialized”</span></span><br></pre></td></tr></table></figure>
<p>你可以查看<a href="../chapter3/04_Expressions.html">捕获列表</a>章节，获取更多关于捕获列表的信息。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/17_Optional_Chaining/" itemprop="url">
                第二章-17可选链式调用（Optional Chaining）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:10+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/17_Optional_Chaining/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/17_Optional_Chaining/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="可选链式调用（Optional_Chaining）">可选链式调用（Optional Chaining）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/Jasonbroker" target="_blank" rel="external">Jasonbroker</a><br>校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>, <a href="https://github.com/stanzhai" target="_blank" rel="external">stanzhai</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/lyojo" target="_blank" rel="external">lyojo</a></p>
<p>2.1<br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a>，2015-10-31</p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#optional_chaining_as_an_alternative_to_forced_unwrapping">使用可选链式调用代替强制展开</a></li>
<li><a href="#defining_model_classes_for_optional_chaining">为可选链式调用定义模型类</a></li>
<li><a href="#accessing_properties_through_optional_chaining">通过可选链式调用访问属性</a></li>
<li><a href="#calling_methods_through_optional_chaining">通过可选链式调用调用方法</a></li>
<li><a href="#accessing_subscripts_through_optional_chaining">通过可选链式调用访问下标</a></li>
<li><a href="#linking_multiple_levels_of_chaining">连接多层可选链式调用</a></li>
<li><a href="#chaining_on_methods_with_optional_return_values">在方法的可选返回值上进行可选链式调用</a></li>
</ul>
<p>可选链式调用（Optional Chaining）是一种可以在当前值可能为<code>nil</code>的可选值上请求和调用属性、方法及下标的方法。如果可选值有值，那么调用就会成功；如果可选值是<code>nil</code>，那么调用将返回<code>nil</code>。多个调用可以连接在一起形成一个调用链，如果其中任何一个节点为<code>nil</code>，整个调用链都会失败，即返回<code>nil</code>。</p>
<blockquote>
<p>注意<br>Swift 的可选链式调用和 Objective-C 中向<code>nil</code>发送消息有些相像，但是 Swift 的可选链式调用可以应用于任意类型，并且能检查调用是否成功。</p>
</blockquote>
<p><a name="optional_chaining_as_an_alternative_to_forced_unwrapping"></a></p>
<h2 id="使用可选链式调用代替强制展开">使用可选链式调用代替强制展开</h2><p>通过在想调用的属性、方法、或下标的可选值（optional value）后面放一个问号（<code>?</code>），可以定义一个可选链。这一点很像在可选值后面放一个叹号（<code>!</code>）来强制展开它的值。它们的主要区别在于当可选值为空时可选链式调用只会调用失败，然而强制展开将会触发运行时错误。</p>
<p>为了反映可选链式调用可以在空值（<code>nil</code>）上调用的事实，不论这个调用的属性、方法及下标返回的值是不是可选值，它的返回结果都是一个可选值。你可以利用这个返回值来判断你的可选链式调用是否调用成功，如果调用有返回值则说明调用成功，返回<code>nil</code>则说明调用失败。</p>
<p>特别地，可选链式调用的返回结果与原本的返回结果具有相同的类型，但是被包装成了一个可选值。例如，使用可选链式调用访问属性，当可选链式调用成功时，如果属性原本的返回结果是<code>Int</code>类型，则会变为<code>Int?</code>类型。</p>
<p>下面几段代码将解释可选链式调用和强制展开的不同。</p>
<p>首先定义两个类<code>Person</code>和<code>Residence</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> residence: <span class="type">Residence</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Residence</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> numberOfRooms = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Residence</code>有一个<code>Int</code>类型的属性<code>numberOfRooms</code>，其默认值为<code>1</code>。<code>Person</code>具有一个可选的<code>residence</code>属性，其类型为<code>Residence?</code>。</p>
<p>如果创建一个新的<code>Person</code>实例，因为它的<code>residence</code>属性是可选的，<code>john</code>属性将初始化为<code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> john = <span class="type">Person</span>()</span><br></pre></td></tr></table></figure>
<p>如果使用叹号（<code>!</code>）强制展开获得这个<code>john</code>的<code>residence</code>属性中的<code>numberOfRooms</code>值，会触发运行时错误，因为这时<code>residence</code>没有可以展开的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> roomCount = john.residence!.numberOfRooms</span><br><span class="line"><span class="comment">// 这会引发运行时错误</span></span><br></pre></td></tr></table></figure>
<p><code>john.residence</code>为非<code>nil</code>值的时候，上面的调用会成功，并且把<code>roomCount</code>设置为<code>Int</code>类型的房间数量。正如上面提到的，当<code>residence</code>为<code>nil</code>的时候上面这段代码会触发运行时错误。</p>
<p>可选链式调用提供了另一种访问<code>numberOfRooms</code>的方式，使用问号（<code>?</code>）来替代原来的叹号（<code>!</code>）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> roomCount = john.residence?.numberOfRooms &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"John's residence has <span class="subst">\(roomCount)</span> room(s)."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Unable to retrieve the number of rooms."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “Unable to retrieve the number of rooms.”</span></span><br></pre></td></tr></table></figure>
<p>在<code>residence</code>后面添加问号之后，Swift 就会在<code>residence</code>不为<code>nil</code>的情况下访问<code>numberOfRooms</code>。</p>
<p>因为访问<code>numberOfRooms</code>有可能失败，可选链式调用会返回<code>Int?</code>类型，或称为“可选的 <code>Int</code>”。如上例所示，当<code>residence</code>为<code>nil</code>的时候，可选的<code>Int</code>将会为<code>nil</code>，表明无法访问<code>numberOfRooms</code>。访问成功时，可选的<code>Int</code>值会通过可选绑定展开，并赋值给非可选类型的<code>roomCount</code>常量。</p>
<p>要注意的是，即使<code>numberOfRooms</code>是非可选的<code>Int</code>时，这一点也成立。只要使用可选链式调用就意味着<code>numberOfRooms</code>会返回一个<code>Int?</code>而不是<code>Int</code>。</p>
<p>可以将一个<code>Residence</code>的实例赋给<code>john.residence</code>，这样它就不再是<code>nil</code>了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">john.residence = <span class="type">Residence</span>()</span><br></pre></td></tr></table></figure>
<p><code>john.residence</code>现在包含一个实际的<code>Residence</code>实例，而不再是<code>nil</code>。如果你试图使用先前的可选链式调用访问<code>numberOfRooms</code>，它现在将返回值为<code>1</code>的<code>Int?</code>类型的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> roomCount = john.residence?.numberOfRooms &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"John's residence has <span class="subst">\(roomCount)</span> room(s)."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Unable to retrieve the number of rooms."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “John's residence has 1 room(s).”</span></span><br></pre></td></tr></table></figure>
<p><a name="defining_model_classes_for_optional_chaining"></a></p>
<h2 id="为可选链式调用定义模型类">为可选链式调用定义模型类</h2><p>通过使用可选链式调用可以调用多层属性、方法和下标。这样可以在复杂的模型中向下访问各种子属性，并且判断能否访问子属性的属性、方法或下标。</p>
<p>下面这段代码定义了四个模型类，这些例子包括多层可选链式调用。为了方便说明，在<code>Person</code>和<code>Residence</code>的基础上增加了<code>Room</code>类和<code>Address</code>类，以及相关的属性、方法以及下标。</p>
<p><code>Person</code>类的定义基本保持不变：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> residence: <span class="type">Residence</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Residence</code>类比之前复杂些，增加了一个名为<code>rooms</code>的变量属性，该属性被初始化为<code>[Room]</code>类型的空数组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Residence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rooms = [<span class="type">Room</span>]()</span><br><span class="line">    <span class="keyword">var</span> numberOfRooms: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rooms.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">Room</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> rooms[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            rooms[i] = newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">printNumberOfRooms</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"The number of rooms is <span class="subst">\(numberOfRooms)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> address: <span class="type">Address</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在<code>Residence</code>有了一个存储<code>Room</code>实例的数组，<code>numberOfRooms</code>属性被实现为计算型属性，而不是存储型属性。<code>numberOfRooms</code>属性简单地返回<code>rooms</code>数组的<code>count</code>属性的值。</p>
<p><code>Residence</code>还提供了访问<code>rooms</code>数组的快捷方式，即提供可读写的下标来访问<code>rooms</code>数组中指定位置的元素。</p>
<p>此外，<code>Residence</code>还提供了<code>printNumberOfRooms()</code>方法，这个方法的作用是打印<code>numberOfRooms</code>的值。</p>
<p>最后，<code>Residence</code>还定义了一个可选属性<code>address</code>，其类型为<code>Address?</code>。<code>Address</code>类的定义在下面会说明。</p>
<p><code>Room</code>类是一个简单类，其实例被存储在<code>rooms</code>数组中。该类只包含一个属性<code>name</code>，以及一个用于将该属性设置为适当的房间名的初始化函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Room</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123; <span class="keyword">self</span>.name = name &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一个类是<code>Address</code>，这个类有三个<code>String?</code>类型的可选属性。<code>buildingName</code>以及<code>buildingNumber</code>属性分别表示某个大厦的名称和号码，第三个属性<code>street</code>表示大厦所在街道的名称：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> buildingName: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> buildingNumber: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> street: <span class="type">String</span>?</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">buildingIdentifier</span><span class="params">()</span></span> -&gt; <span class="type">String</span>? &#123;</span><br><span class="line">        <span class="keyword">if</span> buildingName != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> buildingName</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> buildingNumber != <span class="literal">nil</span> &amp;&amp; street != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"<span class="subst">\(buildingNumber)</span> <span class="subst">\(street)</span>"</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Address</code>类提供了<code>buildingIdentifier()</code>方法，返回值为<code>String?</code>。 如果<code>buildingName</code>有值则返回<code>buildingName</code>。或者，如果<code>buildingNumber</code>和<code>street</code>均有值则返回<code>buildingNumber</code>。否则，返回<code>nil</code>。</p>
<p><a name="accessing_properties_through_optional_chaining"></a></p>
<h2 id="通过可选链式调用访问属性">通过可选链式调用访问属性</h2><p>正如<a href="#optional_chaining_as_an_alternative_to_forced_unwrapping">使用可选链式调用代替强制展开</a>中所述，可以通过可选链式调用在一个可选值上访问它的属性，并判断访问是否成功。</p>
<p>下面的代码创建了一个<code>Person</code>实例，然后像之前一样，尝试访问<code>numberOfRooms</code>属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> john = <span class="type">Person</span>()</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> roomCount = john.residence?.numberOfRooms &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"John's residence has <span class="subst">\(roomCount)</span> room(s)."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Unable to retrieve the number of rooms."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “Unable to retrieve the number of rooms.”</span></span><br></pre></td></tr></table></figure>
<p>因为<code>john.residence</code>为<code>nil</code>，所以这个可选链式调用依旧会像先前一样失败。</p>
<p>还可以通过可选链式调用来设置属性值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someAddress = <span class="type">Address</span>()</span><br><span class="line">someAddress.buildingNumber = <span class="string">"29"</span></span><br><span class="line">someAddress.street = <span class="string">"Acacia Road"</span></span><br><span class="line">john.residence?.address = someAddress</span><br></pre></td></tr></table></figure>
<p>在这个例子中，通过<code>john.residence</code>来设定<code>address</code>属性也会失败，因为<code>john.residence</code>当前为<code>nil</code>。</p>
<p>上面代码中的赋值过程是可选链式调用的一部分，这意味着可选链式调用失败时，等号右侧的代码不会被执行。对于上面的代码来说，很难验证这一点，因为像这样赋值一个常量没有任何副作用。下面的代码完成了同样的事情，但是它使用一个函数来创建<code>Address</code>实例，然后将该实例返回用于赋值。该函数会在返回前打印“Function was called”，这使你能验证等号右侧的代码是否被执行。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">createAddress</span><span class="params">()</span></span> -&gt; <span class="type">Address</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Function was called."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> someAddress = <span class="type">Address</span>()</span><br><span class="line">    someAddress.buildingNumber = <span class="string">"29"</span></span><br><span class="line">    someAddress.street = <span class="string">"Acacia Road"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> someAddress</span><br><span class="line">&#125;</span><br><span class="line">john.residence?.address = createAddress()</span><br></pre></td></tr></table></figure>
<p>没有任何打印消息，可以看出<code>createAddress()</code>函数并未被执行。</p>
<p><a name="calling_methods_through_optional_chaining"></a></p>
<h2 id="通过可选链式调用调用方法">通过可选链式调用调用方法</h2><p>可以通过可选链式调用来调用方法，并判断是否调用成功，即使这个方法没有返回值。</p>
<p><code>Residence</code>类中的<code>printNumberOfRooms()</code>方法打印当前的<code>numberOfRooms</code>值，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">printNumberOfRooms</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The number of rooms is <span class="subst">\(numberOfRooms)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法没有返回值。然而，没有返回值的方法具有隐式的返回类型<code>Void</code>，如<a href="./06_Functions.html#functions_without_return_values">无返回值函数</a>中所述。这意味着没有返回值的方法也会返回<code>()</code>，或者说空的元组。</p>
<p>如果在可选值上通过可选链式调用来调用这个方法，该方法的返回类型会是<code>Void?</code>，而不是<code>Void</code>，因为通过可选链式调用得到的返回值都是可选的。这样我们就可以使用<code>if</code>语句来判断能否成功调用<code>printNumberOfRooms()</code>方法，即使方法本身没有定义返回值。通过判断返回值是否为<code>nil</code>可以判断调用是否成功：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> john.residence?.printNumberOfRooms() != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"It was possible to print the number of rooms."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"It was not possible to print the number of rooms."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “It was not possible to print the number of rooms.”</span></span><br></pre></td></tr></table></figure>
<p>同样的，可以据此判断通过可选链式调用为属性赋值是否成功。在上面的<a href="#accessing_properties_through_optional_chaining">通过可选链式调用访问属性</a>的例子中，我们尝试给<code>john.residence</code>中的<code>address</code>属性赋值，即使<code>residence</code>为<code>nil</code>。通过可选链式调用给属性赋值会返回<code>Void?</code>，通过判断返回值是否为<code>nil</code>就可以知道赋值是否成功：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (john.residence?.address = someAddress) != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"It was possible to set the address."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"It was not possible to set the address."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “It was not possible to set the address.”</span></span><br></pre></td></tr></table></figure>
<p><a name="accessing_subscripts_through_optional_chaining"></a></p>
<h2 id="通过可选链式调用访问下标">通过可选链式调用访问下标</h2><p>通过可选链式调用，我们可以在一个可选值上访问下标，并且判断下标调用是否成功。</p>
<blockquote>
<p>注意<br>通过可选链式调用访问可选值的下标时，应该将问号放在下标方括号的前面而不是后面。可选链式调用的问号一般直接跟在可选表达式的后面。</p>
</blockquote>
<p>下面这个例子用下标访问<code>john.residence</code>属性存储的<code>Residence</code>实例的<code>rooms</code>数组中的第一个房间的名称，因为<code>john.residence</code>为<code>nil</code>，所以下标调用失败了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstRoomName = john.residence?[<span class="number">0</span>].name &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The first room name is <span class="subst">\(firstRoomName)</span>."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Unable to retrieve the first room name."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “Unable to retrieve the first room name.”</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，问号直接放在<code>john.residence</code>的后面，并且在方括号的前面，因为<code>john.residence</code>是可选值。</p>
<p>类似的，可以通过下标，用可选链式调用来赋值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">john.residence?[<span class="number">0</span>] = <span class="type">Room</span>(name: <span class="string">"Bathroom"</span>)</span><br></pre></td></tr></table></figure>
<p>这次赋值同样会失败，因为<code>residence</code>目前是<code>nil</code>。</p>
<p>如果你创建一个<code>Residence</code>实例，并为其<code>rooms</code>数组添加一些<code>Room</code>实例，然后将<code>Residence</code>实例赋值给<code>john.residence</code>，那就可以通过可选链和下标来访问数组中的元素：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> johnsHouse = <span class="type">Residence</span>()</span><br><span class="line">johnsHouse.rooms.append(<span class="type">Room</span>(name: <span class="string">"Living Room"</span>))</span><br><span class="line">johnsHouse.rooms.append(<span class="type">Room</span>(name: <span class="string">"Kitchen"</span>))</span><br><span class="line">john.residence = johnsHouse</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstRoomName = john.residence?[<span class="number">0</span>].name &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"The first room name is <span class="subst">\(firstRoomName)</span>."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Unable to retrieve the first room name."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “The first room name is Living Room.”</span></span><br></pre></td></tr></table></figure>
<p><a name="accessing_subscripts_of_optional_type"></a></p>
<h3 id="访问可选类型的下标">访问可选类型的下标</h3><p>如果下标返回可选类型值，比如 Swift 中<code>Dictionary</code>类型的键的下标，可以在下标的结尾括号后面放一个问号来在其可选返回值上进行可选链式调用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> testScores = [<span class="string">"Dave"</span>: [<span class="number">86</span>, <span class="number">82</span>, <span class="number">84</span>], <span class="string">"Bev"</span>: [<span class="number">79</span>, <span class="number">94</span>, <span class="number">81</span>]]</span><br><span class="line">testScores[<span class="string">"Dave"</span>]?[<span class="number">0</span>] = <span class="number">91</span></span><br><span class="line">testScores[<span class="string">"Bev"</span>]?[<span class="number">0</span>]++</span><br><span class="line">testScores[<span class="string">"Brian"</span>]?[<span class="number">0</span>] = <span class="number">72</span></span><br><span class="line"><span class="comment">// "Dave" 数组现在是 [91, 82, 84]，"Bev" 数组现在是 [80, 94, 81]</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中定义了一个<code>testScores</code>数组，包含了两个键值对，把<code>String</code>类型的键映射到一个<code>Int</code>值的数组。这个例子用可选链式调用把<code>&quot;Dave&quot;</code>数组中第一个元素设为<code>91</code>，把<code>&quot;Bev&quot;</code>数组的第一个元素<code>+1</code>，然后尝试把<code>&quot;Brian&quot;</code>数组中的第一个元素设为<code>72</code>。前两个调用成功，因为<code>testScores</code>字典中包含<code>&quot;Dave&quot;</code>和<code>&quot;Bev&quot;</code>这两个键。但是<code>testScores</code>字典中没有<code>&quot;Brian&quot;</code>这个键，所以第三个调用失败。</p>
<p><a name="linking_multiple_levels_of_chaining"></a></p>
<h2 id="连接多层可选链式调用">连接多层可选链式调用</h2><p>可以通过连接多个可选链式调用在更深的模型层级中访问属性、方法以及下标。然而，多层可选链式调用不会增加返回值的可选层级。</p>
<p>也就是说：</p>
<ul>
<li>如果你访问的值不是可选的，可选链式调用将会返回可选值。</li>
<li>如果你访问的值就是可选的，可选链式调用不会让可选返回值变得“更可选”。</li>
</ul>
<p>因此：</p>
<ul>
<li>通过可选链式调用访问一个<code>Int</code>值，将会返回<code>Int?</code>，无论使用了多少层可选链式调用。</li>
<li>类似的，通过可选链式调用访问<code>Int?</code>值，依旧会返回<code>Int?</code>值，并不会返回<code>Int??</code>。</li>
</ul>
<p>下面的例子尝试访问<code>john</code>中的<code>residence</code>属性中的<code>address</code>属性中的<code>street</code>属性。这里使用了两层可选链式调用，<code>residence</code>以及<code>address</code>都是可选值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> johnsStreet = john.residence?.address?.street &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"John's street name is <span class="subst">\(johnsStreet)</span>."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Unable to retrieve the address."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “Unable to retrieve the address.”</span></span><br></pre></td></tr></table></figure>
<p><code>john.residence</code>现在包含一个有效的<code>Residence</code>实例。然而，<code>john.residence.address</code>的值当前为<code>nil</code>。因此，调用<code>john.residence?.address?.street</code>会失败。</p>
<p>需要注意的是，上面的例子中，<code>street</code>的属性为<code>String?</code>。<code>john.residence?.address?.street</code>的返回值也依然是<code>String?</code>，即使已经使用了两层可选链式调用。</p>
<p>如果为<code>john.residence.address</code>赋值一个<code>Address</code>实例，并且为<code>address</code>中的<code>street</code>属性设置一个有效值，我们就能过通过可选链式调用来访问<code>street</code>属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> johnsAddress = <span class="type">Address</span>()</span><br><span class="line">johnsAddress.buildingName = <span class="string">"The Larches"</span></span><br><span class="line">johnsAddress.street = <span class="string">"Laurel Street"</span></span><br><span class="line">john.residence?.address = johnsAddress</span><br><span class="line">	</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> johnsStreet = john.residence?.address?.street &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"John's street name is <span class="subst">\(johnsStreet)</span>."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Unable to retrieve the address."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “John's street name is Laurel Street.”</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，因为<code>john.residence</code>包含一个有效的<code>Residence</code>实例，所以对<code>john.residence</code>的<code>address</code>属性赋值将会成功。</p>
<p><a name="chaining_on_methods_with_optional_return_values"></a></p>
<h2 id="在方法的可选返回值上进行可选链式调用">在方法的可选返回值上进行可选链式调用</h2><p>上面的例子展示了如何在一个可选值上通过可选链式调用来获取它的属性值。我们还可以在一个可选值上通过可选链式调用来调用方法，并且可以根据需要继续在方法的可选返回值上进行可选链式调用。</p>
<p>在下面的例子中，通过可选链式调用来调用<code>Address</code>的<code>buildingIdentifier()</code>方法。这个方法返回<code>String?</code>类型的值。如上所述，通过可选链式调用来调用该方法，最终的返回值依旧会是<code>String?</code>类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> buildingIdentifier = john.residence?.address?.buildingIdentifier() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"John's building identifier is <span class="subst">\(buildingIdentifier)</span>."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “John's building identifier is The Larches.”</span></span><br></pre></td></tr></table></figure>
<p>如果要在该方法的返回值上进行可选链式调用，在方法的圆括号后面加上问号即可：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> beginsWithThe =</span><br><span class="line">	john.residence?.address?.buildingIdentifier()?.hasPrefix(<span class="string">"The"</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> beginsWithThe &#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">"John's building identifier begins with \"The\"."</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">"John's building identifier does not begin with \"The\"."</span>)</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “John's building identifier begins with "The".”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>在上面的例子中，在方法的圆括号后面加上问号是因为你要在<code>buildingIdentifier()</code>方法的可选返回值上进行可选链式调用，而不是方法本身。</p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/18_Error_Handling/" itemprop="url">
                第二章-18错误处理（Error Handling）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:09+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/18_Error_Handling/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/18_Error_Handling/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="错误处理（Error_Handling）">错误处理（Error Handling）</h1><hr>
<blockquote>
<p>2.1<br>翻译+校对：<a href="https://github.com/lyojo" target="_blank" rel="external">lyojo</a> <a href="https://github.com/ray16897188" target="_blank" rel="external">ray16897188</a> 2015-10-23<br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a> 2015-10-24</p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#representing_and_throwing_errors">表示并抛出错误</a></li>
<li><a href="#handling_errors">处理错误</a></li>
<li><a href="#specifying_cleanup_actions">指定清理操作</a></li>
</ul>
<p><em>错误处理（Error handling）</em>是响应错误以及从错误中恢复的过程。Swift 提供了在运行时对可恢复错误的抛出、捕获、传递和操作的一流支持。</p>
<p>某些操作无法保证总是执行完所有代码或总是生成有用的结果。可选类型可用来表示值缺失，但是当某个操作失败时，最好能得知失败的原因，从而可以作出相应的应对。</p>
<p>举个例子，假如有个从磁盘上的某个文件读取数据并进行处理的任务，该任务会有多种可能失败的情况，包括指定路径下文件并不存在，文件不具有可读权限，或者文件编码格式不兼容。区分这些不同的失败情况可以让程序解决并处理某些错误，然后把它解决不了的错误报告给用户。</p>
<blockquote>
<p>注意<br>Swift 中的错误处理涉及到错误处理模式，这会用到 Cocoa 和 Objective-C 中的<code>NSError</code>。关于这个类的更多信息请参见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216" target="_blank" rel="external">Using Swift with Cocoa and Objective-C (Swift 2.1)</a> 中的<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-ID10" target="_blank" rel="external">错误处理</a>。</p>
</blockquote>
<p><a name="representing_and_throwing_errors"></a></p>
<p>##表示并抛出错误</p>
<p>在 Swift 中，错误用符合<code>ErrorType</code>协议的类型的值来表示。这个空协议表明该类型可以用于错误处理。</p>
<p>Swift 的枚举类型尤为适合构建一组相关的错误状态，枚举的关联值还可以提供错误状态的额外信息。例如，你可以这样表示在一个游戏中操作自动贩卖机时可能会出现的错误状态：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">VendingMachineError</span>: <span class="title">ErrorType</span> </span>&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">InvalidSelection</span>				     <span class="comment">//选择无效</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">InsufficientFunds</span>(coinsNeeded: <span class="type">Int</span>) <span class="comment">//金额不足</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">OutOfStock</span>			                 <span class="comment">//缺货</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抛出一个错误可以让你表明有意外情况发生，导致正常的执行流程无法继续执行。抛出错误使用<code>throws</code>关键字。例如，下面的代码抛出一个错误，提示贩卖机还需要<code>5</code>个硬币：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw <span class="type">VendingMachineError</span>.<span class="type">InsufficientFunds</span>(coinsNeeded: <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p><a name="handling_errors"></a></p>
<p>##处理错误</p>
<p>某个错误被抛出时，附近的某部分代码必须负责处理这个错误，例如纠正这个问题、尝试另外一种方式、或是向用户报告错误。</p>
<p>Swift 中有<code>4</code>种处理错误的方式。你可以把函数抛出的错误传递给调用此函数的代码、用<code>do-catch</code>语句处理错误、将错误作为可选类型处理、或者断言此错误根本不会发生。每种方式在下面的小节中都有描述。</p>
<p>当一个函数抛出一个错误时，你的程序流程会发生改变，所以重要的是你能迅速识别代码中会抛出错误的地方。为了标识出这些地方，在调用一个能抛出错误的函数、方法或者构造器之前，加上<code>try</code>关键字，或者<code>try?</code>或<code>try!</code>这种变体。这些关键字在下面的小节中有具体讲解。</p>
<blockquote>
<p>注意<br>Swift 中的错误处理和其他语言中用<code>try</code>，<code>catch</code>和<code>throw</code>进行异常处理很像。和其他语言中（包括 Objective-C ）的异常处理不同的是，Swift 中的错误处理并不涉及解除调用栈，这是一个计算代价高昂的过程。就此而言，<code>throw</code>语句的性能特性是可以和<code>return</code>语句相媲美的。</p>
</blockquote>
<p>###用 throwing 函数传递错误</p>
<p>为了表示一个函数、方法或构造器可以抛出错误，在函数声明的参数列表之后加上<code>throws</code>关键字。一个标有<code>throws</code>关键字的函数被称作<em>throwing 函数</em>。如果这个函数指明了返回值类型，<code>throws</code>关键词需要写在箭头（<code>-&gt;</code>）的前面。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">canThrowErrors</span><span class="params">()</span></span> throws -&gt; <span class="type">String</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">cannotThrowErrors</span><span class="params">()</span></span> -&gt; <span class="type">String</span></span><br></pre></td></tr></table></figure>
<p>一个 throwing 函数可以在其内部抛出错误，并将错误传递到函数被调用时的作用域。</p>
<blockquote>
<p>注意<br>只有 throwing 函数可以传递错误。任何在某个非 throwing 函数内部抛出的错误只能在函数内部处理。</p>
</blockquote>
<p>下面的例子中，<code>VendingMechine</code>类有一个<code>vend(itemNamed:)</code>方法，如果请求的物品不存在、缺货或者花费超过了投入金额，该方法就会抛出一个相应的<code>VendingMachineError</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> price: <span class="type">Int</span></span><br><span class="line">	<span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VendingMachine</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> inventory = [</span><br><span class="line">        <span class="string">"Candy Bar"</span>: <span class="type">Item</span>(price: <span class="number">12</span>, <span class="built_in">count</span>: <span class="number">7</span>),</span><br><span class="line">        <span class="string">"Chips"</span>: <span class="type">Item</span>(price: <span class="number">10</span>, <span class="built_in">count</span>: <span class="number">4</span>),</span><br><span class="line">        <span class="string">"Pretzels"</span>: <span class="type">Item</span>(price: <span class="number">7</span>, <span class="built_in">count</span>: <span class="number">11</span>)</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">var</span> coinsDeposited = <span class="number">0</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">dispenseSnack</span><span class="params">(snack: String)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Dispensing <span class="subst">\(snack)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">vend</span><span class="params">(itemNamed name: String)</span></span> throws &#123;</span><br><span class="line">        guard <span class="keyword">var</span> item = inventory[name] <span class="keyword">else</span> &#123;</span><br><span class="line">            throw <span class="type">VendingMachineError</span>.<span class="type">InvalidSelection</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        guard item.<span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            throw <span class="type">VendingMachineError</span>.<span class="type">OutOfStock</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        guard item.price &lt;= coinsDeposited <span class="keyword">else</span> &#123;</span><br><span class="line">            throw <span class="type">VendingMachineError</span>.<span class="type">InsufficientFunds</span>(coinsNeeded: item.price - coinsDeposited)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        coinsDeposited -= item.price</span><br><span class="line">        --item.<span class="built_in">count</span></span><br><span class="line">        inventory[name] = item</span><br><span class="line">        dispenseSnack(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>vend(itemNamed:)</code>方法的实现中使用了<code>guard</code>语句来提前退出方法，确保在购买某个物品所需的条件中，有任一条件不满足时，能提前退出方法并抛出相应的错误。由于<code>throw</code>语句会立即退出方法，所以物品只有在所有条件都满足时才会被售出。</p>
<p>因为<code>vend(itemNamed:)</code>方法会传递出它抛出的任何错误，在你的代码中调用此方法的地方，必须要么直接处理这些错误——使用<code>do-catch</code>语句，<code>try?</code>或<code>try!</code>；要么继续将这些错误传递下去。例如下面例子中，<code>buyFavoriteSnack(_:vendingMachine:)</code>同样是一个 throwing 函数，任何由<code>vend(itemNamed:)</code>方法抛出的错误会一直被传递到<code>buyFavoriteSnack(_:vendingMachine:)</code>函数被调用的地方。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> favoriteSnacks = [</span><br><span class="line">	<span class="string">"Alice"</span>: <span class="string">"Chips"</span>,</span><br><span class="line">	<span class="string">"Bob"</span>: <span class="string">"Licorice"</span>,</span><br><span class="line">	<span class="string">"Eve"</span>: <span class="string">"Pretzels"</span>,</span><br><span class="line">]</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">buyFavoriteSnack</span><span class="params">(person: String, vendingMachine: VendingMachine)</span></span> throws &#123;</span><br><span class="line">	<span class="keyword">let</span> snackName = favoriteSnacks[person] ?? <span class="string">"Candy Bar"</span></span><br><span class="line">	try vendingMachine.vend(itemNamed: snackName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例中，<code>buyFavoriteSnack(_:vendingMachine:)</code>函数会查找某人最喜欢的零食，并通过调用<code>vend(itemNamed:)</code>方法来尝试为他们购买。因为<code>vend(itemNamed:)</code>方法能抛出错误，所以在调用的它时候在它前面加了<code>try</code>关键字。</p>
<p>###用 Do-Catch 处理错误</p>
<p>可以使用一个<code>do-catch</code>语句运行一段闭包代码来处理错误。如果在<code>do</code>子句中的代码抛出了一个错误，这个错误会与<code>catch</code>子句做匹配，从而决定哪条子句能处理它。</p>
<p>下面是<code>do-catch</code>语句的一般形式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    try expression</span><br><span class="line">    statements</span><br><span class="line">&#125; catch pattern <span class="number">1</span> &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; catch pattern <span class="number">2</span> <span class="keyword">where</span> condition &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>catch</code>后面写一个匹配模式来表明这个子句能处理什么样的错误。如果一条<code>catch</code>子句没有指定匹配模式，那么这条子句可以匹配任何错误，并且把错误绑定到一个名字为<code>error</code>的局部常量。关于模式匹配的更多信息请参考 <a href="../chapter3/07_Patterns.html">模式</a>。</p>
<p><code>catch</code>子句不必将<code>do</code>子句中的代码所抛出的每一个可能的错误都作处理。如果所有<code>catch</code>子句都未处理错误，错误就会传递到周围的作用域。然而，错误还是必须要被某个周围的作用域处理的——要么是一个外围的<code>do-catch</code>错误处理语句，要么是一个 throwing 函数的内部。举例来说，下面的代码处理了<code>VendingMachineError</code>枚举类型的全部枚举值，但是所有其它的错误就必须由它周围的作用域处理：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vendingMachine = <span class="type">VendingMachine</span>()</span><br><span class="line">vendingMachine.coinsDeposited = <span class="number">8</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    try buyFavoriteSnack(<span class="string">"Alice"</span>, vendingMachine: vendingMachine)</span><br><span class="line">&#125; catch <span class="type">VendingMachineError</span>.<span class="type">InvalidSelection</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Invalid Selection."</span>)</span><br><span class="line">&#125; catch <span class="type">VendingMachineError</span>.<span class="type">OutOfStock</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Out of Stock."</span>)</span><br><span class="line">&#125; catch <span class="type">VendingMachineError</span>.<span class="type">InsufficientFunds</span>(<span class="keyword">let</span> coinsNeeded) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Insufficient funds. Please insert an additional <span class="subst">\(coinsNeeded)</span> coins."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “Insufficient funds. Please insert an additional 2 coins.”</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，<code>buyFavoriteSnack(_:vendingMachine:)</code>函数在一个<code>try</code>表达式中调用，因为它能抛出错误。如果错误被抛出，相应的执行会马上转移到<code>catch</code>子句中，并判断这个错误是否要被继续传递下去。如果没有错误抛出，<code>do</code>子句中余下的语句就会被执行。</p>
<p>###将错误转换成可选值</p>
<p>可以使用<code>try?</code>通过将错误转换成一个可选值来处理错误。如果在评估<code>try?</code>表达式时一个错误被抛出，那么表达式的值就是<code>nil</code>。例如下面代码中的<code>x</code>和<code>y</code>具有相同的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">someThrowingFunction</span><span class="params">()</span></span> throws -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> x = try? someThrowingFunction()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> y: <span class="type">Int</span>?</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    y = try someThrowingFunction()</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    y = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>someThrowingFunction()</code>抛出一个错误，<code>x</code>和<code>y</code>的值是<code>nil</code>。否则<code>x</code>和<code>y</code>的值就是该函数的返回值。注意，无论<code>someThrowingFunction()</code>的返回值类型是什么类型，<code>x</code>和<code>y</code>都是这个类型的可选类型。例子中此函数返回一个整型，所以<code>x</code>和<code>y</code>是可选整型。</p>
<p>如果你想对所有的错误都采用同样的方式来处理，用<code>try?</code>就可以让你写出简洁的错误处理代码。例如，下面的代码用几种方式来获取数据，如果所有方式都失败了则返回<code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">fetchData</span><span class="params">()</span></span> -&gt; <span class="type">Data</span>? &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> data = try? fetchDataFromDisk() &#123; <span class="keyword">return</span> data &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> data = try? fetchDataFromServer() &#123; <span class="keyword">return</span> data &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="禁用错误传递">禁用错误传递</h3><p>有时你知道某个 throwing 函数实际上在运行时是不会抛出错误的，在这种情况下，你可以在表达式前面写<code>try!</code>来禁用错误传递，这会把调用包装在一个断言不会有错误抛出的运行时断言中。如果实际上抛出了错误，你会得到一个运行时错误。</p>
<p>例如，下面的代码使用了<code>loadImage(_:)</code>函数，该函数从给定的路径加载图片资源，如果图片无法载入则抛出一个错误。在这种情况下，因为图片是和应用绑定的，运行时不会有错误抛出，所以适合禁用错误传递：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> photo = try! loadImage(<span class="string">"./Resources/John Appleseed.jpg"</span>)</span><br></pre></td></tr></table></figure>
<p><a name="specifying_cleanup_actions"></a></p>
<p>##指定清理操作</p>
<p>可以使用<code>defer</code>语句在即将离开当前代码块时执行一系列语句。该语句让你能执行一些必要的清理工作，不管是以何种方式离开当前代码块的——无论是由于抛出错误而离开，还是由于诸如<code>return</code>或者<code>break</code>的语句。例如，你可以用<code>defer</code>语句来确保文件描述符得以关闭，以及手动分配的内存得以释放。</p>
<p><code>defer</code>语句将代码的执行延迟到当前的作用域退出之前。该语句由<code>defer</code>关键字和要被延迟执行的语句组成。延迟执行的语句不能包含任何控制转移语句，例如<code>break</code>或是<code>return</code>语句，或是抛出一个错误。延迟执行的操作会按照它们被指定时的顺序的相反顺序执行——也就是说，第一条<code>defer</code>语句中的代码会在第二条<code>defer</code>语句中的代码被执行之后才执行，以此类推。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">processFile</span><span class="params">(filename: String)</span></span> throws &#123;</span><br><span class="line">    <span class="keyword">if</span> exists(filename) &#123;</span><br><span class="line">        <span class="keyword">let</span> file = open(filename)</span><br><span class="line">        defer &#123;</span><br><span class="line">            close(file)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> line = try file.readline() &#123;</span><br><span class="line">            <span class="comment">// 处理文件。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// close(file) 会在这里被调用，即作用域的最后。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码使用一条<code>defer</code>语句来确保<code>open(_:)</code>函数有一个相应的对<code>close(_:)</code>函数的调用。</p>
<blockquote>
<p>注意<br>即使没有涉及到错误处理，你也可以使用<code>defer</code>语句。</p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/">&laquo;</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/4/">&raquo;</a>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="https://avatars2.githubusercontent.com/u/14305708?v=3&s=460" alt="terry" itemprop="image"/>
          <p class="site-author-name" itemprop="name">terry</p>
        </div>
        <p class="site-description motion-element" itemprop="description">terry yang's blog | java | scala | bi</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">110</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">5</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">9</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-next-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yangwei8888" target="_blank">github</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/microsoftgoogles" target="_blank">weibo</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/run-zhi-38" target="_blank">zhihu</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">terry</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  

    <script type="text/javascript">
      var disqus_shortname = 'yangwei888';
      var disqus_identifier = 'page/3/index.html';
      var disqus_title = '';
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
