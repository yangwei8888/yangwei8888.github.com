<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="terry yang's blog | java | scala | bi" />



  <meta name="keywords" content="Hexo,next" />



  <link rel="alternate" href="/atom.xml" title="yosita" type="application/atom+xml" />



  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="terry yang&apos;s blog | java | scala | bi">
<meta property="og:type" content="website">
<meta property="og:title" content="yosita">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="yosita">
<meta property="og:description" content="terry yang&apos;s blog | java | scala | bi">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="yosita">
<meta name="twitter:description" content="terry yang&apos;s blog | java | scala | bi">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>

  <title> yosita </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  

  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?953e46480b0a75d01aaf6d872cc77099";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">yosita</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/python_start/" itemprop="url">
                Python 开发指南
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/python_start/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/python_start/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h4 id="版本依赖">版本依赖</h4><p>目前 Python SDK 只支持 Python 2，Python 3 的支持正在开发中。</p>
<h4 id="使用_virtualenv">使用 virtualenv</h4><p>如果您不需要使用 <a href="https://virtualenv.pypa.io/" target="_blank" rel="external">virtualenv</a>，可以跳过这一步。</p>
<p>使用 <a href="https://virtualenv.pypa.io/" target="_blank" rel="external">virtualenv</a> 可以创建一个与系统隔离的 Python 环境，在其中安装的第三方模块版本不会与系统自带的或者其他项目中的模块冲突。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">virtualenv leancloud-demo</span><br><span class="line"><span class="built_in">cd</span> leancloud-demo</span><br><span class="line"><span class="built_in">source</span> bin/activate</span><br></pre></td></tr></table></figure>
<p>之后您在当前 shell 中安装的第三方模块，都只会保存在当前项目目录下。</p>
<p>virtualenv 的更详细使用方法请参考<a href="https://virtualenv.pypa.io/en/latest/" target="_blank" rel="external">官方文档</a>。</p>
<h4 id="安装">安装</h4><p>可以选择使用 <a href="https://pip.pypa.io" target="_blank" rel="external">pip</a> 或者 <a href="https://pythonhosted.org/setuptools/easy_install.html" target="_blank" rel="external">easy_install</a> 来安装 LeanCloud SDK：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install leancloud-sdk</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">easy_install leancloud-sdk</span><br></pre></td></tr></table></figure>
<h4 id="初始化">初始化</h4><p>创建应用后，可以在 <a href="/app.html?appid=#/key">控制台 - 应用设置</a> 里面找到应用对应的 id 和 key。</p>
<p>在使用 Leancloud Python SDK 之前，需要使用 id 和 key 对 SDK 进行初始化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> leancloud</span><br><span class="line"></span><br><span class="line">leancloud.init(<span class="string">'&#123;&#123;appid&#125;&#125;'</span>, <span class="string">'&#123;&#123;appkey&#125;&#125;'</span>)</span><br></pre></td></tr></table></figure>
<h4 id="使用">使用</h4><p>接下来就可以存储数据了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> leancloud <span class="keyword">import</span> Object</span><br><span class="line"><span class="keyword">from</span> leancloud <span class="keyword">import</span> LeanCloudError</span><br><span class="line"></span><br><span class="line">TestObject= Object.extend(<span class="string">'TestObject'</span>)</span><br><span class="line">test_object = TestObject()</span><br><span class="line">test_object.set(<span class="string">'foo'</span>, <span class="string">'bar'</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    test_object.save()</span><br><span class="line"><span class="keyword">except</span> LeanCloudError, e:</span><br><span class="line">    <span class="keyword">print</span> e</span><br></pre></td></tr></table></figure>
<p>大功告成，访问 <a href="/data.html?appid=#/TestObject">控制台 - 数据管理</a> 可以看到上面创建的 TestObject 的相关数据。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/realtime_rest_api/" itemprop="url">
                实时通信 REST API 使用指南
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/realtime_rest_api/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/realtime_rest_api/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="实时通信_REST_API_使用指南">实时通信 REST API 使用指南</h1><h2 id="对话数据操作">对话数据操作</h2><p>你可以通过 REST API 对对话（相应的聊天室、群组或单聊等）进行操作，例如提前创建聊天室，关联聊天室到其他数据实体。LeanCloud 实时通信系统采用透明的设计，对话数据在 LeanCloud 系统中是普通的数据表，表名为 <code>_Conversation</code>，你可以直接调用 <a href="./rest_api.html#对象-1">数据存储相关的 API 进行数据操作</a>。<code>_Conversation</code> 表 包含一些内置的关键字段定义了对话的属性、成员等，你可以在 <a href="./realtime_v2.html#对话_Conversation_">实时通信概览 - 对话</a> 了解。</p>
<h3 id="创建一个对话">创建一个对话</h3><p>创建一个对话即在 <code>_Conversation</code> 表中创建一条记录。对于没有使用过实时通信服务的新用户， <code>_Conversation</code> 表会在第一条记录创建后出现。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST \</span><br><span class="line">  -H <span class="string">"X-LC-Id: &#123;&#123;appid&#125;&#125;"</span> \</span><br><span class="line">  -H <span class="string">"X-LC-Key: &#123;&#123;appkey&#125;&#125;"</span> \</span><br><span class="line">  -H <span class="string">"Content-Type: application/json"</span> \</span><br><span class="line">  <span class="operator">-d</span> <span class="string">'&#123;"name":"My Private Room","m": ["BillGates", "SteveJobs"]&#125;'</span> \</span><br><span class="line">  https://api.leancloud.cn/<span class="number">1.1</span>/classes/_Conversation</span><br></pre></td></tr></table></figure>
<p>上面的例子会创建一个最简单的对话，包括两个 client ID 为 BillGates 和 SteveJobs 的初始成员。对话创建成功会返回 objectId，即实时通信中的对话 ID，客户端就可以通过这个 ID 发送消息了。</p>
<p>常见的开放聊天室的场景，需要通过 REST API 预先创建聊天室，并把对话 ID 与应用内的某个对象关联（如视频、比赛等）。创建开放聊天室只需要包含一个 <strong>tr</strong> 参数，设置为 true 即可。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST \</span><br><span class="line">  -H <span class="string">"X-LC-Id: &#123;&#123;appid&#125;&#125;"</span> \</span><br><span class="line">  -H <span class="string">"X-LC-Key: &#123;&#123;appkey&#125;&#125;"</span> \</span><br><span class="line">  -H <span class="string">"Content-Type: application/json"</span> \</span><br><span class="line">  <span class="operator">-d</span> <span class="string">'&#123;"name": "OpenConf","tr": true&#125;'</span> \</span><br><span class="line">  https://api.leancloud.cn/<span class="number">1.1</span>/classes/_Conversation</span><br></pre></td></tr></table></figure>
<p>系统对话通常也需要通过 REST API 预先创建，创建时需要设置关键的 <code>sys</code> 属性：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST \</span><br><span class="line">  -H <span class="string">"X-LC-Id: &#123;&#123;appid&#125;&#125;"</span> \</span><br><span class="line">  -H <span class="string">"X-LC-Key: &#123;&#123;appkey&#125;&#125;"</span> \</span><br><span class="line">  -H <span class="string">"Content-Type: application/json"</span> \</span><br><span class="line">  <span class="operator">-d</span> <span class="string">'&#123;"name": "Notification Channel","sys": true&#125;'</span> \</span><br><span class="line">  https://api.leancloud.cn/<span class="number">1.1</span>/classes/_Conversation</span><br></pre></td></tr></table></figure>
<h3 id="增删普通对话成员">增删普通对话成员</h3><p>你可以通过 REST API 操作对话数据的 <strong>m</strong> 字段来实现成员的增删。m  字段是一个数组字段，使用数组的操作符进行修改。</p>
<p>增加一个 client id 为 LarryPage 的用户到已有（以对话 id 5552c0c6e4b0846760927d5a 为例）对话：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT \</span><br><span class="line">  -H <span class="string">"X-LC-Id: &#123;&#123;appid&#125;&#125;"</span> \</span><br><span class="line">  -H <span class="string">"X-LC-Key: &#123;&#123;appkey&#125;&#125;"</span> \</span><br><span class="line">  -H <span class="string">"Content-Type: application/json"</span> \</span><br><span class="line">  <span class="operator">-d</span> <span class="string">'&#123;"m": &#123;"__op":"AddUnique","objects":["LarryPage"]&#125;&#125;'</span> \</span><br><span class="line">  https://api.leancloud.cn/<span class="number">1.1</span>/classes/_Conversation/<span class="number">5552</span>c0c6e4b0846760927d5a</span><br></pre></td></tr></table></figure>
<p>将不再活跃的 SteveJobs 清除出对话（以对话 id 5552c0c6e4b0846760927d5a 为例）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT \</span><br><span class="line">  -H <span class="string">"X-LC-Id: &#123;&#123;appid&#125;&#125;"</span> \</span><br><span class="line">  -H <span class="string">"X-LC-Key: &#123;&#123;appkey&#125;&#125;"</span> \</span><br><span class="line">  -H <span class="string">"Content-Type: application/json"</span> \</span><br><span class="line">  <span class="operator">-d</span> <span class="string">'&#123;"m": &#123;"__op":"Remove","objects":["SteveJobs"]&#125;&#125;'</span> \</span><br><span class="line">  https://api.leancloud.cn/<span class="number">1.1</span>/classes/_Conversation/<span class="number">5552</span>c0c6e4b0846760927d5a</span><br></pre></td></tr></table></figure>
<p>对 <code>_Conversation</code> 表的查询等其他操作与普通表完全一致，可以参考 <a href="./rest_api.html#查询">REST API - 查询</a> 的相应说明，这里不再赘述。</p>
<h2 id="获取聊天记录">获取聊天记录</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET \</span><br><span class="line">  -H <span class="string">"X-LC-Id: &#123;&#123;appid&#125;&#125;"</span> \</span><br><span class="line">  -H <span class="string">"X-LC-Key: &#123;&#123;appkey&#125;&#125;"</span> \</span><br><span class="line">  https://leancloud.cn/<span class="number">1.1</span>/rtm/messages/logs</span><br></pre></td></tr></table></figure>
<h3 id="获取某个对话的聊天记录">获取某个对话的聊天记录</h3><table>
<thead>
<tr>
<th>参数</th>
<th>约束</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>convid</td>
<td><strong>必须</strong></td>
<td>对话 id</td>
</tr>
<tr>
<td>max_ts</td>
<td>可选</td>
<td>查询起始的时间戳，返回小于这个时间(不包含)的记录。默认是当前时间。</td>
</tr>
<tr>
<td>msgid</td>
<td>可选</td>
<td>起始的消息 id，与 max_ts 一起作为查询的起点。</td>
</tr>
<tr>
<td>limit</td>
<td>可选</td>
<td>返回条数限制，可选，默认 100 条，最大 1000 条。</td>
</tr>
<tr>
<td>peerid</td>
<td>可选</td>
<td>查看者id（签名参数）</td>
</tr>
<tr>
<td>nonce</td>
<td>可选</td>
<td>签名随机字符串（签名参数）</td>
</tr>
<tr>
<td>signature_ts</td>
<td>可选</td>
<td>签名时间戳（签名参数）</td>
</tr>
<tr>
<td>signature</td>
<td>可选</td>
<td>签名时间戳（签名参数）</td>
</tr>
</tbody>
</table>
<p>为了保证获取聊天记录的安全性，可以开启签名认证（控制台 &gt; <strong>应用选项</strong> &gt; <strong>聊天推送</strong> &gt;<br><strong>聊天记录查询签名认证</strong>）。了解更详细的签名规则请参考 <a href="realtime_v2.html#开启对话签名">聊天签名方法</a>。签名参数仅在开启应用选项后有效，如果没有开启选项，就不需要传签名参数。</p>
<p>签名采用 Hmac-sha1 算法，输出字节流的十六进制字符串 (hex dump)，签名的 key 必须是应用的 master key，签名的消息格式如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">appid:</span><span class="string">peerid:</span><span class="string">convid:</span><span class="string">nonce:</span>signature_ts</span><br></pre></td></tr></table></figure>
<p>返回数据格式，JSON 数组，按消息记录从新到旧排序。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    "<span class="attribute">timestamp</span>": <span class="value"><span class="number">1408008498571</span></span>,</span><br><span class="line">    "<span class="attribute">conv-id</span>":   <span class="value"><span class="string">"219946ef32e40c515d33ae6975a5c593"</span></span>,</span><br><span class="line">    "<span class="attribute">data</span>":      <span class="value"><span class="string">"今天天气不错！"</span></span>,</span><br><span class="line">    "<span class="attribute">from</span>":      <span class="value"><span class="string">"u111872755_9d0461adf9c267ae263b3742c60fa"</span></span>,</span><br><span class="line">    "<span class="attribute">msg-id</span>":    <span class="value"><span class="string">"vdkGm4dtRNmhQ5gqUTFBiA"</span></span>,</span><br><span class="line">    "<span class="attribute">is-conv</span>":   <span class="value"><span class="literal">true</span></span>,</span><br><span class="line">    "<span class="attribute">is-room</span>":   <span class="value"><span class="literal">false</span></span>,</span><br><span class="line">    "<span class="attribute">to</span>":        <span class="value"><span class="string">"5541c02ce4b0f83f4d44414e"</span></span>,</span><br><span class="line">    "<span class="attribute">bin</span>":       <span class="value"><span class="literal">false</span></span>,</span><br><span class="line">    "<span class="attribute">from-ip</span>":   <span class="value"><span class="string">"202.117.15.217"</span></span><br><span class="line">  </span>&#125;,</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>以上返回字段的说明如下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>conv-id</td>
<td>用于查询的对话 id</td>
</tr>
<tr>
<td>from</td>
<td>消息来自 id</td>
</tr>
<tr>
<td>data</td>
<td>消息内容</td>
</tr>
<tr>
<td>timestamp</td>
<td>消息到达服务器的 Unix 时间戳（毫秒）</td>
</tr>
<tr>
<td>msg-id</td>
<td>消息 id</td>
</tr>
<tr>
<td>is-conv</td>
<td>是否是 v2 中对话模型的消息</td>
</tr>
<tr>
<td>from-ip</td>
<td>消息的来源 IP</td>
</tr>
<tr>
<td>ack-at</td>
<td>消息接收者返回的确认到达服务器的 Unix 时间戳（毫秒）</td>
</tr>
</tbody>
</table>
<h3 id="获取某个用户发送的聊天记录">获取某个用户发送的聊天记录</h3><p>此接口仅支持 master key <a href="rest_api.html#更安全的鉴权方式">鉴权认证</a>，建议仅在服务端使用。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>约束</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>from</td>
<td><strong>必须</strong></td>
<td>发送人 id</td>
</tr>
<tr>
<td>max_ts</td>
<td>可选</td>
<td>查询起始的时间戳，返回小于这个时间（不包含）的记录。默认是当前时间。</td>
</tr>
<tr>
<td>msgid</td>
<td>可选</td>
<td>起始的消息 id，与 max_ts 一起作为查询的起点。</td>
</tr>
<tr>
<td>limit</td>
<td>可选</td>
<td>返回条数限制，默认 100 条，最大 1000 条。</td>
</tr>
</tbody>
</table>
<h3 id="获取应用的所有聊天记录">获取应用的所有聊天记录</h3><p>此接口仅支持 master key <a href="rest_api.html#更安全的鉴权方式">鉴权认证</a>，建议仅在服务端使用</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>约束</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>max_ts</td>
<td>可选</td>
<td>查询起始的时间戳，返回小于这个时间（不包含）的记录。默认是 <strong>当前时间</strong>。</td>
</tr>
<tr>
<td>msgid</td>
<td>可选</td>
<td>起始的消息 id，与 max_ts 一起作为查询的起点。</td>
</tr>
<tr>
<td>limit</td>
<td>可选</td>
<td>返回条数限制，默认 100 条，最大 1000 条。</td>
</tr>
</tbody>
</table>
<h3 id="获取系统对话中某个特定用户与系统的消息记录">获取系统对话中某个特定用户与系统的消息记录</h3><p>获取系统对话中某个特定用户与系统的消息记录，需要按照一定的规则构建 <code>convid</code> 参数，构建规则为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">md5</span><span class="params">([系统对话 id] + <span class="string">":"</span> + [用户 Client ID])</span></span></span><br></pre></td></tr></table></figure>
<p>即将系统对话 ID 加半角冒号（<code>:</code>）与用户 ID 拼接后取 MD5 。</p>
<h2 id="删除聊天记录">删除聊天记录</h2><p>删除一条指定的聊天历史记录，必须采用 master key 授权，所以不建议在客户端使用此接口。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -X DELETE \</span><br><span class="line">  -H <span class="string">"X-LC-Id: &#123;&#123;appid&#125;&#125;"</span> \</span><br><span class="line">  -H <span class="string">"X-LC-Key: &#123;&#123;masterkey&#125;&#125;,master"</span> \</span><br><span class="line">  -G \</span><br><span class="line">  --data-urlencode <span class="string">'convid=219946ef32e40c515d33ae6975a5c593'</span> \</span><br><span class="line">  --data-urlencode <span class="string">'msgid=PESlY'</span> \</span><br><span class="line">  --data-urlencode <span class="string">'timestamp=1408008498571'</span> \</span><br><span class="line">  https://leancloud.cn/<span class="number">1.1</span>/rtm/messages/logs</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>convid</td>
<td>对话 id</td>
</tr>
<tr>
<td>msgid</td>
<td>消息 id</td>
</tr>
<tr>
<td>timestamp</td>
<td>消息时间戳</td>
</tr>
</tbody>
</table>
<h3 id="构建对话_ID">构建对话 ID</h3><p>实时通信中 convid 的构建规则为：目前版本中，convid 即对话 ID。</p>
<p>对早期版本来说：</p>
<ul>
<li>对点对点通信，convid 为所有对话参与者的 peer id <strong>排序</strong> 后以半角冒号（:）分隔，做 md5 所得。如对话参与者 peer id 为 <code>u1234</code> 和 <code>u0988</code>，那么对话 ID 为 <code>bcd26a54e98687390b0abb4d83683d4b</code>。</li>
<li>对群组功能，convid 即群组 ID。</li>
</ul>
<h2 id="取未读消息数">取未读消息数</h2><p>您可以从服务器端通过 REST API 调用获取实时通信中，某个 Client ID 的未读消息数。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET \</span><br><span class="line">  -H <span class="string">"X-LC-Id: &#123;&#123;appid&#125;&#125;"</span> \</span><br><span class="line">  -H <span class="string">"X-LC-Key: &#123;&#123;appkey&#125;&#125;"</span> \</span><br><span class="line">  https://leancloud.cn/<span class="number">1.1</span>/rtm/messages/unread/CLIENT_ID</span><br></pre></td></tr></table></figure>
<p>返回：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;"<span class="attribute">count</span>": <span class="value"><span class="number">4</span></span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过_REST_API_发消息">通过 REST API 发消息</h2><p>我们目前提供 REST API 允许向一个已有对话发送消息。</p>
<p><strong>注意</strong>，由于这个接口的管理性质，当你通过这个接口发送消息时，我们不会检查 <strong>from_peer</strong> 是否有权限给这个对话发送消息，而是统统放行，请谨慎使用这个接口。<br>如果你在应用中使用了我们内部定义的 <a href="./realtime_v2.html#消息_Message_">富媒体消息格式</a>，在发送消息时 <strong>message</strong> 字段需要遵守一定的格式要求，下文 <a href="./realtime_rest_api.html#富媒体消息格式说明">富媒体消息格式说明</a> 中将详细说明。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST \</span><br><span class="line">  -H <span class="string">"X-LC-Id: &#123;&#123;appid&#125;&#125;"</span> \</span><br><span class="line">  -H <span class="string">"X-LC-Key: &#123;&#123;masterkey&#125;&#125;,master"</span> \</span><br><span class="line">  -H <span class="string">"Content-Type: application/json"</span> \</span><br><span class="line">  <span class="operator">-d</span> <span class="string">'&#123;"from_peer": "1a", "message": "helloworld", "conv_id": "...", "transient": false&#125;'</span> \</span><br><span class="line">  https://leancloud.cn/<span class="number">1.1</span>/rtm/messages</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>约束</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>from_peer</td>
<td></td>
<td>消息的发件人 id</td>
</tr>
<tr>
<td>conv_id</td>
<td></td>
<td>发送到对话 id</td>
</tr>
<tr>
<td>transient</td>
<td>可选</td>
<td>是否为暂态消息（<strong>由于向后兼容的考虑，默认为 true</strong>，请注意设置这个值。）</td>
</tr>
<tr>
<td>message</td>
<td></td>
<td>消息内容（这里的消息内容的本质是字符串，但是我们对字符串内部的格式没有做限定，<br>理论上开发者可以随意发送任意格式，只要大小不超过 5 KB 限制即可。）</td>
</tr>
<tr>
<td>no_sync</td>
<td>可选</td>
<td>默认情况下消息会被同步给在线的 from_peer 用户的客户端，设置为 true 禁用此功能。</td>
</tr>
</tbody>
</table>
<p>返回说明：</p>
<p>默认情况下发送消息 API 使用异步的方式，调用后直接返回空结果 <code>{}</code>。</p>
<p>对早期版本的实时通信，可以使用 to_peers（数组）或 group_id 参数分别发消息到用户或群组。</p>
<h3 id="给系统对话发消息">给系统对话发消息</h3><p>利用 REST API 给通过系统对话给用户发消息时，除了 conv_id 需要设置为对应系统对话的 ID 以外，还需要设置 to_peers（数组）指定实际接收消息的 Client ID。</p>
<p>目前你可以在一次调用中传入至多 20 个 Client ID。</p>
<h3 id="富媒体消息格式说明">富媒体消息格式说明</h3><p>富媒体消息的参数格式相对于普通文本来说，仅仅是将 message 参数换成了一个 JSON <strong>字符串</strong>。</p>
<blockquote>
<p>注意：由于 LeanCloud 实时通信中所有的消息都是文本，所以这里发送 JSON 结构时<strong>需要首先序列化成字符串</strong>。</p>
</blockquote>
<h4 id="文本消息">文本消息</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -X <span class="keyword">POST</span> \</span><br><span class="line">  -<span class="keyword">H</span> <span class="string">"X-LC-Id: &#123;&#123;appid&#125;&#125;"</span> \</span><br><span class="line">  -<span class="keyword">H</span> <span class="string">"X-LC-Key: &#123;&#123;masterkey&#125;&#125;,master"</span> \</span><br><span class="line">  -<span class="keyword">H</span> <span class="string">"Content-Type: application/json"</span> \</span><br><span class="line">  -<span class="keyword">d</span> '&#123;<span class="string">"from_peer"</span>: <span class="string">"1a"</span>, <span class="string">"message"</span>: <span class="string">"&#123;\"</span>_lctype\<span class="string">":-1,\"</span>_lctext\<span class="string">":\"</span>这是一个纯文本消息\<span class="string">",\"</span>_lcattrs\<span class="string">":&#123;\"</span>a\<span class="string">":\"</span>_lcattrs 是用来存储用户自定义的一些键值对\<span class="string">"&#125;&#125;"</span>, <span class="string">"conv_id"</span>: <span class="string">"..."</span>, <span class="string">"transient"</span>: false&#125;' \</span><br><span class="line">  https:<span class="comment">//leancloud.cn/1.1/rtm/messages</span></span><br></pre></td></tr></table></figure>
<p>发送文本消息可以按照以上的格式进行，参数说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>约束</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>_lctype</code></td>
<td></td>
<td>富媒体消息的类型<br><br><pre>文本消息 -1<br>图像　　 -2<br>音频　　 -3<br>视频　　 -4<br>地理位置 -5<br>通用文件 -6</pre></td>
</tr>
<tr>
<td><code>_lctext</code></td>
<td></td>
<td>富媒体消息的文　字说明</td>
</tr>
<tr>
<td><code>_lcattrs</code></td>
<td></td>
<td>JSON 字符串，用来给开发者存储自定义属性。</td>
</tr>
<tr>
<td><code>_lcfile</code></td>
<td></td>
<td>如果是包含了文件（图像，音频，视频，通用文件）的消息 ，<br><code>_lcfile</code> 就包含了它的文件实体的相关信息。</td>
</tr>
<tr>
<td><code>url</code></td>
<td></td>
<td>文件在上传之后的物理地址</td>
</tr>
<tr>
<td><code>objId</code></td>
<td>可选</td>
<td>文件对应的在 _File 表里面的 objectId</td>
</tr>
<tr>
<td><code>metaData</code></td>
<td>可选</td>
<td>文件的元数据</td>
</tr>
</tbody>
</table>
<p><strong>以上参数针对所有富媒体消息都有效</strong>。</p>
<h4 id="图像消息">图像消息</h4><p>在新版本的聊天中，支持了内建的富媒体消息格式，以下针对整个消息体 JSON 格式化之后的参数说明，例如如下的图像消息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"_lctype"</span>:    -<span class="number">2</span>,                    <span class="comment">//必要参数</span></span><br><span class="line">  <span class="string">"_lctext"</span>:    <span class="string">"图像的文字说明"</span>,</span><br><span class="line">  <span class="string">"_lcattrs"</span>: &#123;</span><br><span class="line">    <span class="string">"a"</span>:        <span class="string">"_lcattrs 是用来存储用户自定义的一些键值对"</span>,</span><br><span class="line">    <span class="string">"b"</span>:        <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"c"</span>:        <span class="number">12</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"_lcfile"</span>: &#123;</span><br><span class="line">    <span class="string">"url"</span>:      <span class="string">"http://ac-p2bpmgci.clouddn.com/246b8acc-2e12-4a9d-a255-8d17a3059d25"</span>, <span class="comment">//必要参数</span></span><br><span class="line">    <span class="string">"objId"</span>:    <span class="string">"54699d87e4b0a56c64f470a4//文件对应的AVFile.objectId"</span>,</span><br><span class="line">    <span class="string">"metaData"</span>: &#123;</span><br><span class="line">      <span class="string">"name"</span>:   <span class="string">"IMG_20141223.jpeg"</span>,   <span class="comment">//图像的名称</span></span><br><span class="line">      <span class="string">"format"</span>: <span class="string">"png"</span>,                 <span class="comment">//图像的格式</span></span><br><span class="line">      <span class="string">"height"</span>: <span class="number">768</span>,                   <span class="comment">//单位：像素</span></span><br><span class="line">      <span class="string">"width"</span>:  <span class="number">1024</span>,                  <span class="comment">//单位：像素</span></span><br><span class="line">      <span class="string">"size"</span>:   <span class="number">18</span>                     <span class="comment">//单位：b</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是完整版的格式，如果想简单的发送一个 URL 可以参照以下格式：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">_lctype</span>": <span class="value">-<span class="number">2</span></span>,</span><br><span class="line">  "<span class="attribute">_lcfile</span>": <span class="value">&#123;</span><br><span class="line">    "<span class="attribute">url</span>":   <span class="value"><span class="string">"http://ac-p2bpmgci.clouddn.com/246b8acc-2e12-4a9d-a255-8d17a3059d25"</span></span><br><span class="line">  </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="音频消息">音频消息</h4><p>与图像类似，音频格式的完整格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"_lctype"</span>:      -<span class="number">3</span>,</span><br><span class="line">  <span class="string">"_lctext"</span>:      <span class="string">"这是一个音频消息"</span>,</span><br><span class="line">  <span class="string">"_lcattrs"</span>: &#123;</span><br><span class="line">    <span class="string">"a"</span>:          <span class="string">"_lcattrs 是用来存储用户自定义的一些键值对"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"_lcfile"</span>: &#123;</span><br><span class="line">    <span class="string">"url"</span>:        <span class="string">"http://ac-p2bpmgci.clouddn.com/246b8acc-2e12-4a9d-a255-8d17a3059d25"</span>,</span><br><span class="line">    <span class="string">"objId"</span>:      <span class="string">"54699d87e4b0a56c64f470a4//文件对应的AVFile.objectId"</span>,</span><br><span class="line">    <span class="string">"metaData"</span>: &#123;</span><br><span class="line">      <span class="string">"name"</span>:     <span class="string">"我的滑板鞋.wav"</span>,</span><br><span class="line">      <span class="string">"format"</span>:   <span class="string">"wav"</span>,</span><br><span class="line">      <span class="string">"duration"</span>: <span class="number">26</span>,    <span class="comment">//单位：秒</span></span><br><span class="line">      <span class="string">"size"</span>:     <span class="number">2738</span>   <span class="comment">//单位：b</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简略版：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">_lctype</span>": <span class="value">-<span class="number">3</span></span>,</span><br><span class="line">  "<span class="attribute">_lcfile</span>": <span class="value">&#123;</span><br><span class="line">    "<span class="attribute">url</span>":   <span class="value"><span class="string">"http://www.somemusic.com/x.mp3"</span></span><br><span class="line">  </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="视频消息">视频消息</h4><p>完整版：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"_lctype"</span>:      -<span class="number">4</span>,</span><br><span class="line">  <span class="string">"_lctext"</span>:      <span class="string">"这是一个视频消息"</span>,</span><br><span class="line">  <span class="string">"_lcattrs"</span>: &#123;</span><br><span class="line">    <span class="string">"a"</span>:          <span class="string">"_lcattrs 是用来存储用户自定义的一些键值对"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"_lcfile"</span>: &#123;</span><br><span class="line">    <span class="string">"url"</span>:        <span class="string">"http://ac-p2bpmgci.clouddn.com/99de0f45-171c-4fdd-82b8-1877b29bdd12"</span>,</span><br><span class="line">    <span class="string">"objId"</span>:      <span class="string">"54699d87e4b0a56c64f470a4"</span>, <span class="comment">//文件对应的 AVFile.objectId</span></span><br><span class="line">    <span class="string">"metaData"</span>: &#123;</span><br><span class="line">      <span class="string">"name"</span>:     <span class="string">"录制的视频.mov"</span>,</span><br><span class="line">      <span class="string">"format"</span>:   <span class="string">"avi"</span>,</span><br><span class="line">      <span class="string">"duration"</span>: <span class="number">168</span>,      <span class="comment">//单位：秒</span></span><br><span class="line">      <span class="string">"size"</span>:     <span class="number">18689</span>     <span class="comment">//单位：b</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简略版：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">_lctype</span>": <span class="value">-<span class="number">4</span></span>,</span><br><span class="line">  "<span class="attribute">_lcfile</span>": <span class="value">&#123;</span><br><span class="line">    "<span class="attribute">url</span>":   <span class="value"><span class="string">"http://www.somevideo.com/Y.flv"</span></span><br><span class="line">  </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="通用文件消息">通用文件消息</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">_lctype</span>": <span class="value">-<span class="number">6</span></span>,</span><br><span class="line">  "<span class="attribute">_lctext</span>": <span class="value"><span class="string">"这是一个普通文件类型"</span></span>,</span><br><span class="line">  "<span class="attribute">_lcattrs</span>": <span class="value">&#123;</span><br><span class="line">    "<span class="attribute">a</span>":     <span class="value"><span class="string">"_lcattrs 是用来存储用户自定义的一些键值对"</span></span><br><span class="line">  </span>&#125;</span>,</span><br><span class="line">  "<span class="attribute">_lcfile</span>": <span class="value">&#123;</span><br><span class="line">    "<span class="attribute">url</span>":   <span class="value"><span class="string">"http://www.somefile.com/jianli.doc"</span></span>,</span><br><span class="line">    "<span class="attribute">name</span>":  <span class="value"><span class="string">"我的简历.doc"</span></span>,</span><br><span class="line">    "<span class="attribute">size</span>":  <span class="value"><span class="number">18689</span>          //单位：b</span><br><span class="line">  </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>简略版：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">_lctype</span>": <span class="value">-<span class="number">6</span></span>,</span><br><span class="line">  "<span class="attribute">_lcfile</span>": <span class="value">&#123;</span><br><span class="line">    "<span class="attribute">url</span>":   <span class="value"><span class="string">"http://www.somefile.com/jianli.doc"</span></span>,</span><br><span class="line">    "<span class="attribute">name</span>":  <span class="value"><span class="string">"我的简历.doc"</span></span><br><span class="line">  </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="地理位置消息">地理位置消息</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">_lctype</span>":     <span class="value">-<span class="number">5</span></span>,</span><br><span class="line">  "<span class="attribute">_lctext</span>":     <span class="value"><span class="string">"这是一个地理位置消息"</span></span>,</span><br><span class="line">  "<span class="attribute">_lcattrs</span>": <span class="value">&#123;</span><br><span class="line">    "<span class="attribute">a</span>":         <span class="value"><span class="string">"_lcattrs 是用来存储用户自定义的一些键值对"</span></span><br><span class="line">  </span>&#125;</span>,</span><br><span class="line">  "<span class="attribute">_lcloc</span>": <span class="value">&#123;</span><br><span class="line">    "<span class="attribute">longitude</span>": <span class="value"><span class="number">23.2</span></span>,</span><br><span class="line">    "<span class="attribute">latitude</span>":  <span class="value"><span class="number">45.2</span></span><br><span class="line">  </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>简略版：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">_lctype</span>":     <span class="value">-<span class="number">5</span></span>,</span><br><span class="line">  "<span class="attribute">_lcloc</span>": <span class="value">&#123;</span><br><span class="line">    "<span class="attribute">longitude</span>": <span class="value"><span class="number">23.2</span></span>,</span><br><span class="line">    "<span class="attribute">latitude</span>":  <span class="value"><span class="number">45.2</span></span><br><span class="line">  </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取暂态对话的在线人数">获取暂态对话的在线人数</h2><p>你可以通过这个 API 获得暂态对话的在线人数。由于暂态对话没有成员列表支持，所以通常使用这个 API 获得当前的在线人数。出于性能的考虑，这个 API 有一定的缓存时间，仅用作粗略计数。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>gid</code></td>
<td>暂态对话的 id</td>
</tr>
</tbody>
</table>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET \</span><br><span class="line">  -H <span class="string">"X-LC-Id: &#123;&#123;appid&#125;&#125;"</span> \</span><br><span class="line">  -H <span class="string">"X-LC-Key: &#123;&#123;appkey&#125;&#125;"</span> \</span><br><span class="line">  https://leancloud.cn/<span class="number">1.1</span>/rtm/transient_group/onlines?gid=...</span><br></pre></td></tr></table></figure>
<p>返回：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;"<span class="attribute">result</span>": <span class="value"><span class="number">0</span></span>&#125;</span><br></pre></td></tr></table></figure>
<p>这个 API 也可以用于获取早期版本开放群组的在线人数。</p>
<h2 id="查询在线状态">查询在线状态</h2><p>在线状态查询 API 可以一次至多查询 20 个 Client ID 当前是否在线：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST \</span><br><span class="line">  -H <span class="string">"X-LC-Id: &#123;&#123;appid&#125;&#125;"</span> \</span><br><span class="line">  -H <span class="string">"X-LC-Key: &#123;&#123;masterkey&#125;&#125;,master"</span> \</span><br><span class="line">  -H <span class="string">"Content-Type: application/json"</span> \</span><br><span class="line">  <span class="operator">-d</span> <span class="string">'&#123;"peers": ["7u", "8b", "3h", ...]&#125;'</span> \</span><br><span class="line">  https://leancloud.cn/<span class="number">1.1</span>/rtm/online</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>peers</td>
<td>要查询的 ID 列表</td>
</tr>
</tbody>
</table>
<p>返回：</p>
<p>在线的 ID 列表</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;"<span class="attribute">results</span>":<span class="value">[<span class="string">"7u"</span>]</span>&#125;</span><br></pre></td></tr></table></figure>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/realtime_v2/" itemprop="url">
                实时通信服务总览
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/realtime_v2/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/realtime_v2/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="实时通信服务总览">实时通信服务总览</h1><p>实时通信服务是 LeanCloud 消息服务中的重要一环。你不但可以为应用加入实时聊天、私信等常用功能，还能实现游戏对战等实时互动功能。</p>
<p>目前，我们提供 Android、iOS、JavaScript、Windows Phone 四个主要平台的客户端 SDK，也提供了一些 Demo 帮助你快速入门：</p>
<ul>
<li><p>iOS 聊天应用：</p>
<ul>
<li><a href="https://github.com/leancloud/LeanMessage-Demo" target="_blank" rel="external">LeanMessageDemo iOS 版</a> (推荐)</li>
<li><a href="https://github.com/leancloud/leanchat-ios" target="_blank" rel="external">LeanChat iOS 版</a></li>
</ul>
</li>
<li><p>Android 聊天应用：</p>
<ul>
<li><a href="https://github.com/leancloud/LeanMessage-Demo" target="_blank" rel="external">LeanMessageDemo Android 版</a> (推荐)</li>
<li><a href="https://github.com/leancloud/leanchat-android" target="_blank" rel="external">LeanChat Android 版</a></li>
</ul>
</li>
<li><p>JavaScript 聊天应用</p>
<ul>
<li><a href="http://leancloud.github.io/js-realtime-sdk/demo/demo2/" target="_blank" rel="external">聊天 Demo</a> (可与 iOS/Android 版 LeanMessageDemo 通信)</li>
<li><a href="https://github.com/leancloud/js-realtime-sdk/tree/master/demo" target="_blank" rel="external">Demo 源码</a></li>
</ul>
</li>
</ul>
<p>关于这些项目的更多介绍、截图预览，可见 <a href="https://github.com/leancloud/leancloud-demos" target="_blank" rel="external">LeanCloud Demos</a> 。</p>
<p>目前新版本实时通信服务接口与旧版本并不兼容，不能互相通信。我们推荐所有新用户直接使用新版本。已有的旧版本用户可以继续参考 <a href="realtime.html">v1 版本文档</a>，我们仍然会对已有版本提供支持，并可能在未来提供无缝的迁移方案。已经发布的旧版本用户不会在功能、资源等各个方面受到任何影响，请放心使用。</p>
<h2 id="功能和特性">功能和特性</h2><p>LeanCloud 实时通信服务定位于完美实现网络层的通讯能力，其设计目标聚焦在：</p>
<ul>
<li><strong>快捷</strong><br><br>LeanCloud 云端要能支持上亿终端同时在线，并且消息传递延时需要严格控制在毫秒以内。</li>
<li><strong>灵活</strong><br><br>既要为完全依托 LeanCloud 平台的开发者考虑，也要为自有账户系统的用户设计：如果用户自己有完备的后台和账户系统，应该完全不用暴露内部数据就能使用我们的服务。而且，消息通知的手段要多样化，要让开发者有更多定制的能力。譬如聊天时对方不在线，应该能走「消息推送（Push Notification）」通道来及时提醒对方，并允许开发者对推送内容进行「私人定制」等等。</li>
<li><strong>安全</strong><br><br>除了简单的 appId 和 secretKey 之外，还应该赋予开发者更多的安全控制能力，来保证聊天通道的私密性。</li>
</ul>
<p>LeanCloud 实时通信服务的特性主要有：</p>
<ul>
<li><strong>与账户系统解耦合</strong><br><br>任何终端用户要加入聊天，只需要提供一个唯一标识自己的 clientId 即可，这样可以尽量避免自有账户系统的应用数据暴露，也可以促使通信服务专注做好底层的「信使」角色；</li>
<li><strong>多账号登录</strong><br><br>支持单个设备多个账号、单个账号多个设备同时登录，实时消息同步到所有设备。</li>
<li><strong>完整的聊天功能</strong><br><br>支持单聊、群聊、聊天室等不同聊天形式，并且具备完善的群组管理功能。</li>
<li><strong>支持富媒体、自定义类型消息</strong><br><br>支持文本、图片、音频、视频和地理位置等多种格式的富媒体消息，并且开发者还可方便地自定义扩展。</li>
<li><strong>离线消息推送</strong><br><br>消息在对方离线时，会自动通过 <a href="#离线推送通知">消息推送</a> 来及时送达对方，并且推送的消息文本可以由开发者自己控制。</li>
<li><strong>敏感词过滤</strong><br><br>实时消息中出现的敏感词，会自动被过滤掉；对于部分 VIP 客户，我们还允许自定义仅属于自己应用的敏感词列表。</li>
<li><strong>聊天记录保存在云端</strong><br><br>聊天记录自动保存在云端，允许开发者自由获取。</li>
<li><strong>第三方操作鉴权机制</strong><br><br>为了保证信道的安全，也给开发者最大的控制自由，我们提供了操作鉴权的机制：开发者使用自己的服务器来充当鉴权服务器，对消息流向进行「许可控制」。对于消息路由过程中的重要操作（譬如登录、开启对话、邀请加入群组、从群组踢出某人等），实时消息 SDK 在发送请求之前，会先到鉴权服务器获得操作签名，LeanCloud 云端会验证签名有效性并完全按照鉴权结果来对操作放行或拒绝。</li>
<li><strong>系统账号、机器人 Hook 和公众号后台</strong><br><br>支持系统中的小助手、机器人和公众号等场景，方便用户将实时通信系统和自己已有的系统无缝集成，支持二次开发机器人和消息后台。</li>
</ul>
<p>我们提供几个层面用户接口：</p>
<ul>
<li>原生的 Android、iOS、Windows Phone 和 Web (JavaScript) 语言的客户端 SDK</li>
<li>帮助开发者完成后台管理和服务器端相关功能的 REST API</li>
<li>部署在 LeanCloud 环境中的云引擎 Hook 便于开发者修改默认的系统行为</li>
<li>可以实时监控在线用户数、消息数的开发者控制台</li>
</ul>
<h2 id="核心概念">核心概念</h2><h3 id="ClientID、用户和登录">ClientID、用户和登录</h3><p>实时通信服务中的每一个终端称为一个 client。client 拥有一个在应用内唯一标识自己的 id。这个 id 由应用自己定义，必须是不多于 64 个字符的字符串。在大部分场合，client 都可以对应到应用中的某个「用户」，但是并不是只有真的用户才能做为 client，你完全可以把一个探测器当成一个 client，把它收集到的数据通过实时通信服务广播给更多「人」。</p>
<p>默认情况下，LeanCloud 通信服务允许一个 clientId 在多个不同的设备上登录，也允许一个设备上有多个 clientId 同时登录。如果使用场景中需要限制用户只在一处登录，可以在登录时明确设置当前设备的 tag，<br>当 LeanCloud 检测到同一个 tag 的设备出现冲突时，会自动踢出已存在设备上的登录状态。开发者可以根据自己的应用场景选择合适的使用方式。</p>
<p>使用 LeanCloud 实时通信 SDK 完成登录后，开发者就不必关心网络连接等状态，SDK 会自动为开发者保持连接状态，并根据网络状态自动重连。对于 Android 平台，我们使用常驻后台的服务保持在线状态；对于 iOS 和 Windows Phone<br>等平台，我们会在应用仍在前台时保持连接，当应用退到后台时，自动断开连接再激活平台原生的推送服务。</p>
<h4 id="在线状态">在线状态</h4><p>我们目前在 SDK 和 REST API 上提供主动查询的机制帮助开发者查询目标用户的在线状态。</p>
<h3 id="对话（Conversation）">对话（Conversation）</h3><p>用户登录之后，与其他人进行消息沟通，即为开启了一个对话（Conversation）。开始聊天之前，需要先创建或者加入一个对话，然后再邀请其他人进来，之后所有参与者在这个对话内进行交流。所有消息都是由某一个 client 发往一个「对话」。</p>
<p>系统每创建一个对话，就会在云端的 <code>_Conversation</code> 表中增加一条记录，可以进入控制台 &gt; <strong>应用</strong> &gt; <strong>存储</strong> &gt; <strong>数据</strong> 来查看该数据。</p>
<p><code>_Conversation</code> 表中字段名与对话的各个属性的对应关系为：</p>
<table>
<thead>
<tr>
<th>表字段</th>
<th>属性名</th>
<th>类型</th>
<th>约束</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>attr</strong></td>
<td>attributes</td>
<td>Object</td>
<td>可选</td>
<td>自定义属性，供开发者扩展使用。</td>
</tr>
<tr>
<td><strong>objectId</strong></td>
<td>conversationId</td>
<td>String</td>
<td></td>
<td>对话 id（只读），由云端为该对话生成的一个全局唯一的 id。</td>
</tr>
<tr>
<td><strong>c</strong></td>
<td>creator</td>
<td>String</td>
<td></td>
<td>对话创建者的 clientId（只读）</td>
</tr>
<tr>
<td><strong>lm</strong></td>
<td>lastMessageAt</td>
<td>Date</td>
<td></td>
<td>对话中最后一条消息的发送或接收时间</td>
</tr>
<tr>
<td><strong>m</strong></td>
<td>members</td>
<td>Array</td>
<td></td>
<td>对话的所有参与者</td>
</tr>
<tr>
<td><strong>mu</strong></td>
<td>mute</td>
<td>Array</td>
<td></td>
<td>将对话设为静音的参与者，这部分参与者不会收到推送。<br>（仅针对 iOS 以及 Windows Phone 用户有效）</td>
</tr>
<tr>
<td><strong>name</strong></td>
<td>name</td>
<td>String</td>
<td>可选</td>
<td>对话的名字，可为群组命名。</td>
</tr>
<tr>
<td><strong>tr</strong></td>
<td>transient</td>
<td>Boolean</td>
<td>可选</td>
<td>是否为暂态对话</td>
</tr>
<tr>
<td><strong>sys</strong></td>
<td>system</td>
<td>Boolean</td>
<td>可选</td>
<td>是否是系统对话</td>
</tr>
<tr>
<td><strong>unique</strong></td>
<td>unique</td>
<td>Boolean</td>
<td>可选</td>
<td>内部字段，标记根据成员原子创建的对话</td>
</tr>
</tbody>
</table>
<p>除了在各平台的 SDK 里面可以调用 API 创建对话外，我们也提供 <a href="./realtime_rest_api.html#通过_REST_API_创建_更新_删除对话数据">REST API</a> 可以让大家预先建立对话：对话的信息存储在 _Conversation 表中，你可以直接通过 <a href="./rest_api.html#%E5%AF%B9%E8%B1%A1-1">数据存储相关的 REST API</a> 对其进行操作。</p>
<p>这里要特别讨论一下<strong>单聊</strong>、<strong>群聊</strong>、<strong>聊天室</strong>、<strong>公众号</strong>等概念。</p>
<ul>
<li><strong>单聊</strong><br><br>就是两个 client 之间的对话，公开与否（能否让其他人看到这个对话存在）由应用层自己控制。一般而言，它是私密的，并且加入新的成员之后，会切换到新的对话（当然，也可以依然不离开当前对话，这一点还是由应用层来决定）。</li>
<li><strong>群聊</strong><br><br>就是两个（含）以上 client 之间的对话，一般而言，可以添加和删除成员，并且会赋予群聊一个名字。随着成员的减少，群聊也可能只有两个甚至一个成员（成员的多少并不是区分群聊和单聊的关键）。群聊能否公开（譬如支持名字搜索），由应用自己决定。</li>
<li><strong>聊天室</strong><br><br>很多应用使用的开放聊天室、弹幕、网页直播等都可以抽象成「聊天室」，它与群聊类似，都是多人参与的群组，但是也有一些区别：其一在于聊天室人数可能远大于群聊人数；其二在于聊天室强调的是在线人数，所有参与者进入聊天界面就算加入，关闭界面就算退出，所以聊天室不需要离线消息和推送通知，在线成员数比具体成员列表更有意义。</li>
<li><strong>公众号、机器人</strong><br><br>对全部或者部分用户可见（由应用开发者决定）的账号，开发者可以利用这个账号给用户发广播通知，用户也可以通过这个账号反馈内容给开发者，开发者可以在后台看到消息，也可以利用 API 或 Web Hook 将自己的业务系统集成进来。</li>
</ul>
<p>我们将以上场景抽象为「对话」这一概念，并分离出以下类型的对话：</p>
<h4 id="普通对话（Normal_Conversation）">普通对话（Normal Conversation）</h4><p>这是我们经常会用到的「对话」，单聊和群聊都通过它来实现。我们建议开发者将单聊/群聊、私密/公开等属性存入到 Conversation.attributes 之中，在应用层进行区别对待。</p>
<p>为了提高系统的灵活性，我们允许多个对话保持相同的成员，因此创建对话时系统总是默认创建新的对话。<br>如果开发者希望使用固定的对话，可以在创建对话时设置相应 SDK 上的 <code>unique</code> 选项，系统将查找对应成员相同且 <code>unique</code> 选项为 true 的对话，如果找到即返回已有的对话，如果没有则自动创建。<br>（注意，这种方式查找的对话仅对已经使用 <code>unique</code> 选项的对话有效，并且创建对话时不会触发 <code>_Conversation</code> 表在云引擎上的 <code>beforeSave</code> 等 hook）</p>
<h4 id="暂态对话（Transient_Conversation）">暂态对话（Transient Conversation）</h4><p>这是专门用来处理「聊天室」这种需求的。与普通对话一样，它也支持创建、加入/踢出成员等操作，消息记录会被保存并可供获取；但根据应用场景，暂态对话与普通对话在功能上存在一定的取舍，具体为：</p>
<ul>
<li>没有固定成员概念，加入即为成员，断线即为退出</li>
<li>暂态对话不支持查询成员列表，你可以通过相关 API 查询在线人数。</li>
<li>暂态对话不支持离线消息、离线推送通知等功能。</li>
<li>暂态对话没有成员加入、离开的通知。</li>
<li>一个用户一次登录只能加入一个暂态对话，加入新的暂态对话后会自动离开旧的暂态对话。</li>
<li>加入暂态对话后半小时内断网重连会自动加入原暂态对话，超过这个时间则需要重新加入。</li>
</ul>
<h4 id="系统对话（System_Conversation）">系统对话（System Conversation）</h4><p>这是用于实现机器人、公众号、服务账号等场景的对话，也可以用作发送应用内通知的通道。这种对话具有以下特点：</p>
<ul>
<li>在 <code>_Conversation</code> 表中，以 <code>sys</code> 为 <code>true</code> 来标记（<code>m</code>列在系统对话中将被忽略）</li>
<li>该对话没有成员，开发者维护用户和系统对话的订阅关系</li>
<li>开发者可以通过 REST API 以系统对话的渠道给指定的用户发消息</li>
<li>用户可以给系统对话发消息，消息和相关信息会存储在数据存储中的 <code>_SysMessage</code> 表，并不会被其他订阅用户收到</li>
<li>开发者可以配置 Web Hook 地址接收用户发给系统对话的消息，并利用 REST API 发消息回复</li>
<li>在 SDK 层面，系统对话的接口与普通对话完全一致</li>
</ul>
<h4 id="对话类型比较">对话类型比较</h4><table>
<thead>
<tr>
<th>功能点</th>
<th>普通对话</th>
<th>暂态对话</th>
<th>系统对话</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>表字段</strong><span>*</span></td>
<td>m</td>
<td>tr</td>
<td>sys</td>
</tr>
<tr>
<td><strong>成员管理</strong></td>
<td>成员体现在 m 字段上，<br>持久化保存</td>
<td>没有持久化的成员数据，<br>随时加入随时退出</td>
<td>没有成员概念，无法加入和退出，<br>开发者维护订阅关系</td>
</tr>
<tr>
<td><strong>收发消息</strong></td>
<td>只有成员可以收发消息</td>
<td>所有用户都可以发消息，<br>当前在线的成员可以收到消息</td>
<td>开发者通过 API 给特定用户发消息，<br>用户发送的消息到达数据库和 Web Hook</td>
</tr>
<tr>
<td><strong>离线消息</strong></td>
<td>支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td><strong>离线推送</strong></td>
<td>支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td><strong>消息记录</strong></td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td><strong>用例</strong></td>
<td>单聊、群聊</td>
<td>聊天室、弹幕、网页实时评论</td>
<td>公众号、机器人、下发加好友通知</td>
</tr>
</tbody>
</table>
<p><span> * </span> 指 <code>_Conversation</code> 系统表中的字段</p>
<h4 id="创建对话">创建对话</h4><p>对话可以通过 SDK 和 <a href="./realtime_rest_api.html#创建一个对话">REST API</a> 创建。</p>
<p>在大部分使用场景中，普通对话通过 SDK 创建，用于最终用户之间自发的通信。<br>暂态对话和系统对话通常和应用中的特定实体绑定，可以通过 REST API 提前创建，通过应用中的业务逻辑<br>把对话 ID 下发给最终用户。</p>
<h3 id="消息（Message）">消息（Message）</h3><p>实时通信服务的消息。我们的消息允许用户一次传输不超过 <strong>5 KB</strong> 的文本数据。在底层实时通信允许开发者传输任何基于文本的消息数据，系统对消息格式没有任何要求，<br>开发者可以在文本协议基础上定义自己的应用层协议。</p>
<p>消息分为「普通消息」和「暂态消息」。LeanCloud 云端对于普通消息会提供接收回执、自动持久化存储、离线推送等功能。<br>但是暂态消息，则不会被自动保存，也不支持延迟接收，离线用户更不会收到推送通知，所以适合用来做控制协议。<br>譬如聊天过程中「某某正在输入中…」这样的状态信息，就适合通过暂态消息来发送，而用户输入的正式消息，则应该用普通消息来发送。</p>
<p>LeanCloud 对普通消息提供「至少一次」的到达保证，并且在官方 SDK 中支持对消息的去重，开发者无需关心。除了基于「推」模型的消息机制，我们还提供消息记录的机制允许<br>SDK 和 REST API 通过「拉」的方式获取任意时间点前的消息。目前 LeanCloud 对消息记录提供永久存储。</p>
<p>开发者可以通过 SDK 或 <a href="./realtime_rest_api.html#通过_REST_API_发消息">REST API</a> 发送消息。<br>SDK 通常用于最终用户发送消息，而 REST API 是开发者从服务器端发送消息的接口。当从 REST API<br>发送消息时，开发者可以指定消息的发送者、对话 ID，对于系统对话还可以指定消息的接收者。</p>
<h4 id="富媒体消息">富媒体消息</h4><p>为了方便开发者的使用，我们提供了几种封装好的基于 JSON 格式的富媒体消息类型（TypedMessage），譬如：</p>
<ul>
<li>文本（TextMessage）</li>
<li>图片（ImageMessage）</li>
<li>音频（AudioMessage）</li>
<li>视频（VideoMessage）</li>
<li>位置（LocationMessage）</li>
</ul>
<p>这些消息类型可最大程度地简化使用步骤，能更好地满足通用需求。开发者也可以基于我们的框架，方便地扩展出自己的消息类型。</p>
<p>这些消息类型的层次关系为：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                                    Message</span><br><span class="line">                                       |<span class="string"></span><br><span class="line">                                  TypedMessage</span><br><span class="line">                                       </span>|</span><br><span class="line">     __________________________________|<span class="string">__________________________________</span><br><span class="line">     </span>|<span class="string">             </span>|<span class="string">            </span>|<span class="string">             </span>|<span class="string">               </span>|<span class="string">           </span>|</span><br><span class="line">TextMessage  ImageMessage  AudioMessage  VideoMessage  LocationMessage   。。。</span><br></pre></td></tr></table></figure>
<p>关于这部分消息的格式请参考<br><a href="realtime_rest_api.html#%E5%AF%8C%E5%AA%92%E4%BD%93%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E">《实时通信 REST API - 富媒体消息格式说明》</a>了解。</p>
<h4 id="离线消息">离线消息</h4><p>开发者可以通过 <a href="/messaging.html?appid=#/message/realtime/tool"><strong>控制台</strong> &gt; <strong>消息</strong> &gt; <strong>实时消息</strong> &gt; <strong>帮助</strong></a> 界面查询某个 Client ID 的在线状态和离线消息数。</p>
<p>当用户重新登录后，LeanCloud 提供两种方式进行下发离线消息：</p>
<ol>
<li><strong>默认方式</strong>：服务器端会对每个对话推送至多最近 20 条消息。这部分消息在用户上线后会以新消息的形式到达客户端，对于轻量级的应用这种方式可以满足开发者对离线消息的需求；</li>
<li><strong>未读数量方式</strong>：服务器端会返回离线期间产生未读消息的对话列表及未读消息数，开发者可以根据这个通知拉取离线消息记录收取离线消息，这种方式下开发者对消息的数量可以完全的控制；</li>
</ol>
<h4 id="离线推送通知">离线推送通知</h4><h5 id="静态内容">静态内容</h5><p>对离线的 iOS 和 Windows Phone 用户，每次有离线消息时，我们会触发一个对应平台的推送通知。<br>由于不同平台的不同限制，且用户的消息正文可能还包含上层协议，所以我们允许用户在控制台中为应用设置一个静态的 APNs JSON，推送一条内容固定的通知。</p>
<p>进入 <a href="/messaging.html?appid=#/message/realtime/conf">控制台 &gt;<span class="text-muted">（选择应用）</span>&gt; 消息 &gt; 实时消息 &gt; 设置 &gt; iOS 用户离线推送设置</a>，填入：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"alert"</span>:<span class="string">"您有新的消息"</span>, <span class="string">"badge"</span>:<span class="string">"Increment"</span>&#125;`</span><br></pre></td></tr></table></figure>
<p>注意，<code>Increment</code> 大小写敏感，表示自动增加应用 badge 上的数字计数。清除 badge 的操作请参考 <a href="ios_push_guide.html#清除_Badge">iOS 推送指南 &middot; 清除 badge</a>。</p>
<p><img src="/avos/images/realtime_ios_push.png" alt="image"></p>
<h5 id="动态内容">动态内容</h5><p>如果希望推送通知显示动态内容，比如消息的实际内容，或根据消息内容、对话信息等上下文信息来自定义内容，则需要通过 <a href="#_receiversOffline">云引擎 Hook <code>_receiversOffline</code></a> 来实现。</p>
<h5 id="其他设置">其他设置</h5><p>推送默认使用<strong>生产证书</strong>，你也可以在 JSON 中增加一个 <code>_profile</code> 内部属性来选择实际推送的证书，如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">alert</span>":    <span class="value"><span class="string">"您有一条未读消息"</span></span>,</span><br><span class="line">  "<span class="attribute">_profile</span>": <span class="value"><span class="string">"dev"</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p><code>_profile</code> 属性不会实际推送。</p>
<p>目前，设置界面的推送内容支持部分内置变量，你可以将上下文信息直接设置到推送内容中：</p>
<ul>
<li><code>${convId}</code> 推送相关的对话 ID</li>
<li><code>${timestamp}</code> 触发推送的时间戳（Unix 时间戳）</li>
<li><code>${fromClientId}</code> 消息发送者的 Client ID</li>
</ul>
<p>这部分平台的用户，在完成登录时，SDK 会自动关联当前的 Client ID 和设备。关联的方式是通过设备<strong>订阅</strong>名为 Client ID 的 Channel 实现的。开发者可以在数据存储<br>的 <code>_Installation</code> 表中的 <code>channel</code> 字段查到这组关联关系。在实际离线推送时，系统根据用户 Client ID 找到对应的关联设备进行推送。</p>
<p>另外，由于实时通信触发的推送量比较大，内容单一，这部分记录不会保存到消息菜单的推送记录。</p>
<h4 id="敏感词过滤">敏感词过滤</h4><p>根据政策的要求，我们为多人的普通对话、暂态对话和系统对话进行敏感词过滤。海外节点暂未启用。</p>
<p>过滤的词库由 LeanCloud 提供，命中的敏感词将会被替换为 <code>***</code>。如果开发者的应用中也有固定的词库需要过滤，可以联系我们进行针对应用的定制。</p>
<p>如果开发者有较为复杂的过滤需求，我们推荐使用下文提到的云引擎 hook 来实现过滤，在 hook 中开发者对消息的内容有完全的控制力。</p>
<h2 id="权限和认证">权限和认证</h2><p>为了保证聊天通道的安全，我们设计了签名的概念。默认这一功能是关闭的，你可以在 LeanCloud 应用控制台 &gt; <strong>设置</strong> &gt; <strong>应用选项</strong> 中强制启用签名。启用后，所有的用户登录、新建或加入对话、邀请/踢出对话成员等操作都需要包含签名，这样你可以对聊天过程进行充分的控制。</p>
<p><img src="/avos/images/leanmessage_signature2.png" alt="image"></p>
<ol>
<li>客户端进行登录或新建对话等操作，SDK 会调用 SignatureFactory 的实现，并携带用户信息和用户行为（登录、新建对话或群组操作）请求签名；</li>
<li>应用自有的权限系统，或应用在 LeanCloud 云引擎上的签名程序收到请求，进行权限验证，如果通过则利用下文所述的 <a href="#用户登录的签名">签名算法</a> 生成时间戳、随机字符串和签名返回给客户端；</li>
<li>客户端获得签名后，编码到请求中，发给 LeanCloud 实时通信服务器；</li>
<li>实时通信服务器对请求的内容和签名做一遍验证，确认这个操作是被应用服务器允许的，进而执行后续的实际操作。</li>
</ol>
<p>签名采用 <strong>Hmac-sha1</strong> 算法，输出字节流的十六进制字符串（hex dump）。针对不同的请求，需要拼装不同组合的字符串，加上 UTC timestamp 以及随机字符串作为签名的消息。</p>
<h3 id="云引擎签名范例">云引擎签名范例</h3><p>我们提供了一个运行在 LeanCloud <a href="leanengine_guide-cloudcode.html">云引擎</a> 上的 <a href="https://github.com/leancloud/realtime-messaging-signature-cloudcode" target="_blank" rel="external">签名范例程序</a><br>，它提供了基于 Web Hosting 和云函数两种方式的签名实现，你可以根据实际情况选择自己的实现。</p>
<h3 id="用户登录的签名">用户登录的签名</h3><p>签名采用 ，签名的消息格式如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">appid:</span><span class="string">clientid:</span>:<span class="string">timestamp:</span>nonce</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明<a name="signature-param-table"></a><!--2015-09-04 --></th>
</tr>
</thead>
<tbody>
<tr>
<td>appid</td>
<td>应用的 id</td>
</tr>
<tr>
<td>clientid</td>
<td>登录时使用的 clientId</td>
</tr>
<tr>
<td>timestamp</td>
<td>当前的 UTC 时间距离 unix epoch 的<strong>秒数</strong></td>
</tr>
<tr>
<td>nonce</td>
<td>随机字符串</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意：签名的 key <strong>必须</strong> 是应用的 master key，你可以在应用 &gt; <strong>设置</strong> &gt; <strong>应用 Key</strong> 里找到。<strong>请保护好 master key，不要泄露给任何无关人员。</strong></p>
</blockquote>
<p>开发者可以实现自己的 SignatureFactory，调用远程服务器的签名接口获得签名。如果你没有自己的服务器，可以直接在 LeanCloud 云引擎上通过 <strong>网站托管</strong> 来实现自己的签名接口。在移动应用中直接做签名的作法 <strong>非常危险</strong>，它可能导致你的 <strong>master key</strong> 泄漏。</p>
<h3 id="开启对话签名">开启对话签名</h3><p>新建一个对话的时候，签名的消息格式为：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">appid:</span><span class="string">clientid:</span><span class="string">sorted_member_ids:</span><span class="string">timestamp:</span>nonce</span><br></pre></td></tr></table></figure>
<ul>
<li>appid、clientid、timestamp 和 nonce 的含义 <a href="#signature-param-table">同上</a>。</li>
<li>sorted_member_ids 是以半角冒号（:）分隔、<strong>升序排序</strong> 的 user id，即邀请参与该对话的成员列表。</li>
</ul>
<h3 id="群组功能的签名">群组功能的签名</h3><p>在群组功能中，我们对<strong>加群</strong>、<strong>邀请</strong>和<strong>踢出群</strong>这三个动作也允许加入签名，签名格式是：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">appid:</span><span class="string">clientid:</span><span class="string">convid:</span><span class="string">sorted_member_ids:</span><span class="string">timestamp:</span><span class="string">nonce:</span>action</span><br></pre></td></tr></table></figure>
<ul>
<li>appid、clientid、sorted_member_ids、timestamp 和 nonce  的含义同上。对加入群的情况，这里 sorted_member_ids 是空字符串。</li>
<li>convid - 此次行为关联的对话 id。</li>
<li>action - 此次行为的动作，分为 <strong>add</strong> （加群和邀请）与 <strong>remove</strong> （踢出群）两种，但出于兼容考虑，签名时分别使用常量 <strong>invite</strong> 和 <strong>kick</strong> 来进行表示。</li>
</ul>
<h2 id="云引擎_Hook">云引擎 Hook</h2><p>对于普通消息，如果发送时部分成员不在线，LeanCloud 提供了选项，支持将离线消息以推送形式发送到客户端。但是，推送的内容开发者如果希望进行修改的话，该怎么实现呢？可以使用「云引擎 Hook」！</p>
<p>云引擎 Hook 允许你通过自定义的云引擎函数处理实时通信中的某些事件，修改默认的流程等等。目前开放的 hook 云函数包括：</p>
<ul>
<li><strong>_messageReceived</strong><br><br>消息达到服务器，群组成员已解析完成之后，发送给收件人之前。</li>
<li><strong>_receiversOffline</strong><br><br>消息发送完成，存在离线的收件人。</li>
<li><strong>_conversationStart</strong><br><br>创建对话，在签名校验（如果开启）之后，实际创建之前。</li>
<li><strong>_conversationAdd</strong><br><br>向对话添加成员，在签名校验（如果开启）之后，实际加入之前，包括主动加入和被其他用户加入两种情况。</li>
<li><strong>_conversationRemove</strong><br><br>从对话中踢出成员，在签名校验（如果开启）之后，实际踢出之前，用户自己退出对话不会调用。</li>
</ul>
<h3 id="使用场景">使用场景</h3><p>示例应用 <a href="https://github.com/leancloud/leanchat-android" target="_blank" rel="external">LeanChat</a> 也用了云引擎 Hook 功能来自定义消息推送，通过解析上层消息协议获取消息类型和内容，以 <code>fromPeer</code> 得到发送者的名称，组装成 <code>pushMessage</code>，这样能使推送通知的用户体验更好。可参考 <a href="https://github.com/leancloud/leanchat-cloudcode/blob/master/cloud.js" target="_blank" rel="external">leanchat-cloudcode 代码</a>。</p>
<p>与 conversation 相关的 hook 可以在应用签名之外增加额外的权限判断，控制对话是否允许被建立、某些用户是否允许被加入对话等。你可以用这一 hook 实现黑名单功能。</p>
<h3 id="_messageReceived"><code>_messageReceived</code></h3><p>这个 hook 发生在消息到达 LeanCloud 云端之后。如果是群组消息，我们会解析出所有消息收件人。</p>
<p>你可以通过返回参数控制消息是否需要被丢弃，删除个别收件人，还可以修改消息内容。返回空对象（<code>response.success({})</code>）则会执行系统默认的流程。</p>
<div class="callout callout-info">请注意，在这个 hook 的代码实现的任何分支上<strong>请确保最终会调用 response.success 返回结果</strong>，使得消息可以尽快投递给收件人。这个 hook 将<strong>阻塞发送流程</strong>，因此请尽量减少无谓的代码调用，提升效率。</div>

<p>如果你使用了 LeanCloud 默认提供的富媒体消息格式，云引擎参数中的 <code>content</code> 接收的是 JSON 结构的字符串形式。关于这个结构的详细说明，请参考 <a href="./realtime_rest_api.html#富媒体消息格式说明">实时通信 REST API 指南 - 富媒体消息格式说明</a>。</p>
<h4 id="参数">参数</h4><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>fromPeer</td>
<td>消息发送者的 ID</td>
</tr>
<tr>
<td>convId</td>
<td>消息所属对话的 ID</td>
</tr>
<tr>
<td>toPeers</td>
<td>解析出的对话相关的 Client ID</td>
</tr>
<tr>
<td>transient</td>
<td>是否是 transient 消息</td>
</tr>
<tr>
<td>content</td>
<td>消息体字符串</td>
</tr>
<tr>
<td>receipt</td>
<td>是否要求回执</td>
</tr>
<tr>
<td>timestamp</td>
<td>服务器收到消息的时间戳（毫秒）</td>
</tr>
<tr>
<td>sourceIP</td>
<td>消息发送者的 IP</td>
</tr>
</tbody>
</table>
<h4 id="返回">返回</h4><table>
<thead>
<tr>
<th>参数</th>
<th>约束</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>drop</td>
<td>可选</td>
<td>如果返回真值消息将被丢弃</td>
</tr>
<tr>
<td>code</td>
<td>可选</td>
<td>当 drop 为 true 时可以下发一个应用自定义的整型错误码</td>
</tr>
<tr>
<td>content</td>
<td>可选</td>
<td>修改后的 content，如果不提供则保留原消息。</td>
</tr>
<tr>
<td>toPeers</td>
<td>可选</td>
<td>数组，修改后的收件人，如果不提供则保留原收件人。</td>
</tr>
</tbody>
</table>
<h3 id="_receiversOffline"><code>_receiversOffline</code></h3><p>这个 hook 发生在有收件人离线的情况下，你可以通过它来自定义离线推送行为，包括推送内容、被推送用户或略过推送。你也可以直接在 hook 中触发自定义的推送。发往暂态对话的消息不会触发此 hook。</p>
<h4 id="自定义离线消息推送通知的内容">自定义离线消息推送通知的内容</h4><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">AV<span class="built_in">.</span>Cloud<span class="built_in">.</span><span class="class"><span class="keyword">define</span></span>(<span class="string">'_receiversOffline'</span>, function(request, response) &#123;</span><br><span class="line">    <span class="built_in">var</span> <span class="keyword">params</span> = request<span class="built_in">.</span><span class="keyword">params</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">var</span> json = &#123;</span><br><span class="line">        <span class="comment">// 自增未读消息的数目，不想自增就设为数字</span></span><br><span class="line">        badge: <span class="string">"Increment"</span>,</span><br><span class="line">        sound: <span class="string">"default"</span>,</span><br><span class="line">        <span class="comment">// 使用开发证书</span></span><br><span class="line">        _profile: <span class="string">"dev"</span>,</span><br><span class="line">        <span class="comment">// content 为消息的实际内容</span></span><br><span class="line">        alert: <span class="keyword">params</span><span class="built_in">.</span>content</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">var</span> pushMessage = JSON<span class="built_in">.</span>stringify(json);</span><br><span class="line"></span><br><span class="line">    response<span class="built_in">.</span>success(&#123;<span class="string">"pushMessage"</span>: pushMessage&#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>有关可以在推送内容中加入的内置变量和其他可用设置，请参考 <a href="#离线推送通知">离线推送通知</a>。</p>
<h4 id="参数-1">参数</h4><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>fromPeer</td>
<td>消息发送者 ID</td>
</tr>
<tr>
<td>convId</td>
<td>消息所属对话的 ID</td>
</tr>
<tr>
<td>offlinePeers</td>
<td>数组，离线的收件人列表</td>
</tr>
<tr>
<td>content</td>
<td>消息内容</td>
</tr>
<tr>
<td>timestamp</td>
<td>服务器收到消息的时间戳（毫秒）</td>
</tr>
</tbody>
</table>
<h4 id="返回-1">返回</h4><table>
<thead>
<tr>
<th>参数</th>
<th>约束</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>skip</td>
<td>可选</td>
<td>如果为真将跳过推送（比如已经在云引擎里触发了推送或者其他通知）</td>
</tr>
<tr>
<td>offlinePeers</td>
<td>可选</td>
<td>数组，筛选过的推送收件人。</td>
</tr>
<tr>
<td>pushMessage</td>
<td>可选</td>
<td>推送内容，支持自定义 JSON 结构。</td>
</tr>
<tr>
<td>force</td>
<td>可选</td>
<td>如果为真将强制推送给 offlinePeers 里 mute 的用户，默认 false。</td>
</tr>
</tbody>
</table>
<h3 id="_conversationStart"><code>_conversationStart</code></h3><p>在创建对话时调用，发生在签名验证之后、创建对话之前。</p>
<h4 id="参数-2">参数</h4><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>initBy</td>
<td>由谁发起的 clientId</td>
</tr>
<tr>
<td>members</td>
<td>初始成员数组，包含初始成员</td>
</tr>
<tr>
<td>attr</td>
<td>创建对话时的额外属性</td>
</tr>
</tbody>
</table>
<h4 id="返回-2">返回</h4><table>
<thead>
<tr>
<th>参数</th>
<th>约束</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>reject</td>
<td>可选</td>
<td>是否拒绝，默认为 <strong>false</strong>。</td>
</tr>
<tr>
<td>code</td>
<td>可选</td>
<td>当 reject 为 true 时可以下发一个应用自定义的整型错误码。</td>
</tr>
</tbody>
</table>
<h3 id="_conversationAdd"><code>_conversationAdd</code></h3><p>在将用户加入到对话时调用，发生在签名验证之后、加入对话之前。如果是自己加入，那么 <strong>initBy</strong> 和 <strong>members</strong> 的唯一元素是一样的。</p>
<h4 id="参数-3">参数</h4><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>initBy</td>
<td>由谁发起的 clientId</td>
</tr>
<tr>
<td>members</td>
<td>要加入的成员，数组</td>
</tr>
<tr>
<td>convId</td>
<td>对话 id</td>
</tr>
</tbody>
</table>
<h4 id="返回-3">返回</h4><table>
<thead>
<tr>
<th>参数</th>
<th>约束</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>reject</td>
<td>可选</td>
<td>是否拒绝，默认为 <strong>false</strong>。</td>
</tr>
<tr>
<td>code</td>
<td>可选</td>
<td>当 reject 为 true 时可以下发一个应用自定义的整型错误码。</td>
</tr>
</tbody>
</table>
<h3 id="_conversationRemove"><code>_conversationRemove</code></h3><p>在创建对话时调用，发生在签名验证之后、从对话移除成员之前。移除自己时不会触发这个 hook。</p>
<h4 id="参数-4">参数</h4><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>initBy</td>
<td>由谁发起</td>
</tr>
<tr>
<td>members</td>
<td>要踢出的成员，数组。</td>
</tr>
<tr>
<td>convId</td>
<td>对话 id</td>
</tr>
</tbody>
</table>
<h4 id="返回-4">返回</h4><table>
<thead>
<tr>
<th>参数</th>
<th>约束</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>reject</td>
<td>可选</td>
<td>是否拒绝，默认为 <strong>false</strong>。</td>
</tr>
<tr>
<td>code</td>
<td>可选</td>
<td>当 reject 为 true 时可以下发一个应用自定义的整型错误码。</td>
</tr>
</tbody>
</table>
<h3 id="部署环境">部署环境</h3><p>实时通信的云引擎 Hook 要求云引擎部署在云引擎的 <strong>生产环境</strong>，测试环境仅用于开发者手动调用测试。由于缓存的原因，首次部署的云引擎 Hook 需要至多三分钟来正式生效，后续修改会实时生效。</p>
<p>更多使用详情请参考 <a href="leanengine_guide-cloudcode.html#云函数">云引擎 - 云函数</a>。所有云引擎调用都有默认超时时间和容错机制，在出错情况下系统将按照默认的流程执行后续操作。</p>
<h2 id="Android_开发指南">Android 开发指南</h2><p>参考 <a href="realtime_guide-android.html">Android 实时通信开发指南</a></p>
<h2 id="iOS_开发指南">iOS 开发指南</h2><p>参考 <a href="realtime_guide-ios.html">iOS 实时通信开发指南</a></p>
<h2 id="JavaScript_开发指南">JavaScript 开发指南</h2><p>参考 <a href="js_realtime.html">JavaScript 实时通信开发指南</a>。另外，我们已经开源了 JavaScript  Realtime SDK， 见 <a href="https://github.com/leancloud/js-realtime-sdk" target="_blank" rel="external"> LeanCloud JavaScript Realtime SDK - Github 资源库</a> 。</p>
<h2 id="REST_API">REST API</h2><p>参考 <a href="realtime_rest_api.html">实时通信 REST API</a>。</p>
<h2 id="系统对话">系统对话</h2><p>系统对话可以用于实现机器人自动回复、公众号、服务账号等功能。在我们的 <a href="http://leancloud.github.io/leanmessage-demo/" target="_blank" rel="external">官方聊天 Demo</a> 中就有一个使用系统对话 hook 实现的机器人 MathBot，它能计算用户发送来的数学表达式并返回结果，<a href="https://github.com/leancloud/leanmessage-demo/tree/master/server" target="_blank" rel="external">其服务端源码</a> 可以从 GitHub 上获取。</p>
<h3 id="系统对话消息结构">系统对话消息结构</h3><h4 id="_SysMessage"><code>_SysMessage</code></h4><p>用户发给系统对话的消息会存储在 <code>_SysMessage</code> 表中，各字段含义如下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>convId</td>
<td>消息关联的系统对话 ID</td>
</tr>
<tr>
<td>msgId</td>
<td>消息的内部 ID</td>
</tr>
<tr>
<td>from</td>
<td>发消息用户的 Client ID</td>
</tr>
<tr>
<td>fromIp</td>
<td>发消息用户的 IP</td>
</tr>
<tr>
<td>data</td>
<td>消息内容</td>
</tr>
</tbody>
</table>
<h4 id="Web_Hook">Web Hook</h4><p>开发者可以自定义 Web Hook 来实时接收用户发给系统对话的消息，消息的数据结构与上文所述的 <code>_SysMessage</code> 一致。</p>
<p>当有用户向系统对话发送消息时，我们会通过 HTTP POST 请求将 JSON 格式的数据发送到用户设置的 Web Hook 上。</p>
<p>超时时间为 5 秒，当用户 hook 地址超时没有响应，我们会重试至多 3 次。</p>
<p>发送的消息格式为：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    "<span class="attribute">fromIp</span>":      <span class="value"><span class="string">"121.238.214.92"</span></span>,</span><br><span class="line">    "<span class="attribute">conv</span>": <span class="value">&#123;</span><br><span class="line">      "<span class="attribute">__type</span>":    <span class="value"><span class="string">"Pointer"</span></span>,</span><br><span class="line">      "<span class="attribute">className</span>": <span class="value"><span class="string">"_Conversation"</span></span>,</span><br><span class="line">      "<span class="attribute">objectId</span>":  <span class="value"><span class="string">"55b99ad700b0387b8a3d7bf0"</span></span><br><span class="line">    </span>&#125;</span>,</span><br><span class="line">    "<span class="attribute">msgId</span>":       <span class="value"><span class="string">"nYH9iBSBS_uogCEgvZwE7Q"</span></span>,</span><br><span class="line">    "<span class="attribute">from</span>":        <span class="value"><span class="string">"A"</span></span>,</span><br><span class="line">    "<span class="attribute">bin</span>":         <span class="value"><span class="literal">false</span></span>,</span><br><span class="line">    "<span class="attribute">data</span>":        <span class="value"><span class="string">"你好，sys"</span></span>,</span><br><span class="line">    "<span class="attribute">createdAt</span>": <span class="value">&#123;</span><br><span class="line">      "<span class="attribute">__type</span>":    <span class="value"><span class="string">"Date"</span></span>,</span><br><span class="line">      "<span class="attribute">iso</span>":       <span class="value"><span class="string">"2015-07-30T14:37:42.584Z"</span></span><br><span class="line">    </span>&#125;</span>,</span><br><span class="line">    "<span class="attribute">updatedAt</span>":  <span class="value">&#123;</span><br><span class="line">      "<span class="attribute">__type</span>":   <span class="value"><span class="string">"Date"</span></span>,</span><br><span class="line">      "<span class="attribute">iso</span>":      <span class="value"><span class="string">"2015-07-30T14:37:42.584Z"</span></span><br><span class="line">    </span>&#125;</span><br><span class="line">  </span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="开发者给系统对话发送消息">开发者给系统对话发送消息</h3><p>请参考 <a href="./realtime_rest_api.html#给系统对话发消息">REST API - 给系统对话发消息</a>。</p>
<h2 id="限制">限制</h2><ul>
<li>对于客户端主动发起的操作会按照操作类型限制其频率。发消息操作限制为 <strong>每分钟 60 次</strong>，历史消息查询操作限制为 <strong>每分钟 120 次</strong>，其它类型操作包括加入对话、离开对话、建立/关闭连接等均限制为 <strong>每分钟 30 次</strong>。当调用超过限制时，服务端会丢弃超出的消息。</li>
<li>客户端发送的单条消息大小不得超过 5 KB。</li>
<li>目前单个普通对话的成员上限为 500 个。</li>
</ul>
<h2 id="服务器端错误码说明">服务器端错误码说明</h2><p>实时通信的错误码会以 SDK 异常或 WebSocket 关闭状态码的形式返回给客户端。当出现异常情况时，SDK 会输出状态码到日志里，以下是对部分状态码的简单说明：</p>
<!--2015-10-27 Da Li: add <code style="white-space:nowrap"> to prevent unexpected line wrapping. DO NOT REMOVE -->
<table>
<thead>
<tr>
<th>代码</th>
<th>消息</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0</code></td>
<td></td>
<td>websocket 正常关闭，可能发生在服务器重启，或本地网络异常的情况。SDK 会自动重连，无需人工干预。</td>
</tr>
<tr>
<td><code style="white-space:nowrap">1006</code></td>
<td></td>
<td>websocket 连接非正常关闭，通常见于路由器配置对长连接限制的情况。SDK 会自动重连，无需人工干预。</td>
</tr>
<tr>
<td><code>4100</code></td>
<td><code>APP_NOT_AVAILABLE</code></td>
<td>应用不存在或应用禁用了实时通信服务</td>
</tr>
<tr>
<td><code>4103</code></td>
<td><code>INVALID_LOGIN</code></td>
<td>Client Id 格式错误，超过 64 个字符。</td>
</tr>
<tr>
<td><code>4105</code></td>
<td><code>SESSION_REQUIRED</code></td>
<td>Session 没有打开就发送消息，或执行其他操作。常见的错误场景是调用 open session 后直接发送消息，正确的用法是在 Session 打开的回调里执行。</td>
</tr>
<tr>
<td><code>4107</code></td>
<td><code>READ_TIMEOUT</code></td>
<td>读超时，服务器端长时间没有收到客户端的数据，切断连接。SDK 包装了心跳包的机制，出现此错误通常是网络问题。SDK 会自动重连，无需人工干预。</td>
</tr>
<tr>
<td><code>4108</code></td>
<td><code>LOGIN_TIMEOUT</code></td>
<td>登录超时，连接后长时间没有完成 session open。通常是登录被拒绝等原因，出现此问题可能是使用方式有误，可以 <a href="http://ticket.leancloud.cn/" target="_blank" rel="external">创建工单</a>，由我们技术顾问来给出建议。</td>
</tr>
<tr>
<td><code>4109</code></td>
<td><code>FRAME_TOO_LONG</code></td>
<td>包过长。消息大小超过 5 KB，请缩短消息或者拆分消息。</td>
</tr>
<tr>
<td><code>4110</code></td>
<td><code>INVALID_ORIGIN</code></td>
<td>设置安全域名后，当前登录的域名与安全域名不符合。</td>
</tr>
<tr>
<td><code>4200</code></td>
<td><code>INTERNAL_ERROR</code></td>
<td>服务器内部错误，如果反复出现请收集相关线索并 <a href="http://ticket.leancloud.cn/" target="_blank" rel="external">创建工单</a>，我们会尽快解决。</td>
</tr>
<tr>
<td><code>4201</code></td>
<td><code>SEND_MESSAGE_TIMEOUT</code></td>
<td>通过 API 发送消息超时</td>
</tr>
<tr>
<td><code>4302</code></td>
<td><code style="white-space:nowrap">CONVERSATION_SIGNATURE_FAILED</code></td>
<td>对话相关操作签名错误</td>
</tr>
<tr>
<td><code>4303</code></td>
<td><code>CONVERSATION_NOT_FOUND</code></td>
<td>发送消息，或邀请等操作对应的对话不存在。</td>
</tr>
<tr>
<td><code>4304</code></td>
<td><code>CONVERSATION_FULL</code></td>
<td>对话成员已满，不能再添加。</td>
</tr>
<tr>
<td><code>4305</code></td>
<td><code>CONVERSATION_REJECTED_BY_APP</code></td>
<td>对话操作被应用的云引擎 Hook 拒绝</td>
</tr>
<tr>
<td><code>4306</code></td>
<td><code>CONVERSATION_UPDATE_FAILED</code></td>
<td>更新对话操作失败</td>
</tr>
<tr>
<td><code>4307</code></td>
<td><code>CONVERSATION_READ_ONLY</code></td>
<td>该对话为只读，不能更新或增删成员。</td>
</tr>
<tr>
<td><code>4308</code></td>
<td><code>CONVERSATION_NOT_ALLOWED</code></td>
<td>该对话禁止当前用户发送消息</td>
</tr>
<tr>
<td><code>4401</code></td>
<td><code>INVALID_MESSAGING_TARGET</code></td>
<td>发送消息的对话不存在，或当前用户不在对话中。</td>
</tr>
<tr>
<td><code>4402</code></td>
<td><code>MESSAGE_REJECTED_BY_APP</code></td>
<td>发送的消息被应用的云引擎 Hook 拒绝</td>
</tr>
</tbody>
</table>
<h2 id="常见问题_FAQ">常见问题 FAQ</h2><h3 id="要让单个群组消息进入「免打扰模式」，该如何做">要让单个群组消息进入「免打扰模式」，该如何做</h3><p>对于普通对话的新消息，LeanCloud 实时通信服务有选项支持将消息以 Push Notification 的方式通知当前不在线的成员，但是有时候，这种推送会非常频繁对用户造成干扰。LeanCloud 提供选项，支持让单个用户关闭特定对话的离线消息推送。具体可以看相应平台的开发指南文档。</p>
<h3 id="聊天好友关系如何实现">聊天好友关系如何实现</h3><p>LeanCloud 实时通信服务是完全独立的实时通信业务抽象，专注在实时通信本身，所以实时通信的业务逻辑中，并不含有好友关系，以及对应的聊天用户数据信息（如头像、名称等）。实时通信与其他业务逻辑完全隔离，不耦合，唯一关联的就是 clientId。这样做的好处是显而易见的，比如你可以很容易让匿名用户直接通信，你也可以自定义一些好友逻辑，总之可以做成因为任意逻辑而匹配产生的聊天行为。</p>
<p>当然，如果你想维护一套好友关系，完全可以使用你自己的逻辑，只要存储着每个用户在实时通信中的 clientId 即可。我们推荐使用 LeanCloud 的存储，即 LeanStorage，这样可以结合 LeanCloud 中的 User 相关对象来简单地实现账户系统，以及与之相关的存储，详情可以阅读对应的 SDK 开发指南。</p>
<h3 id="聊天记录的保存时间和条数">聊天记录的保存时间和条数</h3><p>我们暂时不限制用户应用中聊天记录的保存时间和条数。未来如有变化我们会提前通知用户，你也随时可以通过 <a href="./realtime_rest_api.html#获取聊天记录">REST API</a> 将聊天记录同步到自己的服务器上。</p>
<h3 id="聊天消息没有收到">聊天消息没有收到</h3><p>当出现聊天消息没有收到的情况，你可以按照以下思路排查：</p>
<ul>
<li>调用消息记录 API 查看消息是否到达了服务器端</li>
<li>如果只有一个消息接收者，可以检查消息记录中对应条目的 <code>ack-at</code> 字段判断消息是否到达了客户端</li>
<li>在 <a href="/messaging.html?appid=#/message/realtime/tool"><strong>控制台</strong> &gt; <strong>消息</strong> &gt; <strong>实时消息</strong> &gt; <strong>帮助</strong></a> 页面的文本框里输入对应的 Client ID，查看是否在线，以及是否有离线消息。</li>
</ul>
<h3 id="为什么我的_iPhone_收不到离线消息推送">为什么我的 iPhone 收不到离线消息推送</h3><p>请先参考 <a href="#聊天消息没有收到">聊天消息没有收到</a>。在 <a href="/messaging.html?appid=#/message/realtime/conf"><strong>控制台</strong> &gt; <strong>消息</strong> &gt; <strong>实时消息</strong> &gt; <strong>设置</strong> &gt; <strong>iOS 用户离线推送设置</strong> &gt; <strong>推送内容</strong></a> 填写「您有新的未读消息」后，当对方不在线的时候，便会触发一个 APNs 的推送。首先，请确保控制台能向 iOS 推送消息，也即如下图所示的推送能顺利到达 iOS 系统，请参考 <a href="ios_push_guide.html">iOS 推送开发文档</a>。</p>
<p><img src="/avos/images/realtime_faq_push.png" alt="image"></p>
<p>之后，还要确保对方确实是离线，如果对方程序在前台并且网络良好，则不会触发推送。如果对方网络未连接，则下次联网的时候收到回调，也不触发推送。也可以利用控制台实时消息页的用户状态查询来确保对方处于离线状态，如下图。</p>
<p><img src="/avos/images/realtime_faq_console.png" alt="image"></p>
<p>离线消息推送默认用的是生产环境编辑框里上传的证书。所以，调试时可能要上传开发证书，并在推送内容中设置 <code>_profile</code> 属性来选择开发证书推送，如 <code>{&quot;alert&quot;: &quot;你有一条未读消息&quot;, &quot;_profile&quot;: &quot;dev&quot;}</code></p>
<p>检查方法总结如下：</p>
<ul>
<li>检查普通的 iOS 推送是否到达</li>
<li>检查证书设置</li>
<li>在控制台检查接收方是否在离线状态</li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/unity_start/" itemprop="url">
                Unity 开发指南
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/unity_start/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/unity_start/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h4 id="下载_SDK">下载 SDK</h4><p>如果您还没有安装 LeanCloud Unity SDK，请按照 <a href="/docs/sdk_down.html">SDK 下载</a> 下载最新版的 Unity 的 SDK。</p>
<h4 id="导入_SDK">导入 SDK</h4><p>打开 Unity 项目，在 <code>Assets</code> 下创建一个子文件夹，名字可以任意根据您自身的习惯命名，这里暂且命名为 <code>AVOSCloud SDK</code>，如图:</p>
<p><img src="/avos/images/quick_start/unity/unity_quick_start_0.png" alt="创建 SDK 文件夹"></p>
<p>然后，右键单击显示菜单，选择「Import New Assets…」，选择刚才下载好的 Unity 的最新版的 SDK，导入进来：</p>
<p><img src="/avos/images/quick_start/unity//unity_quick_start_1.png" alt="导入 dll 文件"></p>
<p>保存整个项目。</p>
<h4 id="启用_SDK">启用 SDK</h4><p>导入成功之后，在 Unity <code>菜单</code> 中选择 <code>GameObject</code> - <code>Create Empty</code>，创建成功之后单击这个 GameObject，如图：</p>
<p><img src="/avos/images/quick_start/unity/unity_quick_start_2.png" alt="创建 image"></p>
<p>然后在右侧的 <code>Inspector</code> 中单击 <code>Add Component</code>，如图：</p>
<p><img src="/avos/images/quick_start/unity/unity_quick_start_3.png" alt="创建 GameObject"></p>
<p>选择 <code>Scripts</code> - <code>AVOSCloud</code> - <code>AVOSCloud Initialize Behaviour</code></p>
<p><img src="/avos/images/quick_start/unity/unity_quick_start_4.png" alt="Scripts"></p>
<p><img src="/avos/images/quick_start/unity/unity_quick_start_5.png" alt="AVOSCloud"></p>
<p><img src="/avos/images/quick_start/unity/unity_quick_start_6.png" alt="Behaviour"></p>
<h4 id="配置_SDK">配置 SDK</h4><p>为了使 SDK 真正为您所用，需要在刚才导入的 <code>AVOSCloud Initialize Behaviour</code> 的里面配置您自己的 <code>App ID</code> 以及 <code>App Key</code>：</p>
<p><img src="/avos/images/quick_start/unity/unity_quick_start_7.png" alt="创建 GameObject"></p>
<h4 id="运行测试">运行测试</h4><p>回到 Unity，右键 <code>Assets</code> 添加一个 <code>C# Script</code>，命名为 <code>AVOSCloudTest</code>，双击这个脚本，会自动打开 <code>MonoDevelop</code>，在 <code>Update</code> 方法里面添加如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> msg=<span class="built_in">string</span>.Empty;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnGUI</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	GUI.Label (<span class="keyword">new</span> Rect (<span class="number">270</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">80</span>), msg);</span><br><span class="line">	<span class="keyword">if</span> (GUI.Button (<span class="keyword">new</span> Rect (<span class="number">50</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">80</span>), <span class="string">"添加GameScore"</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		AVObject gameScore =<span class="keyword">new</span> AVObject(<span class="string">"GameScore"</span>);</span><br><span class="line">		gameScore[<span class="string">"score"</span>] = <span class="number">1337</span>;</span><br><span class="line">		gameScore[<span class="string">"playerName"</span>] = <span class="string">"Neal Caffrey"</span>;</span><br><span class="line">		gameScore.SaveAsync().ContinueWith(t=&gt;</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">if</span>(!t.IsFaulted)</span><br><span class="line">		   &#123;</span><br><span class="line">			  msg=<span class="string">"保存成功"</span>;</span><br><span class="line">		   &#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后回到 Unity，调试运行：</p>
<p><img src="/avos/images/quick_start/unity/unity_quick_start_8.png" alt="创建 GameObject"></p>
<p>点击按钮 <code>添加GameScore</code>，可以看见 <code>保存成功</code>：</p>
<p><img src="/avos/images/quick_start/unity/unity_quick_start_9.png" alt="创建 GameObject"></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/ios_crashreporting_guide/" itemprop="url">
                iOS 崩溃报告使用指南
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/ios_crashreporting_guide/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/ios_crashreporting_guide/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="iOS_崩溃报告使用指南">iOS 崩溃报告使用指南</h1><p>崩溃报告可以自动收集用户端产生的各种异常崩溃信息，包括完整的调用堆栈、设备信息、应用信息等等。如果还没有安装 LeanCloud iOS SDK，请阅读 <a href="/start.html">快速入门</a> 来获得该 SDK，并在 Xcode 中运行和熟悉示例代码。</p>
<h2 id="启用">启用</h2><p>要启用崩溃报告功能，需要将 AVOSCloudCrashReporting.framework 添加到项目的依赖库列表，然后在 AppDelegate 之中，在 LeanCloud SDK 初始化之前添加如下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enable Crash Reporting</span></span><br><span class="line">[<span class="built_in">AVOSCloudCrashReporting</span> enable];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setup AVOSCloud</span></span><br><span class="line">[<span class="built_in">AVOSCloud</span> setApplicationId:<span class="string">@"&#123;&#123;appid&#125;&#125;"</span> clientKey:<span class="string">@"&#123;&#123;appkey&#125;&#125;"</span>];</span><br></pre></td></tr></table></figure>
<p>崩溃报告打开后，应用的崩溃信息会发送到 LeanCloud 云端，具体内容可在 <a href="/stat.html?appid=#/stat/crashreport">控制台 / 分析 / 错误分析</a> 里看到。</p>
<h2 id="符号化">符号化</h2><p>将应用每个版本的符号文件上传至 LeanCloud，会有助于 LeanCLoud 后台正确解析崩溃堆栈信息，更准确地定位问题，因此这一步骤非常重要。</p>
<p>上传符号文件有两种方式：每次构建应用时自动上传和手动上传。我们推荐使用自动上传，这样开发者就不需要在每次发布版本时，还要记着去上传符号文件。实现符号文件<strong>自动上传</strong>的步骤如下：</p>
<p>安装客户端工具（如果出现权限错误，可以在命令前面加上 <code>sudo</code>）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gem update --system</span><br><span class="line">gem install --no-wrappers -n /usr/<span class="built_in">local</span>/bin leancloud</span><br></pre></td></tr></table></figure>
<p>在应用的 Targets 中，选择 <strong>Build Settings</strong> &gt; <strong>Build Options</strong> &gt; <strong>Debug Information Format</strong>，将其设置为 <strong>DWARF with dSYM File</strong>；再打开 <strong>Build Phases</strong> &gt;<span class="text-muted">（点击 + 号）</span>&gt; <strong>New Run Script Phase</strong>，添加一个 <strong>Run Script</strong> 步骤：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">leancloud upload_symbol \</span><br><span class="line"><span class="operator">-f</span> <span class="string">"<span class="variable">$&#123;DWARF_DSYM_FOLDER_PATH&#125;</span>/<span class="variable">$&#123;DWARF_DSYM_FILE_NAME&#125;</span>"</span> \</span><br><span class="line">-i <span class="string">"&#123;&#123;appid&#125;&#125;"</span> \</span><br><span class="line">-k <span class="string">"&#123;&#123;appkey&#125;&#125;"</span></span><br></pre></td></tr></table></figure>
<p>如果只想在 Archive 发布时运行这个脚本，可以勾选 <strong>Run script only when installing</strong>，这样可以加快调试时 Build 的速度。</p>
<p>要手动上传符号文件，则使用：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">leancloud upload_symbol \</span><br><span class="line"><span class="operator">-f</span> <span class="string">"&lt;dSYM/xcarchive/DWARF 请按下面提示替换本路径&gt;"</span> \</span><br><span class="line">-i <span class="string">"&#123;&#123;appid&#125;&#125;"</span> \</span><br><span class="line">-k <span class="string">"&#123;&#123;appkey&#125;&#125;"</span></span><br></pre></td></tr></table></figure>
<p>符号文件将默认上传到中国节点。如果你的应用使用了中国之外的其他节点，例如美国节点，需要通过 <code>-r</code> 或 <code>--region</code> 选项来设置：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">leancloud upload_symbol -r us \</span><br><span class="line"><span class="operator">-f</span> <span class="string">"&lt;dSYM/xcarchive/DWARF 请按下面提示替换本路径&gt;"</span> \</span><br><span class="line">-i <span class="string">"&#123;&#123;appid&#125;&#125;"</span> \</span><br><span class="line">-k <span class="string">"&#123;&#123;appkey&#125;&#125;"</span></span><br></pre></td></tr></table></figure>
<p>目前支持以下节点：</p>
<ul>
<li><strong>cn</strong>：中国</li>
<li><strong>us</strong>：美国</li>
</ul>
<p>符号文件的存放位置，与你的发布流程有关，具体为：</p>
<ul>
<li><p><strong>xcarchive 文件</strong>：对应用进行 Archive 后会生成一个 .xcarchive 文件，在 Xcode 中打开 <strong>Window</strong> / <strong>Organizer</strong> / <strong>Archives</strong> 选项卡里可以看到它的位置。</p>
</li>
<li><p><strong>dSYM 文件</strong>：一般仅在使用 Release 或 Archiving 构建应用时产生，可以在 /Xcode/DerivedData 文件夹下，与生成的 .app 同级的文件夹里找到。</p>
</li>
<li><p><strong>DWARF 文件</strong>：在路径的最底层，它可以通过 strip 应用生成的二进制文件来获得。</p>
</li>
</ul>
<p>请参考以下路径结构，应用文件名为 Demo.app：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">├── Build</span><br><span class="line">    ├── Intermediates</span><br><span class="line">        ├── ArchiveIntermediates</span><br><span class="line">            └── Demo</span><br><span class="line">                ├── BuildProductsPath</span><br><span class="line">                    └── Release-iphoneos</span><br><span class="line">                        ├── Demo<span class="class">.app</span> -&gt; /Users/admin/Library/Developer/Xcode/DerivedData/Demo-dkvwhbscbgyeoldhsxxzmorfqmyf/Build/Intermediates/ArchiveIntermediates/Demo/InstallationBuildProductsLocation/Applications/Demo<span class="class">.app</span></span><br><span class="line">                        └── Demo<span class="class">.app</span><span class="class">.dSYM</span></span><br><span class="line">                            └── Contents</span><br><span class="line">                                ├── Info<span class="class">.plist</span></span><br><span class="line">                                └── Resources</span><br><span class="line">                                    └── DWARF</span><br><span class="line">                                        └── Demo</span><br></pre></td></tr></table></figure>
<p>如果在发布应用时忘了上传符号文件，可以手动来上传。如果一个崩溃报告没有对应的符号文件，系统会提示要符号化。</p>
<h2 id="测试">测试</h2><p>崩溃报告启用之后，要测试崩溃信息是否能发送到 LeanCloud 云端，可以在 view controller 或 AppDelegate 中添加一个 <code>crash</code> 方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)crash &#123;</span><br><span class="line">    [<span class="built_in">NSException</span> raise:<span class="built_in">NSGenericException</span> format:<span class="string">@"只是测试，模拟一条崩溃信息。"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后把下面的调用代码插入到主 view controller 的 <code>viewDidLoad</code> 方法中，或 AppDelegate 的 <code>application:didFinishLaunchingWithOptions:</code> 方法中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(crash) withObject:<span class="literal">nil</span> afterDelay:<span class="number">5.0</span>];</span><br></pre></td></tr></table></figure>
<p>接下来的步骤：</p>
<ol>
<li>build、run，然后 stop 应用；</li>
<li>在 Home 界面点开应用（不要使用调试器开启应用，因为调试器开启时不会收集崩溃信息）；</li>
<li>等待应用崩溃；</li>
<li>再次运行应用。应用将在启动时自动将崩溃报告发送给 LeanCloud 云端。</li>
</ol>
<p>这时打开应用控制台的 <a href="/stat.html?appid=#/stat/crashreport">错误分析</a>，就会看到刚才的崩溃信息。</p>
<blockquote>
<p>注意：崩溃信息可能会延迟几分钟显示。</p>
</blockquote>
<h2 id="流程">流程</h2><p>使用崩溃报告可以极大地改进应用质量，提升用户体验。我们推荐使用以下流程来有效地修复应用崩溃问题：</p>
<ol>
<li>确认要修复的崩溃；<br><br>后台的错误分析列表，可以显示出崩溃发生的次数。由此，你可以分析出哪项崩溃对应用影响最大，对其进行优先修复。点击每条崩溃记录可以查看到更详细的信息，包括调用堆栈、系统版本、设备类型和受影响的应用版本等等。</li>
<li>修复崩溃；<br><br>调试代码，修复崩溃问题。</li>
<li>构建新的版本；</li>
<li>标记已修复的崩溃，向 App Store 发布新版本；<br><br>标记为「已修复」的崩溃不会在默认的列表中出现。如果同样的崩溃在新版本中再次出现，那么这条崩溃记录将自动恢复成「未修复」状态，并且重新出现在默认列表里面。</li>
<li>重复以上步骤，不断改进应用。</li>
</ol>
<h2 id="排错">排错</h2><p><strong>为什么编译的时候会报错：Undefined symbols for architecture i386: “std::<strong>1::basic_string&lt;char, std::</strong>1::char_traits<char>…？</char></strong></p>
<p>这是在项目依赖里面缺少 libc++.dylib 库。打开项目的 <strong>TARGETS</strong> / <strong>General</strong> / <strong>Linked Frameworks and Libraries</strong>，添加 libc++.dylib 即可。</p>
<p><strong>为什么我的崩溃没有在后台显示？</strong></p>
<p>你的应用可能没有向 LeanCloud 云端发送崩溃报告。需要检查：</p>
<ul>
<li>确认在 LeanCloud SDK 初始化之前开启了崩溃报告。</li>
<li>如果正在测试崩溃报告，要确认应用不是通过调试器运行的；需要执行 build、run、stop 之后，再在 Home 界面点开应用。</li>
<li>崩溃信息是在崩溃发生之后、下次应用启动之时发送的，确保应用不会在崩溃信息发送之前再次崩溃。如果是在调试崩溃报告，可以添加一段延时做为保障。</li>
<li>确保没有使用其他崩溃报告的库，否则会互相干扰。</li>
</ul>
<p><strong>为什么我的崩溃没有符号化？</strong></p>
<p>你可能没有上传与应用版本对应的符号文件。请检查：</p>
<ul>
<li>如果设置了自动上传符号文件，切换到 Xcode 的 Report Navigator（Command + 8），验证一下上传是否正常。</li>
<li>确认日志正常，上传过程没有错误。</li>
<li>如果为之前没有符号化的崩溃上传了对应的符号文件，当同一崩溃再次发生时它就会被符号化；而之前没有符号化的崩溃信息不会再被符号化了。所以，这时可以把之前的崩溃记录标记为「已解决」并等待其再次发生。</li>
<li>如果使用了自定义的动态链接框架（dynamic framework），并且部分堆栈信息没有符号化，请确认所有动态链接框架以及主应用的符号文件都已经上传。</li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/01Getting Started/Basic Setup/" itemprop="url">
                01Getting Started-基本设置
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-26T23:00:00+08:00" content="2015-12-26">
            2015-12-26
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Using-Swift-with-Cocoa-and-Objective-C/" itemprop="url" rel="index">
                  <span itemprop="name">Using-Swift-with-Cocoa-and-Objective-C</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/01Getting Started/Basic Setup/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/01Getting Started/Basic Setup/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><blockquote>
<p>翻译：<a href="https://github.com/Creolophus" target="_blank" rel="external">Creolophus</a></p>
<p>校正：<a href="https://github.com/Evilcome" target="_blank" rel="external">Evilcome</a> <a href="https://github.com/dabing1022" target="_blank" rel="external">ChildhoodAndy</a></p>
</blockquote>
<h1 id="基本设置">基本设置</h1><hr>
<p>本页包含内容：</p>
<ul>
<li><a href="#setting_up_your_swift_environment">建立你的 Swift 环境</a></li>
<li><a href="#understanding_the_swift_import_process">理解 Swift 导入过程</a></li>
</ul>
<blockquote>
<p>重要事项</p>
<p>这是一个正在研发的API或技术的概要文件，苹果公司提供这些信息主要是为了帮助你通过苹果产品使用这些技术或者编程接口而做好计划，该信息有可能会在未来发生改变，本文当中提到的软件应该以最终发布的操作系统测试和最终文档为准，未来有可能会提供新版本的文档信息。</p>
</blockquote>
<p>Swift 被设计用来无缝兼容 Cocoa 和 Objective-C 。在 Swift 中，你可以使用 Objective-C 的 API（包括系统框架和你自定义的代码），你也可以在 Objective-C中 使用 Swift 的 API。这种兼容性使 Swift 变成了一个简单、方便并且强大的工具集成到你的 Cocoa 应用开发工作流程中。</p>
<p>这篇指南包括了三个有关兼容性的重要方面方便你更好地利用来开发 Cocoa 应用：</p>
<ul>
<li><strong>互用性</strong> 使你将 Swift 和 Objective-C 相接合，允许在 Objective-C 中使用 Swift 的 Class 并且当你在写 Swift 代码时利用熟悉的 Cocoa Class、Pattern、Practice。</li>
<li><strong>混合和匹配</strong> 允许你创建结合了 Swift 和 Objective-C 文件的混合语言应用，他们能跟彼此进行通信。</li>
<li><strong>迁移</strong> 由于以上两点，从已经存在的 Objective-C 代码迁移到 Swift 是非常简单的，使得用最新的 Swift 特性代替你的 Objective-C 应用部分内容成为了可能。</li>
</ul>
<p>在你开始学习这些特性前，你需要对如何建立 Swift 环境来访问 Cocoa 系统框架有个大体了解。</p>
<p><a name="setting_up_your_swift_environment"></a></p>
<p>##建立你的 Swift 环境</p>
<p>为了开始体验在 Swift 中访问 Cocoa 框架，使用 Xcode 的一个模板来创建一个基于 Swift 应用。</p>
<p>###在 Xcode 中创建一个 Swift 项目</p>
<p>1.选择 File &gt; New &gt; Project &gt; (iOS or OS X) &gt; Application &gt; your <em>template of choice</em>。</p>
<p>2.点击 Language 弹出菜单并选择 Swift。</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/Art/newproject_2x.png" alt="image"></p>
<p>Swift 项目的结构几乎和 Objective-C 项目一模一样，只有一个重要的区别：Swift 没有头文件。在实现和接口之间没有显示的划分，所以一个特定类中的所有信息都存储在单独的<code>.swift</code>文件中。</p>
<p>现在开始，你可以开始体验在<code>app delegate</code>中写 Swift 代码，或者你可以通过选择 File &gt; New &gt; File &gt; (iOS or OS X) &gt; Other &gt; Swift来创建一个 Swift 类。</p>
<p><a name="understanding_the_swift_import_process"></a></p>
<p>##理解 Swift 导入过程</p>
<p>在你建立 Xcode 项目后，你可以在 Swift 里导入任意用 Objective-C 来工作的 Cocoa 平台框架。</p>
<p>任意 Objective-C 的框架（或 C 类库）将作为一个<em>module</em>，能直接导入到 Swift 中。这些包括了所有 Objective-C 系统框架-比如 Foundation、UIKit 和 SpriteKit，就像系统支持公共 C 类库。举个例子，想导入 Foundation，只要简单地添加 import 语句到你写的 Swift 文件的顶部。</p>
<blockquote>
<p>SWIFT</p>
<p><code>import Foundation</code></p>
</blockquote>
<p>这个 import 导入了所有 Foundation 的 API，包括<code>NSDate</code>，<code>NSURL</code>，<code>NSMutableData</code>，并且他们的所有方法、属性和类别都可以在 Swift 中直接使用。</p>
<p>导入过程是非常简洁的。Objective-C 框架在头文件中申明 API。在 Swift 中，那些头文件被编译成 Objective-C 的 module，接着被导入到 Swift 作为 Swift 的 API。导入决定了 Objective-C 的 Function，Class，Method 和 Type 如何在 Swift 中出现。对于 Function 和 Method，这个过程影响他们的参数和返回值。导入过程可以做下面这些事情：</p>
<ul>
<li>重映射确定的 Objective-C 类型到 Swift 中的同等类型，就像 id 到<code>AnyObject</code></li>
<li>重映射确定的 Objective-C 核心类型到 Swift 中的替代类型， 就像<code>NSString</code>到<code>String</code></li>
<li>重映射确定的 Objective-C 概念到 Swift 中相匹配的概念，如<code>pointers</code>到<code>optionals</code></li>
</ul>
<p>在互用性章节，你将会了解到更多关于这些映射如何在你的 Swift 代码进行取舍。<br>导入 Swift 的模型到 Objective-C 和从 Objective-C 导入 Swift 是非常相似的。Swift 申明它的 API，比如一个框架作为 Swift modules。同时这些 Swift modules 会生成 Objective-C 的头文件。这些头文件可以映射回 Objective-C 的 API 中。一些 Swift 的 API 不映射回 Objective-C 因为他们取舍了语言特性发现这些在 Objective-C 中不可用。关于在 Objective-C 中使用 Swift 的更多特性，请参看<a href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/03Mix%20and%20Match/Swift%20and%20Objective-C%20in%20the%20Same%20Project/">在同一项目中使用 Swift 和 Objective-C</a>。</p>
<blockquote>
<p>注意</p>
<p>你不能直接把 C++ 代码导入 Swift。解决办法是为 C++ 代码创建一个 Objective-C 或者 C 的封装。</p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/01Interacting with Objective-C APIs/" itemprop="url">
                02Interoperability-01与 Objective-C 的 API 交互
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-26T22:00:10+08:00" content="2015-12-26">
            2015-12-26
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Using-Swift-with-Cocoa-and-Objective-C/" itemprop="url" rel="index">
                  <span itemprop="name">Using-Swift-with-Cocoa-and-Objective-C</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/01Interacting with Objective-C APIs/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/01Interacting with Objective-C APIs/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><blockquote>
<p>翻译：<a href="https://github.com/Creolophus" target="_blank" rel="external">Creolophus</a></p>
<p>校正：<a href="https://github.com/Evilcome" target="_blank" rel="external">Evilcome</a> <a href="https://github.com/dabing1022" target="_blank" rel="external">ChildhoodAndy</a></p>
</blockquote>
<p>#与 Objective-C 的 API 交互</p>
<hr>
<p>本页包含内容：</p>
<ul>
<li><a href="#initialization">初始化</a></li>
<li><a href="#failable_initialization">可失败初始化</a></li>
<li><a href="#accessing_properties">访问属性</a></li>
<li><a href="#working_with_methods">方法</a></li>
<li><a href="#id_compatibility">id 兼容性（id Compatibility）</a></li>
<li><a href="#Nullability_and_Optionals">空值和可选值</a></li>
<li><a href="#extensions">扩展（Extensions）</a></li>
<li><a href="#closures">闭包（Closures）</a></li>
<li><a href="#object_comparison">比较对象</a></li>
<li><a href="#swift_type_compatibility">Swift 类型兼容性</a></li>
<li><a href="#Requiring_Dynamic_Dispatch">动态分发</a></li>
<li><a href="#Lightweight_Generics">轻量级泛型</a></li>
<li><a href="#objective_c_selectors">Objective-C 选择器（Selectors）</a></li>
</ul>
<p><strong>互用性</strong>是让 Swift 和 Objective-C 相接合的一种特性，使你能够在一种语言编写的文件中使用另一种语言。当你准备开始把 Swift 融入到你的开发流程中时，你应该懂得如何利用互用性来重新定义并提高你写 Cocoa 应用的方案。</p>
<p>互用性很重要的一点就是允许你在写 Swift 代码时使用 Objective-C 的 API 接口。当你导入一个 Objective-C 框架后，你可以使用原生的 Swift 语法实例化它的 Class 并且与之交互。</p>
<p><a name="initialization"></a></p>
<p>##初始化</p>
<p>为了使用 Swift 实例化 Objective-C 的 Class，你应该使用 Swift 语法调用它的一个初始化器。当 Objective-C 的<code>init</code>方法变化到 Swift，他们用 Swift 初始化语法呈现。“init”前缀被截断当作一个关键字，用来表明该方法是初始化方法。那些以“initWith”开头的<code>init</code>方法，“With”也会被去除。从“init”或者“initWith”中分离出来的这部分方法名首字母变成小写，并且被当做是第一个参数的参数名。其余的每一部分方法名依次变为参数名。这些方法名都在圆括号中被调用。</p>
<p>举个例子，你在使用 Objective-C 时会这样做：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UITableView *myTableView = [[UITableView alloc] &#10;initWithFrame:CGRectZero style:UITableViewStyleGrouped];</span><br></pre></td></tr></table></figure>
<p>在 Swift 中，你应该这样做：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myTableView: <span class="type">UITableView</span> = <span class="type">UITableView</span>(frame: <span class="type">CGRectZero</span>, style: .<span class="type">Grouped</span>)</span><br></pre></td></tr></table></figure>
<p>你不需要调用<code>alloc</code>，Swift 能够正确的为你处理。注意，当使用 Swift 风格的初始化函数的时候，“init”不会出现。</p>
<p>你可以在初始化时显式的声明对象的类型，也可以忽略它，Swift 能够正确判断对象的类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myTextField = <span class="type">UITextField</span>(frame: <span class="type">CGRect</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">200.0</span>, <span class="number">40.0</span>))</span><br></pre></td></tr></table></figure>
<p>这里的<code>UITableView</code>和<code>UITextField</code>对象和你在 Objective-C 中使用的具有相同的功能。你可以用一样的方式使用他们，包括访问属性或者调用各自的类中的方法。</p>
<p>为了统一和简易，Objective-C 的工厂方法也在 Swift 中映射为方便的初始化方法。这种映射能够让他们使用同样简洁明了的初始化方法。例如，在 Objective-C 中你可能会像下面这样调用一个工厂方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIColor *color = [UIColor colorWithRed:0.5 green:0.0 blue:0.5 alpha:1.0];</span><br></pre></td></tr></table></figure>
<p>在 Swift 中，你应该这样做：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> color = <span class="type">UIColor</span>(red: <span class="number">0.5</span>, green: <span class="number">0.0</span>, blue: <span class="number">0.5</span>, alpha: <span class="number">1.0</span>)</span><br></pre></td></tr></table></figure>
<p><a name="failable_initialization"></a></p>
<p>##可失败初始化</p>
<p>在 Objective-C 中，构造器会直接返回他们初始化的对象。为了通知调用者初始化失败，Objective-C 构造器会返回<code>nil</code>。在 Swift 中，这种模式被内置到语言特性中，被称为<em>可失败初始化</em>。在 iOS 和 OSX 系统框架中许多 Objective-C 构造器会被检查是否会初始化失败。如果初始化不会失败，这些 Objective-C 构造器便会以<code>init(...)</code>被导入，如果初始化可能会失败，则会以<code>init?(...)</code>被导入。在我们自己的 Objective-C 类以及未被检查的框架类中，构造器会以<code>init!(...)</code>被导入。例如，当图片文件在指定路径中不存在时，<code>UIImage(contentsOfFile:)</code>构造器初始化<code>UIImage</code>对象便会失败。如果初始化成功，我们可以用可选值绑定来对可失败初始化的结果进行解包。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> image = <span class="type">UIImage</span>(contentsOfFile: <span class="string">"MyImage.png"</span>) &#123;</span><br><span class="line">    <span class="comment">// loaded the image successfully</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// could not load the image</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="accessing_properties"></a></p>
<p>##访问属性</p>
<p>在 Swift 中访问和设置 Objective-C 对象的属性时，使用点语法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myTextField.textColor = <span class="type">UIColor</span>.darkGrayColor()</span><br><span class="line">myTextField.text = <span class="string">"Hello world"</span></span><br></pre></td></tr></table></figure>
<p>当 get 或 set 属性时，直接使用属性名称，不需要附加圆括号。注意，<code>darkGrayColor</code>后面附加了一对圆括号，这是因为<code>darkGrayColor</code>是<code>UIColor</code>的一个类方法，不是一个属性。</p>
<p>在 Objective-C 中，一个有返回值的无参数方法可以被作为一个隐式的访问函数，并且可以与访问器使用同样的方法调用。但在 Swift 中不再能够这样做了，只有在 Objective-C 中 使用<code>@property</code>关键字声明的属性才会被作为属性引入。方法被导入和调用见<a href="#working_with_methods">方法</a>描述。</p>
<p><a name="working_with_methods"></a></p>
<p>##方法</p>
<p>在 Swift 中调用 Objective-C 方法时，使用点语法。</p>
<p>当 Objective-C 方法转换到 Swift 时，Objective-C 的<code>selector</code>的第一部分将会成为方法名并出现在圆括号的前面，而第一个参数将直接在括号中出现，并且没有参数名，而剩下的参数名与参数则一一对应的填入圆括号中。选择器的所有部分在调用时都是必需的。</p>
<p>举个例子，你在使用 Objective-C 时会这样做：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[myTableView insertSubview:mySubview atIndex:2];</span><br></pre></td></tr></table></figure>
<p>在 Swift 中，你应该这样做：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myTableView.insertSubview(mySubview, atIndex: <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>如果你调用一个无参方法，仍必须在方法名后面加上一对圆括号</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myTableView.layoutIfNeeded()</span><br></pre></td></tr></table></figure>
<p><a name="id_compatibility"></a></p>
<p>##id 兼容性（id Compatibility）</p>
<p>Swift 包含一个叫做<code>AnyObject</code>的协议类型，表示任意类型的对象，就像 Objective-C 中的<code>id</code>一样。<code>AnyObject</code>协议允许你编写类型安全的 Swift 代码同时维持无类型对象的灵活性。因为<code>AnyObject</code>协议保证了这种安全，Swift 将<code>id</code>对象导入为<code>AnyObject</code>。</p>
<p>举个例子，跟<code>id</code>一样，你可以为<code>AnyObject</code>类型的对象分配任何其它类型的对象，你也同样可以为它重新分配其它类型的对象。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject: <span class="type">AnyObject</span> = <span class="type">UITableViewCell</span>()</span><br><span class="line">myObject = <span class="type">NSDate</span>()</span><br></pre></td></tr></table></figure>
<p>你也可以在调用 Objective-C 方法或者访问属性时不将它转换为具体类的类型。这包括了 Objective-C 中标记为<code>@objc</code>的方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> futureDate = myObject.dateByAddingTimeInterval(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">let</span> timeSinceNow = myObject.timeIntervalSinceNow</span><br></pre></td></tr></table></figure>
<p>然而，由于直到运行时才知道<code>AnyObject</code>的对象类型，所以有可能在不经意间写出不安全代码。另外，与 Objective-C 不同的是，如果你调的用方法或者访问的属性<code>AnyObject</code>对象没有声明，将会报运行时错误。比如下面的代码在运行时将会报出一个<code>unrecognized selector error</code>错误：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myObject.characterAtIndex(<span class="number">5</span>)</span><br><span class="line"><span class="comment">// crash, myObject does't respond to that method</span></span><br></pre></td></tr></table></figure>
<p>但是，你可以通过 Swift 的可选值特性来排除这个 Objective-C 中常见的错误，当你用<code>AnyObject</code>对象调用一个 Objective-C 方法时，这次调用将会变成一次隐式展开可选值的行为。你可以通过可选值特性来决定<code>AnyObject</code>类型的对象是否调用该方法，同样的，你可以把这种特性应用在属性上。</p>
<blockquote>
<p>注</p>
<p>通过<code>AnyObject</code>访问的属性永远返回一个可选值。</p>
</blockquote>
<p>举个例子，在下面的代码中，第一和第二行代码将不会被执行因为<code>length</code>属性和<code>characterAtIndex:</code>方法不存在于 NSDate 对象中。<code>myLength</code>常量会被推测成可选的<code>Int</code>类型并且被赋值为<code>nil</code>。同样你可以使用<code>if-let</code>声明来有条件的展开这个方法的返回值，从而判断对象是否能执行这个方法。就像第三行做的一样。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myLength = myObject.length?</span><br><span class="line"><span class="keyword">let</span> myChar = myObject.characterAtIndex?(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> fifthCharacter = myObject.characterAtIndex(<span class="number">5</span>) &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"Found <span class="subst">\(fifthCharacter)</span> at index 5"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 Swift 中的强制类型转换，从<code>AnyObject</code>类型的对象转换成明确的类型并不会保证成功，所以它会返回一个可选的值。而你需通过检查该值的类型来确认转换是否成功。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="keyword">let</span> userDefaults = <span class="type">NSUserDefaults</span>.standardUserDefaults()</span><br><span class="line"><span class="keyword">let</span> lastRefreshDate: <span class="type">AnyObject</span>? = userDefaults.objectForKey(<span class="string">"LastRefreshDate"</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> date = lastRefreshDate <span class="keyword">as</span>? <span class="type">NSDate</span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"<span class="subst">\(date.timeIntervalSinceReferenceDate)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，如果你能确定这个对象的类型（并且确定不是<code>nil</code>），你可以添加<code>as</code>操作符强制调用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myDate = lastRefreshDate <span class="keyword">as</span> <span class="type">NSDate</span></span><br><span class="line"><span class="keyword">let</span> timeInterval = myDate.timeIntervalSinceReferenceDate</span><br></pre></td></tr></table></figure>
<p><a name="Nullability_and_Optionals"></a></p>
<h2 id="空值和可选值">空值和可选值</h2><p>在 Objective-C 中，对象的引用可以是值为<code>NULL</code>的原始指针（在 Objective-C 中的简称为<code>nil</code>）。而在Swift中，所有的值–包括结构体与对象的引用–都被保证为非空。作为替代，你将这个可以为空的值包装为optional type。当你需要宣告值为空时，你需要使用<code>nil</code>。你可以在<a href="https://github.com/CocoaChina-editors/Welcome-to-Swift/blob/master/The%20Swift%20Programming%20Language/02Language%20Guide/01The%20Basics.md#optionals" target="_blank" rel="external">Optionals</a>中了解更多。</p>
<p>Objective-C 能够使用空值标记来设定一个参数类型，属性类型或者返回值类型是否可以为 NULL 或者 为 nil 值。单独的类型声明可以使用<code>__nullable</code>和<code>__nonnull</code>标注，空值的范围性的声明可以使用<code>NS_ASSUME_NONNULL_BEGIN</code>和<code>NS_ASSUME_NONNULL_END</code>宏。如果一个类型没有任何的空值标注信息，Swift 就不能分辨出可选值和非可选值类型，并且将作为隐式的解包可选值导入。</p>
<ul>
<li>以<code>__nonnull</code>或者范围宏标注声明的空值类型，被作为非空可选值<code>non-optional</code>导入到 Swift。</li>
<li>以<code>__nullable</code>标注声明的空值类型，被作为可选值导入到 Swift。</li>
<li>没有以空值标注声明的类型被作为隐式的解包可选值导入到 Swift。</li>
</ul>
<p>例如，考虑如下的 Objective-C 声明：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nullable) id  nullableProperty;&#10;@property (nonnull) id nonNullProperty;&#10;@property id unannotatedProperty;&#10; &#10;NS_ASSUME_NONNULL_BEGIN&#10;- (id)returnsNonNullValue;&#10;- (void)takesNonNullParameter:(id)value;&#10;NS_ASSUME_NONNULL_END&#10; &#10;- (nullable id)returnsNullableValue;&#10;- (void)takesNullableParameter:(nullable id)value;&#10; &#10;- (id)returnsUnannotatedValue;&#10;- (void)takesUnannotatedParameter:(id)value;</span><br></pre></td></tr></table></figure>
<p>下面是他们如何被导入 Swift 中的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nullableProperty: <span class="type">AnyObject</span>?</span><br><span class="line"><span class="keyword">var</span> nonNullProperty: <span class="type">AnyObject</span></span><br><span class="line"><span class="keyword">var</span> unannotatedProperty: <span class="type">AnyObject</span>!</span><br><span class="line"> </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">returnsNonNullValue</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesNonNullParameter</span><span class="params">(value: AnyObject)</span></span></span><br><span class="line"> </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">returnsNullableValue</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span>?</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesNullableParameter</span><span class="params">(value: AnyObject?)</span></span></span><br><span class="line"> </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">returnsUnannotatedValue</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span>!</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesUnannotatedParameter</span><span class="params">(value: AnyObject!)</span></span></span><br></pre></td></tr></table></figure>
<p>大多数 Objective-C 的系统框架，包括 Foundation，都已经提供了可空的注解，允许你使用惯用和类型安全的方式与值打交道。</p>
<p><a name="extensions"></a></p>
<p>##扩展（Extensions）</p>
<p>Swift 的扩展和 Objective-C 的类别（Category）相似。扩展为原有的类，结构和枚举丰富了功能，包括在 Objective-C 中定义过的。你可以为系统的框架或者你自己的类型增加扩展，只需要导入合适的模块并且保证你在 Objective-C 中使用的类、结构或枚举拥有相同的名字。</p>
<p>举个例子，你可以扩展<code>UIBezierPath</code>类来为它增加一个等边三角形，这个方法只需提供三角形的边长与起点。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIBezierPath</span> </span>&#123;</span><br><span class="line">    convenience <span class="keyword">init</span>(triangleSideLength: <span class="type">Float</span>, origin: <span class="type">CGPoint</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">let</span> squareRoot = <span class="type">Float</span>(sqrt(<span class="number">3</span>))</span><br><span class="line">        <span class="keyword">let</span> altitude = (squareRoot * triangleSideLength) / <span class="number">2</span></span><br><span class="line">        moveToPoint(origin)</span><br><span class="line">        addLineToPoint(<span class="type">CGPoint</span>(triangleSideLength, origin.x))</span><br><span class="line">        addLineToPoint(<span class="type">CGPoint</span>(triangleSideLength / <span class="number">2</span>, altitude))</span><br><span class="line">        closePath()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以使用扩展来增加属性（包括类的属性与静态属性）。然而，这些属性必须是通过计算才能获取的，扩展不会为类，结构体，枚举添加存储属性。下面这个例子为<code>CGRect</code>类增加了一个叫<code>area</code>的属性。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CGRect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">CGFloat</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> width * height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> rect = <span class="type">CGRect</span>(x: <span class="number">0.0</span>, y: <span class="number">0.0</span>, width: <span class="number">10.0</span>, height: <span class="number">50.0</span>)</span><br><span class="line"><span class="keyword">let</span> area = rect.area</span><br><span class="line"><span class="comment">// area: CGFloat = 500.0</span></span><br></pre></td></tr></table></figure>
<p>你同样可以使用扩展来为类添加协议而无需增加它的子类。如果这个协议是在 Swift 中被定义的，你可以添加 comformance 到它的结构或枚举中无论它们在 Objective-C 或在 Swift 中被定义。</p>
<p>你不能使用扩展来覆盖 Objective-C 类型中存在的方法与属性。</p>
<p><a name="closures"></a></p>
<p>##闭包（Closures）</p>
<p>Objective-C 中的<code>blocks</code>会被自动导入为 Swift 中的闭包。例如，下面是一个 Objective-C 中的 block 变量：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void (^completionBlock)(NSData *, NSError *) = ^(NSData *data, NSError *error) &#123;/* ... */&#125;</span><br></pre></td></tr></table></figure>
<p>而它在 Swift 中的形式为</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> completionBlock: (<span class="type">NSData</span>, <span class="type">NSError</span>) -&gt; <span class="type">Void</span> = &#123;data, error <span class="keyword">in</span> <span class="comment">/* ... */</span>&#125;</span><br></pre></td></tr></table></figure>
<p>Swift 的闭包与 Objective-C 中的 blocks 能够和睦相处，所以你可以把一个 Swift 闭包传递给一个把 block 作为参数的 Objective-C 函数。Swift 闭包与函数具有互通的类型，所以你甚至可以传递 Swift 函数的名字。</p>
<p>闭包与 blocks 语义上相通但是在一个地方不同：变量是可以直接改变的，而不是像 block 那样会拷贝变量。换句话说，Swift 中变量的默认行为与 Objective-C 中 __block 变量一致。</p>
<p><a name="object_comparison"></a></p>
<p>##比较对象</p>
<p>当比较两个 Swift 中的对象时，可以使用两种方式。第一种，使用（==），判断两个对象内容是否相同。第二种，使用(===)，判断常量或者变量是否为同一个对象的实例。</p>
<p>Swift 与 Objective-C 一般使用 == 与 === 操作符来做比较。Swift 的 == 操作符为源自 NSObject 的对象提供了默认的实现。在实现 == 操作符时，Swift 调用 NSObject 定义的 isEqual: 方法。</p>
<p>NSObject 类仅仅做了身份的比较，所以你需要在你自己的类中重新实现 isEqual: 方法。因为你可以直接传递 Swift 对象给 Objective-C 的 API，你也应该为这些对象实现自定义的 isEqual: 方法，如果你希望比较两个对象的内容是否相同而不是仅仅比较他们是不是由相同的对象派生。</p>
<p>作为实现比较函数的一部分，确保根据<a href="//https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/DevPedia-CocoaCore/ObjectComparison.html#//apple_ref/doc/uid/TP40008195-CH37">Object comparison</a>实现对象的<code>hash</code>属性。更进一步的说，如果你希望你的类能够作为字典中的键，也需要遵从<code>Hashable</code>协议以及实现<code>hashValues</code>属性。</p>
<p><a name="swift_type_compatibility"></a></p>
<h2 id="Swift_类型兼容性">Swift 类型兼容性</h2><p>当你在 Swift 中创建了一个继承自 Objective-C 类的子类时，该类以及该类的成员-属性，方法，下标和构造器，便会在 Objective-C 中自动可用。在某些情况下，你需要更细粒度的控制如何将 Swift API 暴漏给 Objective-C。如果你的 Swift 类没有继承自 Objective-C 的类，又或者你想更改暴漏给 Objective-C 代码的接口符号名称，你便可以使用<code>@objc</code>属性。如果你正在使用如键值观察的 API 来动态替换方法的实现，也可以通过使用<code>dynamic</code>修饰符来获得对 Objective-C 运行时被自动派发的成员的访问。</p>
<h3 id="在_Objective-C_中暴漏_Swift_接口">在 Objective-C 中暴漏 Swift 接口</h3><p>当你定义一个继承自<code>NSObject</code>类或者其他 Objective-C 类的 Swift 子类时，该类便会自动兼容 Objective-C。Swift 编译器已经为你做好了这部分所需要的工作。</p>
<p>所有的步骤都由 Swift 编译器自动完成，如果你从未在 Objective-C 代码中导入 Swift 类，你也不需要担心类型适配问题。另外一种情况，如果你的 Swift 类并不继承于 Objective-C 类而你希望能在 Objective-C 的代码中使用它，你可以使用下面描述的<code>@objc</code>属性。</p>
<p><code>@objc</code>可以让你的 Swift API 在 Objective-C 中使用。换句话说，你可以通过在任何 Swift 方法、类、属性前添加<code>@objc</code>，来使得他们可以在 Objective-C 代码中使用。如果你的类继承自 Objective-C，编译器会自动帮助你完成这一步。编译器还会在所有的变量、方法、属性前加 @objc，如果这个类自己前面加上了<code>@objc</code>关键字。当你使用<code>@IBOutlet</code>，<code>@IBAction</code>，或者是<code>@NSManaged</code>属性时，<code>@objc</code>也会自动加在前面。这个关键字也可以用在 Objetive-C 中的 target-action 设计模式中，例如，<code>NSTimer</code>或者<code>UIButton</code>。</p>
<p>当你在 Objective-C 中使用 Swift API，编译器通常会对语句做直接的翻译。例如，Swift API <code>func playSong(name: String)</code>会被解释为<code>- (void)playSong:(NSString *)name</code>。然而，有一个例外：当在 Objective-C 中使用 Swift 的初始化函数，编译器会在方法前添加“initWith”并且将原初始化函数的第一个参数首字母大写。例如，这个 Swift 初始化函数<code>init (songName: String, artist: String</code>将被翻译为<code>- (instancetype)initWithSongName:(NSString *)songName artist:(NSString *)artist</code>。</p>
<p>Swift 同时也提供了一个<code>@objc</code>关键字的变体，通过它你可以自定义在 Objective-C 中转换的函数名。例如，如果你的 Swift 类的名字包含 Objective-C 中不支持的字符，你就可以为 Objective-C 提供一个可供替代的名字。如果你要为 Swift 函数提供一个 Objective-C 名字，记得为带参数的函数添加（:）</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="preprocessor">@objc</span>(<span class="type">Squirrel</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> Белка </span>&#123;</span><br><span class="line">    <span class="preprocessor">@objc</span>(initWithName:)</span><br><span class="line">    <span class="keyword">init</span> (имя: <span class="type">String</span>) &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">    <span class="preprocessor">@objc</span>(hideNuts:inTree:)</span><br><span class="line">    <span class="func"><span class="keyword">func</span> прячьОрехи<span class="params">(Int, вДереве: Дерево)</span></span> &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你在 Swift 类中使用<code>@objc(&lt;#name#&gt;)</code>关键字，这个类可以不需要命名空间即可在 Objective-C 中使用。这个关键字在你迁徙 Objecive-C 代码到 Swift 时同样也非常有用。由于归档过的对象存贮了类的名字，你应该使用<code>@objc(&lt;#name#&gt;)</code>来声明与旧的归档过的类相同的名字，这样旧的类才能被新的 Swift 类解档。</p>
<p><a name="Requiring_Dynamic_Dispatch"></a></p>
<h2 id="请求动态分配">请求动态分配</h2><p>@objc 属性将你的 Swift API 暴露给了 Objective-C 运行时，但是它并不能保证一个属性，方法，下标，或构造器的动态调度。通过绕过 Objective-C 运行时，Swift 编译器可能仍然 devirtualize 或内联成员访问来优化代码的性能。当你用动态修改符标记一个成员声明时，对该成员的访问始终是动态调度。由于标有动态修改声明使用 Objective-C 运行时来调度，它们被隐式的用 @objc 属性标记。</p>
<p>动态分配的需求很少是必要的。但是，当你要在运行时替换一个 API 的实现时你必须使用动态修改。例如，你可以使用 Objective-C 运行时方法<code>method_exchangeImplementations</code>函数来替换 app 正在运行时某个方法的实现。如果 Swift 编译器内联了方法的实现或者 devirtualized 对它的访问，新的实现将不会被使用。</p>
<p><a name="Lightweight_Generics"></a></p>
<h2 id="轻量级泛型">轻量级泛型</h2><p>使用轻量级泛型参数的 Objective-C 声明类型，如<code>NSArray</code>，<code>NSSet</code>以及<code>NSDictionary</code>，在被导入到 Swift 时会附带上他们内容保存的类型。</p>
<p>例如，考虑下面的 Objective-C 属性声明：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property NSArray&#60;NSDate *&#62;* dates;&#10;@property NSSet&#60;NSString *&#62;* words;&#10;@property NSDictionary&#60;KeyType: NSURL *, NSData *&#62;* cachedData;</span><br></pre></td></tr></table></figure>
<p>下面是 Swift 导入后：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dates: [<span class="type">NSDate</span>]</span><br><span class="line"><span class="keyword">var</span> words: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;</span><br><span class="line"><span class="keyword">var</span> cachedData: [<span class="type">NSURL</span>: <span class="type">NSData</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>除了 Foundation 中的集合类， Objective-C 的轻量级泛型会被 Swift 忽略掉。任何其他使用轻量级泛型的类型在导入到 Swift 中时会被视为无参数化。</p>
</blockquote>
<p><a name="objective_c_selectors"></a></p>
<h2 id="Objective-C_选择器">Objective-C 选择器</h2><p>Objective-C 选择器是一种指向 Objective-C 方法名的类型。在 Swift 里，Objective-C 的选择器被<code>Selector</code>结构体替代。你可以通过字符串创建一个选择器，比如<code>let mySelector: Selector = &quot;tappedButton:&quot;</code>。因为字符串字面量能够自动被转换为选择器，所以你可以把字符串字面量直接传递给任何能够接受选择器的方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> myButton = <span class="type">UIButton</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">100</span>, height: <span class="number">50</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>?(nibName nibNameOrNil: <span class="type">String</span>?, bundle nibBundleOrNil: <span class="type">NSBundle</span>?) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: nibNameOrNil, bundle: nibBundleOrNil)</span><br><span class="line">        myButton.addTarget(<span class="keyword">self</span>, action: <span class="string">"tappedButton:"</span>, forControlEvents: .<span class="type">TouchUpInside</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">tappedButton</span><span class="params">(sender: UIButton!)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"tapped button"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    required <span class="keyword">init</span>?(coder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: coder)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p><code>performSelector:</code>方法和相关的调用选择器的方法没有导入到 Swift 中因为它们本质上是不安全的。</p>
</blockquote>
<p>如果你的 Swift 类继承自 Objective-C 的类，你的所有方法都可以用作 Objective-C 的选择器。反之，如果你的 Swift 类不是继承自 Objective-C，你需要在想要使用的选择器前面加上<code>@objc</code>属性前缀，详情请看<a href="#swift_type_compatibility">Swift 类型兼容性</a>。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/02Writing Swift Classes with Objective-C Behavior/" itemprop="url">
                02Interoperability-02特性编写Swift类
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-26T22:00:09+08:00" content="2015-12-26">
            2015-12-26
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Using-Swift-with-Cocoa-and-Objective-C/" itemprop="url" rel="index">
                  <span itemprop="name">Using-Swift-with-Cocoa-and-Objective-C</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/02Writing Swift Classes with Objective-C Behavior/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/02Writing Swift Classes with Objective-C Behavior/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><blockquote>
<p>翻译：<a href="https://github.com/halinuya" target="_blank" rel="external">halinuya</a></p>
<p>校对：<a href="https://github.com/song-buaa" target="_blank" rel="external">song-buaa</a> <a href="https://github.com/MonicaZhou" target="_blank" rel="external">MonicaZhou</a> <a href="https://github.com/dabing1022" target="_blank" rel="external">ChildhoodAndy</a></p>
</blockquote>
<h1 id="使用Objective-C特性编写Swift类">使用Objective-C特性编写Swift类</h1><hr>
<p>本节包括内容：</p>
<ul>
<li><a href="#inheriting_from_objective-c_classes">继承Objective-C的类（Inheriting from Objective-C Classes）</a></li>
<li><a href="#adopting_protocols">采用协议（Adopting Protocols）</a></li>
<li><a href="#writing_initializers_and_deinitializers">编写构造器和析构器（Writing Initializers and Deinitializers）</a></li>
<li><a href="#integrating_with_interface_builder">集成Interface Builder（Integrating with Interface Builder）</a></li>
<li><a href="#specifying_property_attributes">指明属性特性（Specifying Property Attributes）</a></li>
<li><a href="#implementing_core_data_managed_object_subclasses">实现Core Data Managed Object子类（Implementing Core Data Managed Object Subclasses）</a></li>
<li><a href="#using_swift_class_names_with_objective_c_apis">使用带Objective-C API的Swift类名</a></li>
</ul>
<p>互用性（互操作性）使开发者可以定义融合了 Objective-C 语言特性的Swift类。编写 Swift 类时，不仅可以继承 Objective-C 语言编写的父类，采用 Objective-C 的协议，还可以利用 Objective-C 的一些其它功能。这意味着，开发者可以基于 Objective-C 中已有的熟悉、可靠的类、方法和框架来创建 Swift 类，并结合 Swift 提供的现代化和更有效的语言特点对其进行优化。</p>
<p><a name="inheriting_from_objective-c_classes"></a></p>
<h2 id="继承Objective-C的类">继承Objective-C的类</h2><p>在 Swift 中，开发者可以定义一个子类，该子类继承自使用 Objective-C 编写的类。创建该子类的方法是，在 Swift 的类名后面加上一个冒号（:），冒号后面跟上 Objective-C 的类名。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySwiftViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 定义类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开发者能够从 Objective-C 的父类中继承所有的功能。如果开发者要覆盖父类中的方法，不要忘记使用<code>override</code>关键字。</p>
<h3 id="NSCoding协议">NSCoding协议</h3><p><code>NSCoding</code>协议要求符合的类型实现所需的构造器<code>init(coder:)</code>。直接采用<code>NSCoding</code>协议的类必须实现这个方法。采用<code>NSCoding</code>协议的类的子类，这些类有一个或者多个自定义的构造器或者不带初始化值的属性，也必须实现这个方法。Xcode提供了以下占位实现来提醒：</p>
<pre><code>required init(coder aDecoder: NSCoder) {
<span class="code">    fatalError("init(coder:) has not been implemented")</span>
}
<span class="xml"><span class="comment"><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">对那些从 Storyboards 里加载的对象，或者用 NSUserDefaults 或 NSKeyedArchiver 类归档到磁盘的对象，你必须提供一个完整的初始化程序的实现。然而，当类型以此种方式无法实例化的时候，你可能并不需要实现构造器。</span><br><span class="line"></span><br><span class="line">&lt;a name=<span class="string">"adopting_protocols"</span>&gt;&lt;/a&gt;</span><br><span class="line"><span class="comment">## 采用协议</span></span><br><span class="line"></span><br><span class="line">在 Swift 中，开发者可以采用 Objective-C 中定义好的协议。和 Swift 协议一样，所有 Objective-C 协议都写在一个用逗号隔开的列表中，跟在所在类的父类名后面（如果它有父类的话）。</span><br><span class="line"></span><br><span class="line">`<span class="javascript"></span>``<span class="javascript">swift</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySwiftViewController</span>: <span class="title">UIViewController</span>, <span class="title">UITableViewDelegate</span>, <span class="title">UITableViewDataSource</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 定义类</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></span></span>

Objective-C 协议与 Swift 协议使用上是一致的。如果开发者想在 Swift 代码中引用 <span class="code">`UITableViewDelegate`</span>协议，可以直接使用<span class="code">`UITableViewDelegate`</span>（跟在 Objective-C 中引用<span class="code">`id&lt;UITableViewDelegate&gt;`</span>是等价的）。

因为在 Swift 中，类和协议的命名空间是统一的，Objective-C 里的 NSObject 协议被重新映射到 Swift 里的 NSObjectProtocol。

<span class="xml"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">name</span>=<span class="value">"writing_initializers_and_deinitializers"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="title">a</span>&gt;</span></span>
<span class="header">## 编写构造器和析构器</span>

Swift 的编译器确保在初始化时，构造器不允许类里有任何未初始化的属性，这样做能够增加代码的安全性和可预测性。另外，与 Objective-C 语言不同，Swift 不提供单独的内存分配方法供开发者调用。当你使用原生的 Swift 初始化方法时（即使是和 Objective-C 类协作），Swift 会将 Objective-C 的初始化方法转换为 Swift 的初始化方法。关于如何实现开发者自定义构造器的更多信息，请查看[<span class="link_label">构造器</span>](<span class="link_url">https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18</span>)。

当开发者希望在类被释放前，执行额外的清理工作时，需要执行一个析构过程来代替<span class="code">`dealloc`</span>方法。在实例被释放前，Swift 会自动调用析构器来执行析构过程。Swift 调用完子类的析构器后，会自动调用父类的析构器。当开发者使用 Objective-C 类或者是继承自 Objective-C 类的 Swift 类时，Swift 也会自动为开发者调用这个类的父类里的<span class="code">`dealloc`</span>方法。关于如何实现开发者自定义析构器的更多信息，请查看[析构器]https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift<span class="emphasis">_Programming_</span>Language/Deinitialization.html#//apple_ref/doc/uid/TP40014097-CH19)。

<span class="xml"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">name</span>=<span class="value">"integrating_with_interface_builder"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="title">a</span>&gt;</span></span>
<span class="header">## 集成Interface Builder</span>

Swift 编译器包含一些属性，使得开发者的 Swift 类集成了 Interface Builder 里的一些特色功能。和 Objective-C 里一样，你能在 Swift 里面使用 outlets，actions 和实时渲染（live rendering）。

<span class="header">### 使用Outlets和Action</span>

使用 Outlets 和 Action 可以连接源代码和 Interface Builder 的 UI 对象。在Swift里面使用 Outlets 和 Action，需要在属性和方法声明前插入<span class="code">`@IBOutlet`</span>或者<span class="code">`@IBAction`</span>关键字。声明一个 Outlet 集合同样是用<span class="code">`@IBOutlet`</span>属性，即为类型指定一个数组。

当开发者在 Swift 里面声明了一个 Outlet 时，Swift 编译器会自动将该类型转换为弱（weak）、隐式（implicitly）、未包装（unwrapped）的 optional（Objective-C 里面对应指针类型）数据类型，并为它分配一个初始化的空值<span class="code">`nil`</span>。实际上，编译器使用<span class="code">`@IBOutlet weak var name: Type! = nil`</span>来代替 <span class="code">`@IBOutlet var name: Type`</span>。编译器将该类型转换成了弱（weak）、隐式（implicitly）、未包装（unwrapped）的 optional 类型，因此开发者就不需要在构造器中为该类型分配一个初始值了。当开发者从故事板（storyboard）或者<span class="code">`xib`</span>文件里面初始化对象 class 后，定义好的 Outlet 和这些对象连接在一起了，所以，这些 Outlet 是隐式的，未包装的。由于创建的 outlets 一般都是弱关系，因此默认 outlets 是弱类型。

例如，下面的 Swift 代码声明了一个拥有 Outlet、Outlet 集合和 Action 的类：

<span class="xml"><span class="comment"><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="preprocessor">@IBOutlet</span> <span class="keyword">var</span> button: <span class="type">UIButton</span></span><br><span class="line"></span><br><span class="line">	<span class="preprocessor">@IBOutlet</span> <span class="keyword">var</span> textFields: <span class="type">UITextField</span>[]</span><br><span class="line"></span><br><span class="line">	<span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">buttonTapped</span><span class="params">(AnyObject)</span></span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"button tapped!"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></span></span>

在<span class="code">`buttonTapped`</span>方法中，消息发送者的信息没有被使用，因此可以省略该方法的参数名。

<span class="header">### 实时渲染（live rendering）</span>
开发者可以在 Interface Builder 中用<span class="code">`@IBDesignable`</span>和<span class="code">`@IBInspectable`</span>来创建生动、可交互的自定义视图（view）。开发者继承<span class="code">`UIView`</span>或者<span class="code">`NSView`</span>来自定义一个视图（view）时，可以在类声明前添加<span class="code">`@IBDesignable`</span>属性。当你在 Interface Builder 里添加了自定义的视图后（在监视器面板的自定义视图类中进行设置），Interface Builder 将在画布上渲染你自定义的视图。


&gt;注意：只能针对框架里对象进行实时渲染

你也可以将<span class="code">`@IBInspectable`</span>属性添加到和用户定义的运行时属性兼容的类型属性里。这样，当开发者将自定义的视图添加到 Interface Builder 里后，就可以在监视器面板中编辑这些属性。

<span class="xml"><span class="comment"><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">@IBDesignable</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCustomView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">	<span class="preprocessor">@IBInspectable</span> <span class="keyword">var</span> textColor: <span class="type">UIColor</span></span><br><span class="line">	<span class="preprocessor">@IBInspectable</span> <span class="keyword">var</span> iconHeight: <span class="type">CGFloat</span></span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></span></span>

<span class="xml"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">name</span>=<span class="value">"specifying_property_attributes"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="title">a</span>&gt;</span></span>
<span class="header">## 指明属性特性</span>

在 Objective-C 中，属性通常都有一组特性（Attributes）说明来指明该属性的一些附加信息。在 Swift 中，开发者可以通过不同的方法来指明属性的这些特性。

<span class="header">### 强类型和弱类型</span>

Swift 里属性默认都是强类型的。使用<span class="code">`weak`</span>关键字修饰一个属性，能指明其对象存储时是一个弱引用。该关键字仅能修饰 optional 对象类型。更多的信息，请查阅[<span class="link_label">特性</span>](<span class="link_url">https://github.com/CocoaChina-editors/Welcome-to-Swift/blob/master/The%20Swift%20Programming%20Language/02Language%20Guide/09Classes%20and%20Structures.md</span>)。

<span class="header">### 读／写和只读</span>

在 Swift 中，没有<span class="code">`readwrite`</span>和<span class="code">`readonly`</span>特性。当声明一个存储型属性时，使用<span class="code">`let`</span>修饰其为只读；使用<span class="code">`var`</span>修饰其为可读／写。当声明一个计算型属性时，为其提供一个 getter 方法，使其成为只读的；提供 getter 方法和 setter 方法，使其成为可读／写的。更多信息，请查阅[<span class="link_label">属性</span>](<span class="link_url">https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13</span>)。

<span class="header">### 拷贝</span>

在 Swift 中，Objective-C 的<span class="code">`copy`</span>特性被转换为<span class="code">`@NSCopying`</span>属性。这一类的属性必须遵守 <span class="code">`NSCopying`</span>协议。更多信息，请查阅[<span class="link_label">特性</span>](<span class="link_url">https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13</span>)。

<span class="xml"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">name</span>=<span class="value">"implementing_core_data_managed_object_subclasses"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="title">a</span>&gt;</span></span>
<span class="header">## 实现Core Data Managed Object子类</span>

Core Data 提供了基本存储和实现<span class="code">`NSManagedObject`</span>子类的一组属性。在与Core Data 模型中管理对象子类相关的特性或者关系的每个属性定义之前，将<span class="code">`@NSmanaged`</span>特性加入。与 Objective-C 里面的 <span class="code">`@dynamic`</span>特性类似，<span class="code">`@NSManaged`</span>特性告知 Swift 编译器，这个属性的存储和实现将在运行时完成。但是，与<span class="code">`@dynamic`</span>不同的是，<span class="code">`@NSManaged`</span>特性仅在 Core Data 支持中可用。

Swift 类被命名空间化---他们局限于被编译的模块中（最典型的是Target）。
为了使用带 Core Data 模型的<span class="code">`NSManagedObject`</span>类的 Swift 子类，在模型实体监视器的类区域里，用模块名字作为类名的前缀。

![](https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/Art/coredatanamespace_2x.png)

<span class="xml"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">name</span>=<span class="value">"using_swift_class_names_with_objective_c_apis"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="title">a</span>&gt;</span></span>
<span class="header">## 使用带Objective-C API的Swift类名</span>

Swift 类的命名基于他们被编译的模块，即使是使用来自 Objective-C 的代码。和 Objective-C 不同的是，所有的类都是全局命名空间的一部分，必须没有相同的名字，Swift 类可以基于他们存在的模块来消除歧义。比如，被称为 MyFramework 框架中的被叫做DataManager 的 Swift 类的全限定名就是 MyFramework.DataManager。一个 Swift 应用目标就是模块本身，所以，在一个叫 MyGreatApp 的应用里，叫 Observer 的 Swift 类的全限定名是 MyGreatApp.Observer。

为了保存在 Objective-C 代码里使用的 Swift 类，Swift类用他们的全限定名暴漏给 Objective-C 运行时。因此，当你使用那些对 Swift 类的字符串代表起作用的 API，必须包含类的全限定名。比如，当你创建一个基于文档的 Mac 应用，要在应用的 Info.plist 里提供 NSDocument 子类的名字。Swift里，你必须使用文档子类的全名，包括从你的应用或者框架里派生出来的模块名字。
<span class="code">    下面的例子中，`NSClassFromString`方法用于检索一个来自字符串代表的类的引用。为了检索 Swift 类，需要使用全限定名，包括应用的名字。</span>

<span class="code">```</span>    swift
let myPersonClass:AnyClass(NSClassFromString("MyGreatApp.Person"))
</code></pre></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/03Working with Cocoa Data Types/" itemprop="url">
                02Interoperability-03与 Cocoa 数据类型共舞
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-26T22:00:08+08:00" content="2015-12-26">
            2015-12-26
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Using-Swift-with-Cocoa-and-Objective-C/" itemprop="url" rel="index">
                  <span itemprop="name">Using-Swift-with-Cocoa-and-Objective-C</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/03Working with Cocoa Data Types/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/03Working with Cocoa Data Types/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><blockquote>
<p>翻译：<a href="https://github.com/wongzigii" target="_blank" rel="external">wongzigii</a>、<a href="https://github.com/SemperIdem" target="_blank" rel="external">星夜暮晨</a></p>
<p>校对：<a href="https://github.com/dabing1022" target="_blank" rel="external">ChildhoodAndy</a></p>
</blockquote>
<h2 id="#与_Cocoa_数据类型共舞">#与 Cocoa 数据类型共舞</h2><p>本节内容包括：</p>
<ul>
<li><a href="#strings">字符串（Strings）</a></li>
<li><a href="#numbers">数值（Numbers）</a></li>
<li><a href="#collection_classes">集合类（Collection Classes）</a></li>
<li><a href="#errors">错误（Errors）</a></li>
<li><a href="#foundation_data_types">Foundation数据类型（Foundation Data Types）</a></li>
<li><a href="#foundation_functions">Foundation函数（Foundation Functions）</a></li>
<li><a href="#core_foundation">Core Foundation</a></li>
</ul>
<p>作为对 Objective-C 互用性（互操作性）的一部分，Swift提供快捷高效的方式来处理 Cocoa 数据类型。</p>
<p>Swift 会自动将一些 Objective-C 类型转换为 Swift 类型，以及将 Swift 类型转换为 Objective-C 类型。在 Objective-C 和 Swift 中也有一些具有互用性的数据类型。那些可转换的数据类型或者具有互用性的数据类型被称为<em>bridged</em>数据类型。举个例子，在 Swift 中，我们可以将一个<code>Array</code>值传递给一个要求为<code>NSArray</code>对象的方法。我们也可以转换一个 bridged 类型和它的副本。当我们使用<code>as</code>转换 bridged 类型或者那些由常量和变量所提供的类型时，Swift 会桥接它们的数据类型。</p>
<p>Swift 也提供一种简单便捷的覆盖方法来连接 Foundation 的数据类型，在后面的 Swift 语言中，我们能在它的句法中感受到自然和统一。</p>
<p><a name="strings"></a></p>
<p>##字符串</p>
<p>Swift会在<code>String</code>类型和<code>NSString</code>类型中自动转换。这意味着在可以使用<code>NSString</code>对象的地方，我们可以使用一个属于 Swift 的<code>String</code>类型代替它，这样做会同时拥有它们数据类型的特点，比如说<code>String</code>类型的字符串插值，基于Swift设计的API，以及<code>NSString</code>类的多种功能。因此，我们几乎不必再在我们的代码中使用<code>NSString</code>类。事实上，当 Swift 接入 Objective-C API 时，它将把所有<code>NSString</code>类型替换为<code>String</code>类型。当我们在我们的Objective-C代码中使用 Swift 类时，接入的API会将所有<code>String</code>类型替换成<code>NSString</code>类型。</p>
<p>为了允许字符串转换，只需导入Foundation框架。举个例子，我们在 Swift的一个字符串中可以访问<code>capitalizedString</code>，这是<code>NSString</code>类的一个属性，然后 Swift 会自动将<code>String</code>转换为一个<code>NSString</code>对象来访问这个属性。这个属性甚至会返回一个 Swift的<code>String</code>类型，因为它在导入的时候被替换了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">let</span> greeting = <span class="string">"hello, world!"</span></span><br><span class="line"><span class="keyword">let</span> capitalizedGreeting = greeting.capitalizedString</span><br><span class="line"><span class="comment">// capitalizedGreeting: String = Hello, World!</span></span><br></pre></td></tr></table></figure>
<p>如果我们确实需要用到一个<code>NSString</code>对象，我们可以用一个 Swift 的<code>String</code>值并转换它。<code>String</code>类型总是可以从一个<code>NSString</code>对象转换为一个Swift的<code>String</code>的值，因此，再没有必要去使用一个可选的类型转换器(<code>as?</code>)。我们也可以在一个字符串中通过定义常量和变量来创建一个<code>NSString</code>对象。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">let</span> myString: <span class="type">NSString</span> = <span class="string">"123"</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> integerValue = <span class="type">Int</span>(myString <span class="keyword">as</span> <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(myString)</span> is the integer <span class="subst">\(integerValue)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// prints "123 is the integer 123"</span></span><br></pre></td></tr></table></figure>
<p>###本地化<br>在Objective-C中，常用<code>NSLocalizedString</code>类的宏来定位一个字符串。这集合的宏包括<code>NSLocalizedString</code>，<code>NSLocalizedStringFromTable</code>，<code>NSLocalizedStringFromTableInBundle</code>，和<code>NSLocalizedStringWithDefaultValue</code>。而在Swift中，只用一个函数就可以实现跟整个<code>NSLocalizedString</code>集一样的功能，即<code>NSLocalizedString(key:tableName:bundle:value:comment:)</code>。这个<code>NSLocalizedString</code>函数分别为<code>tableName</code>，<code>bundle</code>和<code>value</code>参数提供了一个默认值。我们可以用它来替换宏。</p>
<p><a name="numbers"></a></p>
<p>##数值</p>
<p>Swift会自动将已确定的数值类型<code>Int</code>和<code>Float</code>转换为<code>NSNumber</code>。这样的转换允许我们基于其中一种类型创建一个<code>NSNumber</code>：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let <span class="keyword">n</span> = 42</span><br><span class="line">let <span class="keyword">m</span>: NSNumber = <span class="keyword">n</span></span><br></pre></td></tr></table></figure>
<p>我们也能传递一个<code>Int</code>类型的值，比如传递给一个要求为<code>NSNumber</code>类型的参数。同时需要注意的是，<code>NSNumber</code>可以包含多种不同的类型，因此我们不能把它传递给单一的一个<code>Int</code>值。</p>
<p>下面所列出的类型都会自动转换为<code>NSNumber</code>：</p>
<ul>
<li><code>Int</code></li>
<li><code>UInt</code></li>
<li><code>Float</code></li>
<li><code>Double</code></li>
<li><code>Bool</code></li>
</ul>
<p><a name="collection_classes"></a></p>
<p>##集合类</p>
<p>Swift 会自动将<code>NSArray</code>、<code>NSSet</code>和<code>NSDictionary</code>类转换为Swift里等价的类：<code>Array</code>、<code>Set</code>和<code>Dictionary</code>。这意味着我们将受益于Swift强大的算法和得天独厚的语法来处理集合–可互相转换的 Foundation 和 Swift 集合类型。</p>
<p>###数组(Arrays)</p>
<p>Swift 会在<code>Array</code>类型和<code>NSArray</code>类型中自动转换。当我们从一个 Swift 数组转换成一个<code>NSArray</code>对象后，转换后的结果则是一个<code>[ObjectType]</code>类型的数组。如果<code>NSArray</code>对象没有指明一个确切的参数类型，那么它将会转换成<code>[AnyObject]</code>类型的Swift数组。</p>
<p>比如说，我们看到以下Objective-C声明：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSDate</span> *&gt;* dates;</span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">NSDate</span> *&gt; *)datesBeforeDate:(<span class="built_in">NSDate</span> *)date;</span><br><span class="line">- (<span class="keyword">void</span>)addDatesParsedFromTimestamps:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)timestamps;</span><br></pre></td></tr></table></figure>
<p>那么，转换为Swift，则是这样子的：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dates: [<span class="type">NSDate</span>]</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">datesBeforeDate</span><span class="params">(date: NSDate)</span></span> -&gt; [<span class="type">NSDate</span>]</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">addDatesParsedFromTimestamps</span><span class="params">(timestamps: [String])</span></span></span><br></pre></td></tr></table></figure></p>
<p>如果某个对象是 Objective-C 或者 Swift 类的实例，或者这个对象可以转换成另一种类型，那么这个对象则属于<code>AnyObject</code>类型的对象。我们可以将任一<code>NSArray</code>对象转换成一个 Swift 数组，因为所有 Objective-C 的对象都是<code>AnyObject</code>类型的。正因如此，Swift 的编译器会在接入 Objective-C APIs 的时候将<code>NSArray</code>类替换成<code>AnyObject[]</code>。</p>
<p>当我们将一个<code>NSArray</code>对象转换成一个 Swift 数组后，我们也可以将数组强制类型转换成一个特定的类型。与从<code>NSArray</code>类转换到<code>AnyObject[]</code>不同的是，从<code>AnyObject</code>类型的对象转换成明确的类型并不会保证成功。由于直到运行时编译器才知道<code>AnyObject</code>的对象能否被强制转换为特定的类型，因此，从<code>AnyObject[]</code>转换为<code>SomeType[]</code>会返回一个 optional 的值。举个例子，如果我们知道一个Swift数组只包含<code>UIView</code>类的实例(或者一个<code>UIView</code>类的子类)，我们可以将<code>AnyObject</code>类型的数组元素强制转换为<code>UIView</code>对象。如果Swift数组中的元素在运行时不是<code>UIView</code>类型的对象，那么转换则会返回<code>nil</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> swiftyArray = foundationArray <span class="keyword">as</span> <span class="type">AnyObject</span>[]</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> downcastedSwiftArray = swiftArray <span class="keyword">as</span>? <span class="type">UIView</span>[] &#123;</span><br><span class="line">    <span class="comment">// downcastedSwiftArray contains only UIView objects</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以在for循环中将NSArray对象定向地强制转换为特定类型的Swift数组:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> aView: <span class="type">UIView</span>! <span class="keyword">in</span> foundationArray &#123;</span><br><span class="line">     <span class="comment">// aView is of type UIView</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这种转换是强制转换，如果转换不成功则会在运行时产生错误信息。</p>
</blockquote>
<p>当我们从 Swift 数组转换为<code>NSArray</code>对象时，Swift 数组里的元素必须是属于<code>AnyObject</code>的。例如，一个<code>Int[]</code>类型的 Swift 数组包含<code>Int</code>结构的元素。<code>Int</code>类型并不是一个类的实例，但由于<code>Int</code>类型转换成了<code>NSNumber</code>类，<code>Int</code>类型属于<code>AnyObject</code>类型的。因此，我们可以将一个<code>Int[]</code>类型的Swift数组转换为<code>NSArray</code>对象。如果 Swift 数组里的一个元素不属于<code>AnyObject</code>类型，那么在运行时就会产生错误。</p>
<p>我们也可以从 Swift 数组中创建一个<code>NSArray</code>对象。当我们将一个常量或变量定义为一个<code>NSArray</code>对象并分配一个数组给它作为实例变量时，Swift 将会创建 <code>NSArray</code>对象，而不是 Swift 数组。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> schoolSupplies: <span class="type">NSArray</span> = [<span class="string">"Pencil"</span>, <span class="string">"Eraser"</span>, <span class="string">"Notebkko"</span>]</span><br><span class="line"><span class="comment">// schoolSupplies is an NSArray object containing NSString objects</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，Swift 数组包含包含三个<code>String</code>字符串。由于从<code>String</code>类型转换为<code>NSString</code>类，数组字面量被转换成一个<code>NSArray</code>对象，并成功分配给<code>schoolSupplies</code>变量。</p>
<p>当我们在 Objective-C 代码中使用 Swift 类或者协议时，接入的API会将全部所有类型的Swift数组代替为<code>NSArray</code>。若我们将一个<code>NSArray</code>对象传递给Swift的API并要求数组元素为一个新的类型，运行时就会产生错误。如果 Swift API 返回一个不能被转换为<code>NSArray</code>类型的 Swift 数组，错误也会随之产生。</p>
<p>###集合(Sets)</p>
<p>除了数组以外，Swift还会自动在<code>Set</code>类型和<code>NSSet</code>类之间进行转换。当我们将一个带有参数类型的<code>NSSet</code>对象转换为Swift集合之后，得到的结果是<code>Set&lt;ObjectType&gt;</code>类型的集合。而如果<code>NSSet</code>对象没有指明其参数类型，那么它将会转换为<code>Set&lt;AnyObject&gt;</code>类型的Swift集合。</p>
<p>比如说，我们看到以下Objective-C声明：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt;* words;</span><br><span class="line">- (<span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt; *)wordsMatchingPredicate:(<span class="built_in">NSPredicate</span> *)predicate;</span><br><span class="line">- (<span class="keyword">void</span>)removeWords:(<span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt; *)words;</span><br></pre></td></tr></table></figure>
<p>那么，转换为Swift，则是这个样子的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> words: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">wordsMatchingPredicate</span><span class="params">(predicate: NSPredicate)</span></span> -&gt; <span class="type">Set</span>&lt;<span class="type">String</span>&gt;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">removeWords</span><span class="params">(words: Set&lt;String&gt;)</span></span></span><br></pre></td></tr></table></figure>
<p>我们能够将所有<code>NSSet</code>对象转换为Swift集合，因为所有的Objective-C对象都可以被转换为<code>AnyObject</code>。所有的<code>NSSet</code>对象都能够转换为Swift对象，因此Swift编译器将会在导入Objective-C API的时候，将所有的<code>NSSet</code>类转换为<code>Set&lt;AnyObject&gt;</code>。同理，当我们在Objective-C中使用Swift类或者协议的时候，导入器将会将Swift集合重新映射为Objective-C兼容的类型：<code>NSSet</code>对象。</p>
<p>当我们将<code>NSSet</code>对象转换为Swift集合后，还可以将集合下转为其他指定类型。就如同Swift数组的下转一样，Swift集合的下转不确保一定成功。对<code>Set&lt;AnyObject&gt;</code>下转为指定类型的结果需要使用<code>as?</code>操作符，以确保其是可选值。</p>
<p>我们仍然可以直接从Swift数组字面量中直接创建一个<code>NSSet</code>对象，它同样遵循上面提到的转换规则。当我们明确地将某个常量或者变量定义为<code>NSSet</code>对象，并且使用一个数组字面量来赋值的时候，Swift将会创建一个<code>NSSet</code>对象，而不是Swift集合。</p>
<p>###字典(Dictionaries)</p>
<p>Swift同样可以在<code>Dictionary</code>和<code>NSDictionary</code>类当中自动转换。当我们将带有参数类型的<code>NSDictionary</code>对象转换为Swift字典之后，得到的结果是一个<code>[ObjectType]</code>类型的字典。如果<code>NSDictionary</code>对象没有指明参数类型，那么它将会被转换为<code>[NSObject:AnyObject]</code>类型的Swift字典。</p>
<p>比如说，我们看到以下Objective-C声明：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSURL</span> *, <span class="built_in">NSData</span> *&gt;* cachedData;</span><br><span class="line">- (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSURL</span> *, <span class="built_in">NSNumber</span> *&gt; *)fileSizesForURLsWithSuffix:(<span class="built_in">NSString</span> *)suffix;</span><br><span class="line">- (<span class="keyword">void</span>)setCacheExpirations:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSURL</span> *, <span class="built_in">NSDate</span> *&gt; *)expirations;</span><br></pre></td></tr></table></figure>
<p>那么，转换为Swift，则是这个样子的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cachedData: [<span class="type">NSURL</span>: <span class="type">NSData</span>]</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">fileSizesForURLsWithSuffix</span><span class="params">(suffix: String)</span></span> -&gt; [<span class="type">NSURL</span>: <span class="type">NSNumber</span>]</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">setCacheExpirations</span><span class="params">(expirations: [NSURL: NSDate])</span></span></span><br></pre></td></tr></table></figure>
<p>我们能够将所有的<code>NSDictionary</code>对象转换为Swift字典，因为所有的Objective-C对象都兼容<code>AnyObject</code>。重申一下，某个对象能够“兼容”<code>AnyObject</code>，指的是其是Objective-C的一个实例，或者是Swift的类，亦或者是能够转换为这两者之一的东西。所有的<code>NSDictionary</code>对象都能够转换为Swift字典，因此Swift编译器会在导入Objective-C API的时候，将所有的<code>NSDictionary</code>类替换成<code>[NSObject: AnyObject]</code>。同理，当我们在Objective-C中使用Swift类或者协议的时候，导入器将会将Swift字典重新映射为Objective-C兼容的类型：<code>NSDictionary</code>对象。</p>
<p>当我们将<code>NSDictionary</code>对象转换为Swift字典后，还可以将字典<em>下转</em>为其他指定类型。就如同Swift数组的下转一样，Swift字典的下转不确保一定成功。对<code>[NSObject: AnyObject]</code>下转为指定类型的结果需要使用<code>as?</code>操作符，以确保其是可选值。</p>
<p>当我们进行反向转换，也就是将Swift字典转换为<code>NSDictionary</code>对象的过程中，其键值都必须是某个类的实例，或者能够被转换为某个类的实例。</p>
<p>我们仍然可以直接从Swift数组字面量中直接创建一个<code>NSDictionary</code>对象，它同样遵循上面提到的转换规则。当我们明确地将某个常量或者变量定义为<code>NSDictionary</code>对象，并且使用一个数组字面量来赋值的时候，Swift将会创建一个<code>NSDictionary</code>对象，而不是Swift字典。</p>
<p><a name="errors"></a></p>
<p>##错误</p>
<p>Swift能够自动在<code>ErrorType</code>类型和<code>NSError</code>类之间转换，会发生错误的Objective-C方法等价于Swift中的<code>throw</code>方法，而会发生错误的Swift方法通过Objecitive-C错误约定，也等价于产生错误的Objective-C方法。</p>
<p>实现<code>ErrorType</code>协议，并且使用<code>@objc</code>特性声明的Swift枚举类型，会产生一个<code>NS_ENUM</code>声明和一个<code>NSString</code>常量，以能够在产生的头文件中设定对应的错误范围。比如说，有以下Swift枚举声明代码：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@objc</span> public <span class="class"><span class="keyword">enum</span> <span class="title">CustomError</span>: <span class="title">Int</span>, <span class="title">ErrorType</span> &#123;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="constant">A</span>, <span class="constant">B</span>, <span class="constant">C</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，在相应的生成头文件中的Objectivive-C声明就是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Project-Swift.h</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">SWIFT_ENUM</span><span class="params">(NSInteger, CustomError)</span> </span>&#123;</span><br><span class="line">  CustomErrorA = <span class="number">0</span>,</span><br><span class="line">  CustomErrorB = <span class="number">1</span>,</span><br><span class="line">  CustomErrorC = <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> NSString * <span class="keyword">const</span> CustomErrorDomain = @<span class="string">"Project.CustomError"</span>;</span><br></pre></td></tr></table></figure>
<p>关于更多Swift和Objective-C API中错误处理的相关信息，请参阅<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-ID10" target="_blank" rel="external">Error Handling</a>。</p>
<p><a name="foundation_data_types"></a></p>
<p>##Foundation数据类型<br>Swift 也提供一种简单便捷的覆盖方法来连接定义在 Foundation 框架中的数据类型。在<code>CGSize</code>和<code>CGPoint</code>中使用覆盖方法，我们就能在它的句法中感受到Swift语言的自然和统一。比如，我们可以使用如下语法创建一个<code>CGSize</code>类型的结构:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> size = <span class="type">CGSize</span>(width: <span class="number">20</span>, height: <span class="number">40</span>)</span><br></pre></td></tr></table></figure>
<p>覆盖方法也允许我们以一种自然的方式调用 Foundation 的结构函数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rect = <span class="type">CGRect</span>(x: <span class="number">50</span>, y: <span class="number">50</span>, width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line"><span class="keyword">let</span> width = rect.width    <span class="comment">// equivalent of CGRectGetWidth(rect)</span></span><br><span class="line"><span class="keyword">let</span> maxX = rect.maxY      <span class="comment">// equivalent of CGRectGetMaxY(rect)</span></span><br></pre></td></tr></table></figure>
<p>Swift可以将<code>NSUInteger</code>和<code>NSInteger</code>转换为<code>Int</code>类型。这些类型都会在 Foundation APIs 中变为<code>Int</code>类型。在 Swift 中<code>Int</code>常被尽可能地用以连贯性，同时当我们要求一个无符号整数类型时，<code>UInt</code>类型总是可使用的。</p>
<p><a name="foundation_functions"></a></p>
<p>##Foundation函数</p>
<p>在 Swift 中，<code>NSLog</code>可在系统控制台输出信息。我们可以像在 Objective-C 中使用过的语法格式那样使用此函数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSLog</span>(<span class="string">"%.7f"</span>, pi)</span><br><span class="line"><span class="comment">// Logs "3.1415927" to the console</span></span><br></pre></td></tr></table></figure>
<p>同时，Swift 也提供像<code>print(_:)</code>这样的输出函数。多亏于 Swift 的字符插值机制才让这些函数简单，粗暴，高效。这些函数不会在系统控制台输出信息，但在需要调用的时候却是可用的。</p>
<p>Swift 中不再存在<code>NSAssert</code>函数，取而代之的是<code>assert</code>函数。</p>
<p><a name="core_foundation"></a></p>
<p>##Core Foundation</p>
<p>Swift中的 Core Foundation 类型是一个成熟的类。当出现内存管理注释时，Swift 会自动地管理 Core Foundation 对象的内存，这其中包括我们实例化了的 Core Foundation 对象。在 Swift 中，我们可以自由变换 Fundation 和 Core Foundation 类型。如果我们想先转换为桥接 Foundation 类型时，那么也可以桥接一些 toll-free bridged Core Foundation 类型到 Swift 标准库类型。</p>
<p>###重映射类型(Remapped Types)</p>
<p>当 Swift 导入 Core Foundation 类型时，编译器会重映射导入的类型名字。编译器会从每个类型名字的末端移除 <em>Ref</em>，这是因为所有的 Swift 类都属于引用类型，因此后缀是多余的。</p>
<p>Core Foundation 中的<code>CFTypeRef</code>类型会对<code>Anyobject</code>类型重映射。所以我们以前使用的<code>CFTypeRef</code>，现在该换成<code>AnyObject</code>了。</p>
<p>###内存管理对象(Memory Managed Objects)</p>
<p>在 Swift 中，从 annotated APIs 返回的 Core Foundation 对象能够自动进行内存管理–我们不再需要调用自身的<code>CFRetain</code>，<code>CFRelease</code>，或者<code>CFAutorelease</code>函数。</p>
<p>如果我们从自身的C函数和 Objective-C 方法中返回一个 Core Foundation 对象，我们需要用<code>CF_RETURNS_RETAINED</code>或者<code>CF_RETURNS_NOT_RETAINED</code>注释这个对象。我们同样可以使用<code>CF_IMPLICIT_BRIDGING_ENABLED</code>和<code>CF_IMPLICIT_BRIDGING_DISABLED</code>宏命令来封装C函数声明，这些函数遵循Core Foundation的管理规定、命名规定，以便能够根据命名退导出内存管理机制能。</p>
<p>如果我们只调用那些不会间接返回 Core Foundation 对象的 annotated APIs，那么现在我们可以跳过本节的剩余部分了。否则，下面我们继续学习非托管的 Core Foundation 对象。</p>
<p>###非托管对象(Unmanaged Objects)</p>
<p>当 Swift 导入 unannotated 的APIs时，编译器将不会自动地对返回的 Core Foundation 对象进行内存管理托管。Swift 将这些返回的 Core Foundation 对象封闭在一个<code>Unmanaged&lt;T&gt;</code>结构中。那些间接返回 Core Foundation 的对象也是非托管的。举个例子，这里有一个 unannotated 的 C 函数:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CFStringRef</span> <span class="type">StringByAddingTwoStrings</span>(<span class="type">CFStringRef</span> string1, <span class="type">CFStringRef</span> string2)</span><br></pre></td></tr></table></figure>
<p>这里说明了Swift是怎么导入的:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">StringByAddingTwoStrings</span><span class="params">(CFString!, CFString!)</span></span> -&gt; <span class="type">Unmanaged</span>&lt;<span class="type">CFString</span>&gt;!</span><br></pre></td></tr></table></figure>
<p>假设我们从 unannotated APIs 接收了非托管的对象，在使用它之前，我们必须将它转换为能够内存管理的对象。在这方面，Swift 可以帮我们进行内存管理而不用自己动手。同时，<code>Unmanaged&lt;T&gt;</code>结构也提供了两个方法来把一个非托管对象转换为一个可内存管理的对象–<code>takeUnretainedValue()</code>方法和<code>takeRetainedValue()</code>方法。这两个方法会返回原始的，非封闭的对象类型。我们可以根据我们实际调用的APIs返回的unretained或retained的对象，来选择哪一方法更合适。</p>
<p>比如，假设这里有一个 C 函数，这个函数在返回值前不会释放<code>CFString</code>对象。在使用这个对象前，我们使用<code>takeUnretainedValue()</code>函数，以将它转换为一个能够内存管理托管的对象。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> memoryManagedResult = <span class="type">StringByAddingTwoStrings</span>(str1, str2).takeUnretainedValue()</span><br><span class="line"><span class="comment">// memoryManagedResult is a memory managed CFString</span></span><br></pre></td></tr></table></figure>
<p>我们也可以在一个非托管的对象中使用<code>retain()</code>，<code>release()</code>和<code>autorelease()</code>方法，但是这种做法并不值得推荐。</p>
<p>要了解更多信息，请参考<a href="https://developer.apple.com/library/prerelease/ios/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/CFMemoryMgmt.html#//apple_ref/doc/uid/10000127i" target="_blank" rel="external">Memory Management Programming Guide for Core Foundation</a>中的<a href="https://developer.apple.com/library/prerelease/ios/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148" target="_blank" rel="external">Memory Management Programming Guide for Core Foundation</a>一节。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/04Adopting Cocoa Design Patterns/" itemprop="url">
                02Interoperability-04采用Cocoa设计模式
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-26T22:00:07+08:00" content="2015-12-26">
            2015-12-26
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Using-Swift-with-Cocoa-and-Objective-C/" itemprop="url" rel="index">
                  <span itemprop="name">Using-Swift-with-Cocoa-and-Objective-C</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/04Adopting Cocoa Design Patterns/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/04Adopting Cocoa Design Patterns/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><blockquote>
<p>翻译：<a href="https://github.com/JaceFu" target="_blank" rel="external">JaceFu</a> <a href="https://github.com/dabing1022" target="_blank" rel="external">ChildhoodAndy</a></p>
<p>校正：<a href="https://github.com/LunaticM" target="_blank" rel="external">LunaticM</a> <a href="https://github.com/dabing1022" target="_blank" rel="external">ChildhoodAndy</a></p>
</blockquote>
<h2 id="#采用Cocoa设计模式">#采用Cocoa设计模式</h2><p>本页包含内容：</p>
<ul>
<li><a href="#Delegation">委托（Delegation）</a></li>
<li><a href="#error_handling">错误处理（Error Handling）</a></li>
<li><a href="#Key-Value_Observing">键值观察（Key-Value Observing）</a></li>
<li><a href="#Target_Action">Target-Action模式（Target-Action）</a></li>
<li><a href="#Introspection">类型匹配与统一规范（Introspection）</a></li>
<li><a href="#API_Availability">API 可用性</a></li>
</ul>
<p>使用 Cocoa 现有的一些设计模式，是帮助开发者开发一款拥有合理设计思路、稳定的性能、良好的可扩展性应用的有效方法之一。这些模式都依赖于在 Objective-C 中定义的类。因为 Swift 与 Objective-C 的互用性，所以你依然可以在 Swift 代码中使用这些设计模式。在一些情况下，你甚至可以使用 Swift 语言的特性扩展或简化这些 Cocoa 设计模式，使这些设计模式更强大、更易于使用。</p>
<p><a name="Delegation"></a></p>
<h2 id="委托">委托</h2><p>在 Swift 和 Objective-C 中，委托通常由一个定义交互方法和遵循规范的委托属性的协议表示。与 Objective-C 相比，当你在 Swift 中继承一个委托时，虽然继承模式不变，但是内部的实现已经改变了。就像在 Objective-C 中，在你向委托发送消息之前，不管它是不是 <code>nil</code> 你都会去查看，如果定义的方法是非必须实现的方法，不管委托有没有实现这个方法，你也都会去查看。而在 Swift 中，通过保持类型安全的特性，可以有效的消除这些繁琐、不必要的行为问题。</p>
<p>下面列出的代码可以说明这个过程：</p>
<ol>
<li>检查 <code>myDelegate</code> 不为 <code>nil</code>。</li>
<li>检查 <code>myDelegate</code> 是否实现了继承的 <code>window:willUseFullScreenContentSize:</code> 方法。</li>
<li>如果<code>myDelegate</code> 不为 <code>nil</code> 并且实现了 <code>window:willUseFullScreenContentSize:</code> 方法，那么调用该方法，将该方法的返回值分配给名为 <code>fullScreenSize</code> 的属性。</li>
<li>将该方法的返回值输出在控制台。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @inteface MyObject : NSObject</span></span><br><span class="line"><span class="comment">// @property (nonatomic, weak) id&lt;NSWindowDelegate&gt; delegate;</span></span><br><span class="line"><span class="comment">// @end</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> fullScreenSize = myDelegate?.window?(myWindow, willUseFullScreenContentSize: mySize) &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="type">NSStringFromSize</span>(fullScreenSize))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>在一个完全使用 Swift 编写的 app 中，在定义 <code>delegate</code> 属性时，它作为一个不定值的 <code>NSWindowDelegate</code> 对象，并将初始值设为 <code>nil</code>。</p>
</blockquote>
<h2 id="错误处理">错误处理</h2><p>在 Cocoa 中，产生错误的方法将<code>NSError</code>指针参数作为最后一个参数，当错误产生时，该参数会被<code>NSError</code>对象填充。Swift 自动的将 Objective-C 中产生错误的方法转换为 Swift 的原生错误处理功能。</p>
<blockquote>
<p>注意</p>
<p>产生错误的方法，例如代理方法或者采用一个<code>NSError</code>对象作为参数的完成处理函数，不会被 Swift 处理为<code>throw</code>的方法。</p>
</blockquote>
<p>例如，考虑下面的来自于<code>NSFileManager</code>的 Objective-C 方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)removeItemAtURL:(NSURL *)URL&#10;                  error:(NSError **)error;</span><br></pre></td></tr></table></figure>
<p>在 Swift 中，它会被这样的导入：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">removeItemAtURL</span><span class="params">(URL: NSURL)</span></span> throws</span><br></pre></td></tr></table></figure>
<p>注意到<code>removeItemAtURL(_:)</code>方法被 Swift 导入时，返回值类型为 Void，没有错误参数，而是一个<code>throws</code>声明。</p>
<p>如果 Objective-C 方法的最后一个非闭包参数是<code>NSError **</code>类型，Swift 则会将之替换为<code>throws</code>关键字，以表明该方法可以抛出一个错误。如果 Objective-C 方法的错误参数也是它的第一个参数，Swift 则会尝试通过删除选择器的第一部分中的<code>AndReturnError</code>后缀来进一步简化方法的名称，如果存在的话。如果另一种方法是用所得选择器声明的，那么该方法名将不可改变。</p>
<p>如果产生错误的 Objective-C 的方法返回一个用来表示方法调用成功或失败的<code>BOOL</code>值，Swift 会把函数的返回值转换为<code>Void</code>。同样的，如果产生错误的 Objective-C 方法返回一个<code>nil</code>值来表明方法调用的失败，Swift 会把函数的返回值转换为非可选值类型。</p>
<p>否则，如果没有约定可以推断，该方法保持不变。</p>
<h3 id="捕获和处理错误">捕获和处理错误</h3><p>在 Objective-C 中，错误处理是可选的，意味着方法产生的错误会被忽略除非你提供了一个错误指针。在 Swift 中，调用一个会抛出错误的方法要求显示的进行错误处理。</p>
<p>下面是如何在 Objective-C 中处理调用方法产生的错误：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSFileManager *fileManager = [NSFileManager defaultManager];&#10;NSURL *URL = [NSURL fileURLWithPath:@&#34;/path/to/file&#34;];&#10;NSError *error = nil;&#10;BOOL success = [fileManager removeItemAtURL:URL error:&#38;error];&#10;if (!success &#38;&#38; error) &#123;&#10;    NSLog(@&#34;Error: %@&#34;, error.domain);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>下面是 Swift 中等同的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fileManager = <span class="type">NSFileManager</span>.defaultManager()</span><br><span class="line"><span class="keyword">let</span> <span class="type">URL</span> = <span class="type">NSURL</span>.fileURLWithPath(<span class="string">"/path/to/file"</span>)</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    try fileManager.removeItemAtURL(<span class="type">URL</span>)</span><br><span class="line">&#125; catch <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">NSError</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Error: <span class="subst">\(error.domain)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="抛出错误">抛出错误</h3><p>如果一个错误出现在了 Objective-C 方法中，那么该错误被用来填充方法的错误指针参数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// an error occurred</span></span><br><span class="line"><span class="keyword">if</span> (errorPtr) &#123;</span><br><span class="line">   *errorPtr = [<span class="type">NSError</span> errorWithDomain:<span class="type">NSURLErrorDomain</span></span><br><span class="line">                                   code:<span class="type">NSURLErrorCannotOpenFile</span></span><br><span class="line">                               userInfo:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个错误出现在了 Swift 方法中，那么该错误便会被抛出，并且会自动的传递给调用者：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// an error occurred</span></span><br><span class="line">throw <span class="type">NSError</span>(domain: <span class="type">NSURLErrorDomain</span>, code: <span class="type">NSURLErrorCannotOpenFile</span>, userInfo: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>如果 Objective-C 代码调用 Swift 方法抛出了错误，那么该错误会被自动的传递给桥接的 Objective-C 方法的错误指针参数。</p>
<p>例如，考虑<code>NSDocument</code>中的<code>readFromFileWrapper(_:ofType:)</code>方法。在 Objective-C 中，这个方法的最后一个参数是<code>NSError **</code>。当在 Swift 的<code>NSDocument</code>的子类中重写该方法时，该方法会用<code>throws</code>替代错误指针参数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerializedDocument</span>: <span class="title">NSDocument</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">ErrorDomain</span> = <span class="string">"com.example.error.serialized-document"</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> representedObject: [<span class="type">String</span>: <span class="type">AnyObject</span>] = [:]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">readFromFileWrapper</span><span class="params">(fileWrapper: NSFileWrapper, ofType typeName: String)</span></span> throws &#123;</span><br><span class="line">        guard <span class="keyword">let</span> data = fileWrapper.regularFileContents <span class="keyword">else</span> &#123;</span><br><span class="line">            throw <span class="type">NSError</span>(domain: <span class="type">NSURLErrorDomain</span>, code: <span class="type">NSURLErrorCannotOpenFile</span>, userInfo: <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> <span class="type">JSON</span> <span class="keyword">as</span> [<span class="type">String</span>: <span class="type">AnyObject</span>] = try <span class="type">NSJSONSerialization</span>.<span class="type">JSONObjectWithData</span>(data, options: []) &#123;</span><br><span class="line">            <span class="keyword">self</span>.representedObject = <span class="type">JSON</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            throw <span class="type">NSError</span>(domain: <span class="type">SerializedDocument</span>.<span class="type">ErrorDomain</span>, code: -<span class="number">1</span>, userInfo: <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果方法不能够使用常规的文件的内容来创建一个对象，则会抛出一个<code>NSError</code>对象。如果方法是从 Swift 代码中调用的，那么该错误会被传递到它的调用域。如果该方法是在 Objective-C 代码中被调用，错误将会传递到错误指针参数里。</p>
<p>在 Objective-C 中，错误处理是可选的，意味着方法产生的错误会被忽略除非你提供了一个错误指针。在 Swift 中，调用一个会抛出错误的方法要求显式的进行错误处理。</p>
<blockquote>
<p>注意</p>
<p>尽管 Swift 的错误处理类似 Objective-C 的异常处理，但它是完全独立的功能。如果一个 Objective-C 方法抛出了一个运行时异常，Swift 则会触发一个运行时错误。没有办法直接在 Swift 中恢复来自 Objective-C 的异常。任何在 Objective-C 代码中的异常处理行为必须用 Swift 来实现。</p>
</blockquote>
<p><a name="Key-Value_Observing"></a></p>
<p>##键值观察</p>
<p>键值观察是一种机制，该机制允许对象获得其他对象的特定属性的变化的通知。只要你的类继承自 NSObject 类，你便可在 Swift 类里使用键值观察。你可以在 Swift 中使用下面三步来实现键值观察：</p>
<ol>
<li>为你想要观察的属性添加动态修改符。关于<code>dynamic</code>更多信息，请见<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID57" target="_blank" rel="external">Requiring Dynamic Dispatch</a></li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObjectToObserve</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    dynamic <span class="keyword">var</span> myDate = <span class="type">NSDate</span>()</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">updateDate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        myDate = <span class="type">NSDate</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>创建一个全局上下文变量。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">var</span> myContext = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ol>
<li>为键-路径增加一个观察者，重写<code>observeValueForKeyPath:ofObject:change:context:</code>函数，并且在<code>deinit</code>中移除观察者。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObserver</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> objectToObserve = <span class="type">MyObjectToObserve</span>()</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        objectToObserve.addObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"myDate"</span>, options: .<span class="type">New</span>, context: &amp;myContext)</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">observeValueForKeyPath</span><span class="params">(keyPath: String?, ofObject object: AnyObject?, change: [NSObject : AnyObject]?, context: UnsafeMutablePointer&lt;Void&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> context == &amp;myContext &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> newValue = change?[<span class="type">NSKeyValueChangeNewKey</span>] &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Date changed: <span class="subst">\(newValue)</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.observeValueForKeyPath(keyPath, ofObject: object, change: change, context: context)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        objectToObserve.removeObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"myDate"</span>, context: &amp;myContext)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="Target_Action"></a></p>
<p>##Target-Action模式（Target-Action）##<br>当有特定事件发生，需要一个对象向另一个对象发送消息时，我们通常采用 Cocoa 的 Target-Action 设计模式。Swift 和 Objective-C 中的 Target-Action 模型基本类似。在 Swift 中，你可以使用 <code>Selector</code> 类型达到 Objective-C 中 selectors 的效果。请在 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID59" target="_blank" rel="external">Objective-C Selectors</a> 中查看在 Swift 中使用 Target-Action 设计模式的示例。</p>
<p><a name="Introspection"></a></p>
<p>##类型匹配与统一规范（Introspection）##<br>在 Objective-C 中，你可以使用 <code>isKindOfClass:</code> 方法检查某个对象是否是指定类型，可以使用 <code>conformsToProtocol:</code> 方法检查某个对象是否遵循特定协议的规范。在 Swift 中，你可以使用 <code>is</code> 运算符完成上述的功能，或者也可以使用 <code>as?</code> 向下匹配指定类型。</p>
<p>你可以使用 <code>is</code> 运算符检查一个实例是否是指定的子类。如果该实例是指定的子类，那么 <code>is</code> 运算结果为 <code>true</code>，反之为 <code>false</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> object <span class="keyword">is</span> <span class="type">UIButton</span> &#123;</span><br><span class="line">    <span class="comment">// object is of type UIButton</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// object is not of type UIButton</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以使用 <code>as?</code> 运算符尝试向下匹配子类型，<code>as?</code> 运算符返回不定值，结合 <code>if-let</code> 语句使用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> button = object <span class="keyword">as</span>? <span class="type">UIButton</span> &#123;</span><br><span class="line">    <span class="comment">// object is successfully cast to type UIButton and bound to button</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// object could not be cast to type UIButton</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请在 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TypeCasting.html#//apple_ref/doc/uid/TP40014097-CH22" target="_blank" rel="external">Type Casting</a> 中查看更多信息。</p>
<p>检查匹配协议的语法与检查匹配类的语法是一样的，下面是使用 <code>as?</code> 检查匹配协议的示例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> dataSource = object <span class="keyword">as</span>? <span class="type">UITableViewDataSource</span> &#123;</span><br><span class="line">    <span class="comment">// object conforms to UITableViewDataSource and is bound to dataSource</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// object not conform to UITableViewDataSource</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，当做完匹配之后，<code>dataSource</code> 会转换为  <code>UITableViewDataSource</code> 类型，所以你只能访问和调用<code>UITableViewDataSource</code> 协议定义的属性和方法。当你想进行其他操作时，必须将其转换为其他的类型。<br><br>可以在 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25" target="_blank" rel="external">Protocols</a> 查看更多相关信息。</p>
<p><a name="API_Availability"></a></p>
<h2 id="API_可用性">API 可用性</h2><p>一些类和方法并不是在你的应用所有平台的所有版本都可用。为了确保你的应用功能上能够适应差异，你需要检查这些 API 的可用性。</p>
<p>在 Objective-C 中，我们使用<code>respondsToSelector:</code>和<code>instancesRespondToSelector:</code>方法来检查一个类或者实例方法是否可用。如果没有检查，调用方法则会抛出<code>NSInvalidArgumentException</code>“unrecognized selector sent to instance”异常。例如，<code>requestWhenInUseAuthorization</code>方法只在 iOS8.0 和 OS X 10.10 中对<code>CLLocationManager</code>实例可用。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if ([CLLocationManager instancesRespondToSelector:@selector(requestWhenInUseAuthorization)]) &#123;&#10;  // &#26041;&#27861;&#21487;&#29992;&#10;&#125; else &#123;&#10;  // &#26041;&#27861;&#19981;&#21487;&#29992;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在 Swift 中，尝试着调用一个目标平台版本不支持的方法将会报出编译时错误。</p>
<p>下面是上一个例子，采用 Swift 编写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> locationManager = <span class="type">CLLocationManager</span>()</span><br><span class="line">locationManager.requestWhenInUseAuthorization()</span><br><span class="line"><span class="comment">// error: only available on iOS 8.0 or newer</span></span><br></pre></td></tr></table></figure>
<p>如果应用的目标低于 ios8.0 或者 OSX10.10，<code>requestWhenInUseAuthorization()</code>方法则不可用，所以编译器会报告错误。</p>
<p>Swift 代码可以使用 API 可用性来作为运行时的条件判断。可用性检查可以使用在一个控制流语句的条件中，例如<code>if</code>,<code>guard</code>或者<code>while</code>语句。</p>
<p>拿前面的例子举例，你可以使用<code>if</code>语句来检查可用性，只有当方法在运行时可用时方可调用<code>requestWhenInUseAuthorization()</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> locationManager = <span class="type">CLLocationManager</span>()</span><br><span class="line"><span class="keyword">if</span> #available(iOS <span class="number">8.0</span>, <span class="type">OSX</span> <span class="number">10.10</span>, *) &#123;</span><br><span class="line">    locationManager.requestWhenInUseAuthorization()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者，你可以使用<code>guard</code>语句来检查可用性，除非当前的目标符合规定要求，否则将会退出作用域。这种方法简化了处理不同平台功能的逻辑。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> locationManager = <span class="type">CLLocationManager</span>()</span><br><span class="line">guard #available(iOS <span class="number">8.0</span>, <span class="type">OSX</span> <span class="number">10.10</span>, *) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">locationManager.requestWhenInUseAuthorization()</span><br></pre></td></tr></table></figure>
<p>每个平台参数包括下面列出的平台名称，后面跟着相应的版本号。最后一个参数是一个星号（*），是用来处理未来潜在的平台。</p>
<p>平台名称：</p>
<ul>
<li>iOS</li>
<li>iOSApplicationExtension</li>
<li>OSX</li>
<li>OSXApplicationExtension</li>
<li>watchOS</li>
</ul>
<p>所有的 Cocoa API 都提供有可用性信息，所以你可以很自信的编写应用所针对的平台的代码。</p>
<p>你可以通过 @available 属性来标注声明从而简化你的 API 的可用性检查。@available 属性使用和 #available 同样的语法来做运行时检查，参数都以逗号隔开平台版本需求。</p>
<p>例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@available(iOS <span class="number">8.0</span>, <span class="type">OSX</span> <span class="number">10.10</span>, *)</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">useShinyNewFeature</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>使用 @available 属性标记的方法可以安全的使用满足特定平台需求的可用 API 而不用显式的做可用性检查。</p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/">&laquo;</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/4/">&raquo;</a>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="https://avatars2.githubusercontent.com/u/14305708?v=3&s=460" alt="terry" itemprop="image"/>
          <p class="site-author-name" itemprop="name">terry</p>
        </div>
        <p class="site-description motion-element" itemprop="description">terry yang's blog | java | scala | bi</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">136</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">11</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-next-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yangwei8888" target="_blank">github</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/microsoftgoogles" target="_blank">weibo</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/run-zhi-38" target="_blank">zhihu</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">terry</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  

    <script type="text/javascript">
      var disqus_shortname = 'yangwei888';
      var disqus_identifier = 'page/3/index.html';
      var disqus_title = '';
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
