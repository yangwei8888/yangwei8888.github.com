<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="terry yang's blog | java | scala | bi" />



  <meta name="keywords" content="Hexo,next" />



  <link rel="alternate" href="/atom.xml" title="yosita" type="application/atom+xml" />



  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="terry yang&apos;s blog | java | scala | bi">
<meta property="og:type" content="website">
<meta property="og:title" content="yosita">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="yosita">
<meta property="og:description" content="terry yang&apos;s blog | java | scala | bi">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="yosita">
<meta name="twitter:description" content="terry yang&apos;s blog | java | scala | bi">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>

  <title> yosita </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  

  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?953e46480b0a75d01aaf6d872cc77099";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">yosita</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/18_Error_Handling/" itemprop="url">
                第二章-18错误处理（Error Handling）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:09+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/18_Error_Handling/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/18_Error_Handling/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="错误处理（Error_Handling）">错误处理（Error Handling）</h1><hr>
<blockquote>
<p>2.1<br>翻译+校对：<a href="https://github.com/lyojo" target="_blank" rel="external">lyojo</a> <a href="https://github.com/ray16897188" target="_blank" rel="external">ray16897188</a> 2015-10-23<br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a> 2015-10-24</p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#representing_and_throwing_errors">表示并抛出错误</a></li>
<li><a href="#handling_errors">处理错误</a></li>
<li><a href="#specifying_cleanup_actions">指定清理操作</a></li>
</ul>
<p><em>错误处理（Error handling）</em>是响应错误以及从错误中恢复的过程。Swift 提供了在运行时对可恢复错误的抛出、捕获、传递和操作的一流支持。</p>
<p>某些操作无法保证总是执行完所有代码或总是生成有用的结果。可选类型可用来表示值缺失，但是当某个操作失败时，最好能得知失败的原因，从而可以作出相应的应对。</p>
<p>举个例子，假如有个从磁盘上的某个文件读取数据并进行处理的任务，该任务会有多种可能失败的情况，包括指定路径下文件并不存在，文件不具有可读权限，或者文件编码格式不兼容。区分这些不同的失败情况可以让程序解决并处理某些错误，然后把它解决不了的错误报告给用户。</p>
<blockquote>
<p>注意<br>Swift 中的错误处理涉及到错误处理模式，这会用到 Cocoa 和 Objective-C 中的<code>NSError</code>。关于这个类的更多信息请参见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216" target="_blank" rel="external">Using Swift with Cocoa and Objective-C (Swift 2.1)</a> 中的<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-ID10" target="_blank" rel="external">错误处理</a>。</p>
</blockquote>
<p><a name="representing_and_throwing_errors"></a></p>
<p>##表示并抛出错误</p>
<p>在 Swift 中，错误用符合<code>ErrorType</code>协议的类型的值来表示。这个空协议表明该类型可以用于错误处理。</p>
<p>Swift 的枚举类型尤为适合构建一组相关的错误状态，枚举的关联值还可以提供错误状态的额外信息。例如，你可以这样表示在一个游戏中操作自动贩卖机时可能会出现的错误状态：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">VendingMachineError</span>: <span class="title">ErrorType</span> </span>&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">InvalidSelection</span>				     <span class="comment">//选择无效</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">InsufficientFunds</span>(coinsNeeded: <span class="type">Int</span>) <span class="comment">//金额不足</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">OutOfStock</span>			                 <span class="comment">//缺货</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抛出一个错误可以让你表明有意外情况发生，导致正常的执行流程无法继续执行。抛出错误使用<code>throws</code>关键字。例如，下面的代码抛出一个错误，提示贩卖机还需要<code>5</code>个硬币：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw <span class="type">VendingMachineError</span>.<span class="type">InsufficientFunds</span>(coinsNeeded: <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p><a name="handling_errors"></a></p>
<p>##处理错误</p>
<p>某个错误被抛出时，附近的某部分代码必须负责处理这个错误，例如纠正这个问题、尝试另外一种方式、或是向用户报告错误。</p>
<p>Swift 中有<code>4</code>种处理错误的方式。你可以把函数抛出的错误传递给调用此函数的代码、用<code>do-catch</code>语句处理错误、将错误作为可选类型处理、或者断言此错误根本不会发生。每种方式在下面的小节中都有描述。</p>
<p>当一个函数抛出一个错误时，你的程序流程会发生改变，所以重要的是你能迅速识别代码中会抛出错误的地方。为了标识出这些地方，在调用一个能抛出错误的函数、方法或者构造器之前，加上<code>try</code>关键字，或者<code>try?</code>或<code>try!</code>这种变体。这些关键字在下面的小节中有具体讲解。</p>
<blockquote>
<p>注意<br>Swift 中的错误处理和其他语言中用<code>try</code>，<code>catch</code>和<code>throw</code>进行异常处理很像。和其他语言中（包括 Objective-C ）的异常处理不同的是，Swift 中的错误处理并不涉及解除调用栈，这是一个计算代价高昂的过程。就此而言，<code>throw</code>语句的性能特性是可以和<code>return</code>语句相媲美的。</p>
</blockquote>
<p>###用 throwing 函数传递错误</p>
<p>为了表示一个函数、方法或构造器可以抛出错误，在函数声明的参数列表之后加上<code>throws</code>关键字。一个标有<code>throws</code>关键字的函数被称作<em>throwing 函数</em>。如果这个函数指明了返回值类型，<code>throws</code>关键词需要写在箭头（<code>-&gt;</code>）的前面。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">canThrowErrors</span><span class="params">()</span></span> throws -&gt; <span class="type">String</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">cannotThrowErrors</span><span class="params">()</span></span> -&gt; <span class="type">String</span></span><br></pre></td></tr></table></figure>
<p>一个 throwing 函数可以在其内部抛出错误，并将错误传递到函数被调用时的作用域。</p>
<blockquote>
<p>注意<br>只有 throwing 函数可以传递错误。任何在某个非 throwing 函数内部抛出的错误只能在函数内部处理。</p>
</blockquote>
<p>下面的例子中，<code>VendingMechine</code>类有一个<code>vend(itemNamed:)</code>方法，如果请求的物品不存在、缺货或者花费超过了投入金额，该方法就会抛出一个相应的<code>VendingMachineError</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> price: <span class="type">Int</span></span><br><span class="line">	<span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VendingMachine</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> inventory = [</span><br><span class="line">        <span class="string">"Candy Bar"</span>: <span class="type">Item</span>(price: <span class="number">12</span>, <span class="built_in">count</span>: <span class="number">7</span>),</span><br><span class="line">        <span class="string">"Chips"</span>: <span class="type">Item</span>(price: <span class="number">10</span>, <span class="built_in">count</span>: <span class="number">4</span>),</span><br><span class="line">        <span class="string">"Pretzels"</span>: <span class="type">Item</span>(price: <span class="number">7</span>, <span class="built_in">count</span>: <span class="number">11</span>)</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">var</span> coinsDeposited = <span class="number">0</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">dispenseSnack</span><span class="params">(snack: String)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Dispensing <span class="subst">\(snack)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">vend</span><span class="params">(itemNamed name: String)</span></span> throws &#123;</span><br><span class="line">        guard <span class="keyword">var</span> item = inventory[name] <span class="keyword">else</span> &#123;</span><br><span class="line">            throw <span class="type">VendingMachineError</span>.<span class="type">InvalidSelection</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        guard item.<span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            throw <span class="type">VendingMachineError</span>.<span class="type">OutOfStock</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        guard item.price &lt;= coinsDeposited <span class="keyword">else</span> &#123;</span><br><span class="line">            throw <span class="type">VendingMachineError</span>.<span class="type">InsufficientFunds</span>(coinsNeeded: item.price - coinsDeposited)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        coinsDeposited -= item.price</span><br><span class="line">        --item.<span class="built_in">count</span></span><br><span class="line">        inventory[name] = item</span><br><span class="line">        dispenseSnack(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>vend(itemNamed:)</code>方法的实现中使用了<code>guard</code>语句来提前退出方法，确保在购买某个物品所需的条件中，有任一条件不满足时，能提前退出方法并抛出相应的错误。由于<code>throw</code>语句会立即退出方法，所以物品只有在所有条件都满足时才会被售出。</p>
<p>因为<code>vend(itemNamed:)</code>方法会传递出它抛出的任何错误，在你的代码中调用此方法的地方，必须要么直接处理这些错误——使用<code>do-catch</code>语句，<code>try?</code>或<code>try!</code>；要么继续将这些错误传递下去。例如下面例子中，<code>buyFavoriteSnack(_:vendingMachine:)</code>同样是一个 throwing 函数，任何由<code>vend(itemNamed:)</code>方法抛出的错误会一直被传递到<code>buyFavoriteSnack(_:vendingMachine:)</code>函数被调用的地方。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> favoriteSnacks = [</span><br><span class="line">	<span class="string">"Alice"</span>: <span class="string">"Chips"</span>,</span><br><span class="line">	<span class="string">"Bob"</span>: <span class="string">"Licorice"</span>,</span><br><span class="line">	<span class="string">"Eve"</span>: <span class="string">"Pretzels"</span>,</span><br><span class="line">]</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">buyFavoriteSnack</span><span class="params">(person: String, vendingMachine: VendingMachine)</span></span> throws &#123;</span><br><span class="line">	<span class="keyword">let</span> snackName = favoriteSnacks[person] ?? <span class="string">"Candy Bar"</span></span><br><span class="line">	try vendingMachine.vend(itemNamed: snackName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例中，<code>buyFavoriteSnack(_:vendingMachine:)</code>函数会查找某人最喜欢的零食，并通过调用<code>vend(itemNamed:)</code>方法来尝试为他们购买。因为<code>vend(itemNamed:)</code>方法能抛出错误，所以在调用的它时候在它前面加了<code>try</code>关键字。</p>
<p>###用 Do-Catch 处理错误</p>
<p>可以使用一个<code>do-catch</code>语句运行一段闭包代码来处理错误。如果在<code>do</code>子句中的代码抛出了一个错误，这个错误会与<code>catch</code>子句做匹配，从而决定哪条子句能处理它。</p>
<p>下面是<code>do-catch</code>语句的一般形式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    try expression</span><br><span class="line">    statements</span><br><span class="line">&#125; catch pattern <span class="number">1</span> &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; catch pattern <span class="number">2</span> <span class="keyword">where</span> condition &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>catch</code>后面写一个匹配模式来表明这个子句能处理什么样的错误。如果一条<code>catch</code>子句没有指定匹配模式，那么这条子句可以匹配任何错误，并且把错误绑定到一个名字为<code>error</code>的局部常量。关于模式匹配的更多信息请参考 <a href="../chapter3/07_Patterns.html">模式</a>。</p>
<p><code>catch</code>子句不必将<code>do</code>子句中的代码所抛出的每一个可能的错误都作处理。如果所有<code>catch</code>子句都未处理错误，错误就会传递到周围的作用域。然而，错误还是必须要被某个周围的作用域处理的——要么是一个外围的<code>do-catch</code>错误处理语句，要么是一个 throwing 函数的内部。举例来说，下面的代码处理了<code>VendingMachineError</code>枚举类型的全部枚举值，但是所有其它的错误就必须由它周围的作用域处理：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vendingMachine = <span class="type">VendingMachine</span>()</span><br><span class="line">vendingMachine.coinsDeposited = <span class="number">8</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    try buyFavoriteSnack(<span class="string">"Alice"</span>, vendingMachine: vendingMachine)</span><br><span class="line">&#125; catch <span class="type">VendingMachineError</span>.<span class="type">InvalidSelection</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Invalid Selection."</span>)</span><br><span class="line">&#125; catch <span class="type">VendingMachineError</span>.<span class="type">OutOfStock</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Out of Stock."</span>)</span><br><span class="line">&#125; catch <span class="type">VendingMachineError</span>.<span class="type">InsufficientFunds</span>(<span class="keyword">let</span> coinsNeeded) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Insufficient funds. Please insert an additional <span class="subst">\(coinsNeeded)</span> coins."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “Insufficient funds. Please insert an additional 2 coins.”</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，<code>buyFavoriteSnack(_:vendingMachine:)</code>函数在一个<code>try</code>表达式中调用，因为它能抛出错误。如果错误被抛出，相应的执行会马上转移到<code>catch</code>子句中，并判断这个错误是否要被继续传递下去。如果没有错误抛出，<code>do</code>子句中余下的语句就会被执行。</p>
<p>###将错误转换成可选值</p>
<p>可以使用<code>try?</code>通过将错误转换成一个可选值来处理错误。如果在评估<code>try?</code>表达式时一个错误被抛出，那么表达式的值就是<code>nil</code>。例如下面代码中的<code>x</code>和<code>y</code>具有相同的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">someThrowingFunction</span><span class="params">()</span></span> throws -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> x = try? someThrowingFunction()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> y: <span class="type">Int</span>?</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    y = try someThrowingFunction()</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    y = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>someThrowingFunction()</code>抛出一个错误，<code>x</code>和<code>y</code>的值是<code>nil</code>。否则<code>x</code>和<code>y</code>的值就是该函数的返回值。注意，无论<code>someThrowingFunction()</code>的返回值类型是什么类型，<code>x</code>和<code>y</code>都是这个类型的可选类型。例子中此函数返回一个整型，所以<code>x</code>和<code>y</code>是可选整型。</p>
<p>如果你想对所有的错误都采用同样的方式来处理，用<code>try?</code>就可以让你写出简洁的错误处理代码。例如，下面的代码用几种方式来获取数据，如果所有方式都失败了则返回<code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">fetchData</span><span class="params">()</span></span> -&gt; <span class="type">Data</span>? &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> data = try? fetchDataFromDisk() &#123; <span class="keyword">return</span> data &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> data = try? fetchDataFromServer() &#123; <span class="keyword">return</span> data &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="禁用错误传递">禁用错误传递</h3><p>有时你知道某个 throwing 函数实际上在运行时是不会抛出错误的，在这种情况下，你可以在表达式前面写<code>try!</code>来禁用错误传递，这会把调用包装在一个断言不会有错误抛出的运行时断言中。如果实际上抛出了错误，你会得到一个运行时错误。</p>
<p>例如，下面的代码使用了<code>loadImage(_:)</code>函数，该函数从给定的路径加载图片资源，如果图片无法载入则抛出一个错误。在这种情况下，因为图片是和应用绑定的，运行时不会有错误抛出，所以适合禁用错误传递：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> photo = try! loadImage(<span class="string">"./Resources/John Appleseed.jpg"</span>)</span><br></pre></td></tr></table></figure>
<p><a name="specifying_cleanup_actions"></a></p>
<p>##指定清理操作</p>
<p>可以使用<code>defer</code>语句在即将离开当前代码块时执行一系列语句。该语句让你能执行一些必要的清理工作，不管是以何种方式离开当前代码块的——无论是由于抛出错误而离开，还是由于诸如<code>return</code>或者<code>break</code>的语句。例如，你可以用<code>defer</code>语句来确保文件描述符得以关闭，以及手动分配的内存得以释放。</p>
<p><code>defer</code>语句将代码的执行延迟到当前的作用域退出之前。该语句由<code>defer</code>关键字和要被延迟执行的语句组成。延迟执行的语句不能包含任何控制转移语句，例如<code>break</code>或是<code>return</code>语句，或是抛出一个错误。延迟执行的操作会按照它们被指定时的顺序的相反顺序执行——也就是说，第一条<code>defer</code>语句中的代码会在第二条<code>defer</code>语句中的代码被执行之后才执行，以此类推。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">processFile</span><span class="params">(filename: String)</span></span> throws &#123;</span><br><span class="line">    <span class="keyword">if</span> exists(filename) &#123;</span><br><span class="line">        <span class="keyword">let</span> file = open(filename)</span><br><span class="line">        defer &#123;</span><br><span class="line">            close(file)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> line = try file.readline() &#123;</span><br><span class="line">            <span class="comment">// 处理文件。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// close(file) 会在这里被调用，即作用域的最后。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码使用一条<code>defer</code>语句来确保<code>open(_:)</code>函数有一个相应的对<code>close(_:)</code>函数的调用。</p>
<blockquote>
<p>注意<br>即使没有涉及到错误处理，你也可以使用<code>defer</code>语句。</p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/19_Type_Casting/" itemprop="url">
                第二章-19类型转换（Type Casting）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:08+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/19_Type_Casting/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/19_Type_Casting/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="类型转换（Type_Casting）">类型转换（Type Casting）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/xiehurricane" target="_blank" rel="external">xiehurricane</a><br>校对：<a href="https://github.com/happyming" target="_blank" rel="external">happyming</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/yangsiy" target="_blank" rel="external">yangsiy</a></p>
<p>2.1<br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a>，2015-11-01</p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#defining_a_class_hierarchy_for_type_casting">定义一个类层次作为例子</a></li>
<li><a href="#checking_type">检查类型</a></li>
<li><a href="#downcasting">向下转型（Downcasting）</a></li>
<li><a href="#type_casting_for_any_and_anyobject"><code>Any</code> 和 <code>AnyObject</code> 的类型转换</a></li>
</ul>
<p><em>类型转换</em> 可以判断实例的类型，也可以将实例看做是其父类或者子类的实例。</p>
<p>类型转换在 Swift 中使用 <code>is</code> 和 <code>as</code> 操作符实现。这两个操作符提供了一种简单达意的方式去检查值的类型或者转换它的类型。</p>
<p>你也可以用它来检查一个类型是否实现了某个协议，就像在<a href="./22_Protocols.html#checking_for_protocol_conformance">检验协议的一致性</a>部分讲述的一样。</p>
<p><a name="defining_a_class_hierarchy_for_type_casting"></a></p>
<h2 id="定义一个类层次作为例子">定义一个类层次作为例子</h2><p>你可以将类型转换用在类和子类的层次结构上，检查特定类实例的类型并且转换这个类实例的类型成为这个层次结构中的其他类型。下面的三个代码段定义了一个类层次和一个包含了这些类实例的数组，作为类型转换的例子。</p>
<p>第一个代码片段定义了一个新的基类 <code>MediaItem</code>。这个类为任何出现在数字媒体库的媒体项提供基础功能。特别的，它声明了一个 <code>String</code> 类型的 <code>name</code> 属性，和一个 <code>init(name:)</code> 初始化器。（假定所有的媒体项都有个名称。）</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MediaItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一个代码段定义了 <code>MediaItem</code> 的两个子类。第一个子类 <code>Movie</code> 封装了与电影相关的额外信息，在父类（或者说基类）的基础上增加了一个 <code>director</code>（导演）属性，和相应的初始化器。第二个子类 <code>Song</code>，在父类的基础上增加了一个 <code>artist</code>（艺术家）属性，和相应的初始化器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Movie</span>: <span class="title">MediaItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> director: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, director: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.director = director</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Song</span>: <span class="title">MediaItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> artist: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, artist: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.artist = artist</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一个代码段创建了一个数组常量 <code>library</code>，包含两个 <code>Movie</code> 实例和三个 <code>Song</code> 实例。<code>library</code> 的类型是在它被初始化时根据它数组中所包含的内容推断来的。Swift 的类型检测器能够推断出 <code>Movie</code> 和 <code>Song</code> 有共同的父类 <code>MediaItem</code>，所以它推断出 <code>[MediaItem]</code> 类作为 <code>library</code> 的类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> library = [</span><br><span class="line">    <span class="type">Movie</span>(name: <span class="string">"Casablanca"</span>, director: <span class="string">"Michael Curtiz"</span>),</span><br><span class="line">    <span class="type">Song</span>(name: <span class="string">"Blue Suede Shoes"</span>, artist: <span class="string">"Elvis Presley"</span>),</span><br><span class="line">    <span class="type">Movie</span>(name: <span class="string">"Citizen Kane"</span>, director: <span class="string">"Orson Welles"</span>),</span><br><span class="line">    <span class="type">Song</span>(name: <span class="string">"The One And Only"</span>, artist: <span class="string">"Chesney Hawkes"</span>),</span><br><span class="line">    <span class="type">Song</span>(name: <span class="string">"Never Gonna Give You Up"</span>, artist: <span class="string">"Rick Astley"</span>)</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 数组 library 的类型被推断为 [MediaItem]</span></span><br></pre></td></tr></table></figure>
<p>在幕后 <code>library</code> 里存储的媒体项依然是 <code>Movie</code> 和 <code>Song</code> 类型的。但是，若你迭代它，依次取出的实例会是 <code>MediaItem</code> 类型的，而不是 <code>Movie</code> 和 <code>Song</code> 类型。为了让它们作为原本的类型工作，你需要检查它们的类型或者向下转换它们到其它类型，就像下面描述的一样。</p>
<p><a name="checking_type"></a></p>
<h2 id="检查类型（Checking_Type）">检查类型（Checking Type）</h2><p>用类型检查操作符（<code>is</code>）来检查一个实例是否属于特定子类型。若实例属于那个子类型，类型检查操作符返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p>下面的例子定义了两个变量，<code>movieCount</code> 和 <code>songCount</code>，用来计算数组 <code>library</code> 中 <code>Movie</code> 和 <code>Song</code> 类型的实例数量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> movieCount = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> songCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> library &#123;</span><br><span class="line">    <span class="keyword">if</span> item <span class="keyword">is</span> <span class="type">Movie</span> &#123;</span><br><span class="line">        ++movieCount</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> item <span class="keyword">is</span> <span class="type">Song</span> &#123;</span><br><span class="line">        ++songCount</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Media library contains <span class="subst">\(movieCount)</span> movies and <span class="subst">\(songCount)</span> songs"</span>)</span><br><span class="line"><span class="comment">// 打印 “Media library contains 2 movies and 3 songs”</span></span><br></pre></td></tr></table></figure>
<p>示例迭代了数组 <code>library</code> 中的所有项。每一次，<code>for-in</code> 循环设置<br><code>item</code> 为数组中的下一个 <code>MediaItem</code>。</p>
<p>若当前 <code>MediaItem</code> 是一个 <code>Movie</code> 类型的实例，<code>item is Movie</code> 返回<br><code>true</code>，否则返回 <code>false</code>。同样的，<code>item is Song</code> 检查 <code>item</code> 是否为 <code>Song</code> 类型的实例。在循环结束后，<code>movieCount</code> 和 <code>songCount</code> 的值就是被找到的属于各自类型的实例的数量。</p>
<p><a name="downcasting"></a></p>
<h2 id="向下转型（Downcasting）">向下转型（Downcasting）</h2><p>某类型的一个常量或变量可能在幕后实际上属于一个子类。当确定是这种情况时，你可以尝试向下转到它的子类型，用类型转换操作符（<code>as?</code> 或 <code>as!</code>）。</p>
<p>因为向下转型可能会失败，类型转型操作符带有两种不同形式。条件形式（conditional form）<code>as?</code> 返回一个你试图向下转成的类型的可选值（optional value）。强制形式 <code>as!</code> 把试图向下转型和强制解包（force-unwraps）转换结果结合为一个操作。</p>
<p>当你不确定向下转型可以成功时，用类型转换的条件形式（<code>as?</code>）。条件形式的类型转换总是返回一个可选值（optional value），并且若下转是不可能的，可选值将是 <code>nil</code>。这使你能够检查向下转型是否成功。</p>
<p>只有你可以确定向下转型一定会成功时，才使用强制形式（<code>as!</code>）。当你试图向下转型为一个不正确的类型时，强制形式的类型转换会触发一个运行时错误。</p>
<p>下面的例子，迭代了 <code>library</code> 里的每一个 <code>MediaItem</code>，并打印出适当的描述。要这样做，<code>item</code> 需要真正作为 <code>Movie</code> 或 <code>Song</code> 的类型来使用，而不仅仅是作为 <code>MediaItem</code>。为了能够在描述中使用 <code>Movie</code> 或 <code>Song</code> 的 <code>director</code> 或 <code>artist</code> 属性，这是必要的。</p>
<p>在这个示例中，数组中的每一个 <code>item</code> 可能是 <code>Movie</code> 或 <code>Song</code>。事前你不知道每个 <code>item</code> 的真实类型，所以这里使用条件形式的类型转换（<code>as?</code>）去检查循环里的每次下转：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> library &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> movie = item <span class="keyword">as</span>? <span class="type">Movie</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Movie: '<span class="subst">\(movie.name)</span>', dir. <span class="subst">\(movie.director)</span>"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> song = item <span class="keyword">as</span>? <span class="type">Song</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Song: '<span class="subst">\(song.name)</span>', by <span class="subst">\(song.artist)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Movie: 'Casablanca', dir. Michael Curtiz</span></span><br><span class="line"><span class="comment">// Song: 'Blue Suede Shoes', by Elvis Presley</span></span><br><span class="line"><span class="comment">// Movie: 'Citizen Kane', dir. Orson Welles</span></span><br><span class="line"><span class="comment">// Song: 'The One And Only', by Chesney Hawkes</span></span><br><span class="line"><span class="comment">// Song: 'Never Gonna Give You Up', by Rick Astley</span></span><br></pre></td></tr></table></figure>
<p>示例首先试图将 <code>item</code> 下转为 <code>Movie</code>。因为 <code>item</code> 是一个 <code>MediaItem</code><br>类型的实例，它可能是一个 <code>Movie</code>；同样，它也可能是一个 <code>Song</code>，或者仅仅是基类<br><code>MediaItem</code>。因为不确定，<code>as?</code> 形式在试图下转时将返回一个可选值。<code>item as? Movie</code> 的返回值是 <code>Movie?</code> 或者说“可选 <code>Movie</code>”。</p>
<p>当向下转型为 <code>Movie</code> 应用在两个 <code>Song</code><br>实例时将会失败。为了处理这种情况，上面的例子使用了可选绑定（optional binding）来检查可选 <code>Movie</code> 真的包含一个值（这个是为了判断下转是否成功。）可选绑定是这样写的“<code>if let movie = item as? Movie</code>”，可以这样解读：</p>
<p>“尝试将 <code>item</code> 转为 <code>Movie</code> 类型。若成功，设置一个新的临时常量 <code>movie</code> 来存储返回的可选 <code>Movie</code> 中的值”</p>
<p>若向下转型成功，然后 <code>movie</code> 的属性将用于打印一个 <code>Movie</code> 实例的描述，包括它的导演的名字 <code>director</code>。相似的原理被用来检测 <code>Song</code> 实例，当 <code>Song</code> 被找到时则打印它的描述（包含 <code>artist</code> 的名字）。</p>
<blockquote>
<p>注意<br>转换没有真的改变实例或它的值。根本的实例保持不变；只是简单地把它作为它被转换成的类型来使用。</p>
</blockquote>
<p><a name="type_casting_for_any_and_anyobject"></a></p>
<h2 id="Any_和_AnyObject_的类型转换"><code>Any</code> 和 <code>AnyObject</code> 的类型转换</h2><p>Swift 为不确定类型提供了两种特殊的类型别名：</p>
<ul>
<li><code>AnyObject</code> 可以表示任何类类型的实例。</li>
<li><code>Any</code> 可以表示任何类型，包括函数类型。</li>
</ul>
<blockquote>
<p>注意<br>只有当你确实需要它们的行为和功能时才使用 <code>Any</code> 和 <code>AnyObject</code>。在你的代码里使用你期望的明确类型总是更好的。</p>
</blockquote>
<p><a name="anyobject"></a></p>
<h3 id="AnyObject_类型"><code>AnyObject</code> 类型</h3><p>当在工作中使用 Cocoa APIs 时，我们经常会接收到一个 <code>[AnyObject]</code> 类型的数组，或者说“一个任意类型对象的数组”。这是因为 Objective-C 没有明确的类型化数组。但是，你常常可以从 API 提供的信息来确定数组中对象的类型。</p>
<blockquote>
<p>译者注<br>这段文档似乎没有及时更新，从 Xcode 7 和 Swift 2.0 开始，由于 Objective-C 引入了轻量泛型，集合类型已经可以类型化了，在 Swift 中使用 Cocoa API 也越来越少遇到 <code>AnyObject</code> 类型了。详情请参阅 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID173" target="_blank" rel="external">Lightweight Generics</a> 和 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID69" target="_blank" rel="external">Collection Classes</a>。</p>
</blockquote>
<p>在这些情况下，你可以使用强制形式的类型转换（<code>as</code>）来下转数组中的每一项到比 <code>AnyObject</code> 更明确的类型，不需要可选解包（optional unwrapping）。</p>
<p>下面的示例定义了一个 <code>[AnyObject]</code> 类型的数组并填入三个 <code>Movie</code> 类型的实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someObjects: [<span class="type">AnyObject</span>] = [</span><br><span class="line">    <span class="type">Movie</span>(name: <span class="string">"2001: A Space Odyssey"</span>, director: <span class="string">"Stanley Kubrick"</span>),</span><br><span class="line">    <span class="type">Movie</span>(name: <span class="string">"Moon"</span>, director: <span class="string">"Duncan Jones"</span>),</span><br><span class="line">    <span class="type">Movie</span>(name: <span class="string">"Alien"</span>, director: <span class="string">"Ridley Scott"</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>因为知道这个数组只包含 <code>Movie</code> 实例，你可以直接用（<code>as!</code>）下转并解包到非可选的 <code>Movie</code> 类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> object <span class="keyword">in</span> someObjects &#123;</span><br><span class="line">    <span class="keyword">let</span> movie = object <span class="keyword">as</span>! <span class="type">Movie</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Movie: '<span class="subst">\(movie.name)</span>', dir. <span class="subst">\(movie.director)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Movie: '2001: A Space Odyssey', dir. Stanley Kubrick</span></span><br><span class="line"><span class="comment">// Movie: 'Moon', dir. Duncan Jones</span></span><br><span class="line"><span class="comment">// Movie: 'Alien', dir. Ridley Scott</span></span><br></pre></td></tr></table></figure>
<p>为了变为一个更简短的形式，下转 <code>someObjects</code> 数组为 <code>[Movie]</code> 类型而不是下转数组中的每一项：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> movie <span class="keyword">in</span> someObjects <span class="keyword">as</span>! [<span class="type">Movie</span>] &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Movie: '<span class="subst">\(movie.name)</span>', dir. <span class="subst">\(movie.director)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Movie: '2001: A Space Odyssey', dir. Stanley Kubrick</span></span><br><span class="line"><span class="comment">// Movie: 'Moon', dir. Duncan Jones</span></span><br><span class="line"><span class="comment">// Movie: 'Alien', dir. Ridley Scott</span></span><br></pre></td></tr></table></figure>
<p><a name="any"></a></p>
<h3 id="Any_类型"><code>Any</code> 类型</h3><p>这里有个示例，使用 <code>Any</code> 类型来和混合的不同类型一起工作，包括函数类型和非类类型。它创建了一个可以存储 <code>Any</code> 类型的数组 <code>things</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> things = [<span class="type">Any</span>]()</span><br><span class="line"></span><br><span class="line">things.append(<span class="number">0</span>)</span><br><span class="line">things.append(<span class="number">0.0</span>)</span><br><span class="line">things.append(<span class="number">42</span>)</span><br><span class="line">things.append(<span class="number">3.14159</span>)</span><br><span class="line">things.append(<span class="string">"hello"</span>)</span><br><span class="line">things.append((<span class="number">3.0</span>, <span class="number">5.0</span>))</span><br><span class="line">things.append(<span class="type">Movie</span>(name: <span class="string">"Ghostbusters"</span>, director: <span class="string">"Ivan Reitman"</span>))</span><br><span class="line">things.append(&#123; (name: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span> <span class="string">"Hello, <span class="subst">\(name)</span>"</span> &#125;)</span><br></pre></td></tr></table></figure>
<p><code>things</code> 数组包含两个 <code>Int</code> 值，两个 <code>Double</code> 值，一个 <code>String</code> 值，一个元组 <code>(Double, Double)</code>，一个<code>Movie</code>实例“Ghostbusters”，以及一个接受 <code>String</code> 值并返回另一个 <code>String</code> 值的闭包表达式。</p>
<p>你可以在 <code>switch</code> 表达式的 <code>case</code> 中使用 <code>is</code> 和 <code>as</code> 操作符来找出只知道是 <code>Any</code> 或 <code>AnyObject</code> 类型的常量或变量的具体类型。下面的示例迭代 <code>things</code> 数组中的每一项，并用 <code>switch</code> 语句查找每一项的类型。有几个 <code>switch</code> 语句的 <code>case</code> 绑定它们匹配到的值到一个指定类型的常量，从而可以打印这些值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> thing <span class="keyword">in</span> things &#123;</span><br><span class="line">    <span class="keyword">switch</span> thing &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span> <span class="keyword">as</span> <span class="type">Int</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"zero as an Int"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span> <span class="keyword">as</span> <span class="type">Double</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"zero as a Double"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> someInt <span class="keyword">as</span> <span class="type">Int</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"an integer value of <span class="subst">\(someInt)</span>"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> someDouble <span class="keyword">as</span> <span class="type">Double</span> <span class="keyword">where</span> someDouble &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"a positive double value of <span class="subst">\(someDouble)</span>"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">is</span> <span class="type">Double</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"some other double value that I don't want to print"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> someString <span class="keyword">as</span> <span class="type">String</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"a string value of \"<span class="subst">\(someString)</span>\""</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">as</span> (<span class="type">Double</span>, <span class="type">Double</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"an (x, y) point at <span class="subst">\(x)</span>, <span class="subst">\(y)</span>"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> movie <span class="keyword">as</span> <span class="type">Movie</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"a movie called '<span class="subst">\(movie.name)</span>', dir. <span class="subst">\(movie.director)</span>"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> stringConverter <span class="keyword">as</span> <span class="type">String</span> -&gt; <span class="type">String</span>:</span><br><span class="line">        <span class="built_in">print</span>(stringConverter(<span class="string">"Michael"</span>))</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"something else"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// zero as an Int</span></span><br><span class="line"><span class="comment">// zero as a Double</span></span><br><span class="line"><span class="comment">// an integer value of 42</span></span><br><span class="line"><span class="comment">// a positive double value of 3.14159</span></span><br><span class="line"><span class="comment">// a string value of "hello"</span></span><br><span class="line"><span class="comment">// an (x, y) point at 3.0, 5.0</span></span><br><span class="line"><span class="comment">// a movie called 'Ghostbusters', dir. Ivan Reitman</span></span><br><span class="line"><span class="comment">// Hello, Michael</span></span><br></pre></td></tr></table></figure>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/20_Nested_Types/" itemprop="url">
                第二章-20嵌套类型（Nested Types）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:07+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/20_Nested_Types/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/20_Nested_Types/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="嵌套类型（Nested_Types）">嵌套类型（Nested Types）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/Lin-H" target="_blank" rel="external">Lin-H</a><br>校对：<a href="https://github.com/shinyzhu" target="_blank" rel="external">shinyzhu</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/SergioChan" target="_blank" rel="external">SergioChan</a></p>
<p>2.1<br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a>，2015-11-01</p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#nested_types_in_action">嵌套类型实践</a></li>
<li><a href="#referring_to_nested_types">引用嵌套类型</a></li>
</ul>
<p>枚举常被用于为特定类或结构体实现某些功能。类似的，也能够在某个复杂的类型中，方便地定义工具类或结构体来使用。为了实现这种功能，Swift 允许你定义嵌套类型，可以在支持的类型中定义嵌套的枚举、类和结构体。</p>
<p>要在一个类型中嵌套另一个类型，将嵌套类型的定义写在其外部类型的<code>{}</code>内，而且可以根据需要定义多级嵌套。</p>
<p><a name="nested_types_in_action"></a></p>
<h2 id="嵌套类型实践">嵌套类型实践</h2><p>下面这个例子定义了一个结构体<code>BlackjackCard</code>（二十一点），用来模拟<code>BlackjackCard</code>中的扑克牌点数。<code>BlackjackCard</code>结构体包含两个嵌套定义的枚举类型<code>Suit</code>和<code>Rank</code>。</p>
<p>在<code>BlackjackCard</code>中，<code>Ace</code>牌可以表示<code>1</code>或者<code>11</code>，<code>Ace</code>牌的这一特征通过一个嵌套在<code>Rank</code>枚举中的结构体<code>Values</code>来表示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BlackjackCard</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 嵌套的 Suit 枚举</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Suit</span>: <span class="title">Character</span> </span>&#123;</span><br><span class="line">       <span class="keyword">case</span> <span class="type">Spades</span> = <span class="string">"♠"</span>, <span class="type">Hearts</span> = <span class="string">"♡"</span>, <span class="type">Diamonds</span> = <span class="string">"♢"</span>, <span class="type">Clubs</span> = <span class="string">"♣"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 嵌套的 Rank 枚举</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Rank</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">       <span class="keyword">case</span> <span class="type">Two</span> = <span class="number">2</span>, <span class="type">Three</span>, <span class="type">Four</span>, <span class="type">Five</span>, <span class="type">Six</span>, <span class="type">Seven</span>, <span class="type">Eight</span>, <span class="type">Nine</span>, <span class="type">Ten</span></span><br><span class="line">       <span class="keyword">case</span> <span class="type">Jack</span>, <span class="type">Queen</span>, <span class="type">King</span>, <span class="type">Ace</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">Values</span> </span>&#123;</span><br><span class="line">           <span class="keyword">let</span> first: <span class="type">Int</span>, second: <span class="type">Int</span>?</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">var</span> values: <span class="type">Values</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Ace</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Values</span>(first: <span class="number">1</span>, second: <span class="number">11</span>)</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Jack</span>, .<span class="type">Queen</span>, .<span class="type">King</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Values</span>(first: <span class="number">10</span>, second: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Values</span>(first: <span class="keyword">self</span>.rawValue, second: <span class="literal">nil</span>)</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BlackjackCard 的属性和方法</span></span><br><span class="line">    <span class="keyword">let</span> rank: <span class="type">Rank</span>, suit: <span class="type">Suit</span></span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">    	<span class="keyword">var</span> output = <span class="string">"suit is <span class="subst">\(suit.rawValue)</span>,"</span></span><br><span class="line">        output += <span class="string">" value is <span class="subst">\(rank.values.first)</span>"</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> second = rank.values.second &#123;</span><br><span class="line">            output += <span class="string">" or <span class="subst">\(second)</span>"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Suit</code>枚举用来描述扑克牌的四种花色，并用一个<code>Character</code>类型的原始值表示花色符号。</p>
<p><code>Rank</code>枚举用来描述扑克牌从<code>Ace</code>~<code>10</code>，以及<code>J</code>、<code>Q</code>、<code>K</code>，这<code>13</code>种牌，并用一个<code>Int</code>类型的原始值表示牌的面值。（这个<code>Int</code>类型的原始值未用于<code>Ace</code>、<code>J</code>、<code>Q</code>、<code>K</code>这<code>4</code>种牌。）</p>
<p>如上所述，<code>Rank</code>枚举在内部定义了一个嵌套结构体<code>Values</code>。结构体<code>Values</code>中定义了两个属性，用于反映只有<code>Ace</code>有两个数值，其余牌都只有一个数值：</p>
<ul>
<li><code>first</code>的类型为<code>Int</code></li>
<li><code>second</code>的类型为<code>Int?</code>，或者说“optional <code>Int</code>”</li>
</ul>
<p><code>Rank</code>还定义了一个计算型属性<code>values</code>，它将会返回一个<code>Values</code>结构体的实例。这个计算型属性会根据牌的面值，用适当的数值去初始化<code>Values</code>实例。对于<code>J</code>、<code>Q</code>、<code>K</code>、<code>Ace</code>这四种牌，会使用特殊数值。对于数字面值的牌，使用枚举实例的原始值。</p>
<p><code>BlackjackCard</code>结构体拥有两个属性——<code>rank</code>与<code>suit</code>。它也同样定义了一个计算型属性<code>description</code>，<code>description</code>属性用<code>rank</code>和<code>suit</code>中的内容来构建对扑克牌名字和数值的描述。该属性使用可选绑定来检查可选类型<code>second</code>是否有值，若有值，则在原有的描述中增加对<code>second</code>的描述。</p>
<p>因为<code>BlackjackCard</code>是一个没有自定义构造器的结构体，在<a href="./14_Initialization.html#memberwise_initializers_for_structure_types">结构体的逐一成员构造器</a>中可知，结构体有默认的成员构造器，所以你可以用默认的构造器去初始化新常量<code>theAceOfSpades</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> theAceOfSpades = <span class="type">BlackjackCard</span>(rank: .<span class="type">Ace</span>, suit: .<span class="type">Spades</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"theAceOfSpades: <span class="subst">\(theAceOfSpades.description)</span>"</span>)</span><br><span class="line"><span class="comment">// 打印 “theAceOfSpades: suit is ♠, value is 1 or 11”</span></span><br></pre></td></tr></table></figure>
<p>尽管<code>Rank</code>和<code>Suit</code>嵌套在<code>BlackjackCard</code>中，但它们的类型仍可从上下文中推断出来，所以在初始化实例时能够单独通过成员名称（<code>.Ace</code>和<code>.Spades</code>）引用枚举实例。在上面的例子中，<code>description</code>属性正确地反映了黑桃A牌具有<code>1</code>和<code>11</code>两个值。</p>
<p><a name="referring_to_nested_types"></a></p>
<h2 id="引用嵌套类型">引用嵌套类型</h2><p>在外部引用嵌套类型时，在嵌套类型的类型名前加上其外部类型的类型名作为前缀：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> heartsSymbol = <span class="type">BlackjackCard</span>.<span class="type">Suit</span>.<span class="type">Hearts</span>.rawValue</span><br><span class="line"><span class="comment">// 红心符号为 “♡”</span></span><br></pre></td></tr></table></figure>
<p>对于上面这个例子，这样可以使<code>Suit</code>、<code>Rank</code>和<code>Values</code>的名字尽可能的短，因为它们的名字可以由定义它们的上下文来限定。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/21_Extensions/" itemprop="url">
                第二章-21扩展（Extensions）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:06+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/21_Extensions/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/21_Extensions/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="扩展（Extensions）">扩展（Extensions）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/lyuka" target="_blank" rel="external">lyuka</a><br>校对：<a href="https://github.com/Hawstein" target="_blank" rel="external">Hawstein</a></p>
<p>2.0<br>翻译+校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a></p>
<p>2.1<br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#extension_syntax">扩展语法</a></li>
<li><a href="#computed_properties">计算型属性</a></li>
<li><a href="#initializers">构造器</a></li>
<li><a href="#methods">方法</a></li>
<li><a href="#subscripts">下标</a></li>
<li><a href="#nested_types">嵌套类型</a></li>
</ul>
<p><em>扩展</em> 就是为一个已有的类、结构体、枚举类型或者协议类型添加新功能。这包括在没有权限获取原始源代码的情况下扩展类型的能力（即 <em>逆向建模</em> ）。扩展和 Objective-C 中的分类类似。（与 Objective-C 不同的是，Swift 的扩展没有名字。）</p>
<p>Swift 中的扩展可以：</p>
<ul>
<li>添加计算型属性和计算型类型属性</li>
<li>定义实例方法和类型方法</li>
<li>提供新的构造器</li>
<li>定义下标</li>
<li>定义和使用新的嵌套类型</li>
<li>使一个已有类型符合某个协议</li>
</ul>
<p>在 Swift 中，你甚至可以对协议进行扩展，提供协议要求的实现，或者添加额外的功能，从而可以让符合协议的类型拥有这些功能。你可以从<a href="./22_Protocols.html#protocol_extensions">协议扩展</a>获取更多的细节。</p>
<blockquote>
<p>注意<br>扩展可以为一个类型添加新的功能，但是不能重写已有的功能。</p>
</blockquote>
<p><a name="extension_syntax"></a></p>
<h2 id="扩展语法（Extension_Syntax）">扩展语法（Extension Syntax）</h2><p>使用关键字 <code>extension</code> 来声明扩展：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SomeType</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为 SomeType 添加的新功能写到这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过扩展来扩展一个已有类型，使其采纳一个或多个协议。在这种情况下，无论是类还是结构体，协议名字的书写方式完全一样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SomeType</span>: <span class="title">SomeProtocol</span>, <span class="title">AnotherProctocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 协议实现写到这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这种方式添加协议一致性的详细描述请参阅<a href="./22_Protocols.html#adding_protocol_conformance_with_an_extension">利用扩展添加协议一致性</a>。</p>
<blockquote>
<p>注意<br>如果你通过扩展为一个已有类型添加新功能，那么新功能对该类型的所有已有实例都是可用的，即使它们是在这个扩展定义之前创建的。</p>
</blockquote>
<p><a name="computed_properties"></a></p>
<h2 id="计算型属性（Computed_Properties）">计算型属性（Computed Properties）</h2><p>扩展可以为已有类型添加计算型实例属性和计算型类型属性。下面的例子为 Swift 的内建 <code>Double</code> 类型添加了五个计算型实例属性，从而提供与距离单位协作的基本支持：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Double</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> km: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> * <span class="number">1_000.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> m : <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> cm: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> / <span class="number">100.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> mm: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> / <span class="number">1_000.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> ft: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> / <span class="number">3.28084</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> oneInch = <span class="number">25.4</span>.mm</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"One inch is <span class="subst">\(oneInch)</span> meters"</span>)</span><br><span class="line"><span class="comment">// 打印 “One inch is 0.0254 meters”</span></span><br><span class="line"><span class="keyword">let</span> threeFeet = <span class="number">3</span>.ft</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Three feet is <span class="subst">\(threeFeet)</span> meters"</span>)</span><br><span class="line"><span class="comment">// 打印 “Three feet is 0.914399970739201 meters”</span></span><br></pre></td></tr></table></figure>
<p>这些计算型属性表达的含义是把一个 <code>Double</code> 值看作是某单位下的长度值。即使它们被实现为计算型属性，但这些属性的名字仍可紧接一个浮点型字面值，从而通过点语法来使用，并以此实现距离转换。</p>
<p>在上述例子中，<code>Double</code> 值 <code>1.0</code> 用来表示“1米”。这就是为什么计算型属性 <code>m</code> 返回 <code>self</code>，即表达式 <code>1.m</code> 被认为是计算 <code>Double</code> 值 <code>1.0</code>。</p>
<p>其它单位则需要一些单位换算。一千米等于 1,000 米，所以计算型属性 <code>km</code> 要把值乘以 <code>1_000.00</code> 来实现千米到米的单位换算。类似地，一米有 3.28024 英尺，所以计算型属性 <code>ft</code> 要把对应的 <code>Double</code> 值除以 <code>3.28024</code> 来实现英尺到米的单位换算。</p>
<p>这些属性是只读的计算型属性，为了更简洁，省略了 <code>get</code> 关键字。它们的返回值是 <code>Double</code>，而且可以用于所有接受 <code>Double</code> 值的数学计算中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aMarathon = <span class="number">42</span>.km + <span class="number">195</span>.m</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"A marathon is <span class="subst">\(aMarathon)</span> meters long"</span>)</span><br><span class="line"><span class="comment">// 打印 “A marathon is 42195.0 meters long”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>扩展可以添加新的计算型属性，但是不可以添加存储型属性，也不可以为已有属性添加属性观察器。</p>
</blockquote>
<p><a name="initializers"></a></p>
<h2 id="构造器（Initializers）">构造器（Initializers）</h2><p>扩展可以为已有类型添加新的构造器。这可以让你扩展其它类型，将你自己的定制类型作为其构造器参数，或者提供该类型的原始实现中未提供的额外初始化选项。  </p>
<p>扩展能为类添加新的便利构造器，但是它们不能为类添加新的指定构造器或析构器。指定构造器和析构器必须总是由原始的类实现来提供。</p>
<blockquote>
<p>注意<br>如果你使用扩展为一个值类型添加构造器，且该值类型的原始实现中未定义任何定制的构造器时，你可以在扩展中的构造器里调用逐一成员构造器。如果该值类型为所有存储型属性提供了默认值，你还可以在扩展中的构造器里调用默认构造器。<br>正如在<a href="./14_Initialization.html#initializer_delegation_for_value_types">值类型的构造器代理</a>中描述的，如果你把定制的构造器写在值类型的原始实现中，上述规则将不再适用。</p>
</blockquote>
<p>下面的例子定义了一个用于描述几何矩形的结构体 <code>Rect</code>。这个例子同时定义了两个辅助结构体 <code>Size</code> 和 <code>Point</code>，它们都把 <code>0.0</code> 作为所有属性的默认值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span>, height = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> origin = <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size = <span class="type">Size</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为结构体 <code>Rect</code> 未提供定制的构造器，因此它会获得一个逐一成员构造器。又因为它为所有存储型属性提供了默认值，它又会获得一个默认构造器。详情请参阅<a href="./14_Initialization.html#default_initializers">默认构造器</a>。这些构造器可以用于构造新的 <code>Rect</code> 实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> defaultRect = <span class="type">Rect</span>()</span><br><span class="line"><span class="keyword">let</span> memberwiseRect = <span class="type">Rect</span>(origin: <span class="type">Point</span>(x: <span class="number">2.0</span>, y: <span class="number">2.0</span>),</span><br><span class="line">    size: <span class="type">Size</span>(width: <span class="number">5.0</span>, height: <span class="number">5.0</span>))</span><br></pre></td></tr></table></figure>
<p>你可以提供一个额外的接受指定中心点和大小的构造器来扩展 <code>Rect</code> 结构体：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Rect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>(center: <span class="type">Point</span>, size: <span class="type">Size</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> originX = center.x - (size.width / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">let</span> originY = center.y - (size.height / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(origin: <span class="type">Point</span>(x: originX, y: originY), size: size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个新的构造器首先根据提供的 <code>center</code> 和 <code>size</code> 的值计算一个合适的原点。然后调用该结构体的逐一成员构造器 <code>init(origin:size:)</code>，该构造器将新的原点和大小的值保存到了相应的属性中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> centerRect = <span class="type">Rect</span>(center: <span class="type">Point</span>(x: <span class="number">4.0</span>, y: <span class="number">4.0</span>),</span><br><span class="line">    size: <span class="type">Size</span>(width: <span class="number">3.0</span>, height: <span class="number">3.0</span>))</span><br><span class="line"><span class="comment">// centerRect 的原点是 (2.5, 2.5)，大小是 (3.0, 3.0)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>如果你使用扩展提供了一个新的构造器，你依旧有责任确保构造过程能够让实例完全初始化。</p>
</blockquote>
<p><a name="methods"></a></p>
<h2 id="方法（Methods）">方法（Methods）</h2><p>扩展可以为已有类型添加新的实例方法和类型方法。下面的例子为 <code>Int</code> 类型添加了一个名为 <code>repetitions</code> 的实例方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">repetitions</span><span class="params">(task: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="keyword">self</span> &#123;</span><br><span class="line">            task()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 <code>repetitions(:_)</code> 方法接受一个 <code>() -&gt; Void</code> 类型的单参数，表示没有参数且没有返回值的函数。</p>
<p>定义该扩展之后，你就可以对任意整数调用 <code>repetitions(_:)</code> 方法，将闭包中的任务执行整数对应的次数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>.repetitions(&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello!"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// Hello!</span></span><br><span class="line"><span class="comment">// Hello!</span></span><br><span class="line"><span class="comment">// Hello!</span></span><br></pre></td></tr></table></figure>
<p>可以使用尾随闭包让调用更加简洁：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>.repetitions &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Goodbye!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Goodbye!</span></span><br><span class="line"><span class="comment">// Goodbye!</span></span><br><span class="line"><span class="comment">// Goodbye!</span></span><br></pre></td></tr></table></figure>
<p><a name="mutating_instance_methods"></a></p>
<h3 id="可变实例方法（Mutating_Instance_Methods）">可变实例方法（Mutating Instance Methods）</h3><p>通过扩展添加的实例方法也可以修改该实例本身。结构体和枚举类型中修改 <code>self</code> 或其属性的方法必须将该实例方法标注为 <code>mutating</code>，正如来自原始实现的可变方法一样。</p>
<p>下面的例子为 Swift 的 <code>Int</code> 类型添加了一个名为 <code>square</code> 的可变方法，用于计算原始值的平方值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">square</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span> = <span class="keyword">self</span> * <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> someInt = <span class="number">3</span></span><br><span class="line">someInt.square()</span><br><span class="line"><span class="comment">// someInt 的值现在是 9</span></span><br></pre></td></tr></table></figure>
<p><a name="subscripts"></a></p>
<h2 id="下标（Subscripts）">下标（Subscripts）</h2><p>扩展可以为已有类型添加新下标。这个例子为 Swift 内建类型 <code>Int</code> 添加了一个整型下标。该下标 <code>[n]</code> 返回十进制数字从右向左数的第 <code>n</code> 个数字：</p>
<ul>
<li><code>123456789[0]</code> 返回 <code>9</code></li>
<li><code>123456789[1]</code> 返回 <code>8</code></li>
</ul>
<p>……以此类推。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="keyword">var</span> digitIndex: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> decimalBase = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> digitIndex &gt; <span class="number">0</span> &#123;</span><br><span class="line">            decimalBase *= <span class="number">10</span></span><br><span class="line">            --digitIndex</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">self</span> / decimalBase) % <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">746381295</span>[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 返回 5</span></span><br><span class="line"><span class="number">746381295</span>[<span class="number">1</span>]</span><br><span class="line"><span class="comment">// 返回 9</span></span><br><span class="line"><span class="number">746381295</span>[<span class="number">2</span>]</span><br><span class="line"><span class="comment">// 返回 2</span></span><br><span class="line"><span class="number">746381295</span>[<span class="number">8</span>]</span><br><span class="line"><span class="comment">// 返回 7</span></span><br></pre></td></tr></table></figure>
<p>如果该 <code>Int</code> 值没有足够的位数，即下标越界，那么上述下标实现会返回 <code>0</code>，犹如在数字左边自动补 <code>0</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">746381295</span>[<span class="number">9</span>]</span><br><span class="line"><span class="comment">// 返回 0，即等同于：</span></span><br><span class="line"><span class="number">0746381295</span>[<span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<p><a name="nested_types"></a></p>
<h2 id="嵌套类型（Nested_Types）">嵌套类型（Nested Types）</h2><p>扩展可以为已有的类、结构体和枚举添加新的嵌套类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Kind</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Negative</span>, <span class="type">Zero</span>, <span class="type">Positive</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> kind: <span class="type">Kind</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> .<span class="type">Zero</span></span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> x <span class="keyword">where</span> x &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> .<span class="type">Positive</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> .<span class="type">Negative</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该例子为 <code>Int</code> 添加了嵌套枚举。这个名为 <code>Kind</code> 的枚举表示特定整数的类型。具体来说，就是表示整数是正数、零或者负数。</p>
<p>这个例子还为 <code>Int</code> 添加了一个计算型实例属性，即 <code>kind</code>，用来根据整数返回适当的 <code>Kind</code> 枚举成员。</p>
<p>现在，这个嵌套枚举可以和任意 <code>Int</code> 值一起使用了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">printIntegerKinds</span><span class="params">(numbers: [Int])</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        <span class="keyword">switch</span> number.kind &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Negative</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"- "</span>, terminator: <span class="string">""</span>)</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Zero</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"0 "</span>, terminator: <span class="string">""</span>)</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Positive</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"+ "</span>, terminator: <span class="string">""</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">""</span>)</span><br><span class="line">&#125;</span><br><span class="line">printIntegerKinds([<span class="number">3</span>, <span class="number">19</span>, -<span class="number">27</span>, <span class="number">0</span>, -<span class="number">6</span>, <span class="number">0</span>, <span class="number">7</span>])</span><br><span class="line"><span class="comment">// 打印 “+ + - 0 - 0 +”</span></span><br></pre></td></tr></table></figure>
<p>函数 <code>printIntegerKinds(_:)</code> 接受一个 <code>Int</code> 数组，然后对该数组进行迭代。在每次迭代过程中，对当前整数的计算型属性 <code>kind</code> 的值进行评估，并打印出适当的描述。</p>
<blockquote>
<p>注意<br>由于已知 <code>number.kind</code> 是 <code>Int.Kind</code> 类型，因此在 <code>switch</code> 语句中，<code>Int.Kind</code> 中的所有成员值都可以使用简写形式，例如使用 <code>. Negative</code> 而不是 <code>Int.Kind.Negative</code>。</p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/22_Protocols/" itemprop="url">
                第二章-22协议（Protocols）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:05+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/22_Protocols/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/22_Protocols/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="协议（Protocols）">协议（Protocols）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/geek5nan" target="_blank" rel="external">geek5nan</a><br>校对：<a href="https://github.com/dabing1022" target="_blank" rel="external">dabing1022</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/futantan" target="_blank" rel="external">futantan</a></p>
<p>2.1<br>翻译：<a href="https://github.com/kevin833752" target="_blank" rel="external">小铁匠Linus</a><br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a>，2015-11-01</p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#protocol_syntax">协议语法（Protocol Syntax）</a></li>
<li><a href="#property_requirements">属性要求（Property Requirements）</a></li>
<li><a href="#method_requirements">方法要求（Method Requirements）</a></li>
<li><a href="#mutating_method_requirements">Mutating 方法要求（Mutating Method Requirements）</a></li>
<li><a href="#initializer_requirements">构造器要求（Initializer Requirements）</a></li>
<li><a href="#protocols_as_types">协议作为类型（Protocols as Types）</a></li>
<li><a href="#delegation">委托（代理）模式（Delegation）</a></li>
<li><a href="#adding_protocol_conformance_with_an_extension">通过扩展添加协议一致性（Adding Protocol Conformance with an Extension）</a></li>
<li><a href="#declaring_protocol_adoption_with_an_extension">通过扩展采纳协议（Declaring Protocol Adoption with an Extension）</a></li>
<li><a href="#collections_of_protocol_types">协议类型的集合（Collections of Protocol Types）</a></li>
<li><a href="#protocol_inheritance">协议的继承（Protocol Inheritance）</a></li>
<li><a href="#class_only_protocol">类类型专属协议（Class-Only Protocol）</a></li>
<li><a href="#protocol_composition">协议合成（Protocol Composition）</a></li>
<li><a href="#checking_for_protocol_conformance">检查协议一致性（Checking for Protocol Conformance）</a></li>
<li><a href="#optional_protocol_requirements">可选的协议要求（Optional Protocol Requirements）</a></li>
<li><a href="#protocol_extensions">协议扩展（Protocol Extensions）</a></li>
</ul>
<p>协议定义了一个蓝图，规定了用来实现某一特定任务或者功能的方法、属性，以及其他需要的东西。类、结构体或枚举都可以采纳协议，并为协议定义的这些要求提供具体实现。某个类型能够满足某个协议的要求，就可以说该类型“符合”这个协议。</p>
<p>除了采纳协议的类型必须实现的要求外，还可以对协议进行扩展，通过扩展来实现一部分要求或者实现一些附加功能，这样采纳协议的类型就能够使用这些功能。</p>
<p><a name="protocol_syntax"></a></p>
<h2 id="协议语法">协议语法</h2><p>协议的定义方式与类、结构体和枚举的定义非常相似：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 这里是协议的定义部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要让自定义类型采纳某个协议，在定义类型时，需要在类型名称后加上协议名称，中间以冒号（<code>:</code>）分隔。采纳多个协议时，各协议之间用逗号（<code>,</code>）分隔：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeStructure</span>: <span class="title">FirstProtocol</span>, <span class="title">AnotherProtocol</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 这里是结构体的定义部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拥有父类的类在采纳协议时，应该将父类名放在协议名之前，以逗号分隔：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>: <span class="title">SomeSuperClass</span>, <span class="title">FirstProtocol</span>, <span class="title">AnotherProtocol</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 这里是类的定义部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="property_requirements"></a></p>
<h2 id="属性要求">属性要求</h2><p>协议可以要求采纳协议的类型提供特定名称和类型的实例属性或类型属性。协议不指定属性是存储型属性还是计算型属性，它只指定属性的名称和类型。此外，协议还指定属性是只读的还是可读可写的。</p>
<p>如果协议要求属性是可读可写的，那么该属性不能是常量属性或只读的计算型属性。如果协议只要求属性是只读的，那么该属性不仅可以是只读的，如果代码需要的话，还可以是可写的。</p>
<p>协议通常用 <code>var</code> 关键字来声明变量属性，在类型声明后加上 <code>{ set get }</code> 来表示属性是可读可写的，只读属性则用 <code>{ get }</code> 来表示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> mustBeSettable: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">	<span class="keyword">var</span> doesNotNeedToBeSettable: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在协议中定义类型属性时，总是使用 <code>static</code> 关键字作为前缀。当类类型采纳协议时，除了 <code>static</code> 关键字，还可以使用 <code>class</code> 关键字来声明类型属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">AnotherProtocol</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">var</span> someTypeProperty: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下所示，这是一个只含有一个实例属性要求的协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">FullyNamed</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> fullName: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>FullyNamed</code> 协议除了要求采纳协议的类型提供 <code>fullName</code> 属性外，并没有其他特别的要求。这个协议表示，任何采纳 <code>FullyNamed</code> 的类型，都必须有一个只读的 <code>String</code> 类型的实例属性 <code>fullName</code>。</p>
<p>下面是一个采纳 <code>FullyNamed</code> 协议的简单结构体：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>: <span class="title">FullyNamed</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> fullName: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> john = <span class="type">Person</span>(fullName: <span class="string">"John Appleseed"</span>)</span><br><span class="line"><span class="comment">// john.fullName 为 "John Appleseed"</span></span><br></pre></td></tr></table></figure>
<p>这个例子中定义了一个叫做 <code>Person</code> 的结构体，用来表示一个具有名字的人。从第一行代码可以看出，它采纳了 <code>FullyNamed</code> 协议。</p>
<p><code>Person</code> 结构体的每一个实例都有一个 <code>String</code> 类型的存储型属性 <code>fullName</code>。这正好满足了 <code>FullyNamed</code> 协议的要求，也就意味着 <code>Person</code> 结构体正确地符合了协议。（如果协议要求未被完全满足，在编译时会报错。）</p>
<p>下面是一个更为复杂的类，它采纳并符合了 <code>FullyNamed</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Starship</span>: <span class="title">FullyNamed</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">prefix</span>: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, <span class="keyword">prefix</span>: <span class="type">String</span>? = <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">prefix</span> = <span class="keyword">prefix</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> fullName: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">prefix</span> != <span class="literal">nil</span> ? <span class="keyword">prefix</span>! + <span class="string">" "</span> : <span class="string">""</span>) + name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ncc1701 = <span class="type">Starship</span>(name: <span class="string">"Enterprise"</span>, <span class="keyword">prefix</span>: <span class="string">"USS"</span>)</span><br><span class="line"><span class="comment">// ncc1701.fullName 是 "USS Enterprise"</span></span><br></pre></td></tr></table></figure>
<p><code>Starship</code> 类把 <code>fullName</code> 属性实现为只读的计算型属性。每一个 <code>Starship</code> 类的实例都有一个名为 <code>name</code> 的非可选属性和一个名为 <code>prefix</code> 的可选属性。 当 <code>prefix</code> 存在时，计算型属性 <code>fullName</code> 会将 <code>prefix</code> 插入到 <code>name</code> 之前，从而为星际飞船构建一个全名。</p>
<p><a name="method_requirements"></a></p>
<h2 id="方法要求">方法要求</h2><p>协议可以要求采纳协议的类型实现某些指定的实例方法或类方法。这些方法作为协议的一部分，像普通方法一样放在协议的定义中，但是不需要大括号和方法体。可以在协议中定义具有可变参数的方法，和普通方法的定义方式相同。但是，不支持为协议中的方法的参数提供默认值。</p>
<p>正如属性要求中所述，在协议中定义类方法的时候，总是使用 <code>static</code> 关键字作为前缀。当类类型采纳协议时，除了 <code>static</code> 关键字，还可以使用 <code>class</code> 关键字作为前缀：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">someTypeMethod</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的例子定义了一个只含有一个实例方法的协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">RandomNumberGenerator</span> </span>&#123;</span><br><span class="line">	<span class="func"><span class="keyword">func</span> <span class="title">random</span><span class="params">()</span></span> -&gt; <span class="type">Double</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RandomNumberGenerator</code> 协议要求采纳协议的类型必须拥有一个名为 <code>random</code>， 返回值类型为 <code>Double</code> 的实例方法。尽管这里并未指明，但是我们假设返回值在 <code>[0.0,1.0)</code> 区间内。</p>
<p><code>RandomNumberGenerator</code> 协议并不关心每一个随机数是怎样生成的，它只要求必须提供一个随机数生成器。</p>
<p>如下所示，下边是一个采纳了 <code>RandomNumberGenerator</code> 协议的类。该类实现了一个叫做 <em>线性同余生成器（linear congruential generator）</em> 的伪随机数算法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearCongruentialGenerator</span>: <span class="title">RandomNumberGenerator</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> lastRandom = <span class="number">42.0</span></span><br><span class="line">	<span class="keyword">let</span> m = <span class="number">139968.0</span></span><br><span class="line">	<span class="keyword">let</span> a = <span class="number">3877.0</span></span><br><span class="line">	<span class="keyword">let</span> <span class="built_in">c</span> = <span class="number">29573.0</span></span><br><span class="line">	<span class="func"><span class="keyword">func</span> <span class="title">random</span><span class="params">()</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">		lastRandom = ((lastRandom * a + <span class="built_in">c</span>) % m)</span><br><span class="line">		<span class="keyword">return</span> lastRandom / m</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generator = <span class="type">LinearCongruentialGenerator</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Here's a random number: <span class="subst">\(generator.random()</span>)"</span>)</span><br><span class="line"><span class="comment">// 打印 “Here's a random number: 0.37464991998171”</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"And another one: <span class="subst">\(generator.random()</span>)"</span>)</span><br><span class="line"><span class="comment">// 打印 “And another one: 0.729023776863283”</span></span><br></pre></td></tr></table></figure>
<p><a name="mutating_method_requirements"></a></p>
<h2 id="Mutating_方法要求">Mutating 方法要求</h2><p>有时需要在方法中改变方法所属的实例。例如，在值类型（即结构体和枚举）的实例方法中，将 <code>mutating</code> 关键字作为方法的前缀，写在 <code>func</code> 关键字之前，表示可以在该方法中修改它所属的实例以及实例的任意属性的值。这一过程在<a href="./11_Methods.html#modifying_value_types_from_within_instance_methods">在实例方法中修改值类型</a>章节中有详细描述。</p>
<p>如果你在协议中定义了一个实例方法，该方法会改变采纳该协议的类型的实例，那么在定义协议时需要在方法前加 <code>mutating</code> 关键字。这使得结构体和枚举能够采纳此协议并满足此方法要求。</p>
<blockquote>
<p>注意<br>实现协议中的 <code>mutating</code> 方法时，若是类类型，则不用写 <code>mutating</code> 关键字。而对于结构体和枚举，则必须写 <code>mutating</code> 关键字。</p>
</blockquote>
<p>如下所示，<code>Togglable</code> 协议只要求实现一个名为 <code>toggle</code> 的实例方法。根据名称的暗示，<code>toggle()</code> 方法将改变实例属性，从而切换采纳该协议类型的实例的状态。</p>
<p><code>toggle()</code> 方法在定义的时候，使用 <code>mutating</code> 关键字标记，这表明当它被调用时，该方法将会改变采纳协议的类型的实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Togglable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">toggle</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当使用枚举或结构体来实现 <code>Togglable</code> 协议时，需要提供一个带有 <code>mutating</code> 前缀的 <code>toggle()</code> 方法。</p>
<p>下面定义了一个名为 <code>OnOffSwitch</code> 的枚举。这个枚举在两种状态之间进行切换，用枚举成员 <code>On</code> 和 <code>Off</code> 表示。枚举的 <code>toggle()</code> 方法被标记为 <code>mutating</code>，以满足 <code>Togglable</code> 协议的要求：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">OnOffSwitch</span>: <span class="title">Togglable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Off</span>, <span class="type">On</span></span><br><span class="line">	<span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">toggle</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="type">Off</span>:</span><br><span class="line">			<span class="keyword">self</span> = <span class="type">On</span></span><br><span class="line">		<span class="keyword">case</span> <span class="type">On</span>:</span><br><span class="line">			<span class="keyword">self</span> = <span class="type">Off</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> lightSwitch = <span class="type">OnOffSwitch</span>.<span class="type">Off</span></span><br><span class="line">lightSwitch.toggle()</span><br><span class="line"><span class="comment">// lightSwitch 现在的值为 .On</span></span><br></pre></td></tr></table></figure>
<p><a name="initializer_requirements"></a></p>
<h2 id="构造器要求">构造器要求</h2><p>协议可以要求采纳协议的类型实现指定的构造器。你可以像编写普通构造器那样，在协议的定义里写下构造器的声明，但不需要写花括号和构造器的实体：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>(someParameter: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造器要求在类中的实现">构造器要求在类中的实现</h3><p>你可以在采纳协议的类中实现构造器，无论是作为指定构造器，还是作为便利构造器。无论哪种情况，你都必须为构造器实现标上 <code>required</code> 修饰符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>: <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line">    required <span class="keyword">init</span>(someParameter: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里是构造器的实现部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>required</code> 修饰符可以确保所有子类也必须提供此构造器实现，从而也能符合协议。</p>
<p>关于 <code>required</code> 构造器的更多内容，请参考<a href="./14_Initialization.html#required_initializers">必要构造器</a>。</p>
<blockquote>
<p>注意<br>如果类已经被标记为 <code>final</code>，那么不需要在协议构造器的实现中使用 <code>required</code> 修饰符，因为 <code>final</code> 类不能有子类。关于 <code>final</code> 修饰符的更多内容，请参见<a href="./13_Inheritance.html#preventing_overrides">防止重写</a>。</p>
</blockquote>
<p>如果一个子类重写了父类的指定构造器，并且该构造器满足了某个协议的要求，那么该构造器的实现需要同时标注 <code>required</code> 和 <code>override</code> 修饰符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeSuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 这里是构造器的实现部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeSubClass</span>: <span class="title">SomeSuperClass</span>, <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 因为采纳协议，需要加上 required</span></span><br><span class="line">    <span class="comment">// 因为继承自父类，需要加上 override</span></span><br><span class="line">    required <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 这里是构造器的实现部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可失败构造器要求">可失败构造器要求</h3><p>协议还可以为采纳协议的类型定义可失败构造器要求，详见<a href="./14_Initialization.html#failable_initializers">可失败构造器</a>。</p>
<p>采纳协议的类型可以通过可失败构造器（<code>init?</code>）或非可失败构造器（<code>init</code>）来满足协议中定义的可失败构造器要求。协议中定义的非可失败构造器要求可以通过非可失败构造器（<code>init</code>）或隐式解包可失败构造器（<code>init!</code>）来满足。</p>
<p><a name="protocols_as_types"></a></p>
<h2 id="协议作为类型">协议作为类型</h2><p>尽管协议本身并未实现任何功能，但是协议可以被当做一个成熟的类型来使用。</p>
<p>协议可以像其他普通类型一样使用，使用场景如下：</p>
<ul>
<li>作为函数、方法或构造器中的参数类型或返回值类型</li>
<li>作为常量、变量或属性的类型</li>
<li>作为数组、字典或其他容器中的元素类型</li>
</ul>
<blockquote>
<p>注意<br>协议是一种类型，因此协议类型的名称应与其他类型（例如 <code>Int</code>，<code>Double</code>，<code>String</code>）的写法相同，使用大写字母开头的驼峰式写法，例如（<code>FullyNamed</code> 和 <code>RandomNumberGenerator</code>）。</p>
</blockquote>
<p>下面是将协议作为类型使用的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dice</span> </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> sides: <span class="type">Int</span></span><br><span class="line">	<span class="keyword">let</span> generator: <span class="type">RandomNumberGenerator</span></span><br><span class="line">	<span class="keyword">init</span>(sides: <span class="type">Int</span>, generator: <span class="type">RandomNumberGenerator</span>) &#123;</span><br><span class="line">		<span class="keyword">self</span>.sides = sides</span><br><span class="line">		<span class="keyword">self</span>.generator = generator</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="func"><span class="keyword">func</span> <span class="title">roll</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="type">Int</span>(generator.random() * <span class="type">Double</span>(sides)) + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子中定义了一个 <code>Dice</code> 类，用来代表桌游中拥有 N 个面的骰子。<code>Dice</code> 的实例含有 <code>sides</code> 和 <code>generator</code> 两个属性，前者是整型，用来表示骰子有几个面，后者为骰子提供一个随机数生成器，从而生成随机点数。</p>
<p><code>generator</code> 属性的类型为 <code>RandomNumberGenerator</code>，因此任何采纳了 <code>RandomNumberGenerator</code> 协议的类型的实例都可以赋值给 <code>generator</code>，除此之外并无其他要求。</p>
<p><code>Dice</code> 类还有一个构造器，用来设置初始状态。构造器有一个名为 <code>generator</code>，类型为 <code>RandomNumberGenerator</code> 的形参。在调用构造方法创建 <code>Dice</code> 的实例时，可以传入任何采纳 <code>RandomNumberGenerator</code> 协议的实例给 <code>generator</code>。</p>
<p><code>Dice</code> 类提供了一个名为 <code>roll</code> 的实例方法，用来模拟骰子的面值。它先调用 <code>generator</code> 的 <code>random()</code> 方法来生成一个 <code>[0.0,1.0)</code> 区间内的随机数，然后使用这个随机数生成正确的骰子面值。因为 <code>generator</code> 采纳了 <code>RandomNumberGenerator</code> 协议，可以确保它有个 <code>random()</code> 方法可供调用。</p>
<p>下面的例子展示了如何使用 <code>LinearCongruentialGenerator</code> 的实例作为随机数生成器来创建一个六面骰子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d6 = <span class="type">Dice</span>(sides: <span class="number">6</span>, generator: <span class="type">LinearCongruentialGenerator</span>())</span><br><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>...<span class="number">5</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Random dice roll is <span class="subst">\(d6.roll()</span>)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Random dice roll is 3</span></span><br><span class="line"><span class="comment">// Random dice roll is 5</span></span><br><span class="line"><span class="comment">// Random dice roll is 4</span></span><br><span class="line"><span class="comment">// Random dice roll is 5</span></span><br><span class="line"><span class="comment">// Random dice roll is 4</span></span><br></pre></td></tr></table></figure>
<p><a name="delegation"></a></p>
<h2 id="委托（代理）模式">委托（代理）模式</h2><p>委托是一种设计模式，它允许类或结构体将一些需要它们负责的功能委托给其他类型的实例。委托模式的实现很简单：定义协议来封装那些需要被委托的功能，这样就能确保采纳协议的类型能提供这些功能。委托模式可以用来响应特定的动作，或者接收外部数据源提供的数据，而无需关心外部数据源的类型。</p>
<p>下面的例子定义了两个基于骰子游戏的协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">DiceGame</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> dice: <span class="type">Dice</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">	<span class="func"><span class="keyword">func</span> <span class="title">play</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">DiceGameDelegate</span> </span>&#123;</span><br><span class="line">	<span class="func"><span class="keyword">func</span> <span class="title">gameDidStart</span><span class="params">(game: DiceGame)</span></span></span><br><span class="line">	<span class="func"><span class="keyword">func</span> <span class="title">game</span><span class="params">(game: DiceGame, didStartNewTurnWithDiceRoll diceRoll:Int)</span></span></span><br><span class="line">	<span class="func"><span class="keyword">func</span> <span class="title">gameDidEnd</span><span class="params">(game: DiceGame)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DiceGame</code> 协议可以被任意涉及骰子的游戏采纳。<code>DiceGameDelegate</code> 协议可以被任意类型采纳，用来追踪 <code>DiceGame</code> 的游戏过程。</p>
<p>如下所示，<code>SnakesAndLadders</code> 是 <a href="./05_Control_Flow.html">Control Flow</a> 章节引入的蛇梯棋游戏的新版本。新版本使用 <code>Dice</code> 实例作为骰子，并且实现了 <code>DiceGame</code> 和 <code>DiceGameDelegate</code> 协议，后者用来记录游戏的过程：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnakesAndLadders</span>: <span class="title">DiceGame</span> </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> finalSquare = <span class="number">25</span></span><br><span class="line">	<span class="keyword">let</span> dice = <span class="type">Dice</span>(sides: <span class="number">6</span>, generator: <span class="type">LinearCongruentialGenerator</span>())</span><br><span class="line">	<span class="keyword">var</span> square = <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> board: [<span class="type">Int</span>]</span><br><span class="line">	<span class="keyword">init</span>() &#123;</span><br><span class="line">		board = [<span class="type">Int</span>](<span class="built_in">count</span>: finalSquare + <span class="number">1</span>, repeatedValue: <span class="number">0</span>)</span><br><span class="line">		board[<span class="number">03</span>] = +<span class="number">08</span>; board[<span class="number">06</span>] = +<span class="number">11</span>; board[<span class="number">09</span>] = +<span class="number">09</span>; board[<span class="number">10</span>] = +<span class="number">02</span></span><br><span class="line">		board[<span class="number">14</span>] = -<span class="number">10</span>; board[<span class="number">19</span>] = -<span class="number">11</span>; board[<span class="number">22</span>] = -<span class="number">02</span>; board[<span class="number">24</span>] = -<span class="number">08</span></span><br><span class="line">	&#125;</span><br><span class="line"> 	<span class="keyword">var</span> delegate: <span class="type">DiceGameDelegate</span>?</span><br><span class="line"> 	<span class="func"><span class="keyword">func</span> <span class="title">play</span><span class="params">()</span></span> &#123;</span><br><span class="line"> 		square = <span class="number">0</span></span><br><span class="line"> 		delegate?.gameDidStart(<span class="keyword">self</span>)</span><br><span class="line"> 		gameLoop: <span class="keyword">while</span> square != finalSquare &#123;</span><br><span class="line"> 			<span class="keyword">let</span> diceRoll = dice.roll()</span><br><span class="line"> 			delegate?.game(<span class="keyword">self</span>, didStartNewTurnWithDiceRoll: diceRoll)</span><br><span class="line"> 			<span class="keyword">switch</span> square + diceRoll &#123;</span><br><span class="line"> 			<span class="keyword">case</span> finalSquare:</span><br><span class="line"> 				<span class="keyword">break</span> gameLoop</span><br><span class="line"> 			<span class="keyword">case</span> <span class="keyword">let</span> newSquare <span class="keyword">where</span> newSquare &gt; finalSquare:</span><br><span class="line"> 				<span class="keyword">continue</span> gameLoop</span><br><span class="line"> 			<span class="keyword">default</span>:</span><br><span class="line"> 			    square += diceRoll</span><br><span class="line"> 			    square += board[square]</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		delegate?.gameDidEnd(<span class="keyword">self</span>)</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于这个蛇梯棋游戏的详细描述请参阅 <a href="./05_Control_Flow.html">Control Flow</a> 章节中的 <a href="./05_Control_Flow.html#break">Break</a> 部分。</p>
<p>这个版本的游戏封装到了 <code>SnakesAndLadders</code> 类中，该类采纳了 <code>DiceGame</code> 协议，并且提供了相应的只读的 <code>dice</code> 属性和 <code>play()</code> 方法。（ <code>dice</code> 属性在构造之后就不再改变，且协议只要求 <code>dice</code> 为只读的，因此将 <code>dice</code> 声明为常量属性。）</p>
<p>游戏使用 <code>SnakesAndLadders</code> 类的 <code>init()</code> 构造器来初始化游戏。所有的游戏逻辑被转移到了协议中的 <code>play()</code> 方法，<code>play()</code> 方法使用协议要求的 <code>dice</code> 属性提供骰子摇出的值。</p>
<p>注意，<code>delegate</code> 并不是游戏的必备条件，因此 <code>delegate</code> 被定义为 <code>DiceGameDelegate</code> 类型的可选属性。因为 <code>delegate</code> 是可选值，因此会被自动赋予初始值 <code>nil</code>。随后，可以在游戏中为 <code>delegate</code> 设置适当的值。</p>
<p><code>DicegameDelegate</code> 协议提供了三个方法用来追踪游戏过程。这三个方法被放置于游戏的逻辑中，即 <code>play()</code> 方法内。分别在游戏开始时，新一轮开始时，以及游戏结束时被调用。</p>
<p>因为 <code>delegate</code> 是一个 <code>DiceGameDelegate</code> 类型的可选属性，因此在 <code>play()</code> 方法中通过可选链式调用来调用它的方法。若 <code>delegate</code> 属性为 <code>nil</code>，则调用方法会优雅地失败，并不会产生错误。若 <code>delegate</code> 不为 <code>nil</code>，则方法能够被调用，并传递 <code>SnakesAndLadders</code> 实例作为参数。</p>
<p>如下示例定义了 <code>DiceGameTracker</code> 类，它采纳了 <code>DiceGameDelegate</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiceGameTracker</span>: <span class="title">DiceGameDelegate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfTurns = <span class="number">0</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">gameDidStart</span><span class="params">(game: DiceGame)</span></span> &#123;</span><br><span class="line">        numberOfTurns = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> game <span class="keyword">is</span> <span class="type">SnakesAndLadders</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Started a new game of Snakes and Ladders"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"The game is using a <span class="subst">\(game.dice.sides)</span>-sided dice"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">game</span><span class="params">(game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int)</span></span> &#123;</span><br><span class="line">        ++numberOfTurns</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Rolled a <span class="subst">\(diceRoll)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">gameDidEnd</span><span class="params">(game: DiceGame)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"The game lasted for <span class="subst">\(numberOfTurns)</span> turns"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DiceGameTracker</code> 实现了 <code>DiceGameDelegate</code> 协议要求的三个方法，用来记录游戏已经进行的轮数。当游戏开始时，<code>numberOfTurns</code> 属性被赋值为 <code>0</code>，然后在每新一轮中递增，游戏结束后，打印游戏的总轮数。</p>
<p><code>gameDidStart(_:)</code> 方法从 <code>game</code> 参数获取游戏信息并打印。<code>game</code> 参数是 <code>DiceGame</code> 类型而不是 <code>SnakeAndLadders</code> 类型，所以在方法中只能访问 <code>DiceGame</code> 协议中的内容。当然了，<code>SnakeAndLadders</code> 的方法也可以在类型转换之后调用。在上例代码中，通过 <code>is</code> 操作符检查 <code>game</code> 是否为 <code>SnakesAndLadders</code> 类型的实例，如果是，则打印出相应的消息。</p>
<p>无论当前进行的是何种游戏，由于 <code>game</code> 符合 <code>DiceGame</code> 协议，可以确保 <code>game</code> 含有 <code>dice</code> 属性。因此在 <code>gameDidStart(_:)</code> 方法中可以通过传入的 <code>game</code> 参数来访问 <code>dice</code> 属性，进而打印出 <code>dice</code> 的 <code>sides</code> 属性的值。</p>
<p><code>DiceGameTracker</code> 的运行情况如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tracker = <span class="type">DiceGameTracker</span>()</span><br><span class="line"><span class="keyword">let</span> game = <span class="type">SnakesAndLadders</span>()</span><br><span class="line">game.delegate = tracker</span><br><span class="line">game.play()</span><br><span class="line"><span class="comment">// Started a new game of Snakes and Ladders</span></span><br><span class="line"><span class="comment">// The game is using a 6-sided dice</span></span><br><span class="line"><span class="comment">// Rolled a 3</span></span><br><span class="line"><span class="comment">// Rolled a 5</span></span><br><span class="line"><span class="comment">// Rolled a 4</span></span><br><span class="line"><span class="comment">// Rolled a 5</span></span><br><span class="line"><span class="comment">// The game lasted for 4 turns</span></span><br></pre></td></tr></table></figure>
<p><a name="adding_protocol_conformance_with_an_extension"></a></p>
<h2 id="通过扩展添加协议一致性">通过扩展添加协议一致性</h2><p>即便无法修改源代码，依然可以通过扩展令已有类型采纳并符合协议。扩展可以为已有类型添加属性、方法、下标脚本以及构造器，因此可以符合协议中的相应要求。详情请在<a href="./21_Extensions.html">扩展</a>章节中查看。</p>
<blockquote>
<p>注意<br>通过扩展令已有类型采纳并符合协议时，该类型的所有实例也会随之获得协议中定义的各项功能。</p>
</blockquote>
<p>例如下面这个 <code>TextRepresentable</code> 协议，任何想要通过文本表示一些内容的类型都可以实现该协议。这些想要表示的内容可以是实例本身的描述，也可以是实例当前状态的文本描述：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TextRepresentable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textualDescription: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过扩展，令先前提到的 <code>Dice</code> 类采纳并符合 <code>TextRepresentable</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Dice</span>: <span class="title">TextRepresentable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textualDescription: <span class="type">String</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"A <span class="subst">\(sides)</span>-sided dice"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过扩展采纳并符合协议，和在原始定义中采纳并符合协议的效果完全相同。协议名称写在类型名之后，以冒号隔开，然后在扩展的大括号内实现协议要求的内容。</p>
<p>现在所有 <code>Dice</code> 的实例都可以看做 <code>TextRepresentable</code> 类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> d12 = <span class="type">Dice</span>(sides: <span class="number">12</span>,generator: <span class="type">LinearCongruentialGenerator</span>())</span><br><span class="line"><span class="built_in">print</span>(d12. textualDescription)</span><br><span class="line"><span class="comment">// 打印 “A 12-sided dice”</span></span><br></pre></td></tr></table></figure>
<p>同样，<code>SnakesAndLadders</code> 类也可以通过扩展采纳并符合 <code>TextRepresentable</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SnakesAndLadders</span>: <span class="title">TextRepresentable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textualDescription: <span class="type">String</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"A game of Snakes and Ladders with <span class="subst">\(finalSquare)</span> squares"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(game.textualDescription)</span><br><span class="line"><span class="comment">// 打印 “A game of Snakes and Ladders with 25 squares”</span></span><br></pre></td></tr></table></figure>
<p><a name="declaring_protocol_adoption_with_an_extension"></a></p>
<h2 id="通过扩展采纳协议">通过扩展采纳协议</h2><p>当一个类型已经符合了某个协议中的所有要求，却还没有声明采纳该协议时，可以通过空扩展体的扩展来采纳该协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hamster</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">   	<span class="keyword">var</span> textualDescription: <span class="type">String</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"A hamster named <span class="subst">\(name)</span>"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Hamster</span>: <span class="title">TextRepresentable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>从现在起，<code>Hamster</code> 的实例可以作为 <code>TextRepresentable</code> 类型使用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> simonTheHamster = <span class="type">Hamster</span>(name: <span class="string">"Simon"</span>)</span><br><span class="line"><span class="keyword">let</span> somethingTextRepresentable: <span class="type">TextRepresentable</span> = simonTheHamster</span><br><span class="line"><span class="built_in">print</span>(somethingTextRepresentable.textualDescription)</span><br><span class="line"><span class="comment">// 打印 “A hamster named Simon”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>即使满足了协议的所有要求，类型也不会自动采纳协议，必须显式地采纳协议。</p>
</blockquote>
<p><a name="collections_of_protocol_types"></a></p>
<h2 id="协议类型的集合">协议类型的集合</h2><p>协议类型可以在数组或者字典这样的集合中使用，在<a href="./22_Protocols.html##protocols_as_types">协议类型</a>提到了这样的用法。下面的例子创建了一个元素类型为 <code>TextRepresentable</code> 的数组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> things: [<span class="type">TextRepresentable</span>] = [game, d12, simonTheHamster]</span><br></pre></td></tr></table></figure>
<p>如下所示，可以遍历 <code>things</code> 数组，并打印每个元素的文本表示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> thing <span class="keyword">in</span> things &#123;</span><br><span class="line">	<span class="built_in">print</span>(thing.textualDescription)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A game of Snakes and Ladders with 25 squares</span></span><br><span class="line"><span class="comment">// A 12-sided dice</span></span><br><span class="line"><span class="comment">// A hamster named Simon</span></span><br></pre></td></tr></table></figure>
<p><code>thing</code> 是 <code>TextRepresentable</code> 类型而不是 <code>Dice</code>，<code>DiceGame</code>，<code>Hamster</code> 等类型，即使实例在幕后确实是这些类型中的一种。由于 <code>thing</code> 是 <code>TextRepresentable</code> 类型，任何 <code>TextRepresentable</code> 的实例都有一个 <code>textualDescription</code> 属性，所以在每次循环中可以安全地访问 <code>thing.textualDescription</code>。</p>
<p><a name="protocol_inheritance"></a></p>
<h2 id="协议的继承">协议的继承</h2><p>协议能够继承一个或多个其他协议，可以在继承的协议的基础上增加新的要求。协议的继承语法与类的继承相似，多个被继承的协议间用逗号分隔：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">InheritingProtocol</span>: <span class="title">SomeProtocol</span>, <span class="title">AnotherProtocol</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 这里是协议的定义部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下所示，<code>PrettyTextRepresentable</code> 协议继承了 <code>TextRepresentable</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">PrettyTextRepresentable</span>: <span class="title">TextRepresentable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> prettyTextualDescription: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子中定义了一个新的协议 <code>PrettyTextRepresentable</code>，它继承自 <code>TextRepresentable</code> 协议。任何采纳 <code>PrettyTextRepresentable</code> 协议的类型在满足该协议的要求时，也必须满足 <code>TextRepresentable</code> 协议的要求。在这个例子中，<code>PrettyTextRepresentable</code> 协议额外要求采纳协议的类型提供一个返回值为 <code>String</code> 类型的 <code>prettyTextualDescription</code> 属性。</p>
<p>如下所示，扩展 <code>SnakesAndLadders</code>，使其采纳并符合 <code>PrettyTextRepresentable</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SnakesAndLadders</span>: <span class="title">PrettyTextRepresentable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prettyTextualDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> output = textualDescription + <span class="string">":\n"</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span>...finalSquare &#123;</span><br><span class="line">            <span class="keyword">switch</span> board[index] &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">let</span> ladder <span class="keyword">where</span> ladder &gt; <span class="number">0</span>:</span><br><span class="line">                output += <span class="string">"▲ "</span></span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">let</span> snake <span class="keyword">where</span> snake &lt; <span class="number">0</span>:</span><br><span class="line">                output += <span class="string">"▼ "</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                output += <span class="string">"○ "</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述扩展令 <code>SnakesAndLadders</code> 采纳了 <code>PrettyTextRepresentable</code> 协议，并提供了协议要求的 <code>prettyTextualDescription</code> 属性。每个 <code>PrettyTextRepresentable</code> 类型同时也是 <code>TextRepresentable</code> 类型，所以在 <code>prettyTextualDescription</code> 的实现中，可以访问 <code>textualDescription</code> 属性。然后，拼接上了冒号和换行符。接着，遍历数组中的元素，拼接一个几何图形来表示每个棋盘方格的内容：</p>
<ul>
<li>当从数组中取出的元素的值大于 <code>0</code> 时，用 <code>▲</code> 表示。</li>
<li>当从数组中取出的元素的值小于 <code>0</code> 时，用 <code>▼</code> 表示。</li>
<li>当从数组中取出的元素的值等于 <code>0</code> 时，用 <code>○</code> 表示。</li>
</ul>
<p>任意 <code>SankesAndLadders</code> 的实例都可以使用 <code>prettyTextualDescription</code> 属性来打印一个漂亮的文本描述：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(game.prettyTextualDescription)</span><br><span class="line"><span class="comment">// A game of Snakes and Ladders with 25 squares:</span></span><br><span class="line"><span class="comment">// ○ ○ ▲ ○ ○ ▲ ○ ○ ▲ ▲ ○ ○ ○ ▼ ○ ○ ○ ○ ▼ ○ ○ ▼ ○ ▼ ○</span></span><br></pre></td></tr></table></figure>
<p><a name="class_only_protocol"></a></p>
<h2 id="类类型专属协议">类类型专属协议</h2><p>你可以在协议的继承列表中，通过添加 <code>class</code> 关键字来限制协议只能被类类型采纳，而结构体或枚举不能采纳该协议。<code>class</code> 关键字必须第一个出现在协议的继承列表中，在其他继承的协议之前：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeClassOnlyProtocol</span>: <span class="title">class</span>, <span class="title">SomeInheritedProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里是类类型专属协议的定义部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以上例子中，协议 <code>SomeClassOnlyProtocol</code> 只能被类类型采纳。如果尝试让结构体或枚举类型采纳该协议，则会导致编译错误。</p>
<blockquote>
<p>注意<br>当协议定义的要求需要采纳协议的类型必须是引用语义而非值语义时，应该采用类类型专属协议。关于引用语义和值语义的更多内容，请查看<a href="./09_Classes_and_Structures.html#structures_and_enumerations_are_value_types">结构体和枚举是值类型</a>和<a href="./09_Classes_and_Structures.html#classes_are_reference_types">类是引用类型</a>。</p>
</blockquote>
<p><a name="protocol_composition"></a></p>
<h2 id="协议合成">协议合成</h2><p>有时候需要同时采纳多个协议，你可以将多个协议采用 <code>protocol&lt;SomeProtocol, AnotherProtocol&gt;</code> 这样的格式进行组合，称为 <em>协议合成（protocol composition）</em>。你可以在 <code>&lt;&gt;</code> 中罗列任意多个你想要采纳的协议，以逗号分隔。</p>
<p>下面的例子中，将 <code>Named</code> 和 <code>Aged</code> 两个协议按照上述语法组合成一个协议，作为函数参数的类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Named</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Aged</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>: <span class="title">Named</span>, <span class="title">Aged</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">wishHappyBirthday</span><span class="params">(celebrator: <span class="keyword">protocol</span>&lt;Named, Aged&gt;)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Happy birthday <span class="subst">\(celebrator.name)</span> - you're <span class="subst">\(celebrator.age)</span>!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> birthdayPerson = <span class="type">Person</span>(name: <span class="string">"Malcolm"</span>, age: <span class="number">21</span>)</span><br><span class="line">wishHappyBirthday(birthdayPerson)</span><br><span class="line"><span class="comment">// 打印 “Happy birthday Malcolm - you're 21!”</span></span><br></pre></td></tr></table></figure>
<p><code>Named</code> 协议包含 <code>String</code> 类型的 <code>name</code> 属性。<code>Aged</code> 协议包含 <code>Int</code> 类型的 <code>age</code> 属性。<code>Person</code> 结构体采纳了这两个协议。</p>
<p><code>wishHappyBirthday(_:)</code> 函数的参数 <code>celebrator</code> 的类型为 <code>protocol&lt;Named，Aged&gt;</code>。这意味着它不关心参数的具体类型，只要参数符合这两个协议即可。</p>
<p>上面的例子创建了一个名为 <code>birthdayPerson</code> 的 <code>Person</code> 的实例，作为参数传递给了 <code>wishHappyBirthday(_:)</code> 函数。因为 <code>Person</code> 同时符合这两个协议，所以这个参数合法，函数将打印生日问候语。</p>
<blockquote>
<p>注意<br>协议合成并不会生成新的、永久的协议类型，而是将多个协议中的要求合成到一个只在局部作用域有效的临时协议中。</p>
</blockquote>
<p><a name="checking_for_protocol_conformance"></a></p>
<h2 id="检查协议一致性">检查协议一致性</h2><p>你可以使用<a href="./20_Type_Casting.html">类型转换</a>中描述的 <code>is</code> 和 <code>as</code> 操作符来检查协议一致性，即是否符合某协议，并且可以转换到指定的协议类型。检查和转换到某个协议类型在语法上和类型的检查和转换完全相同：</p>
<ul>
<li><code>is</code> 用来检查实例是否符合某个协议，若符合则返回 <code>true</code>，否则返回 <code>false</code>。</li>
<li><code>as?</code> 返回一个可选值，当实例符合某个协议时，返回类型为协议类型的可选值，否则返回 <code>nil</code>。</li>
<li><code>as!</code> 将实例强制向下转换到某个协议类型，如果强转失败，会引发运行时错误。</li>
</ul>
<p>下面的例子定义了一个 <code>HasArea</code> 协议，该协议定义了一个 <code>Double</code> 类型的只读属性 <code>area</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">HasArea</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">Double</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下所示，<code>Circle</code> 类和 <code>Country</code> 类都采纳了 <code>HasArea</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>: <span class="title">HasArea</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pi = <span class="number">3.1415927</span></span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">Double</span> &#123; <span class="keyword">return</span> pi * radius * radius &#125;</span><br><span class="line">    <span class="keyword">init</span>(radius: <span class="type">Double</span>) &#123; <span class="keyword">self</span>.radius = radius &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Country</span>: <span class="title">HasArea</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">init</span>(area: <span class="type">Double</span>) &#123; <span class="keyword">self</span>.area = area &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Circle</code> 类把 <code>area</code> 属性实现为基于存储型属性 <code>radius</code> 的计算型属性。<code>Country</code> 类则把 <code>area</code> 属性实现为存储型属性。这两个类都正确地符合了 <code>HasArea</code> 协议。</p>
<p>如下所示，<code>Animal</code> 是一个未采纳 <code>HasArea</code> 协议的类：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> legs: <span class="type">Int</span></span><br><span class="line">	<span class="keyword">init</span>(legs: <span class="type">Int</span>) &#123; <span class="keyword">self</span>.legs = legs &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Circle</code>，<code>Country</code>，<code>Animal</code> 并没有一个共同的基类，尽管如此，它们都是类，它们的实例都可以作为 <code>AnyObject</code> 类型的值，存储在同一个数组中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> objects: [<span class="type">AnyObject</span>] = [</span><br><span class="line">	<span class="type">Circle</span>(radius: <span class="number">2.0</span>),</span><br><span class="line">	<span class="type">Country</span>(area: <span class="number">243_610</span>),</span><br><span class="line">	<span class="type">Animal</span>(legs: <span class="number">4</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><code>objects</code> 数组使用字面量初始化，数组包含一个 <code>radius</code> 为 <code>2</code> 的 <code>Circle</code> 的实例，一个保存了英国国土面积的 <code>Country</code> 实例和一个 <code>legs</code> 为 <code>4</code> 的 <code>Animal</code> 实例。</p>
<p>如下所示，<code>objects</code> 数组可以被迭代，并对迭代出的每一个元素进行检查，看它是否符合 <code>HasArea</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> object <span class="keyword">in</span> objects &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> objectWithArea = object <span class="keyword">as</span>? <span class="type">HasArea</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Area is <span class="subst">\(objectWithArea.area)</span>"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Something that doesn't have an area"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Area is 12.5663708</span></span><br><span class="line"><span class="comment">// Area is 243610.0</span></span><br><span class="line"><span class="comment">// Something that doesn't have an area</span></span><br></pre></td></tr></table></figure>
<p>当迭代出的元素符合 <code>HasArea</code> 协议时，将 <code>as?</code> 操作符返回的可选值通过可选绑定，绑定到 <code>objectWithArea</code> 常量上。<code>objectWithArea</code> 是 <code>HasArea</code> 协议类型的实例，因此 <code>area</code> 属性可以被访问和打印。</p>
<p><code>objects</code> 数组中的元素的类型并不会因为强转而丢失类型信息，它们仍然是 <code>Circle</code>，<code>Country</code>，<code>Animal</code> 类型。然而，当它们被赋值给 <code>objectWithArea</code> 常量时，只被视为 <code>HasArea</code> 类型，因此只有 <code>area</code> 属性能够被访问。</p>
<p><a name="optional_protocol_requirements"></a></p>
<h2 id="可选的协议要求">可选的协议要求</h2><p>协议可以定义可选要求，采纳协议的类型可以选择是否实现这些要求。在协议中使用 <code>optional</code> 关键字作为前缀来定义可选要求。使用可选要求时（例如，可选的方法或者属性），它们的类型会自动变成可选的。比如，一个类型为 <code>(Int) -&gt; String</code> 的方法会变成 <code>((Int) -&gt; String)?</code>。需要注意的是整个函数类型是可选的，而不是函数的返回值。</p>
<p>协议中的可选要求可通过可选链式调用来使用，因为采纳协议的类型可能没有实现这些可选要求。类似 <code>someOptionalMethod?(someArgument)</code> 这样，你可以在可选方法名称后加上 <code>?</code> 来调用可选方法。详细内容可在<a href="./17_Optional_Chaining.html">可选链式调用</a>章节中查看。</p>
<blockquote>
<p>注意<br>可选的协议要求只能用在标记 <code>@objc</code> 特性的协议中。<br>该特性表示协议将暴露给 Objective-C 代码，详情参见<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216" target="_blank" rel="external"><code>Using Swift with Cocoa and Objective-C(Swift 2.1)</code></a>。即使你不打算和 Objective-C 有什么交互，如果你想要指定可选的协议要求，那么还是要为协议加上 <code>@obj</code> 特性。<br>还需要注意的是，标记 <code>@objc</code> 特性的协议只能被继承自 Objective-C 类的类或者 <code>@objc</code> 类采纳，其他类以及结构体和枚举均不能采纳这种协议。</p>
</blockquote>
<p>下面的例子定义了一个名为 <code>Counter</code> 的用于整数计数的类，它使用外部的数据源来提供每次的增量。数据源由 <code>CounterDataSource</code> 协议定义，包含两个可选要求：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">CounterDataSource</span> </span>&#123;</span><br><span class="line">    optional <span class="func"><span class="keyword">func</span> <span class="title">incrementForCount</span><span class="params">(<span class="built_in">count</span>: Int)</span></span> -&gt; <span class="type">Int</span></span><br><span class="line">    optional <span class="keyword">var</span> fixedIncrement: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CounterDataSource</code> 协议定义了一个可选方法 <code>incrementForCount(_:)</code> 和一个可选属性 <code>fiexdIncrement</code>，它们使用了不同的方法来从数据源中获取适当的增量值。</p>
<blockquote>
<p>注意<br>严格来讲，<code>CounterDataSource</code> 协议中的方法和属性都是可选的，因此采纳协议的类可以不实现这些要求，尽管技术上允许这样做，不过最好不要这样写。</p>
</blockquote>
<p><code>Counter</code> 类含有 <code>CounterDataSource?</code> 类型的可选属性 <code>dataSource</code>，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> dataSource: <span class="type">CounterDataSource</span>?</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">increment</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> amount = dataSource?.incrementForCount?(<span class="built_in">count</span>) &#123;</span><br><span class="line">            <span class="built_in">count</span> += amount</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> amount = dataSource?.fixedIncrement &#123;</span><br><span class="line">            <span class="built_in">count</span> += amount</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Counter</code> 类使用变量属性 <code>count</code> 来存储当前值。该类还定义了一个 <code>increment()</code> 方法，每次调用该方法的时候，将会增加 <code>count</code> 的值。</p>
<p><code>increment()</code> 方法首先试图使用 <code>incrementForCount(_:)</code> 方法来得到每次的增量。<code>increment()</code> 方法使用可选链式调用来尝试调用 <code>incrementForCount(_:)</code>，并将当前的 <code>count</code> 值作为参数传入。</p>
<p>这里使用了两层可选链式调用。首先，由于 <code>dataSource</code> 可能为 <code>nil</code>，因此在 <code>dataSource</code> 后边加上了 <code>?</code>，以此表明只在 <code>dataSource</code> 非空时才去调用 <code>incrementForCount(_:)</code> 方法。其次，即使 <code>dataSource</code> 存在，也无法保证其是否实现了 <code>incrementForCount(_:)</code> 方法，因为这个方法是可选的。因此，<code>incrementForCount(_:)</code> 方法同样使用可选链式调用进行调用，只有在该方法被实现的情况下才能调用它，所以在 <code>incrementForCount(_:)</code> 方法后边也加上了 <code>?</code>。</p>
<p>调用 <code>incrementForCount(_:)</code> 方法在上述两种情形下都有可能失败，所以返回值为 <code>Int?</code> 类型。虽然在 <code>CounterDataSource</code> 协议中，<code>incrementForCount(_:)</code> 的返回值类型是非可选 <code>Int</code>。另外，即使这里使用了两层可选链式调用，最后的返回结果依旧是单层的可选类型，即 <code>Int?</code> 而不是 <code>Int??</code>。关于这一点的更多信息，请查阅<a href="./17_Optional_Chaining">连接多层可选链式调用</a></p>
<p>在调用 <code>incrementForCount(_:)</code> 方法后，<code>Int?</code> 型的返回值通过可选绑定解包并赋值给常量 <code>amount</code>。如果可选值确实包含一个数值，也就是说，数据源和方法都存在，数据源方法返回了一个有效值。之后便将解包后的 <code>amount</code> 加到 <code>count</code> 上，增量操作完成。</p>
<p>如果没有从 <code>incrementForCount(_:)</code> 方法获取到值，可能由于 <code>dataSource</code> 为 <code>nil</code>，或者它并没有实现 <code>incrementForCount(_:)</code> 方法，那么 <code>increment()</code> 方法将试图从数据源的 <code>fixedIncrement</code> 属性中获取增量。<code>fixedIncrement</code> 是一个可选属性，因此属性值是一个 <code>Int?</code> 值，即使该属性在 <code>CounterDataSource</code> 协议中的类型是非可选的 <code>Int</code>。</p>
<p>下面的例子展示了 <code>CounterDataSource</code> 的简单实现。<code>ThreeSource</code> 类采纳了 <code>CounterDataSource</code> 协议，它实现了可选属性 <code>fixedIncrement</code>，每次会返回 <code>3</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreeSource</span>: <span class="title">NSObject</span>, <span class="title">CounterDataSource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fixedIncrement = <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用 <code>ThreeSource</code> 的实例作为 <code>Counter</code> 实例的数据源：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="type">Counter</span>()</span><br><span class="line">counter.dataSource = <span class="type">ThreeSource</span>()</span><br><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>...<span class="number">4</span> &#123;</span><br><span class="line">    counter.increment()</span><br><span class="line">    <span class="built_in">print</span>(counter.<span class="built_in">count</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 12</span></span><br></pre></td></tr></table></figure>
<p>上述代码新建了一个 <code>Counter</code> 实例，并将它的数据源设置为一个 <code>TreeSource</code> 的实例，然后调用 <code>increment()</code> 方法四次。和预期一样，每次调用都会将 <code>count</code> 的值增加 <code>3</code>.</p>
<p>下面是一个更为复杂的数据源 <code>TowardsZeroSource</code>，它将使得最后的值变为 <code>0</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">@objc</span> <span class="class"><span class="keyword">class</span> <span class="title">TowardsZeroSource</span>: <span class="title">NSObject</span>, <span class="title">CounterDataSource</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">incrementForCount</span><span class="params">(<span class="built_in">count</span>: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">count</span> == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">count</span> &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TowardsZeroSource</code> 实现了 <code>CounterDataSource</code> 协议中的 <code>incrementForCount(_:)</code> 方法，以 <code>count</code> 参数为依据，计算出每次的增量。如果 <code>count</code> 已经为 <code>0</code>，此方法返回 <code>0</code>，以此表明之后不应再有增量操作发生。</p>
<p>你可以使用 <code>TowardsZeroSource</code> 实例将 <code>Counter</code> 实例来从 <code>-4</code> 增加到 <code>0</code>。一旦增加到 <code>0</code>，数值便不会再有变动：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">counter.<span class="built_in">count</span> = -<span class="number">4</span></span><br><span class="line">counter.dataSource = <span class="type">TowardsZeroSource</span>()</span><br><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>...<span class="number">5</span> &#123;</span><br><span class="line">    counter.increment()</span><br><span class="line">    <span class="built_in">print</span>(counter.<span class="built_in">count</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -3</span></span><br><span class="line"><span class="comment">// -2</span></span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p><a name="protocol_extensions"></a></p>
<h2 id="协议扩展">协议扩展</h2><p>协议可以通过扩展来为采纳协议的类型提供属性、方法以及下标脚本的实现。通过这种方式，你可以基于协议本身来实现这些功能，而无需在每个采纳协议的类型中都重复同样的实现，也无需使用全局函数。</p>
<p>例如，可以扩展 <code>RandomNumberGenerator</code> 协议来提供 <code>randomBool()</code> 方法。该方法使用协议中定义的 <code>random()</code> 方法来返回一个随机的 <code>Bool</code> 值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">RandomNumberGenerator</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">randomBool</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> random() &gt; <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过协议扩展，所有采纳协议的类型，都能自动获得这个扩展所增加的方法实现，无需任何额外修改：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> generator = <span class="type">LinearCongruentialGenerator</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Here's a random number: <span class="subst">\(generator.random()</span>)"</span>)</span><br><span class="line"><span class="comment">// 打印 “Here's a random number: 0.37464991998171”</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"And here's a random Boolean: <span class="subst">\(generator.randomBool()</span>)"</span>)</span><br><span class="line"><span class="comment">// 打印 “And here's a random Boolean: true”</span></span><br></pre></td></tr></table></figure>
<p><a name="providing_default_implementations"></a></p>
<h3 id="提供默认实现">提供默认实现</h3><p>可以通过协议扩展来为协议要求的属性、方法以及下标脚本提供默认的实现。如果采纳协议的类型为这些要求提供了自己的实现，那么这些自定义实现将会替代扩展中的默认实现被使用。</p>
<blockquote>
<p>注意<br>通过协议扩展为协议要求提供的默认实现和可选的协议要求不同。虽然在这两种情况下，采纳协议的类型都无需自己实现这些要求，但是通过扩展提供的默认实现可以直接调用，而无需使用可选链式调用。</p>
</blockquote>
<p>例如，<code>PrettyTextRepresentable</code> 协议继承自 <code>TextRepresentable</code> 协议，可以为其提供一个默认的 <code>prettyTextualDescription</code> 属性，只是简单地返回 <code>textualDescription</code> 属性的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PrettyTextRepresentable</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prettyTextualDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> textualDescription</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="adding_constraints_to_protocol_extensions"></a></p>
<h3 id="为协议扩展添加限制条件">为协议扩展添加限制条件</h3><p>在扩展协议的时候，可以指定一些限制条件，只有采纳协议的类型满足这些限制条件时，才能获得协议扩展提供的默认实现。这些限制条件写在协议名之后，使用 <code>where</code> 子句来描述，正如<a href="./23_Generics.html#where_clauses">Where子句</a>)中所描述的。</p>
<p>例如，你可以扩展 <code>CollectionType</code> 协议，但是只适用于集合中的元素采纳了 <code>TextRepresentable</code> 协议的情况：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CollectionType</span> <span class="title">where</span> <span class="title">Generator</span>.<span class="title">Element</span>: <span class="title">TextRepresentable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textualDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> itemsAsText = <span class="keyword">self</span>.<span class="built_in">map</span> &#123; $<span class="number">0</span>.textualDescription &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"["</span> + itemsAsText.joinWithSeparator(<span class="string">", "</span>) + <span class="string">"]"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>textualDescription</code> 属性返回整个集合的文本描述，它将集合中的每个元素的文本描述以逗号分隔的方式连接起来，包在一对方括号中。</p>
<p>现在我们来看看先前的 <code>Hamster</code> 结构体，它符合 <code>TextRepresentable</code> 协议，同时这里还有个装有 <code>Hamster</code> 的实例的数组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> murrayTheHamster = <span class="type">Hamster</span>(name: <span class="string">"Murray"</span>)</span><br><span class="line"><span class="keyword">let</span> morganTheHamster = <span class="type">Hamster</span>(name: <span class="string">"Morgan"</span>)</span><br><span class="line"><span class="keyword">let</span> mauriceTheHamster = <span class="type">Hamster</span>(name: <span class="string">"Maurice"</span>)</span><br><span class="line"><span class="keyword">let</span> hamsters = [murrayTheHamster, morganTheHamster, mauriceTheHamster]</span><br></pre></td></tr></table></figure>
<p>因为 <code>Array</code> 符合 <code>CollectionType</code> 协议，而数组中的元素又符合 <code>TextRepresentable</code> 协议，所以数组可以使用 <code>textualDescription</code> 属性得到数组内容的文本表示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(hamsters.textualDescription)</span><br><span class="line"><span class="comment">// 打印 “[A hamster named Murray, A hamster named Morgan, A hamster named Maurice]”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>如果多个协议扩展都为同一个协议要求提供了默认实现，而采纳协议的类型又同时满足这些协议扩展的限制条件，那么将会使用限制条件最多的那个协议扩展提供的默认实现。</p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/23_Generics/" itemprop="url">
                第二章-23泛型（Generics）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:04+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/23_Generics/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/23_Generics/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="泛型（Generics）">泛型（Generics）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/takalard" target="_blank" rel="external">takalard</a><br>校对：<a href="https://github.com/lifedim" target="_blank" rel="external">lifedim</a></p>
<p>2.0<br>翻译+校对： <a href="https://github.com/SergioChan" target="_blank" rel="external">SergioChan</a></p>
<p>2.1<br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a>，2015-11-01</p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#the_problem_that_generics_solve">泛型所解决的问题</a></li>
<li><a href="#generic_functions">泛型函数</a></li>
<li><a href="#type_parameters">类型参数</a></li>
<li><a href="#naming_type_parameters">命名类型参数</a></li>
<li><a href="#generic_types">泛型类型</a></li>
<li><a href="#extending_a_generic_type">扩展一个泛型类型</a></li>
<li><a href="#type_constraints">类型约束</a></li>
<li><a href="#associated_types">关联类型</a></li>
<li><a href="#where_clauses">Where 子句</a></li>
</ul>
<p>泛型代码可以让你编写适用自定义需求以及任意类型的灵活可重用的函数和类型。它的可以让你避免重复的代码，用一种清晰和抽象的方式来表达代码的意图。</p>
<p>泛型是 Swift 的强大特性之一，许多 Swift 标准库是通过泛型代码构建的。事实上，泛型的使用贯穿了整本语言手册，只是你可能没有发现而已。例如，Swift 的 <code>Array</code> 和 <code>Dictionary</code> 都是泛型集合。你可以创建一个 <code>Int</code> 数组，也可创建一个 <code>String</code> 数组，甚至可以是任意其他 Swift 类型的数组。同样的，你也可以创建存储任意指定类型的字典。</p>
<p><a name="the_problem_that_generics_solve"></a></p>
<h2 id="泛型所解决的问题">泛型所解决的问题</h2><p>下面是一个标准的非泛型函数 <code>swapTwoInts(_:_:)</code>，用来交换两个 <code>Int</code> 值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">swapTwoInts</span><span class="params">(<span class="keyword">inout</span> a: Int, <span class="keyword">inout</span> <span class="number">_</span> b: Int)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA = a</span><br><span class="line">    a = b</span><br><span class="line">    b = temporaryA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数使用输入输出参数（<code>inout</code>）来交换 <code>a</code> 和 <code>b</code> 的值，请参考<a href="./06_Functions.html#in_out_parameters">输入输出参数</a>。</p>
<p><code>swapTwoInts(_:_:)</code> 函数交换 <code>b</code> 的原始值到 <code>a</code>，并交换 <code>a</code> 的原始值到 <code>b</code>。你可以调用这个函数交换两个 <code>Int</code> 变量的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someInt = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> anotherInt = <span class="number">107</span></span><br><span class="line">swapTwoInts(&amp;someInt, &amp;anotherInt)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"someInt is now <span class="subst">\(someInt)</span>, and anotherInt is now <span class="subst">\(anotherInt)</span>"</span>)</span><br><span class="line"><span class="comment">// 打印 “someInt is now 107, and anotherInt is now 3”</span></span><br></pre></td></tr></table></figure>
<p>诚然，<code>swapTwoInts(_:_:)</code> 函数挺有用，但是它只能交换 <code>Int</code> 值，如果你想要交换两个 <code>String</code> 值或者 <code>Double</code>值，就不得不写更多的函数，例如 <code>swapTwoStrings(_:_:)</code> 和 <code>swapTwoDoubles(_:_:)</code>，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">swapTwoStrings</span><span class="params">(<span class="keyword">inout</span> a: String, <span class="keyword">inout</span> <span class="number">_</span> b: String)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA = a</span><br><span class="line">    a = b</span><br><span class="line">    b = temporaryA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">swapTwoDoubles</span><span class="params">(<span class="keyword">inout</span> a: Double, <span class="keyword">inout</span> <span class="number">_</span> b: Double)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA = a</span><br><span class="line">    a = b</span><br><span class="line">    b = temporaryA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能注意到 <code>swapTwoInts(_:_:)</code>、<code>swapTwoStrings(_:_:)</code> 和 <code>swapTwoDoubles(_:_:)</code> 的函数功能都是相同的，唯一不同之处就在于传入的变量类型不同，分别是 <code>Int</code>、<code>String</code> 和 <code>Double</code>。</p>
<p>在实际应用中，通常需要一个更实用更灵活的函数来交换两个任意类型的值，幸运的是，泛型代码帮你解决了这种问题。（这些函数的泛型版本已经在下面定义好了。）</p>
<blockquote>
<p>注意<br>在上面三个函数中，<code>a</code> 和 <code>b</code> 类型相同。如果 <code>a</code> 和 <code>b</code> 类型不同，那它们俩就不能互换值。Swift 是类型安全的语言，所以它不允许一个 <code>String</code> 类型的变量和一个 <code>Double</code> 类型的变量互换值。试图这样做将导致编译错误。</p>
</blockquote>
<p><a name="generic_functions"></a></p>
<h2 id="泛型函数">泛型函数</h2><p>泛型函数可以适用于任何类型，下面的 <code>swapTwoValues(_:_:)</code> 函数是上面三个函数的泛型版本：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">swapTwoValues</span><span class="generics">&lt;T&gt;</span><span class="params">(<span class="keyword">inout</span> a: T, <span class="keyword">inout</span> <span class="number">_</span> b: T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA = a</span><br><span class="line">    a = b</span><br><span class="line">    b = temporaryA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>swapTwoValues(_:_:)</code> 的函数主体和 <code>swapTwoInts(_:_:)</code> 函数是一样的，它们只在第一行有点不同，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">swapTwoInts</span><span class="params">(<span class="keyword">inout</span> a: Int, <span class="keyword">inout</span> <span class="number">_</span> b: Int)</span></span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">swapTwoValues</span><span class="generics">&lt;T&gt;</span><span class="params">(<span class="keyword">inout</span> a: T, <span class="keyword">inout</span> <span class="number">_</span> b: T)</span></span></span><br></pre></td></tr></table></figure>
<p>这个函数的泛型版本使用了占位类型名（在这里用字母 <code>T</code> 来表示）来代替实际类型名（例如 <code>Int</code>、<code>String</code> 或 <code>Double</code>）。占位类型名没有指明 <code>T</code> 必须是什么类型，但是它指明了 <code>a</code> 和 <code>b</code> 必须是同一类型 <code>T</code>，而无论 <code>T</code> 代表什么类型。只有 <code>swapTwoValues(_:_:)</code> 函数在调用时，才能根据所传入的实际类型决定 <code>T</code> 所代表的类型。</p>
<p>另外一个不同之处在于这个泛型函数名后面跟着占位类型名（<code>T</code>），而且是用尖括号括起来的（<code>&lt;T&gt;</code>）。这个尖括号告诉 Swift 那个 <code>T</code> 是 <code>swapTwoValues(_:_:)</code> 函数定义的一个占位类型名，因此 Swift 不会去查找名为 <code>T</code> 的实际类型。</p>
<p><code>swapTwoValues(_:_:)</code> 函数现在可以像 <code>swapTwoInts(_:_:)</code> 那样调用，可以传入任意类型的值，只要两个值的类型相同。<code>swapTwoValues(_:_:)</code> 函数被调用时，<code>T</code> 所代表的类型都会由传入的值的类型推断出来。</p>
<p>在下面的两个例子中，<code>T</code> 分别代表 <code>Int</code> 和 <code>String</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someInt = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> anotherInt = <span class="number">107</span></span><br><span class="line">swapTwoValues(&amp;someInt, &amp;anotherInt)</span><br><span class="line"><span class="comment">// someInt is now 107, and anotherInt is now 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someString = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">var</span> anotherString = <span class="string">"world"</span></span><br><span class="line">swapTwoValues(&amp;someString, &amp;anotherString)</span><br><span class="line"><span class="comment">// someString is now "world", and anotherString is now "hello"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>上面定义的 <code>swapTwoValues(_:_:)</code> 函数是受 <code>swap(_:_:)</code> 函数启发而实现的。后者存在于 Swift 标准库，你可以在你的应用程序中使用它。如果你在代码中需要类似 <code>swapTwoValues(_:_:)</code> 函数的功能，你可以使用已存在的 <code>swap(_:_:)</code> 函数。</p>
</blockquote>
<p><a name="type_parameters"></a></p>
<h2 id="类型参数">类型参数</h2><p>在上面的 <code>swapTwoValues(_:_:)</code> 例子中，占位类型 <code>T</code> 是类型参数的一个例子。类型参数指定并命名一个占位类型，并且紧随在函数名后面，使用一对尖括号括起来（例如 <code>&lt;T&gt;</code>）。</p>
<p>一旦一个类型参数被指定，你可以用它来定义一个函数的参数类型（例如 <code>swapTwoValues(_:_:)</code> 函数中的参数 <code>a</code> 和 <code>b</code>），或者作为函数的返回类型，还可以用作函数主体中的注释类型。在这些情况下，类型参数会在函数调用时被实际类型所替换。（在上面的 <code>swapTwoValues(_:_:)</code> 例子中，当函数第一次被调用时，<code>T</code> 被 <code>Int</code> 替换，第二次调用时，被 <code>String</code> 替换。）</p>
<p>你可提供多个类型参数，将它们都写在尖括号中，用逗号分开。</p>
<p><a name="naming_type_parameters"></a></p>
<h2 id="命名类型参数">命名类型参数</h2><p>在大多数情况下，类型参数具有一个描述性名字，例如 <code>Dictionary&lt;Key, Value&gt;</code> 中的 <code>Key</code> 和 <code>Value</code>，以及 <code>Array&lt;Element&gt;</code> 中的 <code>Element</code>，这可以告诉阅读代码的人这些类型参数和泛型函数之间的关系。然而，当它们之间的关系没有意义时，通常使用单一的字母来命名，例如 <code>T</code>、<code>U</code>、<code>V</code>，正如上面演示的 <code>swapTwoValues(_:_:)</code> 函数中的 <code>T</code> 一样。</p>
<blockquote>
<p>注意<br>请始终使用大写字母开头的驼峰式命名法（例如 <code>T</code> 和 <code>MyTypeParameter</code>）来为类型参数命名，以表明它们是占位类型，而不是一个值。</p>
</blockquote>
<p><a name="generic_types"></a></p>
<h2 id="泛型类型">泛型类型</h2><p>除了泛型函数，Swift 还允许你定义泛型类型。这些自定义类、结构体和枚举可以适用于任何类型，如同 <code>Array</code> 和 <code>Dictionary</code> 的用法。</p>
<p>这部分内容将向你展示如何编写一个名为 <code>Stack</code> （栈）的泛型集合类型。栈是一系列值的有序集合，和 <code>Array</code> 类似，但它相比 Swift 的 <code>Array</code> 类型有更多的操作限制。数组允许对其中任意位置的元素执行插入或删除操作。而栈，只允许在集合的末端添加新的元素（称之为入栈）。同样的，栈也只能从末端移除元素（称之为出栈）。</p>
<blockquote>
<p>注意<br>栈的概念已被 <code>UINavigationController</code> 类用来模拟视图控制器的导航结构。你通过调用 <code>UINavigationController</code> 的 <code>pushViewController(_:animated:)</code> 方法来添加新的视图控制器到导航栈，通过 <code>popViewControllerAnimated(_:)</code> 方法来从导航栈中移除某个视图控制器。每当你需要一个严格的“后进先出”方式来管理集合，栈都是最实用的模型。</p>
</blockquote>
<p>下图展示了一个栈的压栈（push）和出栈（pop）的行为：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPushPop_2x.png" alt="此处输入图片的描述"></p>
<ol>
<li>现在有三个值在栈中。</li>
<li>第四个值被压入到栈的顶部。</li>
<li>现在有四个值在栈中，最近入栈的那个值在顶部。</li>
<li>栈中最顶部的那个值被移除，或称之为出栈。</li>
<li>移除掉一个值后，现在栈再一次只有三个值。</li>
</ol>
<p>下面展示了如何编写一个非泛型版本的栈，在这种情况下是 <code>Int</code> 型的栈：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IntStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> items = [<span class="type">Int</span>]()</span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">push</span><span class="params">(item: Int)</span></span> &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个结构体在栈中使用一个名为 <code>items</code> 的 <code>Array</code> 属性来存储值。<code>Stack</code> 提供了两个方法：<code>push(_:)</code> 和 <code>pop()</code>，用来向栈中压入值以及从栈中移除值。这些方法被标记为 <code>mutating</code>，因为它们需要修改结构体的 <code>items</code> 数组。</p>
<p>上面的 <code>IntStack</code> 结构体只能用于 <code>Int</code> 类型。不过，可以定义一个泛型 <code>Stack</code> 结构体，从而能够处理任意类型的值。</p>
<p>下面是相同代码的泛型版本：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> items = [<span class="type">Element</span>]()</span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">push</span><span class="params">(item: Element)</span></span> &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，<code>Stack</code> 基本上和 <code>IntStack</code> 相同，只是用占位类型参数 <code>Element</code> 代替了实际的 <code>Int</code> 类型。这种类型参数包裹在一对尖括号里（<code>&lt;Element&gt;</code>），紧跟在结构体名后面。</p>
<p><code>Element</code> 为尚未提供的类型定义了一个占位名。这种尚未提供的类型可以在结构体的定义中通过 <code>Element</code> 来引用。在这种情况下，<code>Element</code> 在如下三个地方被用作占位符：</p>
<ul>
<li>创建 <code>items</code> 属性，使用 <code>Element</code> 类型的空数组对其进行初始化。</li>
<li>指定 <code>push(_:)</code> 方法的单一参数 <code>item</code> 的类型必须是 <code>Element</code> 类型。</li>
<li>指定 <code>pop()</code> 方法的返回值类型必须是 <code>Element</code> 类型。</li>
</ul>
<p>由于 <code>Stack</code> 是泛型类型，因此可以用来创建 Swift 中任意有效类型的栈，如同 <code>Array</code> 和 <code>Dictionary</code>。</p>
<p>你可以通过在尖括号中写出栈中需要存储的数据类型来创建并初始化一个 <code>Stack</code> 实例。例如，要创建一个 <code>String</code> 类型的栈，可以写成 <code>Stack&lt;String&gt;()</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stackOfStrings = <span class="type">Stack</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">stackOfStrings.push(<span class="string">"uno"</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">"dos"</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">"tres"</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">"cuatro"</span>)</span><br><span class="line"><span class="comment">// 栈中现在有 4 个字符串</span></span><br></pre></td></tr></table></figure>
<p>下图展示了 <code>stackOfStrings</code> 如何将这四个值入栈：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPushedFourStrings_2x.png" alt="此处输入图片的描述"></p>
<p>移除并返回栈顶部的值 <code>&quot;cuatro&quot;</code>，即将其出栈：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fromTheTop = stackOfStrings.pop()</span><br><span class="line"><span class="comment">// fromTheTop 的值为 "cuatro"，现在栈中还有 3 个字符串</span></span><br></pre></td></tr></table></figure>
<p>下图展示了 <code>stackOfStrings</code> 如何将顶部的值出栈：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPoppedOneString_2x.png" alt="此处输入图片的描述"></p>
<p><a name="extending_a_generic_type"></a></p>
<h2 id="扩展一个泛型类型">扩展一个泛型类型</h2><p>当你扩展一个泛型类型的时候，你并不需要在扩展的定义中提供类型参数列表。更加方便的是，原始类型定义中声明的类型参数列表在扩展中可以直接使用，并且这些来自原始类型中的参数名称会被用作原始定义中类型参数的引用。</p>
<p>下面的例子扩展了泛型类型 <code>Stack</code>，为其添加了一个名为 <code>topItem</code> 的只读计算型属性，它将会返回当前栈顶端的元素而不会将其从栈中移除：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> topItem: <span class="type">Element</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> items.isEmpty ? <span class="literal">nil</span> : items[items.<span class="built_in">count</span> - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>topItem</code> 属性会返回一个 <code>Element</code> 类型的可选值。当栈为空的时候，<code>topItem</code> 会返回 <code>nil</code>；当栈不为空的时候，<code>topItem</code> 会返回 <code>items</code> 数组中的最后一个元素。</p>
<p>注意，这个扩展并没有定义一个类型参数列表。相反的，<code>Stack</code> 类型已有的类型参数名称 <code>Element</code>，被用在扩展中来表示计算型属性 <code>topItem</code> 的可选类型。</p>
<p>计算型属性 <code>topItem</code> 现在可以用来访问任意 <code>Stack</code> 实例的顶端元素而不是移除它：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> topItem = stackOfStrings.topItem &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The top item on the stack is <span class="subst">\(topItem)</span>."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “The top item on the stack is tres.”</span></span><br></pre></td></tr></table></figure>
<p><a name="type_constraints"></a></p>
<h2 id="类型约束">类型约束</h2><p><code>swapTwoValues(_:_:)</code> 函数和 <code>Stack</code> 类型可以作用于任何类型。不过，有的时候如果能将使用在泛型函数和泛型类型中的类型，强制约束为某种特定类型，将会是非常有用的。类型约束可以指定一个类型参数必须继承自指定类，或者符合一个特定的协议或协议组合。</p>
<p>例如，Swift 的 <code>Dictionary</code> 类型对字典的键的类型做了些限制。在<a href="./04_Collection_Types.html#dictionaries">字典</a>的描述中，字典的键的类型必须是可哈希的。也就是说，必须有一种方法能作为其唯一的表示。<code>Dictionary</code> 之所以需要其键是可哈希的，是为了便于检查字典是否已经包含某个特定键的值。如无此要求，<code>Dictionary</code> 将无法判断是否可以插入或者替换某个指定键的值，也不能查找到已经存储在字典中的指定键的值。</p>
<p>这个要求强制加上了一个类型约束作用于 <code>Dictionary</code> 的键类型上，其键类型必须符合 <code>Hashable</code> 协议，这是 Swift 标准库中定义的一个特定协议。所有的 Swift 基本类型（例如 <code>String</code>、<code>Int</code>、<code>Double</code> 和 <code>Bool</code>）默认都是可哈希的。</p>
<p>当你创建自定义泛型类型时，你可以定义你自己的类型约束，这些约束将提供更为强大的泛型编程能力。抽象概念，例如可哈希的，描述的是类型在概念上的特征，而不是它们的显式类型。</p>
<p><a name="type_constraint_syntax"></a></p>
<h3 id="类型约束语法">类型约束语法</h3><p>你可以在一个类型参数名后面放置一个类名或者协议名，通过冒号分隔，从而定义类型约束，它们将作为类型参数列表的一部分。这种基本的类型约束作用于泛型函数时的语法如下所示（作用于泛型类型时的语法与之相同）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">someFunction</span><span class="generics">&lt;T: SomeClass, U: SomeProtocol&gt;</span><span class="params">(someT: T, someU: U)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这里是泛型函数的函数体部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个函数有两个类型参数。第一个类型参数 <code>T</code>，有一个要求 <code>T</code> 必须是 <code>SomeClass</code> 子类的类型约束；第二个类型参数 <code>U</code>，有一个要求 <code>U</code> 必须符合 <code>SomeProtocol</code> 协议的类型约束。</p>
<p><a name="type_constraints_in_action"></a></p>
<h3 id="类型约束实践">类型约束实践</h3><p>这里有个名为 <code>findStringIndex</code> 的非泛型函数，该函数的功能是在 <code>String</code> 值的数组中查找给定 <code>String</code> 值的索引。若查找到匹配的字符串，<code>findStringIndex(_:_:)</code> 函数返回该字符串在数组中的索引值，反之则返回 <code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">findStringIndex</span><span class="params">(array: [String], <span class="number">_</span> valueToFind: String)</span></span> -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> array.<span class="built_in">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> value == valueToFind &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>findStringIndex(_:_:)</code> 函数可以用于查找字符串数组中的某个字符串：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> strings = [<span class="string">"cat"</span>, <span class="string">"dog"</span>, <span class="string">"llama"</span>, <span class="string">"parakeet"</span>, <span class="string">"terrapin"</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> foundIndex = findStringIndex(strings, <span class="string">"llama"</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The index of llama is <span class="subst">\(foundIndex)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “The index of llama is 2”</span></span><br></pre></td></tr></table></figure>
<p>如果只能查找字符串在数组中的索引，用处不是很大。不过，你可以写出相同功能的泛型函数 <code>findIndex(_:_:)</code>，用占位类型 <code>T</code> 替换 <code>String</code> 类型。</p>
<p>下面展示了 <code>findStringIndex(_:_:)</code> 函数的泛型版本 <code>findIndex(_:_:)</code>。请注意这个函数仍然返回 <code>Int?</code>，那是因为函数返回的是一个可选的索引数，而不是从数组中得到的一个可选值。需要提醒的是，这个函数无法通过编译，原因在例子后面会说明：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">findIndex</span><span class="generics">&lt;T&gt;</span><span class="params">(array: [T], <span class="number">_</span> valueToFind: T)</span></span> -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> array.<span class="built_in">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> value == valueToFind &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面所写的函数无法通过编译。这个问题出在相等性检查上，即 <code>“if value == valueToFind”</code>。不是所有的 Swift 类型都可以用等式符（<code>==</code>）进行比较。例如，如果你创建一个你自己的类或结构体来表示一个复杂的数据模型，那么 Swift 无法猜到对于这个类或结构体而言“相等”意味着什么。正因如此，这部分代码无法保证适用于每个可能的类型 <code>T</code>，当你试图编译这部分代码时会出现相应的错误。</p>
<p>不过，所有的这些并不会让我们无从下手。Swift 标准库中定义了一个 <code>Equatable</code> 协议，该协议要求任何符合该协议的类型必须实现等式符（<code>==</code>），从而能对符合该协议的类型的任意两个值进行比较。所有的 Swift 标准类型自动支持 <code>Equatable</code> 协议。</p>
<p>任何 <code>Equatable</code> 类型都可以安全地使用在 <code>findIndex(_:_:)</code> 函数中，因为其保证支持等式操作符。为了说明这个事实，当你定义一个函数时，你可以定义一个 <code>Equatable</code> 类型约束作为类型参数定义的一部分：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">findIndex</span><span class="generics">&lt;T: Equatable&gt;</span><span class="params">(array: [T], <span class="number">_</span> valueToFind: T)</span></span> -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> array.<span class="built_in">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> value == valueToFind &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>findIndex(_:_:)</code> 中的这个单一类型参数写做 <code>T: Equatable</code>，也就意味着“任何符合 <code>Equatable</code> 协议的 <code>T</code> 类型”。</p>
<p><code>findIndex(_:_:)</code> 函数现在可以成功编译了，并且可以作用于任何符合 <code>Equatable</code> 的类型，如 <code>Double</code> 或 <code>String</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> doubleIndex = findIndex([<span class="number">3.14159</span>, <span class="number">0.1</span>, <span class="number">0.25</span>], <span class="number">9.3</span>)</span><br><span class="line"><span class="comment">// doubleIndex 类型为 Int?，其值为 nil，因为 9.3 不在数组中</span></span><br><span class="line"><span class="keyword">let</span> stringIndex = findIndex([<span class="string">"Mike"</span>, <span class="string">"Malcolm"</span>, <span class="string">"Andrea"</span>], <span class="string">"Andrea"</span>)</span><br><span class="line"><span class="comment">// stringIndex 类型为 Int?，其值为 2</span></span><br></pre></td></tr></table></figure>
<p><a name="associated_types"></a></p>
<h2 id="关联类型">关联类型</h2><p>定义一个协议时，有的时候声明一个或多个关联类型作为协议定义的一部分将会非常有用。关联类型作为协议的一部分，为某个类型提供了一个占位名（或者说别名），其代表的实际类型在协议被采纳时才会被指定。你可以通过 <code>typealias</code> 关键字来指定关联类型。</p>
<p><a name="associated_types_in_action"></a></p>
<h3 id="关联类型实践">关联类型实践</h3><p>下面例子定义了一个 <code>Container</code> 协议，该协议定义了一个关联类型 <code>ItemType</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">ItemType</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">append</span><span class="params">(item: ItemType)</span></span></span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">ItemType</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Container</code> 协议定义了三个任何采纳协议的类型必须提供的功能：</p>
<ul>
<li>必须可以通过 <code>append(_:)</code> 方法添加一个新元素到容器里。</li>
<li>必须可以通过 <code>count</code> 属性获取容器中元素的数量，并返回一个 <code>Int</code> 值。</li>
<li>必须可以通过接受 <code>Int</code> 索引值的下标检索到每一个元素。</li>
</ul>
<p>这个协议没有指定容器中元素该如何存储，以及元素必须是何种类型。这个协议只指定了三个任何采纳 <code>Container</code> 协议的类型必须提供的功能。采纳协议的类型在满足这三个条件的情况下也可以提供其他额外的功能。</p>
<p>任何采纳 <code>Container</code> 协议的类型必须能够指定其存储的元素的类型，必须保证只有正确类型的元素可以加进容器中，必须明确通过其下标返回的元素的类型。</p>
<p>为了定义这三个条件，<code>Container</code> 协议需要在不知道容器中元素的具体类型的情况下引用这种类型。<code>Container</code> 协议需要指定任何通过 <code>append(_:)</code> 方法添加到容器中的元素和容器中的元素是相同类型，并且通过容器下标返回的元素的类型也是这种类型。</p>
<p>为了达到此目的，<code>Container</code> 协议声明了一个关联类型 <code>ItemType</code>，写作 <code>typealias ItemType</code>。这个协议无法定义 <code>ItemType</code> 是什么类型的别名，这个信息将留给采纳协议的类型来提供。尽管如此，<code>ItemType</code> 别名提供了一种方式来引用 <code>Container</code> 中元素的类型，并将之用于 <code>append(_:)</code> 方法和下标，从而保证任何 <code>Container</code> 的预期行为都能够被执行。</p>
<p>下面是先前的非泛型的 <code>IntStack</code> 类型，这一版本采纳并符合了 <code>Container</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IntStack</span>: <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="comment">// IntStack 的原始实现部分</span></span><br><span class="line">    <span class="keyword">var</span> items = [<span class="type">Int</span>]()</span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">push</span><span class="params">(item: Int)</span></span> &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Container 协议的实现部分</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">ItemType</span> = <span class="type">Int</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">append</span><span class="params">(item: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>IntStack</code> 结构体实现了 <code>Container</code> 协议的三个要求，其原有功能也不会和这些要求相冲突。</p>
<p>此外，<code>IntStack</code> 指定 <code>ItemType</code> 为 <code>Int</code> 类型，即 <code>typealias ItemType = Int</code>，从而将 <code>Container</code> 协议中抽象的 <code>ItemType</code> 类型转换为具体的 <code>Int</code> 类型。</p>
<p>由于 Swift 的类型推断，你实际上不用在 <code>IntStack</code> 的定义中声明 <code>ItemType</code> 为 <code>Int</code>。因为 <code>IntStack</code> 符合 <code>Container</code> 协议的所有要求，Swift 只需通过 <code>append(_:)</code> 方法的 <code>item</code> 参数类型和下标返回值的类型，就可以推断出 <code>ItemType</code> 的具体类型。事实上，如果你在上面的代码中删除了 <code>typealias ItemType = Int</code> 这一行，这一切仍旧可以正常工作，因为 Swift 清楚地知道 <code>ItemType</code> 应该是何种类型。</p>
<p>你也可以令泛型 <code>Stack</code> 结构体符合 <code>Container</code> 协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&lt;<span class="title">Element</span>&gt;: <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Stack&lt;Element&gt; 的原始实现部分</span></span><br><span class="line">    <span class="keyword">var</span> items = [<span class="type">Element</span>]()</span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">push</span><span class="params">(item: Element)</span></span> &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Container 协议的实现部分</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">append</span><span class="params">(item: Element)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> items[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一次，占位类型参数 <code>Element</code> 被用作 <code>append(_:)</code> 方法的 <code>item</code> 参数和下标的返回类型。Swift 可以据此推断出 <code>Element</code> 的类型即是 <code>ItemType</code> 的类型。</p>
<p><a name="extending_an_existing_type_to_specify_an_associated_type"></a></p>
<h3 id="通过扩展一个存在的类型来指定关联类型">通过扩展一个存在的类型来指定关联类型</h3><p><a href="./22_Protocols.html#adding_protocol_conformance_with_an_extension">通过扩展添加协议一致性</a>中描述了如何利用扩展让一个已存在的类型符合一个协议，这包括使用了关联类型的协议。</p>
<p>Swift 的 <code>Array</code> 已经提供 <code>append(_:)</code> 方法，一个 <code>count</code> 属性，以及一个接受 <code>Int</code> 型索引值的可用来检索数组元素的下标。这三个功能都符合 <code>Container</code> 协议的要求，也就意味着你可以扩展 <code>Array</code> 去符合 <code>Container</code> 协议，只需简单地声明 <code>Array</code> 采纳该协议即可。你可以通过一个空扩展来实现这点，正如<a href="./22_Protocols.html#declaring_protocol_adoption_with_an_extension">通过扩展采纳协议</a>中的描述：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span>: <span class="title">Container</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如同上面的泛型 <code>Stack</code> 结构体一样，<code>Array</code> 的 <code>append(_:)</code> 方法和下标确保了 Swift 可以推断出 <code>ItemType</code> 的类型。定义了这个扩展后，你可以将任意 <code>Array</code> 当作 <code>Container</code> 来使用。</p>
<p><a name="where_clauses"></a></p>
<h2 id="Where_子句">Where 子句</h2><p><a href="#type_constraints">类型约束</a>让你能够为泛型函数或泛型类型的类型参数定义一些强制要求。</p>
<p>为关联类型定义约束也是非常有用的。你可以在参数列表中通过 <code>where</code> 子句为关联类型定义约束。一个 <code>where</code> 子句能够使一个关联类型符合某个特定的协议，以及某个特定的类型参数和关联类型必须类型相同。你可以通过将 <code>where</code> 关键字紧跟在类型参数列表后面来定义 <code>where</code> 子句，<code>where</code> 子句后跟一个或者多个针对关联类型的约束，以及一个或多个类型参数和关联类型间的相等关系。</p>
<p>下面的例子定义了一个名为 <code>allItemsMatch</code> 的泛型函数，用来检查两个 <code>Container</code> 实例是否包含相同顺序的相同元素。如果所有的元素能够匹配，那么返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p>被检查的两个 <code>Container</code> 可以不是相同类型的容器（虽然它们可以相同），但它们必须拥有相同类型的元素。这个要求通过一个类型约束以及一个 <code>where</code> 子句来表示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">allItemsMatch</span><span class="generics">&lt;</span><br><span class="line">    C1: Container, C2: Container</span><br><span class="line">    where C1.ItemType == C2.ItemType, C1.ItemType: Equatable&gt;</span></span><br><span class="line">    <span class="params">(someContainer: C1, <span class="number">_</span> anotherContainer: C2)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查两个容器含有相同数量的元素</span></span><br><span class="line">        <span class="keyword">if</span> someContainer.<span class="built_in">count</span> != anotherContainer.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查每一对元素是否相等</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;someContainer.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> someContainer[i] != anotherContainer[i] &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所有元素都匹配，返回 true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数接受 <code>someContainer</code> 和 <code>anotherContainer</code> 两个参数。参数 <code>someContainer</code> 的类型为 <code>C1</code>，参数 <code>anotherContainer</code> 的类型为 <code>C2</code>。<code>C1</code> 和 <code>C2</code> 是容器的两个占位类型参数，函数被调用时才能确定它们的具体类型。</p>
<p>这个函数的类型参数列表还定义了两个类型参数的要求：</p>
<ul>
<li><code>C1</code> 必须符合 <code>Container</code> 协议（写作 <code>C1: Container</code>）。</li>
<li><code>C2</code> 必须符合 <code>Container</code> 协议（写作 <code>C2: Container</code>）。</li>
<li><code>C1</code> 的 <code>ItemType</code> 必须和 <code>C2</code> 的 <code>ItemType</code>类型相同（写作 <code>C1.ItemType == C2.ItemType</code>）。</li>
<li><code>C1</code> 的 <code>ItemType</code> 必须符合 <code>Equatable</code> 协议（写作 <code>C1.ItemType: Equatable</code>）。</li>
</ul>
<p>第三个和第四个要求被定义为一个 <code>where</code> 子句，写在关键字 <code>where</code> 后面，它们也是泛型函数类型参数列表的一部分。</p>
<p>这些要求意味着：</p>
<ul>
<li><code>someContainer</code> 是一个 <code>C1</code> 类型的容器。</li>
<li><code>anotherContainer</code> 是一个 <code>C2</code> 类型的容器。</li>
<li><code>someContainer</code> 和 <code>anotherContainer</code> 包含相同类型的元素。</li>
<li><code>someContainer</code> 中的元素可以通过不等于操作符（<code>!=</code>）来检查它们是否彼此不同。</li>
</ul>
<p>第三个和第四个要求结合起来意味着 <code>anotherContainer</code> 中的元素也可以通过 <code>!=</code> 操作符来比较，因为它们和 <code>someContainer</code> 中的元素类型相同。</p>
<p>这些要求让 <code>allItemsMatch(_:_:)</code> 函数能够比较两个容器，即使它们是不同的容器类型。</p>
<p><code>allItemsMatch(_:_:)</code> 函数首先检查两个容器是否拥有相同数量的元素，如果它们的元素数量不同，那么一定不匹配，函数就会返回 <code>false</code>。</p>
<p>进行这项检查之后，通过 <code>for-in</code> 循环和半闭区间操作符（<code>..&lt;</code>）来迭代每个元素，检查 <code>someContainer</code> 中的元素是否不等于 <code>anotherContainer</code> 中的对应元素。如果两个元素不相等，那么两个容器不匹配，函数返回 <code>false</code>。</p>
<p>如果循环体结束后未发现任何不匹配的情况，表明两个容器匹配，函数返回 <code>true</code>。</p>
<p>下面演示了 <code>allItemsMatch(_:_:)</code> 函数的使用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stackOfStrings = <span class="type">Stack</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">stackOfStrings.push(<span class="string">"uno"</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">"dos"</span>)</span><br><span class="line">stackOfStrings.push(<span class="string">"tres"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arrayOfStrings = [<span class="string">"uno"</span>, <span class="string">"dos"</span>, <span class="string">"tres"</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> allItemsMatch(stackOfStrings, arrayOfStrings) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"All items match."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Not all items match."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “All items match.”</span></span><br></pre></td></tr></table></figure>
<p>上面的例子创建一个 <code>Stack</code> 实例来存储一些 <code>String</code> 值，然后将三个字符串压入栈中。这个例子还通过数组字面量创建了一个 <code>Array</code> 实例，数组中包含三个同栈中一样的字符串。即使栈和数组是不同的类型，但它们都符合 <code>Container</code> 协议，而且它们都包含相同类型的值。因此你可以用这两个容器作为参数来调用 <code>allItemsMatch(_:_:)</code> 函数。在上面的例子中，<code>allItemsMatch(_:_:)</code> 函数正确地显示了这两个容器中的所有元素都是相互匹配的。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/24_Access_Control/" itemprop="url">
                第二章-24访问控制（Access Control）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:03+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/24_Access_Control/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/24_Access_Control/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="访问控制（Access_Control）">访问控制（Access Control）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="http://www.devtalking.com/" target="_blank" rel="external">JaceFu</a><br>校对：<a href="http://childhood.logdown.com" target="_blank" rel="external">ChildhoodAndy</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/mmoaay" target="_blank" rel="external">mmoaay</a></p>
<p>2.1<br>翻译：<a href="https://github.com/futantan" target="_blank" rel="external">Prayer</a><br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a>，2015-11-01</p>
</blockquote>
<p>本页内容包括：</p>
<ul>
<li><a href="#modules_and_source_files">模块和源文件</a></li>
<li><a href="#access_levels">访问级别</a><ul>
<li><a href="#guiding_principle_of_access_levels">访问级别基本原则</a></li>
<li><a href="#default_access_levels">默认访问级别</a></li>
<li><a href="#access_levels_for_single-target_apps">单 target 应用程序的访问级别</a></li>
<li><a href="#access_levels_for_frameworks">框架的访问级别</a></li>
<li><a href="#access_levels_for_unit_test_targets">单元测试 target 的访问级别</a></li>
</ul>
</li>
<li><a href="#access_control_syntax">访问控制语法</a></li>
<li><a href="#custom_types">自定义类型</a><ul>
<li><a href="#tuple_types">元组类型</a></li>
<li><a href="#function_types">函数类型</a></li>
<li><a href="#enumeration_types">枚举类型</a></li>
<li><a href="#nested_types">嵌套类型</a></li>
</ul>
</li>
<li><a href="#subclassing">子类</a></li>
<li><a href="#constants_variables_properties_subscripts">常量、变量、属性、下标</a><ul>
<li><a href="#getters_and_setters">Getter和Setter</a></li>
</ul>
</li>
<li><a href="#initializers">构造器</a><ul>
<li><a href="#default_initializers">默认构造器</a></li>
<li><a href="#default_memberwise_initializers_for_structure_types">结构体默认的成员逐一构造器</a></li>
</ul>
</li>
<li><a href="#protocols">协议</a><ul>
<li><a href="#protocol_inheritance">协议继承</a></li>
<li><a href="#protocol_conformance">协议一致性</a></li>
</ul>
</li>
<li><a href="#extensions">扩展</a><ul>
<li><a href="#adding_protocol_conformance_with_an_extension">通过扩展添加协议一致性</a></li>
</ul>
</li>
<li><a href="#generics">泛型</a></li>
<li><a href="#type_aliases">类型别名</a></li>
</ul>
<p>访问控制可以限定其他源文件或模块中的代码对你的代码的访问级别。这个特性可以让我们隐藏代码的一些实现细节，并且可以为其他人可以访问和使用的代码提供接口。</p>
<p>你可以明确地给单个类型（类、结构体、枚举）设置访问级别，也可以给这些类型的属性、方法、构造器、下标等设置访问级别。协议也可以被限定在一定的范围内使用，包括协议里的全局常量、变量和函数。</p>
<p>Swift 不仅提供了多种不同的访问级别，还为某些典型场景提供了默认的访问级别，这样就不需要我们在每段代码中都申明显式访问级别。其实，如果只是开发一个单一 target 的应用程序，我们完全可以不用显式申明代码的访问级别。</p>
<blockquote>
<p>注意<br>为了简单起见，对于代码中可以设置访问级别的特性（属性、基本类型、函数等），在下面的章节中我们会称之为“实体”。</p>
</blockquote>
<p><a name="modules_and_source_files"></a></p>
<h2 id="模块和源文件">模块和源文件</h2><p>Swift 中的访问控制模型基于模块和源文件这两个概念。</p>
<p>模块指的是独立的代码单元，框架或应用程序会作为一个独立的模块来构建和发布。在 Swift 中，一个模块可以使用 <code>import</code> 关键字导入另外一个模块。</p>
<p>在 Swift 中，Xcode 的每个 target（例如框架或应用程序）都被当作独立的模块处理。如果你是为了实现某个通用的功能，或者是为了封装一些常用方法而将代码打包成独立的框架，这个框架就是 Swift 中的一个模块。当它被导入到某个应用程序或者其他框架时，框架内容都将属于这个独立的模块。  </p>
<p>源文件就是 Swift 中的源代码文件，它通常属于一个模块，即一个应用程序或者框架。尽管我们一般会将不同的类型分别定义在不同的源文件中，但是同一个源文件也可以包含多个类型、函数之类的定义。</p>
<p><a name="access_levels"></a></p>
<h2 id="访问级别">访问级别</h2><p>Swift 为代码中的实体提供了三种不同的访问级别。这些访问级别不仅与源文件中定义的实体相关，同时也与源文件所属的模块相关。</p>
<ul>
<li><code>public</code>：可以访问同一模块源文件中的任何实体，在模块外也可以通过导入该模块来访问源文件里的所有实体。通常情况下，框架中的某个接口可以被任何人使用时，你可以将其设置为 <code>public</code> 级别。</li>
<li><code>internal</code>：可以访问同一模块源文件中的任何实体，但是不能从模块外访问该模块源文件中的实体。通常情况下，某个接口只在应用程序或框架内部使用时，你可以将其设置为 <code>internal</code> 级别。</li>
<li><code>private</code>：限制实体只能在所在的源文件内部使用。使用 <code>private</code> 级别可以隐藏某些功能的实现细节。</li>
</ul>
<p><code>public</code> 为最高（限制最少）访问级别，<code>private</code> 为最低（限制最多）访问级别。</p>
<blockquote>
<p>注意<br>Swift 中的 <code>private</code> 访问级别不同于其他语言，它的范围限于源文件，而不是声明范围内。这就意味着，一个类型可以访问其所在源文件中的所有 <code>private</code> 实体，但是如果它的扩展定义在其他源文件中，那么它的扩展就不能访问它在这个源文件中定义的 <code>private</code> 实体。</p>
</blockquote>
<p><a name="guiding_principle_of_access_levels"></a></p>
<h3 id="访问级别基本原则">访问级别基本原则</h3><p>Swift 中的访问级别遵循一个基本原则：不可以在某个实体中定义访问级别更高的实体。</p>
<p>例如：</p>
<ul>
<li>一个 <code>public</code> 访问级别的变量，其类型的访问级别不能是 <code>internal</code> 或 <code>private</code>。因为无法保证变量的类型在使用变量的地方也具有访问权限。</li>
<li>函数的访问级别不能高于它的参数类型和返回类型的访问级别。因为如果函数定义为 <code>public</code> 而参数类型或者返回类型定义为 <code>internal</code> 或 <code>private</code>，就会出现函数可以在任何地方被访问，但是它的参数类型和返回类型却不可以。</li>
</ul>
<p><a name="default_access_levels"></a></p>
<h3 id="默认访问级别">默认访问级别</h3><p>如果你不为代码中的实体显式指定访问级别，那么它们默认为 <code>internal</code> 级别（有一些例外情况，稍后会进行说明）。因此，在大多数情况下，我们不需要显式指定实体的访问级别。</p>
<p><a name="access_levels_for_single-target_apps"></a></p>
<h3 id="单_target_应用程序的访问级别">单 target 应用程序的访问级别</h3><p>当你编写一个单 target 应用程序时，应用的所有功能都是为该应用服务，而不需要提供给其他应用或者模块使用，所以我们不需要明确设置访问级别，使用默认的访问级别 <code>internal</code> 即可。但是，你也可以使用 <code>private</code> 级别，用于隐藏一些功能的实现细节。</p>
<p><a name="access_levels_for_frameworks"></a></p>
<h3 id="框架的访问级别">框架的访问级别</h3><p>当你开发框架时，就需要把一些对外的接口定义为 <code>public</code> 级别，以便使用者导入该框架后可以正常使用其功能。这些被你定义为 <code>public</code> 的接口，就是这个框架的 API。</p>
<blockquote>
<p>注意<br>框架依然会使用默认的 <code>internal</code> 级别，也可以指定为 <code>private</code> 级别。当你想把某个实体作为框架的 API 的时候，需显式为其指定 <code>public</code> 级别。</p>
</blockquote>
<p><a name="access_levels_for_unit_test_targets"></a></p>
<h3 id="单元测试_target_的访问级别">单元测试 target 的访问级别</h3><p>当你的应用程序包含单元测试 target 时，为了测试，测试模块需要访问应用程序模块中的代码。默认情况下只有 <code>public</code> 级别的实体才可以被其他模块访问。然而，如果在导入应用程序模块的语句前使用 <code>@testable</code> 特性，然后在允许测试的编译设置（<code>Build Options -&gt; Enable Testability</code>）下编译这个应用程序模块，单元测试 target 就可以访问应用程序模块中所有 <code>internal</code> 级别的实体。</p>
<p><a name="access_control_syntax"></a></p>
<h2 id="访问控制语法">访问控制语法</h2><p>通过修饰符 <code>public</code>、<code>internal</code>、<code>private</code> 来声明实体的访问级别：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SomePublicClass</span> </span>&#123;&#125;</span><br><span class="line">internal <span class="class"><span class="keyword">class</span> <span class="title">SomeInternalClass</span> </span>&#123;&#125;</span><br><span class="line">private <span class="class"><span class="keyword">class</span> <span class="title">SomePrivateClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">var</span> somePublicVariable = <span class="number">0</span></span><br><span class="line">internal <span class="keyword">let</span> someInternalConstant = <span class="number">0</span></span><br><span class="line">private <span class="func"><span class="keyword">func</span> <span class="title">somePrivateFunction</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>除非专门指定，否则实体默认的访问级别为 <code>internal</code>，可以查阅<a href="#default_access_levels">默认访问级别</a>这一节。这意味着在不使用修饰符显式声明访问级别的情况下，<code>SomeInternalClass</code> 和 <code>someInternalConstant</code> 仍然拥有隐式的访问级别 <code>internal</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeInternalClass</span> </span>&#123;&#125;   <span class="comment">// 隐式访问级别 internal</span></span><br><span class="line"><span class="keyword">var</span> someInternalConstant = <span class="number">0</span> <span class="comment">// 隐式访问级别 internal</span></span><br></pre></td></tr></table></figure>
<p><a name="custom_types"></a></p>
<h2 id="自定义类型">自定义类型</h2><p>如果想为一个自定义类型指定访问级别，在定义类型时进行指定即可。新类型只能在它的访问级别限制范围内使用。例如，你定义了一个 <code>private</code> 级别的类，那这个类就只能在定义它的源文件中使用，可以作为属性类型、函数参数类型或者返回类型，等等。</p>
<p>一个类型的访问级别也会影响到类型成员（属性、方法、构造器、下标）的默认访问级别。如果你将类型指定为 <code>private</code> 级别，那么该类型的所有成员的默认访问级别也会变成 <code>private</code>。如果你将类型指定为 <code>public</code> 或者 <code>internal</code> 级别（或者不明确指定访问级别，而使用默认的 <code>internal</code> 访问级别），那么该类型的所有成员的默认访问级别将是 <code>internal</code>。</p>
<blockquote>
<p>注意<br>上面提到，一个 <code>public</code> 类型的所有成员的访问级别默认为 <code>internal</code> 级别，而不是 <code>public</code> 级别。如果你想将某个成员指定为 <code>public</code> 级别，那么你必须显式指定。这样做的好处是，在你定义公共接口的时候，可以明确地选择哪些接口是需要公开的，哪些是内部使用的，避免不小心将内部使用的接口公开。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SomePublicClass</span> </span>&#123;          <span class="comment">// 显式的 public 类</span></span><br><span class="line">   	public <span class="keyword">var</span> somePublicProperty = <span class="number">0</span>   <span class="comment">// 显式的 public 类成员</span></span><br><span class="line">   	<span class="keyword">var</span> someInternalProperty = <span class="number">0</span>        <span class="comment">// 隐式的 internal 类成员</span></span><br><span class="line">   	private <span class="func"><span class="keyword">func</span> <span class="title">somePrivateMethod</span><span class="params">()</span></span> &#123;&#125; <span class="comment">// 显式的 private 类成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeInternalClass</span> </span>&#123;               <span class="comment">// 隐式的 internal 类</span></span><br><span class="line">   	<span class="keyword">var</span> someInternalProperty = <span class="number">0</span>        <span class="comment">// 隐式的 internal 类成员</span></span><br><span class="line">   	private <span class="func"><span class="keyword">func</span> <span class="title">somePrivateMethod</span><span class="params">()</span></span> &#123;&#125; <span class="comment">// 显式的 private 类成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private <span class="class"><span class="keyword">class</span> <span class="title">SomePrivateClass</span> </span>&#123;        <span class="comment">// 显式的 private 类</span></span><br><span class="line">   	<span class="keyword">var</span> somePrivateProperty = <span class="number">0</span>         <span class="comment">// 隐式的 private 类成员</span></span><br><span class="line">   	<span class="func"><span class="keyword">func</span> <span class="title">somePrivateMethod</span><span class="params">()</span></span> &#123;&#125;         <span class="comment">// 隐式的 private 类成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="tuple_types"></a></p>
<h3 id="元组类型">元组类型</h3><p>元组的访问级别将由元组中访问级别最严格的类型来决定。例如，如果你构建了一个包含两种不同类型的元组，其中一个类型为 <code>internal</code> 级别，另一个类型为 <code>private</code> 级别，那么这个元组的访问级别为 <code>private</code>。</p>
<blockquote>
<p>注意<br>元组不同于类、结构体、枚举、函数那样有单独的定义。元组的访问级别是在它被使用时自动推断出的，而无法明确指定。</p>
</blockquote>
<p><a name="function_types"></a></p>
<h3 id="函数类型">函数类型</h3><p>函数的访问级别根据访问级别最严格的参数类型或返回类型的访问级别来决定。但是，如果这种访问级别不符合函数定义所在环境的默认访问级别，那么就需要明确地指定该函数的访问级别。</p>
<p>下面的例子定义了一个名为 <code>someFunction</code> 的全局函数，并且没有明确地指定其访问级别。也许你会认为该函数应该拥有默认的访问级别 <code>internal</code>，但事实并非如此。事实上，如果按下面这种写法，代码将无法通过编译：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">()</span></span> -&gt; (<span class="type">SomeInternalClass</span>, <span class="type">SomePrivateClass</span>) &#123;</span><br><span class="line">   	<span class="comment">// 此处是函数实现部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，这个函数的返回类型是一个元组，该元组中包含两个自定义的类（可查阅<a href="#custom_types">自定义类型</a>）。其中一个类的访问级别是 <code>internal</code>，另一个的访问级别是 <code>private</code>，所以根据元组访问级别的原则，该元组的访问级别是 <code>private</code>（元组的访问级别与元组中访问级别最低的类型一致）。</p>
<p>因为该函数返回类型的访问级别是 <code>private</code>，所以你必须使用 <code>private</code> 修饰符，明确指定该函数的访问级别：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private <span class="func"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">()</span></span> -&gt; (<span class="type">SomeInternalClass</span>, <span class="type">SomePrivateClass</span>) &#123;</span><br><span class="line">   	<span class="comment">// 此处是函数实现部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将该函数指定为 <code>public</code> 或 <code>internal</code>，或者使用默认的访问级别 <code>internal</code> 都是错误的，因为如果把该函数当做 <code>public</code> 或 <code>internal</code> 级别来使用的话，可能会无法访问 <code>private</code> 级别的返回值。</p>
<p><a name="enumeration_types"></a></p>
<h3 id="枚举类型">枚举类型</h3><p>枚举成员的访问级别和该枚举类型相同，你不能为枚举成员单独指定不同的访问级别。</p>
<p>比如下面的例子，枚举 <code>CompassPoint</code> 被明确指定为 <code>public</code> 级别，那么它的成员 <code>North</code>、<code>South</code>、<code>East</code>、<code>West</code> 的访问级别同样也是 <code>public</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">enum</span> <span class="title">CompassPoint</span> </span>&#123;</span><br><span class="line">   	<span class="keyword">case</span> <span class="type">North</span></span><br><span class="line">   	<span class="keyword">case</span> <span class="type">South</span></span><br><span class="line">   	<span class="keyword">case</span> <span class="type">East</span></span><br><span class="line">   	<span class="keyword">case</span> <span class="type">West</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="raw_values_and_associated_values"></a></p>
<h4 id="原始值和关联值">原始值和关联值</h4><p>枚举定义中的任何原始值或关联值的类型的访问级别至少不能低于枚举类型的访问级别。例如，你不能在一个 <code>internal</code> 访问级别的枚举中定义 <code>private</code> 级别的原始值类型。</p>
<p><a name="nested_types"></a></p>
<h3 id="嵌套类型">嵌套类型</h3><p>如果在 <code>private</code> 级别的类型中定义嵌套类型，那么该嵌套类型就自动拥有 <code>private</code> 访问级别。如果在 <code>public</code> 或者 <code>internal</code> 级别的类型中定义嵌套类型，那么该嵌套类型自动拥有 <code>internal</code> 访问级别。如果想让嵌套类型拥有 <code>public</code> 访问级别，那么需要明确指定该嵌套类型的访问级别。</p>
<p><a name="subclassing"></a></p>
<h2 id="子类">子类</h2><p>子类的访问级别不得高于父类的访问级别。例如，父类的访问级别是 <code>internal</code>，子类的访问级别就不能是 <code>public</code>。</p>
<p>此外，你可以在符合当前访问级别的条件下重写任意类成员（方法、属性、构造器、下标等）。</p>
<p>可以通过重写为继承来的类成员提供更高的访问级别。下面的例子中，类 <code>A</code> 的访问级别是 <code>public</code>，它包含一个方法 <code>someMethod()</code>，访问级别为 <code>private</code>。类 <code>B</code> 继承自类 <code>A</code>，访问级别为 <code>internal</code>，但是在类 <code>B</code> 中重写了类 <code>A</code> 中访问级别为 <code>private</code> 的方法 <code>someMethod()</code>，并重新指定为 <code>internal</code> 级别。通过这种方式，我们就可以将某类中 <code>private</code> 级别的类成员重新指定为更高的访问级别，以便其他人使用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">   	private <span class="func"><span class="keyword">func</span> <span class="title">someMethod</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">internal <span class="class"><span class="keyword">class</span> <span class="title">B</span>: <span class="title">A</span> </span>&#123;</span><br><span class="line">   	<span class="keyword">override</span> internal <span class="func"><span class="keyword">func</span> <span class="title">someMethod</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们甚至可以在子类中，用子类成员去访问访问级别更低的父类成员，只要这一操作在相应访问级别的限制范围内（也就是说，在同一源文件中访问父类 <code>private</code> 级别的成员，在同一模块内访问父类 <code>internal</code> 级别的成员）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    private <span class="func"><span class="keyword">func</span> <span class="title">someMethod</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">internal <span class="class"><span class="keyword">class</span> <span class="title">B</span>: <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> internal <span class="func"><span class="keyword">func</span> <span class="title">someMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.someMethod()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为父类 <code>A</code> 和子类 <code>B</code> 定义在同一个源文件中，所以在子类 <code>B</code> 可以在重写的 <code>someMethod()</code> 方法中调用 <code>super.someMethod()</code>。</p>
<p><a name="constants_variables_properties_subscripts"></a></p>
<h2 id="常量、变量、属性、下标">常量、变量、属性、下标</h2><p>常量、变量、属性不能拥有比它们的类型更高的访问级别。例如，你不能定义一个 <code>public</code> 级别的属性，但是它的类型却是 <code>private</code> 级别的。同样，下标也不能拥有比索引类型或返回类型更高的访问级别。  </p>
<p>如果常量、变量、属性、下标的类型是 <code>private</code> 级别的，那么它们必须明确指定访问级别为 <code>private</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">var</span> privateInstance = <span class="type">SomePrivateClass</span>()</span><br></pre></td></tr></table></figure>
<p><a name="getters_and_setters"></a></p>
<h3 id="Getter_和_Setter">Getter 和 Setter</h3><p>常量、变量、属性、下标的 <code>Getters</code> 和 <code>Setters</code> 的访问级别和它们所属类型的访问级别相同。</p>
<p><code>Setter</code> 的访问级别可以低于对应的 <code>Getter</code> 的访问级别，这样就可以控制变量、属性或下标的读写权限。在 <code>var</code> 或 <code>subscript</code> 关键字之前，你可以通过 <code>private(set)</code> 或 <code>internal(set)</code> 为它们的写入权限指定更低的访问级别。</p>
<blockquote>
<p>注意<br>这个规则同时适用于存储型属性和计算型属性。即使你不明确指定存储型属性的 <code>Getter</code> 和 <code>Setter</code>，Swift 也会隐式地为其创建 <code>Getter</code> 和 <code>Setter</code>，用于访问该属性的后备存储。使用 <code>private(set)</code> 和 <code>internal(set)</code> 可以改变 <code>Setter</code> 的访问级别，这对计算型属性也同样适用。  </p>
</blockquote>
<p>下面的例子中定义了一个名为 <code>TrackedString</code> 的结构体，它记录了 <code>value</code> 属性被修改的次数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrackedString</span> </span>&#123;</span><br><span class="line">    private(<span class="keyword">set</span>) <span class="keyword">var</span> numberOfEdits = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> value: <span class="type">String</span> = <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            numberOfEdits++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TrackedString</code> 结构体定义了一个用于存储 <code>String</code> 值的属性 <code>value</code>，并将初始值设为 <code>&quot;&quot;</code>（一个空字符串）。该结构体还定义了另一个用于存储 <code>Int</code> 值的属性 <code>numberOfEdits</code>，它用于记录属性 <code>value</code> 被修改的次数。这个功能通过属性 <code>value</code> 的 <code>didSet</code> 观察器实现，每当给 <code>value</code> 赋新值时就会调用 <code>didSet</code> 方法，然后将 <code>numberOfEdits</code> 的值加一。</p>
<p>结构体 <code>TrackedString</code> 和它的属性 <code>value</code> 均没有显式指定访问级别，所以它们都拥有默认的访问级别 <code>internal</code>。但是该结构体的 <code>numberOfEdits</code> 属性使用了 <code>private(set)</code> 修饰符，这意味着 <code>numberOfEdits</code> 属性只能在定义该结构体的源文件中赋值。<code>numberOfEdits</code> 属性的 <code>Getter</code> 依然是默认的访问级别 <code>internal</code>，但是 <code>Setter</code> 的访问级别是 <code>private</code>，这表示该属性只有在当前的源文件中是可读写的，而在当前源文件所属的模块中只是一个可读的属性。  </p>
<p>如果你实例化 <code>TrackedString</code> 结构体，并多次对 <code>value</code> 属性的值进行修改，你就会看到 <code>numberOfEdits</code> 的值会随着修改次数而变化：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringToEdit = <span class="type">TrackedString</span>()</span><br><span class="line">stringToEdit.value = <span class="string">"This string will be tracked."</span></span><br><span class="line">stringToEdit.value += <span class="string">" This edit will increment numberOfEdits."</span></span><br><span class="line">stringToEdit.value += <span class="string">" So will this one."</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The number of edits is <span class="subst">\(stringToEdit.numberOfEdits)</span>"</span>)</span><br><span class="line"><span class="comment">// 打印 “The number of edits is 3”</span></span><br></pre></td></tr></table></figure>
<p>虽然你可以在其他的源文件中实例化该结构体并且获取到 <code>numberOfEdits</code> 属性的值，但是你不能对其进行赋值。这一限制保护了该记录功能的实现细节，同时还提供了方便的访问方式。</p>
<p>你可以在必要时为 <code>Getter</code> 和 <code>Setter</code> 显式指定访问级别。下面的例子将 <code>TrackedString</code> 结构体明确指定为了 <code>public</code> 访问级别。结构体的成员（包括 <code>numberOfEdits</code> 属性）拥有默认的访问级别 <code>internal</code>。你可以结合 <code>public</code> 和 <code>private(set)</code> 修饰符把结构体中的 <code>numberOfEdits</code> 属性的 <code>Getter</code> 的访问级别设置为 <code>public</code>，而 <code>Setter</code> 的访问级别设置为 <code>private</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">struct</span> <span class="title">TrackedString</span> </span>&#123;</span><br><span class="line">    public private(<span class="keyword">set</span>) <span class="keyword">var</span> numberOfEdits = <span class="number">0</span></span><br><span class="line">    public <span class="keyword">var</span> value: <span class="type">String</span> = <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            numberOfEdits++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="initializers"></a></p>
<h2 id="构造器">构造器</h2><p>自定义构造器的访问级别可以低于或等于其所属类型的访问级别。唯一的例外是<a href="./14_Initialization.html#required_initializers">必要构造器</a>，它的访问级别必须和所属类型的访问级别相同。</p>
<p>如同函数或方法的参数，构造器参数的访问级别也不能低于构造器本身的访问级别。</p>
<p><a name="default_initializers"></a></p>
<h3 id="默认构造器">默认构造器</h3><p>如<a href="./14_Initialization.html#default_initializers">默认构造器</a>所述，Swift 会为结构体和类提供一个默认的无参数的构造器，只要它们为所有存储型属性设置了默认初始值，并且未提供自定义的构造器。</p>
<p>默认构造器的访问级别与所属类型的访问级别相同，除非类型的访问级别是 <code>public</code>。如果一个类型被指定为 <code>public</code> 级别，那么默认构造器的访问级别将为 <code>internal</code>。如果你希望一个 <code>public</code> 级别的类型也能在其他模块中使用这种无参数的默认构造器，你只能自己提供一个 <code>public</code> 访问级别的无参数构造器。</p>
<p><a name="default_memberwise_initializers_for_structure_types"></a></p>
<h3 id="结构体默认的成员逐一构造器">结构体默认的成员逐一构造器</h3><p>如果结构体中任意存储型属性的访问级别为 <code>private</code>，那么该结构体默认的成员逐一构造器的访问级别就是 <code>private</code>。否则，这种构造器的访问级别依然是 <code>internal</code>。</p>
<p>如同前面提到的默认构造器，如果你希望一个 <code>public</code> 级别的结构体也能在其他模块中使用其默认的成员逐一构造器，你依然只能自己提供一个 <code>public</code> 访问级别的成员逐一构造器。</p>
<p><a name="protocols"></a></p>
<h2 id="协议">协议</h2><p>如果想为一个协议类型明确地指定访问级别，在定义协议时指定即可。这将限制该协议只能在适当的访问级别范围内被采纳。</p>
<p>协议中的每一个要求都具有和该协议相同的访问级别。你不能将协议中的要求设置为其他访问级别。这样才能确保该协议的所有要求对于任意采纳者都将可用。</p>
<blockquote>
<p>注意<br>如果你定义了一个 <code>public</code> 访问级别的协议，那么该协议的所有实现也会是 <code>public</code> 访问级别。这一点不同于其他类型，例如，当类型是 <code>public</code> 访问级别时，其成员的访问级别却只是 <code>internal</code>。</p>
</blockquote>
<p><a name="protocol_inheritance"></a></p>
<h3 id="协议继承">协议继承</h3><p>如果定义了一个继承自其他协议的新协议，那么新协议拥有的访问级别最高也只能和被继承协议的访问级别相同。例如，你不能将继承自 <code>internal</code> 协议的新协议定义为 <code>public</code> 协议。</p>
<p><a name="protocol_conformance"></a></p>
<h3 id="协议一致性">协议一致性</h3><p>一个类型可以采纳比自身访问级别低的协议。例如，你可以定义一个 <code>public</code> 级别的类型，它可以在其他模块中使用，同时它也可以采纳一个 <code>internal</code> 级别的协议，但是只能在该协议所在的模块中作为符合该协议的类型使用。</p>
<p>采纳了协议的类型的访问级别取它本身和所采纳协议两者间最低的访问级别。也就是说如果一个类型是 <code>public</code> 级别，采纳的协议是 <code>internal</code> 级别，那么采纳了这个协议后，该类型作为符合协议的类型时，其访问级别也是 <code>internal</code>。</p>
<p>如果你采纳了协议，那么实现了协议的所有要求后，你必须确保这些实现的访问级别不能低于协议的访问级别。例如，一个 <code>public</code> 级别的类型，采纳了 <code>internal</code> 级别的协议，那么协议的实现至少也得是 <code>internal</code> 级别。</p>
<blockquote>
<p>注意<br>Swift 和 Objective-C 一样，协议的一致性是全局的，也就是说，在同一程序中，一个类型不可能用两种不同的方式实现同一个协议。</p>
</blockquote>
<p><a name="extensions"></a></p>
<h2 id="扩展">扩展</h2><p>你可以在访问级别允许的情况下对类、结构体、枚举进行扩展。扩展成员具有和原始类型成员一致的访问级别。例如，你扩展了一个 <code>public</code> 或者 <code>internal</code> 类型，扩展中的成员具有默认的 <code>internal</code> 访问级别，和原始类型中的成员一致 。如果你扩展了一个 <code>private</code> 类型，扩展成员则拥有默认的 <code>private</code> 访问级别。</p>
<p>或者，你可以明确指定扩展的访问级别（例如，<code>private extension</code>），从而给该扩展中的所有成员指定一个新的默认访问级别。这个新的默认访问级别仍然可以被单独指定的访问级别所覆盖。</p>
<p><a name="adding_protocol_conformance_with_an_extension"></a></p>
<h3 id="通过扩展添加协议一致性">通过扩展添加协议一致性</h3><p>如果你通过扩展来采纳协议，那么你就不能显式指定该扩展的访问级别了。协议拥有相应的访问级别，并会为该扩展中所有协议要求的实现提供默认的访问级别。</p>
<p><a name="generics"></a></p>
<h2 id="泛型">泛型</h2><p>泛型类型或泛型函数的访问级别取决于泛型类型或泛型函数本身的访问级别，还需结合类型参数的类型约束的访问级别，根据这些访问级别中的最低访问级别来确定。</p>
<p><a name="type_aliases"></a></p>
<h2 id="类型别名">类型别名</h2><p>你定义的任何类型别名都会被当作不同的类型，以便于进行访问控制。类型别名的访问级别不可高于其表示的类型的访问级别。例如，<code>private</code> 级别的类型别名可以作为 <code>public</code>、<code>internal</code>、<code>private</code> 类型的别名，但是 <code>public</code> 级别的类型别名只能作为 <code>public</code> 类型的别名，不能作为 <code>internal</code> 或 <code>private</code> 类型的别名。</p>
<blockquote>
<p>注意<br>这条规则也适用于为满足协议一致性而将类型别名用于关联类型的情况。</p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/25_Advanced_Operators/" itemprop="url">
                第二章-25高级运算符（Advanced Operators）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:02+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/25_Advanced_Operators/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/25_Advanced_Operators/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="高级运算符（Advanced_Operators）">高级运算符（Advanced Operators）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/xielingwang" target="_blank" rel="external">xielingwang</a><br>校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/buginux" target="_blank" rel="external">buginux</a></p>
<p>2.1<br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a>，2015-11-01</p>
</blockquote>
<p>本页内容包括：</p>
<ul>
<li><a href="#bitwise_operators">位运算符</a></li>
<li><a href="#overflow_operators">溢出运算符</a></li>
<li><a href="#precedence_and_associativity">优先级和结合性</a></li>
<li><a href="#operator_functions">运算符函数</a></li>
<li><a href="#custom_operators">自定义运算符</a></li>
</ul>
<p>除了在之前介绍过的<a href="./02_Basic_Operators.html">基本运算符</a>，Swift 中还有许多可以对数值进行复杂运算的高级运算符。这些高级运算符包含了在 C 和 Objective-C 中已经被大家所熟知的位运算符和移位运算符。</p>
<p>与 C 语言中的算术运算符不同，Swift 中的算术运算符默认是不会溢出的。所有溢出行为都会被捕获并报告为错误。如果想让系统允许溢出行为，可以选择使用 Swift 中另一套默认支持溢出的运算符，比如溢出加法运算符（<code>&amp;+</code>）。所有的这些溢出运算符都是以 <code>&amp;</code> 开头的。</p>
<p>自定义结构体、类和枚举时，如果也为它们提供标准 Swift 运算符的实现，将会非常有用。在 Swift 中自定义运算符非常简单，运算符也会针对不同类型使用对应实现。</p>
<p>我们不用被预定义的运算符所限制。在 Swift 中可以自由地定义中缀、前缀、后缀和赋值运算符，以及相应的优先级与结合性。这些运算符在代码中可以像预定义的运算符一样使用，我们甚至可以扩展已有的类型以支持自定义的运算符。</p>
<p><a name="bitwise_operators"></a></p>
<h2 id="位运算符">位运算符</h2><p>位运算符可以操作数据结构中每个独立的比特位。它们通常被用在底层开发中，比如图形编程和创建设备驱动。位运算符在处理外部资源的原始数据时也十分有用，比如对自定义通信协议传输的数据进行编码和解码。</p>
<p>Swift 支持 C 语言中的全部位运算符，接下来会一一介绍。</p>
<p><a name="bitwise_not_operator"></a></p>
<h3 id="按位取反运算符">按位取反运算符</h3><p>按位取反运算符（<code>~</code>）可以对一个数值的全部比特位进行取反：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitwiseNOT_2x.png" alt="Art/bitwiseNOT_2x.png"></p>
<p>按位取反运算符是一个前缀运算符，需要直接放在运算的数之前，并且它们之间不能添加任何空格：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> initialBits: <span class="type">UInt8</span> = <span class="number">0b00001111</span></span><br><span class="line"><span class="keyword">let</span> invertedBits = ~initialBits <span class="comment">// 等于 0b11110000</span></span><br></pre></td></tr></table></figure>
<p><code>UInt8</code> 类型的整数有 8 个比特位，可以存储 <code>0 ~ 255</code> 之间的任意整数。这个例子初始化了一个 <code>UInt8</code> 类型的整数，并赋值为二进制的 <code>00001111</code>，它的前 4 位都为 <code>0</code>，后 4 位都为 <code>1</code>。这个值等价于十进制的 <code>15</code>。</p>
<p>接着使用按位取反运算符创建了一个名为 <code>invertedBits</code> 的常量，这个常量的值与全部位取反后的 <code>initialBits</code> 相等。即所有的 <code>0</code> 都变成了 <code>1</code>，同时所有的 <code>1</code> 都变成 <code>0</code>。<code>invertedBits</code> 的二进制值为 <code>11110000</code>，等价于无符号十进制数的 <code>240</code>。</p>
<p><a name="bitwise_and_operator"></a></p>
<h3 id="按位与运算符">按位与运算符</h3><p>按位与运算符（<code>&amp;</code>）可以对两个数的比特位进行合并。它返回一个新的数，只有当两个数的对应位都为 <code>1</code> 的时候，新数的对应位才为 <code>1</code>：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitwiseAND_2x.png" alt="Art/bitwiseAND_2x.png"></p>
<p>在下面的示例当中，<code>firstSixBits</code> 和 <code>lastSixBits</code> 中间 4 个位的值都为 <code>1</code>。按位与运算符对它们进行了运算，得到二进制数值 <code>00111100</code>，等价于无符号十进制数的 <code>60</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstSixBits: <span class="type">UInt8</span> = <span class="number">0b11111100</span></span><br><span class="line"><span class="keyword">let</span> lastSixBits: <span class="type">UInt8</span>  = <span class="number">0b00111111</span></span><br><span class="line"><span class="keyword">let</span> middleFourBits = firstSixBits &amp; lastSixBits <span class="comment">// 等于 00111100</span></span><br></pre></td></tr></table></figure>
<p><a name="bitwise_or_operator"></a></p>
<h3 id="按位或运算符">按位或运算符</h3><p>按位或运算符（<code>|</code>）可以对两个数的比特位进行比较。它返回一个新的数，只要两个数的对应位中有任意一个为 <code>1</code> 时，新数的对应位就为 <code>1</code>：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitwiseOR_2x.png" alt="Art/bitwiseOR_2x.png" title="Art/bitwiseOR_2x.png"></p>
<p>在下面的示例中，<code>someBits</code> 和 <code>moreBits</code> 不同的位会被设置为 <code>1</code>。接位或运算符对它们进行了运算，得到二进制数值 <code>11111110</code>，等价于无符号十进制数的 <code>254</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someBits: <span class="type">UInt8</span> = <span class="number">0b10110010</span></span><br><span class="line"><span class="keyword">let</span> moreBits: <span class="type">UInt8</span> = <span class="number">0b01011110</span></span><br><span class="line"><span class="keyword">let</span> combinedbits = someBits | moreBits <span class="comment">// 等于 11111110</span></span><br></pre></td></tr></table></figure>
<p><a name="bitwise_xor_operator"></a></p>
<h3 id="按位异或运算符">按位异或运算符</h3><p>按位异或运算符（<code>^</code>）可以对两个数的比特位进行比较。它返回一个新的数，当两个数的对应位不相同时，新数的对应位就为 <code>1</code>：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitwiseXOR_2x.png" alt="Art/bitwiseXOR_2x.png" title="Art/bitwiseXOR_2x.png"></p>
<p>在下面的示例当中，<code>firstBits</code> 和 <code>otherBits</code> 都有一个自己的位为 <code>1</code> 而对方的对应位为 <code>0</code> 的位。 按位异或运算符将新数的这两个位都设置为 <code>1</code>，同时将其它位都设置为 <code>0</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstBits: <span class="type">UInt8</span> = <span class="number">0b00010100</span></span><br><span class="line"><span class="keyword">let</span> otherBits: <span class="type">UInt8</span> = <span class="number">0b00000101</span></span><br><span class="line"><span class="keyword">let</span> outputBits = firstBits ^ otherBits <span class="comment">// 等于 00010001</span></span><br></pre></td></tr></table></figure>
<p><a name="bitwise_left_and_right_shift_operators"></a></p>
<h3 id="按位左移、右移运算符">按位左移、右移运算符</h3><p>按位左移运算符（<code>&lt;&lt;</code>）和按位右移运算符（<code>&gt;&gt;</code>）可以对一个数的所有位进行指定位数的左移和右移，但是需要遵守下面定义的规则。</p>
<p>对一个数进行按位左移或按位右移，相当于对这个数进行乘以 2 或除以 2 的运算。将一个整数左移一位，等价于将这个数乘以 2，同样地，将一个整数右移一位，等价于将这个数除以 2。</p>
<p><a name="shifting_behavior_for_unsigned_integers"></a></p>
<h4 id="无符号整数的移位运算">无符号整数的移位运算</h4><p>对无符号整数进行移位的规则如下：</p>
<ol>
<li>已经存在的位按指定的位数进行左移和右移。</li>
<li>任何因移动而超出整型存储范围的位都会被丢弃。</li>
<li>用 <code>0</code> 来填充移位后产生的空白位。</li>
</ol>
<p>这种方法称为逻辑移位。</p>
<p>以下这张图展示了 <code>11111111 &lt;&lt; 1</code>（即把 <code>11111111</code> 向左移动 <code>1</code> 位），和 <code>11111111 &gt;&gt; 1</code>（即把 <code>11111111</code> 向右移动 <code>1</code> 位）的结果。蓝色的部分是被移位的，灰色的部分是被抛弃的，橙色的部分则是被填充进来的：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftUnsigned_2x.png" alt="Art/bitshiftUnsigned_2x.png" title="Art/bitshiftUnsigned_2x.png"></p>
<p>下面的代码演示了 Swift 中的移位运算：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> shiftBits: <span class="type">UInt8</span> = <span class="number">4</span> <span class="comment">// 即二进制的 00000100</span></span><br><span class="line">shiftBits &lt;&lt; <span class="number">1</span>           <span class="comment">// 00001000</span></span><br><span class="line">shiftBits &lt;&lt; <span class="number">2</span>           <span class="comment">// 00010000</span></span><br><span class="line">shiftBits &lt;&lt; <span class="number">5</span>           <span class="comment">// 10000000</span></span><br><span class="line">shiftBits &lt;&lt; <span class="number">6</span>           <span class="comment">// 00000000</span></span><br><span class="line">shiftBits &gt;&gt; <span class="number">2</span>           <span class="comment">// 00000001</span></span><br></pre></td></tr></table></figure>
<p>可以使用移位运算对其他的数据类型进行编码和解码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pink: <span class="type">UInt32</span> = <span class="number">0xCC6699</span></span><br><span class="line"><span class="keyword">let</span> redComponent = (pink &amp; <span class="number">0xFF0000</span>) &gt;&gt; <span class="number">16</span>  <span class="comment">// redComponent 是 0xCC，即 204</span></span><br><span class="line"><span class="keyword">let</span> greenComponent = (pink &amp; <span class="number">0x00FF00</span>) &gt;&gt; <span class="number">8</span> <span class="comment">// greenComponent 是 0x66， 即 102</span></span><br><span class="line"><span class="keyword">let</span> blueComponent = pink &amp; <span class="number">0x0000FF</span>         <span class="comment">// blueComponent 是 0x99，即 153</span></span><br></pre></td></tr></table></figure>
<p>这个示例使用了一个命名为 <code>pink</code> 的 <code>UInt32</code> 型常量来存储 CSS 中粉色的颜色值。该 CSS 的十六进制颜色值 <code>#CC6699</code>，在 Swift 中表示为 <code>0xCC6699</code>。然后利用按位与运算符（<code>&amp;</code>）和按位右移运算符（<code>&gt;&gt;</code>）从这个颜色值中分解出红（<code>CC</code>）、绿（<code>66</code>）以及蓝（<code>99</code>）三个部分。</p>
<p>红色部分是通过对 <code>0xCC6699</code> 和 <code>0xFF0000</code> 进行按位与运算后得到的。<code>0xFF0000</code> 中的 <code>0</code> 部分“掩盖”了 <code>OxCC6699</code> 中的第二、第三个字节，使得数值中的 <code>6699</code> 被忽略，只留下 <code>0xCC0000</code>。</p>
<p>然后，再将这个数按向右移动 16 位（<code>&gt;&gt; 16</code>）。十六进制中每两个字符表示 8 个比特位，所以移动 16 位后 <code>0xCC0000</code> 就变为 <code>0x0000CC</code>。这个数和<code>0xCC</code>是等同的，也就是十进制数值的 <code>204</code>。</p>
<p>同样的，绿色部分通过对 <code>0xCC6699</code> 和 <code>0x00FF00</code> 进行按位与运算得到 <code>0x006600</code>。然后将这个数向右移动 8 位，得到 <code>0x66</code>，也就是十进制数值的 <code>102</code>。</p>
<p>最后，蓝色部分通过对 <code>0xCC6699</code> 和 <code>0x0000FF</code> 进行按位与运算得到 <code>0x000099</code>。这里不需要再向右移位，所以结果为 <code>0x99</code> ，也就是十进制数值的 <code>153</code>。</p>
<p><a name="shifting_behavior_for_signed_integers"></a></p>
<h4 id="有符号整数的移位运算">有符号整数的移位运算</h4><p>对比无符号整数，有符号整数的移位运算相对复杂得多，这种复杂性源于有符号整数的二进制表现形式。（为了简单起见，以下的示例都是基于 8 比特位的有符号整数的，但是其中的原理对任何位数的有符号整数都是通用的。）</p>
<p>有符号整数使用第 1 个比特位（通常被称为符号位）来表示这个数的正负。符号位为 <code>0</code> 代表正数，为 <code>1</code> 代表负数。</p>
<p>其余的比特位（通常被称为数值位）存储了实际的值。有符号正整数和无符号数的存储方式是一样的，都是从 <code>0</code> 开始算起。这是值为 <code>4</code> 的 <code>Int8</code> 型整数的二进制位表现形式：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftSignedFour_2x.png" alt="Art/bitshiftSignedFour_2x.png" title="Art/bitshiftSignedFour_2x.png"></p>
<p>符号位为 <code>0</code>，说明这是一个正数，另外 7 位则代表了十进制数值 <code>4</code> 的二进制表示。</p>
<p>负数的存储方式略有不同。它存储的值的绝对值等于 <code>2</code> 的 <code>n</code> 次方减去它的实际值（也就是数值位表示的值），这里的 <code>n</code> 为数值位的比特位数。一个 8 比特位的数有 7 个比特位是数值位，所以是 <code>2</code> 的 <code>7</code> 次方，即 <code>128</code>。</p>
<p>这是值为 <code>-4</code> 的 <code>Int8</code> 型整数的二进制位表现形式：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftSignedMinusFour_2x.png" alt="Art/bitshiftSignedMinusFour_2x.png" title="Art/bitshiftSignedMinusFour_2x.png"></p>
<p>这次的符号位为 <code>1</code>，说明这是一个负数，另外 7 个位则代表了数值 <code>124</code>（即 <code>128 - 4</code>）的二进制表示：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftSignedMinusFourValue_2x.png" alt="Art/bitshiftSignedMinusFourValue_2x.png" title="Art/bitshiftSignedMinusFourValue_2x.png"></p>
<p>负数的表示通常被称为二进制补码表示。用这种方法来表示负数乍看起来有点奇怪，但它有几个优点。</p>
<p>首先，如果想对 <code>-1</code> 和 <code>-4</code> 进行加法运算，我们只需要将这两个数的全部 8 个比特位进行相加，并且将计算结果中超出 8 位的数值丢弃：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftSignedAddition_2x.png" alt="Art/bitshiftSignedAddition_2x.png" title="Art/bitshiftSignedAddition_2x.png"></p>
<p>其次，使用二进制补码可以使负数的按位左移和右移运算得到跟正数同样的效果，即每向左移一位就将自身的数值乘以 2，每向右一位就将自身的数值除以 2。要达到此目的，对有符号整数的右移有一个额外的规则：</p>
<ul>
<li>当对正整数进行按位右移运算时，遵循与无符号整数相同的规则，但是对于移位产生的空白位使用符号位进行填充，而不是用 <code>0</code>。</li>
</ul>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftSigned_2x.png" alt="Art/bitshiftSigned_2x.png" title="Art/bitshiftSigned_2x.png"></p>
<p>这个行为可以确保有符号整数的符号位不会因为右移运算而改变，这通常被称为算术移位。</p>
<p>由于正数和负数的特殊存储方式，在对它们进行右移的时候，会使它们越来越接近 <code>0</code>。在移位的过程中保持符号位不变，意味着负整数在接近 <code>0</code> 的过程中会一直保持为负。</p>
<p><a name="overflow_operators"></a></p>
<h2 id="溢出运算符">溢出运算符</h2><p>在默认情况下，当向一个整数赋予超过它容量的值时，Swift 默认会报错，而不是生成一个无效的数。这个行为为我们在运算过大或着过小的数的时候提供了额外的安全性。</p>
<p>例如，<code>Int16</code> 型整数能容纳的有符号整数范围是 <code>-32768</code> 到 <code>32767</code>，当为一个 <code>Int16</code> 型变量赋的值超过这个范围时，系统就会报错：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> potentialOverflow = <span class="type">Int16</span>.<span class="built_in">max</span></span><br><span class="line"><span class="comment">// potentialOverflow 的值是 32767，这是 Int16 能容纳的最大整数</span></span><br><span class="line">potentialOverflow += <span class="number">1</span></span><br><span class="line"><span class="comment">// 这里会报错</span></span><br></pre></td></tr></table></figure>
<p>为过大或者过小的数值提供错误处理，能让我们在处理边界值时更加灵活。</p>
<p>然而，也可以选择让系统在数值溢出的时候采取截断处理，而非报错。可以使用 Swift 提供的三个溢出运算符来让系统支持整数溢出运算。这些运算符都是以 <code>&amp;</code> 开头的：</p>
<ul>
<li>溢出加法 <code>&amp;+</code></li>
<li>溢出减法 <code>&amp;-</code></li>
<li>溢出乘法 <code>&amp;*</code></li>
</ul>
<p><a name="value_overflow"></a></p>
<h3 id="数值溢出">数值溢出</h3><p>数值有可能出现上溢或者下溢。</p>
<p>这个示例演示了当我们对一个无符号整数使用溢出加法（<code>&amp;+</code>）进行上溢运算时会发生什么：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> unsignedOverflow = <span class="type">UInt8</span>.<span class="built_in">max</span></span><br><span class="line"><span class="comment">// unsignedOverflow 等于 UInt8 所能容纳的最大整数 255</span></span><br><span class="line">unsignedOverflow = unsignedOverflow &amp;+ <span class="number">1</span></span><br><span class="line"><span class="comment">// 此时 unsignedOverflow 等于 0</span></span><br></pre></td></tr></table></figure>
<p><code>unsignedOverflow</code> 被初始化为 <code>UInt8</code> 所能容纳的最大整数（<code>255</code>，以二进制表示即 <code>11111111</code>）。然后使用了溢出加法运算符（<code>&amp;+</code>）对其进行加 <code>1</code> 运算。这使得它的二进制表示正好超出 <code>UInt8</code> 所能容纳的位数，也就导致了数值的溢出，如下图所示。数值溢出后，留在 <code>UInt8</code> 边界内的值是 <code>00000000</code>，也就是十进制数值的 <code>0</code>。</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/overflowAddition_2x.png" alt="Art/overflowAddition_2x.png" title="Art/overflowAddition_2x.png"></p>
<p>同样地，当我们对一个无符号整数使用溢出减法（<code>&amp;-</code>）进行下溢运算时也会产生类似的现象：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> unsignedOverflow = <span class="type">UInt8</span>.<span class="built_in">min</span></span><br><span class="line"><span class="comment">// unsignedOverflow 等于 UInt8 所能容纳的最小整数 0</span></span><br><span class="line">unsignedOverflow = unsignedOverflow &amp;- <span class="number">1</span></span><br><span class="line"><span class="comment">// 此时 unsignedOverflow 等于 255</span></span><br></pre></td></tr></table></figure>
<p><code>UInt8</code> 型整数能容纳的最小值是 <code>0</code>，以二进制表示即 <code>00000000</code>。当使用溢出减法运算符对其进行减 <code>1</code> 运算时，数值会产生下溢并被截断为 <code>11111111</code>， 也就是十进制数值的 <code>255</code>。</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/overflowUnsignedSubtraction_2x.png" alt="Art/overflowUnsignedSubtraction_2x.png" title="Art/overflowAddition_2x.png"></p>
<p>溢出也会发生在有符号整型数值上。在对有符号整型数值进行溢出加法或溢出减法运算时，符号位也需要参与计算，正如<a href="#bitwise_left_and_right_shift_operators">按位左移、右移运算符</a>所描述的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> signedOverflow = <span class="type">Int8</span>.<span class="built_in">min</span></span><br><span class="line"><span class="comment">// signedOverflow 等于 Int8 所能容纳的最小整数 -128</span></span><br><span class="line">signedOverflow = signedOverflow &amp;- <span class="number">1</span></span><br><span class="line"><span class="comment">// 此时 signedOverflow 等于 127</span></span><br></pre></td></tr></table></figure>
<p><code>Int8</code> 型整数能容纳的最小值是 <code>-128</code>，以二进制表示即 <code>10000000</code>。当使用溢出减法运算符对其进行减 <code>1</code> 运算时，符号位被翻转，得到二进制数值 <code>01111111</code>，也就是十进制数值的 <code>127</code>，这个值也是 <code>Int8</code> 型整数所能容纳的最大值。</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/overflowSignedSubtraction_2x.png" alt="Art/overflowSignedSubtraction_2x.png" title="Art/overflowSignedSubtraction_2x.png"></p>
<p>对于无符号与有符号整型数值来说，当出现上溢时，它们会从数值所能容纳的最大数变成最小的数。同样地，当发生下溢时，它们会从所能容纳的最小数变成最大的数。</p>
<p><a name="precedence_and_associativity"></a></p>
<h2 id="优先级和结合性">优先级和结合性</h2><p>运算符的优先级使得一些运算符优先于其他运算符，高优先级的运算符会先被计算。</p>
<p>结合性定义了相同优先级的运算符是如何结合的，也就是说，是与左边结合为一组，还是与右边结合为一组。可以将这意思理解为“它们是与左边的表达式结合的”或者“它们是与右边的表达式结合的”。</p>
<p>在复合表达式的运算顺序中，运算符的优先级和结合性是非常重要的。举例来说，运算符优先级解释了为什么下面这个表达式的运算结果会是 <code>17</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> + <span class="number">3</span> % <span class="number">4</span> * <span class="number">5</span></span><br><span class="line"><span class="comment">// 结果是 17</span></span><br></pre></td></tr></table></figure>
<p>如果完全从左到右进行运算，则运算的过程是这样的：</p>
<ul>
<li>2 + 3 = 5</li>
<li>5 % 4 = 1</li>
<li>1 * 5 = 5</li>
</ul>
<p>但是正确答案是 <code>17</code> 而不是 <code>5</code>。优先级高的运算符要先于优先级低的运算符进行计算。与 C 语言类似，在 Swift 中，乘法运算符（<code>*</code>）与取余运算符（<code>%</code>）的优先级高于加法运算符（<code>+</code>）。因此，它们的计算顺序要先于加法运算。</p>
<p>而乘法与取余的优先级相同。这时为了得到正确的运算顺序，还需要考虑结合性。乘法与取余运算都是左结合的。可以将这考虑成为这两部分表达式都隐式地加上了括号：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> + ((<span class="number">3</span> % <span class="number">4</span>) * <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p><code>(3 % 4)</code> 等于 <code>3</code>，所以表达式相当于：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> + (<span class="number">3</span> * <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p><code>3 * 5</code> 等于 <code>15</code>，所以表达式相当于：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> + <span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>因此计算结果为 <code>17</code>。</p>
<p>如果想查看完整的 Swift 运算符优先级和结合性规则，请参考<a href="../chapter3/04_Expressions.html">表达式</a>。如果想查看 Swift 标准库提供所有的运算符，请查看 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Reference/Swift_StandardLibrary_Operators/index.html#//apple_ref/doc/uid/TP40016054" target="_blank" rel="external">Swift Standard Library Operators Reference</a>。</p>
<blockquote>
<p>注意<br>相对 C 语言和 Objective-C 来说，Swift 的运算符优先级和结合性规则更加简洁和可预测。但是，这也意味着它们相较于 C 语言及其衍生语言并不是完全一致的。在对现有的代码进行移植的时候，要注意确保运算符的行为仍然符合你的预期。</p>
</blockquote>
<p><a name="operator_functions"></a></p>
<h2 id="运算符函数">运算符函数</h2><p>类和结构体可以为现有的运算符提供自定义的实现，这通常被称为运算符重载。</p>
<p>下面的例子展示了如何为自定义的结构体实现加法运算符（<code>+</code>）。算术加法运算符是一个双目运算符，因为它可以对两个值进行运算，同时它还是中缀运算符，因为它出现在两个值中间。</p>
<p>例子中定义了一个名为 <code>Vector2D</code> 的结构体用来表示二维坐标向量 <code>(x, y)</code>，紧接着定义了一个可以对两个 <code>Vector2D</code> 结构体进行相加的运算符函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vector2D</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> + <span class="params">(<span class="keyword">left</span>: Vector2D, <span class="keyword">right</span>: Vector2D)</span></span> -&gt; <span class="type">Vector2D</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Vector2D</span>(x: <span class="keyword">left</span>.x + <span class="keyword">right</span>.x, y: <span class="keyword">left</span>.y + <span class="keyword">right</span>.y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该运算符函数被定义为一个全局函数，并且函数的名字与它要进行重载的 <code>+</code> 名字一致。因为算术加法运算符是双目运算符，所以这个运算符函数接收两个类型为 <code>Vector2D</code> 的参数，同时有一个 <code>Vector2D</code> 类型的返回值。</p>
<p>在这个实现中，输入参数分别被命名为 <code>left</code> 和 <code>right</code>，代表在 <code>+</code> 运算符左边和右边的两个 <code>Vector2D</code> 实例。函数返回了一个新的 <code>Vector2D</code> 实例，这个实例的 <code>x</code> 和 <code>y</code> 分别等于作为参数的两个实例的 <code>x</code> 和 <code>y</code> 的值之和。</p>
<p>这个函数被定义成全局的，而不是 <code>Vector2D</code> 结构体的成员方法，所以任意两个 <code>Vector2D</code> 实例都可以使用这个中缀运算符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vector = <span class="type">Vector2D</span>(x: <span class="number">3.0</span>, y: <span class="number">1.0</span>)</span><br><span class="line"><span class="keyword">let</span> anotherVector = <span class="type">Vector2D</span>(x: <span class="number">2.0</span>, y: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">let</span> combinedVector = vector + anotherVector</span><br><span class="line"><span class="comment">// combinedVector 是一个新的 Vector2D 实例，值为 (5.0, 5.0)</span></span><br></pre></td></tr></table></figure>
<p>这个例子实现两个向量 <code>(3.0，1.0)</code> 和 <code>(2.0，4.0)</code> 的相加，并得到新的向量 <code>(5.0，5.0)</code>。这个过程如下图示：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/vectorAddition_2x.png" alt="Art/vectorAddition_2x.png" title="Art/vectorAddition_2x.png"></p>
<p><a name="prefix_and_postfix_operators"></a></p>
<h3 id="前缀和后缀运算符">前缀和后缀运算符</h3><p>上个例子演示了一个双目中缀运算符的自定义实现。类与结构体也能提供标准单目运算符的实现。单目运算符只运算一个值。当运算符出现在值之前时，它就是前缀的（例如 <code>-a</code>），而当它出现在值之后时，它就是后缀的（例如 <code>i++</code>）。</p>
<p>要实现前缀或者后缀运算符，需要在声明运算符函数的时候在 <code>func</code> 关键字之前指定 <code>prefix</code> 或者 <code>postfix</code> 修饰符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">prefix</span> <span class="func"><span class="keyword">func</span> - <span class="params">(vector: Vector2D)</span></span> -&gt; <span class="type">Vector2D</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Vector2D</span>(x: -vector.x, y: -vector.y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码为 <code>Vector2D</code> 类型实现了单目负号运算符。由于该运算符是前缀运算符，所以这个函数需要加上 <code>prefix</code> 修饰符。</p>
<p>对于简单数值，单目负号运算符可以对它们的正负性进行改变。对于 <code>Vector2D</code> 来说，该运算将其 <code>x</code> 和 <code>y</code> 属性的正负性都进行了改变：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> positive = <span class="type">Vector2D</span>(x: <span class="number">3.0</span>, y: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">let</span> negative = -positive</span><br><span class="line"><span class="comment">// negative 是一个值为 (-3.0, -4.0) 的 Vector2D 实例</span></span><br><span class="line"><span class="keyword">let</span> alsoPositive = -negative</span><br><span class="line"><span class="comment">// alsoPositive 是一个值为 (3.0, 4.0) 的 Vector2D 实例</span></span><br></pre></td></tr></table></figure>
<p><a name="compound_assignment_operators"></a></p>
<h3 id="复合赋值运算符">复合赋值运算符</h3><p>复合赋值运算符将赋值运算符（<code>=</code>）与其它运算符进行结合。例如，将加法与赋值结合成加法赋值运算符（<code>+=</code>）。在实现的时候，需要把运算符的左参数设置成 <code>inout</code> 类型，因为这个参数的值会在运算符函数内直接被修改。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> += <span class="params">(<span class="keyword">inout</span> <span class="keyword">left</span>: Vector2D, <span class="keyword">right</span>: Vector2D)</span></span> &#123;</span><br><span class="line">    <span class="keyword">left</span> = <span class="keyword">left</span> + <span class="keyword">right</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为加法运算在之前已经定义过了，所以在这里无需重新定义。在这里可以直接利用现有的加法运算符函数，用它来对左值和右值进行相加，并再次赋值给左值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> original = <span class="type">Vector2D</span>(x: <span class="number">1.0</span>, y: <span class="number">2.0</span>)</span><br><span class="line"><span class="keyword">let</span> vectorToAdd = <span class="type">Vector2D</span>(x: <span class="number">3.0</span>, y: <span class="number">4.0</span>)</span><br><span class="line">original += vectorToAdd</span><br><span class="line"><span class="comment">// original 的值现在为 (4.0, 6.0)</span></span><br></pre></td></tr></table></figure>
<p>还可以将赋值与 <code>prefix</code> 或 <code>postfix</code> 修饰符结合起来，下面的代码为 <code>Vector2D</code> 实例实现了前缀自增运算符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">prefix</span> <span class="func"><span class="keyword">func</span> ++ <span class="params">(<span class="keyword">inout</span> vector: Vector2D)</span></span> -&gt; <span class="type">Vector2D</span> &#123;</span><br><span class="line">    vector += <span class="type">Vector2D</span>(x: <span class="number">1.0</span>, y: <span class="number">1.0</span>)</span><br><span class="line">    <span class="keyword">return</span> vector</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个前缀自增运算符使用了前面定义的加法赋值运算。它对 <code>Vector2D</code> 的 <code>x</code> 和 <code>y</code> 属性都进行了加 <code>1</code> 运算，再将结果返回：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toIncrement = <span class="type">Vector2D</span>(x: <span class="number">3.0</span>, y: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">let</span> afterIncrement = ++toIncrement</span><br><span class="line"><span class="comment">// toIncrement 的值现在为 (4.0, 5.0)</span></span><br><span class="line"><span class="comment">// afterIncrement 的值同样为 (4.0, 5.0)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>不能对默认的赋值运算符（<code>=</code>）进行重载。只有组合赋值运算符可以被重载。同样地，也无法对三目条件运算符 （<code>a ? b : c</code>） 进行重载。</p>
</blockquote>
<p><a name="equivalence_operators"></a></p>
<h3 id="等价运算符">等价运算符</h3><p>自定义的类和结构体没有对等价运算符进行默认实现，等价运算符通常被称为“相等”运算符（<code>==</code>）与“不等”运算符（<code>!=</code>）。对于自定义类型，Swift 无法判断其是否“相等”，因为“相等”的含义取决于这些自定义类型在你的代码中所扮演的角色。</p>
<p>为了使用等价运算符能对自定义的类型进行判等运算，需要为其提供自定义实现，实现的方法与其它中缀运算符一样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> == <span class="params">(<span class="keyword">left</span>: Vector2D, <span class="keyword">right</span>: Vector2D)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">left</span>.x == <span class="keyword">right</span>.x) &amp;&amp; (<span class="keyword">left</span>.y == <span class="keyword">right</span>.y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> != <span class="params">(<span class="keyword">left</span>: Vector2D, <span class="keyword">right</span>: Vector2D)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !(<span class="keyword">left</span> == <span class="keyword">right</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码实现了“相等”运算符（<code>==</code>）来判断两个 <code>Vector2D</code> 实例是否相等。对于 <code>Vector2D</code> 类型来说，“相等”意味着“两个实例的 <code>x</code> 属性和 <code>y</code> 属性都相等”，这也是代码中用来进行判等的逻辑。示例里同时也实现了“不等”运算符（<code>!=</code>），它简单地将“相等”运算符的结果进行取反后返回。</p>
<p>现在我们可以使用这两个运算符来判断两个 <code>Vector2D</code> 实例是否相等：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> twoThree = <span class="type">Vector2D</span>(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">let</span> anotherTwoThree = <span class="type">Vector2D</span>(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">if</span> twoThree == anotherTwoThree &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"These two vectors are equivalent."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “These two vectors are equivalent.”</span></span><br></pre></td></tr></table></figure>
<p><a name="custom_operators"></a></p>
<h2 id="自定义运算符">自定义运算符</h2><p>除了实现标准运算符，在 Swift 中还可以声明和实现自定义运算符。可以用来自定义运算符的字符列表请参考<a href="../chapter3/02_Lexical_Structure.html#operators">运算符</a>。</p>
<p>新的运算符要使用 <code>operator</code> 关键字在全局作用域内进行定义，同时还要指定 <code>prefix</code>、<code>infix</code> 或者 <code>postfix</code> 修饰符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">prefix</span> <span class="keyword">operator</span> +++ &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码定义了一个新的名为 <code>+++</code> 的前缀运算符。对于这个运算符，在 Swift 中并没有意义，因此我们针对 <code>Vector2D</code> 的实例来定义它的意义。对这个示例来讲，<code>+++</code> 被实现为“前缀双自增”运算符。它使用了前面定义的复合加法运算符来让矩阵对自身进行相加，从而让 <code>Vector2D</code> 实例的 <code>x</code> 属性和 <code>y</code> 属性的值翻倍：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">prefix</span> <span class="func"><span class="keyword">func</span> +++ <span class="params">(<span class="keyword">inout</span> vector: Vector2D)</span></span> -&gt; <span class="type">Vector2D</span> &#123;</span><br><span class="line">    vector += vector</span><br><span class="line">    <span class="keyword">return</span> vector</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Vector2D</code> 的 <code>+++</code> 的实现和 <code>++</code> 的实现很相似，唯一不同的是前者对自身进行相加，而后者是与另一个值为 <code>(1.0, 1.0)</code> 的向量相加。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toBeDoubled = <span class="type">Vector2D</span>(x: <span class="number">1.0</span>, y: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">let</span> afterDoubling = +++toBeDoubled</span><br><span class="line"><span class="comment">// toBeDoubled 现在的值为 (2.0, 8.0)</span></span><br><span class="line"><span class="comment">// afterDoubling 现在的值也为 (2.0, 8.0)</span></span><br></pre></td></tr></table></figure>
<p><a name="precedence_and_associativity_for_custom_infix_operators"></a></p>
<h3 id="自定义中缀运算符的优先级和结合性">自定义中缀运算符的优先级和结合性</h3><p>自定义的中缀运算符也可以指定优先级和结合性。<a href="#precedence_and_associativity">优先级和结合性</a>中详细阐述了这两个特性是如何对中缀运算符的运算产生影响的。</p>
<p>结合性可取的值有<code>left</code>，<code>right</code> 和 <code>none</code>。当左结合运算符跟其他相同优先级的左结合运算符写在一起时，会跟左边的值进行结合。同理，当右结合运算符跟其他相同优先级的右结合运算符写在一起时，会跟右边的值进行结合。而非结合运算符不能跟其他相同优先级的运算符写在一起。</p>
<p>结合性的默认值是 <code>none</code>，优先级的默认值 <code>100</code>。</p>
<p>以下例子定义了一个新的中缀运算符 <code>+-</code>，此运算符的结合性为 <code>left</code>，并且它的优先级为 <code>140</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> +- &#123; <span class="keyword">associativity</span> <span class="keyword">left</span> <span class="keyword">precedence</span> <span class="number">140</span> &#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> +- <span class="params">(<span class="keyword">left</span>: Vector2D, <span class="keyword">right</span>: Vector2D)</span></span> -&gt; <span class="type">Vector2D</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Vector2D</span>(x: <span class="keyword">left</span>.x + <span class="keyword">right</span>.x, y: <span class="keyword">left</span>.y - <span class="keyword">right</span>.y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> firstVector = <span class="type">Vector2D</span>(x: <span class="number">1.0</span>, y: <span class="number">2.0</span>)</span><br><span class="line"><span class="keyword">let</span> secondVector = <span class="type">Vector2D</span>(x: <span class="number">3.0</span>, y: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">let</span> plusMinusVector = firstVector +- secondVector</span><br><span class="line"><span class="comment">// plusMinusVector 是一个 Vector2D 实例，并且它的值为 (4.0, -2.0)</span></span><br></pre></td></tr></table></figure>
<p>这个运算符把两个向量的 <code>x</code> 值相加，同时用第一个向量的 <code>y</code> 值减去第二个向量的 <code>y</code> 值。因为它本质上是属于“相加型”运算符，所以将它的结合性和优先级被分别设置为 <code>left</code> 和 <code>140</code>，这与 <code>+</code> 和 <code>-</code> 等默认的中缀“相加型”运算符是相同的。关于 Swift 标准库提供的运算符的结合性与优先级，请参考 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Reference/Swift_StandardLibrary_Operators/index.html#//apple_ref/doc/uid/TP40016054" target="_blank" rel="external">Swift Standard Library Operators Reference</a>。</p>
<blockquote>
<p>注意<br>当定义前缀与后缀运算符的时候，我们并没有指定优先级。然而，如果对同一个值同时使用前缀与后缀运算符，则后缀运算符会先参与运算。</p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/chapter2/" itemprop="url">
                第二章-Swift 教程
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:01+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/chapter2/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/chapter2/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="Swift_教程">Swift 教程</h1><p>本章介绍了 Swift 的各种特性及其使用方法，是全书的核心部分。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/v1.0/" itemprop="url">
                v1.0
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:00+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/v1.0/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/v1.0/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><blockquote>
<p>Swift 兴趣交流群：<code>305014012</code>，307017261（已满）<br><a href="http://swiftist.org" target="_blank" rel="external">Swift 开发者社区</a></p>
</blockquote>
<!-- -->
<blockquote>
<p>如果你觉得这个项目不错，请<a href="https://github.com/numbbbbb/the-swift-programming-language-in-chinese" target="_blank" rel="external">点击Star一下</a>，您的支持是我们最大的动力。</p>
</blockquote>
<!-- -->
<blockquote>
<p>关于文档中翻译错误，逻辑错误以及疑难问题答疑，请关注<a href="http://weibo.com/u/5241713117" target="_blank" rel="external">“@老码团队”</a>官方微博，会有技术人员统一收集答疑</p>
</blockquote>
<h1 id="The_Swift_Programming_Language_中文版">The Swift Programming Language 中文版</h1><p>###这一次，让中国和世界同步</p>
<p>现在是6月12日凌晨4:38，我用了整整一晚上的时间来进行最后的校对，终于可以在12日拿出一个可以发布的版本。</p>
<p>9天时间，1317个 Star，310个 Fork，超过30人参与翻译和校对工作，项目最高排名GitHub总榜第4。</p>
<p>设想过很多遍校对完成时的场景，仰天大笑还是泪流满面？真正到了这一刻才发现，疲倦已经不允许我有任何情绪。</p>
<p>说实话，刚开始发起项目的时候完全没想到会发展成今天这样，我一度计划自己一个人翻译完整本书。万万没想到，会有这么多的人愿意加入并贡献出自己的力量。</p>
<p>coverxit发给我最后一份文档的时候说，我要去背单词了，我问他，周末要考六级？他说是的。</p>
<p>pp-prog告诉我，这几天太累了，校对到一半睡着了，醒来又继续做。2点17分，发给我校对完成的文档。</p>
<p>lifedim说他平时12点就会睡，1点47分，发给我校对后的文档。</p>
<p>团队里每个人都有自己的事情，上班、上学、创业，但是我们只用了9天就完成整本书的翻译。我不知道大家付出了多少，牺牲了多少，但是我知道，他们的付出必将被这些文字记录下来，即使再过10年，20年，依然熠熠生辉，永不被人遗忘。</p>
<p>全体人员名单（排名不分先后）：</p>
<ul>
<li><a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></li>
<li><a href="https://github.com/stanzhai" target="_blank" rel="external">stanzhai</a></li>
<li><a href="https://github.com/coverxit" target="_blank" rel="external">coverxit</a></li>
<li><a href="https://github.com/wh1100717" target="_blank" rel="external">wh1100717</a></li>
<li><a href="https://github.com/TimothyYe" target="_blank" rel="external">TimothyYe</a></li>
<li><a href="https://github.com/honghaoz" target="_blank" rel="external">honghaoz</a></li>
<li><a href="https://github.com/lyuka" target="_blank" rel="external">lyuka</a></li>
<li><a href="https://github.com/JaySurplus" target="_blank" rel="external">JaySurplus</a></li>
<li><a href="https://github.com/Hawstein" target="_blank" rel="external">Hawstein</a></li>
<li><a href="https://github.com/geek5nan" target="_blank" rel="external">geek5nan</a></li>
<li><a href="https://github.com/yankuangshi" target="_blank" rel="external">yankuangshi</a></li>
<li><a href="https://github.com/xielingwang" target="_blank" rel="external">xielingwang</a></li>
<li><a href="https://github.com/yulingtianxia" target="_blank" rel="external">yulingtianxia</a></li>
<li><a href="https://github.com/twlkyao" target="_blank" rel="external">twlkyao</a></li>
<li><a href="https://github.com/dabing1022" target="_blank" rel="external">dabing1022</a></li>
<li><a href="https://github.com/vclwei" target="_blank" rel="external">vclwei</a></li>
<li><a href="https://github.com/fd5788" target="_blank" rel="external">fd5788</a></li>
<li><a href="https://github.com/siemenliu" target="_blank" rel="external">siemenliu</a></li>
<li><a href="https://github.com/youkugems" target="_blank" rel="external">youkugems</a></li>
<li><a href="https://github.com/haolloyin" target="_blank" rel="external">haolloyin</a></li>
<li><a href="https://github.com/wxstars" target="_blank" rel="external">wxstars</a></li>
<li><a href="https://github.com/IceskYsl" target="_blank" rel="external">IceskYsl</a></li>
<li><a href="https://github.com/sg552" target="_blank" rel="external">sg552</a></li>
<li><a href="https://github.com/superkam" target="_blank" rel="external">superkam</a></li>
<li><a href="https://github.com/zac1st1k" target="_blank" rel="external">zac1st1k</a></li>
<li><a href="https://github.com/bzsy" target="_blank" rel="external">bzsy</a></li>
<li><a href="https://github.com/pyanfield" target="_blank" rel="external">pyanfield</a></li>
<li><a href="https://github.com/ericzyh" target="_blank" rel="external">ericzyh</a></li>
<li><a href="https://github.com/peiyucn" target="_blank" rel="external">peiyucn</a></li>
<li><a href="https://github.com/sunfiled" target="_blank" rel="external">sunfiled</a></li>
<li><a href="https://github.com/lzw120" target="_blank" rel="external">lzw120</a></li>
<li><a href="https://github.com/viztor" target="_blank" rel="external">viztor</a></li>
<li><a href="https://github.com/wongzigii" target="_blank" rel="external">wongzigii</a></li>
<li><a href="https://github.com/umcsdon" target="_blank" rel="external">umcsdon</a></li>
<li><a href="https://github.com/zq54zquan" target="_blank" rel="external">zq54zquan</a></li>
<li><a href="https://github.com/xiehurricane" target="_blank" rel="external">xiehurricane</a></li>
<li><a href="https://github.com/Jasonbroker" target="_blank" rel="external">Jasonbroker</a></li>
<li><a href="https://github.com/tualatrix" target="_blank" rel="external">tualatrix</a></li>
<li><a href="https://github.com/pp-prog" target="_blank" rel="external">pp-prog</a></li>
<li><a href="https://github.com/088haizi" target="_blank" rel="external">088haizi</a></li>
<li><a href="https://github.com/baocaixiong" target="_blank" rel="external">baocaixiong</a></li>
<li><a href="https://github.com/yeahdongcn" target="_blank" rel="external">yeahdongcn</a></li>
<li><a href="https://github.com/shinyzhu" target="_blank" rel="external">shinyzhu</a></li>
<li><a href="https://github.com/lslxdx" target="_blank" rel="external">lslxdx</a></li>
<li><a href="https://github.com/Evilcome" target="_blank" rel="external">Evilcome</a></li>
<li><a href="https://github.com/zqp" target="_blank" rel="external">zqp</a></li>
<li><a href="https://github.com/NicePiao" target="_blank" rel="external">NicePiao</a></li>
<li><a href="https://github.com/LunaticM" target="_blank" rel="external">LunaticM</a></li>
<li><a href="https://github.com/menlongsheng" target="_blank" rel="external">menlongsheng</a></li>
<li><a href="https://github.com/lifedim" target="_blank" rel="external">lifedim</a></li>
<li><a href="https://github.com/happyming" target="_blank" rel="external">happyming</a></li>
<li><a href="https://github.com/bruce0505" target="_blank" rel="external">bruce0505</a></li>
<li><a href="https://github.com/Lin-H" target="_blank" rel="external">Lin-H</a></li>
<li><a href="https://github.com/takalard" target="_blank" rel="external">takalard</a></li>
<li><a href="https://github.com/dabing1022" target="_blank" rel="external">dabing1022</a></li>
<li><a href="https://github.com/marsprince" target="_blank" rel="external">marsprince</a></li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/">&laquo;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/8/">&raquo;</a>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="https://avatars2.githubusercontent.com/u/14305708?v=3&s=460" alt="terry" itemprop="image"/>
          <p class="site-author-name" itemprop="name">terry</p>
        </div>
        <p class="site-description motion-element" itemprop="description">terry yang's blog | java | scala | bi</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">142</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">11</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-next-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yangwei8888" target="_blank">github</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/microsoftgoogles" target="_blank">weibo</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/run-zhi-38" target="_blank">zhihu</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">terry</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  

    <script type="text/javascript">
      var disqus_shortname = 'yangwei888';
      var disqus_identifier = 'page/7/index.html';
      var disqus_title = '';
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
