

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Type Checker Design and Implementation &mdash; Swift Programming Language documentation 0.1.9 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Swift Programming Language documentation 0.1.9 documentation" href="index.html"/>
        <link rel="up" title="Contents" href="contents.html"/>
        <link rel="next" title="Debugging the Swift Compiler" href="DebuggingTheCompiler.html"/>
        <link rel="prev" title="Swift Intermediate Language (SIL)" href="SIL.html"/>
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>


  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Swift Programming Language documentation
          

          
          </a>

          
            
            
              <div class="version">
                0.1.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">swift docs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="ABI.html">The Swift ABI</a></li>
<li class="toctree-l1"><a class="reference internal" href="ARCOptimization.html">ARC Optimization for Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="AccessControl.html">Access Control</a></li>
<li class="toctree-l1"><a class="reference internal" href="AccessControlInStdlib.html">Scope and introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="AccessControlInStdlib.html#public"><cite>public</cite></a></li>
<li class="toctree-l1"><a class="reference internal" href="AccessControlInStdlib.html#internal"><cite>internal</cite></a></li>
<li class="toctree-l1"><a class="reference internal" href="AccessControlInStdlib.html#private"><cite>private</cite></a></li>
<li class="toctree-l1"><a class="reference internal" href="AccessControlInStdlib.html#leading-underscore-rule">Leading Underscore Rule</a></li>
<li class="toctree-l1"><a class="reference internal" href="Arrays.html">The Swift Array Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="CallingConvention.html">The Swift Calling Convention</a></li>
<li class="toctree-l1"><a class="reference internal" href="DebuggingTheCompiler.html">Debugging the Swift Compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="Dependency Analysis.html">Dependency Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="DriverInternals.html">Driver Design &amp; Internals</a></li>
<li class="toctree-l1"><a class="reference internal" href="DriverParseableOutput.html">Parseable Driver Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="ErrorHandling.html">Error Handling in Swift 2.0</a></li>
<li class="toctree-l1"><a class="reference internal" href="ErrorHandlingRationale.html">Error Handling Rationale and Proposal</a></li>
<li class="toctree-l1"><a class="reference internal" href="Failable Initializers.html">Failable initializers</a></li>
<li class="toctree-l1"><a class="reference internal" href="Generics.html">Generics in Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="GitWorkflows.html">Git Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="GitWorkflows.html#svn-git-workflows">SVN -&gt; GIT Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="HighLevelSILOptimizations.html">High-Level Optimizations in SIL</a></li>
<li class="toctree-l1"><a class="reference internal" href="Import.html">IMPORT SYNTAX</a></li>
<li class="toctree-l1"><a class="reference internal" href="Import.html#resolving-name-clashes">RESOLVING NAME CLASHES</a></li>
<li class="toctree-l1"><a class="reference internal" href="Import.html#future-extensions">FUTURE EXTENSIONS</a></li>
<li class="toctree-l1"><a class="reference internal" href="IndexInvalidation.html">Index Invalidation Rules in the Swift Standard Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#using-versioned-api">Using Versioned API</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#publishing-versioned-api">Publishing Versioned API</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#giving-up-flexibility">Giving Up Flexibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#optimization">Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#resilience-domains">Resilience Domains</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#protocol-conformances">Protocol Conformances</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#checking-binary-compatibility">Checking Binary Compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#summary">Summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#glossary">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="Literals.html">Literals</a></li>
<li class="toctree-l1"><a class="reference internal" href="LogicalObjects.html">Logical Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="Modules.html">High-Level Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="Modules.html#import"><code class="docutils literal"><span class="pre">import</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="Modules.html#interoperability-with-objective-c-via-clang">Interoperability with Objective-C via Clang</a></li>
<li class="toctree-l1"><a class="reference internal" href="Modules.html#glossary">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="MutationModel.html">Immutability and Read-Only Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="ObjectInitialization.html">Object Initialization</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html">Writing High-Performance Swift Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#enabling-optimizations">Enabling Optimizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#whole-module-optimizations">Whole Module Optimizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#reducing-dynamic-dispatch">Reducing Dynamic Dispatch</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#using-container-types-efficiently">Using Container Types Efficiently</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#unchecked-operations">Unchecked operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#generics">Generics</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#the-cost-of-large-swift-values">The cost of large swift values</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#unsafe-code">Unsafe code</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#protocols">Protocols</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#footnotes">Footnotes</a></li>
<li class="toctree-l1"><a class="reference internal" href="Pattern Matching.html">Pattern Matching</a></li>
<li class="toctree-l1"><a class="reference internal" href="SIL.html">Swift Intermediate Language (SIL)</a></li>
<li class="toctree-l1"><a class="reference internal" href="SequencesAndCollections.html">Sequences And Collections in Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="Serialization.html">Swift Binary Serialization Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="StdlibAPIGuidelines.html">Swift Standard Library API Design Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="StdlibRationales.html">Rationales for the Swift standard library designs</a></li>
<li class="toctree-l1"><a class="reference internal" href="StoredAndComputedVariables.html">Stored and Computed Variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="StringDesign.html">Swift String Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="Testing.html">Testing Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="TextFormatting.html">Text Formatting in Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="TransparentAttr.html"><code class="docutils literal"><span class="pre">&#64;_transparent</span></code></a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Type Checker Design and Implementation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#purpose">Purpose</a></li>
<li class="toctree-l2"><a class="reference internal" href="#approach">Approach</a></li>
<li class="toctree-l2"><a class="reference internal" href="#constraints">Constraints</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#constraint-generation">Constraint Generation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overloading">Overloading</a></li>
<li class="toctree-l4"><a class="reference internal" href="#polymorphic-types">Polymorphic Types</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#constraint-solving">Constraint Solving</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#simplification">Simplification</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#relational-constraints">Relational Constraints</a></li>
<li class="toctree-l4"><a class="reference internal" href="#member-constraints">Member Constraints</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#strategies">Strategies</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overload-selection">Overload Selection</a></li>
<li class="toctree-l4"><a class="reference internal" href="#type-variable-bindings">Type Variable Bindings</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#comparing-solutions">Comparing Solutions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#solution-application">Solution Application</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#locators">Locators</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overload-choices">Overload Choices</a></li>
<li class="toctree-l4"><a class="reference internal" href="#simplifying-locators">Simplifying Locators</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#performance">Performance</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#constraint-graph">Constraint Graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="#simplification-worklist">Simplification Worklist</a></li>
<li class="toctree-l3"><a class="reference internal" href="#solver-scopes">Solver Scopes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#online-scoring">Online Scoring</a></li>
<li class="toctree-l3"><a class="reference internal" href="#arena-memory-management">Arena Memory Management</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#diagnostics">Diagnostics</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="contents.html">Contents</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="IndexInvalidation.html">Index Invalidation Rules in the Swift Standard Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="AccessControl.html">Access Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="DriverInternals.html">Driver Design &amp; Internals</a></li>
<li class="toctree-l2"><a class="reference internal" href="DriverParseableOutput.html">Parseable Driver Output</a></li>
<li class="toctree-l2"><a class="reference internal" href="ErrorHandling.html">Error Handling in Swift 2.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="ErrorHandlingRationale.html">Error Handling Rationale and Proposal</a></li>
<li class="toctree-l2"><a class="reference internal" href="Generics.html">Generics in Swift</a></li>
<li class="toctree-l2"><a class="reference internal" href="LogicalObjects.html">Logical Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="ObjectInitialization.html">Object Initialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="Pattern Matching.html">Pattern Matching</a></li>
<li class="toctree-l2"><a class="reference internal" href="StoredAndComputedVariables.html">Stored and Computed Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="SIL.html">Swift Intermediate Language (SIL)</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Type Checker Design and Implementation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#purpose">Purpose</a></li>
<li class="toctree-l3"><a class="reference internal" href="#approach">Approach</a></li>
<li class="toctree-l3"><a class="reference internal" href="#constraints">Constraints</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#constraint-generation">Constraint Generation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#constraint-solving">Constraint Solving</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#simplification">Simplification</a></li>
<li class="toctree-l4"><a class="reference internal" href="#strategies">Strategies</a></li>
<li class="toctree-l4"><a class="reference internal" href="#comparing-solutions">Comparing Solutions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#solution-application">Solution Application</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#locators">Locators</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#performance">Performance</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#constraint-graph">Constraint Graph</a></li>
<li class="toctree-l4"><a class="reference internal" href="#simplification-worklist">Simplification Worklist</a></li>
<li class="toctree-l4"><a class="reference internal" href="#solver-scopes">Solver Scopes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#online-scoring">Online Scoring</a></li>
<li class="toctree-l4"><a class="reference internal" href="#arena-memory-management">Arena Memory Management</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#diagnostics">Diagnostics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="DebuggingTheCompiler.html">Debugging the Swift Compiler</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="weak.html">Weak References</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Swift Programming Language documentation</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
        <li><a href="contents.html">Contents</a> &raquo;</li>
      
    <li>Type Checker Design and Implementation</li>
    <li class="wy-breadcrumbs-aside">
      
        
          <a href="_sources/TypeChecker.txt" rel="nofollow"> View page source</a>
        
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="type-checker-design-and-implementation">
<h1>Type Checker Design and Implementation<a class="headerlink" href="#type-checker-design-and-implementation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="purpose">
<h2>Purpose<a class="headerlink" href="#purpose" title="Permalink to this headline">¶</a></h2>
<p>This document describes the design and implementation of the Swift
type checker. It is intended for developers who wish to modify,
extend, or improve on the type checker, or simply to understand in
greater depth how the Swift type system works. Familiarity with the
Swift programming language is assumed.</p>
</div>
<div class="section" id="approach">
<h2>Approach<a class="headerlink" href="#approach" title="Permalink to this headline">¶</a></h2>
<p>The Swift language and its type system incorporate a number of popular
language features, including object-oriented programming via classes,
function and operator overloading, subtyping, and constrained
parametric polymorphism. Swift makes extensive use of type inference,
allowing one to omit the types of many variables and expressions. For
example:</p>
<div class="highlight-python"><div class="highlight"><pre>func round(x: Double) -&gt; Int { /* ... */ }
var pi: Double = 3.14159
var three = round(pi) // &#39;three&#39; has type &#39;Int&#39;

func identity&lt;T&gt;(x: T) -&gt; T { return x }
var eFloat: Float = -identity(2.71828)  // numeric literal gets type &#39;Float&#39;
</pre></div>
</div>
<p>Swift&#8217;s type inference allows type information to flow in two
directions. As in most mainstream languages, type information can flow
from the leaves of the expression tree (e.g., the expression &#8216;pi&#8217;,
which refers to a double) up to the root (the type of the variable
&#8216;three&#8217;). However, Swift also allows type information to flow from the
context (e.g., the fixed type of the variable &#8216;eFloat&#8217;) at the root of
the expression tree down to the leaves (the type of the numeric
literal 2.71828). This bi-directional type inference is common in
languages that use ML-like type systems, but is not present in
mainstream languages like C++, Java, C#, or Objective-C.</p>
<p>Swift implements bi-directional type inference using a
constraint-based type checker that is reminiscent of the classical
Hindley-Milner type inference algorithm. The use of a constraint
system allows a straightforward, general presentation of language
semantics that is decoupled from the actual implementation of the
solver. It is expected that the constraints themselves will be
relatively stable, while the solver will evolve over time to improve
performance and diagnostics.</p>
<p>The Swift language contains a number of features not part of the
Hindley-Milner type system, including constrained polymorphic types
and function overloading, which complicate the presentation and
implementation somewhat. On the other hand, Swift limits the scope of
type inference to a single expression or statement, for purely
practical reasons: we expect that we can provide better performance
and vastly better diagnostics when the problem is limited in scope.</p>
<p>Type checking proceeds in three main stages:</p>
<dl class="docutils">
<dt><a class="reference internal" href="#constraint-generation">Constraint Generation</a></dt>
<dd>Given an input expression and (possibly) additional contextual
information, generate a set of type constraints that describes the
relationships among the types of the various subexpressions. The
generated constraints may contain unknown types, represented by type
variables, which will be determined by the solver.</dd>
<dt><a class="reference internal" href="#constraint-solving">Constraint Solving</a></dt>
<dd>Solve the system of constraints by assigning concrete types to each
of the type variables in the constraint system. The constraint
solver should provide the most specific solution possible among
different alternatives.</dd>
<dt><a class="reference internal" href="#solution-application">Solution Application</a></dt>
<dd>Given the input expression, the set of type constraints generated
from that expression, and the set of assignments of concrete types
to each of the type variables, produce a well-typed expression that
makes all implicit conversions (and other transformations) explicit
and resolves all unknown types and overloads. This step cannot fail.</dd>
</dl>
<p>The following sections describe these three stages of type checking,
as well as matters of performance and diagnostics.</p>
</div>
<div class="section" id="constraints">
<h2>Constraints<a class="headerlink" href="#constraints" title="Permalink to this headline">¶</a></h2>
<p>A constraint system consists of a set of type constraints. Each type
constraint either places a requirement on a single type (e.g., it is
an integer literal type) or relates two types (e.g., one is a subtype
of the other). The types described in constraints can be any type in
the Swift type system including, e.g., builtin types, tuple types,
function types, enum/struct/class types, protocol types, and generic
types. Additionally, a type can be a type variable <code class="docutils literal"><span class="pre">T</span></code> (which are
typically numbered, <code class="docutils literal"><span class="pre">T0</span></code>, <code class="docutils literal"><span class="pre">T1</span></code>, <code class="docutils literal"><span class="pre">T2</span></code>, etc., and are introduced
as needed). Type variables can be used in place of any other type,
e.g., a tuple type <code class="docutils literal"><span class="pre">(T0,</span> <span class="pre">Int,</span> <span class="pre">(T0)</span> <span class="pre">-&gt;</span> <span class="pre">Int)</span></code> involving the type
variable <code class="docutils literal"><span class="pre">T0</span></code>.</p>
<p>There are a number of different kinds of constraints used to describe
the Swift type system:</p>
<dl class="docutils">
<dt><strong>Equality</strong></dt>
<dd><p class="first">An equality constraint requires two types to be identical. For
example, the constraint <code class="docutils literal"><span class="pre">T0</span> <span class="pre">==</span> <span class="pre">T1</span></code> effectively ensures that <code class="docutils literal"><span class="pre">T0</span></code> and
<code class="docutils literal"><span class="pre">T1</span></code> get the same concrete type binding. There are two different
flavors of equality constraints:</p>
<blockquote class="last">
<div><ul class="simple">
<li>Exact equality constraints, or  &#8220;binding&#8221;, written <code class="docutils literal"><span class="pre">T0</span> <span class="pre">:=</span> <span class="pre">X</span></code>
for some type variable <code class="docutils literal"><span class="pre">T0</span></code> and  type <code class="docutils literal"><span class="pre">X</span></code>, which requires
that <code class="docutils literal"><span class="pre">T0</span></code> be exactly identical to <code class="docutils literal"><span class="pre">X</span></code>;</li>
<li>Equality constraints, written <code class="docutils literal"><span class="pre">X</span> <span class="pre">==</span> <span class="pre">Y</span></code> for types <code class="docutils literal"><span class="pre">X</span></code> and
<code class="docutils literal"><span class="pre">Y</span></code>, which require <code class="docutils literal"><span class="pre">X</span></code> and <code class="docutils literal"><span class="pre">Y</span></code> to have the same type,
ignoring lvalue types in the process. For example, the
constraint <code class="docutils literal"><span class="pre">T0</span> <span class="pre">==</span> <span class="pre">X</span></code> would be satisfied by assigning <code class="docutils literal"><span class="pre">T0</span></code>
the type <code class="docutils literal"><span class="pre">X</span></code> and by assigning <code class="docutils literal"><span class="pre">T0</span></code> the type <code class="docutils literal"><span class="pre">&#64;lvalue</span> <span class="pre">X</span></code>.</li>
</ul>
</div></blockquote>
</dd>
<dt><strong>Subtyping</strong></dt>
<dd>A subtype constraint requires the first type to be equivalent to or
a subtype of the second. For example, a class type <code class="docutils literal"><span class="pre">Dog</span></code> is a
subtype of a class type <code class="docutils literal"><span class="pre">Animal</span></code> if <code class="docutils literal"><span class="pre">Dog</span></code> inherits from
<code class="docutils literal"><span class="pre">Animal</span></code> either directly or indirectly. Subtyping constraints are
written <code class="docutils literal"><span class="pre">X</span> <span class="pre">&lt;</span> <span class="pre">Y</span></code>.</dd>
<dt><strong>Conversion</strong></dt>
<dd>A conversion constraint requires that the first type be convertible
to the second, which includes subtyping and equality. Additionally,
it allows a user-defined conversion function to be
called. Conversion constraints are written <code class="docutils literal"><span class="pre">X</span> <span class="pre">&lt;c</span> <span class="pre">Y</span></code>, read as
&#8220;<code class="docutils literal"><span class="pre">X</span></code> can be converted to <code class="docutils literal"><span class="pre">Y</span></code>.&#8221;</dd>
<dt><strong>Construction</strong></dt>
<dd>A construction constraint, written <code class="docutils literal"><span class="pre">X</span> <span class="pre">&lt;C</span> <span class="pre">Y</span></code> requires that the
second type be a nominal type with a constructor that accepts a
value of the first type. For example, the constraint <code class="docutils literal"><span class="pre">Int</span> <span class="pre">&lt;C</span>
<span class="pre">String</span></code> is satisfiable because <code class="docutils literal"><span class="pre">String</span></code> has a constructor that
accepts an <code class="docutils literal"><span class="pre">Int</span></code>.</dd>
<dt><strong>Member</strong></dt>
<dd>A member constraint <code class="docutils literal"><span class="pre">X[.name]</span> <span class="pre">==</span> <span class="pre">Y</span></code> specifies that the first type
(<code class="docutils literal"><span class="pre">X</span></code>) have a member (or an overloaded set of members) with the
given name, and that the type of that member be bound to the second
type (<code class="docutils literal"><span class="pre">Y</span></code>).  There are two flavors of member constraint: value
member constraints, which refer to the member in an expression
context, and type member constraints, which refer to the member in a
type context (and therefore can only refer to types).</dd>
<dt><strong>Conformance</strong></dt>
<dd>A conformance constraint <code class="docutils literal"><span class="pre">X</span> <span class="pre">conforms</span> <span class="pre">to</span> <span class="pre">Y</span></code> specifies that the
first type (<code class="docutils literal"><span class="pre">X</span></code>) must conform to the protocol <code class="docutils literal"><span class="pre">Y</span></code>.</dd>
<dt><strong>Checked cast</strong></dt>
<dd>A constraint describing a checked cast from the first type to the
second, i.e., for <code class="docutils literal"><span class="pre">x</span> <span class="pre">as</span> <span class="pre">T</span></code>.</dd>
<dt><strong>Applicable function</strong></dt>
<dd>An applicable function requires that both types are function types
with the same input and output types. It is used when the function
type on the left-hand side is being split into its input and output
types for function application purposes. Note, that it does not
require the type attributes to match.</dd>
<dt><strong>Overload binding</strong></dt>
<dd>An overload binding constraint binds a type variable by selecting a
particular choice from an overload set. Multiple overloads are
represented by a disjunction constraint.</dd>
<dt><strong>Conjunction</strong></dt>
<dd>A constraint that is the conjunction of two or more other
constraints. Typically used within a disjunction.</dd>
<dt><strong>Disjunction</strong></dt>
<dd>A constraint that is the disjunction of two or more
constraints. Disjunctions are used to model different decisions that
the solver could make, i.e., the sets of overloaded functions from
which the solver could choose, or different potential conversions,
each of which might resolve in a (different) solution.</dd>
<dt><strong>Archetype</strong></dt>
<dd>An archetype constraint requires that the constrained type be bound
to an archetype. This is a very specific kind of constraint that is
only used for calls to operators in protocols.</dd>
<dt><strong>Class</strong></dt>
<dd>A class constraint requires that the constrained type be bound to a
class type.</dd>
<dt><strong>Self object of protocol</strong></dt>
<dd>An internal-use-only constraint that describes the conformance of a
<code class="docutils literal"><span class="pre">Self</span></code> type to a protocol. It is similar to a conformance
constraint but &#8220;looser&#8221; because it allows a protocol type to be the
self object of its own protocol (even when an existential type would
not conform to its own protocol).</dd>
<dt><strong>Dynamic lookup value</strong></dt>
<dd>A constraint that requires that the constrained type be
DynamicLookup or an lvalue thereof.</dd>
</dl>
<div class="section" id="constraint-generation">
<h3>Constraint Generation<a class="headerlink" href="#constraint-generation" title="Permalink to this headline">¶</a></h3>
<p>The process of constraint generation produces a constraint system
that relates the types of the various subexpressions within an
expression. Programmatically, constraint generation walks an
expression from the leaves up to the root, assigning a type (which
often involves type variables) to each subexpression as it goes.</p>
<p>Constraint generation is driven by the syntax of the
expression, and each different kind of expression&#8212;function
application, member access, etc.&#8212;generates a specific set of
constraints. Here, we enumerate the primary expression kinds in the
language and describe the type assigned to the expression and the
constraints generated from such as expression. We use <code class="docutils literal"><span class="pre">T(a)</span></code> to
refer to the type assigned to the subexpression <code class="docutils literal"><span class="pre">a</span></code>. The constraints
and types generated from the primary expression kinds are:</p>
<dl class="docutils">
<dt><strong>Declaration reference</strong></dt>
<dd><p class="first">An expression that refers to a declaration <code class="docutils literal"><span class="pre">x</span></code> is assigned the
type of a reference to <code class="docutils literal"><span class="pre">x</span></code>. For example, if <code class="docutils literal"><span class="pre">x</span></code> is declared as
<code class="docutils literal"><span class="pre">var</span> <span class="pre">x:</span> <span class="pre">Int</span></code>, the expression <code class="docutils literal"><span class="pre">x</span></code> is assigned the type
<code class="docutils literal"><span class="pre">&#64;lvalue</span> <span class="pre">Int</span></code>. No constraints are generated.</p>
<p class="last">When a name refers to a set of overloaded declarations, the
selection of the appropriate declaration is handled by the
solver. This particular issue is discussed in the <a class="reference internal" href="#overloading">Overloading</a>
section. Additionally, when the name refers to a generic function or
a generic type, the declaration reference may introduce new type
variables; see the <a class="reference internal" href="#polymorphic-types">Polymorphic Types</a> section for more information.</p>
</dd>
<dt><strong>Member reference</strong></dt>
<dd><p class="first">A member reference expression <code class="docutils literal"><span class="pre">a.b</span></code> is assigned the type <code class="docutils literal"><span class="pre">T0</span></code>
for a fresh type variable <code class="docutils literal"><span class="pre">T0</span></code>. In addition, the expression
generates the value member constraint <code class="docutils literal"><span class="pre">T(a).b</span> <span class="pre">==</span> <span class="pre">T0</span></code>.  Member
references may end up resolving to a member of a nominal type or an
element of a tuple; in the latter case, the name (<code class="docutils literal"><span class="pre">b</span></code>) may
either be an identifier or a positional argument (e.g., <code class="docutils literal"><span class="pre">1</span></code>).</p>
<p class="last">Note that resolution of the member constraint can refer to a set of
overloaded declarations; this is described further in the
<a class="reference internal" href="#overloading">Overloading</a> section.</p>
</dd>
<dt><strong>Unresolved member reference</strong></dt>
<dd><p class="first">An unresolved member reference <code class="docutils literal"><span class="pre">.name</span></code> refers to a member of a
enum type. The enum type is assumed to have a fresh variable
type <code class="docutils literal"><span class="pre">T0</span></code> (since that type can only be known from context), and a
value member constraint <code class="docutils literal"><span class="pre">T0.name</span> <span class="pre">==</span> <span class="pre">T1</span></code>, for fresh type variable
<code class="docutils literal"><span class="pre">T1</span></code>, captures the fact that it has a member named <code class="docutils literal"><span class="pre">name</span></code> with
some as-yet-unknown type <code class="docutils literal"><span class="pre">T1</span></code>. The type of the unresolved member
reference is <code class="docutils literal"><span class="pre">T1</span></code>, the type of the member. When the unresolved
member reference is actually a call <code class="docutils literal"><span class="pre">.name(x)</span></code>, the function
application is folded into the constraints generated by the
unresolved member reference.</p>
<p class="last">Note that the constraint system above actually has insufficient
information to determine the type <code class="docutils literal"><span class="pre">T0</span></code> without additional
contextual information. The <a class="reference internal" href="#overloading">Overloading</a> section describes how the
overload-selection mechanism is used to resolve this problem.</p>
</dd>
<dt><strong>Function application</strong></dt>
<dd>A function application <code class="docutils literal"><span class="pre">a(b)</span></code> generates two constraints. First,
the applicable function constraint <code class="docutils literal"><span class="pre">T0</span> <span class="pre">-&gt;</span> <span class="pre">T1</span> <span class="pre">==Fn</span> <span class="pre">T(a)</span></code> (for fresh
type variables <code class="docutils literal"><span class="pre">T0</span></code> and <code class="docutils literal"><span class="pre">T1</span></code>) captures the rvalue-to-lvalue
conversion applied on the function (<code class="docutils literal"><span class="pre">a</span></code>) and decomposes the
function type into its argument and result types. Second, the
conversion constraint <code class="docutils literal"><span class="pre">T(b)</span> <span class="pre">&lt;c</span> <span class="pre">T0</span></code> captures the requirement that
the actual argument type (<code class="docutils literal"><span class="pre">b</span></code>) be convertible to the argument type
of the function. Finally, the expression is given the type <code class="docutils literal"><span class="pre">T1</span></code>,
i.e., the result type of the function.</dd>
<dt><strong>Construction</strong></dt>
<dd><p class="first">A type construction <code class="docutils literal"><span class="pre">A(b)</span></code>, where <code class="docutils literal"><span class="pre">A</span></code> refers to a type, generates
a construction constraint <code class="docutils literal"><span class="pre">T(b)</span> <span class="pre">&lt;C</span> <span class="pre">A</span></code>, which requires that <code class="docutils literal"><span class="pre">A</span></code>
have a constructor that accepts <code class="docutils literal"><span class="pre">b</span></code>. The type of the expression is
<code class="docutils literal"><span class="pre">A</span></code>.</p>
<p class="last">Note that construction and function application use the same
syntax. Here, the constraint generator performs a shallow analysis
of the type of the &#8220;function&#8221; argument (<code class="docutils literal"><span class="pre">A</span></code> or <code class="docutils literal"><span class="pre">a</span></code>, in the
exposition above); if it obviously has metatype type, the expression
is considered a coercion/construction rather than a function
application. This particular area of the language needs more work.</p>
</dd>
<dt><strong>Subscripting</strong></dt>
<dd>A subscript operation <code class="docutils literal"><span class="pre">a[b]</span></code> is similar to function application. A
value member constraint <code class="docutils literal"><span class="pre">T(a).subscript</span> <span class="pre">==</span> <span class="pre">T0</span> <span class="pre">-&gt;</span> <span class="pre">T1</span></code> treats the
subscript as a function from the key type to the value type,
represented by fresh type variables <code class="docutils literal"><span class="pre">T0</span></code> and <code class="docutils literal"><span class="pre">T1</span></code>,
respectively. The constraint <code class="docutils literal"><span class="pre">T(b)</span> <span class="pre">&lt;c</span> <span class="pre">T0</span></code> requires the key
argument to be convertible to the key type, and the type of the
subscript operation is <code class="docutils literal"><span class="pre">T1</span></code>.</dd>
<dt><strong>Literals</strong></dt>
<dd>A literal expression, such as <code class="docutils literal"><span class="pre">17</span></code>, <code class="docutils literal"><span class="pre">1.5</span></code>, or <code class="docutils literal"><span class="pre">&quot;Hello,</span>
<span class="pre">world!</span></code>, is assigned a fresh type variable <code class="docutils literal"><span class="pre">T0</span></code>. Additionally, a
literal constraint is placed on that type variable depending on the
kind of literal, e.g., &#8220;<code class="docutils literal"><span class="pre">T0</span></code> is an integer literal.&#8221;</dd>
<dt><strong>Closures</strong></dt>
<dd><p class="first">A closure is assigned a function type based on the parameters and
return type. When a parameter has no specified type or is positional
(<code class="docutils literal"><span class="pre">$1</span></code>, <code class="docutils literal"><span class="pre">$2</span></code>, etc.), it is assigned a fresh type variable to
capture the type. Similarly, if the return type is omitted, it is
assigned a fresh type variable.</p>
<p class="last">When the body of the closure is a single expression, that expression
participates in the type checking of its enclosing expression
directly. Otherwise, the body of the closure is separately
type-checked once the type checking of its context has computed a
complete function type.</p>
</dd>
<dt><strong>Array allocation</strong></dt>
<dd>An array allocation <code class="docutils literal"><span class="pre">new</span> <span class="pre">A[s]</span></code> is assigned the type <code class="docutils literal"><span class="pre">A[]</span></code>. The
type checker (separately) checks that <code class="docutils literal"><span class="pre">T(s)</span></code> is an array bound
type.</dd>
<dt><strong>Address of</strong></dt>
<dd>An address-of expression <code class="docutils literal"><span class="pre">&amp;a</span></code> always returns an <code class="docutils literal"><span class="pre">&#64;inout</span></code>
type. Therefore, it is assigned the type <code class="docutils literal"><span class="pre">&#64;inout</span> <span class="pre">T0</span></code> for a fresh
type variable <code class="docutils literal"><span class="pre">T0</span></code>. The subtyping constraint <code class="docutils literal"><span class="pre">&#64;inout</span> <span class="pre">T0</span> <span class="pre">&lt;</span> <span class="pre">&#64;lvalue</span>
<span class="pre">T(a)</span></code> captures the requirement that input expression be an lvalue
of some type.</dd>
<dt><strong>Ternary operator</strong></dt>
<dd>A ternary operator <code class="docutils literal"><span class="pre">x</span> <span class="pre">?</span> <span class="pre">y</span> <span class="pre">:</span> <span class="pre">z</span></code> generates a number of
constraints. The type <code class="docutils literal"><span class="pre">T(x)</span></code> must conform to the <code class="docutils literal"><span class="pre">LogicValue</span></code>
protocol to determine which branch is taken. Then, a new type
variable <code class="docutils literal"><span class="pre">T0</span></code> is introduced to capture the result type, and the
constraints <code class="docutils literal"><span class="pre">T(y)</span> <span class="pre">&lt;c</span> <span class="pre">T0</span></code> and <code class="docutils literal"><span class="pre">T(z)</span> <span class="pre">&lt;c</span> <span class="pre">T0</span></code> capture the need for
both branches of the ternary operator to convert to a common type.</dd>
</dl>
<p>There are a number of other expression kinds within the language; see
the constraint generator for their mapping to constraints.</p>
<div class="section" id="overloading">
<h4>Overloading<a class="headerlink" href="#overloading" title="Permalink to this headline">¶</a></h4>
<p>Overloading is the process of giving multiple, different definitions
to the same name. For example, we might overload a <code class="docutils literal"><span class="pre">negate</span></code> function
to work on both <code class="docutils literal"><span class="pre">Int</span></code> and <code class="docutils literal"><span class="pre">Double</span></code> types, e.g.:</p>
<div class="highlight-python"><div class="highlight"><pre>func negate(x: Int) -&gt; Int { return -x }
func negate(x: Double) -&gt; Double { return -x }
</pre></div>
</div>
<p>Given that there are two definitions of <code class="docutils literal"><span class="pre">negate</span></code>, what is the type
of the declaration reference expression <code class="docutils literal"><span class="pre">negate</span></code>? If one selects the
first overload, the type is <code class="docutils literal"><span class="pre">(Int)</span> <span class="pre">-&gt;</span> <span class="pre">Int</span></code>; for the second overload,
the type is <code class="docutils literal"><span class="pre">(Double)</span> <span class="pre">-&gt;</span> <span class="pre">Double</span></code>. However, constraint generation
needs to assign some specific type to the expression, so that its
parent expressions can refer to that type.</p>
<p>Overloading in the type checker is modeled by introducing a fresh type
variable (call it <code class="docutils literal"><span class="pre">T0</span></code>) for the type of the reference to an
overloaded declaration. Then, a disjunction constraint is introduced,
in which each term binds that type variable (via an exact equality
constraint) to the type produced by one of the overloads in the
overload set. In our negate example, the disjunction is
<code class="docutils literal"><span class="pre">T0</span> <span class="pre">:=</span> <span class="pre">(Int)</span> <span class="pre">-&gt;</span> <span class="pre">Int</span> <span class="pre">or</span> <span class="pre">T0</span> <span class="pre">:=</span> <span class="pre">(Double)</span> <span class="pre">-&gt;</span> <span class="pre">Double</span></code>. The constraint
solver, discussed in the later section on <a class="reference internal" href="#constraint-solving">Constraint Solving</a>,
explores both possible bindings, and the overloaded reference resolves
to whichever binding results in a solution that satisfies all
constraints <a class="footnote-reference" href="#id5" id="id1">[1]</a>.</p>
<p>Overloading can be introduced both by expressions that refer to sets
of overloaded declarations and by member constraints that end up
resolving to a set of overloaded declarations. One particularly
interesting case is the unresolved member reference, e.g.,
<code class="docutils literal"><span class="pre">.name</span></code>. As noted in the prior section, this generates the
constraint <code class="docutils literal"><span class="pre">T0.name</span> <span class="pre">==</span> <span class="pre">T1</span></code>, where <code class="docutils literal"><span class="pre">T0</span></code> is a fresh type variable
that will be bound to the enum type and <code class="docutils literal"><span class="pre">T1</span></code> is a fresh type
variable that will be bound to the type of the selected member. The
issue noted in the prior section is that this constraint does not give
the solver enough information to determine <code class="docutils literal"><span class="pre">T0</span></code> without
guesswork. However, we note that the type of an enum member actually
has a regular structure. For example, consider the <code class="docutils literal"><span class="pre">Optional</span></code> type:</p>
<div class="highlight-python"><div class="highlight"><pre>enum Optional&lt;T&gt; {
  case None
  case Some(T)
}
</pre></div>
</div>
<p>The type of <code class="docutils literal"><span class="pre">Optional&lt;T&gt;.None</span></code> is <code class="docutils literal"><span class="pre">Optional&lt;T&gt;</span></code>, while the type of
<code class="docutils literal"><span class="pre">Optional&lt;T&gt;.Some</span></code> is <code class="docutils literal"><span class="pre">(T)</span> <span class="pre">-&gt;</span> <span class="pre">Optional&lt;T&gt;</span></code>. In fact, the
type of an enum element can have one of two forms: it can be <code class="docutils literal"><span class="pre">T0</span></code>,
for an enum element that has no extra data, or it can be <code class="docutils literal"><span class="pre">T2</span> <span class="pre">-&gt;</span> <span class="pre">T0</span></code>,
where <code class="docutils literal"><span class="pre">T2</span></code> is the data associated with the enum element.  For the
latter case, the actual arguments are parsed as part of the unresolved
member reference, so that a function application constraint describes
their conversion to the input type <code class="docutils literal"><span class="pre">T2</span></code>.</p>
</div>
<div class="section" id="polymorphic-types">
<h4>Polymorphic Types<a class="headerlink" href="#polymorphic-types" title="Permalink to this headline">¶</a></h4>
<p>The Swift language includes generics, a system of constrained
parameter polymorphism that enables polymorphic types and
functions. For example, one can implement a <code class="docutils literal"><span class="pre">min</span></code> function as,
e.g.,:</p>
<div class="highlight-python"><div class="highlight"><pre>func min&lt;T : Comparable&gt;(x: T, y: T) -&gt; T {
  if y &lt; x { return y }
  return x
}
</pre></div>
</div>
<p>Here, <code class="docutils literal"><span class="pre">T</span></code> is a generic parameter that can be replaced with any
concrete type, so long as that type conforms to the protocol
<code class="docutils literal"><span class="pre">Comparable</span></code>. The type of <code class="docutils literal"><span class="pre">min</span></code> is (internally) written as <code class="docutils literal"><span class="pre">&lt;T</span> <span class="pre">:</span>
<span class="pre">Comparable&gt;</span> <span class="pre">(x:</span> <span class="pre">T,</span> <span class="pre">y:</span> <span class="pre">T)</span> <span class="pre">-&gt;</span> <span class="pre">T</span></code>, which can be read as &#8220;for all <code class="docutils literal"><span class="pre">T</span></code>,
where <code class="docutils literal"><span class="pre">T</span></code> conforms to <code class="docutils literal"><span class="pre">Comparable</span></code>, the type of the function is
<code class="docutils literal"><span class="pre">(x:</span> <span class="pre">T,</span> <span class="pre">y:</span> <span class="pre">T)</span> <span class="pre">-&gt;</span> <span class="pre">T</span></code>.&#8221; Different uses of the <code class="docutils literal"><span class="pre">min</span></code> function may
have different bindings for the generic parameter <code class="docutils literal"><span class="pre">T</span></code>.</p>
<p>When the constraint generator encounters a reference to a generic
function, it immediately replaces each of the generic parameters within
the function type with a fresh type variable, introduces constraints
on that type variable to match the constraints listed in the generic
function, and produces a monomorphic function type based on the
newly-generated type variables. For example, the first occurrence of
the declaration reference expression <code class="docutils literal"><span class="pre">min</span></code> would result in a type
<code class="docutils literal"><span class="pre">(x</span> <span class="pre">:</span> <span class="pre">T0,</span> <span class="pre">y</span> <span class="pre">:</span> <span class="pre">T0)</span> <span class="pre">-&gt;</span> <span class="pre">T0</span></code>, where <code class="docutils literal"><span class="pre">T0</span></code> is a fresh type variable, as
well as the subtype constraint <code class="docutils literal"><span class="pre">T0</span> <span class="pre">&lt;</span> <span class="pre">Comparable</span></code>, which expresses
protocol conformance. The next occurrence of the declaration reference
expression <code class="docutils literal"><span class="pre">min</span></code> would produce the type <code class="docutils literal"><span class="pre">(x</span> <span class="pre">:</span> <span class="pre">T1,</span> <span class="pre">y</span> <span class="pre">:</span> <span class="pre">T1)</span> <span class="pre">-&gt;</span> <span class="pre">T1</span></code>,
where <code class="docutils literal"><span class="pre">T1</span></code> is a fresh type variable (and therefore distinct from
<code class="docutils literal"><span class="pre">T0</span></code>), and so on. This replacement process is referred to as
&#8220;opening&#8221; the generic function type, and is a fairly simple (but
effective) way to model the use of polymorphic functions within the
constraint system without complicating the solver. Note that this
immediate opening of generic function types is only valid because
Swift does not support first-class polymorphic functions, e.g., one
cannot declare a variable of type <code class="docutils literal"><span class="pre">&lt;T&gt;</span> <span class="pre">T</span> <span class="pre">-&gt;</span> <span class="pre">T</span></code>.</p>
<p>Uses of generic types are also immediately opened by the constraint
solver. For example, consider the following generic dictionary type:</p>
<div class="highlight-python"><div class="highlight"><pre>class Dictionary&lt;Key : Hashable, Value&gt; {
  // ...
}
</pre></div>
</div>
<p>When the constraint solver encounters the expression <code class="docutils literal"><span class="pre">Dictionary()</span></code>,
it opens up the type <code class="docutils literal"><span class="pre">Dictionary</span></code>&#8212;which has not
been provided with any specific generic arguments&#8212;to the type
<code class="docutils literal"><span class="pre">Dictionary&lt;T0,</span> <span class="pre">T1&gt;</span></code>, for fresh type variables <code class="docutils literal"><span class="pre">T0</span></code> and <code class="docutils literal"><span class="pre">T1</span></code>,
and introduces the constraint <code class="docutils literal"><span class="pre">T0</span> <span class="pre">conforms</span> <span class="pre">to</span> <span class="pre">Hashable</span></code>. This allows
the actual key and value types of the dictionary to be determined by
the context of the expression. As noted above for first-class
polymorphic functions, this immediate opening is valid because an
unbound generic type, i.e., one that does not have specified generic
arguments, cannot be used except where the generic arguments can be
inferred.</p>
</div>
</div>
</div>
<div class="section" id="constraint-solving">
<h2>Constraint Solving<a class="headerlink" href="#constraint-solving" title="Permalink to this headline">¶</a></h2>
<p>The primary purpose of the constraint solver is to take a given set of
constraints and determine the most specific type binding for each of the type
variables in the constraint system. As part of this determination, the
constraint solver also resolves overloaded declaration references by
selecting one of the overloads.</p>
<p>Solving the constraint systems generated by the Swift language can, in
the worst case, require exponential time. Even the classic
Hindley-Milner type inference algorithm requires exponential time, and
the Swift type system introduces additional complications, especially
overload resolution. However, the problem size for any particular
expression is still fairly small, and the constraint solver can employ
a number of tricks to improve performance. The <a class="reference internal" href="#performance">Performance</a> section
describes some tricks that have been implemented or are planned, and
it is expected that the solver will be extended with additional tricks
going forward.</p>
<p>This section will focus on the basic ideas behind the design of the
solver, as well as the type rules that it applies.</p>
<div class="section" id="simplification">
<h3>Simplification<a class="headerlink" href="#simplification" title="Permalink to this headline">¶</a></h3>
<p>The constraint generation process introduces a number of constraints
that can be immediately solved, either directly (because the solution
is obvious and trivial) or by breaking the constraint down into a
number of smaller constraints. This process, referred to as
<em>simplification</em>, canonicalizes a constraint system for later stages
of constraint solving. It is also re-invoked each time the constraint
solver makes a guess (at resolving an overload or binding a type
variable, for example), because each such guess often leads to other
simplifications. When all type variables and overloads have been
resolved, simplification terminates the constraint solving process
either by detecting a trivial constraint that is not satisfied (hence,
this is not a proper solution) or by reducing the set of constraints
down to only simple constraints that are trivially satisfied.</p>
<p>The simplification process breaks down constraints into simpler
constraints, and each different kind of constraint is handled by
different rules based on the Swift type system. The constraints fall
into five categories: relational constraints, member constraints,
type properties, conjunctions, and disjunctions. Only the first three
kinds of constraints have interesting simplification rules, and are
discussed in the following sections.</p>
<div class="section" id="relational-constraints">
<h4>Relational Constraints<a class="headerlink" href="#relational-constraints" title="Permalink to this headline">¶</a></h4>
<p>Relational constraints describe a relationship between two types. This
category covers the equality, subtyping, and conversion constraints,
and provides the most common simplifications. The simplification of
relationship constraints proceeds by comparing the structure of the
two types and applying the typing rules of the Swift language to
generate additional constraints. For example, if the constraint is a
conversion constraint:</p>
<div class="highlight-python"><div class="highlight"><pre>A -&gt; B &lt;c C -&gt; D
</pre></div>
</div>
<p>then both types are function types, and we can break down this
constraint into two smaller constraints <code class="docutils literal"><span class="pre">C</span> <span class="pre">&lt;</span> <span class="pre">A</span></code> and <code class="docutils literal"><span class="pre">B</span> <span class="pre">&lt;</span> <span class="pre">D</span></code> by
applying the conversion rule for function types. Similarly, one can
destroy all of the various type constructors&#8212;tuple types, generic
type specializations, lvalue types, etc.&#8212;to produce simpler
requirements, based on the type rules of the language <a class="footnote-reference" href="#id6" id="id2">[2]</a>.</p>
<p>Relational constraints involving a type variable on one or both sides
generally cannot be solved directly. Rather, these constraints inform
the solving process later by providing possible type bindings,
described in the <a class="reference internal" href="#type-variable-bindings">Type Variable Bindings</a> section. The exception is
an equality constraint between two type variables, e.g., <code class="docutils literal"><span class="pre">T0</span> <span class="pre">==</span>
<span class="pre">T1</span></code>. These constraints are simplified by unifying the equivalence
classes of <code class="docutils literal"><span class="pre">T0</span></code> and <code class="docutils literal"><span class="pre">T1</span></code> (using a basic union-find algorithm),
such that the solver need only determine a binding for one of the type
variables (and the other gets the same binding).</p>
</div>
<div class="section" id="member-constraints">
<h4>Member Constraints<a class="headerlink" href="#member-constraints" title="Permalink to this headline">¶</a></h4>
<p>Member constraints specify that a certain type has a member of a given
name and provide a binding for the type of that member. A member
constraint <code class="docutils literal"><span class="pre">A.member</span> <span class="pre">==</span> <span class="pre">B</span></code> can be simplified when the type of <code class="docutils literal"><span class="pre">A</span></code>
is determined to be a nominal or tuple type, in which case name lookup
can resolve the member name to an actual declaration. That declaration
has some type <code class="docutils literal"><span class="pre">C</span></code>, so the member constraint is simplified to the
exact equality constraint <code class="docutils literal"><span class="pre">B</span> <span class="pre">:=</span> <span class="pre">C</span></code>.</p>
<p>The member name may refer to a set of overloaded declarations. In this
case, the type <code class="docutils literal"><span class="pre">C</span></code> is a fresh type variable (call it <code class="docutils literal"><span class="pre">T0</span></code>). A
disjunction constraint is introduced, each term of which new overload
set binds a different declaration&#8217;s type to <code class="docutils literal"><span class="pre">T0</span></code>, as described in
the section on <a class="reference internal" href="#overloading">Overloading</a>.</p>
<p>The kind of member constraint&#8212;type or value&#8212;also affects the
declaration type <code class="docutils literal"><span class="pre">C</span></code>. A type constraint can only refer to member
types, and <code class="docutils literal"><span class="pre">C</span></code> will be the declared type of the named member. A
value constraint, on the other hand, can refer to either a type or a
value, and <code class="docutils literal"><span class="pre">C</span></code> is the type of a reference to that entity. For a
reference to a type, <code class="docutils literal"><span class="pre">C</span></code> will be a metatype of the declared type.</p>
</div>
</div>
<div class="section" id="strategies">
<h3>Strategies<a class="headerlink" href="#strategies" title="Permalink to this headline">¶</a></h3>
<p>The basic approach to constraint solving is to simplify the
constraints until they can no longer be simplified, then produce (and
check) educated guesses about which declaration from an overload set
should be selected or what concrete type should be bound to a given
type variable. Each guess is tested as an assumption, possibly with
other guesses, until the solver either arrives at a solution or
concludes that the guess was incorrect.</p>
<p>Within the implementation, each guess is modeled as an assumption
within a new solver scope. The solver scope inherits all of the
constraints, overload selections, and type variable bindings of its
parent solver scope, then adds one more guess. As such, the solution
space explored by the solver can be viewed as a tree, where the
top-most node is the constraint system generated directly from the
expression. The leaves of the tree are either solutions to the
type-checking problem (where all constraints have been simplified
away) or represent sets of assumptions that do not lead to a solution.</p>
<p>The following sections describe the techniques used by the solver to
produce derived constraint systems that explore the solution space.</p>
<div class="section" id="overload-selection">
<h4>Overload Selection<a class="headerlink" href="#overload-selection" title="Permalink to this headline">¶</a></h4>
<p>Overload selection is the simplest way to make an assumption. For an
overload set that introduced a disjunction constraint
<code class="docutils literal"><span class="pre">T0</span> <span class="pre">:=</span> <span class="pre">A1</span> <span class="pre">or</span> <span class="pre">T0</span> <span class="pre">:=</span> <span class="pre">A2</span> <span class="pre">or</span> <span class="pre">...</span> <span class="pre">or</span> <span class="pre">T0</span> <span class="pre">:=</span> <span class="pre">AN</span></code> into the constraint
system, each term in the disjunction will be visited separately. Each
solver state binds the type variable <code class="docutils literal"><span class="pre">T0</span></code> and explores
whether the selected overload leads to a suitable solution.</p>
</div>
<div class="section" id="type-variable-bindings">
<h4>Type Variable Bindings<a class="headerlink" href="#type-variable-bindings" title="Permalink to this headline">¶</a></h4>
<p>A second way in which the solver makes assumptions is to guess at the
concrete type to which a given type variable should be bound. That
type binding is then introduced in a new, derived constraint system to
determine if the binding is feasible.</p>
<p>The solver does not conjure concrete type bindings from nothing, nor
does it perform an exhaustive search. Rather, it uses the constraints
placed on that type variable to produce potential candidate
types. There are several strategies employed by the solver.</p>
<div class="section" id="meets-and-joins">
<h5>Meets and Joins<a class="headerlink" href="#meets-and-joins" title="Permalink to this headline">¶</a></h5>
<p>A given type variable <code class="docutils literal"><span class="pre">T0</span></code> often has relational constraints
placed on it that relate it to concrete types, e.g., <code class="docutils literal"><span class="pre">T0</span> <span class="pre">&lt;c</span> <span class="pre">Int</span></code> or
<code class="docutils literal"><span class="pre">Float</span> <span class="pre">&lt;c</span> <span class="pre">T0</span></code>. In these cases, we can use the concrete types as a
starting point to make educated guesses for the type <code class="docutils literal"><span class="pre">T0</span></code>.</p>
<p>To determine an appropriate guess, the relational constraints placed
on the type variable are categorized. Given a relational constraint of the form
<code class="docutils literal"><span class="pre">T0</span> <span class="pre">&lt;?</span> <span class="pre">A</span></code> (where <code class="docutils literal"><span class="pre">&lt;?</span></code> is one of <code class="docutils literal"><span class="pre">&lt;</span></code>, <code class="docutils literal"><span class="pre">&lt;t</span></code>, or <code class="docutils literal"><span class="pre">&lt;c</span></code>), where
<code class="docutils literal"><span class="pre">A</span></code> is some concrete type, <code class="docutils literal"><span class="pre">A</span></code> is said to be  &#8220;above&#8221;
<code class="docutils literal"><span class="pre">T0</span></code>. Similarly, given a constraint of the form <code class="docutils literal"><span class="pre">B</span> <span class="pre">&lt;?</span> <span class="pre">T0</span></code> for a
concrete type <code class="docutils literal"><span class="pre">B</span></code>, <code class="docutils literal"><span class="pre">B</span></code> is said to be &#8220;below&#8221; <code class="docutils literal"><span class="pre">T0</span></code>. The
above/below terminologies comes from a visualization of the lattice of
types formed by the conversion relationship, e.g., there is an edge
<code class="docutils literal"><span class="pre">A</span> <span class="pre">-&gt;</span> <span class="pre">B</span></code> in the latter if <code class="docutils literal"><span class="pre">A</span></code> is convertible to <code class="docutils literal"><span class="pre">B</span></code>. <code class="docutils literal"><span class="pre">B</span></code> would
therefore be higher in the lattice than <code class="docutils literal"><span class="pre">A</span></code>, and the topmost element
of the lattice is the element to which all types can be converted,
<code class="docutils literal"><span class="pre">protocol&lt;&gt;</span></code> (often called &#8220;top&#8221;).</p>
<p>The concrete types &#8220;above&#8221; and &#8220;below&#8221; a given type variable provide
bounds on the possible concrete types that can be assigned to that
type variable. The solver computes <a class="footnote-reference" href="#id7" id="id3">[3]</a> the join of the types &#8220;below&#8221;
the type variable, i.e., the most specific (lowest) type to which all
of the types &#8220;below&#8221; can be converted, and uses that join as a
starting guess.</p>
</div>
<div class="section" id="supertype-fallback">
<h5>Supertype Fallback<a class="headerlink" href="#supertype-fallback" title="Permalink to this headline">¶</a></h5>
<p>The join of the &#8220;below&#8221; types computed as a starting point may be too
specific, due to constraints that involve the type variable but
weren&#8217;t simple enough to consider as part of the join. To cope with
such cases, if no solution can be found with the join of the &#8220;below&#8221;
types, the solver creates a new set of derived constraint systems with
weaker assumptions, corresponding to each of the types that the join
is directly convertible to. For example, if the join was some class
<code class="docutils literal"><span class="pre">Derived</span></code>, the supertype fallback would then try the class <code class="docutils literal"><span class="pre">Base</span></code>
from which <code class="docutils literal"><span class="pre">Derived</span></code> directly inherits. This fallback process
continues until the types produced are no longer convertible to the
meet of types &#8220;above&#8221; the type variable, i.e., the least specific
(highest) type from which all of the types &#8220;above&#8221; the type variable
can be converted <a class="footnote-reference" href="#id8" id="id4">[4]</a>.</p>
</div>
<div class="section" id="default-literal-types">
<h5>Default Literal Types<a class="headerlink" href="#default-literal-types" title="Permalink to this headline">¶</a></h5>
<p>If a type variable is bound by a conformance constraint to one of the
literal protocols, &#8220;<code class="docutils literal"><span class="pre">T0</span></code> conforms to <code class="docutils literal"><span class="pre">IntegerLiteralConvertible</span></code>&#8221;,
then the constraint solver will guess that the type variable can be
bound to the default literal type for that protocol. For example,
<code class="docutils literal"><span class="pre">T0</span></code> would get the default integer literal type <code class="docutils literal"><span class="pre">Int</span></code>, allowing
one to type-check expressions with too little type information to
determine the types of these literals, e.g., <code class="docutils literal"><span class="pre">-1</span></code>.</p>
</div>
</div>
</div>
<div class="section" id="comparing-solutions">
<h3>Comparing Solutions<a class="headerlink" href="#comparing-solutions" title="Permalink to this headline">¶</a></h3>
<p>The solver explores a potentially large solution space, and it is
possible that it will find multiple solutions to the constraint system
as given. Such cases are not necessarily ambiguities, because the
solver can then compare the solutions to to determine whether one of
the solutions is better than all of the others. To do so, it computes
a &#8220;score&#8221; for each solution based on a number of factors:</p>
<ul class="simple">
<li>How many user-defined conversions were applied.</li>
<li>How many non-trivial function conversions were applied.</li>
<li>How many literals were given &#8220;non-default&#8221; types.</li>
</ul>
<p>Solutions with smaller scores are considered better solutions. When
two solutions have the same score, the type variables and overload
choices of the two systems are compared to produce a relative score:</p>
<ul class="simple">
<li>If the two solutions have selected different type variable bindings
for a type variable where a &#8220;more specific&#8221; type variable is a
better match, and one of the type variable bindings is a subtype of
the other, the solution with the subtype earns +1.</li>
<li>If an overload set has different selected overloads in the two
solutions, the overloads are compared. If the type of the
overload picked in one solution is a subtype of the type of
the overload picked in the other solution, then first solution earns
+1.</li>
</ul>
<p>The solution with the greater relative score is considered to be
better than the other solution.</p>
</div>
</div>
<div class="section" id="solution-application">
<h2>Solution Application<a class="headerlink" href="#solution-application" title="Permalink to this headline">¶</a></h2>
<p>Once the solver has produced a solution to the constraint system, that
solution must be applied to the original expression to produce a fully
type-checked expression that makes all implicit conversions and
resolved overloads explicit. This application process walks the
expression tree from the leaves to the root, rewriting each expression
node based on the kind of expression:</p>
<dl class="docutils">
<dt><em>Declaration references</em></dt>
<dd>Declaration references are rewritten with the precise type of the
declaration as referenced. For overloaded declaration references, the
<code class="docutils literal"><span class="pre">Overload*Expr</span></code> node is replaced with a simple declaration
reference expression. For references to polymorphic functions or
members of generic types, a <code class="docutils literal"><span class="pre">SpecializeExpr</span></code> node is introduced to
provide substitutions for all of the generic parameters.</dd>
<dt><em>Member references</em></dt>
<dd>References to members are similar to declaration
references. However, they have the added constraint that the base
expression needs to be a reference. Therefore, an rvalue of
non-reference type will be materialized to produce the necessary
reference.</dd>
<dt><em>Literals</em></dt>
<dd>Literals are converted to the appropriate literal type, which
typically involves introducing calls to the witnesses for the
appropriate literal protocols.</dd>
<dt><em>Closures</em></dt>
<dd>Since the closure has acquired a complete function type,
the body of the closure is type-checked with that
complete function type.</dd>
</dl>
<p>The solution application step cannot fail for any type checking rule
modeled by the constraint system. However, there are some failures
that are intentionally left to the solution application phase, such as
a postfix &#8216;!&#8217; applied to a non-optional type.</p>
<div class="section" id="locators">
<h3>Locators<a class="headerlink" href="#locators" title="Permalink to this headline">¶</a></h3>
<p>During constraint generation and solving, numerous constraints are
created, broken apart, and solved. During constraint application as
well as during diagnostics emission, it is important to track the
relationship between the constraints and the actual expressions from
which they originally came. For example, consider the following type
checking problem:</p>
<div class="highlight-python"><div class="highlight"><pre>struct X {
  // user-defined conversions
  func [conversion] __conversion () -&gt; String { /* ... */ }
  func [conversion] __conversion () -&gt; Int { /* ... */ }
}

func f(i : Int, s : String) { }

var x : X
f(10.5, x)
</pre></div>
</div>
<p>This constraint system generates the constraints &#8220;<code class="docutils literal"><span class="pre">T(f)</span></code> ==Fn <code class="docutils literal"><span class="pre">T0</span>
<span class="pre">-&gt;</span> <span class="pre">T1</span></code>&#8221; (for fresh variables <code class="docutils literal"><span class="pre">T0</span></code> and <code class="docutils literal"><span class="pre">T1</span></code>), &#8220;<code class="docutils literal"><span class="pre">(T2,</span> <span class="pre">X)</span> <span class="pre">&lt;c</span>
<span class="pre">T0</span></code>&#8221; (for fresh variable <code class="docutils literal"><span class="pre">T2</span></code>) and &#8220;<code class="docutils literal"><span class="pre">T2</span></code> conforms to
<code class="docutils literal"><span class="pre">FloatLiteralConvertible</span></code>&#8221;. As part of the solution, after <code class="docutils literal"><span class="pre">T0</span></code> is
replaced with <code class="docutils literal"><span class="pre">(i</span> <span class="pre">:</span> <span class="pre">Int,</span> <span class="pre">s</span> <span class="pre">:</span> <span class="pre">String)</span></code>, the second of
these constraints is broken down into &#8220;<code class="docutils literal"><span class="pre">T2</span> <span class="pre">&lt;c</span> <span class="pre">Int</span></code>&#8221; and &#8220;<code class="docutils literal"><span class="pre">X</span> <span class="pre">&lt;c</span>
<span class="pre">String</span></code>&#8221;. These two constraints are interesting for different
reasons: the first will fail, because <code class="docutils literal"><span class="pre">Int</span></code> does not conform to
<code class="docutils literal"><span class="pre">FloatLiteralConvertible</span></code>. The second will succeed by selecting one
of the (overloaded) conversion functions.</p>
<p>In both of these cases, we need to map the actual constraint of
interest back to the expressions they refer to. In the first case, we
want to report not only that the failure occurred because <code class="docutils literal"><span class="pre">Int</span></code> is
not <code class="docutils literal"><span class="pre">FloatLiteralConvertible</span></code>, but we also want to point out where
the <code class="docutils literal"><span class="pre">Int</span></code> type actually came from, i.e., in the parameter. In the
second case, we want to determine which of the overloaded conversion
functions was selected to perform the conversion, so that conversion
function can be called by constraint application if all else succeeds.</p>
<p><em>Locators</em> address both issues by tracking the location and derivation
of constraints. Each locator is anchored at a specific expression,
i.e., the function application <code class="docutils literal"><span class="pre">f(10.5,</span> <span class="pre">x)</span></code>, and contains a path of
zero or more derivation steps from that anchor. For example, the
&#8220;<code class="docutils literal"><span class="pre">T(f)</span></code> ==Fn <code class="docutils literal"><span class="pre">T0</span> <span class="pre">-&gt;</span> <span class="pre">T1</span></code>&#8221; constraint has a locator that is
anchored at the function application and a path with the &#8220;apply
function&#8221; derivation step, meaning that this is the function being
applied. Similarly, the &#8220;<code class="docutils literal"><span class="pre">(T2,</span> <span class="pre">X)</span> <span class="pre">&lt;c</span> <span class="pre">T0</span></code> constraint has a
locator anchored at the function application and a path with the
&#8220;apply argument&#8221; derivation step, meaning that this is the argument
to the function.</p>
<p>When constraints are simplified, the resulting constraints have
locators with longer paths. For example, when a conversion constraint between two
tuples is simplified conversion constraints between the corresponding
tuple elements, the resulting locators refer to specific elements. For
example, the <code class="docutils literal"><span class="pre">T2</span> <span class="pre">&lt;c</span> <span class="pre">Int</span></code> constraint will be anchored at the function
application (still), and have two derivation steps in its path: the
&#8220;apply function&#8221; derivation step from its parent constraint followed
by the &#8220;tuple element 0&#8221; constraint that refers to this specific tuple
element. Similarly, the <code class="docutils literal"><span class="pre">X</span> <span class="pre">&lt;c</span> <span class="pre">String</span></code> constraint will have the same
locator, but with &#8220;tuple element 1&#8221; rather than &#8220;tuple element 0&#8221;. The
<code class="docutils literal"><span class="pre">ConstraintLocator</span></code> type in the constraint solver has a number of
different derivation step kinds (called &#8220;path elements&#8221; in the source)
that describe the various ways in which larger constraints can be
broken down into smaller ones.</p>
<div class="section" id="overload-choices">
<h4>Overload Choices<a class="headerlink" href="#overload-choices" title="Permalink to this headline">¶</a></h4>
<p>Whenever the solver creates a new overload set, that overload set is
associated with a particular locator. Continuing the example from the
parent section, the solver will create an overload set containing the
two user-defined conversions. This overload set is created while
simplifying the constraint <code class="docutils literal"><span class="pre">X</span> <span class="pre">&lt;c</span> <span class="pre">String</span></code>, so it uses the locator
from that constraint extended by a &#8220;conversion member&#8221; derivation
step. The complete locator for this overload set is, therefore:</p>
<div class="highlight-python"><div class="highlight"><pre>function application -&gt; apply argument -&gt; tuple element #1 -&gt; conversion member
</pre></div>
</div>
<p>When the solver selects a particular overload from the overload set,
it records the selected overload based on the locator of the overload
set. When it comes time to perform constraint application, the locator
is recreated based on context (as the bottom-up traversal walks the
expressions to rewrite them with their final types) and used to find
the appropriate conversion to call. The same mechanism is used to
select the appropriate overload when an expression refers directly to
an overloaded function. Additionally, when comparing two solutions to
the same constraint system, overload sets present in both solutions
can be found by comparing the locators for each of the overload
choices made in each solution. Naturally, all of these operations
require locators to be unique, which occurs in the constraint system
itself.</p>
</div>
<div class="section" id="simplifying-locators">
<h4>Simplifying Locators<a class="headerlink" href="#simplifying-locators" title="Permalink to this headline">¶</a></h4>
<p>Locators provide the derivation of location information that follows
the path of the solver, and can be used to query and recover the
important decisions made by the solver. However, the locators
determined by the solver may not directly refer to the most specific
expression for the purposes of identifying the corresponding source
location. For example, the failed constraint &#8220;<code class="docutils literal"><span class="pre">Int</span></code> conforms to
<code class="docutils literal"><span class="pre">FloatLiteralConvertible</span></code>&#8221; can most specifically by centered on the
floating-point literal <code class="docutils literal"><span class="pre">10.5</span></code>, but its locator is:</p>
<div class="highlight-python"><div class="highlight"><pre>function application -&gt; apply argument -&gt; tuple element #0
</pre></div>
</div>
<p>The process of locator simplification maps a locator to its most
specific expression. Essentially, it starts at the anchor of the
locator (in this case, the application <code class="docutils literal"><span class="pre">f(10.5,</span> <span class="pre">x)</span></code>) and then walks
the path, matching derivation steps to subexpressions. The &#8220;function
application&#8221; derivation step extracts the argument (<code class="docutils literal"><span class="pre">(10.5,</span>
<span class="pre">x)</span></code>). Then, the &#8220;tuple element #0&#8221; derivation extracts the tuple
element 0 subexpression, <code class="docutils literal"><span class="pre">10.5</span></code>, at which point we have traversed
the entire path and now have the most specific expression for
source-location purposes.</p>
<p>Simplification does not always exhaust the complete path. For example,
consider a slight modification to our example, so that the argument to
<code class="docutils literal"><span class="pre">f</span></code> is provided by another call, we get a different result
entirely:</p>
<div class="highlight-python"><div class="highlight"><pre>func f(i : Int, s : String) { }
func g() -&gt; (f : Float, x : X) { }

f(g())
</pre></div>
</div>
<p>Here, the failing constraint is <code class="docutils literal"><span class="pre">Float</span> <span class="pre">&lt;c</span> <span class="pre">Int</span></code>, with the same
locator:</p>
<div class="highlight-python"><div class="highlight"><pre>function application -&gt; apply argument -&gt; tuple element #0
</pre></div>
</div>
<p>When we simplify this locator, we start with <code class="docutils literal"><span class="pre">f(g())</span></code>. The &#8220;apply
argument&#8221; derivation step takes us to the argument expression
<code class="docutils literal"><span class="pre">g()</span></code>. Here, however, there is no subexpression for the first tuple
element of <code class="docutils literal"><span class="pre">g()</span></code>, because it&#8217;s simple part of the tuple returned
from <code class="docutils literal"><span class="pre">g</span></code>. At this point, simplification ceases, and creates the
simplified locator:</p>
<div class="highlight-python"><div class="highlight"><pre>function application of g -&gt; tuple element #0
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="performance">
<h2>Performance<a class="headerlink" href="#performance" title="Permalink to this headline">¶</a></h2>
<p>The performance of the type checker is dependent on a number of
factors, but the chief concerns are the size of the solution space
(which is exponential in the worst case) and the effectiveness of the
solver in exploring that solution space. This section describes some
of the techniques used to improve solver performance, many of which
can doubtless be improved.</p>
<div class="section" id="constraint-graph">
<h3>Constraint Graph<a class="headerlink" href="#constraint-graph" title="Permalink to this headline">¶</a></h3>
<p>The constraint graph describes the relationships among type variables
in the constraint system. Each vertex in the constraint graph
corresponds to a single type variable. The edges of the graph
correspond to constraints in the constraint system, relating sets of
type variables together. Technically, this makes the constraint graph
a <em>multigraph</em>, although the internal representation is more akin to a
graph with multiple kinds of edges: each vertex (node) tracks the set
of constraints that mention the given type variable as well as the set
of type variables that are adjacent to this type variable. A vertex
also includes information about the equivalence class corresponding to
a given type variable (when type variables have been merged) or the
binding of a type variable to a specific type.</p>
<p>The constraint graph is critical to a number of solver
optimizations. For example, it is used to compute the connected
components within the constraint graph, so that each connected
component can be solved independently. The partial results from all of
the connected components are then combined into a complete
solution. Additionally, the constraint graph is used to direct
simplification, described below.</p>
</div>
<div class="section" id="simplification-worklist">
<h3>Simplification Worklist<a class="headerlink" href="#simplification-worklist" title="Permalink to this headline">¶</a></h3>
<p>When the solver has attempted a type variable binding, that binding
often leads to additional simplifications in the constraint
system. The solver will query the constraint graph to determine which
constraints mention the type variable and will place those constraints
onto the simplification worklist. If those constraints can be
simplified further, it may lead to additional type variable bindings,
which in turn adds more constraints to the worklist. Once the worklist
is exhausted, simplification has completed. The use of the worklist
eliminates the need to reprocess constraints that could not have
changed because the type variables they mention have not changed.</p>
</div>
<div class="section" id="solver-scopes">
<h3>Solver Scopes<a class="headerlink" href="#solver-scopes" title="Permalink to this headline">¶</a></h3>
<p>The solver proceeds through the solution space in a depth-first
manner. Whenever the solver is about to make a guess&#8212;such as a
speculative type variable binding or the selection of a term from a
disjunction&#8212;it introduces a new solver scope to capture the results
of that assumption. Subsequent solver scopes are nested as the solver
builds up a set of assumptions, eventually leading to either a
solution or an error. When a solution is found, the stack of solver
scopes contains all of the assumptions needed to produce that
solution, and is saved in a separate solution data structure.</p>
<p>The solver scopes themselves are designed to be fairly cheap to create
and destroy. To support this, all of the major data structures used by
the constraint solver have reversible operations, allowing the solver
to easily backtrack. For example, the addition of a constraint to the
constraint graph can be reversed by removing that same constraint. The
constraint graph tracks all such additions in a stack: pushing a new
solver scope stores a marker to the current top of the stack, and
popping that solver scope reverses all of the operations on that stack
until it hits the marker.</p>
</div>
<div class="section" id="online-scoring">
<h3>Online Scoring<a class="headerlink" href="#online-scoring" title="Permalink to this headline">¶</a></h3>
<p>As the solver evaluates potential solutions, it keeps track of the
score of the current solution and of the best complete solution found
thus far. If the score of the current solution is ever greater than
that of the best complete solution, it abandons the current solution
and backtracks to continue its search.</p>
<p>The solver makes some attempt at evaluating cheaper solutions before
more expensive solutions. For example, it will prefer to try normal
conversions before user-defined conversions, prefer the &#8220;default&#8221;
literal types over other literal types, and prefer cheaper conversions
to more expensive conversions. However, some of the rules are fairly
ad hoc, and could benefit from more study.</p>
</div>
<div class="section" id="arena-memory-management">
<h3>Arena Memory Management<a class="headerlink" href="#arena-memory-management" title="Permalink to this headline">¶</a></h3>
<p>Each constraint system introduces its own memory allocation arena,
making allocations cheap and deallocation essentially free. The
allocation arena extends all the way into the AST context, so that
types composed of type variables (e.g., <code class="docutils literal"><span class="pre">T0</span> <span class="pre">-&gt;</span> <span class="pre">T1</span></code>) will be
allocated within the constraint system&#8217;s arena rather than the
permanent arena. Most data structures involved in constraint solving
use this same arena.</p>
</div>
</div>
<div class="section" id="diagnostics">
<h2>Diagnostics<a class="headerlink" href="#diagnostics" title="Permalink to this headline">¶</a></h2>
<p>The diagnostics produced by the type checker are currently
terrible. We plan to do something about this, eventually. We also
believe that we can implement some heroics, such as spell-checking
that takes into account the surrounding expression to only provide
well-typed suggestions.</p>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>It is possible that both overloads will result in a solution,
in which case the solutions will be ranked based on the rules
discussed in the section <a class="reference internal" href="#comparing-solutions">Comparing Solutions</a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>As of the time of this writing, the type rules of Swift have
not specifically been documented outside of the source code. The
constraints-based type checker contains a function <code class="docutils literal"><span class="pre">matchTypes</span></code>
that documents and implements each of these rules. A future revision
of this document will provide a more readily-accessible version.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>More accurately, as of this writing, &#8220;will compute&#8221;. The solver
doesn&#8217;t current compute meets and joins properly. Rather, it
arbitrarily picks one of the constraints &#8220;below&#8221; to start with.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>Again, as of this writing, the solver doesn&#8217;t actually compute
meets and joins, so the solver continues until it runs out of
supertypes to enumerate.</td></tr>
</tbody>
</table>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="DebuggingTheCompiler.html" class="btn btn-neutral float-right" title="Debugging the Swift Compiler" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="SIL.html" class="btn btn-neutral" title="Swift Intermediate Language (SIL)" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright apple.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.1.9',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>