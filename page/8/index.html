<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="terry yang's blog | java | scala | bi" />



  <meta name="keywords" content="Hexo,next" />



  <link rel="alternate" href="/atom.xml" title="yosita" type="application/atom+xml" />



  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="terry yang&apos;s blog | java | scala | bi">
<meta property="og:type" content="website">
<meta property="og:title" content="yosita">
<meta property="og:url" content="http://yoursite.com/page/8/index.html">
<meta property="og:site_name" content="yosita">
<meta property="og:description" content="terry yang&apos;s blog | java | scala | bi">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="yosita">
<meta name="twitter:description" content="terry yang&apos;s blog | java | scala | bi">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>

  <title> yosita </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  

  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?7e8961fdae021b7bf62f2c767bb18c23";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">yosita</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter3/06_Attributes/" itemprop="url">
                第三章-06特性（Attributes）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T11:00:15+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter3/06_Attributes/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter3/06_Attributes/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="特性（Attributes）">特性（Attributes）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/Hawstein" target="_blank" rel="external">Hawstein</a><br>校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>, <a href="https://github.com/stanzhai" target="_blank" rel="external">stanzhai</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/KYawn" target="_blank" rel="external">KYawn</a></p>
<p>2.1<br>翻译：<a href="https://github.com/kevin833752" target="_blank" rel="external">小铁匠Linus</a></p>
</blockquote>
<p>本页内容包括：</p>
<ul>
<li><a href="#declaration_attributes">声明特性</a></li>
<li><a href="#type_attributes">类型特性</a></li>
</ul>
<p>特性提供了关于声明和类型的更多信息。在Swift中有两类特性，用于修饰声明的以及用于修饰类型的。</p>
<p>通过以下方式指定一个特性：符号<code>@</code>后面跟特性名，如果包含参数，则把参数带上：</p>
<blockquote>
<p>@<code>attribute name</code><br>@<code>attribute name</code>(<code>attribute arguments</code>)  </p>
</blockquote>
<p>有些声明特性通过接收参数来指定特性的更多信息以及它是如何修饰一个特定的声明的。这些特性的参数写在小括号内，它们的格式由它们所属的特性来定义。</p>
<p><a name="declaration_attributes"></a></p>
<h2 id="声明特性">声明特性</h2><p>声明特性只能应用于声明。然而，你也可以将<code>noreturn</code>特性应用于函数或方法类型。</p>
<p><code>autoclosure</code></p>
<p>这个特性通过把表达式自动封装成无参数的闭包来延迟表达式的计算。它可以声明返回表达式自身类型的没有参数的方法类型，也可以用于函数参数的声明。含有<code>autoclosure</code>特性的声明同时也具有<code>noescape</code>的特性，除非传递可选参数<code>escaping</code>.关于怎样使用<code>autoclosure</code>特性的例子，参见<a href="./03_Types.html#function_type">函数类型</a>.</p>
<p><code>available</code></p>
<p>将<code>available</code>特性用于声明时，意味着该声明的生命周期会依赖于特定的平台和操作系统版本。</p>
<p><code>available</code>特性经常与参数列表一同出现，该参数列表至少有两个参数，参数之间由逗号分隔。这些参数由以下这些平台名字中的一个起头：</p>
<ul>
<li><code>iOS</code></li>
<li><code>iOSApplicationExtension</code></li>
<li><code>OSX</code></li>
<li><code>OSXApplicationExtension</code></li>
<li><code>watchOS</code></li>
</ul>
<p>当然，你也可以用一个星号(*)来表示，该声明在上面提到的所有平台上都是有效的。</p>
<p>剩下的参数，可以以任何顺序出现，并且可以添加关于声明生命周期的附加信息，包括重要的里程碑。</p>
<ul>
<li><p><code>unavailable</code>参数表示：该声明在特定的平台上是无效的</p>
</li>
<li><p><code>introduced</code>参数表示：该声明第一次被引入时所在平台的版本。格式如下：<br></p><p><code>introduced=version number</code></p><p>这里的<code>version number</code>由一个正的十进制整数或浮点数构成。</p>
</li>
<li><p><code>deprecated</code>参数表示：该声明第一次被建议弃用时所在平台的版本。格式如下：<br></p><p><code>deprecated=version number</code></p><p>这里的<code>version number</code>由一个正的十进制整数或浮点数构成。</p>
</li>
<li><p><code>obsoleted</code>参数表示：该声明第一次被弃用时所在平台的版本。当一个声明被弃用时，它就从此平台中被移除，不能再被使用。格式如下：<br></p><p><code>obsoleted=version number</code></p><p>这里的<code>version number</code>由一个正的十进制整数或浮点数构成。</p>
</li>
<li><p><code>message</code>参数用来提供文本信息。当使用建议弃用或者被弃用的声明时，编译器会抛出错误或警告信息。格式如下：<br></p><p><code>message=message</code></p><p>这里的<code>message</code>由一个字符串文字构成。</p>
</li>
<li><p><code>renamed</code>参数用来提供文本信息，用以表示被重命名的声明的新名字。当使用这个重命名的声明遇到错误时，编译器会显示出该新名字。格式如下：<br></p><p><code>renamed=new name</code></p><p>这里的<code>new name</code>由一个字符串文字构成。</p>
</li>
</ul>
<p>你可以将<code>renamed</code>参数和<code>unavailable</code>参数以及类型别名声明组合使用，以向用户表示：在你的代码中，一个声明已经被重命名。当一个声明的名字在一个框架或者库的不同发布版本间发生变化时，这会相当有用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// First release</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MyProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">// protocol definition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Subsequent release renames MyProtocol</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MyRenamedProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">// protocol definition</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@available(*, unavailable, renamed=<span class="string">"MyRenamedProtocol"</span>)</span><br><span class="line"><span class="keyword">typealias</span> <span class="type">MyProtocol</span> = <span class="type">MyRenamedProtocol</span></span><br></pre></td></tr></table></figure>
<p>你可以在一个单独的声明上使用多个<code>available</code>特性，以详细说明该声明在不同平台上的有效性。编译器只有在当前的目标平台和<code>available</code>特性中指定的平台匹配时，才会使用<code>available</code>特性。</p>
<p>如果<code>available</code>特性除了平台名称参数外，只指定了一个<code>introduced</code>参数，那么可以使用以下简写语法代替：</p>
<p>@available(<code>platform name</code> <code>version number</code>, *)</p>
<p><code>available</code>特性的简写语法可以简明地表达出多个平台的可用性。尽管这两种形式在功能上是相同的，但请尽可能地使用简明语法形式。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@available(iOS <span class="number">8.0</span>, <span class="type">OSX</span> <span class="number">10.10</span>, *)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class definition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>objc</code></p>
<p>该特性用于修饰任何可以在Objective-C中表示的声明。比如，非嵌套类、协议、非泛型枚举（仅限整型值类型）、类和协议的属性和方法（包括<code>getter</code>和<code>setter</code>）、构造器、析构器以及下标。<code>objc</code>特性告诉编译器这个声明可以在Objective-C代码中使用。</p>
<p>标有<code>objc</code>特性的类必须继承自Objective-C中定义的类。如果你将<code>objc</code>特性应用于一个类或协议，它也会隐式地应用于那个类的成员或协议。对于标记了<code>objc</code>特性的类，编译器会隐式地为它的子类添加<code>objc</code>特性。标记了<code>objc</code>特性的协议不能继承没有标记<code>objc</code>的协议。</p>
<p>如果你将<code>objc</code>特性应用于枚举，每一个枚举的<code>case</code>都会以枚举名称和<code>case</code>名称组合的方式暴露在Objective-C代码中。例如：一个名为<code>Venus</code>的<code>case</code>在<code>Planet</code>枚举中，这个<code>case</code>暴露在Objective-C代码中时叫做<code>PlanetVenus</code>。</p>
<p><code>objc</code>特性有一个可选的参数，由标记符组成。当你想把<code>objc</code>所修饰的实体以一个不同的名字暴露给Objective-C时，你就可以使用这个特性参数。你可以使用这个参数来命名类，协议，方法，getters，setters，以及构造器。下面的例子把<code>ExampleClass</code>中<code>enabled</code>属性的getter暴露给Objective-C，名字是<code>isEnabled</code>，而不是它原来的属性名。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">@objc</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleClass</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> enabled: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="preprocessor">@objc</span>(isEnabled) <span class="keyword">get</span> &#123;</span><br><span class="line">        <span class="comment">// Return the appropriate value</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>noescape</code></p>
<p>在函数或者方法声明上使用该特性，它表示参数将不会被存储用作后续的计算，其用来确保不会超出函数调用的生命周期。对于其属性或方法来说，使用<code>noescape</code>声明属性的函数类型不需要显式的使用<code>self.</code>。</p>
<p><code>nonobjc</code></p>
<p>该特性用于方法、属性、下标、或构造器的声明，这些声明本是可以在Objective-C代码中表示的。使用<code>nonobjc</code>特性告诉编译器这个声明不能在Objective-C代码中使用。</p>
<p>可以使用<code>nonobjc</code>特性解决标有<code>objc</code>的类中桥接方法的循环问题，该特性还允许标有<code>objc</code>的类的构造器和方法进行重载(overload)。</p>
<p>标有<code>nonobjc</code>特性的方法不能重写(override)一个标有<code>objc</code>特性的方法。然而，标有<code>objc</code>特性的方法可以重写标有<code>nonobjc</code>特性的方法。同样，标有<code>nonobjc</code>特性的方法不能满足一个需要标有<code>@objc</code>特性的方法的协议。</p>
<p><code>noreturn</code></p>
<p>该特性用于修饰函数或方法声明，表明该函数或方法的对应类型，<code>T</code>，是<code>@noreturn T</code>。你可以用这个特性修饰函数或方法的类型，这样一来，函数或方法就不会返回到它的调用者中去。</p>
<p>对于一个没有用<code>noreturn</code>特性标记的函数或方法，你可以将它重写为用该特性标记的。相反，对于一个已经用<code>noreturn</code>特性标记的函数或方法，你则不可以将它重写为没使用该特性标记的。当你在一个comforming类型中实现一个协议方法时，该规则同样适用。</p>
<p><code>NSApplicationMain</code></p>
<p>在类上使用该特性表示该类是应用程序委托类，使用该特性与调用<code>NSApplicationMain(_:_:)</code>函数并且把该类的名字作为委托类的名字传递给函数的效果相同。</p>
<p>如果你不想使用这个特性，可以提供一个<code>main.swift</code>文件，并且提供一个<code>main()</code>函数去调用<code>NSApplicationMain(_:_:)</code>函数。比如，如果你的应用程序使用一个派生于<code>NSApplication</code>的自定义子类作为主要类，你可以调用<code>NSApplicationMain</code>函数而不是使用该特性。</p>
<p><code>NSCopying</code></p>
<p>该特性用于修饰一个类的存储型变量属性。该特性将使属性的setter与属性值的一个副本合成，这个值由<code>copyWithZone(_:)</code>方法返回，而不是属性本身的值。该属性的类型必需遵循<code>NSCopying</code>协议。</p>
<p><code>NSCopying</code>特性的原理与Objective-C中的<code>copy</code>特性相似。</p>
<p><code>NSManaged</code></p>
<p>该特性用于修饰<code>NSManagedObject</code>子类中的实例方法或存储型变量属性，表明属性的存储和实现由Core Data在运行时基于相关实体描述动态提供。对于标记了<code>NSManaged</code>特性的属性，Core Data也会在运行时提供存储。</p>
<p><code>testable</code></p>
<p>该特性用于<code>import</code>声明可以测试的编译模块，它能访问任何标有<code>internal</code>权限标识符的实体，这和将它声明为<code>public</code>权限标识符有同样的效果。</p>
<p><code>UIApplicationMain</code></p>
<p>在类上使用该特性表示该类是应用程序委托类，使用该特性与调用<code>UIApplicationMain(_:_:)</code>函数并且把该类的名字作为委托类的名字传递给函数的效果相同。</p>
<p>如果你不想使用这个特性，可以提供一个<code>main.swift</code>文件，并且提供一个<code>main</code>函数去调用<code>UIApplicationMain(_:_:)</code>函数。比如，如果你的应用程序使用一个派生于<code>UIApplication</code>的自定义子类作为主要类，你可以调用<code>UIApplicationMain</code>函数而不是使用该特性。</p>
<p><code>warn_unused_result</code></p>
<p>该特性应用于方法或函数声明，当方法或函数被调用，但其结果未被使用时，该特性会让编译器会产生警告。</p>
<p>你可以使用这个特性提供一个警告信息，这个警告信息是关于不正确地使用未变异的方法，这个方法也有一个对应的变异方法。</p>
<p><code>warn_unused_result</code>特性会有选择地采用下面两个参数之一。</p>
<ul>
<li><p><code>message</code>参数用来提供警告信息。在当方法或函数被调用，但其结果未被使用时，会显示警告信息。格式如下：<br></p><p><code>message=message</code></p><p>这里的<code>message</code>由一个字符串文字构成。</p>
</li>
<li><p><code>mutable_variant</code>参数用于提供变异方法的名称，如果未变异方法以一个可变的值被调用而且其结果并未被使用时，应该使用此变异方法。格式如下（方法名有字符串构成）：</p><p><code>mutable_variant=method name</code></p><p><br>比如，Swift标准库同时提供了变异方法<code>sortInPlace()</code>和未变异方法<code>sort()</code>集合，它们的元素生成器符合<code>Comparable</code>协议。如果你调用了<code>sort()</code>方法，而没有使用它的结果，其实很有可能，你是打算使用变异方法<code>sortInPlace()</code>。</p>
</li>
</ul>
<h3 id="Interface_Builder使用的声明特性">Interface Builder使用的声明特性</h3><p>Interface Builder特性是Interface Builder用来与Xcode同步的声明特性。Swift提供了以下的Interface Builder特性：<code>IBAction</code>，<code>IBDesignable</code>，<code>IBInspectable</code>，以及<code>IBOutlet</code>。这些特性与Objective-C中对应的特性在概念上是相同的。</p>
<p><code>IBOutlet</code>和<code>IBInspectable</code>用于修饰一个类的属性声明；<code>IBAction</code>特性用于修饰一个类的方法声明；<code>IBDesignable</code>用于修饰类的声明。</p>
<p><a name="type_attributes"></a></p>
<h2 id="类型特性">类型特性</h2><p>类型特性只能用于修饰类型。然而，你也可以用<code>noreturn</code>特性去修饰函数或方法声明。</p>
<p><code>convention</code></p>
<p>该特性用于函数的类型，它指出函数调用的约定。</p>
<p><code>convention</code>特性总是与下面的参数之一一起出现。</p>
<ul>
<li><p><code>swift</code>参数用于表明一个Swift函数引用。这是Swift中标准的函数值调用约定。</p>
</li>
<li><p><code>block</code>参数用于表明一个Objective-C兼容的块引用。函数值表示为一个块对象的引用，这是一个<code>id-</code>兼容的Objective-C对象，对象中嵌入了调用函数。调用函数使用C的调用约定。</p>
</li>
<li><p><code>c</code>参数用于表明一个C函数引用。函数值没有上下文，这个函数也使用C的调用约定。</p>
</li>
</ul>
<p>使用C函数调用约定的函数也可用作使用Objective-C块调用约定的函数，同时使用Objective-C块调用约定的函数也可用作使用Swift函数调用约定的函数。然而，只有非泛型的全局函数和本地函数或者不使用任何本地变量的闭包可以被用作使用C函数调用约定的函数。</p>
<p><code>noreturn</code></p>
<p>该特性用于修饰函数或方法的类型，表明该函数或方法不会返回到它的调用者中去。你也可以用它标记函数或方法的声明，表示函数或方法的相应类型，<code>T</code>，是<code>@noreturn T</code>。</p>
<blockquote>
<p>特性语法<br><em>特性</em> → <strong>@</strong> <a href="#attribute_name"><em>特性名</em></a> <a href="#attribute_argument_clause"><em>特性参数子句</em></a> (可选)<br><em>特性名</em> → <a href="02_Lexical_Structure.html#identifiers"><em>标识符</em></a><br><em>特性参数子句</em> → <strong>(</strong> <a href="#balanced_tokens"><em>平衡令牌列表</em></a> (可选) <strong>)</strong><br><em>特性(Attributes)列表</em> → <a href="#attribute"><em>特色</em></a> <a href="#attributes"><em>特性(Attributes)列表</em></a> (可选)<br><em>平衡令牌列表</em> → <a href="#balanced_token"><em>平衡令牌</em></a> <a href="#balanced_tokens"><em>平衡令牌列表</em></a> (可选)<br><em>平衡令牌</em> → <strong>(</strong> <a href="#balanced_tokens"><em>平衡令牌列表</em></a> (可选) <strong>)</strong><br><em>平衡令牌</em> → <strong>[</strong> <a href="#balanced_tokens"><em>平衡令牌列表</em></a> (可选) <strong>]</strong><br><em>平衡令牌</em> → <strong>{</strong> <a href="#balanced_tokens"><em>平衡令牌列表</em></a> (可选) <strong>}</strong><br><em>平衡令牌</em> → <strong>任意标识符, 关键字, 字面量或运算符</strong><br><em>平衡令牌</em> → <strong>任意标点除了(, ), [, ], {, 或 }</strong></p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter3/07_Patterns/" itemprop="url">
                第三章-07模式（Patterns）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T11:00:14+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter3/07_Patterns/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter3/07_Patterns/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="模式（Patterns）">模式（Patterns）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/honghaoz" target="_blank" rel="external">honghaoz</a><br>校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>, <a href="https://github.com/stanzhai" target="_blank" rel="external">stanzhai</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/ray16897188" target="_blank" rel="external">ray16897188</a>,</p>
<p>2.1<br>翻译：<a href="https://github.com/WXGBridgeQ" target="_blank" rel="external">BridgeQ</a></p>
</blockquote>
<p>本页内容包括：</p>
<ul>
<li><a href="#wildcard_pattern">通配符模式（Wildcard Pattern）</a></li>
<li><a href="#identifier_pattern">标识符模式（Identifier Pattern）</a></li>
<li><a href="#value-binding_pattern">值绑定模式（Value-Binding Pattern）</a></li>
<li><a href="#tuple_pattern">元组模式（Tuple Pattern）</a></li>
<li><a href="#enumeration_case_pattern">枚举用例模式（Enumeration Case Pattern）</a></li>
<li><a href="#optional_pattern">可选模式（Optional Pattern）</a></li>
<li><a href="#type-casting_pattern">类型转换模式（Type-Casting Pattern）</a></li>
<li><a href="#expression_pattern">表达式模式（Expression Pattern）</a></li>
</ul>
<p>模式（pattern）代表了单个值或者复合值的结构。例如，元组<code>(1, 2)</code>的结构是逗号分隔的，包含两个元素的列表。因为模式代表一种值的结构，而不是特定的某个值，你可以把模式和各种同类型的值匹配起来。比如，<code>(x, y)</code>可以匹配元组<code>(1, 2)</code>，以及任何含两个元素的元组。除了将模式与一个值匹配外，你可以从复合值中提取出部分或全部，然后分别把各个部分和一个常量或变量绑定起来。</p>
<p>swift语言中模式有2个基本的分类：一类能成功和任何值的类型相匹配，另一类在运行时（runtime）和某特定值匹配时可能会失败。</p>
<p>第一类模式用于解构简单变量，常量和可选绑定中的值。此类模式包括通配符模式（wildcard patterns），标识符模式（identifier patterns），以及任何包含了它们的值绑定模式（value binding patterns）或者元祖模式（tuple patterns）。你可以为这类模式指定一个类型标注（type annotation）从而限制它们只能匹配某种特定类型的值。</p>
<p>第二类模式用于全模式匹配，这种情况下你用来相比较的值在运行时可能还不存在。此类模式包括枚举用例模式（enumeration case patterns），可选模式（optional patterns），表达式模式（expression patterns）和类型转换模式（type-casting patterns）。你在<code>switch</code>语句的case标签中，<code>do</code>语句的<code>catch</code>从句中，或者在<code>if, while, guard</code>和<code>for-in</code>语句的case条件句中使用这类模式。</p>
<blockquote>
<p>模式(Patterns) 语法<br><em>模式</em> → <a href="../chapter3/07_Patterns.html#wildcard_pattern"><em>通配符模式</em></a> <a href="../chapter3/03_Types.html#type_annotation"><em>类型标注</em></a> <em>可选</em><br><em>模式</em> → <a href="../chapter3/07_Patterns.html#identifier_pattern"><em>标识符模式</em></a> <a href="../chapter3/03_Types.html#type_annotati(Value Binding"><em>类型标注</em></a>on) <em>可选</em><br><em>模式</em> → <a href="../chapter3/07_Patterns.html#value_binding_pattern"><em>值绑定模式</em></a><br><em>模式</em> → <a href="../chapter3/07_Patterns.html#tuple_pattern"><em>元组模式</em></a> <a href="../chapter3/03_Types.html#type_annotation"><em>类型标注</em></a> <em>可选</em><br><em>模式</em> → <a href="../chapter3/07_Patterns.html#enum_case_pattern"><em>枚举用例模式</em></a><br><em>模式</em> → <a href="../chapter3/07_Patterns.html#optional_pattern"><em>可选模式</em></a><br><em>模式</em> → <a href="../chapter3/07_Patterns.html#type_casting_pattern"><em>类型转换模式</em></a><br><em>模式</em> → <a href="../chapter3/07_Patterns.html#expression_pattern"><em>表达式模式</em></a>  </p>
</blockquote>
<p><a name="wildcard_pattern"></a></p>
<h2 id="通配符模式（Wildcard_Pattern）">通配符模式（Wildcard Pattern）</h2><p>通配符模式由一个下划线（_）构成，且匹配并忽略任何值。当你不在乎被匹配的值时可以使用该模式。例如，下面这段代码在闭区间<code>1...3</code>中循环，每次循环时忽略该区间内的当前值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>...<span class="number">3</span> &#123;</span><br><span class="line">    <span class="comment">// Do something three times.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通配符模式语法<br><em>通配符模式</em> → <strong>_</strong>  </p>
</blockquote>
<p><a name="identifier_pattern"></a></p>
<h2 id="标识符模式（Identifier_Pattern）">标识符模式（Identifier Pattern）</h2><p>标识符模式匹配任何值，并将匹配的值和一个变量或常量绑定起来。例如，在下面的常量声明中，<code>someValue</code>是一个标识符模式，匹配了类型是<code>Int</code>的<code>42</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue = <span class="number">42</span></span><br></pre></td></tr></table></figure>
<p>当匹配成功时，<code>42</code>被绑定（赋值）给常量<code>someValue</code>。</p>
<p>如果一个变量或常量声明的左边的模式是一个标识符模式，那么这个标识符模式是一个隐式的值绑定模式（value-binding pattern）。</p>
<blockquote>
<p>标识符模式语法<br><em>标识符模式</em> → <a href="LexicalStructure.html#identifier"><em>标识符</em></a>  </p>
</blockquote>
<p><a name="value-binding_pattern"></a></p>
<h2 id="值绑定模式（Value-Binding_Pattern）">值绑定模式（Value-Binding Pattern）</h2><p>值绑定模式把匹配到的值绑定给一个变量或常量名。把绑定匹配到的值绑定给常量时，用关键字<code>let</code>,绑定给变量时，用关键字<code>var</code>。</p>
<p>在值绑定模式中的标识符模式会把新命名的变量或常量与匹配值做绑定。例如，你可以拆开一个元组的元素，然后把每个元素绑定到其相应一个的标识符模式中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> point = (<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">switch</span> point &#123;</span><br><span class="line">    <span class="comment">// Bind x and y to the elements of point.</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The point is at (<span class="subst">\(x)</span>, <span class="subst">\(y)</span>)."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// prints "The point is at (3, 2).”</span></span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，<code>let</code>将元组模式<code>(x, y)</code>分配到各个标识符模式。正是由于这么做，<code>switch</code>语句中<code>case let (x, y):</code>和<code>case (let x, let y):</code>匹配到的值是一样的。</p>
<blockquote>
<p>值绑定(Value Binding)模式语法<br><em>值绑定模式</em> → <strong>var</strong> <a href="../chapter3/07_Patterns.html#pattern"><em>模式</em></a> | <strong>let</strong> <a href="../chapter3/07_Patterns.html#pattern"><em>模式</em></a>  </p>
</blockquote>
<p><a name="tuple_pattern"></a></p>
<h2 id="元组模式（Tuple_Pattern）">元组模式（Tuple Pattern）</h2><p>元组模式是逗号分隔的，有零个或多个模式的列表，并被一对圆括号括起来。元组模式匹配相应元组类型的值。</p>
<p>你可以使用类型标注去限制一个元组模式能匹配哪些种元组类型。例如，在常量声明<code>let (x, y): (Int, Int) = (1, 2)</code>中的元组模式<code>(x, y): (Int, Int)</code>只匹配两个元素都是<code>Int</code>这种类型的元组。如果仅需要限制一个元组模式中的某几个元素，只需要直接对这几个元素提供类型标注即可。例如，在<code>let (x: String, y)</code>中的元组模式可以和任何有两个元素，且第一个元素类型是<code>String</code>的元组类型匹配。</p>
<p>当元组模式被用在<code>for-in</code>语句或者变量或常量声明时，它仅可以包含通配符模式，标识符模式，可选模式或者其他包含这些模式的元祖模式。比如下面这段代码就不正确，因为<code>(x, 0)</code>中的元素<code>0</code>是一个表达式模式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> points = [(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">0</span>), (<span class="number">2</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="comment">// This code isn't valid.</span></span><br><span class="line"><span class="keyword">for</span> (x, <span class="number">0</span>) <span class="keyword">in</span> points &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于只包含一个元素的元组，括号是不起作用的。模式只匹配这个单个元素的类型。举例来说，下面3条语句是等效的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>        <span class="comment">// a: Int = 2</span></span><br><span class="line"><span class="keyword">let</span> (a) = <span class="number">2</span>      <span class="comment">// a: Int = 2</span></span><br><span class="line"><span class="keyword">let</span> (a): <span class="type">Int</span> = <span class="number">2</span> <span class="comment">// a: Int = 2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>元组模式语法<br><em>元组模式</em> → <strong>(</strong> <a href="../chapter3/07_Patterns.html#tuple_pattern_element_list"><em>元组模式元素列表</em></a> <em>可选</em> <strong>)</strong><br><em>元组模式元素列表</em> → <a href="../chapter3/07_Patterns.html#tuple_pattern_element"><em>元组模式元素</em></a> | <a href="../chapter3/07_Patterns.html#tuple_pattern_element"><em>元组模式元素</em></a> <strong>,</strong> <a href="../chapter3/07_Patterns.html#tuple_pattern_element_list"><em>元组模式元素列表</em></a><br><em>元组模式元素</em> → <a href="../chapter3/07_Patterns.html#pattern"><em>模式</em></a>  </p>
</blockquote>
<p><a name="enumeration_case_pattern"></a></p>
<h2 id="枚举用例模式（Enumeration_Case_Pattern）">枚举用例模式（Enumeration Case Pattern）</h2><p>一个枚举用例模式匹配现有的某个枚举类型的某个用例（case）。枚举用例模式出现在<code>switch</code>语句中的case标签中，以及<code>if</code>，<code>while</code>，<code>guard</code>和<code>for-in</code>语句的case条件中。</p>
<p>如果你准备匹配的枚举用例有任何关联的值，则相应的枚举用例模式必须指定一个包含每个关联值元素的元组模式。关于使用<code>switch</code>语句来匹配包含关联值枚举用例的例子，请参阅<code>Associated Values</code>.</p>
<blockquote>
<p>枚举用例模式语法<br><em>enum-case-pattern</em> → <a href="../chapter3/03_Types.html#type_identifier"><em>类型标识</em></a> <em>可选</em> <strong>.</strong> <a href="../chapter3/05_Declarations.html#enum_case_name"><em>枚举的case名</em></a> <a href="../chapter3/07_Patterns.html#tuple_pattern"><em>元组模式</em></a> <em>可选</em>  </p>
</blockquote>
<p><a name="optional_pattern"></a></p>
<h2 id="可选模式（Optional_Pattern）">可选模式（Optional Pattern）</h2><p>可选模式与封装在一个<code>Optional(Wrapped)</code>或者一个<code>ExplicitlyUnwrappedOptional(Wrapped)</code>枚举中的<code>Some(Wrapped)</code>用例相匹配。可选模式由一个标识符模式和紧随其后的一个问号组成，在某些情况下表现为枚举用例模式。</p>
<p>由于可选模式是<code>optional</code>和<code>ImplicitlyUnwrappedOptional</code>枚举用例模式的语法糖（syntactic sugar），下面的2种写法是一样的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someOptional: <span class="type">Int</span>? = <span class="number">42</span></span><br><span class="line"><span class="comment">// Match using an enumeration case pattern</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">case</span> .<span class="type">Some</span>(<span class="keyword">let</span> x) = someOptional &#123;</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Match using an optional pattern</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> x? = someOptional &#123;</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个数组的元素是可选类型，可选模式为<code>for-in</code>语句提供了一种在该数组中迭代的简便方式，只为数组中的非空<code>non-nil</code>元素执行循环体。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayOfOptionalInts: [<span class="type">Int</span>?] = [<span class="literal">nil</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="literal">nil</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment">// Match only non-nil values</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">case</span> <span class="keyword">let</span> number? <span class="keyword">in</span> arrayOfOptinalInts &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Found a <span class="subst">\(number)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Found a 2</span></span><br><span class="line"><span class="comment">//Found a 3</span></span><br><span class="line"><span class="comment">//Found a 5</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>可选模式语法<br><em>可选模式</em> → <a href="../chapter3/03_Types.html#type_identifier"><em>标识符模式</em></a> ?</p>
</blockquote>
<p><a name="type-casting_patterns"></a></p>
<h2 id="类型转换模式（Type-Casting_Patterns）">类型转换模式（Type-Casting Patterns）</h2><p>有两种类型转换模式，<code>is</code>模式和<code>as</code>模式。这两种模式只出现在<code>switch</code>语句中的case标签中。<code>is</code>模式和<code>as</code>模式有以下形式：</p>
<blockquote>
<p>is <code>type</code><br><code>pattern</code> as <code>type</code></p>
</blockquote>
<p><code>is</code>模式仅当一个值的类型在运行时（runtime）和<code>is</code>模式右边的指定类型一致 - 或者是该类型的子类 - 的情况下，才会匹配这个值。<code>is</code>模式和<code>is</code>操作符有相似表现，它们都进行类型转换，却舍弃返回的类型。</p>
<p><code>as</code>模式仅当一个值的类型在运行时（runtime）和<code>as</code>模式右边的指定类型一致 - 或者是该类型的子类 - 的情况下，才会匹配这个值。如果匹配成功，被匹配的值的类型被转换成<code>as</code>模式左边指定的模式。</p>
<p>关于使用<code>switch</code>语句来匹配<code>is</code>模式和<code>as</code>模式值的例子，请参阅<code>Type Casting for Any and AnyObject</code>。</p>
<blockquote>
<p>类型转换模式语法<br><em>type-casting-pattern</em> → <a href="../chapter3/07_Patterns.html#is_pattern"><em>is模式</em></a> | <a href="../chapter3/07_Patterns.html#as_pattern"><em>as模式</em></a><br><em>is模式</em> → <strong>is</strong> <a href="../chapter3/03_Types.html#type"><em>类型</em></a><br><em>as模式</em> → <a href="../chapter3/07_Patterns.html#pattern"><em>模式</em></a> <strong>as</strong> <a href="../chapter3/03_Types.html#type"><em>类型</em></a>  </p>
</blockquote>
<p><a name="expression_pattern"></a></p>
<h2 id="表达式模式（Expression_Pattern）">表达式模式（Expression Pattern）</h2><p>一个表达式模式代表了一个表达式的值。表达式模式只出现在<code>switch</code>语句中的<code>case</code>标签中。</p>
<p>由表达式模式所代表的表达式与使用了Swift标准库中<code>~=</code>操作符的输入表达式的值进行比较。如果<code>~=</code>操作符返回<code>true</code>，则匹配成功。默认情况下，<code>~=</code>操作符使用<code>==</code>操作符来比较两个相同类型的值。它也可以将一个整型数值与一个<code>Range</code>对象中的一段整数区间做匹配，正如下面这个例子所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> point = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">switch</span> point &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"(0, 0) is at the origin."</span>)</span><br><span class="line"><span class="keyword">case</span> (-<span class="number">2</span>...<span class="number">2</span>, -<span class="number">2</span>...<span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"(<span class="subst">\(point.<span class="number">0</span>)</span>, <span class="subst">\(point.<span class="number">1</span>)</span>) is near the origin."</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The point is at (<span class="subst">\(point.<span class="number">0</span>)</span>, <span class="subst">\(point.<span class="number">1</span>)</span>)."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// prints "(1, 2) is near the origin.”</span></span><br></pre></td></tr></table></figure>
<p>你可以重载<code>~=</code>操作符来提供自定义的表达式匹配行为。比如你可以重写上面的例子，拿<code>point</code>表达式去比较字符串形式的点。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Overload the ~= operator to match a string with an integer</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> ~=<span class="params">(pattern: String, value: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pattern == <span class="string">"<span class="subst">\(value)</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> point &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="string">"0"</span>, <span class="string">"0"</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"(0, 0) is at the origin."</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The point is at (<span class="subst">\(point.<span class="number">0</span>)</span>, <span class="subst">\(point.<span class="number">1</span>)</span>)."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// prints "(1, 2) is near the origin.”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>表达式模式语法<br><em>表达式模式</em> → <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a>  </p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter3/08_Generic_Parameters_and_Arguments/" itemprop="url">
                第三章-08泛型参数（Generic Parameters and Arguments）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T11:00:13+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter3/08_Generic_Parameters_and_Arguments/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter3/08_Generic_Parameters_and_Arguments/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="泛型参数（Generic_Parameters_and_Arguments）">泛型参数（Generic Parameters and Arguments）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/fd5788" target="_blank" rel="external">fd5788</a><br>校对：<a href="https://github.com/yankuangshi" target="_blank" rel="external">yankuangshi</a>, <a href="https://github.com/stanzhai" target="_blank" rel="external">stanzhai</a></p>
<p>2.0<br>翻译+校对：<a href="https:github.com/wardenNScaiyi" target="_blank" rel="external">wardenNScaiyi</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#generic_parameter">泛型形参子句</a><ul>
<li><a href="#where_clauses">Where 子句</a></li>
</ul>
</li>
<li><a href="#generic_argument">泛型实参子句</a></li>
</ul>
<p>本节涉及泛型类型、泛型函数以及泛型构造器的参数，包括形参和实参。声明泛型类型、函数或构造器时，须指定相应的类型参数。类型参数相当于一个占位符，当实例化泛型类型、调用泛型函数或泛型构造器时，就用具体的类型实参替代之。</p>
<p>关于 Swift 语言的泛型概述，请参阅 <a href="../chapter2/23_Generics.md">泛型</a>。</p>
<p><a name="generic_parameter"></a></p>
<h2 id="泛型形参子句">泛型形参子句</h2><p>泛型形参子句指定泛型类型或函数的类型形参，以及这些参数相关的约束和要求。泛型形参子句用尖括号（<code>&lt;&gt;</code>）包住，并且有以下两种形式：</p>
<blockquote>
<p>&lt;<code>泛型形参列表</code>&gt;<br>&lt;<code>泛型形参列表</code> where <code>类型要求</code>&gt;</p>
</blockquote>
<p>泛型形参列表中泛型形参用逗号分开，其中每一个采用以下形式：</p>
<blockquote>
<p><code>类型形参</code> : <code>约束</code></p>
</blockquote>
<p>泛型形参由两部分组成：类型形参及其后的可选约束。类型形参只是占位符类型（如 <code>T</code>，<code>U</code>，<code>V</code>，<code>Key</code>，<code>Value</code> 等）的名字而已。你可以在泛型类型、函数的其余部分或者构造器声明，包括函数或构造器的签名中使用它（以及它的关联类型）。</p>
<p>约束用于指明该类型形参继承自某个类或者符合某个协议或协议组合。例如，在下面的泛型函数中，泛型形参 <code>T: Comparable</code> 表示任何用于替代类型形参 <code>T</code> 的类型实参必须满足 <code>Comparable</code> 协议。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">simpleMax</span><span class="generics">&lt;T: Comparable&gt;</span><span class="params">(x: T, <span class="number">_</span> y: T)</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如，因为 <code>Int</code> 和 <code>Double</code> 均满足<code>Comparable</code>协议，所以该函数可以接受这两种类型。与泛型类型相反，调用泛型函数或构造器时不需要指定泛型实参子句。类型实参由传递给函数或构造器的实参推断而出。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">simpleMax(<span class="number">17</span>, <span class="number">42</span>) <span class="comment">// T 被推断为 Int 类型</span></span><br><span class="line">simpleMax(<span class="number">3.14159</span>, <span class="number">2.71828</span>) <span class="comment">// T 被推断为 Double 类型</span></span><br></pre></td></tr></table></figure>
<p><a name="where_clauses"></a></p>
<h3 id="Where_子句">Where 子句</h3><p>要想对类型形参及其关联类型指定额外要求，可以在泛型形参列表之后添加 <code>where</code> 子句。<code>where</code> 子句由关键字 <code>where</code> 及其后的用逗号分隔的一个或多个要求组成。</p>
<p><code>where</code> 子句中的要求用于指明该类型形参继承自某个类或符合某个协议或协议组合。尽管 <code>where</code> 子句提供了语法糖使其有助于表达类型形参上的简单约束（如 <code>T: Comparable</code> 等同于 <code>T where T: Comparable</code>，等等），但是依然可以用来对类型形参及其关联类型提供更复杂的约束。如，<code>&lt;T where T: C, T: P&gt;</code> 表示泛型类型 <code>T</code> 继承自类 <code>C</code> 且符合协议 <code>P</code>。</p>
<p>如上所述，可以强制约束类型形参的关联类型符合某个协议。例如 <code>&lt;S: SequenceType where S.Generator.Element: Equatable&gt;</code> 表示 <code>S</code> 符合 <code>SequenceType</code> 协议，而且 <code>S</code> 的关联类型 <code>S.Generator.Element</code> 符合 <code>Eauatable</code> 协议。这种约束确保了序列中的每个元素都是符合 <code>Equatable</code> 协议的。</p>
<p>也可以用操作符 <code>==</code> 来指定两个类型必须相同。例如，泛型形参子句 <code>&lt;S1: SequenceType, S2: SequenceType where S1.Generator.Element == S2.Generator.Element&gt;</code> 表示 <code>S1</code> 和 <code>S2</code> 必须都符合 <code>SequenceType</code> 协议，而且两个序列中的元素类型必须相同。</p>
<p>当然，替代类型形参的类型实参必须满足所有的约束和要求。</p>
<p>泛型函数或构造器可以重载，但在泛型形参子句中的类型形参必须有不同的约束或要求，抑或二者皆不同。当调用重载的泛型函数或构造器时，编译器会根据这些约束来决定调用哪个重载函数或构造器。</p>
<blockquote>
<p>泛型形参子句语法  </p>
</blockquote>
<p><a name="generic-parameter-clause"></a></p>
<blockquote>
<p><em>泛型形参子句</em> → <strong>&lt;</strong> <a href="#generic-parameter-list"><em>泛型形参列表</em></a> <a href="#requirement-clause"><em>约束子句</em></a><sub>可选</sub> <strong>&gt;</strong><br><a name="generic-parameter-list"></a><br><em>泛型形参列表</em> → <a href="#generic-parameter"><em>泛形形参</em></a> | <a href="#generic-parameter"><em>泛形形参</em></a> <strong>,</strong> <a href="#generic-parameter-list"><em>泛型形参列表</em></a><br><a name="generic-parameter"></a><br><em>泛形形参</em> → <a href="03_Types.html#type-name"><em>类型名称</em></a><br><em>泛形形参</em> → <a href="03_Types.html#type-name"><em>类型名称</em></a> <strong>:</strong> <a href="03_Types.html#type-identifier"><em>类型标识符</em></a><br><em>泛形形参</em> → <a href="03_Types.html#type-name"><em>类型名称</em></a> <strong>:</strong> <a href="03_Types.html#protocol-composition-type"><em>协议合成类型</em></a>  </p>
</blockquote>
<p><a name="requirement-clause"></a></p>
<blockquote>
<p><em>约束子句</em> → <strong>where</strong> <a href="#requirement-list"><em>约束列表</em></a><br><a name="requirement-list"></a><br><em>约束列表</em> → <a href="#requirement"><em>约束</em></a> | <a href="#requirement"><em>约束</em></a> <strong>,</strong> <a href="#requirement-list"><em>约束列表</em></a><br><a name="requirement"></a><br><em>约束</em> → <a href="#conformance-requirement"><em>一致性约束</em></a> | <a href="#same-type-requirement"><em>同类型约束</em></a>  </p>
</blockquote>
<p><a name="conformance-requirement"></a></p>
<blockquote>
<p><em>一致性约束</em> → <a href="03_Types.html#type-identifier"><em>类型标识符</em></a> <strong>:</strong> <a href="03_Types.html#type-identifier"><em>类型标识符</em></a><br><em>一致性约束</em> → <a href="03_Types.html#type-identifier"><em>类型标识符</em></a> <strong>:</strong> <a href="03_Types.html#protocol-composition-type"><em>协议合成类型</em></a><br><a name="same-type-requirement"></a><br><em>同类型约束</em> → <a href="03_Types.html#type-identifier"><em>类型标识符</em></a> <strong>==</strong> <a href="03_Types.html#type"><em>类型</em></a>  </p>
</blockquote>
<p><a name="generic_argument"></a></p>
<h2 id="泛型实参子句">泛型实参子句</h2><p>泛型实参子句指定泛型类型的类型实参。泛型实参子句用尖括号（<code>&lt;&gt;</code>）包住，形式如下：</p>
<blockquote>
<p>&lt;<code>泛型实参列表</code>&gt;</p>
</blockquote>
<p>泛型实参列表中类型实参用逗号分开。类型实参是实际具体类型的名字，用来替代泛型类型的泛型形参子句中的相应的类型形参。从而得到泛型类型的一个特化版本。例如，Swift 标准库中的泛型字典类型定义如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dictionary</span>&lt;<span class="title">Key</span>: <span class="title">Hashable</span>, <span class="title">Value</span>&gt;: <span class="title">CollectionType</span>, <span class="title">DictionaryLiteralConvertible</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>泛型 <code>Dictionary</code> 类型的特化版本，<code>Dictionary&lt;String, Int&gt;</code> 就是用具体的 <code>String</code> 和 <code>Int</code> 类型替代泛型类型 <code>Key: Hashable</code> 和 <code>Value</code> 产生的。每一个类型实参必须满足它所替代的泛型形参的所有约束，包括任何 <code>where</code> 子句所指定的额外的关联类型要求。上面的例子中，类型形参 <code>Key</code> 的类型必须符合 <code>Hashable</code> 协议，因此 <code>String</code> 也必须满足 <code>Hashable</code> 协议。</p>
<p>可以用本身就是泛型类型的特化版本的类型实参替代类型形参（假设已满足合适的约束和关联类型要求）。例如，为了生成一个元素类型是整型数组的数组，可以用数组的特化版本 <code>Array&lt;Int&gt;</code> 替代泛型类型 <code>Array&lt;T&gt;</code> 的类型形参 <code>T</code> 来实现。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayOfArrays: <span class="type">Array</span>&lt;<span class="type">Array</span>&lt;<span class="type">Int</span>&gt;&gt; = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br></pre></td></tr></table></figure>
<p>如 <a href="#generic_parameter">泛型形参子句</a> 所述，不能用泛型实参子句来指定泛型函数或构造器的类型实参。</p>
<blockquote>
<p>泛型实参子句语法<br><a name="generic-argument-clause"></a><br><em>泛型实参子句</em> → <strong>&lt;</strong> <a href="#generic-argument-list"><em>泛型实参列表</em></a> <strong>&gt;</strong><br><a name="generic-argument-list"></a><br><em>泛型实参列表</em> → <a href="#generic-argument"><em>泛型实参</em></a> | <a href="#generic-argument"><em>泛型实参</em></a> <strong>,</strong> <a href="#generic-argument-list"><em>泛型实参列表</em></a><br><a name="generic-argument"></a><br><em>泛型实参</em> → <a href="03_Types.html#type"><em>类型</em></a>  </p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter3/09_Summary_of_the_Grammar/" itemprop="url">
                第三章-09语法总结（Summary of the Grammar）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T11:00:12+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter3/09_Summary_of_the_Grammar/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter3/09_Summary_of_the_Grammar/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="语法总结（Summary_of_the_Grammar）">语法总结（Summary of the Grammar）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/stanzhai" target="_blank" rel="external">stanzhai</a><br>校对：<a href="https://github.com/xielingwang" target="_blank" rel="external">xielingwang</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/miaosiqi" target="_blank" rel="external">miaosiqi</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#statements">语句（Statements）</a></li>
<li><a href="#generic_parameters_and_arguments">泛型参数（Generic Parameters and Arguments）</a></li>
<li><a href="#declarations">声明（Declarations）</a></li>
<li><a href="#patterns">模式（Patterns）</a></li>
<li><a href="#attributes">属性（Attributes）</a></li>
<li><a href="#expressions">表达式（Expressions）</a></li>
<li><a href="#lexical_structure">词法结构（Lexical Structure）</a></li>
<li><a href="#types">类型（Types）</a></li>
</ul>
<p><a name="statements"></a></p>
<h2 id="语句">语句</h2><blockquote>
<p>语句语法<br><em>语句</em> → <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a> <strong>;</strong> <em>可选</em><br><em>语句</em> → <a href="../chapter3/05_Declarations.html#declaration"><em>声明</em></a> <strong>;</strong> <em>可选</em><br><em>语句</em> → <a href="../chapter3/10_Statements.html#loop_statement"><em>循环语句</em></a> <strong>;</strong> <em>可选</em><br><em>语句</em> → <a href="../chapter3/10_Statements.html#branch_statement"><em>分支语句</em></a> <strong>;</strong> <em>可选</em><br><em>语句</em> → <a href="../chapter3/10_Statements.html#labeled_statement"><em>标记语句(Labeled Statement)</em></a><br><em>语句</em> → <a href="../chapter3/10_Statements.html#control_transfer_statement"><em>控制转移语句</em></a> <strong>;</strong> <em>可选</em><br><em>语句</em> → <a href="TODO"><em>延迟语句</em></a> <strong>;</strong> <em>可选</em> </p>
<p><em>语句</em> → <a href="TODO"><em>执行语句</em></a> <strong>;</strong> <em>可选</em> </p>
<p><em>多条语句(Statements)</em> → <a href="../chapter3/10_Statements.html#statement"><em>语句</em></a> <a href="../chapter3/10_Statements.html#statements"><em>多条语句(Statements)</em></a> <em>可选</em>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>循环语句语法<br><em>循环语句</em> → <a href="../chapter3/10_Statements.html#for_statement"><em>for语句</em></a><br><em>循环语句</em> → <a href="../chapter3/10_Statements.html#for_in_statement"><em>for-in语句</em></a><br><em>循环语句</em> → <a href="../chapter3/10_Statements.html#wheetatype类型ile_statement"><em>while语句</em></a><br><em>循环语句</em> → <a href="../chapter3/10_Statements.html#do_while_statement"><em>repeat-while语句</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>For 循环语法<br><em>for语句</em> → <strong>for</strong> <a href="../chapter3/10_Statements.html#for_init"><em>for初始条件</em></a> <em>可选</em> <strong>;</strong> <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a> <em>可选</em> <strong>;</strong> <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#code_block"><em>代码块</em></a><br><em>for语句</em> → <strong>for</strong> <strong>(</strong> <a href="../chapter3/10_Statements.html#for_init"><em>for初始条件</em></a> <em>可选</em> <strong>;</strong> <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a> <em>可选</em> <strong>;</strong> <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a> <em>可选</em> <strong>)</strong> <a href="../chapter3/05_Declarations.html#code_block"><em>代码块</em></a><br><em>for初始条件</em> → <a href="../chapter3/05_Declarations.html#variable_declaration"><em>变量声明</em></a> | <a href="../chapter3/04_Expressions.html#expression_list"><em>表达式集</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>For-In 循环语法<br><em>for-in语句</em> → <strong>for case</strong> <em>可选</em> <a href="../chapter3/07_Patterns.html#pattern"><em>模式</em></a> <strong>in</strong> <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a> <a href="../chapter3/05_Declarations.html#code_block"><em>代码块</em></a> <a href="TODO"><em>where从句</em></a> <em>可选</em></p>
</blockquote>
<!-- -->
<blockquote>
<p>While 循环语法<br><em>while语句</em> → <strong>while</strong> <a href="../chapter3/10_Statements.html#while_condition"><em>条件从句</em></a> <a href="../chapter3/05_Declarations.html#code_block"><em>代码块</em></a><br><em>条件从句</em> → <a href="TODO"><em>表达式</em></a></p>
<p><em>条件从句</em> → <a href="TODO"><em>表达式</em></a> <em>,</em> <a href=""><em>表达式集</em></a></p>
<p><em>条件从句</em> → <a href="TODO"><em>表达式集</em></a></p>
<p><em>条件从句</em> → <a href="TODO"><em>可用条件 (availability-condition</em>)</a> <em>|</em> <a href=""><em>表达式集</em></a></p>
<p><em>条件集</em> → <a href="TODO"><em>条件</em></a> <em>|</em> <a href="TODO"><em>条件</em></a> <em>,</em> <a href=""><em>条件集</em></a></p>
<p><em>条件</em> → <a href="TODO"><em>可用条件(availability-condition)</em></a> <em>|</em> <a href="TODO"><em>个例条件(case-condition)</em></a> <em>|</em> <a href="TODO"><em>可选绑定条件(optional-binding-condition)</em></a></p>
<p><em>个例条件(case-condition)</em> → <strong>case</strong> <a href="TODO"><em>模式</em></a> <a href="TODO"><em>构造器</em></a> <a href="TODO"><em>where从句</em></a><em>可选</em> </p>
<p><em>可选绑定条件(optional-binding-condition)</em> → <a href="TODO"><em>可选绑定头(optional-binding-head)</em></a> <a href="TODO"><em>可选绑定连续集(optional-binding-continuation-list)</em></a> <em>可选</em> <a href="TODO"><em>where从句</em></a> <em>可选</em></p>
<p><em>可选绑定头(optional-binding-head)</em> → <strong>let</strong> <a href="TODO"><em>模式 构造器</em></a> <em>|</em> <strong>var</strong>  <a href="TODO"><em>模式 构造器</em></a></p>
<p><em>可选绑定连续集(optional-binding-contiuation-list)</em> → <a href="TODO"><em>可选绑定连续(optional-binding-contiuation)</em></a> <em>|</em> <a href="TODO"><em>可选绑定连续(optional-binding-contiuation)</em></a> <em>，</em> <a href="TODO"><em>可选绑定连续集(optional-binding-contiuation-list)</em></a></p>
<p><em>可选绑定连续(optional-binding-continuation)</em> → <a href="TODO"><em>模式 构造器</em></a> <em>|</em> <a href="TODO"><em>可选绑定头(optional-binding-head)</em></a> </p>
</blockquote>
<!-- -->
<blockquote>
<p>Repeat-While语句语法<br><em>repeat-while-statement</em> → <strong>repeat</strong> <a href="TODO"><em>代码块</em></a> <strong>while</strong> <a href="TODO"><em>表达式</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>分支语句语法<br><em>分支语句</em> → <a href="../chapter3/10_Statements.html#if_statement"><em>if语句</em></a> </p>
<p><em>分支语句</em> → <a href="TODO"><em>guard语句</em></a>  </p>
<p><em>分支语句</em> → <a href="../chapter3/10_Statements.html#switch_statement"><em>switch语句</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>If语句语法<br><em>if语句</em> → <strong>if</strong> <a href="TODO"><em>条件从句</em></a> <a href="TODO"><em>代码块</em></a> <a href="TODO"><em>else从句(Clause)</em></a> <em>可选</em>  </p>
<p><em>else从句(Clause)</em> → <strong>else</strong> <a href="../chapter3/05_Declarations.html#code_block"><em>代码块</em></a> | <strong>else</strong> <a href="../chapter3/10_Statements.html#if_statement"><em>if语句</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>Guard 语句语法<br><em>guard语句</em> → <strong>guard</strong> <a href="TODO"><em>条件从句</em></a> <strong>else</strong> <a href="TODO"><em>代码块</em></a> </p>
</blockquote>
<!-- -->
<blockquote>
<p>Switch语句语法<br><em>switch语句</em> → <strong>switch</strong> <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a> <strong>{</strong> <a href="../chapter3/10_Statements.html#switch_cases"><em>SwitchCase</em></a> <em>可选</em> <strong>}</strong><br><em>SwitchCase集</em> → <a href="../chapter3/10_Statements.html#switch_case"><em>SwitchCase</em></a> <a href="../chapter3/10_Statements.html#switch_cases"><em>SwitchCase集</em></a> <em>可选</em><br><em>SwitchCase</em> → <a href="../chapter3/10_Statements.html#case_label"><em>case标签</em></a> <a href="../chapter3/10_Statements.html#statements"><em>多条语句(Statements)</em></a> | <a href="../chapter3/10_Statements.html#default_label"><em>default标签</em></a> <a href="../chapter3/10_Statements.html#statements"><em>多条语句(Statements)</em></a><br><em>SwitchCase</em> → <a href="../chapter3/10_Statements.html#case_label"><em>case标签</em></a> <strong>;</strong> | <a href="../chapter3/10_Statements.html#default_label"><em>default标签</em></a> <strong>;</strong><br><em>case标签</em> → <strong>case</strong> <a href="../chapter3/10_Statements.html#case_item_list"><em>case项集</em></a> <strong>:</strong><br><em>case项集</em> → <a href="../chapter3/07_Patterns.html#pattern"><em>模式</em></a> <a href="../chapter3/10_Statements.html#guard_clause"><em>where-clause</em></a> <em>可选</em> | <a href="../chapter3/07_Patterns.html#pattern"><em>模式</em></a> <a href="../chapter3/10_Statements.html#guard_clause"><em>where-clause</em></a> <em>可选</em> <strong>,</strong> <a href="../chapter3/10_Statements.html#case_item_list"><em>case项集</em></a><br><em>default标签</em> → <strong>default</strong> <strong>:</strong><br><em>where从句</em> → <strong>where</strong> <a href="TODO"><em>where表达式</em></a><br><em>where表达式</em> → <a href="TODO"><em>表达式</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>标记语句语法<br><em>标记语句(Labeled Statement)</em> → <a href="../chapter3/10_Statements.html#statement_label"><em>语句标签</em></a> <a href="../chapter3/10_Statements.html#loop_statement"><em>循环语句</em></a> | <a href="../chapter3/10_Statements.html#statement_label"><em>语句标签</em></a> <a href="../chapter3/10_Statements.html#switch_statement"><em>if语句</em></a> | <a href="TODY"><em>语句标签</em></a> <a href="TODY"><em>switch语句</em></a><br><em>语句标签</em> → <a href="../chapter3/10_Statements.html#label_name"><em>标签名称</em></a> <strong>:</strong><br><em>标签名称</em> → <a href="../chapter3/02_Lexical_Structure.html#identifier"><em>标识符</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>控制传递语句(Control Transfer Statement) 语法<br><em>控制传递语句</em> → <a href="../chapter3/10_Statements.html#break_statement"><em>break语句</em></a><br><em>控制传递语句</em> → <a href="../chapter3/10_Statements.html#continue_statement"><em>continue语句</em></a><br><em>控制传递语句</em> → <a href="../chapter3/10_Statements.html#fallthrough_statement"><em>fallthrough语句</em></a><br><em>控制传递语句</em> → <a href="../chapter3/10_Statements.html#return_statement"><em>return语句</em></a><br><em>控制传递语句</em> → <a href="TODO"><em>throw语句</em></a> </p>
</blockquote>
<!-- -->
<blockquote>
<p>Break 语句语法<br><em>break语句</em> → <strong>break</strong> <a href="../chapter3/10_Statements.html#label_name"><em>标签名称</em></a> <em>可选</em>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>Continue 语句语法<br><em>continue语句</em> → <strong>continue</strong> <a href="../chapter3/10_Statements.html#label_name"><em>标签名称</em></a> <em>可选</em>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>Fallthrough 语句语法<br><em>fallthrough语句</em> → <strong>fallthrough</strong>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>Return 语句语法<br><em>return语句</em> → <strong>return</strong> <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a> <em>可选</em>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>可用条件(Availability Condition)语法</p>
<p><em>可用条件(availability-condition)</em> → <strong>#available</strong> <strong>(</strong> <a href="TODO"><em>多可用参数</em>(availability-arguments)</a> <strong>)</strong> </p>
<p><em>多可用参数(availability- arguments)</em> → <a href="TODO"><em>可用参数(availability-argument)</em></a>|<a href="TODO"><em>可用参数(availability-argument)</em></a> , <a href="TODO">多可用参数(availability-arguments)</a></p>
<p><em>可用参数(availability- argument)</em> → <a href="TODO"><em>平台名(platform-name)</em></a> <a href="TODO"><em>平台版本(platform-version)</em></a></p>
<p><em>可用参数(availability- argument)</em> → *</p>
<p><em>平台名</em> → <strong>iOS</strong> | <strong>iOSApplicationExtension</strong></p>
<p><em>平台名</em> → <strong>OSX</strong> | <strong>OSXApplicationExtension</strong></p>
<p><em>平台名</em> → <strong>watchOS</strong> </p>
<p><em>平台版本</em> → <a href="TODO"><em>十进制数(decimal-digits)</em></a></p>
<p><em>平台版本</em> → <a href="TODO"><em>十进制数(decimal-digits)</em></a> . <a href="TODO"><em>十进制数(decimal-digits)</em></a> </p>
<p><em>平台版本</em> → <a href="TODO"><em>十进制数(decimal-digits)</em></a> <strong>.</strong> <a href="TODO"><em>十进制数(decimal-digits)</em></a> <strong>.</strong> <a href="TODO"><em>十进制数（decimal-digits)</em></a>)</p>
</blockquote>
<!-- -->
<blockquote>
<p>抛出语句(Throw Statement)语法</p>
<p><em>抛出语句(throw-statement)</em> → <strong>throw</strong> <a href="TODO"><em>表达式(expression)</em></a></p>
</blockquote>
<!-- -->
<blockquote>
<p>延迟语句 (defer-statement)语法</p>
<p><em>延迟语句(defer-statement)</em> → <strong>defer</strong> <a href="TODO"><em>代码块</em></a></p>
</blockquote>
<!-- -->
<blockquote>
<p>执行语句(do-statement)语法</p>
<p><em>执行语句(do-statement)</em> → <strong>do</strong> <a href="TODO"><em>代码块</em></a> <a href="TODO"><em>catch-clauses</em></a> <em>可选</em></p>
<p><em>catch-clauses</em> → <a href="TODO"><em>catch-clause</em></a> <a href="TODO"><em>catch-clauses</em></a> <em>可选</em></p>
<p><em>catch-clauses</em> → <strong>catch</strong> <a href="TODO"><em>模式(pattern)</em></a> <em>可选</em>  <a href="TODO"><em>where-clause</em></a> <em>可选</em> <a href="TODO"><em>代码块(code-block)</em></a> <em>可选</em></p>
</blockquote>
<p><a name="generic_parameters_and_arguments"></a></p>
<h2 id="泛型参数">泛型参数</h2><blockquote>
<p>泛型形参从句(Generic Parameter Clause) 语法<br><em>泛型参数从句</em> → <strong>&lt;</strong> <a href="GenericParametersAndArguments.html#generic_parameter_list"><em>泛型参数集</em></a> <a href="GenericParametersAndArguments.html#requirement_clause"><em>约束从句</em></a> <em>可选</em> <strong>&gt;</strong><br><em>泛型参数集</em> → <a href="GenericParametersAndArguments.html#generic_parameter"><em>泛形参数</em></a> | <a href="GenericParametersAndArguments.html#generic_parameter"><em>泛形参数</em></a> <strong>,</strong> <a href="GenericParametersAndArguments.html#generic_parameter_list"><em>泛型参数集</em></a><br><em>泛形参数</em> → <a href="../chapter3/03_Types.html#type_name"><em>类型名称</em></a><br><em>泛形参数</em> → <a href="../chapter3/03_Types.html#type_name"><em>类型名称</em></a> <strong>:</strong> <a href="../chapter3/03_Types.html#type_identifier"><em>类型标识</em></a><br><em>泛形参数</em> → <a href="../chapter3/03_Types.html#type_name"><em>类型名称</em></a> <strong>:</strong> <a href="../chapter3/03_Types.html#protocol_composition_type"><em>协议合成类型</em></a><br><em>约束从句</em> → <strong>where</strong> <a href="GenericParametersAndArguments.html#requirement_list"><em>约束集</em></a><br><em>约束集</em> → <a href="GenericParametersAndArguments.html#requirement"><em>约束</em></a> | <a href="GenericParametersAndArguments.html#requirement"><em>约束</em></a> <strong>,</strong> <a href="GenericParametersAndArguments.html#requirement_list"><em>约束集</em></a><br><em>约束</em> → <a href="GenericParametersAndArguments.html#conformance_requirement"><em>一致性约束</em></a> | <a href="GenericParametersAndArguments.html#same_type_requirement"><em>同类型约束</em></a><br><em>一致性约束</em> → <a href="../chapter3/03_Types.html#type_identifier"><em>类型标识</em></a> <strong>:</strong> <a href="../chapter3/03_Types.html#type_identifier"><em>类型标识</em></a><br><em>一致性约束</em> → <a href="../chapter3/03_Types.html#type_identifier"><em>类型标识</em></a> <strong>:</strong> <a href="../chapter3/03_Types.html#protocol_composition_type"><em>协议合成类型</em></a><br><em>同类型约束</em> → <a href="../chapter3/03_Types.html#type_identifier"><em>类型标识</em></a> <strong>==</strong> <a href="../chapter3/03_Types.html#type_identifier"><em>类型</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>泛型实参从句语法<br><em>(泛型参数从句Generic Argument Clause)</em> → <strong>&lt;</strong> <a href="GenericParametersAndArguments.html#generic_argument_list"><em>泛型参数集</em></a> <strong>&gt;</strong><br><em>泛型参数集</em> → <a href="GenericParametersAndArguments.html#generic_argument"><em>泛型参数</em></a> | <a href="GenericParametersAndArguments.html#generic_argument"><em>泛型参数</em></a> <strong>,</strong> <a href="GenericParametersAndArguments.html#generic_argument_list"><em>泛型参数集</em></a><br><em>泛型参数</em> → <a href="../chapter3/03_Types.html#type"><em>类型</em></a>  </p>
</blockquote>
<p><a name="declarations"></a></p>
<h2 id="声明_(Declarations)">声明 (Declarations)</h2><blockquote>
<p>声明语法<br><em>声明</em> → <a href="../chapter3/05_Declarations.html#import_declaration"><em>导入声明</em></a><br><em>声明</em> → <a href="../chapter3/05_Declarations.html#constant_declaration"><em>常量声明</em></a><br><em>声明</em> → <a href="../chapter3/05_Declarations.html#variable_declaration"><em>变量声明</em></a><br><em>声明</em> → <a href="../chapter3/05_Declarations.html#typealias_declaration"><em>类型别名声明</em></a><br><em>声明</em> → <a href="../chapter3/05_Declarations.html#function_declaration"><em>函数声明</em></a><br><em>声明</em> → <a href="../chapter3/05_Declarations.html#enum_declaration"><em>枚举声明</em></a><br><em>声明</em> → <a href="../chapter3/05_Declarations.html#struct_declaration"><em>结构体声明</em></a><br><em>声明</em> → <a href="../chapter3/05_Declarations.html#class_declaration"><em>类声明</em></a><br><em>声明</em> → <a href="../chapter3/05_Declarations.html#protocol_declaration"><em>协议声明</em></a><br><em>声明</em> → <a href="../chapter3/05_Declarations.html#initializer_declaration"><em>构造器声明</em></a><br><em>声明</em> → <a href="../chapter3/05_Declarations.html#deinitializer_declaration"><em>析构器声明</em></a><br><em>声明</em> → <a href="../chapter3/05_Declarations.html#extension_declaration"><em>扩展声明</em></a><br><em>声明</em> → <a href="../chapter3/05_Declarations.html#subscript_declaration"><em>下标脚本声明</em></a><br><em>声明</em> → <a href="../chapter3/05_Declarations.html#operator_declaration"><em>运算符声明</em></a><br><em>声明(Declarations)集</em> → <a href="../chapter3/05_Declarations.html#declaration"><em>声明</em></a> <a href="../chapter3/05_Declarations.html#declarations"><em>声明(Declarations)集</em></a> <em>可选</em>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>顶级(Top Level) 声明语法<br><em>顶级声明</em> → <a href="../chapter3/10_Statements.html#statements"><em>多条语句(Statements)</em></a> <em>可选</em>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>代码块语法<br><em>代码块</em> → <strong>{</strong> <a href="../chapter3/10_Statements.html#statements"><em>多条语句(Statements)</em></a> <em>可选</em> <strong>}</strong>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>导入(Import)声明语法<br><em>导入声明</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>属性(Attributes)集</em></a> <em>可选</em> <strong>import</strong> <a href="../chapter3/05_Declarations.html#import_kind"><em>导入类型</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#import_path"><em>导入路径</em></a><br><em>导入类型</em> → <strong>typealias</strong> | <strong>struct</strong> | <strong>class</strong> | <strong>enum</strong> | <strong>protocol</strong> | <strong>var</strong> | <strong>func</strong><br><em>导入路径</em> → <a href="../chapter3/05_Declarations.html#import_path_identifier"><em>导入路径标识符</em></a> | <a href="../chapter3/05_Declarations.html#import_path_identifier"><em>导入路径标识符</em></a> <strong>.</strong> <a href="../chapter3/05_Declarations.html#import_path"><em>导入路径</em></a><br><em>导入路径标识符</em> → <a href="../chapter3/02_Lexical_Structure.html#identifier"><em>标识符</em></a> | <a href="../chapter3/02_Lexical_Structure.html#operator"><em>运算符</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>常数声明语法<br><em>常量声明</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>属性(Attributes)集</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#declaration_specifiers"><em>声明修改符(Modifiers)集</em></a> <em>可选</em> <strong>let</strong> <a href="../chapter3/05_Declarations.html#pattern_initializer_list"><em>模式构造器集</em></a><br><em>模式构造器集</em> → <a href="../chapter3/05_Declarations.html#pattern_initializer"><em>模式构造器</em></a> | <a href="../chapter3/05_Declarations.html#pattern_initializer"><em>模式构造器</em></a> <strong>,</strong> <a href="../chapter3/05_Declarations.html#pattern_initializer_list"><em>模式构造器集</em></a><br><em>模式构造器</em> → <a href="../chapter3/07_Patterns.html#pattern"><em>模式</em></a> <a href="../chapter3/05_Declarations.html#initializer"><em>构造器</em></a> <em>可选</em><br><em>构造器</em> → <strong>=</strong> <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>变量声明语法<br><em>变量声明</em> → <a href="../chapter3/05_Declarations.html#variable_declaration_head"><em>变量声明头(Head)</em></a> <a href="../chapter3/05_Declarations.html#pattern_initializer_list"><em>模式构造器集</em></a><br><em>变量声明</em> → <a href="../chapter3/05_Declarations.html#variable_declaration_head"><em>变量声明头(Head)</em></a> <a href="../chapter3/05_Declarations.html#variable_name"><em>变量名</em></a> <a href="../chapter3/03_Types.html#type_annotation"><em>类型注解</em></a> <a href="../chapter3/05_Declarations.html#code_block"><em>代码块</em></a><br><em>变量声明</em> → <a href="../chapter3/05_Declarations.html#variable_declaration_head"><em>变量声明头(Head)</em></a> <a href="../chapter3/05_Declarations.html#variable_name"><em>变量名</em></a> <a href="../chapter3/03_Types.html#type_annotation"><em>类型注解</em></a> <a href="../chapter3/05_Declarations.html#getter_setter_block"><em>getter-setter块</em></a><br><em>变量声明</em> → <a href="../chapter3/05_Declarations.html#variable_declaration_head"><em>变量声明头(Head)</em></a> <a href="../chapter3/05_Declarations.html#variable_name"><em>变量名</em></a> <a href="../chapter3/03_Types.html#type_annotation"><em>类型注解</em></a> <a href="../chapter3/05_Declarations.html#getter_setter_keyword_block"><em>getter-setter关键字(Keyword)块</em></a><br><em>变量声明</em> → <a href="../chapter3/05_Declarations.html#variable_declaration_head"><em>变量声明头(Head)</em></a> <a href="../chapter3/05_Declarations.html#variable_name"><em>变量名</em></a> <a href="../chapter3/03_Types.html#type_annotation"><em>类型注解</em></a> <a href="../chapter3/05_Declarations.html#initializer"><em>构造器</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#willSet_didSet_block"><em>willSet-didSet代码块</em></a><br><em>变量声明头(Head)</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>属性(Attributes)集</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#declaration_specifiers"><em>声明修改符(Modifers)集</em></a> <em>可选</em> <strong>var</strong><br><em>变量名称</em> → <a href="../chapter3/02_Lexical_Structure.html#identifier"><em>标识符</em></a><br><em>getter-setter块</em> → <strong>{</strong> <a href="../chapter3/05_Declarations.html#getter_clause"><em>getter从句</em></a> <a href="../chapter3/05_Declarations.html#setter_clause"><em>setter从句</em></a> <em>可选</em> <strong>}</strong><br><em>getter-setter块</em> → <strong>{</strong> <a href="../chapter3/05_Declarations.html#setter_clause"><em>setter从句</em></a> <a href="../chapter3/05_Declarations.html#getter_clause"><em>getter从句</em></a> <strong>}</strong><br><em>getter从句</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>属性(Attributes)集</em></a> <em>可选</em> <strong>get</strong> <a href="../chapter3/05_Declarations.html#code_block"><em>代码块</em></a><br><em>setter从句</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>属性(Attributes)集</em></a> <em>可选</em> <strong>set</strong> <a href="../chapter3/05_Declarations.html#setter_name"><em>setter名称</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#code_block"><em>代码块</em></a><br><em>setter名称</em> → <strong>(</strong> <a href="../chapter3/02_Lexical_Structure.html#identifier"><em>标识符</em></a> <strong>)</strong><br><em>getter-setter关键字(Keyword)块</em> → <strong>{</strong> <a href="../chapter3/05_Declarations.html#getter_keyword_clause"><em>getter关键字(Keyword)从句</em></a> <a href="../chapter3/05_Declarations.html#setter_keyword_clause"><em>setter关键字(Keyword)从句</em></a> <em>可选</em> <strong>}</strong><br><em>getter-setter关键字(Keyword)块</em> → <strong>{</strong> <a href="../chapter3/05_Declarations.html#setter_keyword_clause"><em>setter关键字(Keyword)从句</em></a> <a href="../chapter3/05_Declarations.html#getter_keyword_clause"><em>getter关键字(Keyword)从句</em></a> <strong>}</strong><br><em>getter关键字(Keyword)从句</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>属性(Attributes)集</em></a> <em>可选</em> <strong>get</strong><br><em>setter关键字(Keyword)从句</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>属性(Attributes)集</em></a> <em>可选</em> <strong>set</strong><br><em>willSet-didSet代码块</em> → <strong>{</strong> <a href="../chapter3/05_Declarations.html#willSet_clause"><em>willSet从句</em></a> <a href="../chapter3/05_Declarations.html#didSet_clause"><em>didSet从句</em></a> <em>可选</em> <strong>}</strong><br><em>willSet-didSet代码块</em> → <strong>{</strong> <a href="../chapter3/05_Declarations.html#didSet_clause"><em>didSet从句</em></a> <a href="../chapter3/05_Declarations.html#willSet_clause"><em>willSet从句</em></a> <strong>}</strong><br><em>willSet从句</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>属性(Attributes)集</em></a> <em>可选</em> <strong>willSet</strong> <a href="../chapter3/05_Declarations.html#setter_name"><em>setter名称</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#code_block"><em>代码块</em></a><br><em>didSet从句</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>属性(Attributes)集</em></a> <em>可选</em> <strong>didSet</strong> <a href="../chapter3/05_Declarations.html#setter_name"><em>setter名称</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#code_block"><em>代码块</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>类型别名声明语法<br><em>类型别名声明</em> → <a href="../chapter3/05_Declarations.html#typealias_head"><em>类型别名头(Head)</em></a> <a href="../chapter3/05_Declarations.html#typealias_assignment"><em>类型别名赋值</em></a><br><em>类型别名头(Head)</em> → <a href="TODO"><em>属性</em></a> <em>可选</em> <a href="TODO"><em>访问级别修改符(access-level-modifier)</em></a> <strong>typealias</strong> <a href="../chapter3/05_Declarations.html#typealias_name"><em>类型别名名称</em></a><br><em>类型别名名称</em> → <a href="../chapter3/02_Lexical_Structure.html#identifier"><em>标识符</em></a><br><em>类型别名赋值</em> → <strong>=</strong> <a href="../chapter3/03_Types.html#type"><em>类型</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>函数声明语法<br><em>函数声明</em> → <a href="../chapter3/05_Declarations.html#function_head"><em>函数头</em></a> <a href="../chapter3/05_Declarations.html#function_name"><em>函数名</em></a> <a href="GenericParametersAndArguments.html#generic_parameter_clause"><em>泛型参数从句</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#function_signature"><em>函数签名(Signature)</em></a> <a href="../chapter3/05_Declarations.html#function_body"><em>函数体</em></a><br><em>函数头</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>属性(Attributes)集</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#declaration_specifiers"><em>声明描述符(Specifiers)集</em></a> <em>可选</em> <strong>func</strong><br><em>函数名</em> → <a href="../chapter3/02_Lexical_Structure.html#identifier"><em>标识符</em></a> | <a href="../chapter3/02_Lexical_Structure.html#operator"><em>运算符</em></a><br><em>函数签名(Signature)</em> → <a href="../chapter3/05_Declarations.html#parameter_clauses"><em>parameter-clauses</em></a> <strong>throws</strong> <em>可选</em> <a href="../chapter3/05_Declarations.html#function_result"><em>函数结果</em></a> <em>可选</em> </p>
<p><em>函数签名(Signature)</em> → <a href="../chapter3/05_Declarations.html#parameter_clauses"><em>parameter-clauses</em></a> <strong>rethrows</strong> <a href="../chapter3/05_Declarations.html#function_result"><em>函数结果</em></a> <em>可选</em><br><em>函数结果</em> → <strong>-&gt;</strong> <a href="../chapter3/06_Attributes.html#attributes"><em>属性(Attributes)集</em></a> <em>可选</em> <a href="../chapter3/03_Types.html#type"><em>类型</em></a><br><em>函数体</em> → <a href="../chapter3/05_Declarations.html#code_block"><em>代码块</em></a><br><em>参数从句</em> → <a href="../chapter3/05_Declarations.html#parameter_clause"><em>参数从句</em></a> <a href="../chapter3/05_Declarations.html#parameter_clauses"><em>parameter-clauses</em></a> <em>可选</em><br><em>参数从句</em> → <strong>(</strong> <strong>)</strong> | <strong>(</strong> <a href="../chapter3/05_Declarations.html#parameter_list"><em>参数集</em></a> <strong>…</strong> <em>可选</em> <strong>)</strong><br><em>参数集</em> → <a href="../chapter3/05_Declarations.html#parameter"><em>参数</em></a> | <a href="../chapter3/05_Declarations.html#parameter"><em>参数</em></a> <strong>,</strong> <a href="../chapter3/05_Declarations.html#parameter_list"><em>参数集</em></a><br><em>参数</em> → <strong>inout</strong> <em>可选</em> <strong>let</strong> <em>可选</em> <a href="../chapter3/05_Declarations.html#parameter_name"><em>外部参数名</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#local_parameter_name"><em>本地参数名</em></a> <em>可选</em> <a href="../chapter3/03_Types.html#type_annotation"><em>类型注解</em></a> <a href="../chapter3/05_Declarations.html#default_argument_clause"><em>默认参数从句</em></a> <em>可选</em><br><em>参数</em> → <strong>inout</strong> <em>可选</em> <strong>var</strong> <a href="../chapter3/05_Declarations.html#parameter_name"><em>外部参数名</em></a> <a href="../chapter3/05_Declarations.html#local_parameter_name"><em>本地参数名</em></a> <em>可选</em> <a href="../chapter3/03_Types.html#type_annotation"><em>类型注解</em></a> <a href="../chapter3/05_Declarations.html#default_argument_clause"><em>默认参数从句</em></a> <em>可选</em><br><em>参数</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>属性(Attributes)集</em></a> <em>可选</em> <a href="../chapter3/03_Types.html#type"><em>类型</em></a><br><em>外部参数名</em> → <a href="../chapter3/02_Lexical_Structure.html#identifier"><em>标识符</em></a> | <strong>_</strong><br><em>本地参数名</em> → <a href="../chapter3/02_Lexical_Structure.html#identifier"><em>标识符</em></a> | <strong>_</strong><br><em>默认参数从句</em> → <strong>=</strong> <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>枚举声明语法<br><em>枚举声明</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>属性(Attributes)集</em></a> <em>可选</em> <a href="TODO"><em>访问级别修改器(access-level-modifier)</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#union_style_enum"><em>联合式枚举</em></a> </p>
<p><em>枚举声明</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>属性(Attributes)集</em></a> <em>可选</em> <a href="TODO"><em>访问级别修改器(access-level-modifier)</em></a> <em>可选</em> <a href="TODO"><em>原始值式枚举(raw-value-style-enum)</em></a></p>
<p><em>联合式枚举</em> → <strong>enum</strong> <a href="../chapter3/05_Declarations.html#enum_name"><em>枚举名</em></a> <a href="GenericParametersAndArguments.html#generic_parameter_clause"><em>泛型参数从句</em></a> <em>可选</em> <a href="TODO"><em>类型继承从句(type-inheritance-clause)</em></a> <em>可选</em> <strong>{</strong> <a href="../chapter3/05_Declarations.html#union_style_enum_members"><em>联合样式枚举成员</em></a> <em>可选</em> <strong>}</strong>  </p>
<p><em>联合样式枚举成员</em> → <a href="../chapter3/05_Declarations.html#union_style_enum_member"><em>union-style-enum-member</em></a> <a href="../chapter3/05_Declarations.html#union_style_enum_members"><em>联合样式枚举成员</em></a> <em>可选</em>  </p>
<p><em>联合样式枚举成员</em> → <a href="../chapter3/05_Declarations.html#declaration"><em>声明</em></a> | <a href="../chapter3/05_Declarations.html#union_style_enum_case_clause"><em>联合式(Union Style)的枚举case从句</em></a>  </p>
<p><em>联合式(Union Style)的枚举case从句</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>属性(Attributes)集</em></a> <em>可选</em> <strong>case</strong> <a href="../chapter3/05_Declarations.html#union_style_enum_case_list"><em>联合式(Union Style)的枚举case集</em></a><br><em>联合式(Union Style)的枚举case集</em> → <a href="../chapter3/05_Declarations.html#union_style_enum_case"><em>联合式(Union Style)的case</em></a> | <a href="../chapter3/05_Declarations.html#union_style_enum_case"><em>联合式(Union Style)的case</em></a> <strong>,</strong> <a href="../chapter3/05_Declarations.html#union_style_enum_case_list"><em>联合式(Union Style)的枚举case集</em></a><br><em>联合式(Union Style)的枚举case</em> → <a href="../chapter3/05_Declarations.html#enum_case_name"><em>枚举的case名</em></a> <a href="../chapter3/03_Types.html#tuple_type"><em>元组类型</em></a> <em>可选</em><br><em>枚举名</em> → <a href="../chapter3/02_Lexical_Structure.html#identifier"><em>标识符</em></a><br><em>枚举的case名</em> → <a href="../chapter3/02_Lexical_Structure.html#identifier"><em>标识符</em></a><br><em>原始值式枚举</em> → <strong>enum</strong> <a href="../chapter3/05_Declarations.html#enum_name"><em>枚举名</em></a> <a href="GenericParametersAndArguments.html#generic_parameter_clause"><em>泛型参数从句</em></a> <em>可选</em> <strong>:</strong> <a href="../chapter3/03_Types.html#type_identifier"><em>类型标识</em></a> <strong>{</strong> <a href="../chapter3/05_Declarations.html#raw_value_style_enum_members"><em>原始值式枚举成员集</em></a> <em>可选</em> <strong>}</strong><br><em>原始值式枚举成员集</em> → <a href="../chapter3/05_Declarations.html#raw_value_style_enum_member"><em>原始值式枚举成员</em></a> <a href="../chapter3/05_Declarations.html#raw_value_style_enum_members"><em>原始值式枚举成员集</em></a> <em>可选</em><br><em>原始值式枚举成员</em> → <a href="../chapter3/05_Declarations.html#declaration"><em>声明</em></a> | <a href="../chapter3/05_Declarations.html#raw_value_style_enum_case_clause"><em>原始值式枚举case从句</em></a><br><em>原始值式枚举case从句</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>属性(Attributes)集</em></a> <em>可选</em> <strong>case</strong> <a href="../chapter3/05_Declarations.html#raw_value_style_enum_case_list"><em>原始值式枚举case集</em></a><br><em>原始值式枚举case集</em> → <a href="../chapter3/05_Declarations.html#raw_value_style_enum_case"><em>原始值式枚举case</em></a> | <a href="../chapter3/05_Declarations.html#raw_value_style_enum_case"><em>原始值式枚举case</em></a> <strong>,</strong> <a href="../chapter3/05_Declarations.html#raw_value_style_enum_case_list"><em>原始值式枚举case集</em></a><br><em>原始值式枚举case</em> → <a href="../chapter3/05_Declarations.html#enum_case_name"><em>枚举的case名</em></a> <a href="../chapter3/05_Declarations.html#raw_value_assignment"><em>原始值赋值</em></a> <em>可选</em><br><em>原始值赋值</em> → <strong>=</strong> <a href="../chapter3/02_Lexical_Structure.html#literal"><em>字面量</em></a><br><em>原始值字面量(raw-value-literal)</em> → <a href="TODO"><em>数值字面量</em></a> | <a href="TODO"><em>字符串字面量</em></a> | <a href="TODO"><em>布尔字面量</em></a></p>
</blockquote>
<!-- -->
<blockquote>
<p>结构体声明语法<br><em>结构体声明</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>属性(Attributes)集</em></a> <em>可选</em> <a href="TODO"><em>访问级别修改器(access-level-modifier)</em></a> <em>可选</em> <strong>struct</strong> <a href="../chapter3/05_Declarations.html#struct_name"><em>结构体名称</em></a> <a href="GenericParametersAndArguments.html#generic_parameter_clause"><em>泛型参数从句</em></a> <em>可选</em> <a href="../chapter3/03_Types.html#type_inheritance_clause"><em>类型继承从句</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#struct_body"><em>结构体主体</em></a><br><em>结构体名称</em> → <a href="../chapter3/02_Lexical_Structure.html#identifier"><em>标识符</em></a><br><em>结构体主体</em> → <strong>{</strong> <a href="../chapter3/05_Declarations.html#declarations"><em>声明(Declarations)集</em></a> <em>可选</em> <strong>}</strong>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>类声明语法<br><em>类声明</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>属性(Attributes)集</em></a> <em>可选</em> <a href="TODO"><em>访问级别修改器(access-level-modifier)</em></a> <strong>class</strong> <a href="../chapter3/05_Declarations.html#class_name"><em>类名</em></a> <a href="GenericParametersAndArguments.html#generic_parameter_clause"><em>泛型参数从句</em></a> <em>可选</em> <a href="../chapter3/03_Types.html#type_inheritance_clause"><em>类型继承从句</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#class_body"><em>类主体</em></a><br><em>类名</em> → <a href="../chapter3/02_Lexical_Structure.html#identifier"><em>标识符</em></a><br><em>类主体</em> → <strong>{</strong> <a href="../chapter3/05_Declarations.html#declarations"><em>声明(Declarations)集</em></a> <em>可选</em> <strong>}</strong>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>协议(Protocol)声明语法<br><em>协议声明</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>属性(Attributes)集</em></a> <em>可选</em><a href="TODO"><em>访问级别修改器(access-level-modifier)</em></a>  <strong>protocol</strong> <a href="../chapter3/05_Declarations.html#protocol_name"><em>协议名</em></a> <a href="../chapter3/03_Types.html#type_inheritance_clause"><em>类型继承从句</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#protocol_body"><em>协议主体</em></a><br><em>协议名</em> → <a href="../chapter3/02_Lexical_Structure.html#identifier"><em>标识符</em></a><br><em>协议主体</em> → <strong>{</strong> <a href="../chapter3/05_Declarations.html#protocol_member_declarations"><em>协议成员声明(Declarations)集</em></a> <em>可选</em> <strong>}</strong><br><em>协议成员声明</em> → <a href="../chapter3/05_Declarations.html#protocol_property_declaration"><em>协议属性声明</em></a><br><em>协议成员声明</em> → <a href="../chapter3/05_Declarations.html#protocol_method_declaration"><em>协议方法声明</em></a><br><em>协议成员声明</em> → <a href="../chapter3/05_Declarations.html#protocol_initializer_declaration"><em>协议构造器声明</em></a><br><em>协议成员声明</em> → <a href="../chapter3/05_Declarations.html#protocol_subscript_declaration"><em>协议下标脚本声明</em></a><br><em>协议成员声明</em> → <a href="../chapter3/05_Declarations.html#protocol_associated_type_declaration"><em>协议关联类型声明</em></a><br><em>协议成员声明(Declarations)集</em> → <a href="../chapter3/05_Declarations.html#protocol_member_declaration"><em>协议成员声明</em></a> <a href="../chapter3/05_Declarations.html#protocol_member_declarations"><em>协议成员声明(Declarations)集</em></a> <em>可选</em>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>协议属性声明语法<br><em>协议属性声明</em> → <a href="../chapter3/05_Declarations.html#variable_declaration_head"><em>变量声明头(Head)</em></a> <a href="../chapter3/05_Declarations.html#variable_name"><em>变量名</em></a> <a href="../chapter3/03_Types.html#type_annotation"><em>类型注解</em></a> <a href="../chapter3/05_Declarations.html#getter_setter_keyword_block"><em>getter-setter关键字(Keyword)块</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>协议方法声明语法<br><em>协议方法声明</em> → <a href="../chapter3/05_Declarations.html#function_head"><em>函数头</em></a> <a href="../chapter3/05_Declarations.html#function_name"><em>函数名</em></a> <a href="GenericParametersAndArguments.html#generic_parameter_clause"><em>泛型参数从句</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#function_signature"><em>函数签名(Signature)</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>协议构造器声明语法<br><em>协议构造器声明</em> → <a href="../chapter3/05_Declarations.html#initializer_head"><em>构造器头(Head)</em></a> <a href="GenericParametersAndArguments.html#generic_parameter_clause"><em>泛型参数从句</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#parameter_clause"><em>参数从句</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>协议下标脚本声明语法<br><em>协议下标脚本声明</em> → <a href="../chapter3/05_Declarations.html#subscript_head"><em>下标脚本头(Head)</em></a> <a href="../chapter3/05_Declarations.html#subscript_result"><em>下标脚本结果(Result)</em></a> <a href="../chapter3/05_Declarations.html#getter_setter_keyword_block"><em>getter-setter关键字(Keyword)块</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>协议关联类型声明语法<br><em>协议关联类型声明</em> → <a href="../chapter3/05_Declarations.html#typealias_head"><em>类型别名头(Head)</em></a> <a href="../chapter3/03_Types.html#type_inheritance_clause"><em>类型继承从句</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#typealias_assignment"><em>类型别名赋值</em></a> <em>可选</em>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>构造器声明语法<br><em>构造器声明</em> → <a href="../chapter3/05_Declarations.html#initializer_head"><em>构造器头(Head)</em></a> <a href="GenericParametersAndArguments.html#generic_parameter_clause"><em>泛型参数从句</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#parameter_clause"><em>参数从句</em></a> <a href="../chapter3/05_Declarations.html#initializer_body"><em>构造器主体</em></a><br><em>构造器头(Head)</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>属性(Attributes)集</em></a> <em>可选</em> <a href="TODO"><em>声明修改器集(declaration-modifiers)</em></a> <em>可选</em>  <strong>init</strong><br><em>构造器头(Head)</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>属性(Attributes)集</em></a> <em>可选</em> <a href="TODO"><em>声明修改器集(declaration-modifiers)</em></a> <em>可选</em>  <strong>init ?</strong></p>
<p><em>构造器头(Head)</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>属性(Attributes)集</em></a> <em>可选</em> <a href="TODO"><em>声明修改器集(declaration-modifiers)</em></a> <em>可选</em>  <strong>init !</strong>    </p>
<p><em>构造器主体</em> → <a href="../chapter3/05_Declarations.html#code_block"><em>代码块</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>析构器声明语法<br><em>析构器声明</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>属性(Attributes)集</em></a> <em>可选</em> <strong>deinit</strong> <a href="../chapter3/05_Declarations.html#code_block"><em>代码块</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>扩展(Extension)声明语法<br><em>扩展声明</em> → <a href="TODO"><em>访问级别修改器</em></a> <em>可选</em> <strong>extension</strong> <a href="../chapter3/03_Types.html#type_identifier"><em>类型标识</em></a> <a href="../chapter3/03_Types.html#type_inheritance_clause"><em>类型继承从句</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#extension_body"><em>extension-body</em></a><br><em>extension-body</em> → <strong>{</strong> <a href="../chapter3/05_Declarations.html#declarations"><em>声明(Declarations)集</em></a> <em>可选</em> <strong>}</strong>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>下标脚本声明语法<br><em>下标脚本声明</em> → <a href="../chapter3/05_Declarations.html#subscript_head"><em>下标脚本头(Head)</em></a> <a href="../chapter3/05_Declarations.html#subscript_result"><em>下标脚本结果(Result)</em></a> <a href="../chapter3/05_Declarations.html#code_block"><em>代码块</em></a><br><em>下标脚本声明</em> → <a href="../chapter3/05_Declarations.html#subscript_head"><em>下标脚本头(Head)</em></a> <a href="../chapter3/05_Declarations.html#subscript_result"><em>下标脚本结果(Result)</em></a> <a href="../chapter3/05_Declarations.html#getter_setter_block"><em>getter-setter块</em></a><br><em>下标脚本声明</em> → <a href="../chapter3/05_Declarations.html#subscript_head"><em>下标脚本头(Head)</em></a> <a href="../chapter3/05_Declarations.html#subscript_result"><em>下标脚本结果(Result)</em></a> <a href="../chapter3/05_Declarations.html#getter_setter_keyword_block"><em>getter-setter关键字(Keyword)块</em></a><br><em>下标脚本头(Head)</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>属性(Attributes)集</em></a> <em>可选</em> <a href="TODO"><em>声明修改器(declaration-modifiers)</em></a> <em>可选</em> <strong>subscript</strong> <a href="../chapter3/05_Declarations.html#parameter_clause"><em>参数从句</em></a><br><em>下标脚本结果(Result)</em> → <strong>-&gt;</strong> <a href="../chapter3/06_Attributes.html#attributes"><em>属性(Attributes)集</em></a> <em>可选</em> <a href="../chapter3/03_Types.html#type"><em>类型</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>运算符声明语法<br><em>运算符声明</em> → <a href="../chapter3/05_Declarations.html#prefix_operator_declaration"><em>前置运算符声明</em></a> | <a href="../chapter3/05_Declarations.html#postfix_operator_declaration"><em>后置运算符声明</em></a> | <a href="../chapter3/05_Declarations.html#infix_operator_declaration"><em>中置运算符声明</em></a><br><em>前置运算符声明</em> → <strong>prefix</strong> <strong>运算符</strong>  <a href="../chapter3/02_Lexical_Structure.html#operator"><em>运算符</em></a> <strong>{</strong> <strong>}</strong><br><em>后置运算符声明</em> → <strong>postfix</strong> <strong>运算符</strong>  <a href="../chapter3/02_Lexical_Structure.html#operator"><em>运算符</em></a> <strong>{</strong> <strong>}</strong><br><em>中置运算符声明</em> → <strong>infix</strong> <strong>运算符</strong>  <a href="../chapter3/02_Lexical_Structure.html#operator"><em>运算符</em></a> <strong>{</strong> <a href="../chapter3/05_Declarations.html#infix_operator_attributes"><em>中置运算符属性集</em></a> <em>可选</em> <strong>}</strong><br><em>中置运算符属性集</em> → <a href="../chapter3/05_Declarations.html#precedence_clause"><em>优先级从句</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#associativity_clause"><em>结和性从句</em></a> <em>可选</em><br><em>优先级从句</em> → <strong>precedence</strong> <a href="../chapter3/05_Declarations.html#precedence_level"><em>优先级水平</em></a><br><em>优先级水平</em> → 数值 0 到 255，首末项包括在内<br><em>结和性从句</em> → <strong>associativity</strong> <a href="../chapter3/05_Declarations.html#associativity"><em>结和性</em></a><br><em>结和性</em> → <strong>left</strong> | <strong>right</strong> | <strong>none</strong>  </p>
</blockquote>
<!-- -->
<p>声明修改器语法</p>
<blockquote>
<p><em>声明修改器</em> → <strong>类</strong> | <strong>便捷(convenience)</strong> | <strong>动态(dynamic)</strong> | <strong>final</strong> | <strong>中置(infix)</strong> | <strong>lazy</strong> | <strong>可变(mutating)</strong> | <strong>不可变(nonmutating)</strong> | <strong>可选(optional)</strong> | <strong>改写(override)</strong> | <strong>后置</strong> | <strong>前置</strong> | <strong>required</strong> | <strong>static</strong> | <strong>unowned</strong> | <strong>unowned(safe)</strong> | <strong>unowned(unsafe)</strong> | <strong>弱(weak)</strong></p>
<p><em>声明修改器</em> → <a href="TODO"><em>访问级别声明器(access-level-modifier)</em></a></p>
<p><em>声明修改集</em> → <a href="TODO"><em>声明修改器</em></a> <a href="TODO"><em>声明修改器集</em></a> <em>可选</em></p>
<p><em>访问级别修改器</em> → <strong>内部的</strong> | <strong>内部的(set)</strong> </p>
<p><em>访问级别修改器</em> → <strong>私有的</strong> | <strong>私有的(set)</strong> </p>
<p><em>访问级别修改器</em> → <strong>公共的</strong><br>| <strong>公共的(set)</strong> </p>
<p><em>访问级别修改器集</em> →<a href="TODO"><em>访问级别修改器</em></a> <a href="TODO"><em>访问级别修改器集</em></a> <em>可选</em> </p>
</blockquote>
<p><a name="patterns"></a></p>
<h2 id="模式">模式</h2><blockquote>
<p>模式(Patterns) 语法<br><em>模式</em> → <a href="../chapter3/07_Patterns.html#wildcard_pattern"><em>通配符模式</em></a> <a href="../chapter3/03_Types.html#type_annotation"><em>类型注解</em></a> <em>可选</em><br><em>模式</em> → <a href="../chapter3/07_Patterns.html#identifier_pattern"><em>标识符模式</em></a> <a href="../chapter3/03_Types.html#type_annotati Value Bindingon"><em>类型注解</em></a> <em>可选</em><br><em>模式</em> → <a href="../chapter3/07_Patterns.html#value_binding_pattern"><em>值绑定模式</em></a><br><em>模式</em> → <a href="../chapter3/07_Patterns.html#tuple_pattern"><em>元组模式</em></a> <a href="../chapter3/03_Types.html#type_annotation"><em>类型注解</em></a> <em>可选</em>  </p>
<p><em>模式</em> → <a href="../chapter3/07_Patterns.html#enum_case_pattern"><em>枚举个例模式</em></a><br><em>模式</em> → <a href="TODO"><em>可选模式</em></a><br><em>模式</em> → <a href="../chapter3/07_Patterns.html#type_casting_pattern"><em>类型转换模式</em></a><br><em>模式</em> → <a href="../chapter3/07_Patterns.html#expression_pattern"><em>表达式模式</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>通配符模式语法<br><em>通配符模式</em> → <strong>_</strong>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>标识符模式语法<br><em>标识符模式</em> → <a href="../chapter3/02_Lexical_Structure.html#identifier"><em>标识符</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>值绑定(Value Binding)模式语法<br><em>值绑定模式</em> → <strong>var</strong> <a href="../chapter3/07_Patterns.html#pattern"><em>模式</em></a> | <strong>let</strong> <a href="../chapter3/07_Patterns.html#pattern"><em>模式</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>元组模式语法<br><em>元组模式</em> → <strong>(</strong> <a href="../chapter3/07_Patterns.html#tuple_pattern_element_list"><em>元组模式元素集</em></a> <em>可选</em> <strong>)</strong><br><em>元组模式元素集</em> → <a href="../chapter3/07_Patterns.html#tuple_pattern_element"><em>元组模式元素</em></a> | <a href="../chapter3/07_Patterns.html#tuple_pattern_element"><em>元组模式元素</em></a> <strong>,</strong> <a href="../chapter3/07_Patterns.html#tuple_pattern_element_list"><em>元组模式元素集</em></a><br><em>元组模式元素</em> → <a href="../chapter3/07_Patterns.html#pattern"><em>模式</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>枚举用例模式语法<br><em>enum-case-pattern</em> → <a href="../chapter3/03_Types.html#type_identifier"><em>类型标识</em></a> <em>可选</em> <strong>.</strong> <a href="../chapter3/05_Declarations.html#enum_case_name"><em>枚举的case名</em></a> <a href="../chapter3/07_Patterns.html#tuple_pattern"><em>元组模式</em></a> <em>可选</em> </p>
</blockquote>
<!-- -->
<blockquote>
<p>可选模式语法<br><em>可选模式</em> → <a href="TODO"><em>识别符模式</em></a> <strong>?</strong></p>
</blockquote>
<!-- -->
<blockquote>
<p>类型转换模式语法<br><em>类型转换模式(type-casting-pattern)</em> → <a href="../chapter3/07_Patterns.html#is_pattern"><em>is模式</em></a> | <a href="../chapter3/07_Patterns.html#as_pattern"><em>as模式</em></a><br><em>is模式</em> → <strong>is</strong> <a href="../chapter3/03_Types.html#type"><em>类型</em></a><br><em>as模式</em> → <a href="../chapter3/07_Patterns.html#pattern"><em>模式</em></a> <strong>as</strong> <a href="../chapter3/03_Types.html#type"><em>类型</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>表达式模式语法<br><em>表达式模式</em> → <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a>  </p>
</blockquote>
<p><a name="attributes"></a></p>
<h2 id="属性">属性</h2><blockquote>
<p>属性语法<br><em>属性</em> → <strong>@</strong> <a href="../chapter3/06_Attributes.html#attribute_name"><em>属性名</em></a> <a href="../chapter3/06_Attributes.html#attribute_argument_clause"><em>属性参数从句</em></a> <em>可选</em><br><em>属性名</em> → <a href="../chapter3/02_Lexical_Structure.html#identifier"><em>标识符</em></a><br><em>属性参数从句</em> → <strong>(</strong> <a href="../chapter3/06_Attributes.html#balanced_tokens"><em>平衡令牌集</em></a> <em>可选</em> <strong>)</strong><br><em>属性(Attributes)集</em> → <a href="../chapter3/06_Attributes.html#attribute"><em>属性</em></a> <a href="../chapter3/06_Attributes.html#attributes"><em>属性(Attributes)集</em></a> <em>可选</em><br><em>平衡令牌集</em> → <a href="../chapter3/06_Attributes.html#balanced_token"><em>平衡令牌</em></a> <a href="../chapter3/06_Attributes.html#balanced_tokens"><em>平衡令牌集</em></a> <em>可选</em><br><em>平衡令牌</em> → <strong>(</strong> <a href="../chapter3/06_Attributes.html#balanced_tokens"><em>平衡令牌集</em></a> <em>可选</em> <strong>)</strong><br><em>平衡令牌</em> → <strong>[</strong> <a href="../chapter3/06_Attributes.html#balanced_tokens"><em>平衡令牌集</em></a> <em>可选</em> <strong>]</strong><br><em>平衡令牌</em> → <strong>{</strong> <a href="../chapter3/06_Attributes.html#balanced_tokens"><em>平衡令牌集</em></a> <em>可选</em> <strong>}</strong><br><em>平衡令牌</em> → <strong>任意标识符, 关键字, 字面量或运算符</strong><br><em>平衡令牌</em> → <strong>任意标点除了(, ), [, ], {, 或 }</strong></p>
</blockquote>
<p><a name="expressions"></a></p>
<h2 id="表达式">表达式</h2><blockquote>
<p>表达式语法<br><em>表达式</em> → <a href="TODO"><em>try-operator</em></a> <em>可选</em> <a href="../chapter3/04_Expressions.html#prefix_expression"><em>前置表达式</em></a> <a href="../chapter3/04_Expressions.html#binary_expressions"><em>二元表达式集</em></a> <em>可选</em><br><em>表达式集</em> → <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a> | <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a> <strong>,</strong> <a href="../chapter3/04_Expressions.html#expression_list"><em>表达式集</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>前置表达式语法<br><em>前置表达式</em> → <a href="../chapter3/02_Lexical_Structure.html#prefix_operator"><em>前置运算符</em></a> <em>可选</em> <a href="../chapter3/04_Expressions.html#postfix_expression"><em>后置表达式</em></a><br><em>前置表达式</em> → <a href="../chapter3/04_Expressions.html#in_out_expression"><em>写入写出(in-out)表达式</em></a><br><em>写入写出(in-out)表达式</em> → <strong>&amp;</strong> <a href="../chapter3/02_Lexical_Structure.html#identifier"><em>标识符</em></a> </p>
</blockquote>
<!-- -->
<blockquote>
<p>try表达式语法<br><em>try-operator</em> → <strong>try</strong> | <strong>try !</strong>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>二元表达式语法<br><em>二元表达式</em> → <a href="../chapter3/02_Lexical_Structure.html#binary_operator"><em>二元运算符</em></a> <a href="../chapter3/04_Expressions.html#prefix_expression"><em>前置表达式</em></a><br><em>二元表达式</em> → <a href="../chapter3/04_Expressions.html#assignment_operator"><em>赋值运算符</em></a> <a href="TODO"><em>try运算符</em></a> <em>可选</em> <a href="../chapter3/04_Expressions.html#prefix_expression"><em>前置表达式</em></a><br><em>二元表达式</em> → <a href="../chapter3/04_Expressions.html#conditional_operator"><em>条件运算符</em></a> <a href="TODO"><em>try运算符</em></a> <em>可选</em> <a href="../chapter3/04_Expressions.html#prefix_expression"><em>前置表达式</em></a><br><em>二元表达式</em> → <a href="../chapter3/04_Expressions.html#type_casting_operator"><em>类型转换运算符</em></a><br><em>二元表达式集</em> → <a href="../chapter3/04_Expressions.html#binary_expression"><em>二元表达式</em></a> <a href="../chapter3/04_Expressions.html#binary_expressions"><em>二元表达式集</em></a> <em>可选</em>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>赋值运算符语法<br><em>赋值运算符</em> → <strong>=</strong>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>三元条件运算符语法<br><em>三元条件运算符</em> → <strong>?</strong> <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a> <strong>:</strong>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>类型转换运算符语法<br><em>类型转换运算符</em> → <strong>is</strong> <a href="../chapter3/03_Types.html#type"><em>类型</em></a> </p>
<p><em>类型转换运算符</em> → <strong>as</strong> <a href="../chapter3/03_Types.html#type"><em>类型</em></a> </p>
<p><em>类型转换运算符</em> → <strong>as ?</strong> <a href="../chapter3/03_Types.html#type"><em>类型</em></a> </p>
<p><em>类型转换运算符</em> → <strong>as !</strong> <a href="../chapter3/03_Types.html#type"><em>类型</em></a> </p>
</blockquote>
<!-- -->
<blockquote>
<p>主表达式语法<br><em>主表达式</em> → <a href="../chapter3/02_Lexical_Structure.html#identifier"><em>标识符</em></a> <a href="GenericParametersAndArguments.html#generic_argument_clause"><em>泛型参数从句</em></a> <em>可选</em><br><em>主表达式</em> → <a href="../chapter3/04_Expressions.html#literal_expression"><em>字面量表达式</em></a><br><em>主表达式</em> → <a href="../chapter3/04_Expressions.html#self_expression"><em>self表达式</em></a><br><em>主表达式</em> → <a href="../chapter3/04_Expressions.html#superclass_expression"><em>超类表达式</em></a><br><em>主表达式</em> → <a href="../chapter3/04_Expressions.html#closure_expression"><em>闭包表达式</em></a><br><em>主表达式</em> → <a href="../chapter3/04_Expressions.html#parenthesized_expression"><em>圆括号表达式</em></a><br><em>主表达式</em> → <a href="../chapter3/04_Expressions.html#implicit_member_expression"><em>隐式成员表达式</em></a><br><em>主表达式</em> → <a href="../chapter3/04_Expressions.html#wildcard_expression"><em>通配符表达式</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>字面量表达式语法<br><em>字面量表达式</em> → <a href="../chapter3/02_Lexical_Structure.html#literal"><em>字面量</em></a><br><em>字面量表达式</em> → <a href="../chapter3/04_Expressions.html#array_literal"><em>数组字面量</em></a> | <a href="../chapter3/04_Expressions.html#dictionary_literal"><em>字典字面量</em></a><br><em>字面量表达式</em> → <strong>&#95;&#95;FILE&#95;&#95;</strong> | <strong>&#95;&#95;LINE&#95;&#95;</strong> | <strong>&#95;&#95;COLUMN&#95;&#95;</strong> | <strong>&#95;&#95;FUNCTION&#95;&#95;</strong><br><em>数组字面量</em> → <strong>[</strong> <a href="../chapter3/04_Expressions.html#array_literal_items"><em>数组字面量项集</em></a> <em>可选</em> <strong>]</strong><br><em>数组字面量项集</em> → <a href="../chapter3/04_Expressions.html#array_literal_item"><em>数组字面量项</em></a> <strong>,</strong> <em>可选</em> | <a href="../chapter3/04_Expressions.html#array_literal_item"><em>数组字面量项</em></a> <strong>,</strong> <a href="../chapter3/04_Expressions.html#array_literal_items"><em>数组字面量项集</em></a><br><em>数组字面量项</em> → <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a><br><em>字典字面量</em> → <strong>[</strong> <a href="../chapter3/04_Expressions.html#dictionary_literal_items"><em>字典字面量项集</em></a> <strong>]</strong> | <strong>[</strong> <strong>:</strong> <strong>]</strong><br><em>字典字面量项集</em> → <a href="../chapter3/04_Expressions.html#dictionary_literal_item"><em>字典字面量项</em></a> <strong>,</strong> <em>可选</em> | <a href="../chapter3/04_Expressions.html#dictionary_literal_item"><em>字典字面量项</em></a> <strong>,</strong> <a href="../chapter3/04_Expressions.html#dictionary_literal_items"><em>字典字面量项集</em></a><br><em>字典字面量项</em> → <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a> <strong>:</strong> <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>Self 表达式语法<br><em>self表达式</em> → <strong>self</strong><br><em>self表达式</em> → <strong>self</strong> <strong>.</strong> <a href="../chapter3/02_Lexical_Structure.html#identifier"><em>标识符</em></a><br><em>self表达式</em> → <strong>self</strong> <strong>[</strong> <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a> <strong>]</strong><br><em>self表达式</em> → <strong>self</strong> <strong>.</strong> <strong>init</strong>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>超类表达式语法<br><em>超类表达式</em> → <a href="../chapter3/04_Expressions.html#superclass_method_expression"><em>超类方法表达式</em></a> | <a href="../chapter3/04_Expressions.html#超类下标表达式"><em>超类下标表达式</em></a> | <a href="../chapter3/04_Expressions.html#superclass_initializer_expression"><em>超类构造器表达式</em></a><br><em>超类方法表达式</em> → <strong>super</strong> <strong>.</strong> <a href="../chapter3/02_Lexical_Structure.html#identifier"><em>标识符</em></a><br><em>超类下标表达式</em> → <strong>super</strong> <strong>[</strong> <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a> <strong>]</strong><br><em>超类构造器表达式</em> → <strong>super</strong> <strong>.</strong> <strong>init</strong>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>闭包表达式语法<br><em>闭包表达式</em> → <strong>{</strong> <a href="../chapter3/04_Expressions.html#closure_signature"><em>闭包签名(Signational)</em></a> <em>可选</em> <a href="../chapter3/10_Statements.html#statements"><em>多条语句(Statements)</em></a> <strong>}</strong><br><em>闭包签名(Signational)</em> → <a href="../chapter3/05_Declarations.html#parameter_clause"><em>参数从句</em></a> <a href="../chapter3/05_Declarations.html#function_result"><em>函数结果</em></a> <em>可选</em> <strong>in</strong><br><em>闭包签名(Signational)</em> → <a href="../chapter3/02_Lexical_Structure.html#identifier_list"><em>标识符集</em></a> <a href="../chapter3/05_Declarations.html#function_result"><em>函数结果</em></a> <em>可选</em> <strong>in</strong><br><em>闭包签名(Signational)</em> → <a href="../chapter3/04_Expressions.html#capture_list"><em>捕获(Capature)集</em></a> <a href="../chapter3/05_Declarations.html#parameter_clause"><em>参数从句</em></a> <a href="../chapter3/05_Declarations.html#function_result"><em>函数结果</em></a> <em>可选</em> <strong>in</strong><br><em>闭包签名(Signational)</em> → <a href="../chapter3/04_Expressions.html#capture_list"><em>捕获(Capature)集</em></a> <a href="../chapter3/02_Lexical_Structure.html#identifier_list"><em>标识符集</em></a> <a href="../chapter3/05_Declarations.html#function_result"><em>函数结果</em></a> <em>可选</em> <strong>in</strong><br><em>闭包签名(Signational)</em> → <a href="../chapter3/04_Expressions.html#capture_list"><em>捕获(Capature)集</em></a> <strong>in</strong><br><em>捕获(Capature)集</em> → <strong>[</strong> <a href="../chapter3/04_Expressions.html#capture_specifier"><em>捕获(Capature)说明符</em></a> <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a> <strong>]</strong><br><em>捕获(Capature)说明符</em> → <strong>weak</strong> | <strong>unowned</strong> | <strong>unowned(safe)</strong> | <strong>unowned(unsafe)</strong>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>隐式成员表达式语法<br><em>隐式成员表达式</em> → <strong>.</strong> <a href="../chapter3/02_Lexical_Structure.html#identifier"><em>标识符</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>圆括号表达式(Parenthesized Expression)语法<br><em>圆括号表达式</em> → <strong>(</strong> <a href="../chapter3/04_Expressions.html#expression_element_list"><em>表达式元素集</em></a> <em>可选</em> <strong>)</strong><br><em>表达式元素集</em> → <a href="../chapter3/04_Expressions.html#expression_element"><em>表达式元素</em></a> | <a href="../chapter3/04_Expressions.html#expression_element"><em>表达式元素</em></a> <strong>,</strong> <a href="../chapter3/04_Expressions.html#expression_element_list"><em>表达式元素集</em></a><br><em>表达式元素</em> → <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a> | <a href="../chapter3/02_Lexical_Structure.html#identifier"><em>标识符</em></a> <strong>:</strong> <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>通配符表达式语法<br><em>通配符表达式</em> → <strong>_</strong>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>后置表达式语法<br><em>后置表达式</em> → <a href="../chapter3/04_Expressions.html#primary_expression"><em>主表达式</em></a><br><em>后置表达式</em> → <a href="../chapter3/04_Expressions.html#postfix_expression"><em>后置表达式</em></a> <a href="../chapter3/02_Lexical_Structure.html#postfix_operator"><em>后置运算符</em></a><br><em>后置表达式</em> → <a href="../chapter3/04_Expressions.html#function_call_expression"><em>函数调用表达式</em></a><br><em>后置表达式</em> → <a href="../chapter3/04_Expressions.html#initializer_expression"><em>构造器表达式</em></a><br><em>后置表达式</em> → <a href="../chapter3/04_Expressions.html#explicit_member_expression"><em>显示成员表达式</em></a><br><em>后置表达式</em> → <a href="../chapter3/04_Expressions.html#postfix_self_expression"><em>后置self表达式</em></a><br><em>后置表达式</em> → <a href="../chapter3/04_Expressions.html#dynamic_type_expression"><em>动态类型表达式</em></a><br><em>后置表达式</em> → <a href="../chapter3/04_Expressions.html#subscript_expression"><em>下标表达式</em></a><br><em>后置表达式</em> → <a href="../chapter3/04_Expressions.html#forced_value_expression"><em>强制取值(Forced Value)表达式</em></a><br><em>后置表达式</em> → <a href="../chapter3/04_Expressions.html#optional_chaining_expression"><em>可选链(Optional Chaining)表达式</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>函数调用表达式语法<br><em>函数调用表达式</em> → <a href="../chapter3/04_Expressions.html#postfix_expression"><em>后置表达式</em></a> <a href="../chapter3/04_Expressions.html#parenthesized_expression"><em>圆括号表达式</em></a><br><em>函数调用表达式</em> → <a href="../chapter3/04_Expressions.html#postfix_expression"><em>后置表达式</em></a> <a href="../chapter3/04_Expressions.html#parenthesized_expression"><em>圆括号表达式</em></a> <em>可选</em> <a href="../chapter3/04_Expressions.html#trailing_closure"><em>后置闭包(Trailing Closure)</em></a><br><em>后置闭包(Trailing Closure)</em> → <a href="../chapter3/04_Expressions.html#closure_expression"><em>闭包表达式</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>构造器表达式语法<br><em>构造器表达式</em> → <a href="../chapter3/04_Expressions.html#postfix_expression"><em>后置表达式</em></a> <strong>.</strong> <strong>init</strong>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>显式成员表达式语法<br><em>显示成员表达式</em> → <a href="../chapter3/04_Expressions.html#postfix_expression"><em>后置表达式</em></a> <strong>.</strong> <a href="../chapter3/02_Lexical_Structure.html#decimal_digit"><em>十进制数字</em></a><br><em>显示成员表达式</em> → <a href="../chapter3/04_Expressions.html#postfix_expression"><em>后置表达式</em></a> <strong>.</strong> <a href="../chapter3/02_Lexical_Structure.html#identifier"><em>标识符</em></a> <a href="GenericParametersAndArguments.html#generic_argument_clause"><em>泛型参数从句</em></a> <em>可选</em>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>后置Self 表达式语法<br><em>后置self表达式</em> → <a href="../chapter3/04_Expressions.html#postfix_expression"><em>后置表达式</em></a> <strong>.</strong> <strong>self</strong>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>动态类型表达式语法<br><em>动态类型表达式</em> → <a href="../chapter3/04_Expressions.html#postfix_expression"><em>后置表达式</em></a> <strong>.</strong> <strong>dynamicType</strong>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>附属脚本表达式语法<br><em>附属脚本表达式</em> → <a href="../chapter3/04_Expressions.html#postfix_expression"><em>后置表达式</em></a> <strong>[</strong> <a href="../chapter3/04_Expressions.html#expression_list"><em>表达式集</em></a> <strong>]</strong>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>强制取值(Forced Value)语法<br><em>强制取值(Forced Value)表达式</em> → <a href="../chapter3/04_Expressions.html#postfix_expression"><em>后置表达式</em></a> <strong>!</strong>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>可选链表达式语法<br><em>可选链表达式</em> → <a href="../chapter3/04_Expressions.html#postfix_expression"><em>后置表达式</em></a> <strong>?</strong>  </p>
</blockquote>
<p><a name="lexical_structure"></a></p>
<h2 id="词法结构">词法结构</h2><blockquote>
<p>标识符语法<br><em>标识符</em> → <a href="../chapter3/02_Lexical_Structure.html#identifier_head"><em>标识符头(Head)</em></a> <a href="../chapter3/02_Lexical_Structure.html#identifier_characters"><em>标识符字符集</em></a> <em>可选</em><br><em>标识符</em> → <a href="../chapter3/02_Lexical_Structure.html#identifier_head"><em>标识符头(Head)</em></a> <a href="../chapter3/02_Lexical_Structure.html#identifier_characters"><em>标识符字符集</em></a> <em>可选</em><br><em>标识符</em> → <a href="../chapter3/02_Lexical_Structure.html#implicit_parameter_name"><em>隐式参数名</em></a><br><em>标识符集</em> → <a href="../chapter3/02_Lexical_Structure.html#identifier"><em>标识符</em></a> | <a href="../chapter3/02_Lexical_Structure.html#identifier"><em>标识符</em></a> <strong>,</strong> <a href="../chapter3/02_Lexical_Structure.html#identifier_list"><em>标识符集</em></a><br><em>标识符头(Head)</em> → Upper- or lowercase letter A through Z</p>
<p><em>标识符头(Head)</em> → _</p>
<p><em>标识符头(Head)</em> → U+00A8, U+00AA, U+00AD, U+00AF, U+00B2–U+00B5, or U+00B7–U+00BA<br><em>标识符头(Head)</em> → U+00BC–U+00BE, U+00C0–U+00D6, U+00D8–U+00F6, or U+00F8–U+00FF<br><em>标识符头(Head)</em> → U+0100–U+02FF, U+0370–U+167F, U+1681–U+180D, or U+180F–U+1DBF<br><em>标识符头(Head)</em> → U+1E00–U+1FFF<br><em>标识符头(Head)</em> → U+200B–U+200D, U+202A–U+202E, U+203F–U+2040, U+2054, or U+2060–U+206F<br><em>标识符头(Head)</em> → U+2070–U+20CF, U+2100–U+218F, U+2460–U+24FF, or U+2776–U+2793<br><em>标识符头(Head)</em> → U+2C00–U+2DFF or U+2E80–U+2FFF<br><em>标识符头(Head)</em> → U+3004–U+3007, U+3021–U+302F, U+3031–U+303F, or U+3040–U+D7FF<br><em>标识符头(Head)</em> → U+F900–U+FD3D, U+FD40–U+FDCF, U+FDF0–U+FE1F, or U+FE30–U+FE44<br><em>标识符头(Head)</em> → U+FE47–U+FFFD<br><em>标识符头(Head)</em> → U+10000–U+1FFFD, U+20000–U+2FFFD, U+30000–U+3FFFD, or U+40000–U+4FFFD<br><em>标识符头(Head)</em> → U+50000–U+5FFFD, U+60000–U+6FFFD, U+70000–U+7FFFD, or U+80000–U+8FFFD<br><em>标识符头(Head)</em> → U+90000–U+9FFFD, U+A0000–U+AFFFD, U+B0000–U+BFFFD, or U+C0000–U+CFFFD<br><em>标识符头(Head)</em> → U+D0000–U+DFFFD or U+E0000–U+EFFFD<br><em>标识符字符</em> → 数值 0 到 9<br><em>标识符字符</em> → U+0300–U+036F, U+1DC0–U+1DFF, U+20D0–U+20FF, or U+FE20–U+FE2F<br><em>标识符字符</em> → <a href="../chapter3/02_Lexical_Structure.html#identifier_head"><em>标识符头(Head)</em></a><br><em>标识符字符集</em> → <a href="../chapter3/02_Lexical_Structure.html#identifier_character"><em>标识符字符</em></a> <a href="../chapter3/02_Lexical_Structure.html#identifier_characters"><em>标识符字符集</em></a> <em>可选</em><br><em>隐式参数名</em> → <strong>$</strong> <a href="../chapter3/02_Lexical_Structure.html#decimal_digits"><em>十进制数字集</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>字面量语法<br><em>字面量</em> → <a href="../chapter3/02_Lexical_Structure.html#integer_literal"><em>数值型字面量</em></a> | <a href="../chapter3/02_Lexical_Structure.html#floating_point_literal"><em>字符串字面量</em></a> | <a href="../chapter3/02_Lexical_Structure.html#string_literal"><em>布尔字面量</em></a> | <a href="TODO"><em>空字面量</em></a> </p>
<p><em>数值型字面量</em> → <strong>-</strong> <em>可选</em> <a href="TODO"><em>整形字面量</em></a> | <strong>-</strong> <em>可选</em> <a href="TODO"><em>浮点型字面量</em></a></p>
<p><em>布尔字面量</em> → <strong>true</strong> | <strong>false</strong></p>
<p><em>空字面量</em> → <strong>nil</strong></p>
</blockquote>
<!-- -->
<blockquote>
<p>整型字面量语法<br><em>整型字面量</em> → <a href="../chapter3/02_Lexical_Structure.html#binary_literal"><em>二进制字面量</em></a><br><em>整型字面量</em> → <a href="../chapter3/02_Lexical_Structure.html#octal_literal"><em>八进制字面量</em></a><br><em>整型字面量</em> → <a href="../chapter3/02_Lexical_Structure.html#decimal_literal"><em>十进制字面量</em></a><br><em>整型字面量</em> → <a href="../chapter3/02_Lexical_Structure.html#hexadecimal_literal"><em>十六进制字面量</em></a><br><em>二进制字面量</em> → <strong>0b</strong> <a href="../chapter3/02_Lexical_Structure.html#binary_digit"><em>二进制数字</em></a> <a href="../chapter3/02_Lexical_Structure.html#binary_literal_characters"><em>二进制字面量字符集</em></a> <em>可选</em><br><em>二进制数字</em> → 数值 0 到 1<br><em>二进制字面量字符</em> → <a href="../chapter3/02_Lexical_Structure.html#binary_digit"><em>二进制数字</em></a> | <strong>_</strong><br><em>二进制字面量字符集</em> → <a href="../chapter3/02_Lexical_Structure.html#binary_literal_character"><em>二进制字面量字符</em></a> <a href="../chapter3/02_Lexical_Structure.html#binary_literal_characters"><em>二进制字面量字符集</em></a> <em>可选</em><br><em>八进制字面量</em> → <strong>0o</strong> <a href="../chapter3/02_Lexical_Structure.html#octal_digit"><em>八进制数字</em></a> <a href="../chapter3/02_Lexical_Structure.html#octal_literal_characters"><em>八进制字符集</em></a> <em>可选</em><br><em>八进字数字</em> → 数值 0 到 7<br><em>八进制字符</em> → <a href="../chapter3/02_Lexical_Structure.html#octal_digit"><em>八进制数字</em></a> | <strong>_</strong><br><em>八进制字符集</em> → <a href="../chapter3/02_Lexical_Structure.html#octal_literal_character"><em>八进制字符</em></a> <a href="../chapter3/02_Lexical_Structure.html#octal_literal_characters"><em>八进制字符集</em></a> <em>可选</em><br><em>十进制字面量</em> → <a href="../chapter3/02_Lexical_Structure.html#decimal_digit"><em>十进制数字</em></a> <a href="../chapter3/02_Lexical_Structure.html#decimal_literal_characters"><em>十进制字符集</em></a> <em>可选</em><br><em>十进制数字</em> → 数值 0 到 9<br><em>十进制数字集</em> → <a href="../chapter3/02_Lexical_Structure.html#decimal_digit"><em>十进制数字</em></a> <a href="../chapter3/02_Lexical_Structure.html#decimal_digits"><em>十进制数字集</em></a> <em>可选</em><br><em>十进制字面量字符</em> → <a href="../chapter3/02_Lexical_Structure.html#decimal_digit"><em>十进制数字</em></a> | <strong>_</strong><br><em>十进制字面量字符集</em> → <a href="../chapter3/02_Lexical_Structure.html#decimal_literal_character"><em>十进制字面量字符</em></a> <a href="../chapter3/02_Lexical_Structure.html#decimal_literal_characters"><em>十进制字面量字符集</em></a> <em>可选</em><br><em>十六进制字面量</em> → <strong>0x</strong> <a href="../chapter3/02_Lexical_Structure.html#hexadecimal_digit"><em>十六进制数字</em></a> <a href="../chapter3/02_Lexical_Structure.html#hexadecimal_literal_characters"><em>十六进制字面量字符集</em></a> <em>可选</em><br><em>十六进制数字</em> → 数值 0 到 9, a through f, or A through F<br><em>十六进制字符</em> → <a href="../chapter3/02_Lexical_Structure.html#hexadecimal_digit"><em>十六进制数字</em></a> | <strong>_</strong><br><em>十六进制字面量字符集</em> → <a href="../chapter3/02_Lexical_Structure.html#hexadecimal_literal_character"><em>十六进制字符</em></a> <a href="../chapter3/02_Lexical_Structure.html#hexadecimal_literal_characters"><em>十六进制字面量字符集</em></a> <em>可选</em>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>浮点型字面量语法<br><em>浮点数字面量</em> → <a href="../chapter3/02_Lexical_Structure.html#decimal_literal"><em>十进制字面量</em></a> <a href="../chapter3/02_Lexical_Structure.html#decimal_fraction"><em>十进制分数</em></a> <em>可选</em> <a href="../chapter3/02_Lexical_Structure.html#decimal_exponent"><em>十进制指数</em></a> <em>可选</em><br><em>浮点数字面量</em> → <a href="../chapter3/02_Lexical_Structure.html#hexadecimal_literal"><em>十六进制字面量</em></a> <a href="../chapter3/02_Lexical_Structure.html#hexadecimal_fraction"><em>十六进制分数</em></a> <em>可选</em> <a href="../chapter3/02_Lexical_Structure.html#hexadecimal_exponent"><em>十六进制指数</em></a><br><em>十进制分数</em> → <strong>.</strong> <a href="../chapter3/02_Lexical_Structure.html#decimal_literal"><em>十进制字面量</em></a><br><em>十进制指数</em> → <a href="../chapter3/02_Lexical_Structure.html#floating_point_e"><em>浮点数e</em></a> <a href="../chapter3/02_Lexical_Structure.html#sign"><em>正负号</em></a> <em>可选</em> <a href="../chapter3/02_Lexical_Structure.html#decimal_literal"><em>十进制字面量</em></a><br><em>十六进制分数</em> → <strong>.</strong> <a href="../chapter3/02_Lexical_Structure.html#hexadecimal_literal"><em>十六进制数</em></a><br> <a href="TODO"><em>十六进制字面量字符集</em></a><em>可选</em><br><em>十六进制指数</em> → <a href="../chapter3/02_Lexical_Structure.html#floating_point_p"><em>浮点数p</em></a> <a href="../chapter3/02_Lexical_Structure.html#sign"><em>正负号</em></a> <em>可选</em> <a href="../chapter3/02_Lexical_Structure.html#hexadecimal_literal"><em>十六进制字面量</em></a><br><em>浮点数e</em> → <strong>e</strong> | <strong>E</strong><br><em>浮点数p</em> → <strong>p</strong> | <strong>P</strong><br><em>正负号</em> → <strong>+</strong> | <strong>-</strong>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>字符串型字面量语法<br><em>字符串字面量</em> → <strong>“</strong> <a href="../chapter3/02_Lexical_Structure.html#quoted_text"><em>引用文本</em></a> <strong>“</strong><br><em>引用文本</em> → <a href="../chapter3/02_Lexical_Structure.html#quoted_text_item"><em>引用文本条目</em></a> <a href="../chapter3/02_Lexical_Structure.html#quoted_text"><em>引用文本</em></a> <em>可选</em><br><em>引用文本条目</em> → <a href="../chapter3/02_Lexical_Structure.html#escaped_character"><em>转义字符</em></a><br><em>引用文本条目</em> → <strong>(</strong> <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a> <strong>)</strong><br><em>引用文本条目</em> → 除了”­, \­, U+000A, or U+000D的所有Unicode的字符<br><em>转义字符</em> → <strong>/0</strong> | <strong>\</strong> | <strong>\t</strong> | <strong>\n</strong> | <strong>\r</strong> | <strong>\”</strong> | <strong>\’</strong><br><em>转义字符</em> → <strong>\u</strong> <strong>{</strong> <a href="TODO"><em>十六进制标量数字集</em></a> <strong>}</strong><br><em>unicode标量数字集</em> → Between one and eight hexadecimal digits</p>
</blockquote>
<!-- -->
<blockquote>
<p>运算符语法语法<br><em>运算符</em> → <a href="../chapter3/02_Lexical_Structure.html#operator_character"><em>运算符头</em></a> <a href="../chapter3/02_Lexical_Structure.html#operator"><em>运算符字符集</em></a> <em>可选</em><br><em>运算符</em> → <a href="TODO"><em>点运算符头</em></a> <a href="TODO"><em>点运算符字符集</em></a> <em>可选</em><br><em>运算符字符</em> → <strong>/</strong> | <strong>=</strong> | <strong>-</strong> | <strong>+</strong> | <strong>!</strong> | <strong>&#42;</strong> | <strong>%</strong> | <strong>&lt;</strong> | <strong>&gt;</strong> | <strong>&amp;</strong> | <strong>|</strong> | <strong>^</strong> | <strong>~</strong> | <strong>?</strong><br><em>运算符头</em> → U+00A1–U+00A7</p>
<p><em>运算符头</em> → U+00A9 or U+00AB</p>
<p><em>运算符头</em> →  U+00AC or U+00AE</p>
<p><em>运算符头</em> → U+00B0–U+00B1, U+00B6, U+00BB, U+00BF, U+00D7, or U+00F7</p>
<p><em>运算符头</em> → U+2016–U+2017 or U+2020–U+2027</p>
<p><em>运算符头</em> → U+2030–U+203E</p>
<p><em>运算符头</em> → U+2041–U+2053</p>
<p><em>运算符头</em> → U+2055–U+205E</p>
<p><em>运算符头</em> → U+2190–U+23FF</p>
<p><em>运算符头</em> → U+2500–U+2775</p>
<p><em>运算符头</em> → U+2794–U+2BFF</p>
<p><em>运算符头</em> → U+2E00–U+2E7F</p>
<p><em>运算符头</em> → U+3001–U+3003</p>
<p><em>运算符头</em> → U+3008–U+3030</p>
<p><em>运算符字符</em> → <a href="TODO"><em>运算符头</em></a></p>
<p><em>运算符字符</em> → U+0300–U+036F</p>
<p><em>运算符字符</em> → U+1DC0–U+1DFF</p>
<p><em>运算符字符</em> → U+20D0–U+20FF</p>
<p><em>运算符字符</em> → U+FE00–U+FE0F</p>
<p><em>运算符字符</em> → U+FE20–U+FE2F</p>
<p><em>运算符字符</em> → U+E0100–U+E01EF</p>
<p><em>运算符字符集</em> → <a href="TODO"><em>运算符字符</em></a> <a href="TODO"><em>运算符字符集</em></a><em>可选</em></p>
<p><em>点运算符头</em> → <strong>..</strong> </p>
<p><em>点运算符字符</em> → <strong>.</strong> | <a href="TODO"><em>运算符字符</em></a></p>
<p><em>点运算符字符集</em> → <a href="TODO"><em>点运算符字符</em></a> <a href="TODO"><em>点运算符字符集</em></a> <em>可选</em></p>
<p><em>二元运算符</em> → <a href="../chapter3/02_Lexical_Structure.html#operator"><em>运算符</em></a><br><em>前置运算符</em> → <a href="../chapter3/02_Lexical_Structure.html#operator"><em>运算符</em></a><br><em>后置运算符</em> → <a href="../chapter3/02_Lexical_Structure.html#operator"><em>运算符</em></a>  </p>
</blockquote>
<p><a name="types"></a></p>
<h2 id="类型">类型</h2><blockquote>
<p>类型语法<br><em>类型</em> → <a href="../chapter3/03_Types.html#array_type"><em>数组类型</em></a> | <a href="TODO"><em>字典类型</em></a> | <a href="../chapter3/03_Types.html#function_type"><em>函数类型</em></a> | <a href="../chapter3/03_Types.html#type_identifier"><em>类型标识符</em></a> | <a href="../chapter3/03_Types.html#tuple_type"><em>元组类型</em></a> | <a href="../chapter3/03_Types.html#optional_type"><em>可选类型</em></a> | <a href="../chapter3/03_Types.html#implicitly_unwrapped_optional_type"><em>隐式解析可选类型</em></a> | <a href="../chapter3/03_Types.html#protocol_composition_type"><em>协议合成类型</em></a> | <a href="../chapter3/03_Types.html#metatype_type"><em>元型类型</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>类型注解语法<br><em>类型注解</em> → <strong>:</strong> <a href="../chapter3/06_Attributes.html#attributes"><em>属性(Attributes)集</em></a> <em>可选</em> <a href="../chapter3/03_Types.html#type"><em>类型</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>类型标识语法<br><em>类型标识</em> → <a href="../chapter3/03_Types.html#type_name"><em>类型名称</em></a> <a href="GenericParametersAndArguments.html#generic_argument_clause"><em>泛型参数从句</em></a> <em>可选</em> | <a href="../chapter3/03_Types.html#type_name"><em>类型名称</em></a> <a href="GenericParametersAndArguments.html#generic_argument_clause"><em>泛型参数从句</em></a> <em>可选</em> <strong>.</strong> <a href="../chapter3/03_Types.html#type_identifier"><em>类型标识符</em></a><br><em>类型名</em> → <a href="../chapter3/02_Lexical_Structure.html#identifier"><em>标识符</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>元组类型语法<br><em>元组类型</em> → <strong>(</strong> <a href="../chapter3/03_Types.html#tuple_type_body"><em>元组类型主体</em></a> <em>可选</em> <strong>)</strong><br><em>元组类型主体</em> → <a href="../chapter3/03_Types.html#tuple_type_element_list"><em>元组类型的元素集</em></a> <strong>…</strong> <em>可选</em><br><em>元组类型的元素集</em> → <a href="../chapter3/03_Types.html#tuple_type_element"><em>元组类型的元素</em></a> | <a href="../chapter3/03_Types.html#tuple_type_element"><em>元组类型的元素</em></a> <strong>,</strong> <a href="../chapter3/03_Types.html#tuple_type_element_list"><em>元组类型的元素集</em></a><br><em>元组类型的元素</em> → <a href="../chapter3/06_Attributes.html#attributes"><em>属性(Attributes)集</em></a> <em>可选</em> <strong>inout</strong> <em>可选</em> <a href="../chapter3/03_Types.html#type"><em>类型</em></a> | <strong>inout</strong> <em>可选</em> <a href="../chapter3/03_Types.html#element_name"><em>元素名</em></a> <a href="../chapter3/03_Types.html#type_annotation"><em>类型注解</em></a><br><em>元素名</em> → <a href="../chapter3/02_Lexical_Structure.html#identifier"><em>标识符</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>函数类型语法<br><em>函数类型</em> → <a href="../chapter3/03_Types.html#type"><em>类型</em></a>  <strong>throws</strong> <em>可选</em> <strong>-&gt;</strong> <a href="../chapter3/03_Types.html#type"><em>类型</em></a><br><em>函数类型</em> → <a href="TODO"><em>类型</em></a>  <strong>rethrows</strong> <strong>-&gt;</strong> <a href="TODO"><em>类型</em></a> </p>
</blockquote>
<!-- -->
<blockquote>
<p>数组类型语法<br><em>数组类型</em> → <strong>[</strong> <a href="../chapter3/03_Types.html#array_type"><em>类型</em></a> <strong>]</strong>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>字典类型语法<br><em>字典类型</em> → <strong>[</strong> <a href="TODO"><em>类型 <strong>:</strong> 类型</em></a> <strong>]</strong></p>
</blockquote>
<!-- -->
<blockquote>
<p>可选类型语法<br><em>可选类型</em> → <a href="../chapter3/03_Types.html#type"><em>类型</em></a> <strong>?</strong>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>隐式解析可选类型(Implicitly Unwrapped Optional Type)语法<br><em>隐式解析可选类型</em> → <a href="../chapter3/03_Types.html#type"><em>类型</em></a> <strong>!</strong>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>协议合成类型语法<br><em>协议合成类型</em> → <strong>protocol</strong> <strong>&lt;</strong> <a href="../chapter3/03_Types.html#protocol_identifier_list"><em>协议标识符集</em></a> <em>可选</em> <strong>&gt;</strong><br><em>协议标识符集</em> → <a href="../chapter3/03_Types.html#protocol_identifier"><em>协议标识符</em></a> | <a href="../chapter3/03_Types.html#protocol_identifier"><em>协议标识符</em></a> <strong>,</strong> <a href="../chapter3/03_Types.html#protocol_identifier_list"><em>协议标识符集</em></a><br><em>协议标识符</em> → <a href="../chapter3/03_Types.html#type_identifier"><em>类型标识符</em></a>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>元(Metatype)类型语法<br><em>元类型</em> → <a href="../chapter3/03_Types.html#type"><em>类型</em></a> <strong>.</strong> <strong>Type</strong> | <a href="../chapter3/03_Types.html#type"><em>类型</em></a> <strong>.</strong> <strong>Protocol</strong>  </p>
</blockquote>
<!-- -->
<blockquote>
<p>类型继承从句语法  </p>
<p><em>类型继承从句</em> → <strong>:</strong> <a href="TODO"><em>类条件(class-requirement))</em></a> <strong>,</strong> <a href="../chapter3/03_Types.html#type_inheritance_list"><em>类型继承集</em></a> </p>
<p><em>类型继承从句</em> → <strong>:</strong> <a href="TODO"><em>类条件(class-requirement))</em></a> </p>
<p><em>类型继承从句</em> → <strong>:</strong> <a href="TODO"><em>类型继承集</em></a>  </p>
<p><em>类型继承集</em> → <a href="../chapter3/03_Types.html#type_identifier"><em>类型标识符</em></a> | <a href="../chapter3/03_Types.html#type_identifier"><em>类型标识符</em></a> <strong>,</strong> <a href="../chapter3/03_Types.html#type_inheritance_list"><em>类型继承集</em></a></p>
<p><em>类条件</em> → <strong>class</strong> </p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter3/10_Statements/" itemprop="url">
                第三章-10语句（Statements）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T11:00:11+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter3/10_Statements/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter3/10_Statements/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><a name="statement_statements"></a></p>
<h1 id="语句（Statements）">语句（Statements）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/coverxit" target="_blank" rel="external">coverxit</a><br>校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>, <a href="https://github.com/coverxit" target="_blank" rel="external">coverxit</a>, <a href="https://github.com/stanzhai" target="_blank" rel="external">stanzhai</a>,</p>
<p>2.0<br>翻译+校对：<a href="https://github.com/littledogboy" target="_blank" rel="external">littledogboy</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#loop_statements">循环语句</a></li>
<li><a href="#branch_statements">分支语句</a></li>
<li><a href="#labeled_statement">带标签的语句</a></li>
<li><a href="#control_transfer_statements">控制传递语句</a></li>
</ul>
<p>在 Swift 中，有三种类型的语句：简单语句、编译控制语句和控制流语句。简单语句是最常见的，用于构造表达式或者声明。编译控制语句允许程序改变编译器的行为以及包含构建配置和源代码控制语句。</p>
<p>控制流语句则用于控制程序执行的流程，Swift 中有几种类型的控制流语句：循环语句、分支语句和控制传递语句。循环语句用于重复执行代码块；分支语句用于执行满足特定条件的代码块；控制传递语句则用于修改代码的执行顺序。另外，Swift 提供了 <code>do</code> 语句来引入范围以及捕获和处理错误，还提供了 <code>defer</code> 语句在退出当前范围之前执行清理操作。</p>
<p>是否将分号（<code>;</code>）添加到语句的结尾处是可选的。但若要在同一行内写多条独立语句，请务必使用分号。</p>
<blockquote>
<p>语句语法<br><em>语句</em> → <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a> <strong>;</strong> <em>可选</em><br><em>语句</em> → <a href="../chapter3/05_Declarations.html#declaration"><em>声明</em></a> <strong>;</strong> <em>可选</em><br><em>语句</em> → <a href="../chapter3/10_Statements.html#loop_statement"><em>循环语句</em></a> <strong>;</strong> <em>可选</em><br><em>语句</em> → <a href="../chapter3/10_Statements.html#branch_statement"><em>分支语句</em></a> <strong>;</strong> <em>可选</em><br><em>语句</em> → <a href="../chapter3/10_Statements.html#labeled_statement"><em>标记语句(Labeled Statement)</em></a><br><em>语句</em> → <a href="../chapter3/10_Statements.html#control_transfer_statement"><em>控制转移语句</em></a> <strong>;</strong> <em>可选</em><br><em>语句</em> → <a href="../chapter3/10_Statements.html#control_transfer_statement"><em>XXX语句</em></a> <strong>;</strong> <em>可选</em><br><em>多条语句(Statements)</em> → <a href="../chapter3/10_Statements.html#statement"><em>语句</em></a> <a href="../chapter3/10_Statements.html#statements"><em>多条语句(Statements)</em></a> <em>可选</em>  </p>
</blockquote>
<p><a name="loop_statements"></a></p>
<h2 id="循环语句">循环语句</h2><p>取决于特定的循环条件，循环语句允许重复执行代码块。Swift 提供四种类型的循环语句：<code>for</code>语句、<code>for-in</code>语句、<code>while</code>语句和<code>do-while</code>语句。</p>
<p>通过<code>break</code>语句和<code>continue</code>语句可以改变循环语句的控制流。有关这两条语句，详情参见 <a href="#break_statement">Break 语句</a>和 <a href="#continue_statement">Continue 语句</a>。</p>
<blockquote>
<p>循环语句语法<br><em>循环语句</em> → <a href="../chapter3/10_Statements.html#for_statement"><em>for语句</em></a><br><em>循环语句</em> → <a href="../chapter3/10_Statements.html#for_in_statement"><em>for-in语句</em></a><br><em>循环语句</em> → <a href="../chapter3/10_Statements.html#wheetatype类型ile_statement"><em>while语句</em></a><br><em>循环语句</em> → <a href="../chapter3/10_Statements.html#do_while_statement"><em>do-while语句</em></a>  </p>
</blockquote>
<p><a name="for_statements"></a></p>
<h3 id="For_语句">For 语句</h3><p><code>for</code>语句只有在循环条件为真时重复执行代码块，此时计数器递增。</p>
<p><code>for</code>语句的形式如下：</p>
<blockquote>
<p>for <code>initialzation</code>; <code>condition</code>; <code>increment</code> {<br>    <code>statements</code><br>}  </p>
</blockquote>
<p><em>initialzation</em>、<em>condition</em> 和 <em>increment</em> 之间的分号，以及包围循环体 <em>statements</em> 的大括号都是不可省略的。</p>
<p><code>for</code>语句的执行流程如下：</p>
<ol>
<li><em>initialzation</em> <em>循环变量</em> 只会被执行一次，通常用于声明和初始化在接下来的循环中需要使用的变量。</li>
<li>判断 <em>condition</em> 循环条件：<br> 如果为<code>true</code>，<em>statements</em> <em>循环体</em> 将会被执行，然后转到第3步。如果为<code>false</code>，<em>statements</em> 和 <em>increment</em> <em>循环增量</em> 都不会被执行，<code>for</code>至此执行完毕。</li>
<li>计算 <em>increment</em> 表达式，然后转到第2步。</li>
</ol>
<p>在 <em>initialzation</em> 中定义的变量仅在<code>for</code>循环的作用域内有效。<em>condition</em> 表达式的值的类型必须遵循<code>BooleanType</code>协议。</p>
<blockquote>
<p>For 循环语法<br><em>for语句</em> → <strong>for</strong> <a href="../chapter3/10_Statements.html#for_init"><em>for初始条件</em></a> <em>可选</em> <strong>;</strong> <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a> <em>可选</em> <strong>;</strong> <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a> <em>可选</em> <a href="../chapter3/05_Declarations.html#code_block"><em>代码块</em></a><br><em>for语句</em> → <strong>for</strong> <strong>(</strong> <a href="../chapter3/10_Statements.html#for_init"><em>for初始条件</em></a> <em>可选</em> <strong>;</strong> <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a> <em>可选</em> <strong>;</strong> <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a> <em>可选</em> <strong>)</strong> <a href="../chapter3/05_Declarations.html#code_block"><em>代码块</em></a><br><em>for初始条件</em> → <a href="../chapter3/05_Declarations.html#variable_declaration"><em>变量声明</em></a> | <a href="../chapter3/04_Expressions.html#expression_list"><em>表达式列表</em></a>  </p>
</blockquote>
<p><a name="for-in_statements"></a></p>
<h3 id="For-In_语句">For-In 语句</h3><p><code>for-in</code>语句允许在重复执行代码块的同时，迭代集合（或遵循<code>Sequence</code>协议的任意类型）中的每一项。</p>
<p><code>for-in</code>语句的形式如下：</p>
<blockquote>
<p>for <code>item</code> in <code>collection</code> {<br>    <code>statements</code><br>}  </p>
</blockquote>
<p><code>for-in</code>语句在循环开始前会调用 <em>collection</em> 表达式的<code>generate</code>方法来获取一个生成器类型（这是一个遵循<code>Generator</code>协议的类型）的值。接下来循环开始，调用 <em>collection</em> 表达式的<code>next</code>方法。如果其返回值不是<code>None</code>，它将会被赋给 <em>item</em>，然后执行 <em>statements</em>，执行完毕后回到循环开始处；否则，将不会赋值给 <em>item</em> 也不会执行 <em>statements</em>，<code>for-in</code>至此执行完毕。</p>
<blockquote>
<p>For-In 循环语法<br><em>for-in语句</em> → <strong>for</strong> <a href="../chapter3/07_Patterns.html#pattern"><em>模式</em></a> <strong>in</strong> <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a> <a href="../chapter3/05_Declarations.html#code_block"><em>代码块</em></a>  </p>
</blockquote>
<p><a name="while_statements"></a></p>
<h3 id="While_语句">While 语句</h3><p><code>while</code>语句当循环条件为真时，允许重复执行代码块。</p>
<p><code>while</code>语句的形式如下：</p>
<blockquote>
<p>while <code>condition</code> {<br>    <code>statements</code><br>}  </p>
</blockquote>
<p><code>while</code>语句的执行流程如下：</p>
<ol>
<li>计算 <em>condition</em> 表达式：<br> 如果为真<code>true</code>，转到第2步。如果为<code>false</code>，<code>while</code>至此执行完毕。</li>
<li>执行 <em>statements</em> ，然后转到第1步。</li>
</ol>
<p>由于 <em>condition</em> 的值在 <em>statements</em> 执行前就已计算出，因此<code>while</code>语句中的 <em>statements</em> 可能会被执行若干次，也可能不会被执行。</p>
<p><em>condition</em> 表达式的值的类型必须遵循<code>BooleanType</code>协议。同时，<em>condition</em> 表达式也可以使用可选绑定，详情参见<a href="../chapter2/01_The_Basics.html#optional_binding">可选绑定</a>。</p>
<blockquote>
<p>While 循环语法<br><em>while语句</em> → <strong>while</strong> <a href="../chapter3/10_Statements.html#while_condition"><em>while条件</em></a> <a href="../chapter3/05_Declarations.html#code_block"><em>代码块</em></a><br><em>条件</em> → <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a> | <a href="../chapter3/05_Declarations.html#declaration"><em>声明</em></a><br><em>条件</em> → <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a><br><em>条件</em> → <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a> | <a href="TODO"><em>条件列表</em></a><br><em>条件</em> → <a href="../chapter3/10_Statement.html#availability"><em>可用条件</em></a> <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a><br><em>条件列表</em> → <a href="TODO"><em>条件条件</em></a>  <a href="TODO"><em>条件列表</em></a><br><em>条件</em> → <a href="../chapter3/10_Statement.html#availability"><em>可用条件</em></a> <a href="../chapter2/01_The_Basics.html#optional_binding">可选绑定条件</a><br><em>case条件</em> → <strong>case</strong> <a href="../chapter3/07_Patterns.html#pattern"><em>模式</em></a> <a href="TODO">构造器</a> <a href="DOTO">where</a><br><em>可选绑定条件</em> → <a href="TODO">可选绑定头</a> <a href="TODO">持续可选绑定</a> <a href="TODO">持续可选绑定列表</a><br><em>可选绑定头</em> → <strong>let</strong> <a href="../chapter3/07_Patterns.html#pattern"><em>模式</em></a>  <a href="TODO">构造器</a>  <strong>var</strong>  <a href="../chapter3/07_Patterns.html#pattern"><em>模式</em></a>  <a href="TODO">构造器</a><br> <em>可持续绑定列表</em> →  <a href="../chapter3/07_Patterns.html#pattern"><em>模式</em></a> |  <a href="TODO">构造器</a> <a href="TODO">可选绑定头</a></p>
</blockquote>
<p><a name="while-while_statements"></a></p>
<h3 id="Repeat-While_语句">Repeat-While 语句</h3><p><code>repeat-while</code>语句允许代码块被执行一次或多次。</p>
<p><code>repeat-while</code>语句的形式如下：</p>
<blockquote>
<p>repeat {<br>    <code>statements</code><br>} while <code>condition</code>  </p>
</blockquote>
<p><code>repeat-while</code>语句的执行流程如下：</p>
<ol>
<li>执行 <em>statements</em>，然后转到第2步。</li>
<li>计算 <em>condition</em> 表达式：<br> 如果为<code>true</code>，转到第1步。如果为<code>false</code>，<code>repeat-while</code>至此执行完毕。</li>
</ol>
<p>由于 <em>condition</em> 表达式的值是在 <em>statements</em> 执行后才计算出，因此<code>repeat-while</code>语句中的 <em>statements</em> 至少会被执行一次。</p>
<p><em>condition</em> 表达式的值的类型必须遵循<code>BooleanType</code>协议。同时，<em>condition</em> 表达式也可以使用可选绑定，详情参见<a href="../chapter2/01_The_Basics.html#optional_binding">可选绑定</a>。</p>
<blockquote>
<p>Repeat-While 循环语法  </p>
<ul>
<li>repeat-while语句<em> → <strong>repeat</strong> [</em>代码块<em>](../chapter3/05_Declarations.html#code_block) <strong>while</strong> [</em>while条件*](../chapter3/10_Statements.html#while_condition)  </li>
</ul>
</blockquote>
<p><a name="branch_statements"></a></p>
<h2 id="分支语句">分支语句</h2><p>取决于一个或者多个条件的值，分支语句允许程序执行指定部分的代码。显然，分支语句中条件的值将会决定如何分支以及执行哪一块代码。Swift 提供两种类型的分支语句：<code>if</code>语句和<code>switch</code>语句。</p>
<p><code>switch</code>语句中的控制流可以用<code>break</code>语句修改，详情请见<a href="#break_statement">Break 语句</a>。</p>
<blockquote>
<p>分支语句语法<br><em>分支语句</em> → <a href="../chapter3/10_Statements.html#if_statement"><em>if语句</em></a><br><em>分支语句</em> → <a href="../chapter3/10_Statements.html#switch_statement"><em>switch语句</em></a>  </p>
</blockquote>
<p><a name="if_statements"></a></p>
<h3 id="If_语句">If 语句</h3><p>取决于一个或多个条件的值，<code>if</code>语句将决定执行哪一块代码。</p>
<p><code>if</code>语句有两种标准形式，在这两种形式里都必须有大括号。</p>
<p>第一种形式是当且仅当条件为真时执行代码，像下面这样：</p>
<blockquote>
<p>if <code>condition</code> {<br>    <code>statements</code><br>}  </p>
</blockquote>
<p>第二种形式是在第一种形式的基础上添加 <em>else 语句</em>，当只有一个 else 语句时，像下面这样：</p>
<blockquote>
<p>if <code>condition</code> {<br>    <code>statements to execute if condition is true</code><br>} else {<br>    <code>statements to execute if condition is false</code><br>}</p>
</blockquote>
<p>同时，else 语句也可包含<code>if</code>语句，从而形成一条链来测试更多的条件，像下面这样：</p>
<blockquote>
<p>if <code>condition 1</code> {<br>    <code>statements to execute if condition 1 is true</code><br>} else if <code>condition 2</code> {<br>    <code>statements to execute if condition 2 is true</code><br>}<br>else {<br>    <code>statements to execute if both conditions are false</code><br>}  </p>
</blockquote>
<p><code>if</code>语句中条件的值的类型必须遵循<code>LogicValue</code>协议。同时，条件也可以使用可选绑定，详情参见<a href="../chapter2/01_The_Basics.html#optional_binding">可选绑定</a>。</p>
<blockquote>
<p>If语句语法<br><em>if语句</em> → <strong>if</strong> <a href="../chapter3/10_Statements.html#if_condition"><em>if条件</em></a> <a href="../chapter3/05_Declarations.html#code_block"><em>代码块</em></a> <a href="../chapter3/10_Statements.html#else_clause"><em>else(Clause)</em></a> <em>可选</em><br><em>if条件</em> → <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a> | <a href="../chapter3/05_Declarations.html#declaration"><em>声明</em></a><br><em>else(Clause)</em> → <strong>else</strong> <a href="../chapter3/05_Declarations.html#code_block"><em>代码块</em></a> | <strong>else</strong> <a href="../chapter3/10_Statements.html#if_statement"><em>if语句</em></a>     </p>
</blockquote>
<p><a name="guard_statements"></a></p>
<h3 id="Guard_语句">Guard 语句</h3><p><code>guard</code> 语句用来转移程序控制出其作用域，如果一个或者多个条件不成立。<br> <code>guard</code> 语句的格式如下：    </p>
<blockquote>
<p>guard <code>condition</code> else {<br>   <code>statements</code><br>}    </p>
</blockquote>
<p> <code>guard</code>语句中条件值的类型必须遵循<code>LogicValue</code>协议。且条件可以使用可选绑定，详情参见<a href="../chapter2/01_The_Basics.html#optional_binding">可选绑定</a>。</p>
<p> 在<code>guard</code>语句中声明的常量或者变量，可用范围从声明开始到作用域结束,常量和变量的值从可选绑定声明中分配。</p>
<p> <code>guard</code>语句需要有<code>else</code>子句，并且必须调用被<code>noreturn</code>属性标记的函数,或者使用下面的语句把程序执行转移到guard语句的作用域外。    </p>
<ul>
<li><code>return</code></li>
<li><code>break</code></li>
<li><code>continue</code></li>
<li><code>throw</code>    </li>
</ul>
<p>执行转移语句详情参见<a href="TODO">控制传递语句</a></p>
<p><a name="switch_statements"></a></p>
<h3 id="Switch_语句">Switch 语句</h3><p>取决于<code>switch</code>语句的<em>控制表达式（control expression）</em>，<code>switch</code>语句将决定执行哪一块代码。</p>
<p><code>switch</code>语句的形式如下：</p>
<blockquote>
<p>switch <code>control expression</code> {<br>    case <code>pattern 1</code>:<br>        <code>statements</code><br>    case <code>pattern 2</code> where <code>condition</code>:<br>        <code>statements</code><br>    case <code>pattern 3</code> where <code>condition</code>,<br>    <code>pattern 4</code> where <code>condition</code>:<br>        <code>statements</code><br>    default:<br>        <code>statements</code><br>}  </p>
</blockquote>
<p><code>switch</code>语句的<em>控制表达式（control expression）</em>会首先被计算，然后与每一个 case 的模式（pattern）进行匹配。如果匹配成功，程序将会执行对应的 case 分支里的 <em>statements</em>。另外，每一个 case 分支都不能为空，也就是说在每一个 case 分支中至少有一条语句。如果你不想在匹配到的 case 分支中执行代码，只需在该分支里写一条<code>break</code>语句即可。</p>
<p>可以用作控制表达式的值是十分灵活的，除了标量类型(scalar types，如<code>Int</code>、<code>Character</code>)外，你可以使用任何类型的值，包括浮点数、字符串、元组、自定义类的实例和可选（optional）类型，甚至是枚举类型中的成员值和指定的范围(range)等。关于在<code>switch</code>语句中使用这些类型，详情参见<a href="../chapter2/05_Control_Flow.html">控制流</a>一章的 <a href="../chapter2/05_Control_Flow.html#switch">Switch</a>。</p>
<p>你可以在模式后面添加一个起保护作用的表达式(guard expression)。<em>起保护作用的表达式</em>是这样构成的：关键字<code>where</code>后面跟着一个作为额外测试条件的表达式。因此，当且仅当<em>控制表达式</em>匹配一个<em>case</em>的某个模式且起保护作用的表达式为真时，对应 case 分支中的 <em>statements</em> 才会被执行。在下面的例子中，<em>控制表达式</em>只会匹配含两个相等元素的元组，如<code>(1, 1)</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">where</span> x == y:</span><br></pre></td></tr></table></figure>
<p>正如上面这个例子，也可以在模式中使用<code>let</code>（或<code>var</code>）语句来绑定常量（或变量）。这些常量（或变量）可以在其对应的起保护作用的表达式和其对应的<em>case</em>块里的代码中引用。但是，如果 case 中有多个模式匹配控制表达式，那么这些模式都不能绑定常量（或变量）。</p>
<p><code>switch</code>语句也可以包含默认（<code>default</code>）分支，只有其它 case 分支都无法匹配控制表达式时，默认分支中的代码才会被执行。一个<code>switch</code>语句只能有一个默认分支，而且必须在<code>switch</code>语句的最后面。</p>
<p>尽管模式匹配操作实际的执行顺序，特别是模式的计算顺序是不可知的，但是 Swift 规定<code>switch</code>语句中的模式匹配的顺序和书写源代码的顺序保持一致。因此，当多个模式含有相同的值且能够匹配控制表达式时，程序只会执行源代码中第一个匹配的 case 分支中的代码。</p>
<h4 id="Switch_语句必须是完备的">Switch 语句必须是完备的</h4><p>在 Swift 中，<code>switch</code>语句中控制表达式的每一个可能的值都必须至少有一个 case 分支与之对应。在某些情况下（例如，表达式的类型是<code>Int</code>），你可以使用默认块满足该要求。</p>
<h4 id="不存在隐式的贯穿(fall_through)">不存在隐式的贯穿(fall through)</h4><p>当匹配的 case 分支中的代码执行完毕后，程序会终止<code>switch</code>语句，而不会继续执行下一个 case 分支。这就意味着，如果你想执行下一个 case 分支，需要显式地在你需要的 case 分支里使用<code>fallthrough</code>语句。关于<code>fallthrough</code>语句的更多信息，详情参见 <a href="#fallthrough_statement">Fallthrough 语句</a>。</p>
<blockquote>
<p>Switch语句语法<br><em>switch语句</em> → <strong>switch</strong> <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a> <strong>{</strong> <a href="../chapter3/10_Statements.html#switch_cases"><em>SwitchCase列表</em></a> <em>可选</em> <strong>}</strong><br><em>SwitchCase列表</em> → <a href="../chapter3/10_Statements.html#switch_case"><em>SwitchCase</em></a> <a href="../chapter3/10_Statements.html#switch_cases"><em>SwitchCase列表</em></a> <em>可选</em><br><em>SwitchCase</em> → <a href="../chapter3/10_Statements.html#case_label"><em>case标签</em></a> <a href="../chapter3/10_Statements.html#statements"><em>多条语句(Statements)</em></a> | <a href="../chapter3/10_Statements.html#default_label"><em>default标签</em></a> <a href="../chapter3/10_Statements.html#statements"><em>多条语句(Statements)</em></a><br><em>SwitchCase</em> → <a href="../chapter3/10_Statements.html#case_label"><em>case标签</em></a> <strong>;</strong> | <a href="../chapter3/10_Statements.html#default_label"><em>default标签</em></a> <strong>;</strong><br><em>case标签</em> → <strong>case</strong> <a href="../chapter3/10_Statements.html#case_item_list"><em>case项列表</em></a> <strong>:</strong><br><em>case项列表</em> → <a href="../chapter3/07_Patterns.html#pattern"><em>模式</em></a> <a href="../chapter3/10_Statements.html#guard_clause"><em>guard-clause</em></a> <em>可选</em> | <a href="../chapter3/07_Patterns.html#pattern"><em>模式</em></a> <a href="../chapter3/10_Statements.html#guard_clause"><em>guard-clause</em></a> <em>可选</em> <strong>,</strong> <a href="../chapter3/10_Statements.html#case_item_list"><em>case项列表</em></a><br><em>default标签</em> → <strong>default</strong> <strong>:</strong><br><em>where-clause</em> → <strong>where</strong> <a href="../chapter3/10_Statements.html#guard"><em>guard-expression</em></a><br><em>where-expression</em> → <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a>  </p>
</blockquote>
<p><a name="labeled_statements"></a><br><a name="control_transfer_statements"></a></p>
<h2 id="带标签的语句">带标签的语句</h2><p>你可以在循环语句或<code>switch</code>语句前面加上<em>标签</em>，它由标签名和紧随其后的冒号(:)组成。在<code>break</code>和<code>continue</code>后面跟上标签名可以显式地在循环语句或<code>switch</code>语句中更改控制流，把控制权传递给指定标签标记的语句。关于这两条语句用法，详情参见 <a href="#break_statement">Break 语句</a>和 <a href="#continue_statement">Continue 语句</a>。</p>
<p>标签的作用域是该标签所标记的语句之后的所有语句。你可以不使用带标签的语句，但只要使用它，标签名就必唯一。</p>
<p>关于使用带标签的语句的例子，详情参见<a href="../chapter2/05_Control_Flow.html">控制流</a>一章的<a href="../chapter2/05_Control_Flow.html#labeled_statements">带标签的语句</a>。</p>
<blockquote>
<p>标记语句语法<br><em>标记语句(Labeled Statement)</em> → <a href="../chapter3/10_Statements.html#statement_label"><em>语句标签</em></a> <a href="../chapter3/10_Statements.html#loop_statement"><em>循环语句</em></a> | <a href="../chapter3/10_Statements.html#statement_label"><em>语句标签</em></a> <a href="../chapter3/10_Statements.html#switch_statement"><em>switch语句</em></a><br><em>语句标签</em> → <a href="../chapter3/10_Statements.html#label_name"><em>标签名称</em></a> <strong>:</strong><br><em>标签名称</em> → <a href="../chapter3/02_Lexical_Structure.html#identifier"><em>标识符</em></a>  </p>
</blockquote>
<p><a name="control_transfer_statements"></a></p>
<h2 id="控制传递语句">控制传递语句</h2><p>通过无条件地把控制权从一片代码传递到另一片代码，控制传递语句能够改变代码执行的顺序。Swift 提供四种类型的控制传递语句：<code>break</code>语句、<code>continue</code>语句、<code>fallthrough</code>语句和<code>return</code>语句。</p>
<blockquote>
<p>控制传递语句(Control Transfer Statement) 语法<br><em>控制传递语句</em> → <a href="../chapter3/10_Statements.html#break_statement"><em>break语句</em></a><br><em>控制传递语句</em> → <a href="../chapter3/10_Statements.html#continue_statement"><em>continue语句</em></a><br><em>控制传递语句</em> → <a href="../chapter3/10_Statements.html#fallthrough_statement"><em>fallthrough语句</em></a><br><em>控制传递语句</em> → <a href="../chapter3/10_Statements.html#return_statement"><em>return语句</em></a><br><em>控制传递语句</em> → <a href="../chapter3/10_Statements.html#throw_statement"><em>throw语句</em></a>  </p>
</blockquote>
<p><a name="break_statements"></a></p>
<h3 id="Break_语句">Break 语句</h3><p><code>break</code>语句用于终止循环或<code>switch</code>语句的执行。使用<code>break</code>语句时，可以只写<code>break</code>这个关键词，也可以在<code>break</code>后面跟上标签名（label name），像下面这样：</p>
<blockquote>
<p>break<br>break <code>label name</code></p>
</blockquote>
<p>当<code>break</code>语句后面带标签名时，可用于终止由这个标签标记的循环或<code>switch</code>语句的执行。</p>
<p>而当只写<code>break</code>时，则会终止<code>switch</code>语句或上下文中包含<code>break</code>语句的最内层循环的执行。</p>
<p>在这两种情况下，控制权都会被传递给循环或<code>switch</code>语句外面的第一行语句。</p>
<p>关于使用<code>break</code>语句的例子，详情参见<a href="../chapter2/05_Control_Flow.html">控制流</a>一章的 <a href="../chapter2/05_Control_Flow.html#break">Break</a> 和<a href="../chapter2/05_Control_Flow.html#labeled_statements">带标签的语句</a>。</p>
<blockquote>
<p>Break 语句语法<br><em>break语句</em> → <strong>break</strong> <a href="../chapter3/10_Statements.html#label_name"><em>标签名称</em></a> <em>可选</em>  </p>
</blockquote>
<p><a name="continue_statements"></a></p>
<h3 id="Continue_语句">Continue 语句</h3><p><code>continue</code>语句用于终止循环中当前迭代的执行，但不会终止该循环的执行。使用<code>continue</code>语句时，可以只写<code>continue</code>这个关键词，也可以在<code>continue</code>后面跟上标签名（label name），像下面这样：</p>
<blockquote>
<p>continue<br>continue <code>label name</code>  </p>
</blockquote>
<p>当<code>continue</code>语句后面带标签名时，可用于终止由这个标签标记的循环中当前迭代的执行。</p>
<p>而当只写<code>break</code>时，可用于终止上下文中包含<code>continue</code>语句的最内层循环中当前迭代的执行。</p>
<p>在这两种情况下，控制权都会被传递给循环外面的第一行语句。</p>
<p>在<code>for</code>语句中，<code>continue</code>语句执行后，<em>increment</em> 表达式还是会被计算，这是因为每次循环体执行完毕后 <em>increment</em> 表达式都会被计算。</p>
<p>关于使用<code>continue</code>语句的例子，详情参见<a href="../chapter2/05_Control_Flow.html">控制流</a>一章的 <a href="../chapter2/05_Control_Flow.html#continue">Continue</a> 和<a href="../chapter2/05_Control_Flow.html#labeled_statements">带标签的语句</a>。</p>
<blockquote>
<p>Continue 语句语法<br><em>continue语句</em> → <strong>continue</strong> <a href="../chapter3/10_Statements.html#label_name"><em>标签名称</em></a> <em>可选</em>  </p>
</blockquote>
<p><a name="fallthrough_statements"></a></p>
<h3 id="Fallthrough_语句">Fallthrough 语句</h3><p><code>fallthrough</code>语句用于在<code>switch</code>语句中传递控制权。<code>fallthrough</code>语句会把控制权从<code>switch</code>语句中的一个 case 传递给下一个 case 。这种传递是无条件的，即使下一个 case 的模式与<code>switch</code>语句的控制表达式的值不匹配。</p>
<p><code>fallthrough</code>语句可出现在<code>switch</code>语句中的任意 case 里，但不能出现在最后一个 case 分支中。同时，<code>fallthrough</code>语句也不能把控制权传递给使用了可选绑定的 case 分支。</p>
<p>关于在<code>switch</code>语句中使用<code>fallthrough</code>语句的例子，详情参见<a href="../chapter2/05_Control_Flow.html">控制流</a>一章的<a href="../chapter2/05_Control_Flow.html#control_transfer_statements">控制传递语句</a>。</p>
<blockquote>
<p>Fallthrough 语句语法<br><em>fallthrough语句</em> → <strong>fallthrough</strong>  </p>
</blockquote>
<p><a name="return_statements"></a></p>
<h3 id="Return_语句">Return 语句</h3><p><code>return</code>语句用于在函数或方法的实现中将控制权传递给调用者，接着程序将会从调用者的位置继续向下执行。</p>
<p>使用<code>return</code>语句时，可以只写<code>return</code>这个关键词，也可以在<code>return</code>后面跟上表达式，像下面这样：</p>
<blockquote>
<p>return<br>return <code>expression</code>  </p>
</blockquote>
<p>当<code>return</code>语句后面带表达式时，表达式的值将会返回给调用者。如果表达式值的类型与调用者期望的类型不匹配，Swift 则会在返回表达式的值之前将表达式值的类型转换为调用者期望的类型。</p>
<p>而当只写<code>return</code>时，仅仅是将控制权从该函数或方法传递给调用者，而不返回一个值。（这就是说，该函数或方法的返回类型为<code>Void</code>或<code>()</code>）</p>
<blockquote>
<p>Return 语句语法<br><em>return语句</em> → <strong>return</strong> <a href="../chapter3/04_Expressions.html#expression"><em>表达式</em></a> <em>可选</em>     </p>
</blockquote>
<p><a name="availability_statements"></a></p>
<h3 id="Availability_语句">Availability 语句</h3><p>可用性条件，被当做<code>if</code> ，<code>while</code> 语句的条件，并且 <code>guard</code> 语句在运行时会基于特定的语法格式查询接口的可用性。    </p>
<p>avaliability 语句的形式如下：</p>
<blockquote>
<p>if #available(<code>platform name version</code>,<code>...</code>, *) {<br>  <code>statements to execute if the APIs are available</code><br>} else {<br> <code>fallback statements to execute if the APIs are unavailable</code><br>}    </p>
</blockquote>
<p>可用性条件执行一个代码块时，取决于在运行时想要使用的接口是否可用。<br>当编译器检查到代码块中的接口是可用的，则从可用性条件中获取相应信息。    </p>
<p>可用性条件使用逗号分隔平台名称和版本列表。使用<code>iOS</code>，<code>OSX</code>，以及<code>watchOS</code>为平台名称，包括相应的版本号。*参数是必需的。在任何平台上代码块主体都被可用性条件保护起来，由满足最低部署条件的目标设备运行。        </p>
<p>与布尔类型条件不同，不能用逻辑运算符 <strong>&amp;&amp;</strong> 和 <strong>||</strong> 合并可用性条件。 </p>
<blockquote>
<p>可用性条件语法<br><em>可用性条件</em> → <strong>#available</strong> ( <a href="TODO">availability-arguments­</a> )<br><em>可用性条件</em> → <a href="TODO">availability-argument­</a> |  <a href="TODO">availability-argument</a>­ ,­ <a href="TODO">availability-arguments­</a><br><em>可用性条件</em> → <a href="TODO">平台名称</a>  <a href="TODO">版本号</a><br><em>可用性条件</em> →   <strong>*</strong><br><em>平台名称</em> →  <strong>iOS</strong> |  <strong>iOSApplicationExtension</strong><br><em>平台名称</em> → <strong>OSX</strong>  |  <strong>OSXApplicationExtension­</strong><br><em>平台名称</em> → <strong>watchOS</strong><br><em>版本号</em> → <a href="TODO">十进制数字</a><br><em>版本号</em> → <a href="TODO">十进制数字</a>  <strong>.</strong> <a href="TODO">十进制数字</a><br><em>版本号</em> → <a href="TODO">十进制数字</a>  <strong>.</strong> <a href="TODO">十进制数字</a> <strong>.</strong> <a href="TODO">十进制数字</a></p>
</blockquote>
<p><a name="throw_statements"></a></p>
<h3 id="Throw_语句">Throw 语句</h3><p><code>throw</code>语句出现在抛出函数或者抛出方法体内，或者类型被<code>throws</code>关键字标记的表达式体内。   </p>
<p><code>throw</code>语句使程序结束执行当前的作用域，并在封闭作用域中传播错误。抛出的错误会一直传播，直到被<code>do</code>语句的<code>catch</code>子句处理掉。    </p>
<p><code>throw</code>语句由<code>throw</code>关键字 跟一个表达式组成 ，如下所示。    </p>
<blockquote>
<p>throw <code>expression</code>    </p>
</blockquote>
<p>表达式值的类型必须遵循 <code>LogicValue</code>协议     </p>
<p>关于如何使用<code>throw</code>语句的例子，详情参见<a href="TODO">错误处理</a>一章的<a href="TODO">抛出错误</a>。    </p>
<blockquote>
<p>throw 语句语法<br><em>抛出语句</em> → <strong>throw</strong>  <em><a href="TODO">表达式­</a></em>    </p>
</blockquote>
<p><a name="defer_statements"></a></p>
<h3 id="Defer_语句">Defer 语句</h3><p> <code>defer</code> 语句用于转移程序控制出延迟语句作用域之前执行代码。    </p>
<p>在 <code>defer</code> 语句中的语句无论程序控制如何转移都会执行。这意味着 <code>defer</code> 语句可以被使用在以下这些情况，像手动得执行资源管理，关闭文件描述，或者即使抛出了错误也需要去实现执行一些动作。    </p>
<p>如果多个 <code>defer</code> 语句出现在同一范围内，那么它们执行的顺序与出现的顺序相反。给定作用域中的第一个<code>defer</code> 语句，会在最后执行，这意味着最后执行的延迟语句中的语句涉及的资源可以被其他 <code>defer</code>语句清理掉。    </p>
<blockquote>
<p>1  func f( ) {<br>2  defer { print(“First”) }<br>3  defer { print(“Second”) }<br>4  defer { print(“Third”) }<br>5  }<br>6  f()<br>7  // prints “Third”<br>8  // prints “Second”<br>9  // prints “First”    </p>
</blockquote>
<p><code>defer</code> 语句中的语句无法转移程序控制出延迟语句。    </p>
<blockquote>
<p>defer 语句语法<br><em>延迟语句</em>  → <strong>defer</strong> <em><a href="TODO">代码块</a></em>    </p>
</blockquote>
<p><a name="do_statements"></a></p>
<h3 id="Do_语句">Do 语句</h3><p><code>do</code> 语句用于引入一个新的作用域,该作用域中可以含有一个或多个<code>catch</code>子句,catch子句中定义了一些匹配错误情况的模式。<code>do</code> 语句作用域内定义的常量和变量，只能在do语句作用域内访问。    </p>
<p>swift 中的 do 语句与C 中限定代码块界限的大括号 （{}）很相似，并且在程序运行的时候并不会造成系统开销。    </p>
<blockquote>
<p>do {<br>   try <code>expression</code><br>   <code>statements</code><br>} catch <code>pattern 1</code> {<br>    <code>statements</code><br>} catch <code>pattern 2</code> where condition {<br>    <code>statements</code><br>}    </p>
</blockquote>
<p>如同<code>switch</code>语句,编译器会判断<code>catch</code>子句是否被遗漏。如果catch没有被遗漏，则认为错误被处理。否则，错误会自动传播出包含作用域,被一个封闭的<code>catch</code>语句或抛出函数处理掉，包含函数必须以<code>throws</code>关键字声明。    </p>
<p>为了确保错误已经被处理，使用一个匹配所有错误的<code>catch</code>子句，如通配符模式（_）。如果一个<code>catch</code>子句不指定一种模式，<code>catch</code>子句会匹配和约束任何局部变量命名的<code>error</code>。有关在<code>catch</code>子句中使用模式的更多信息，详见<a href="TODO">模式</a>。    </p>
<p>关于在一些<code>catch</code>子句中如何使用<code>do</code>语句的例子，详情参见<a href="TODO">错误处理</a>一章的<a href="TODO">抛出错误</a>。       </p>
<blockquote>
<p>do 语句语法  → <strong>do</strong> <em>[</em>代码块<em>](../chapter3/05_Declarations.html#code_block) <a href="TODO">catch</a></em><br>catch  → <em><a href="TODO">catch子句</a> <a href="TODO">catch子句</a></em><br>catch  → <strong>catch</strong> <em>[</em>模式<em>](../chapter3/07_Patterns.html#pattern)** </em>可选的<em> [</em>where<em>]() </em>可选的<em>  [</em>代码块*](../chapter3/05_Declarations.html#code_block)</p>
</blockquote>
<p><a name="compiler_control_statements"></a></p>
<h3 id="编译控制语句">编译控制语句</h3><p>编译控制语句允许程序改变编译器的行为。Swift 有两种编译控制语句：构建配置语句和源代码控制语句。</p>
<blockquote>
<p>编译控制语句语法<br><em>编译控制语句</em>   → <a href="../chapter3/04_Expressions.html#build_config_statements"><em>构建配置语句</em></a><br><em>编译控制语句</em>   → <a href="../chapter3/04_Expressions.html#line_control_statements"><em>源代码控制语句</em></a></p>
</blockquote>
<p><a name="build_config_statements"></a></p>
<h4 id="构建配置语句">构建配置语句</h4><p>构建配置语句可以根据一个或多个配置项来有条件的编译代码。</p>
<p>每一个构建配置语句都以 <code>#if</code> 开始， <code>#endif</code> 结束。如下是一个简单的构建配置语句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">if</span> build configuration</span></span><br><span class="line">statements</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>和 <code>if</code> 语句的条件不同，构建配置的条件是在编译时进行判断的。它的结果是：只有构建配置在编译时判断为 <code>true</code> 的情况下语句才会被编译和执行。</p>
<p><em>构建配置</em> 可以是 <code>true</code> 和 <code>false</code> 的常量，也可以是使用 <code>-D</code> 命令行标志的标识符，或者是下列表格中的任意一个平台测试方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>可用参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>os()</td>
<td>OSX, iOS, watchOS, tvOS</td>
</tr>
<tr>
<td>arch()</td>
<td>i386, x86_64, arm, arm64 ｜</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意<br><code>arch(arm)</code> 构建配置在 ARM 64位设备上不会返回 <code>true</code>。如果代码的构建目标是 32 位的 iOS 模拟器，<code>arch(i386)</code> 构建配置返回 <code>true</code>。</p>
</blockquote>
<p>你可以使用逻辑操作符 <code>&amp;&amp;</code>、<code>||</code> 和 <code>!</code> 来连接构建配置，还可以使用圆括号来进行分组。</p>
<p>就像 <code>if</code> 语句一样，你可以使用  <code>#elseif</code> 分句来添加任意多个条件分支来测试不同的构建配置。你也可以使用 <code>#else</code> 分句来添加最终的条件分支。包含多个分支的构建配置语句例子如下：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">if</span> build configuration 1</span></span><br><span class="line">statements <span class="keyword">to</span> compile <span class="keyword">if</span> build configuration <span class="number">1</span> <span class="keyword">is</span> <span class="literal">true</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">elseif</span> build configuration 2</span></span><br><span class="line">statements <span class="keyword">to</span> compile <span class="keyword">if</span> build configuration <span class="number">2</span> <span class="keyword">is</span> <span class="literal">true</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">statements <span class="keyword">to</span> compile <span class="keyword">if</span> both build configurations are <span class="literal">false</span></span><br><span class="line"><span class="preprocessor">#endif</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>即使没有被编译，构建配置语句中的每一个分句仍然会被解析。</p>
</blockquote>
<hr>
<blockquote>
<p>构建配置语句语法<br>单个构建配置语句 → #if­ 多个构建配置语句（可选） 多个构建配置 <code>elseif</code> 分句（可选）­ 单个构建配置 <code>else</code> 分句（可选）­#endif­<br>多个构建配置 <code>elseif</code> 分句 → 单个构建配置 <code>elseif</code>­ 分句 多个构建配置 <code>elseif</code> 分句（可选）<br>单个构建配置 <code>elseif</code>­ 分句 → #elseif­ 多个构建配置语句（可选）<br>单个构建配置 <code>else</code> 分句 → #else­ 语句（可选）<br>构建配置 → 平台测试方法<br>构建配置 → 标识符<br>构建配置 → boolean 常量<br>构建配置 → (­构建配置­)­<br>构建配置 → !­ 构建配置­<br>构建配置 → 构建配置 &amp;&amp;­ 构建配置­<br>构建配置 → 构建配置 ­||­ 构建配置­<br>平台测试方法 → os­(­操作系统)­<br>平台测试方法 → arch­(­架构)­<br>操作系统 → OSX­  iOS­  watchOS­  tvOS­<br>架构 → i386­  x86_64­  arm­  arm64­</p>
</blockquote>
<p><a name="line_control_statements"></a></p>
<h4 id="源代码控制语句">源代码控制语句</h4><p>源代码控制语句用来给被编译源代码指定一个与原始行号和文件名不同的行号和文件名。使用源代码控制语句可以改变 Swift 使用源代码的位置，以便进行分析和测试。</p>
<p>源代码的控制语句的例子如下：</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#line line number filename</span></span><br></pre></td></tr></table></figure>
<p>源代码控制语句改变了常量表达式 <code>__LINE__</code> 和 <code>__FILE__</code> 的值，以一行源代码开头，然后跟着源代码控制语句。<code>line number</code> 改变了 <code>__LINE__</code> 的值，它是一个大于 0 的常量。<code>filename</code> 改变了 <code>__FILE__</code> 的值，它是一个字符串常量。</p>
<p>你可以通过写一句不指定 <code>line number</code> 和 <code>filename</code> 的源代码控制语句来吧源代码的位置回退到初始的行号和文件。</p>
<p>源代码控制语句必须出现在源代码的那一行，而且不能是源代码文件的最后一行。</p>
<blockquote>
<p>源代码控制语句</p>
<p>源代码控制语句 → #line­<br>源代码控制语句 → #line­ line-number­ file-name­<br>line-number → 大于 0 的十进制数<br>file-name → 字符串常量</p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter4/01_Access_Control/" itemprop="url">
                第四章-01Access Control 权限控制的黑与白
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T10:00:10+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter4/01_Access_Control/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter4/01_Access_Control/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="Access_Control_权限控制的黑与白">Access Control 权限控制的黑与白</h1><blockquote>
<p>翻译：<a href="http://weibo.com/littlekok/" target="_blank" rel="external">老码团队翻译组-Arya</a><br>校对：<a href="http://weibo.com/u/5241713117" target="_blank" rel="external">老码团队翻译组-Oberyn</a></p>
</blockquote>
<p>如果您之前没有接触过权限控制，先来听一个小故事：</p>
<blockquote>
<p> 小明是五道口工业学院的一个大一新生，最近他有点烦恼，因为同屋经常用他的热水壶，好像那是自己家的一样，可是碍于同学情面，又不好意思说。直到有一天，他和学姐小K吐槽。</p>
<p> 学姐听了之后，说：大学集体生活里面，大部分东西都是默认室友可以共用的。如果你不想别人拿，我可以帮你做封印，只要打上private标记，它们就看不到你的东西，更加用不了你的东西了。</p>
<p> 小明说哇靠学姐你还会妖法……</p>
</blockquote>
<p>Swift语言从Xcode 6 beta 5版本起，加入了对权限控制（Access Control）的支持。其实权限控制和小明的物品一样，你可以设定水壶是只有自己能用，还是只有宿舍里的人能用，还是全校都可以用。</p>
<p>从此以后，你可以好像神盾局局长一样，完全掌控自己的代码块的”保密级别“，哪些是只能在本文件引用，哪些能用在整个项目里，你还可以发挥大爱精神，把它开源成只要导入你的框架，大家都可以使用的API。</p>
<p>这三种权限分别是：</p>
<ul>
<li><p>#####private 私有的</p>
<p>  在哪里写的，就在哪里用。无论是类、变量、常量还是函数，一旦被标记为私有的，就只能在定义他们的源文件里使用，不能为别的文件所用。</p>
</li>
<li><p>#####internal 内部的</p>
<p>  标记为internal的代码块，在整个应用（App bundle）或者框架（framework）的范围内都是可以访问的。</p>
</li>
<li><p>#####public 公开的</p>
<p>  标记为public的代码块一般用来建立API，这是最开放的权限，使得任何人只要导入这个模块，都可以访问使用。</p>
</li>
</ul>
<p>如果要把所有的爱加上一个期限，噢不，是给所有的代码块都标记上权限，不累死才怪。还好swift里面所有代码实体的默认权限，都是最常用的internal。所以当你开发自己的App时，可能完全不用管权限控制的事情。</p>
<p>但当你需要写一个公开API的时候，就必须对里面的代码块进行“隐身对其可见”的public标记，要么其他人是用不到的。</p>
<p>Private（私有级别）的权限最严格，它可以用来隐藏某些功能的细节实现方式。合理构筑你的代码，你就可以安全地使用extension和高级功能，又不把它们暴露给项目内的其他文件。</p>
<p>除了可以给整个声明设权限，Swift还允许大家在需要的时候，把某个属性（property）的取值权限比赋值权限设得更加开放。</p>
<p>#####举个例子：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ListItem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ListItem这个类，有两个公开的属性</span></span><br><span class="line">public <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line">public <span class="keyword">var</span> isComplete: <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的代码表示把变量UUID的赋值权限设为private，对整个app可读，但值只能在本文件里写入</span></span><br><span class="line">private(<span class="keyword">set</span>) <span class="keyword">var</span> <span class="type">UUID</span>: <span class="type">NSUUID</span></span><br><span class="line"></span><br><span class="line">public <span class="keyword">init</span>(text: <span class="type">String</span>, completed: <span class="type">Bool</span>, <span class="type">UUID</span>: <span class="type">NSUUID</span>) &#123;</span><br><span class="line">	<span class="keyword">self</span>.text = text</span><br><span class="line">	<span class="keyword">self</span>.isComplete = completed</span><br><span class="line">	<span class="keyword">self</span>.<span class="type">UUID</span> = <span class="type">UUID</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这段没有特别标记权限，因此属于默认的internal级别。在框架目标内可用，但对于其他目标不可用</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">refreshIdentity</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">self</span>.<span class="type">UUID</span> = <span class="type">NSUUID</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">isEqual</span><span class="params">(object: AnyObject?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> item = object <span class="keyword">as</span>? <span class="type">ListItem</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">self</span>.<span class="type">UUID</span> == item.<span class="type">UUID</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们使用Objective-C和Swift混合开发时，需要注意：</p>
<ul>
<li><p>如果你在写的是一个应用，Xcode会生成一个头文件来保证两者的可互访性，而这个生成的头文件会包含public和internal级别的声明。</p>
</li>
<li><p>如果你的最终产品是一个Swift框架，头文件里只会出现标记为public级别的声明。（因为框架的头文件，属于公开的Objective-C接口的一部分，只有public部分对Objective-C可用。）</p>
</li>
</ul>
<p>虽然Swift不推荐大家传播和使用第三方的框架，但对于建立和分享源文件形式的框架是支持的。对于需要写框架，方便应用与多个项目的开发者来说，要记得把API标记为public级别。</p>
<p>如果您想了解更多关于权限控制的内容，可以查看苹果官方最新的《The Swift Language》和《Using Swift with Cocoa and Objective-C》指南，<br>这两本指南在iBooks里面可以下载更新喔。</p>
<p>本文由翻译自Apple Swift Blog ：<a href="https://developer.apple.com/swift/blog/?id=5" target="_blank" rel="external">https://developer.apple.com/swift/blog/?id=5</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter4/02_Type_Custom/" itemprop="url">
                第四章-02造个类型不是梦-白话Swift类型创建
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T10:00:09+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter4/02_Type_Custom/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter4/02_Type_Custom/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="造个类型不是梦-白话Swift类型创建">造个类型不是梦-白话Swift类型创建</h1><hr>
<blockquote>
<p>翻译：<a href="http://weibo.com/u/5241713117" target="_blank" rel="external">老码团队翻译组-Tyrion</a><br>校对：<a href="http://weibo.com/u/5241713117" target="_blank" rel="external">老码团队翻译组-Oberyn</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#prototype">自定义原型</a></li>
<li><a href="#imp-default">实现默认值</a></li>
<li><a href="#init-by-bool">支持基本布尔型初始化</a></li>
<li><a href="#condition-by-bool">支持Bool类型判断</a></li>
<li><a href="#support-all-type">支持兼容各们各派的类型</a></li>
<li><a href="#make-up-type">完善OCBool的布尔基因体系</a></li>
</ul>
<p>小伙伴们，Swift中的Bool类型有着非常重要的语法功能，并支撑起了整个Swift体系中的逻辑判断体系，经过老码的研究和学习， Bool类型本身其实是对基础Boolean类型封装，小伙伴们可能咬着手指头问老码，怎么一会Bool类型，一会Boolean类型，其区别在于，前者是基于枚举的组合类型，而后者则是基本类型，只有两种true和false。</p>
<p><a name="prefix_expressions"></a></p>
<p>####自定义原型<br>接下老码根据Bool的思想来创建一个OCBool类型，来让小伙伴们了解一下Swift中到底是怎么玩儿的。<br>来我们先看一下OCBool的定义。</p>
<p>#####代码示例如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">OCBool</span></span>&#123;</span><br><span class="line"><span class="keyword">case</span> ocTrue</span><br><span class="line"><span class="keyword">case</span> ocFalse</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>#####注意：</p>
<ul>
<li>代码中第2行和第3行，可以合并到一行写，如苹果官方Blog所写的一样</li>
<li>代码中命名需要注意：OCBool是类型名，所以首字母必须大写，而case中的ocTrue和ocFalse是小类型则需要首字母小写。</li>
</ul>
<p><a name="imp-default"></a></p>
<p>####实现默认值<br>行，我们给了一个漂亮的定义，不过按照传统语言的经验，Bool值默认情况下是假， 所以我们的OCBool也应该如此，我们使用类型扩展技术增加这个默认特性：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">OCBool</span></span>&#123;</span><br><span class="line">     <span class="keyword">init</span>()&#123;</span><br><span class="line">             <span class="keyword">self</span> =.ocFalse</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>#####注意：</p>
<ul>
<li>代码中第1行：extension关键字，非常强大，小伙伴们可以通过此创造出许多好玩的东西，建议各位去Github上看一个名为“Swiftz”的项目，它将扩展用到了极致。</li>
<li>代码中第3行：self = .ocFalse语法，刚入门的小伙伴们很迷糊，为什么会有奇怪的点语法，因为大牛Chris在Swift中增加了类型智能推断功能，在苹果Blog中，提到了“Context”概念，就是这个意思，因为这行语句是在枚举OCBool中的，其上下文就是OCBool的定义体，编译器当然知道.ocFalse就是OCBool.ocFalse了，所以这里直接点语法，非常整齐。<br>现在我们可以使用如下方法使用这个Bool类型。</li>
</ul>
<p>#####代码示例如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result:<span class="type">OCBool</span> = <span class="type">OCBool</span>()</span><br><span class="line"><span class="keyword">var</span> result1:<span class="type">OCBool</span> = .ocTrue</span><br></pre></td></tr></table></figure></p>
<p><a name="init-by-bool"></a></p>
<p>####支持基本布尔型初始化<br>正如上述代码所述，我们只能通过类型或者枚举项目赋值，这是组合类型的用法，但是编码的日子里，我们总是希望和true，false直接打交道，也就是说，我们希望这么做，<br>代码示例如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isSuccess:<span class="type">OCBool</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>如果小伙伴们直接这么用，则会出现如下错误：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/Users/</span>tyrion-OldCoder<span class="regexp">/Documents/</span>Learning<span class="regexp">/BoolType/</span>BoolType/main.<span class="string">swift:</span><span class="number">30</span>:<span class="number">24</span>: Type <span class="string">'OCBool'</span> does not conform to protocol <span class="string">'BooleanLiteralConvertible'</span></span><br></pre></td></tr></table></figure></p>
<p>编译器咆哮的原因是，我们的类型没有遵从“布尔字面量转换协议”，接下来修正这个问题，</p>
<p>#####代码示例如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"Hello, World!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">OCBool</span></span>&#123;</span><br><span class="line">    <span class="keyword">case</span> ocTrue</span><br><span class="line">    <span class="keyword">case</span> ocFalse</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">OCBool</span>: <span class="title">BooleanLiteralConvertible</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">convertFromBooleanLiteral</span><span class="params">( value: Bool)</span></span> -&gt;<span class="type">OCBool</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value ? ocTrue : ocFalse</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isSuccess:<span class="type">OCBool</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>#####注意：</p>
<ul>
<li><p>代码中的第11行是重点，我的类型OCBool支持了BooleanLiteralConvertible协议，这个协到底是干什么的呢，小伙伴们在Xcode代码编辑器，按住Command键，然后点击第11行中的BooleanLiteralConvertible协议名，则会进入它的定义，<br>#####其定义如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">BooleanLiteralConvertible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">BooleanLiteralType</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">convertFromBooleanLiteral</span>(<span class="title">value</span>: <span class="title">BooleanLiteralType</span>) -&gt; <span class="title">Self</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>这个定义中有个类方法convertFromBooleanLiteral，它的参数为BooleanLiteralType类型，也就是我传入的Bool类型， 且返回值为实现这个协议的类型本身，在我们的OCBool类型中，其返回值就是OCBool本身。经过这个定义，我们可以直接对OCBool类型直接进行布尔字面量初始化了。</p>
</li>
</ul>
<p><a name="condition-by-bool"></a></p>
<p>####支持Bool类型判断<br>小伙伴们不安分， 肯定想着我怎么用它实现逻辑判断，所以如果你这么写，</p>
<p>#####代码示例如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isSuccess:<span class="type">OCBool</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> isSuccess &#123;</span><br><span class="line">    <span class="built_in">println</span>( <span class="string">"老码请你吃火锅！"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你永远吃不到老码的火锅，因为这里编译器会咆哮：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/Users/</span>tyrion-OldCoder<span class="regexp">/Documents/</span>Learning<span class="regexp">/BoolType/</span>BoolType/main.<span class="string">swift:</span><span class="number">27</span>:<span class="number">4</span>: Type <span class="string">'OCBool'</span> does not conform to protocol <span class="string">'LogicValue'</span></span><br></pre></td></tr></table></figure></p>
<p>OCBool现在只能用bool类型初始化，而不能直接返回bool型，小火把们还记得在《老码说编程之白话Swift江湖》中，老码多次提到，妈妈再也不担心我们 if a = 1{}的写法了， 因为等号不支持值返回了， 所以在if判断是后面的条件必须有返回值，OCBool没有，所以编译器哭了。我们解决这个问题。</p>
<p>#####代码示例如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"Hello, World!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">OCBool</span></span>&#123;</span><br><span class="line">    <span class="keyword">case</span> ocTrue</span><br><span class="line">    <span class="keyword">case</span> ocFalse</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">OCBool</span>: <span class="title">BooleanLiteralConvertible</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">convertFromBooleanLiteral</span><span class="params">( value: Bool)</span></span> -&gt;<span class="type">OCBool</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value ? ocTrue : ocFalse</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">OCBool</span>: <span class="title">LogicValue</span></span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">getLogicValue</span><span class="params">()</span></span> -&gt;<span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> boolValue: <span class="type">Bool</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span>&#123;</span><br><span class="line">        <span class="keyword">case</span> .ocTrue:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">case</span> .ocFalse:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> boolValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isSuccess:<span class="type">OCBool</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> isSuccess &#123;</span><br><span class="line">    <span class="built_in">println</span>( <span class="string">"老码请你吃火锅！"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>####运行结果如下：<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br><span class="line">老码请你吃火锅！</span><br><span class="line"><span class="keyword">Program</span> ended <span class="keyword">with</span> <span class="keyword">exit</span> code: <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>#####注意：</p>
<ul>
<li>如果小伙伴们现在用的是Beta版的Xcode，注意苹果官方Blog中，在代码第17行如果在Xcode Beta4下是错误的，这里的协议是，LogicValue而不是BooleanVue，所以记得看错误提示才是好习惯。</li>
<li>注意代码第34行，完美支持if判断，且输出结果为“老码请你吃火锅”，老码也是说说而已，请不要当真。</li>
</ul>
<p><a name="support-all-type"></a></p>
<p>####支持兼容各们各派的类型<br>小伙伴们，江湖风险，门派众多，老码有自己的OCBool类型，可能嵩山少林有自己的SSBool类型，甚至连郭美美都可能有自己的MMBool类型，所以OCBool必须能够识别这些类型，这些各门各派的类型，只要支持LogicValue协议，就应该可以被识别，看老码怎么做，</p>
<p>#####代码示例如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">OCBool</span></span>&#123;</span><br><span class="line">    <span class="keyword">init</span>( <span class="number">_</span> v: <span class="type">LogicValue</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> v.getLogicValue()&#123;</span><br><span class="line">            <span class="keyword">self</span> = .ocTrue</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">self</span> = .ocFalse</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mmResult: <span class="type">Bool</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> ocResult:<span class="type">OCBool</span> = <span class="type">OCBool</span>(mmResult)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ocResult &#123;</span><br><span class="line">    <span class="built_in">println</span>( <span class="string">"老码没钱，郭美美请你吃火锅！"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>#####代码运行结果如下：<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br><span class="line">老码没钱，郭美美请你吃火锅！</span><br><span class="line"><span class="keyword">Program</span> ended <span class="keyword">with</span> <span class="keyword">exit</span> code: <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>漂亮！我们的OCBool类型现在支持了所有的逻辑变量初始化。</p>
<p>#####注意：</p>
<ul>
<li>代码中第2行：“_”下横杠的用法，这是一个功能强大的小强，在此的目的是屏蔽外部参数名，所以小伙伴们可以直接：var ocResult:OCBool = OCBool(mmResult)而不是：var ocResult:OCBool = OCBool(v: mmResult)，小伙伴们惊呆了！这个init函数中本来就没有外部参数名啊，还记得老码在书里说过没，Swift的初始化函数会默认使用内部参数名，作为外部参数名。</li>
</ul>
<p><a name="make-up-type"></a></p>
<p>####完善OCBool的布尔基因体系：<br>小伙伴们，bool类型的价值就是在于各种判断，诸如==，!=, &amp;，|,^,!，以及各种组合逻辑运算，我们OCBool也要具备这些功能，否则就会基因缺陷，且看老码如何实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">OCBool</span>: <span class="title">Equatable</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//支持等值判断运算符</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> ==<span class="params">( <span class="keyword">left</span>: OCBool, <span class="keyword">right</span>: OCBool )</span></span>-&gt;<span class="type">Bool</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">left</span>, <span class="keyword">right</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> (.ocTrue, .ocTrue):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//支持位与运算符</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> &amp;<span class="params">( <span class="keyword">left</span>:OCBool, <span class="keyword">right</span>: OCBool)</span></span>-&gt;<span class="type">OCBool</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">left</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">right</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//支持位或运算符</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> |<span class="params">( <span class="keyword">left</span>:OCBool, <span class="keyword">right</span>: OCBool)</span></span>-&gt;<span class="type">OCBool</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">left</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">right</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//支持位异或运算符</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> ^<span class="params">( <span class="keyword">left</span>:OCBool, <span class="keyword">right</span>: OCBool)</span></span>-&gt;<span class="type">OCBool</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">OCBool</span>( <span class="keyword">left</span> != <span class="keyword">right</span> )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//支持求反运算符</span></span><br><span class="line"><span class="preprocessor">@prefix</span> <span class="func"><span class="keyword">func</span> !<span class="params">( a:OCBool )</span></span>-&gt; <span class="type">OCBool</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a ^ <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//支持组合求与运算符</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> &amp;= <span class="params">(<span class="keyword">inout</span> <span class="keyword">left</span>:OCBool, <span class="keyword">right</span>:OCBool )</span></span>&#123;</span><br><span class="line">    <span class="keyword">left</span> = <span class="keyword">left</span> &amp; <span class="keyword">right</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isHasMoney:<span class="type">OCBool</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> isHasWife:<span class="type">OCBool</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> isHasHealty:<span class="type">OCBool</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> isHasLover:<span class="type">OCBool</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">isHasMoney != isHasHealty</span><br><span class="line">isHasHealty == isHasMoney</span><br><span class="line">isHasWife ^ isHasLover</span><br><span class="line">isHasWife = !isHasLover</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isHasMoney | isHasHealty) &amp; isHasHealty&#123;</span><br><span class="line">    <span class="built_in">println</span>( <span class="string">"人生赢家，就像老码一样！"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"人生最苦的事事，人死了钱没花了，人生最苦的事是，人活着，钱没了！"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，到这里就到这里了，窗外的雷声叫醒了老码，现在应该去吃饭了，以上老码给大家展示了如果制造一个自己的类型，记得老码的示例是在Xcode6 Beta4下测试的，至于Beta5的改变还没有涉及，小伙伴们要好生练习，以后各种自定类型都是基于这个思想。还有这个章节不是老码的原创，老码认真的阅读了苹果的官方博客，且自己的练习总结，如果小伙伴们费了吃奶的劲还是看不懂，请找度娘谷歌，还是看不懂请到老码官方微博：<a href="http://weibo.com/u/5241713117咆哮。" target="_blank" rel="external">http://weibo.com/u/5241713117咆哮。</a></p>
<p>本文由翻译自Apple Swift Blog ：<a href="https://developer.apple.com/swift/blog/?id=8" target="_blank" rel="external">https://developer.apple.com/swift/blog/?id=8</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter4/03_Ballons/" itemprop="url">
                第四章-03WWDC里面的那个“大炮打气球”
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T10:00:08+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter4/03_Ballons/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter4/03_Ballons/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="WWDC里面的那个“大炮打气球”">WWDC里面的那个“大炮打气球”</h1><blockquote>
<p>翻译：<a href="http://weibo.com/littlekok/" target="_blank" rel="external">老码团队翻译组-Arya</a><br>校对：<a href="Jame">老码团队翻译组-</a></p>
</blockquote>
<p><img src="https://devimages.apple.com.edgekey.net/swift/images/swift-screenshot.jpg" alt="Ballon playground"></p>
<p>很多小伙伴说，对WWDC上介绍Swift语言时，演示的那个“大炮打气球”的Ballons项目很感兴趣。</p>
<p>Ballons不但展现了playgrounds许多很赞的特性，还让我们看到写代码的过程，原来可以这么互动，这么好玩。</p>
<p>现在你可以下载这个<a href="https://developer.apple.com/swift/blog/downloads/Balloons.zip" target="_blank" rel="external">Ballons.playground</a>的教学版本，学习这些有趣的效果是怎么实现的。教学版本里除了源文件，还有相关说明文档，我们还出了一些小小的实验题，你可以动手修改代码，然后在右侧马上看到效果。</p>
<p>这个playground文件用到了SpriteKit的新特性，因此需要最新beta版本的Xcode 6和Yosemite系统来支持它运行。</p>
<p>本文由翻译自Apple Swift Blog的博文：<a href="https://developer.apple.com/swift/blog/?id=9" target="_blank" rel="external">Ballons</a> </p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter4/04_Interacting_with_C_Pointers/" itemprop="url">
                第四章-04Swift与C语言指针友好合作
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T10:00:07+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter4/04_Interacting_with_C_Pointers/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter4/04_Interacting_with_C_Pointers/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="Swift与C语言指针友好合作">Swift与C语言指针友好合作</h1><hr>
<blockquote>
<p>翻译：<a href="http://weibo.com/penguinliong/" target="_blank" rel="external">老码团队翻译组-Relly</a><br>校对：<a href="http://weibo.com/u/5241713117" target="_blank" rel="external">老码团队翻译组-Tyrion</a> </p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#inout-para-pointer">用以输入/输出的参数指针</a></li>
<li><a href="#array-as-para-pointer">作为数组使用的参数指针</a></li>
<li><a href="#string-as-para-pointer">用作字符串参数的指针</a></li>
<li><a href="#security-of-pointer-cast">指针参数转换的安全性</a></li>
</ul>
<p>Objective-C和C的API常常会需要用到指针。Swift中的数据类型都原生支持基于指针的Cocoa API，不仅如此，Swift会自动处理部分最常用的将指针作为参数传递的情况。这篇文章中，我们将着眼于在Swift中让C语言指针与变量、数组和字符串共同工作。</p>
<p>####用以输入/输出的参数指针<br>C和Objective-C并不支持多返回值，所以Cocoa API中常常将指针作为一种在方法间传递额外数据的方式。Swift允许指针被当作<code>inout</code>参数使用，所以你可以用符号<code>&amp;</code>将对一个变量的引用作为指针参数传递。举例来说：<code>UIColor</code>中的<code>getRed(_:green:blue:alpha:)</code>方法需要四个<code>CGFloat*</code>指针来接收颜色的组成信息，我们使用<code>&amp;</code>来将这些组成信息捕获为本地变量：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r: <span class="type">CGFloat</span> = <span class="number">0</span>, g: <span class="type">CGFloat</span> = <span class="number">0</span>, b: <span class="type">CGFloat</span> = <span class="number">0</span>, a: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">color.getRed(&amp;r, green: &amp;g, blue: &amp;b, alpha: &amp;a)</span><br></pre></td></tr></table></figure></p>
<p>另一种常见的情况是Cocoa中<code>NSError</code>的习惯用法。许多方法会使用一个<code>NSError**</code>参数来储存可能的错误的信息。举例来说：我们用<code>NSFileManager</code>的<code>contentOfDirectoryAtPath(_:error:)</code>方法来将目录下的内容列表，并将潜在的错误指向一个<code>NSError?</code>变量：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maybeError: <span class="type">NSError</span>?</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> contents = <span class="type">NSFileManager</span>.defaultManager()</span><br><span class="line">	.contentsOfDirectoryAtPath(<span class="string">"/usr/bin"</span>, error: &amp;maybeError) &#123;</span><br><span class="line">	<span class="comment">// Work with the directory contents</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> error = maybeError &#123;</span><br><span class="line">	<span class="comment">// Handle the error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了安全性，Swift要求被使用<code>&amp;</code>传递的变量已经初始化。因为无法确定这个方法会不会在写入数据前尝试从指针中读取数据。</p>
<p>####作为数组使用的参数指针<br>在C语言中，数组和指针的联系十分紧密，而Swift允许数组能够作为指针使用，从而与基于数组的C语言API协同工作更加简单。一个固定的数组可以使用一个常量指针直接传递，一个变化的数组可以用<code>&amp;</code>运算符将一个非常量指针传递。就和输入/输出参数指针一样。举例来说：我们可以用Accelerate框架中的<code>vDSP_vadd</code>方法让两个数组<code>a</code>和<code>b</code>相加，并将结果写入第三个数组<code>result</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Accelerate</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: [<span class="type">Float</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> b: [<span class="type">Float</span>] = [<span class="number">0.5</span>, <span class="number">0.25</span>, <span class="number">0.125</span>, <span class="number">0.0625</span>]</span><br><span class="line"><span class="keyword">var</span> result: [<span class="type">Float</span>] = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">vDSP_vadd(a, <span class="number">1</span>, b, <span class="number">1</span>, &amp;result, <span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// result now contains [1.5, 2.25, 3.125, 4.0625]</span></span><br></pre></td></tr></table></figure></p>
<p>#用作字符串参数的指针<br>C语言中用<code>cont char*</code>指针来作为传递字符串的基本方式。Swift中的<code>String</code>可以被当作一个无限长度UTF-8编码的<code>const char*</code>指针来传递给方法。举例来说：我们可以直接传递一个字符串给一个标准C和POSIX库方法<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">puts(<span class="string">"Hello from libc"</span>)</span><br><span class="line"><span class="keyword">let</span> fd = open(<span class="string">"/tmp/scratch.txt"</span>, <span class="type">O_WRONLY</span>|<span class="type">O_CREAT</span>, <span class="number">0o666</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> fd &lt; <span class="number">0</span> &#123;</span><br><span class="line">	perror(<span class="string">"could not open /tmp/scratch.txt"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> text = <span class="string">"Hello World"</span></span><br><span class="line">	write(fd, text, strlen(text))</span><br><span class="line">	close(fd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>#指针参数转换的安全性<br>Swift很努力地使与C语言指针的交互更加便利，因为它们广泛地存在于Cocoa之中，同时保持一定的安全性。然而，相比你的其他Swift代码与C语言的指针交互具有潜在的不安全性，所以务必要小心使用。其中特别要注意：</p>
<ul>
<li><p>如果被调用者为了在其返回值之后再次使用而保存了C指针的数据，那么这些转换使用起来并不安全。转换后的指针仅在调用期间保证有效。甚至你将同样的变量、数组或字符串作为多指针参数再次传递，你每次都会收到一个不同的指针。这个异常将全局或静态地储存为变量。你可以安全地将这段地址当作永久唯一的指针使用。例如：作为一个KVO上下文参数使用的时候。</p>
</li>
<li><p>当指针类型为<code>Array</code>或<code>String</code>时，溢出检查不是强制进行的。 基于C语言的API无法增加数组和字符串大小，所以在你将其传递到基于C语言的API之前，你必须确保数组或字符的大小正确。</p>
</li>
</ul>
<p>如果你需要使用基于指针的API时没有遵守以上指导，或是你重写了接受指针参数的Cocoa方法，于是你可以在Swift中直接用不安全的指针来使用未经处理的内存。在未来的文章中我们将着眼于更加高级的情况。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter4/05_Value_and_Reference_Types/" itemprop="url">
                第四章-05Swift里的值类型与引用类型
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T10:00:06+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter4/05_Value_and_Reference_Types/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter4/05_Value_and_Reference_Types/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="Swift里的值类型与引用类型">Swift里的值类型与引用类型</h1><hr>
<blockquote>
<p>翻译：<a href="http://weibo.com/littlekok/" target="_blank" rel="external">老码团队翻译组-Arya</a><br>校对：<a href="http://weibo.com/u/5241713117" target="_blank" rel="external">老码团队翻译组-Jame</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#difference-two">值类型与引用类型的区别</a></li>
<li><a href="#act-in=mutation">Mutation（修改）在安全中扮演的角色</a></li>
<li><a href="#how-to-choose">如何选择类型</a></li>
</ul>
<h3 id="Swift里面的类型分为两种：">Swift里面的类型分为两种：</h3><ul>
<li><strong>值类型(Value Types)</strong>：每个实例都保留了一分独有的数据拷贝，一般以结构体 <code>（struct）</code>、<code>枚举（enum）</code> 或者<code>元组（tuple）</code>的形式出现。</li>
<li><strong>引用类型(Reference Type)</strong>：每个实例共享同一份数据来源，一般以<code>类（class）</code>的形式出现。</li>
</ul>
<p>在这篇博文里面，我们会介绍两种类型各自的优点，以及应该怎么选择使用。</p>
<p><a name="difference-two"></a></p>
<h4 id="值类型与引用类型的区别">值类型与引用类型的区别</h4><p>值类型和引用类型最基本的分别在复制之后的结果。当一个值类型被复制的时候，相当于创造了一个完全独立的实例，这个实例保有属于自己的独有数据，数据不会受到其他实例的数据变化影响：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是一个值类型的例子</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> </span>&#123; <span class="keyword">var</span> data: <span class="type">Int</span> = -<span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="type">S</span>()</span><br><span class="line"><span class="keyword">var</span> b = a							<span class="comment">// b是a的拷贝</span></span><br><span class="line">a.data = <span class="number">42</span>							<span class="comment">// 更改a的数据，b的不受影响</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"<span class="subst">\(a.data)</span>, <span class="subst">\(b.data)</span>"</span>)		<span class="comment">// 输出结果 "42, -1"</span></span><br></pre></td></tr></table></figure>
<p>值类型就好像身份证复印件一样，复印出来之后，修改原件上面的内容，复印件上的内容不会变。</p>
<p>另一方面，复制一个引用类型的时候，实际上是默默地创造了一个共享的实例分身，两者是共用一套数据。因此修改其中任何一个实例的数据，也会影响到另外那个。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是一个引用类型的例子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123; <span class="keyword">var</span> data: <span class="type">Int</span> = -<span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="type">C</span>()</span><br><span class="line"><span class="keyword">var</span> y = x							<span class="comment">// y是x的拷贝</span></span><br><span class="line">x.data = <span class="number">42</span>							<span class="comment">// 更改x的数据，等于同时修改了y</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"<span class="subst">\(x.data)</span>, <span class="subst">\(y.data)</span>"</span>)		<span class="comment">// 输出结果 "42, 42"</span></span><br></pre></td></tr></table></figure>
<p><a name="act-in=mutation"></a></p>
<h4 id="Mutation（修改）在安全中扮演的角色">Mutation（修改）在安全中扮演的角色</h4><p>值类型较引用类型来说，会让你更容易在大量代码中理清状况。如果你总是得到一个独立的拷贝出来的实例，你就可以放心它不会被你app里面的其他部分代码默默地修改。这在多线程的环境里面是尤为重要的，因为另外一个线程可能会在暗地里修改你的数据。因此可能会造成严重的程序错误，这在调试过程中非常难以排除。</p>
<p>由于差别主要在于修改数据的后果，那么当实例的数据只读，不存在需要更改的情况下，用哪种类型都是没有分别的。</p>
<p>你可能在想，有的时候我可能也需要一个完全不变的类。这样使用<code>Cocoa NSObject</code>对象的时候会比较容易，又可以保留值语义的好处。在今天，你可以通过只使用不可变的存储属性，和避开任何可以修改状态的API，用Swift写出一个不可变类<code>（immutable class）</code>。实际上，很多基本的Cocoa类，例如<code>NSURL</code>，都是设计成不可变类的。然而，Swift语言目前只强制<code>struct</code>和<code>enum</code>这种值类型的不可变性，对类这种引用类型则没有。（例如还不支持强制将子类的限制为不可变类）</p>
<p><a name="how-to-choose"></a></p>
<h4 id="如何选择类型？">如何选择类型？</h4><p>所以当我们想要建立一个新的类型的时候，怎么决定用值类型还是引用类型呢？当你使用Cocoa框架的时候，很多API都要通过NSObject的子类使用，所以这时候必须要用到引用类型class。在其他情况下，有下面几个准则：</p>
<ul>
<li><p><strong>什么时候该用值类型</strong>：</p>
<ul>
<li>要用==运算符来比较实例的数据时</li>
<li>你希望那个实例的拷贝能保持独立的状态时</li>
<li>数据会被多个线程使用时</li>
</ul>
</li>
<li><p><strong>什么时候该用引用类型（class）</strong>：</p>
<ul>
<li>要用==运算符来比较实例身份的时候</li>
<li>你希望有创建一个共享的、可变对象的时候</li>
</ul>
</li>
</ul>
<p>在Swift里面，数组(Array)、字符串(String)、字典(Dictionary)都属于值类型。它们就像C语言里面简单的int值，是一个个独立的数据个体。你不需要花任何功夫来防范其他代码在暗地里修改它们。更重要的是，你可以在线程之间安全的传递变量，而不需要特地去同步。在Swift高安全性的精神下，这个模式会帮助你用Swift写出更可控的代码。</p>
<hr>
<p>本章节不是老码的原创，老码认真的阅读了苹果的官方博客，且自己的练习总结，如果小伙伴们费了吃奶的劲还是看不懂，请找度娘谷歌，还是看不懂请到老码<a href="http://weibo.com/u/5241713117" target="_blank" rel="external">官方微博</a>咆哮。  </p>
<h5 id="本文由翻译自Apple_Swift_Blog_：Value_and_Reference_Types">本文由翻译自Apple Swift Blog ：<a href="https://developer.apple.com/swift/blog/?id=10" target="_blank" rel="external">Value and Reference Types</a></h5></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/">&laquo;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/9/">&raquo;</a>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="https://avatars2.githubusercontent.com/u/14305708?v=3&s=460" alt="terry" itemprop="image"/>
          <p class="site-author-name" itemprop="name">terry</p>
        </div>
        <p class="site-description motion-element" itemprop="description">terry yang's blog | java | scala | bi</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">136</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">11</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-next-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yangwei8888" target="_blank">github</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/microsoftgoogles" target="_blank">weibo</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/run-zhi-38" target="_blank">zhihu</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">terry</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  

    <script type="text/javascript">
      var disqus_shortname = 'yangwei888';
      var disqus_identifier = 'page/8/index.html';
      var disqus_title = '';
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
