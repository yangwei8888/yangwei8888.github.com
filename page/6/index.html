<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="terry yang's blog | java | scala | bi" />



  <meta name="keywords" content="Hexo,next" />



  <link rel="alternate" href="/atom.xml" title="yosita" type="application/atom+xml" />



  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="terry yang&apos;s blog | java | scala | bi">
<meta property="og:type" content="website">
<meta property="og:title" content="yosita">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="yosita">
<meta property="og:description" content="terry yang&apos;s blog | java | scala | bi">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="yosita">
<meta name="twitter:description" content="terry yang&apos;s blog | java | scala | bi">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>

  <title> yosita </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  

  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?7e8961fdae021b7bf62f2c767bb18c23";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">yosita</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter4/01_Access_Control/" itemprop="url">
                第四章-01Access Control 权限控制的黑与白
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T10:00:10+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter4/01_Access_Control/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter4/01_Access_Control/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="Access_Control_权限控制的黑与白">Access Control 权限控制的黑与白</h1><blockquote>
<p>翻译：<a href="http://weibo.com/littlekok/" target="_blank" rel="external">老码团队翻译组-Arya</a><br>校对：<a href="http://weibo.com/u/5241713117" target="_blank" rel="external">老码团队翻译组-Oberyn</a></p>
</blockquote>
<p>如果您之前没有接触过权限控制，先来听一个小故事：</p>
<blockquote>
<p> 小明是五道口工业学院的一个大一新生，最近他有点烦恼，因为同屋经常用他的热水壶，好像那是自己家的一样，可是碍于同学情面，又不好意思说。直到有一天，他和学姐小K吐槽。</p>
<p> 学姐听了之后，说：大学集体生活里面，大部分东西都是默认室友可以共用的。如果你不想别人拿，我可以帮你做封印，只要打上private标记，它们就看不到你的东西，更加用不了你的东西了。</p>
<p> 小明说哇靠学姐你还会妖法……</p>
</blockquote>
<p>Swift语言从Xcode 6 beta 5版本起，加入了对权限控制（Access Control）的支持。其实权限控制和小明的物品一样，你可以设定水壶是只有自己能用，还是只有宿舍里的人能用，还是全校都可以用。</p>
<p>从此以后，你可以好像神盾局局长一样，完全掌控自己的代码块的”保密级别“，哪些是只能在本文件引用，哪些能用在整个项目里，你还可以发挥大爱精神，把它开源成只要导入你的框架，大家都可以使用的API。</p>
<p>这三种权限分别是：</p>
<ul>
<li><p>#####private 私有的</p>
<p>  在哪里写的，就在哪里用。无论是类、变量、常量还是函数，一旦被标记为私有的，就只能在定义他们的源文件里使用，不能为别的文件所用。</p>
</li>
<li><p>#####internal 内部的</p>
<p>  标记为internal的代码块，在整个应用（App bundle）或者框架（framework）的范围内都是可以访问的。</p>
</li>
<li><p>#####public 公开的</p>
<p>  标记为public的代码块一般用来建立API，这是最开放的权限，使得任何人只要导入这个模块，都可以访问使用。</p>
</li>
</ul>
<p>如果要把所有的爱加上一个期限，噢不，是给所有的代码块都标记上权限，不累死才怪。还好swift里面所有代码实体的默认权限，都是最常用的internal。所以当你开发自己的App时，可能完全不用管权限控制的事情。</p>
<p>但当你需要写一个公开API的时候，就必须对里面的代码块进行“隐身对其可见”的public标记，要么其他人是用不到的。</p>
<p>Private（私有级别）的权限最严格，它可以用来隐藏某些功能的细节实现方式。合理构筑你的代码，你就可以安全地使用extension和高级功能，又不把它们暴露给项目内的其他文件。</p>
<p>除了可以给整个声明设权限，Swift还允许大家在需要的时候，把某个属性（property）的取值权限比赋值权限设得更加开放。</p>
<p>#####举个例子：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ListItem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ListItem这个类，有两个公开的属性</span></span><br><span class="line">public <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line">public <span class="keyword">var</span> isComplete: <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的代码表示把变量UUID的赋值权限设为private，对整个app可读，但值只能在本文件里写入</span></span><br><span class="line">private(<span class="keyword">set</span>) <span class="keyword">var</span> <span class="type">UUID</span>: <span class="type">NSUUID</span></span><br><span class="line"></span><br><span class="line">public <span class="keyword">init</span>(text: <span class="type">String</span>, completed: <span class="type">Bool</span>, <span class="type">UUID</span>: <span class="type">NSUUID</span>) &#123;</span><br><span class="line">	<span class="keyword">self</span>.text = text</span><br><span class="line">	<span class="keyword">self</span>.isComplete = completed</span><br><span class="line">	<span class="keyword">self</span>.<span class="type">UUID</span> = <span class="type">UUID</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这段没有特别标记权限，因此属于默认的internal级别。在框架目标内可用，但对于其他目标不可用</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">refreshIdentity</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">self</span>.<span class="type">UUID</span> = <span class="type">NSUUID</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">isEqual</span><span class="params">(object: AnyObject?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> item = object <span class="keyword">as</span>? <span class="type">ListItem</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">self</span>.<span class="type">UUID</span> == item.<span class="type">UUID</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们使用Objective-C和Swift混合开发时，需要注意：</p>
<ul>
<li><p>如果你在写的是一个应用，Xcode会生成一个头文件来保证两者的可互访性，而这个生成的头文件会包含public和internal级别的声明。</p>
</li>
<li><p>如果你的最终产品是一个Swift框架，头文件里只会出现标记为public级别的声明。（因为框架的头文件，属于公开的Objective-C接口的一部分，只有public部分对Objective-C可用。）</p>
</li>
</ul>
<p>虽然Swift不推荐大家传播和使用第三方的框架，但对于建立和分享源文件形式的框架是支持的。对于需要写框架，方便应用与多个项目的开发者来说，要记得把API标记为public级别。</p>
<p>如果您想了解更多关于权限控制的内容，可以查看苹果官方最新的《The Swift Language》和《Using Swift with Cocoa and Objective-C》指南，<br>这两本指南在iBooks里面可以下载更新喔。</p>
<p>本文由翻译自Apple Swift Blog ：<a href="https://developer.apple.com/swift/blog/?id=5" target="_blank" rel="external">https://developer.apple.com/swift/blog/?id=5</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter4/02_Type_Custom/" itemprop="url">
                第四章-02造个类型不是梦-白话Swift类型创建
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T10:00:09+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter4/02_Type_Custom/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter4/02_Type_Custom/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="造个类型不是梦-白话Swift类型创建">造个类型不是梦-白话Swift类型创建</h1><hr>
<blockquote>
<p>翻译：<a href="http://weibo.com/u/5241713117" target="_blank" rel="external">老码团队翻译组-Tyrion</a><br>校对：<a href="http://weibo.com/u/5241713117" target="_blank" rel="external">老码团队翻译组-Oberyn</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#prototype">自定义原型</a></li>
<li><a href="#imp-default">实现默认值</a></li>
<li><a href="#init-by-bool">支持基本布尔型初始化</a></li>
<li><a href="#condition-by-bool">支持Bool类型判断</a></li>
<li><a href="#support-all-type">支持兼容各们各派的类型</a></li>
<li><a href="#make-up-type">完善OCBool的布尔基因体系</a></li>
</ul>
<p>小伙伴们，Swift中的Bool类型有着非常重要的语法功能，并支撑起了整个Swift体系中的逻辑判断体系，经过老码的研究和学习， Bool类型本身其实是对基础Boolean类型封装，小伙伴们可能咬着手指头问老码，怎么一会Bool类型，一会Boolean类型，其区别在于，前者是基于枚举的组合类型，而后者则是基本类型，只有两种true和false。</p>
<p><a name="prefix_expressions"></a></p>
<p>####自定义原型<br>接下老码根据Bool的思想来创建一个OCBool类型，来让小伙伴们了解一下Swift中到底是怎么玩儿的。<br>来我们先看一下OCBool的定义。</p>
<p>#####代码示例如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">OCBool</span></span>&#123;</span><br><span class="line"><span class="keyword">case</span> ocTrue</span><br><span class="line"><span class="keyword">case</span> ocFalse</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>#####注意：</p>
<ul>
<li>代码中第2行和第3行，可以合并到一行写，如苹果官方Blog所写的一样</li>
<li>代码中命名需要注意：OCBool是类型名，所以首字母必须大写，而case中的ocTrue和ocFalse是小类型则需要首字母小写。</li>
</ul>
<p><a name="imp-default"></a></p>
<p>####实现默认值<br>行，我们给了一个漂亮的定义，不过按照传统语言的经验，Bool值默认情况下是假， 所以我们的OCBool也应该如此，我们使用类型扩展技术增加这个默认特性：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">OCBool</span></span>&#123;</span><br><span class="line">     <span class="keyword">init</span>()&#123;</span><br><span class="line">             <span class="keyword">self</span> =.ocFalse</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>#####注意：</p>
<ul>
<li>代码中第1行：extension关键字，非常强大，小伙伴们可以通过此创造出许多好玩的东西，建议各位去Github上看一个名为“Swiftz”的项目，它将扩展用到了极致。</li>
<li>代码中第3行：self = .ocFalse语法，刚入门的小伙伴们很迷糊，为什么会有奇怪的点语法，因为大牛Chris在Swift中增加了类型智能推断功能，在苹果Blog中，提到了“Context”概念，就是这个意思，因为这行语句是在枚举OCBool中的，其上下文就是OCBool的定义体，编译器当然知道.ocFalse就是OCBool.ocFalse了，所以这里直接点语法，非常整齐。<br>现在我们可以使用如下方法使用这个Bool类型。</li>
</ul>
<p>#####代码示例如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result:<span class="type">OCBool</span> = <span class="type">OCBool</span>()</span><br><span class="line"><span class="keyword">var</span> result1:<span class="type">OCBool</span> = .ocTrue</span><br></pre></td></tr></table></figure></p>
<p><a name="init-by-bool"></a></p>
<p>####支持基本布尔型初始化<br>正如上述代码所述，我们只能通过类型或者枚举项目赋值，这是组合类型的用法，但是编码的日子里，我们总是希望和true，false直接打交道，也就是说，我们希望这么做，<br>代码示例如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isSuccess:<span class="type">OCBool</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>如果小伙伴们直接这么用，则会出现如下错误：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/Users/</span>tyrion-OldCoder<span class="regexp">/Documents/</span>Learning<span class="regexp">/BoolType/</span>BoolType/main.<span class="string">swift:</span><span class="number">30</span>:<span class="number">24</span>: Type <span class="string">'OCBool'</span> does not conform to protocol <span class="string">'BooleanLiteralConvertible'</span></span><br></pre></td></tr></table></figure></p>
<p>编译器咆哮的原因是，我们的类型没有遵从“布尔字面量转换协议”，接下来修正这个问题，</p>
<p>#####代码示例如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"Hello, World!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">OCBool</span></span>&#123;</span><br><span class="line">    <span class="keyword">case</span> ocTrue</span><br><span class="line">    <span class="keyword">case</span> ocFalse</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">OCBool</span>: <span class="title">BooleanLiteralConvertible</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">convertFromBooleanLiteral</span><span class="params">( value: Bool)</span></span> -&gt;<span class="type">OCBool</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value ? ocTrue : ocFalse</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isSuccess:<span class="type">OCBool</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>#####注意：</p>
<ul>
<li><p>代码中的第11行是重点，我的类型OCBool支持了BooleanLiteralConvertible协议，这个协到底是干什么的呢，小伙伴们在Xcode代码编辑器，按住Command键，然后点击第11行中的BooleanLiteralConvertible协议名，则会进入它的定义，<br>#####其定义如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">BooleanLiteralConvertible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">BooleanLiteralType</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">convertFromBooleanLiteral</span>(<span class="title">value</span>: <span class="title">BooleanLiteralType</span>) -&gt; <span class="title">Self</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>这个定义中有个类方法convertFromBooleanLiteral，它的参数为BooleanLiteralType类型，也就是我传入的Bool类型， 且返回值为实现这个协议的类型本身，在我们的OCBool类型中，其返回值就是OCBool本身。经过这个定义，我们可以直接对OCBool类型直接进行布尔字面量初始化了。</p>
</li>
</ul>
<p><a name="condition-by-bool"></a></p>
<p>####支持Bool类型判断<br>小伙伴们不安分， 肯定想着我怎么用它实现逻辑判断，所以如果你这么写，</p>
<p>#####代码示例如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isSuccess:<span class="type">OCBool</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> isSuccess &#123;</span><br><span class="line">    <span class="built_in">println</span>( <span class="string">"老码请你吃火锅！"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你永远吃不到老码的火锅，因为这里编译器会咆哮：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/Users/</span>tyrion-OldCoder<span class="regexp">/Documents/</span>Learning<span class="regexp">/BoolType/</span>BoolType/main.<span class="string">swift:</span><span class="number">27</span>:<span class="number">4</span>: Type <span class="string">'OCBool'</span> does not conform to protocol <span class="string">'LogicValue'</span></span><br></pre></td></tr></table></figure></p>
<p>OCBool现在只能用bool类型初始化，而不能直接返回bool型，小火把们还记得在《老码说编程之白话Swift江湖》中，老码多次提到，妈妈再也不担心我们 if a = 1{}的写法了， 因为等号不支持值返回了， 所以在if判断是后面的条件必须有返回值，OCBool没有，所以编译器哭了。我们解决这个问题。</p>
<p>#####代码示例如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"Hello, World!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">OCBool</span></span>&#123;</span><br><span class="line">    <span class="keyword">case</span> ocTrue</span><br><span class="line">    <span class="keyword">case</span> ocFalse</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">OCBool</span>: <span class="title">BooleanLiteralConvertible</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">convertFromBooleanLiteral</span><span class="params">( value: Bool)</span></span> -&gt;<span class="type">OCBool</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value ? ocTrue : ocFalse</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">OCBool</span>: <span class="title">LogicValue</span></span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">getLogicValue</span><span class="params">()</span></span> -&gt;<span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> boolValue: <span class="type">Bool</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span>&#123;</span><br><span class="line">        <span class="keyword">case</span> .ocTrue:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">case</span> .ocFalse:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> boolValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isSuccess:<span class="type">OCBool</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> isSuccess &#123;</span><br><span class="line">    <span class="built_in">println</span>( <span class="string">"老码请你吃火锅！"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>####运行结果如下：<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br><span class="line">老码请你吃火锅！</span><br><span class="line"><span class="keyword">Program</span> ended <span class="keyword">with</span> <span class="keyword">exit</span> code: <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>#####注意：</p>
<ul>
<li>如果小伙伴们现在用的是Beta版的Xcode，注意苹果官方Blog中，在代码第17行如果在Xcode Beta4下是错误的，这里的协议是，LogicValue而不是BooleanVue，所以记得看错误提示才是好习惯。</li>
<li>注意代码第34行，完美支持if判断，且输出结果为“老码请你吃火锅”，老码也是说说而已，请不要当真。</li>
</ul>
<p><a name="support-all-type"></a></p>
<p>####支持兼容各们各派的类型<br>小伙伴们，江湖风险，门派众多，老码有自己的OCBool类型，可能嵩山少林有自己的SSBool类型，甚至连郭美美都可能有自己的MMBool类型，所以OCBool必须能够识别这些类型，这些各门各派的类型，只要支持LogicValue协议，就应该可以被识别，看老码怎么做，</p>
<p>#####代码示例如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">OCBool</span></span>&#123;</span><br><span class="line">    <span class="keyword">init</span>( <span class="number">_</span> v: <span class="type">LogicValue</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> v.getLogicValue()&#123;</span><br><span class="line">            <span class="keyword">self</span> = .ocTrue</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">self</span> = .ocFalse</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mmResult: <span class="type">Bool</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> ocResult:<span class="type">OCBool</span> = <span class="type">OCBool</span>(mmResult)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ocResult &#123;</span><br><span class="line">    <span class="built_in">println</span>( <span class="string">"老码没钱，郭美美请你吃火锅！"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>#####代码运行结果如下：<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br><span class="line">老码没钱，郭美美请你吃火锅！</span><br><span class="line"><span class="keyword">Program</span> ended <span class="keyword">with</span> <span class="keyword">exit</span> code: <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>漂亮！我们的OCBool类型现在支持了所有的逻辑变量初始化。</p>
<p>#####注意：</p>
<ul>
<li>代码中第2行：“_”下横杠的用法，这是一个功能强大的小强，在此的目的是屏蔽外部参数名，所以小伙伴们可以直接：var ocResult:OCBool = OCBool(mmResult)而不是：var ocResult:OCBool = OCBool(v: mmResult)，小伙伴们惊呆了！这个init函数中本来就没有外部参数名啊，还记得老码在书里说过没，Swift的初始化函数会默认使用内部参数名，作为外部参数名。</li>
</ul>
<p><a name="make-up-type"></a></p>
<p>####完善OCBool的布尔基因体系：<br>小伙伴们，bool类型的价值就是在于各种判断，诸如==，!=, &amp;，|,^,!，以及各种组合逻辑运算，我们OCBool也要具备这些功能，否则就会基因缺陷，且看老码如何实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">OCBool</span>: <span class="title">Equatable</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//支持等值判断运算符</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> ==<span class="params">( <span class="keyword">left</span>: OCBool, <span class="keyword">right</span>: OCBool )</span></span>-&gt;<span class="type">Bool</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">left</span>, <span class="keyword">right</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> (.ocTrue, .ocTrue):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//支持位与运算符</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> &amp;<span class="params">( <span class="keyword">left</span>:OCBool, <span class="keyword">right</span>: OCBool)</span></span>-&gt;<span class="type">OCBool</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">left</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">right</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//支持位或运算符</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> |<span class="params">( <span class="keyword">left</span>:OCBool, <span class="keyword">right</span>: OCBool)</span></span>-&gt;<span class="type">OCBool</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">left</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">right</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//支持位异或运算符</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> ^<span class="params">( <span class="keyword">left</span>:OCBool, <span class="keyword">right</span>: OCBool)</span></span>-&gt;<span class="type">OCBool</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">OCBool</span>( <span class="keyword">left</span> != <span class="keyword">right</span> )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//支持求反运算符</span></span><br><span class="line"><span class="preprocessor">@prefix</span> <span class="func"><span class="keyword">func</span> !<span class="params">( a:OCBool )</span></span>-&gt; <span class="type">OCBool</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a ^ <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//支持组合求与运算符</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> &amp;= <span class="params">(<span class="keyword">inout</span> <span class="keyword">left</span>:OCBool, <span class="keyword">right</span>:OCBool )</span></span>&#123;</span><br><span class="line">    <span class="keyword">left</span> = <span class="keyword">left</span> &amp; <span class="keyword">right</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isHasMoney:<span class="type">OCBool</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> isHasWife:<span class="type">OCBool</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> isHasHealty:<span class="type">OCBool</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> isHasLover:<span class="type">OCBool</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">isHasMoney != isHasHealty</span><br><span class="line">isHasHealty == isHasMoney</span><br><span class="line">isHasWife ^ isHasLover</span><br><span class="line">isHasWife = !isHasLover</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isHasMoney | isHasHealty) &amp; isHasHealty&#123;</span><br><span class="line">    <span class="built_in">println</span>( <span class="string">"人生赢家，就像老码一样！"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"人生最苦的事事，人死了钱没花了，人生最苦的事是，人活着，钱没了！"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，到这里就到这里了，窗外的雷声叫醒了老码，现在应该去吃饭了，以上老码给大家展示了如果制造一个自己的类型，记得老码的示例是在Xcode6 Beta4下测试的，至于Beta5的改变还没有涉及，小伙伴们要好生练习，以后各种自定类型都是基于这个思想。还有这个章节不是老码的原创，老码认真的阅读了苹果的官方博客，且自己的练习总结，如果小伙伴们费了吃奶的劲还是看不懂，请找度娘谷歌，还是看不懂请到老码官方微博：<a href="http://weibo.com/u/5241713117咆哮。" target="_blank" rel="external">http://weibo.com/u/5241713117咆哮。</a></p>
<p>本文由翻译自Apple Swift Blog ：<a href="https://developer.apple.com/swift/blog/?id=8" target="_blank" rel="external">https://developer.apple.com/swift/blog/?id=8</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter4/03_Ballons/" itemprop="url">
                第四章-03WWDC里面的那个“大炮打气球”
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T10:00:08+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter4/03_Ballons/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter4/03_Ballons/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="WWDC里面的那个“大炮打气球”">WWDC里面的那个“大炮打气球”</h1><blockquote>
<p>翻译：<a href="http://weibo.com/littlekok/" target="_blank" rel="external">老码团队翻译组-Arya</a><br>校对：<a href="Jame">老码团队翻译组-</a></p>
</blockquote>
<p><img src="https://devimages.apple.com.edgekey.net/swift/images/swift-screenshot.jpg" alt="Ballon playground"></p>
<p>很多小伙伴说，对WWDC上介绍Swift语言时，演示的那个“大炮打气球”的Ballons项目很感兴趣。</p>
<p>Ballons不但展现了playgrounds许多很赞的特性，还让我们看到写代码的过程，原来可以这么互动，这么好玩。</p>
<p>现在你可以下载这个<a href="https://developer.apple.com/swift/blog/downloads/Balloons.zip" target="_blank" rel="external">Ballons.playground</a>的教学版本，学习这些有趣的效果是怎么实现的。教学版本里除了源文件，还有相关说明文档，我们还出了一些小小的实验题，你可以动手修改代码，然后在右侧马上看到效果。</p>
<p>这个playground文件用到了SpriteKit的新特性，因此需要最新beta版本的Xcode 6和Yosemite系统来支持它运行。</p>
<p>本文由翻译自Apple Swift Blog的博文：<a href="https://developer.apple.com/swift/blog/?id=9" target="_blank" rel="external">Ballons</a> </p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter4/04_Interacting_with_C_Pointers/" itemprop="url">
                第四章-04Swift与C语言指针友好合作
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T10:00:07+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter4/04_Interacting_with_C_Pointers/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter4/04_Interacting_with_C_Pointers/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="Swift与C语言指针友好合作">Swift与C语言指针友好合作</h1><hr>
<blockquote>
<p>翻译：<a href="http://weibo.com/penguinliong/" target="_blank" rel="external">老码团队翻译组-Relly</a><br>校对：<a href="http://weibo.com/u/5241713117" target="_blank" rel="external">老码团队翻译组-Tyrion</a> </p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#inout-para-pointer">用以输入/输出的参数指针</a></li>
<li><a href="#array-as-para-pointer">作为数组使用的参数指针</a></li>
<li><a href="#string-as-para-pointer">用作字符串参数的指针</a></li>
<li><a href="#security-of-pointer-cast">指针参数转换的安全性</a></li>
</ul>
<p>Objective-C和C的API常常会需要用到指针。Swift中的数据类型都原生支持基于指针的Cocoa API，不仅如此，Swift会自动处理部分最常用的将指针作为参数传递的情况。这篇文章中，我们将着眼于在Swift中让C语言指针与变量、数组和字符串共同工作。</p>
<p>####用以输入/输出的参数指针<br>C和Objective-C并不支持多返回值，所以Cocoa API中常常将指针作为一种在方法间传递额外数据的方式。Swift允许指针被当作<code>inout</code>参数使用，所以你可以用符号<code>&amp;</code>将对一个变量的引用作为指针参数传递。举例来说：<code>UIColor</code>中的<code>getRed(_:green:blue:alpha:)</code>方法需要四个<code>CGFloat*</code>指针来接收颜色的组成信息，我们使用<code>&amp;</code>来将这些组成信息捕获为本地变量：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r: <span class="type">CGFloat</span> = <span class="number">0</span>, g: <span class="type">CGFloat</span> = <span class="number">0</span>, b: <span class="type">CGFloat</span> = <span class="number">0</span>, a: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">color.getRed(&amp;r, green: &amp;g, blue: &amp;b, alpha: &amp;a)</span><br></pre></td></tr></table></figure></p>
<p>另一种常见的情况是Cocoa中<code>NSError</code>的习惯用法。许多方法会使用一个<code>NSError**</code>参数来储存可能的错误的信息。举例来说：我们用<code>NSFileManager</code>的<code>contentOfDirectoryAtPath(_:error:)</code>方法来将目录下的内容列表，并将潜在的错误指向一个<code>NSError?</code>变量：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maybeError: <span class="type">NSError</span>?</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> contents = <span class="type">NSFileManager</span>.defaultManager()</span><br><span class="line">	.contentsOfDirectoryAtPath(<span class="string">"/usr/bin"</span>, error: &amp;maybeError) &#123;</span><br><span class="line">	<span class="comment">// Work with the directory contents</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> error = maybeError &#123;</span><br><span class="line">	<span class="comment">// Handle the error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了安全性，Swift要求被使用<code>&amp;</code>传递的变量已经初始化。因为无法确定这个方法会不会在写入数据前尝试从指针中读取数据。</p>
<p>####作为数组使用的参数指针<br>在C语言中，数组和指针的联系十分紧密，而Swift允许数组能够作为指针使用，从而与基于数组的C语言API协同工作更加简单。一个固定的数组可以使用一个常量指针直接传递，一个变化的数组可以用<code>&amp;</code>运算符将一个非常量指针传递。就和输入/输出参数指针一样。举例来说：我们可以用Accelerate框架中的<code>vDSP_vadd</code>方法让两个数组<code>a</code>和<code>b</code>相加，并将结果写入第三个数组<code>result</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Accelerate</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: [<span class="type">Float</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> b: [<span class="type">Float</span>] = [<span class="number">0.5</span>, <span class="number">0.25</span>, <span class="number">0.125</span>, <span class="number">0.0625</span>]</span><br><span class="line"><span class="keyword">var</span> result: [<span class="type">Float</span>] = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">vDSP_vadd(a, <span class="number">1</span>, b, <span class="number">1</span>, &amp;result, <span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// result now contains [1.5, 2.25, 3.125, 4.0625]</span></span><br></pre></td></tr></table></figure></p>
<p>#用作字符串参数的指针<br>C语言中用<code>cont char*</code>指针来作为传递字符串的基本方式。Swift中的<code>String</code>可以被当作一个无限长度UTF-8编码的<code>const char*</code>指针来传递给方法。举例来说：我们可以直接传递一个字符串给一个标准C和POSIX库方法<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">puts(<span class="string">"Hello from libc"</span>)</span><br><span class="line"><span class="keyword">let</span> fd = open(<span class="string">"/tmp/scratch.txt"</span>, <span class="type">O_WRONLY</span>|<span class="type">O_CREAT</span>, <span class="number">0o666</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> fd &lt; <span class="number">0</span> &#123;</span><br><span class="line">	perror(<span class="string">"could not open /tmp/scratch.txt"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> text = <span class="string">"Hello World"</span></span><br><span class="line">	write(fd, text, strlen(text))</span><br><span class="line">	close(fd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>#指针参数转换的安全性<br>Swift很努力地使与C语言指针的交互更加便利，因为它们广泛地存在于Cocoa之中，同时保持一定的安全性。然而，相比你的其他Swift代码与C语言的指针交互具有潜在的不安全性，所以务必要小心使用。其中特别要注意：</p>
<ul>
<li><p>如果被调用者为了在其返回值之后再次使用而保存了C指针的数据，那么这些转换使用起来并不安全。转换后的指针仅在调用期间保证有效。甚至你将同样的变量、数组或字符串作为多指针参数再次传递，你每次都会收到一个不同的指针。这个异常将全局或静态地储存为变量。你可以安全地将这段地址当作永久唯一的指针使用。例如：作为一个KVO上下文参数使用的时候。</p>
</li>
<li><p>当指针类型为<code>Array</code>或<code>String</code>时，溢出检查不是强制进行的。 基于C语言的API无法增加数组和字符串大小，所以在你将其传递到基于C语言的API之前，你必须确保数组或字符的大小正确。</p>
</li>
</ul>
<p>如果你需要使用基于指针的API时没有遵守以上指导，或是你重写了接受指针参数的Cocoa方法，于是你可以在Swift中直接用不安全的指针来使用未经处理的内存。在未来的文章中我们将着眼于更加高级的情况。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter4/05_Value_and_Reference_Types/" itemprop="url">
                第四章-05Swift里的值类型与引用类型
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T10:00:06+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter4/05_Value_and_Reference_Types/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter4/05_Value_and_Reference_Types/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="Swift里的值类型与引用类型">Swift里的值类型与引用类型</h1><hr>
<blockquote>
<p>翻译：<a href="http://weibo.com/littlekok/" target="_blank" rel="external">老码团队翻译组-Arya</a><br>校对：<a href="http://weibo.com/u/5241713117" target="_blank" rel="external">老码团队翻译组-Jame</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#difference-two">值类型与引用类型的区别</a></li>
<li><a href="#act-in=mutation">Mutation（修改）在安全中扮演的角色</a></li>
<li><a href="#how-to-choose">如何选择类型</a></li>
</ul>
<h3 id="Swift里面的类型分为两种：">Swift里面的类型分为两种：</h3><ul>
<li><strong>值类型(Value Types)</strong>：每个实例都保留了一分独有的数据拷贝，一般以结构体 <code>（struct）</code>、<code>枚举（enum）</code> 或者<code>元组（tuple）</code>的形式出现。</li>
<li><strong>引用类型(Reference Type)</strong>：每个实例共享同一份数据来源，一般以<code>类（class）</code>的形式出现。</li>
</ul>
<p>在这篇博文里面，我们会介绍两种类型各自的优点，以及应该怎么选择使用。</p>
<p><a name="difference-two"></a></p>
<h4 id="值类型与引用类型的区别">值类型与引用类型的区别</h4><p>值类型和引用类型最基本的分别在复制之后的结果。当一个值类型被复制的时候，相当于创造了一个完全独立的实例，这个实例保有属于自己的独有数据，数据不会受到其他实例的数据变化影响：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是一个值类型的例子</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> </span>&#123; <span class="keyword">var</span> data: <span class="type">Int</span> = -<span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="type">S</span>()</span><br><span class="line"><span class="keyword">var</span> b = a							<span class="comment">// b是a的拷贝</span></span><br><span class="line">a.data = <span class="number">42</span>							<span class="comment">// 更改a的数据，b的不受影响</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"<span class="subst">\(a.data)</span>, <span class="subst">\(b.data)</span>"</span>)		<span class="comment">// 输出结果 "42, -1"</span></span><br></pre></td></tr></table></figure>
<p>值类型就好像身份证复印件一样，复印出来之后，修改原件上面的内容，复印件上的内容不会变。</p>
<p>另一方面，复制一个引用类型的时候，实际上是默默地创造了一个共享的实例分身，两者是共用一套数据。因此修改其中任何一个实例的数据，也会影响到另外那个。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是一个引用类型的例子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123; <span class="keyword">var</span> data: <span class="type">Int</span> = -<span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="type">C</span>()</span><br><span class="line"><span class="keyword">var</span> y = x							<span class="comment">// y是x的拷贝</span></span><br><span class="line">x.data = <span class="number">42</span>							<span class="comment">// 更改x的数据，等于同时修改了y</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"<span class="subst">\(x.data)</span>, <span class="subst">\(y.data)</span>"</span>)		<span class="comment">// 输出结果 "42, 42"</span></span><br></pre></td></tr></table></figure>
<p><a name="act-in=mutation"></a></p>
<h4 id="Mutation（修改）在安全中扮演的角色">Mutation（修改）在安全中扮演的角色</h4><p>值类型较引用类型来说，会让你更容易在大量代码中理清状况。如果你总是得到一个独立的拷贝出来的实例，你就可以放心它不会被你app里面的其他部分代码默默地修改。这在多线程的环境里面是尤为重要的，因为另外一个线程可能会在暗地里修改你的数据。因此可能会造成严重的程序错误，这在调试过程中非常难以排除。</p>
<p>由于差别主要在于修改数据的后果，那么当实例的数据只读，不存在需要更改的情况下，用哪种类型都是没有分别的。</p>
<p>你可能在想，有的时候我可能也需要一个完全不变的类。这样使用<code>Cocoa NSObject</code>对象的时候会比较容易，又可以保留值语义的好处。在今天，你可以通过只使用不可变的存储属性，和避开任何可以修改状态的API，用Swift写出一个不可变类<code>（immutable class）</code>。实际上，很多基本的Cocoa类，例如<code>NSURL</code>，都是设计成不可变类的。然而，Swift语言目前只强制<code>struct</code>和<code>enum</code>这种值类型的不可变性，对类这种引用类型则没有。（例如还不支持强制将子类的限制为不可变类）</p>
<p><a name="how-to-choose"></a></p>
<h4 id="如何选择类型？">如何选择类型？</h4><p>所以当我们想要建立一个新的类型的时候，怎么决定用值类型还是引用类型呢？当你使用Cocoa框架的时候，很多API都要通过NSObject的子类使用，所以这时候必须要用到引用类型class。在其他情况下，有下面几个准则：</p>
<ul>
<li><p><strong>什么时候该用值类型</strong>：</p>
<ul>
<li>要用==运算符来比较实例的数据时</li>
<li>你希望那个实例的拷贝能保持独立的状态时</li>
<li>数据会被多个线程使用时</li>
</ul>
</li>
<li><p><strong>什么时候该用引用类型（class）</strong>：</p>
<ul>
<li>要用==运算符来比较实例身份的时候</li>
<li>你希望有创建一个共享的、可变对象的时候</li>
</ul>
</li>
</ul>
<p>在Swift里面，数组(Array)、字符串(String)、字典(Dictionary)都属于值类型。它们就像C语言里面简单的int值，是一个个独立的数据个体。你不需要花任何功夫来防范其他代码在暗地里修改它们。更重要的是，你可以在线程之间安全的传递变量，而不需要特地去同步。在Swift高安全性的精神下，这个模式会帮助你用Swift写出更可控的代码。</p>
<hr>
<p>本章节不是老码的原创，老码认真的阅读了苹果的官方博客，且自己的练习总结，如果小伙伴们费了吃奶的劲还是看不懂，请找度娘谷歌，还是看不懂请到老码<a href="http://weibo.com/u/5241713117" target="_blank" rel="external">官方微博</a>咆哮。  </p>
<h5 id="本文由翻译自Apple_Swift_Blog_：Value_and_Reference_Types">本文由翻译自Apple Swift Blog ：<a href="https://developer.apple.com/swift/blog/?id=10" target="_blank" rel="external">Value and Reference Types</a></h5></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter4/06_Access_Control_and_Protected/" itemprop="url">
                第四章-06访问控制和protected
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T10:00:05+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter4/06_Access_Control_and_Protected/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter4/06_Access_Control_and_Protected/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="访问控制和protected">访问控制和protected</h1><hr>
<blockquote>
<p>翻译：<a href="http://weibo.com/littlekok/" target="_blank" rel="external">老码团队翻译组-Arya</a><br>校对：<a href="http://weibo.com/u/5241713117" target="_blank" rel="external">老码团队翻译组-Jame</a></p>
</blockquote>
<p>原文再续，书折第一回。</p>
<p>很多其他编程语言都有一种”protected“设定，可以限制某些类方法只能被它的子类所使用。</p>
<p>Swift支持了访问控制后，大家给我们的反馈都很不错。而有的开发者问我们：“为什么Swift没有类似protected的选项？” </p>
<p><strong>当我们在设计Swift访问控制的不同等级时，我们认为有两种主要场景：</strong></p>
<ul>
<li>在一个APP里：隐藏某个类的私密细节。</li>
<li>在一个开源框架里：不让导入这个框架的APP，随便接触框架的内部实现细节。</li>
</ul>
<p>上面的两种常见情况，对应着private和internal这两个等级。</p>
<p>而protected相当于把访问控制和继承特性混在一起，把访问控制的等级设定增加了一个维度，使之复杂化。即使设定了protected，子类还是可以通过新的公开方法、新的属性来接触到所谓“protected”了的API。另一方面，我们可以在各种地方重写一个方法，所谓的保护却没有提供优化机制。这种设定往往在做不必要的限制  一 protected允许了子类，但又禁止所有其他别的类（包括那些帮助子类实现某些功能的类）接触父类的成员。</p>
<p>有的开发者指出，apple的框架有时候也会把给子类用的API分隔出来。这时候protected不就有用了吗？我们研究后发现，这些方法一般属于下面两种情况：一是这些方法对子类以外的类没啥用，所以不需要严格保护（例如上面说的协助实现某些功能的类）。二是这些方法就是设计出来被重写，而不是直接用的。举个例子，<code>drawRect(_:)</code>就是在UIKit基础上使用的方法，但它不能在UIKit以外应用。</p>
<p>除此之外，如果有了protected，它要怎么样和extension相互作用呢？一个类的extension能接触它的protected成员吗？一个子类的extension可以接触父类的protected成员吗？extension声明的位置对访问控制等级有没有影响呢？（复杂到要哭了是不是？）</p>
<p>对访问控制的设计，也依循了Objective－C开发者（包括apple内外的）的常规做法。Objective－C方法和属性一般在.h头文件里声明，但也可以写在.m实现文件里。假如有一个公开的类，想把里面某些部分设为只有框架内可以获取时，开发者一般会创建另一个头文件给内部使用。以上三种访问级别，就对应了Swift里面的public，private和internal。</p>
<p>Swift的访问控制等级和继承无关，是单维度、非常清楚明了的。我们认为这样的模式更简洁，同时满足了最主要的需求：将一个类、或一个框架的实现细节隔离保护起来。这可能和你以前用过的不同，但我们鼓励你试试看。</p>
<hr>
<p>本章节不是老码的原创，是老码认真的阅读了苹果的官方博客，自己的练习总结，如果小伙伴们费了吃奶的劲还是看不懂，请找度娘谷歌。还是看不懂？请到老码<a href="http://weibo.com/u/5241713117" target="_blank" rel="external">官方微博</a>咆哮。  </p>
<h5 id="本文由翻译自Apple_Swift_Blog_：Access_Control_and_Protected">本文由翻译自Apple Swift Blog ：<a href="原文地址：https://developer.apple.com/swift/blog/?id=11">Access Control and Protected</a></h5></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter4/07_Optional_Case_Study/" itemprop="url">
                第四章-07可选类型完美解决占位问题
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T10:00:04+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter4/07_Optional_Case_Study/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter4/07_Optional_Case_Study/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="可选类型完美解决占位问题">可选类型完美解决占位问题</h1><hr>
<blockquote>
<p>翻译：<a href="http://weibo.com/u/5241713117" target="_blank" rel="external">老码团队翻译组-Tyrion</a><br>校对：<a href="http://weibo.com/littlekok/" target="_blank" rel="external">老码团队翻译组-Ayra</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#add-function">为Dictionary增加objectsForKeys函数</a></li>
<li><a href="##easy-function">Swift中更简便的方法</a></li>
<li><a href="#nested-optional">内嵌可选类型</a></li>
<li><a href="#provide-default">提供一个默认值</a></li>
</ul>
<p>可选类型是Swift中新引入的，功能很强大。在这篇博文里讨论的，是在Swift里，如何通过可选类型来保证强类型的安全性。作为例子，我们来创建一个Objective-C API的Swift版本，但实际上Swift本身并不需要这样的API。</p>
<p><a name="#add-function"></a></p>
<h4 id="为Dictionary增加objectsForKeys函数">为Dictionary增加objectsForKeys函数</h4><p>在Objective-C中，<figure class="highlight"><figcaption><span>这个方法需要一个```NSArray```数组作为键值参数，然后返回一个包含相关值的数组。文档里写到："返回数组中的第N个值，和输入数组中的第N个值相对应"，那如果有某个键值在字典里不存在呢？于是就有了```notFoundMarker```作为返回提示。比如第三个键值没有找到，那么在返回数组中第三个值就是这个```notFoundMarker```，而不是字典中的第三个值，但是这个值只是用来提醒原字典中没有找到对应值，但在返回数组中该元素存在，且用```notFoundMarker```作为占位符，因为这个对象不能直接使用，所以在Foundation框架中有个专门的类处理这个情况：```NSNull```。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;&#22312;Swift&#20013;&#65292;```Dictionary```&#31867;&#27809;&#26377;&#31867;&#20284;```objectsForKeys```&#30340;&#20989;&#25968;&#65292;&#20026;&#20102;&#35828;&#26126;&#38382;&#39064;&#65292;&#25105;&#20204;&#21160;&#25163;&#21152;&#19968;&#20010;&#65292;&#24182;&#19988;&#20351;&#20854;&#25104;&#20026;&#25805;&#20316;&#23383;&#20856;&#20540;&#30340;&#36890;&#29992;&#26041;&#27861;&#12290;&#25105;&#20204;&#21487;&#20197;&#29992;```extension```&#26469;&#23454;&#29616;&#65306;&#10;&#10;```swift&#10;extension Dictionary&#123;&#10;&#9;func valuesForKeys(keys:[K], notFoundMarker: V )-&#62;[V]&#123;&#10;&#9;&#9;//&#20855;&#20307;&#23454;&#29616;&#20195;&#30721;&#21518;&#38754;&#20250;&#20889;&#21040;&#10;&#9;&#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上就是我们实现的Swift版本，这个和Objective-C版本有很大区别。在Swift中，因为其强类型的原因限制了返回的结果数组只能包含单一类型的元素，所以我们不能放<figure class="highlight"><figcaption><span>我们只用```nil```就可以了。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;&#10;```swift&#10;extension Dictionary&#123;&#10;    func valuesForKeys(keys: [Key]) -&#62; [Value?] &#123;&#10;        var result = [Value?]()&#10;        result.reserveCapacity(keys.count)&#10;        for key in keys&#123;&#10;            result.append(self[key])&#10;        &#125;&#10;        return result&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p><a name="#easy-function"></a></p>
<h4 id="Swift中更简便的方法">Swift中更简便的方法</h4><p>小伙伴们可能会问，为什么Swift中不需要实现这么一个API呢？其实其有更简单的实现，如下面代码所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Dictionary</span> </span>&#123;</span><br><span class="line">	<span class="func"><span class="keyword">func</span> <span class="title">valuesForKeys</span><span class="params">(keys: [Key])</span></span> -&gt; [<span class="type">Value</span>?] &#123;</span><br><span class="line">		<span class="keyword">return</span> keys.<span class="built_in">map</span> &#123; <span class="keyword">self</span>[$<span class="number">0</span>] &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方式实现的功能和最开始的方法实现的功能相同，虽然核心的功能是封装了<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;&#25509;&#19979;&#26469;&#65292;&#25105;&#20204;&#23454;&#39564;&#20960;&#20010;&#20363;&#23376;&#65306;&#10;&#10;```swift&#10;var dic: Dictionary = [ &#34;1&#34;: 2, &#34;3&#34;:3, &#34;4&#34;:5 ]&#10;&#10;var t = dic.valuesForKeys([&#34;1&#34;, &#34;4&#34;]) &#10;//&#32467;&#26524;&#20026;&#65306;[Optional(2), Optional(5)]&#10;&#10;var t = dict.valuesForKeys([&#34;3&#34;, &#34;9&#34;])&#10;// &#32467;&#26524;&#20026;&#65306;[Optional(3), nil]&#10;&#10;t = dic.valuesForKeys([])&#10;//&#32467;&#26524;&#20026;&#65306;[]</span><br></pre></td></tr></table></figure></p>
<p><a name="#nested-optional"></a></p>
<h4 id="内嵌可选类型">内嵌可选类型</h4><p>现在，如果我们为每一个结果调用<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;```swift&#10;var dic: Dictionary = [ &#34;1&#34;: 2, &#34;3&#34;:3, &#34;4&#34;:5 ]&#10;&#10;var t = dic.valuesForKeys([&#34;1&#34;, &#34;4&#34;]).last //&#32467;&#26524;&#20026;&#65306;Optional(Optional(5))&#10;// Optional(Optional(&#34;Ching&#34;))&#10;&#10;var t = dict.valuesForKeys([&#34;3&#34;, &#34;9&#34;]).last&#10;// &#32467;&#26524;&#20026;&#65306;Optional(nil)&#10;&#10;var t = dict.valuesForKeys([]).last&#10;// &#32467;&#26524;&#20026;&#65306;nil</span><br></pre></td></tr></table></figure></p>
<p>小伙伴们立马迷糊了，为什么会出现两层包含的可选类型呢？，特别对第二种情况的<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;&#25105;&#20204;&#22238;&#36807;&#22836;&#30475;&#30475;```last```&#23646;&#24615;&#30340;&#23450;&#20041;&#65306;&#10;&#10;```swift&#10;var last:T? &#123; get &#125;</span><br></pre></td></tr></table></figure></p>
<p>很明显<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;&#22914;&#26524;&#22312;Objective-C&#20013;&#37325;&#26032;&#35843;&#29992;&#19978;&#36848;&#26041;&#27861;&#65292;&#25105;&#20204;&#23558;&#20351;&#29992;```NSNull```&#20316;&#20026;&#21344;&#20301;&#31526;&#65292;Objective-C&#30340;&#35843;&#29992;&#35821;&#27861;&#22914;&#19979;&#25152;&#31034;&#65306;&#10;&#10;```swift&#10;[dict valuesForKeys:@[@&#34;1&#34;, @&#34;4&#34;] notFoundMarker:[NSNull null]].lastObject&#10;// 5&#10;[dict valuesForKeys:@[@&#34;1&#34;, @&#34;3&#34;] notFoundMarker:[NSNull null]].lastObject&#10;// NSNull&#10;[dict valuesForKeys:@[] notFoundMarker:[NSNull null]].lastObject&#10;// nil</span><br></pre></td></tr></table></figure></p>
<p>不管是Swift版本还是Objective-C版本，返回值为<figure class="highlight"><figcaption><span>但是如果返回是```Optional(nil)```或者Objective-C中的```NSNull```都表示数组中的最后一个元素存在，但是元素的内容是空的。在Objective-C中只能借助```NSNull```作为占位符来达到这个目的，但是Swift却可以语言系统类型的角度的实现。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;&#60;a name=&#34;#provide-default&#34;&#62;&#60;/a&#62;&#10;#### &#25552;&#20379;&#19968;&#20010;&#40664;&#35748;&#20540;&#10;&#10;&#36827;&#19968;&#27493;&#23553;&#35013;&#65292;&#22914;&#26524;&#25105;&#23383;&#20856;&#20013;&#30340;&#26576;&#20010;&#25110;&#26576;&#20123;&#20803;&#32032;&#19981;&#23384;&#22312;&#65292;&#25105;&#20204;&#24819;&#25552;&#20379;&#19968;&#20010;&#40664;&#35748;&#20540;&#24590;&#20040;&#21150;&#21602;&#65311;&#23454;&#29616;&#26041;&#27861;&#24456;&#31616;&#21333;&#65306;&#10;&#10;```swift&#10;extension Dictionary &#123;&#10;&#9;func valuesForKeys( keys:[Key], notFoundMarker: Value)-&#62;[Value]&#123;&#10;&#9;&#9;return self.valueForKeys(kes).map&#123; $0 ?? notFoundMarker &#125;&#10;&#9;&#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict.<span class="function"><span class="title">valuesForKeys</span><span class="params">([<span class="string">"1"</span>, <span class="string">"5"</span>], notFoundMarker: <span class="string">"Anonymous"</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>和Objective-C相比，其需要占位符来达到占位的目的，但是Swift却已经从语言类型系统的层面原生的支持了这种用法，同时提供了丰富的语法功能。这就是Swift可选类型的强大之处。同时注意上述例子中用到了空合运算符<code>??</code>。</p>
<hr>
<p>本章节不是老码的原创，是老码认真的阅读了苹果的官方博客，自己的练习总结，如果小伙伴们费了吃奶的劲还是看不懂，请找度娘谷歌。还是看不懂？请到老码<a href="http://weibo.com/u/5241713117" target="_blank" rel="external">官方微博</a>咆哮。  </p>
<h5 id="本文由翻译自Apple_Swift_Blog_：Optionals_Case_Study:_valuesForKeys">本文由翻译自Apple Swift Blog ：<a href="https://developer.apple.com/swift/blog/?id=12" target="_blank" rel="external">Optionals Case Study: valuesForKeys</a></h5></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/18/bilibili/2831578/" itemprop="url">
                中二病也要谈恋爱！恋 Lite＋SP 合辑【BD1080P】
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-18T07:56:29+08:00" content="2015-12-18">
            2015-12-18
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/helloworld/" itemprop="url" rel="index">
                  <span itemprop="name">helloworld</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/18/bilibili/2831578/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/18/bilibili/2831578/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><div class="bili_video"><embed height="452" width="544" quality="high" allowfullscreen="true" type="application/x-shockwave-flash" src="http://share.acg.tv/flash.swf" flashvars="aid=2831578&page=1" pluginspage="http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash"></div>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/15/swift/proposals/0006-apply-api-guidelines-to-the-standard-library/" itemprop="url">
                0006-apply-api-guidelines-to-the-standard-library
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-15T12:30:00+08:00" content="2015-12-15">
            2015-12-15
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/blog/" itemprop="url" rel="index">
                  <span itemprop="name">blog</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/15/swift/proposals/0006-apply-api-guidelines-to-the-standard-library/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/15/swift/proposals/0006-apply-api-guidelines-to-the-standard-library/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="Apply_API_Guidelines_to_the_Standard_Library">Apply API Guidelines to the Standard Library</h1><ul>
<li>Proposal: <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md" target="_blank" rel="external">SE-0006</a></li>
<li>Author(s): <a href="https://github.com/dabrahams" target="_blank" rel="external">Dave Abrahams</a>, <a href="https://github.com/gribozavr" target="_blank" rel="external">Dmitri Gribenko</a>, <a href="https://github.com/moiseev" target="_blank" rel="external">Maxim Moiseev</a></li>
<li>Status: <strong>Awaiting Review</strong></li>
<li>Review manager: <a href="https://github.com/DougGregor" target="_blank" rel="external">Doug Gregor</a></li>
</ul>
<h2 id="Introduction">Introduction</h2><p><a href="https://swift.org/documentation/api-design-guidelines.html" title="API Design Guidelines" target="_blank" rel="external">Swift API Design Guidelines</a> being developed as<br>part of Swift 3.  It is important that the Standard Library is an exemplar of<br>Swift API Design Guidelines: the APIs from the Standard Library are, probably,<br>the most frequently used Swift APIs in any application domain; the Standard<br>Library also sets precedent for other libraries.</p>
<p>In this project, we are reviewing the entire Standard Library and updating it<br>to follow the guidelines.</p>
<h2 id="Proposed_solution">Proposed solution</h2><p>The actual work is being performed on the <a href="https://github.com/apple/swift/tree/swift-3-api-guidelines" title="Swift 3 API Design Guidelines preview" target="_blank" rel="external">swift-3-api-guidelines<br>branch</a> of the <a href="https://github.com/apple/swift" title="Swift repository" target="_blank" rel="external">Swift repository</a>.<br>On high level, the changes can be summarized as follows.</p>
<ul>
<li><p>Strip <code>Type</code> suffix from remaining protocol names.  In a few special cases<br>this means adding a <code>Protocol</code> suffix to get out of the way of type<br>names that are primary (though most of these we expect to be<br>obsoleted by Swift 3 language features).</p>
</li>
<li><p>The concept of <code>generator</code> is renamed to <code>iterator</code>.</p>
</li>
<li><p><code>IndexingGenerator</code> is renamed to <code>DefaultCollectionIterator</code>.</p>
</li>
</ul>
<p><strong>More changes will be summarized here as they are implemented.</strong></p>
<h2 id="API_diffs">API diffs</h2><p>Differences between Swift 2.2 Standard library API and the proposed API are<br>added to this section as they are being implemented on the<br><a href="https://github.com/apple/swift/tree/swift-3-api-guidelines" title="Swift 3 API Design Guidelines preview" target="_blank" rel="external">swift-3-api-guidelines branch</a>.</p>
<h2 id="Impact_on_existing_code">Impact on existing code</h2><p>The proposed changes are massively source-breaking for Swift code, and will<br>require a migrator to translate Swift 2 code into Swift 3 code.  The API diffs<br>from this proposal will be the primary source of the information about the<br>required transformations.  In addition, to the extent the language allows, the<br>library will keep old names as unavailable symbols with a <code>renamed</code> annotation,<br>that allows the compiler to produce good error messages and emit Fix-Its.</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/15/swift/proposals/0005-objective-c-name-translation/" itemprop="url">
                0005-objective-c-name-translation
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-15T12:30:00+08:00" content="2015-12-15">
            2015-12-15
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/blog/" itemprop="url" rel="index">
                  <span itemprop="name">blog</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/15/swift/proposals/0005-objective-c-name-translation/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/15/swift/proposals/0005-objective-c-name-translation/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="Better_Translation_of_Objective-C_APIs_Into_Swift">Better Translation of Objective-C APIs Into Swift</h1><ul>
<li>Proposal: <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md" target="_blank" rel="external">SE-0005</a></li>
<li>Author(s): <a href="https://github.com/DougGregor" target="_blank" rel="external">Doug Gregor</a>, <a href="https://github.com/dabrahams" target="_blank" rel="external">Dave Abrahams</a></li>
<li>Status: <strong>Accepted</strong></li>
</ul>
<h2 id="Introduction">Introduction</h2><p>This proposal describes how we can improve Swift’s “Clang Importer”, which is responsible for mapping C and Objective-C APIs into Swift, to translate the names of Objective-C functions, types, methods, properties, etc. into names that more closely align with the <a href="https://swift.org/documentation/api-design-guidelines.html" title="API Design Guidelines" target="_blank" rel="external">Swift API Design Guidelines</a> being developed as part of Swift 3. Our approach focuses on the differences between the Objective-C <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html" title="Coding Guidelines for Cocoa" target="_blank" rel="external">Coding Guidelines for Cocoa</a> and the Swift API Design Guidelines, using some simple linguistic analysis to aid the automatic translation from Objective-C names to more “Swifty” names.</p>
<h2 id="Motivation">Motivation</h2><p>The Objective-C <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html" title="Coding Guidelines for Cocoa" target="_blank" rel="external">Coding Guidelines for Cocoa</a><br>provide a framework for creating clear, consistent APIs in<br>Objective-C, where they work extraordinarily well. However, Swift is a<br>different language: in particular, it is strongly typed and provides<br>type inference, generics, and overloading. As a result, Objective-C<br>APIs that feel right in Objective-C can feel wordy when used in<br>Swift. For example:</p>
<pre><code>let contentString = listItemView<span class="class">.stringValue</span><span class="class">.stringByTrimmingCharactersInSet</span>(
   NSCharacterSet.<span class="function"><span class="title">whitespaceAndNewlineCharacterSet</span><span class="params">()</span></span>)
</code></pre><p>The APIs used here follow the Objective-C guidelines. A more “Swifty”<br>version of the same code might instead look like this:</p>
<pre><code>let <span class="attribute">content</span> = listItem<span class="class">.stringValue</span><span class="class">.trimming</span>(.whitespaceAndNewlines)
</code></pre><p>The latter example more closely adheres to the <a href="https://swift.org/documentation/api-design-guidelines.html" title="API Design Guidelines" target="_blank" rel="external">Swift API Design<br>Guidelines</a>, in particular, omitting “needless”<br>words that restate the types already enforced by the compiler (view,<br>string, character set, etc.). The goal of this proposal is to make<br>imported Objective-C feel more “Swifty”, providing a more fluid<br>experience for Swift programmers using Objective-C APIs.</p>
<p>The solution in this proposal applies equally to the Objective-C<br>frameworks (e.g., all of Cocoa and Cocoa Touch) and any Objective-C<br>APIs that are available to Swift in mix-and-match projects. Note that<br>the <a href="https://swift.org/core-libraries/" title="Swift Core Libraries" target="_blank" rel="external">Swift core libraries</a><br>reimplement the APIs of Objective-C frameworks, so any API changes to<br>those frameworks (Foundation, XCTest, etc.) will be reflected in the<br>Swift 3 implementations of the core libraries.</p>
<h2 id="Proposed_solution">Proposed solution</h2><p>The proposed solution involves identifying the differences between the<br>Objective-C <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html" title="Coding Guidelines for Cocoa" target="_blank" rel="external">Coding Guidelines for Cocoa</a> and<br>the <a href="https://swift.org/documentation/api-design-guidelines.html" title="API Design Guidelines" target="_blank" rel="external">Swift API Design Guidelines</a> to build a<br>set of transformations that map from the former to the latter based on<br>the guidelines themselves and other observed conventions in<br>Objective-C. This is an extension of other heuristics in the Clang<br>importer that translate names, e.g., the mapping of global enum<br>constants into Swift’s cases (which strips common prefixes from the<br>enum constant names) and the mapping from Objective-C factory methods<br>(e.g., <code>+[NSNumber numberWithBool:]</code>) to Swift initializers<br>(<code>NSNumber(bool: true)</code>).</p>
<p>The heuristics described in this proposal will require iteration,<br>tuning, and experimentation across a large body of Objective-C APIs to<br>get right. Moreover, it will not be perfect: some APIs will<br>undoubtedly end up being less clear in Swift following this<br>translation than they had been before. Therefore, the goal is to make<br>the vast majority of imported Objective-C APIs feel more “Swifty”, and<br>allow the authors of Objective-C APIs that end up being less clear to<br>address those problems on a per-API basis via annotation within the<br>Objective-C headers.</p>
<p>The proposed solution involves several related changes to the Clang importer:</p>
<ol>
<li><p><strong>Generalize the applicability of the <code>swift_name</code> attribute</strong>: The<br>Clang <code>swift_name</code> attribute currently allows limited renaming of enum<br>cases and factory methods. It should be generalized to allow arbitrary<br>renaming of any C or Objective-C entity when it is imported into<br>Swift, allowing authors of C or Objective-C APIs more fine-grained<br>control over the process.</p>
</li>
<li><p><strong>Prune redundant type names</strong>: The Objective-C Coding Guidelines for Cocoa require that the method describe each argument. When those descriptions restate the type of the corresponding parameter, the name conflicts with the <a href="https://swift.org/documentation/api-design-guidelines.html#omit-needless-words" target="_blank" rel="external">omit needless words</a> guideline for Swift APIs. Therefore, we prune these type names during import.</p>
</li>
<li><p><strong>Add default arguments</strong>: In cases where the Objective-C API strongly hints at the need for a default argument, infer the default argument when importing the API. For example, an option-set parameter can be defaulted to <code>[]</code>.</p>
</li>
<li><p><strong>Add first argument labels</strong>: If the first parameter of a method is defaulted, <a href="https://swift.org/documentation/api-design-guidelines.html#first-argument-label" target="_blank" rel="external">it should have an argument label</a>. Determine a first argument label for that method.</p>
</li>
<li><p><strong>Prepend “is” to Boolean properties</strong>: <a href="https://swift.org/documentation/api-design-guidelines.html#first-argument-label" target="_blank" rel="external">Boolean properties should read as assertions on the receiver</a>, but the Objective-C Coding Guidelines for Cocoa <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingIvarsAndTypes.html#//apple_ref/doc/uid/20001284-BAJGIIJE" target="_blank" rel="external">prohibit the use of “is” on properties</a>. Import such properties with “is” prepended.</p>
</li>
<li><p><strong>Strip the “NS” prefix from Foundation APIs</strong>: Foundation is a<br>fundamental part of the <a href="https://swift.org/core-libraries/" title="Swift Core Libraries" target="_blank" rel="external">Swift Core Libraries</a>, and<br>having the prefixes on these cross-platform APIs feels<br>anachronistic. Therefore, remove the “NS” prefix from entities defined<br>in the Foundation module (and other specifically identified modules where it makes sense).</p>
</li>
</ol>
<p>To get a sense of what these transformations do, consider a portion of<br>the imported <code>UIBezierPath</code> API in Swift 2:</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">UIBezierPath</span> : <span class="title">NSObject</span>, <span class="title">NSCopying</span>, <span class="title">NSCoding</span> </span>{
  convenience <span class="keyword">init</span>(ovalInRect: <span class="type">CGRect</span>)
  <span class="func"><span class="keyword">func</span> <span class="title">moveToPoint</span><span class="params">(<span class="number">_</span>: CGPoint)</span></span>
  <span class="func"><span class="keyword">func</span> <span class="title">addLineToPoint</span><span class="params">(<span class="number">_</span>: CGPoint)</span></span>
  <span class="func"><span class="keyword">func</span> <span class="title">addCurveToPoint</span><span class="params">(<span class="number">_</span>: CGPoint, controlPoint1: CGPoint, controlPoint2: CGPoint)</span></span>
  <span class="func"><span class="keyword">func</span> <span class="title">addQuadCurveToPoint</span><span class="params">(<span class="number">_</span>: CGPoint, controlPoint: CGPoint)</span></span>
  <span class="func"><span class="keyword">func</span> <span class="title">appendPath</span><span class="params">(<span class="number">_</span>: UIBezierPath)</span></span>
  <span class="func"><span class="keyword">func</span> <span class="title">bezierPathByReversingPath</span><span class="params">()</span></span> -&gt; <span class="type">UIBezierPath</span>
  <span class="func"><span class="keyword">func</span> <span class="title">applyTransform</span><span class="params">(<span class="number">_</span>: CGAffineTransform)</span></span>
  <span class="keyword">var</span> empty: <span class="type">Bool</span> { <span class="keyword">get</span> }
  <span class="func"><span class="keyword">func</span> <span class="title">containsPoint</span><span class="params">(<span class="number">_</span>: CGPoint)</span></span> -&gt; <span class="type">Bool</span>
  <span class="func"><span class="keyword">func</span> <span class="title">fillWithBlendMode</span><span class="params">(<span class="number">_</span>: CGBlendMode, alpha: CGFloat)</span></span>
  <span class="func"><span class="keyword">func</span> <span class="title">strokeWithBlendMode</span><span class="params">(<span class="number">_</span>: CGBlendMode, alpha: CGFloat)</span></span>
  <span class="func"><span class="keyword">func</span> <span class="title">copyWithZone</span><span class="params">(<span class="number">_</span>: NSZone)</span></span> -&gt; <span class="type">AnyObject</span>
  <span class="func"><span class="keyword">func</span> <span class="title">encodeWithCoder</span><span class="params">(<span class="number">_</span>: NSCoder)</span></span>
}
</code></pre><p>And the same API imported under our current, experimental implementation of this proposal:</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">UIBezierPath</span> : <span class="title">Object</span>, <span class="title">Copying</span>, <span class="title">Coding</span> </span>{
  convenience <span class="keyword">init</span>(ovalIn: <span class="type">CGRect</span>)
  <span class="func"><span class="keyword">func</span> <span class="title">moveTo</span><span class="params">(<span class="number">_</span>: CGPoint)</span></span>
  <span class="func"><span class="keyword">func</span> <span class="title">addLineTo</span><span class="params">(<span class="number">_</span>: CGPoint)</span></span>
  <span class="func"><span class="keyword">func</span> <span class="title">addCurveTo</span><span class="params">(<span class="number">_</span>: CGPoint, controlPoint1: CGPoint, controlPoint2: CGPoint)</span></span>
  <span class="func"><span class="keyword">func</span> <span class="title">addQuadCurveTo</span><span class="params">(<span class="number">_</span>: CGPoint, controlPoint: CGPoint)</span></span>
  <span class="func"><span class="keyword">func</span> <span class="title">append</span><span class="params">(<span class="number">_</span>: UIBezierPath)</span></span>
  <span class="func"><span class="keyword">func</span> <span class="title">reversing</span><span class="params">()</span></span> -&gt; <span class="type">UIBezierPath</span>
  <span class="func"><span class="keyword">func</span> <span class="title">apply</span><span class="params">(<span class="number">_</span>: CGAffineTransform)</span></span>
  <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> { <span class="keyword">get</span> }
  <span class="func"><span class="keyword">func</span> <span class="title">contains</span><span class="params">(<span class="number">_</span>: CGPoint)</span></span> -&gt; <span class="type">Bool</span>
  <span class="func"><span class="keyword">func</span> <span class="title">fillWith</span><span class="params">(<span class="number">_</span>: CGBlendMode, alpha: CGFloat)</span></span>
  <span class="func"><span class="keyword">func</span> <span class="title">strokeWith</span><span class="params">(<span class="number">_</span>: CGBlendMode, alpha: CGFloat)</span></span>
  <span class="func"><span class="keyword">func</span> <span class="title">copy</span><span class="params">(zone <span class="number">_</span>: Zone = <span class="literal">nil</span>)</span></span> -&gt; <span class="type">AnyObject</span>
  <span class="func"><span class="keyword">func</span> <span class="title">encodeWith</span><span class="params">(<span class="number">_</span>: Coder)</span></span>
}
</code></pre><p>In the latter case, a number of words that restated type information<br>in the original APIs have been pruned. The result is closer to<br>following the Swift API Design Guidelines. For example, this shows<br>that Swift developers can now copy any object conforming to the<br>NSCopying with a simple call to <code>foo.copy()</code> instead of calling<br><code>foo.copyWithZone(nil)</code>.</p>
<h2 id="Implementation_Experience">Implementation Experience</h2><p>An experimental, partial implementation of this proposal is available<br>in the main Swift tree behind a set of experimental compiler<br>flags. With these flags, one can see the results of applying this<br>proposal to imported Objective-C APIs (e.g., via the script in<br><code>utils/omit-needless-words.py</code>) and to Swift code itself. The flags<br>are:</p>
<ul>
<li><p><code>-enable-omit-needless-words</code>: this flag enables most of the changes<br>to the Clang importer (bullets 1, 2, 4, and 5 in the prior<br>section). It is currently suitable only for printing the Swift<br>interface to Objective-C modules (e.g., via <code>swift-ide-test</code>).</p>
</li>
<li><p><code>-enable-infer-default-arguments</code>: this flag enables inference of<br>default arguments in the Clang importer (bullet 3 in the prior<br>section).</p>
</li>
<li><p><code>-Womit-needless-words</code>: this flag enables a set of compiler<br>warnings that helps illustrate what Swift code looks like after<br>following the rules described in this proposal. The most important<br>part of each warning is its corresponding Fix-It, which updates the<br>code according to the rules. Tied together with other compiler flags<br>(e.g., <code>-fixit-code</code>, <code>-fixit-all</code>) and a script to collect and apply<br>Fix-Its (in <code>utils/apply-fixit-edits.py</code>), this flag provides a<br>rudimentary migrator that lets us see how Swift code would look<br>under the proposed changes, updating both declarations and use<br>sites. It is currently suitable only for printing the Swift<br>interface to Objective-C modules (e.g., via <code>swift-ide-test</code>).</p>
</li>
</ul>
<p>While the implementation is far from complete, it is enough to see the<br>effects that the proposal has on Objective-C APIs and code that uses<br>them.</p>
<h2 id="Detailed_design">Detailed design</h2><p>This section details the experimental implementation of rules 2-5 in prose. The actual implementation is available in the Swift source tree, mostly in the <code>omitNeedlessWords</code> functions of <a href="https://github.com/apple/swift/blob/master/lib/Basic/StringExtras.cpp" target="_blank" rel="external">lib/Basic/StringExtras.cpp</a>.</p>
<p>The descriptions in this section are described in terms of the incoming Objective-C API. For example, Objective-C method names are “selectors”, e.g., <code>startWithQueue:completionHandler:</code> is a selector with two selector pieces, <code>startWithQueue</code> and <code>completionHandler</code>. A direct mapping of this name into Swift would produce <code>startWithQueue(_:completionHandler:)</code>.</p>
<h3 id="Prune_redundant_type_names">Prune redundant type names</h3><p>Objective-C API names often contain names of parameter and/or result<br>types that would be omitted in a Swift API. The following rules are<br>designed to identify and remove these words. [<a href="https://swift.org/documentation/api-design-guidelines.html#omit-needless-words" target="_blank" rel="external">Omit Needless Words</a>]</p>
<h4 id="Identifying_type_names">Identifying type names</h4><p>The matching process described below searches in a selector piece for<br>a suffix of a string called the <strong>type name</strong>, which is defined as follows:</p>
<ul>
<li><p>For most Objective-C types, the <em>type name</em> is the name under which<br>Swift imports the type, ignoring nullability. For example,</p>
<p>|Objective-C type       | <em>Type Name</em>                                |<br>|———————–|——————————————–|<br>|<code>float</code>                |<code>Float</code>                                     |<br>|<code>nullable NSString</code>    |<code>String</code>                                    |<br>|<code>UIDocument</code>           |<code>UIDocument</code>                                |<br>|<code>nullable UIDocument</code>  |<code>UIDocument</code>                                |<br>|<code>NSInteger</code>            |<code>NSInteger</code>                                 |<br>|<code>NSUInteger</code>           |<code>NSUInteger</code>                                |<br>|<code>CGFloat</code>              |<code>CGFloat</code>                                   |</p>
</li>
<li><p>When the Objective-C type is a block, the <em>type name</em> is “<code>Block</code>.”</p>
</li>
<li><p>When the Objective-C type is a pointer- or reference-to-function,<br>the <em>type name</em> is “<code>Function</code>.”</p>
</li>
<li><p>When the Objective-C type is a typedef other than <code>NSInteger</code>,<br><code>NSUInteger</code>, or <code>CGFloat</code> (which follow the first rule above),<br>the <em>type name</em> is that of the underlying type. For example, when<br>the Objective-C type is <code>UILayoutPriority</code>, which is a typedef for<br><code>float</code>, we try to match the string “<code>Float</code>“. [<a href="https://swift.org/documentation/api-design-guidelines.html#weak-type-information" target="_blank" rel="external">Compensate for Weak Type Information</a>]</p>
</li>
</ul>
<h4 id="Matching">Matching</h4><p>In order to prune a redundant type name from a selector piece, we<br>need to match a substring of the selector that identifies the type.  </p>
<p>A couple of basic rules govern all matches:</p>
<ul>
<li><p><strong>Matches begin and end at word boundaries</strong> in both type names and<br>selector pieces.  Word boundaries occur at the beginning and end of<br>a string, and before every capital letter.</p>
<p>Treating every capital letter as the beginning of a word allows us<br>to match uppercased acronyms without maintaining a special lists of<br>acronyms or prefixes:</p>
<pre>
func documentFor<b>URL</b>(_: NS<b>URL</b>) -> NSDocument?
</pre>

<p> while preventing partial-word mismatches:</p>
 <pre>
 var thumbnailPre<b>view</b> : UI<b>View</b>  // not matched
 </pre>
</li>
<li><p><strong>Matched text extends to the end of the type name</strong>. Because we<br>accept a match for <em>any suffix</em> of the type name, this code:</p>
<pre>
func constraintEqualTo<b>Anchor</b>(anchor: NSLayout<b>Anchor</b>) -&gt; NSLayoutConstraint?
</pre>

<p>can be pruned as follows:</p>
<pre>
func constraintEqualTo(anchor: NSLayoutAnchor) -&gt; NSLayoutConstraint?
</pre>

<p>Conveniently, matching by suffix also means that module prefixes<br>such as <code>NS</code> do not prevent matching or pruning.</p>
</li>
</ul>
<p>Matches are a sequence of one or more of the following:</p>
<ul>
<li><p><strong>Basic matches</strong></p>
<ul>
<li><p>Any substring of the selector piece matches an identical<br>substring of the type name, e.g., <code>String</code> in <code>appendString</code><br>matches <code>String</code> in <code>NSString</code>:</p>
<pre>
func append<b>String</b>(_: NS<b>String</b>)
</pre>
</li>
<li><p><code>Index</code> in the selector piece matches <code>Int</code> in the type name:</p>
<pre>
func characterAt<b>Index</b>(_: <b>Int</b>) -> unichar
</pre>
</li>
</ul>
</li>
<li><p><strong>Collection matches</strong></p>
<ul>
<li><p><code>Indexes</code> or <code>Indices</code> in the selector piece matches <code>IndexSet</code> in<br>the type name:</p>
<pre>
func removeObjectsAt<b>Indexes</b>(_: NS<b>IndexSet</b>)
</pre>
</li>
<li><p>A plural noun in the selector piece matches a collection type name<br>if the noun’s singular form matches the name of the collection’s<br>element type:</p>
</li>
</ul>
<pre>
func arrange<b>Objects</b>(_: <b>[</b>Any<b>Object]</b>) -> [AnyObject]
</pre>
</li>
<li><p><strong>Special suffix matches</strong></p>
<ul>
<li><p>The empty string in the selector piece matches <code>Type</code> or <code>_t</code> in the type name:</p>
<pre>
func writableTypesFor<b>SaveOperation</b>(_: NS<b>SaveOperation</b><i>Type</i>) -> [String]
func objectFor<b>Key</b>(_: <b>Key</b><i>Type</i>) -> AnyObject
func startWith<b>Queue</b>(_: dispatch_<b>queue</b><i>_t</i>, completionHandler: MKMapSnapshotCompletionhandler)
</pre>
</li>
<li><p>The empty string in the selector piece matches <em>one or more digits<br>followed by “D”</em> in the type name:</p>
<pre>
func pointFor<b>Coordinate</b>(_: CLLocation<b>Coordinate</b><i>2D</i>) -> NSPoint
</pre>

</li>
</ul>
</li>
</ul>
<p>In the examples above, the italic text is effectively skipped, so the<br>bold part of the selector piece can be matched and pruned.</p>
<h4 id="Pruning_Restrictions">Pruning Restrictions</h4><p>The following restrictions govern the pruning steps listed in the<br>next section.  If any step would violate one of these rules, it is<br>skipped.</p>
<ul>
<li><p><strong>Never make a selector piece entirely empty</strong>.</p>
</li>
<li><p><strong>Never transform the first selector piece into a Swift keyword</strong>,<br>to avoid forcing the user to escape it with backticks. In Swift, the<br>first Objective-C selector piece becomes:</p>
<ul>
<li>the base name of a method</li>
<li>or the full name of a property </li>
</ul>
<p>neither of which can match a Swift keyword without forcing the<br>user to write backticks.  For example,</p>
<pre>
extension NSParagraphStyle {
&nbsp;&nbsp;class func default<b>ParagraphStyle</b>() -> NS<b>ParagraphStyle</b>
}
let defaultStyle = NSParagraphStyle.<b>default</b>ParagraphStyle()  // OK
</pre>

<p>would become:</p>
<pre>
extension NSParagraphStyle {
&nbsp;&nbsp;class func <b>`default`</b>() -> NSParagraphStyle
}
let defaultStyle = NSParagraphStyle.<b>`default`</b>()              // Awkward
</pre>

<p>By contrast, later selector pieces become argument labels, which<br>are allowed to match Swift keywords without requiring backticks:</p>
<pre>
receiver.handle(someMessage, <b>for</b>: somebody)  // OK
</pre>
</li>
<li><p><strong>Never transform a name into “get”, “set”, “with”, “for”, or<br>“using”</strong>, just to avoid creating absurdly vacuous names.</p>
</li>
<li><p><strong>Never prune a suffix from a parameter introducer unless the suffix<br>is immediately preceded by a preposition, verb, or gerund</strong>.</p>
</li>
</ul>
<p>  This heuristic has the effect of preventing us from breaking up<br>  sequences of nouns that refer to a parameter.  Dropping just the<br>  suffix of a noun phrase tends to imply something unintended about<br>  the parameter that follows.  For example,</p>
  <pre>
func setText<b>Color</b>(_: UI<b>Color</b>)
...
button.<b>setTextColor</b>(.red())  <b>// clear</b>
</pre>

<p>  If we were to drop <code>Color</code>, leaving just <code>Text</code>, call sites<br>  would become confusing:</p>
  <pre>
func setText(_: UIColor)
...
button.<b>setText</b>(.red())      <b>// appears to be setting the text!</b>
</pre>

<p>  Note: We don’t maintain a list of nouns, but if we did, this<br>  rule could be more simply phrased as “don’t prune a suffix<br>  leaving a trailing noun before a parameter”.</p>
<ul>
<li><p><strong>Never prune a suffix from the base name of a method that matches a property of the enclosing class</strong>: </p>
<p>This heuristic has the effect of preventing us from producing<br>too-generic names for methods that conceptually modify a property<br>of the classs.</p>
<pre>
var <b>gestureRecognizers</b>: [UIGestureRecognizer]
func add<b>GestureRecognizer</b>(_: UI<b>GestureRecognizer</b>)
</pre>

<p>If we were to drop <code>GestureRecognizer</code>, leaving just <code>add</code>, we end<br>up with a method that conceptually modifies the<br><code>gestureRecognizers</code> property but uses an overly generic name to<br>do so:</p>
<pre>
var gestureRecognizers: [UIGestureRecognizer]
func add(_: UIGestureRecognizer) <b>// should indicate that we're adding to the property</b>
</pre>

</li>
</ul>
<h4 id="Pruning_Steps">Pruning Steps</h4><p>The following pruning steps are performed in the order<br>shown:</p>
<ol>
<li><p><strong>Prune the result type from the head of type-preserving<br>transforms</strong>.  Specifically, when</p>
<ul>
<li>the receiver type is the same as the result type</li>
<li>and the type name is matched at the head of the first selector piece</li>
<li>and the match is followed by a preposition</li>
</ul>
<p>then prune the match.</p>
<p>You can think of the affected operations as properties or<br>non-mutating methods that produce a transformed version of the<br>receiver.  For example:</p>
<pre>
extension NS<b>Color</b> {
&nbsp;&nbsp;func <b>color</b><i>With</i>AlphaComponent(_: CGFloat) -> NS<b>Color</b>
}
let translucentForeground = <b>foregroundColor.color</b><i>With</i>AlphaComponent(0.5)
</pre>

<p>becomes:</p>
<pre>
extension NS<b>Color</b> {
&nbsp;&nbsp;func <i>with</i>AlphaComponent(_: CGFloat) -> NS<b>Color</b>
}
let translucentForeground = <b>foregroundColor</b>.<i>with</i>AlphaComponent(0.5)
</pre>
</li>
<li><p><strong>Prune an additional hanging “By”</strong>. Specifically, if</p>
<ul>
<li>anything was pruned in step 1</li>
<li>and the remaining selector piece begins with “<code>By</code>“ <em>followed by a gerund</em>,</li>
</ul>
<p>then prune the initial “<code>By</code>“ as well.</p>
<p>This heuristic allows us to arrive at usage of the form <code>a =
b.frobnicating(c)</code>.  For example:</p>
<pre>
extension NSString {
&nbsp;&nbsp;func string<b>By</b><i>Applying</i>Transform(_: NSString, reverse: Bool) -> NSString?
}
let sanitizedInput = rawInput.<b>stringByApplyingTransform</b>(NSStringTransformToXMLHex, reverse: false)
</pre>

<p>becomes:</p>
<pre>
extension NSString {
&nbsp;&nbsp;func applyingTransform(_: NSString, reverse: Bool) -> NString?
}
let sanitizedInput = rawInput.<b>applyingTransform</b>(NSStringTransformToXMLHex, reverse: false)
</pre>
</li>
<li><p><strong>Prune a match for any type name in the signature from the tail of<br>the preceding selector piece</strong>. Specifically,</p>
<p>|From the tail of:                               |Prune a match for:              |<br>|————————————————|——————————–|<br>|a selector piece that introduces a parameter    |the parameter type name         |<br>|the name of a property                          |the property type name          |<br>|the name of a zero-argument method              |the return type name            |</p>
<p>For example,</p>
<pre>
extension NSDocumentController {
&nbsp;&nbsp;func documentFor<b>URL</b>(_ url: NS<b>URL</b>) -> NSDocument? // parameter introducer
}
extension NSManagedObjectContext {
&nbsp;&nbsp;var parent<b>Context</b>: NSManagedObject<b>Context</b>?       // property
}
extension UIColor {
&nbsp;&nbsp;class func darkGray<b>Color</b>() -> UI<b>Color</b>            // zero-argument method
}
...
myDocument = self.documentFor<b>URL</b>(locationOfFile)
if self.managedObjectContext.parent<b>Context</b> != changedContext { return }
foregroundColor = .darkGray<b>Color</b>()
</pre>

<p>becomes:</p>
<pre>
extension NSDocumentController {
&nbsp;&nbsp;func documentFor(_ url: NSURL) -> NSDocument?
}
extension NSManagedObjectContext {
&nbsp;&nbsp;var parent : NSManagedObjectContext?
}
extension UIColor {
&nbsp;&nbsp;class func darkGray() -> UIColor
}
...
myDocument = self.<b>documentFor</b>(locationOfFile)
if self.managedObjectContext.<b>parent</b> != changedContext { return }
foregroundColor = .<b>darkGray</b>()
</pre>

</li>
</ol>
<h5 id="Why_Does_Order_Matter?">Why Does Order Matter?</h5><p>Some steps below prune matches from the head of the first selector<br>piece, and some prune from the tail.  When <code>pruning restrictions</code>_<br>prevent both the head and tail from being pruned, prioritizing<br>head-pruning steps can keep method families together.  For example,<br>in NSFontDescriptor:</p>
<pre><code><span class="func"><span class="keyword">func</span> <span class="title">fontDescriptorWithSymbolicTraits</span><span class="params">(<span class="number">_</span>: NSFontSymbolicTraits)</span></span> -&gt; <span class="type">NSFontDescriptor</span>
<span class="func"><span class="keyword">func</span> <span class="title">fontDescriptorWithSize</span><span class="params">(<span class="number">_</span>: CGFloat)</span></span> -&gt; <span class="type">UIFontDescriptor</span>
<span class="func"><span class="keyword">func</span> <span class="title">fontDescriptorWithMatrix</span><span class="params">(<span class="number">_</span>: CGAffineTransform)</span></span> -&gt;  <span class="type">UIFontDescriptor</span>
...
</code></pre><p>becomes:</p>
<pre>
func <b>with</b>SymbolicTraits(_: UIFontDescriptorSymbolicTraits) ->  UIFontDescriptor
func <b>with</b>Size(_: CGFloat) -> UIFontDescriptor
func <b>with</b>Matrix(_: CGAffineTransform) -> UIFontDescriptor
...
</pre>

<p>If we instead began by pruning <code>SymbolicTraits</code> from the tail of<br>the first method name, the prohibition against creating <code>absurdly
vacuous names</code>_ would prevent us from pruning “<code>fontDescriptorWith</code>“<br>down to “<code>with</code>“, resulting in:</p>
<pre>
func <b>fontDescriptorWith</b>(_: NSFontSymbolicTraits) -> NSFontDescriptor // inconsistent
func withSize(_: CGFloat) -> UIFontDescriptor
func withMatrix(_: CGAffineTransform) -> UIFontDescriptor
...
</pre>


<h4 id="Add_Default_Arguments">Add Default Arguments</h4><p>For any method that is not a single-parameter setter, default<br>arguments are added to parameters in the following cases:</p>
<ul>
<li><p><strong>Nullable trailing closure parameters</strong> are given a default value of <code>nil</code>.</p>
</li>
<li><p><strong>Nullable NSZone parameters</strong> are given a default value of <code>nil</code>. Zones are essentially unused in Swift and should always be <code>nil</code>.</p>
</li>
<li><p><strong>Option set types</strong> whose type name contain the word “Options” are given a default value of <code>[]</code> (the empty option set).</p>
</li>
</ul>
<p>Together, these heuristics allow code like:</p>
<pre>
rootViewController.presentViewController(alert, animated: true<b>, completion: nil</b>)
UIView.animateWithDuration(
  0.2, delay: 0.0, <b>options: [],</b> animations: { self.logo.alpha = 0.0 }) { 
    _ in self.logo.hidden = true 
}
</pre>

<p>to become:</p>
<pre><code>rootViewController.present(alert, <span class="string">animated:</span> <span class="literal">true</span>)
UIView.animateWithDuration(
  <span class="number">0.2</span>, <span class="string">delay:</span> <span class="number">0.0</span>, <span class="string">animations:</span> { self.logo.alpha = <span class="number">0.0</span> }) { _ <span class="keyword">in</span> self.logo.hidden = <span class="literal">true</span> }
</code></pre><h4 id="Add_First_Argument_Labels">Add First Argument Labels</h4><p>When the first parameter of a method is defaulted, <strong>split the first<br>selector piece if it contains a preposition</strong>, turning everything<br>starting with the last preposition into a <em>required</em> label for the<br>first argument. If the generated first argument label starts with the<br>word “with”, drop the “with”.</p>
<p>This heuristic eliminates words that refer only to the first<br>argument from call sites where the argument’s default value is<br>used. For example, instead of:</p>
<pre>
extension NSArray {
  func enumerateObjects<b>With</b>(_: NSEnumerationOptions <b>= []</b>, using: (AnyObject, UnsafeMutablePointer<objcbool>) -> Void)
}

array.enumerateObjects<b>With</b>(.Reverse) { // OK
 // ..
}

array.enumerateObjects<b>With</b>() {         // ?? With what?
 // ..
}
</objcbool></pre>

<p>we get:</p>
<pre>
extension NSArray {
  func enumerateObjects(<b>options</b> _: NSEnumerationOptions <b>= []</b>, using: (AnyObject, UnsafeMutablePointer<objcbool>) -> Void)
}

array.enumerateObjects(<b>options:</b> .Reverse) { // OK
 // ..
}

array.enumerateObjects() {               // OK
 // ..
}
</objcbool></pre>

<h4 id="Prepend_“is”_to_Boolean_Properties">Prepend “is” to Boolean Properties</h4><p><strong>Unless the name of a Boolean property contains</strong></p>
<ul>
<li><p><strong>an auxiliary verb</strong> such as “is”, “has”, “may”, “should”, or<br>“will”</p>
</li>
<li><p><strong>or, a word ending in “s”</strong> , indicating either a plural (for which<br>prepending “is” would be incorrect) or a verb in the continuous<br>tense (which indicates its Boolean nature, e.g., “translates” in<br>“<code>translatesCoordinates</code>“)</p>
</li>
</ul>
<p><strong>prepend “is” to its name</strong>.</p>
<p>For example:</p>
<pre><code>extension NSBezierPath {
  <span class="keyword">var</span> <span class="keyword">empty</span>: <span class="keyword">Bool</span>
}

<span class="keyword">if</span> path.<span class="keyword">empty</span> { ... }
</code></pre><p>will become</p>
<pre>
extension NSBezierPath {
  var <b>isEmpty</b>: Bool
}

if path.<b>isEmpty</b> { ... }
</pre>

<h3 id="Stripping_the_“NS”_Prefix">Stripping the “NS” Prefix</h3><p>The removal of the “NS” prefix for the Foundation module (or other<br>specifically identified modules) is a mechanical translation for all<br>global symbols defined within that module that can be performed in the<br>Clang importer. Note that this removal can create conflicts with the<br>standard library. For example, <code>NSString</code> and <code>NSArray</code> will become<br><code>String</code> and <code>Array</code>, respectively, and Foundation’s versions will<br>shadow the standard library’s versions. We are investigating several<br>ways to address this problem, including:</p>
<ul>
<li><p>Retain the <code>NS</code> prefix on such classes.</p>
</li>
<li><p>Introduce some notion of submodules into Swift, so that these<br>classes would exist in a submodule for reference-semantic types<br>(e.g., one would refer to <code>Foundation.ReferenceTypes.Array</code> or similar).</p>
</li>
</ul>
<h2 id="Impact_on_existing_code">Impact on existing code</h2><p>The proposed changes are massively source-breaking for Swift code that<br>makes use of Objective-C frameworks, and will require a migrator to<br>translate Swift 2 code into Swift 3 code. The <code>-Womit-needless-words</code><br>flag described in the <a href="#implementation-experience">Implementation<br>Experience</a> section can provide the basics<br>for such a migrator. Additionally, the compiler needs to provide good<br>error messages (with Fix-Its) for Swift code that refers to the old<br>(pre-transformed) Objective-C names, which could be achieved with some<br>combination of the Fix-Its described previously and a secondary name<br>lookup mechanism retaining the old names.</p>
<h2 id="Acknowledgments">Acknowledgments</h2><p>The automatic translation described in this proposal has been<br>developed as part of the effort to produce the <a href="https://swift.org/documentation/api-design-guidelines.html" title="API Design Guidelines" target="_blank" rel="external">Swift API Design<br>Guidelines</a> with Dmitri Hrybenko, Ted Kremenek,<br>Chris Lattner, Alex Migicovsky, Max Moiseev, Ali Ozer, and Tony Parker.</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/">&laquo;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/7/">&raquo;</a>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="https://avatars2.githubusercontent.com/u/14305708?v=3&s=460" alt="terry" itemprop="image"/>
          <p class="site-author-name" itemprop="name">terry</p>
        </div>
        <p class="site-description motion-element" itemprop="description">terry yang's blog | java | scala | bi</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">110</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">5</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">9</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-next-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yangwei8888" target="_blank">github</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/microsoftgoogles" target="_blank">weibo</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/run-zhi-38" target="_blank">zhihu</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">terry</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  

    <script type="text/javascript">
      var disqus_shortname = 'yangwei888';
      var disqus_identifier = 'page/6/index.html';
      var disqus_title = '';
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
