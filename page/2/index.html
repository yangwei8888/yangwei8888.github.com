<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="terry yang's blog | java | scala | bi" />



  <meta name="keywords" content="Hexo,next" />



  <link rel="alternate" href="/atom.xml" title="yosita" type="application/atom+xml" />



  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="terry yang&apos;s blog | java | scala | bi">
<meta property="og:type" content="website">
<meta property="og:title" content="yosita">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="yosita">
<meta property="og:description" content="terry yang&apos;s blog | java | scala | bi">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="yosita">
<meta name="twitter:description" content="terry yang&apos;s blog | java | scala | bi">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>

  <title> yosita </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  

  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?953e46480b0a75d01aaf6d872cc77099";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">yosita</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/03Working with Cocoa Data Types/" itemprop="url">
                02Interoperability-03与 Cocoa 数据类型共舞
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-26T22:00:08+08:00" content="2015-12-26">
            2015-12-26
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Using-Swift-with-Cocoa-and-Objective-C/" itemprop="url" rel="index">
                  <span itemprop="name">Using-Swift-with-Cocoa-and-Objective-C</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/03Working with Cocoa Data Types/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/03Working with Cocoa Data Types/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><blockquote>
<p>翻译：<a href="https://github.com/wongzigii" target="_blank" rel="external">wongzigii</a>、<a href="https://github.com/SemperIdem" target="_blank" rel="external">星夜暮晨</a></p>
<p>校对：<a href="https://github.com/dabing1022" target="_blank" rel="external">ChildhoodAndy</a></p>
</blockquote>
<h2 id="23_u4E0E_Cocoa__u6570_u636E_u7C7B_u578B_u5171_u821E"><a href="#23_u4E0E_Cocoa__u6570_u636E_u7C7B_u578B_u5171_u821E" class="headerlink" title="#与 Cocoa 数据类型共舞"></a>#与 Cocoa 数据类型共舞</h2><p>本节内容包括：</p>
<ul>
<li><a href="/#strings">字符串（Strings）</a></li>
<li><a href="/#numbers">数值（Numbers）</a></li>
<li><a href="/#collection_classes">集合类（Collection Classes）</a></li>
<li><a href="/#errors">错误（Errors）</a></li>
<li><a href="/#foundation_data_types">Foundation数据类型（Foundation Data Types）</a></li>
<li><a href="/#foundation_functions">Foundation函数（Foundation Functions）</a></li>
<li><a href="/#core_foundation">Core Foundation</a></li>
</ul>
<p>作为对 Objective-C 互用性（互操作性）的一部分，Swift提供快捷高效的方式来处理 Cocoa 数据类型。</p>
<p>Swift 会自动将一些 Objective-C 类型转换为 Swift 类型，以及将 Swift 类型转换为 Objective-C 类型。在 Objective-C 和 Swift 中也有一些具有互用性的数据类型。那些可转换的数据类型或者具有互用性的数据类型被称为<em>bridged</em>数据类型。举个例子，在 Swift 中，我们可以将一个<code>Array</code>值传递给一个要求为<code>NSArray</code>对象的方法。我们也可以转换一个 bridged 类型和它的副本。当我们使用<code>as</code>转换 bridged 类型或者那些由常量和变量所提供的类型时，Swift 会桥接它们的数据类型。</p>
<p>Swift 也提供一种简单便捷的覆盖方法来连接 Foundation 的数据类型，在后面的 Swift 语言中，我们能在它的句法中感受到自然和统一。</p>
<p><a name="strings"></a></p>
<p>##字符串</p>
<p>Swift会在<code>String</code>类型和<code>NSString</code>类型中自动转换。这意味着在可以使用<code>NSString</code>对象的地方，我们可以使用一个属于 Swift 的<code>String</code>类型代替它，这样做会同时拥有它们数据类型的特点，比如说<code>String</code>类型的字符串插值，基于Swift设计的API，以及<code>NSString</code>类的多种功能。因此，我们几乎不必再在我们的代码中使用<code>NSString</code>类。事实上，当 Swift 接入 Objective-C API 时，它将把所有<code>NSString</code>类型替换为<code>String</code>类型。当我们在我们的Objective-C代码中使用 Swift 类时，接入的API会将所有<code>String</code>类型替换成<code>NSString</code>类型。</p>
<p>为了允许字符串转换，只需导入Foundation框架。举个例子，我们在 Swift的一个字符串中可以访问<code>capitalizedString</code>，这是<code>NSString</code>类的一个属性，然后 Swift 会自动将<code>String</code>转换为一个<code>NSString</code>对象来访问这个属性。这个属性甚至会返回一个 Swift的<code>String</code>类型，因为它在导入的时候被替换了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">let</span> greeting = <span class="string">"hello, world!"</span></span><br><span class="line"><span class="keyword">let</span> capitalizedGreeting = greeting.capitalizedString</span><br><span class="line"><span class="comment">// capitalizedGreeting: String = Hello, World!</span></span><br></pre></td></tr></table></figure>
<p>如果我们确实需要用到一个<code>NSString</code>对象，我们可以用一个 Swift 的<code>String</code>值并转换它。<code>String</code>类型总是可以从一个<code>NSString</code>对象转换为一个Swift的<code>String</code>的值，因此，再没有必要去使用一个可选的类型转换器(<code>as?</code>)。我们也可以在一个字符串中通过定义常量和变量来创建一个<code>NSString</code>对象。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">let</span> myString: <span class="type">NSString</span> = <span class="string">"123"</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> integerValue = <span class="type">Int</span>(myString <span class="keyword">as</span> <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(myString)</span> is the integer <span class="subst">\(integerValue)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// prints "123 is the integer 123"</span></span><br></pre></td></tr></table></figure>
<p>###本地化<br>在Objective-C中，常用<code>NSLocalizedString</code>类的宏来定位一个字符串。这集合的宏包括<code>NSLocalizedString</code>，<code>NSLocalizedStringFromTable</code>，<code>NSLocalizedStringFromTableInBundle</code>，和<code>NSLocalizedStringWithDefaultValue</code>。而在Swift中，只用一个函数就可以实现跟整个<code>NSLocalizedString</code>集一样的功能，即<code>NSLocalizedString(key:tableName:bundle:value:comment:)</code>。这个<code>NSLocalizedString</code>函数分别为<code>tableName</code>，<code>bundle</code>和<code>value</code>参数提供了一个默认值。我们可以用它来替换宏。</p>
<p><a name="numbers"></a></p>
<p>##数值</p>
<p>Swift会自动将已确定的数值类型<code>Int</code>和<code>Float</code>转换为<code>NSNumber</code>。这样的转换允许我们基于其中一种类型创建一个<code>NSNumber</code>：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let <span class="keyword">n</span> = 42</span><br><span class="line">let <span class="keyword">m</span>: NSNumber = <span class="keyword">n</span></span><br></pre></td></tr></table></figure>
<p>我们也能传递一个<code>Int</code>类型的值，比如传递给一个要求为<code>NSNumber</code>类型的参数。同时需要注意的是，<code>NSNumber</code>可以包含多种不同的类型，因此我们不能把它传递给单一的一个<code>Int</code>值。</p>
<p>下面所列出的类型都会自动转换为<code>NSNumber</code>：</p>
<ul>
<li><code>Int</code></li>
<li><code>UInt</code></li>
<li><code>Float</code></li>
<li><code>Double</code></li>
<li><code>Bool</code></li>
</ul>
<p><a name="collection_classes"></a></p>
<p>##集合类</p>
<p>Swift 会自动将<code>NSArray</code>、<code>NSSet</code>和<code>NSDictionary</code>类转换为Swift里等价的类：<code>Array</code>、<code>Set</code>和<code>Dictionary</code>。这意味着我们将受益于Swift强大的算法和得天独厚的语法来处理集合–可互相转换的 Foundation 和 Swift 集合类型。</p>
<p>###数组(Arrays)</p>
<p>Swift 会在<code>Array</code>类型和<code>NSArray</code>类型中自动转换。当我们从一个 Swift 数组转换成一个<code>NSArray</code>对象后，转换后的结果则是一个<code>[ObjectType]</code>类型的数组。如果<code>NSArray</code>对象没有指明一个确切的参数类型，那么它将会转换成<code>[AnyObject]</code>类型的Swift数组。</p>
<p>比如说，我们看到以下Objective-C声明：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSDate</span> *&gt;* dates;</span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">NSDate</span> *&gt; *)datesBeforeDate:(<span class="built_in">NSDate</span> *)date;</span><br><span class="line">- (<span class="keyword">void</span>)addDatesParsedFromTimestamps:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)timestamps;</span><br></pre></td></tr></table></figure>
<p>那么，转换为Swift，则是这样子的：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dates: [<span class="type">NSDate</span>]</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">datesBeforeDate</span><span class="params">(date: NSDate)</span></span> -&gt; [<span class="type">NSDate</span>]</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">addDatesParsedFromTimestamps</span><span class="params">(timestamps: [String])</span></span></span><br></pre></td></tr></table></figure></p>
<p>如果某个对象是 Objective-C 或者 Swift 类的实例，或者这个对象可以转换成另一种类型，那么这个对象则属于<code>AnyObject</code>类型的对象。我们可以将任一<code>NSArray</code>对象转换成一个 Swift 数组，因为所有 Objective-C 的对象都是<code>AnyObject</code>类型的。正因如此，Swift 的编译器会在接入 Objective-C APIs 的时候将<code>NSArray</code>类替换成<code>AnyObject[]</code>。</p>
<p>当我们将一个<code>NSArray</code>对象转换成一个 Swift 数组后，我们也可以将数组强制类型转换成一个特定的类型。与从<code>NSArray</code>类转换到<code>AnyObject[]</code>不同的是，从<code>AnyObject</code>类型的对象转换成明确的类型并不会保证成功。由于直到运行时编译器才知道<code>AnyObject</code>的对象能否被强制转换为特定的类型，因此，从<code>AnyObject[]</code>转换为<code>SomeType[]</code>会返回一个 optional 的值。举个例子，如果我们知道一个Swift数组只包含<code>UIView</code>类的实例(或者一个<code>UIView</code>类的子类)，我们可以将<code>AnyObject</code>类型的数组元素强制转换为<code>UIView</code>对象。如果Swift数组中的元素在运行时不是<code>UIView</code>类型的对象，那么转换则会返回<code>nil</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> swiftyArray = foundationArray <span class="keyword">as</span> <span class="type">AnyObject</span>[]</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> downcastedSwiftArray = swiftArray <span class="keyword">as</span>? <span class="type">UIView</span>[] &#123;</span><br><span class="line">    <span class="comment">// downcastedSwiftArray contains only UIView objects</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以在for循环中将NSArray对象定向地强制转换为特定类型的Swift数组:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> aView: <span class="type">UIView</span>! <span class="keyword">in</span> foundationArray &#123;</span><br><span class="line">     <span class="comment">// aView is of type UIView</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这种转换是强制转换，如果转换不成功则会在运行时产生错误信息。</p>
</blockquote>
<p>当我们从 Swift 数组转换为<code>NSArray</code>对象时，Swift 数组里的元素必须是属于<code>AnyObject</code>的。例如，一个<code>Int[]</code>类型的 Swift 数组包含<code>Int</code>结构的元素。<code>Int</code>类型并不是一个类的实例，但由于<code>Int</code>类型转换成了<code>NSNumber</code>类，<code>Int</code>类型属于<code>AnyObject</code>类型的。因此，我们可以将一个<code>Int[]</code>类型的Swift数组转换为<code>NSArray</code>对象。如果 Swift 数组里的一个元素不属于<code>AnyObject</code>类型，那么在运行时就会产生错误。</p>
<p>我们也可以从 Swift 数组中创建一个<code>NSArray</code>对象。当我们将一个常量或变量定义为一个<code>NSArray</code>对象并分配一个数组给它作为实例变量时，Swift 将会创建 <code>NSArray</code>对象，而不是 Swift 数组。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> schoolSupplies: <span class="type">NSArray</span> = [<span class="string">"Pencil"</span>, <span class="string">"Eraser"</span>, <span class="string">"Notebkko"</span>]</span><br><span class="line"><span class="comment">// schoolSupplies is an NSArray object containing NSString objects</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，Swift 数组包含包含三个<code>String</code>字符串。由于从<code>String</code>类型转换为<code>NSString</code>类，数组字面量被转换成一个<code>NSArray</code>对象，并成功分配给<code>schoolSupplies</code>变量。</p>
<p>当我们在 Objective-C 代码中使用 Swift 类或者协议时，接入的API会将全部所有类型的Swift数组代替为<code>NSArray</code>。若我们将一个<code>NSArray</code>对象传递给Swift的API并要求数组元素为一个新的类型，运行时就会产生错误。如果 Swift API 返回一个不能被转换为<code>NSArray</code>类型的 Swift 数组，错误也会随之产生。</p>
<p>###集合(Sets)</p>
<p>除了数组以外，Swift还会自动在<code>Set</code>类型和<code>NSSet</code>类之间进行转换。当我们将一个带有参数类型的<code>NSSet</code>对象转换为Swift集合之后，得到的结果是<code>Set&lt;ObjectType&gt;</code>类型的集合。而如果<code>NSSet</code>对象没有指明其参数类型，那么它将会转换为<code>Set&lt;AnyObject&gt;</code>类型的Swift集合。</p>
<p>比如说，我们看到以下Objective-C声明：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt;* words;</span><br><span class="line">- (<span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt; *)wordsMatchingPredicate:(<span class="built_in">NSPredicate</span> *)predicate;</span><br><span class="line">- (<span class="keyword">void</span>)removeWords:(<span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt; *)words;</span><br></pre></td></tr></table></figure>
<p>那么，转换为Swift，则是这个样子的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> words: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">wordsMatchingPredicate</span><span class="params">(predicate: NSPredicate)</span></span> -&gt; <span class="type">Set</span>&lt;<span class="type">String</span>&gt;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">removeWords</span><span class="params">(words: Set&lt;String&gt;)</span></span></span><br></pre></td></tr></table></figure>
<p>我们能够将所有<code>NSSet</code>对象转换为Swift集合，因为所有的Objective-C对象都可以被转换为<code>AnyObject</code>。所有的<code>NSSet</code>对象都能够转换为Swift对象，因此Swift编译器将会在导入Objective-C API的时候，将所有的<code>NSSet</code>类转换为<code>Set&lt;AnyObject&gt;</code>。同理，当我们在Objective-C中使用Swift类或者协议的时候，导入器将会将Swift集合重新映射为Objective-C兼容的类型：<code>NSSet</code>对象。</p>
<p>当我们将<code>NSSet</code>对象转换为Swift集合后，还可以将集合下转为其他指定类型。就如同Swift数组的下转一样，Swift集合的下转不确保一定成功。对<code>Set&lt;AnyObject&gt;</code>下转为指定类型的结果需要使用<code>as?</code>操作符，以确保其是可选值。</p>
<p>我们仍然可以直接从Swift数组字面量中直接创建一个<code>NSSet</code>对象，它同样遵循上面提到的转换规则。当我们明确地将某个常量或者变量定义为<code>NSSet</code>对象，并且使用一个数组字面量来赋值的时候，Swift将会创建一个<code>NSSet</code>对象，而不是Swift集合。</p>
<p>###字典(Dictionaries)</p>
<p>Swift同样可以在<code>Dictionary</code>和<code>NSDictionary</code>类当中自动转换。当我们将带有参数类型的<code>NSDictionary</code>对象转换为Swift字典之后，得到的结果是一个<code>[ObjectType]</code>类型的字典。如果<code>NSDictionary</code>对象没有指明参数类型，那么它将会被转换为<code>[NSObject:AnyObject]</code>类型的Swift字典。</p>
<p>比如说，我们看到以下Objective-C声明：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSURL</span> *, <span class="built_in">NSData</span> *&gt;* cachedData;</span><br><span class="line">- (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSURL</span> *, <span class="built_in">NSNumber</span> *&gt; *)fileSizesForURLsWithSuffix:(<span class="built_in">NSString</span> *)suffix;</span><br><span class="line">- (<span class="keyword">void</span>)setCacheExpirations:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSURL</span> *, <span class="built_in">NSDate</span> *&gt; *)expirations;</span><br></pre></td></tr></table></figure>
<p>那么，转换为Swift，则是这个样子的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cachedData: [<span class="type">NSURL</span>: <span class="type">NSData</span>]</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">fileSizesForURLsWithSuffix</span><span class="params">(suffix: String)</span></span> -&gt; [<span class="type">NSURL</span>: <span class="type">NSNumber</span>]</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">setCacheExpirations</span><span class="params">(expirations: [NSURL: NSDate])</span></span></span><br></pre></td></tr></table></figure>
<p>我们能够将所有的<code>NSDictionary</code>对象转换为Swift字典，因为所有的Objective-C对象都兼容<code>AnyObject</code>。重申一下，某个对象能够“兼容”<code>AnyObject</code>，指的是其是Objective-C的一个实例，或者是Swift的类，亦或者是能够转换为这两者之一的东西。所有的<code>NSDictionary</code>对象都能够转换为Swift字典，因此Swift编译器会在导入Objective-C API的时候，将所有的<code>NSDictionary</code>类替换成<code>[NSObject: AnyObject]</code>。同理，当我们在Objective-C中使用Swift类或者协议的时候，导入器将会将Swift字典重新映射为Objective-C兼容的类型：<code>NSDictionary</code>对象。</p>
<p>当我们将<code>NSDictionary</code>对象转换为Swift字典后，还可以将字典<em>下转</em>为其他指定类型。就如同Swift数组的下转一样，Swift字典的下转不确保一定成功。对<code>[NSObject: AnyObject]</code>下转为指定类型的结果需要使用<code>as?</code>操作符，以确保其是可选值。</p>
<p>当我们进行反向转换，也就是将Swift字典转换为<code>NSDictionary</code>对象的过程中，其键值都必须是某个类的实例，或者能够被转换为某个类的实例。</p>
<p>我们仍然可以直接从Swift数组字面量中直接创建一个<code>NSDictionary</code>对象，它同样遵循上面提到的转换规则。当我们明确地将某个常量或者变量定义为<code>NSDictionary</code>对象，并且使用一个数组字面量来赋值的时候，Swift将会创建一个<code>NSDictionary</code>对象，而不是Swift字典。</p>
<p><a name="errors"></a></p>
<p>##错误</p>
<p>Swift能够自动在<code>ErrorType</code>类型和<code>NSError</code>类之间转换，会发生错误的Objective-C方法等价于Swift中的<code>throw</code>方法，而会发生错误的Swift方法通过Objecitive-C错误约定，也等价于产生错误的Objective-C方法。</p>
<p>实现<code>ErrorType</code>协议，并且使用<code>@objc</code>特性声明的Swift枚举类型，会产生一个<code>NS_ENUM</code>声明和一个<code>NSString</code>常量，以能够在产生的头文件中设定对应的错误范围。比如说，有以下Swift枚举声明代码：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@objc</span> public <span class="class"><span class="keyword">enum</span> <span class="title">CustomError</span>: <span class="title">Int</span>, <span class="title">ErrorType</span> &#123;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="constant">A</span>, <span class="constant">B</span>, <span class="constant">C</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，在相应的生成头文件中的Objectivive-C声明就是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Project-Swift.h</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">SWIFT_ENUM</span><span class="params">(NSInteger, CustomError)</span> </span>&#123;</span><br><span class="line">  CustomErrorA = <span class="number">0</span>,</span><br><span class="line">  CustomErrorB = <span class="number">1</span>,</span><br><span class="line">  CustomErrorC = <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> NSString * <span class="keyword">const</span> CustomErrorDomain = @<span class="string">"Project.CustomError"</span>;</span><br></pre></td></tr></table></figure>
<p>关于更多Swift和Objective-C API中错误处理的相关信息，请参阅<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-ID10" target="_blank" rel="external">Error Handling</a>。</p>
<p><a name="foundation_data_types"></a></p>
<p>##Foundation数据类型<br>Swift 也提供一种简单便捷的覆盖方法来连接定义在 Foundation 框架中的数据类型。在<code>CGSize</code>和<code>CGPoint</code>中使用覆盖方法，我们就能在它的句法中感受到Swift语言的自然和统一。比如，我们可以使用如下语法创建一个<code>CGSize</code>类型的结构:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> size = <span class="type">CGSize</span>(width: <span class="number">20</span>, height: <span class="number">40</span>)</span><br></pre></td></tr></table></figure>
<p>覆盖方法也允许我们以一种自然的方式调用 Foundation 的结构函数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rect = <span class="type">CGRect</span>(x: <span class="number">50</span>, y: <span class="number">50</span>, width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line"><span class="keyword">let</span> width = rect.width    <span class="comment">// equivalent of CGRectGetWidth(rect)</span></span><br><span class="line"><span class="keyword">let</span> maxX = rect.maxY      <span class="comment">// equivalent of CGRectGetMaxY(rect)</span></span><br></pre></td></tr></table></figure>
<p>Swift可以将<code>NSUInteger</code>和<code>NSInteger</code>转换为<code>Int</code>类型。这些类型都会在 Foundation APIs 中变为<code>Int</code>类型。在 Swift 中<code>Int</code>常被尽可能地用以连贯性，同时当我们要求一个无符号整数类型时，<code>UInt</code>类型总是可使用的。</p>
<p><a name="foundation_functions"></a></p>
<p>##Foundation函数</p>
<p>在 Swift 中，<code>NSLog</code>可在系统控制台输出信息。我们可以像在 Objective-C 中使用过的语法格式那样使用此函数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSLog</span>(<span class="string">"%.7f"</span>, pi)</span><br><span class="line"><span class="comment">// Logs "3.1415927" to the console</span></span><br></pre></td></tr></table></figure>
<p>同时，Swift 也提供像<code>print(_:)</code>这样的输出函数。多亏于 Swift 的字符插值机制才让这些函数简单，粗暴，高效。这些函数不会在系统控制台输出信息，但在需要调用的时候却是可用的。</p>
<p>Swift 中不再存在<code>NSAssert</code>函数，取而代之的是<code>assert</code>函数。</p>
<p><a name="core_foundation"></a></p>
<p>##Core Foundation</p>
<p>Swift中的 Core Foundation 类型是一个成熟的类。当出现内存管理注释时，Swift 会自动地管理 Core Foundation 对象的内存，这其中包括我们实例化了的 Core Foundation 对象。在 Swift 中，我们可以自由变换 Fundation 和 Core Foundation 类型。如果我们想先转换为桥接 Foundation 类型时，那么也可以桥接一些 toll-free bridged Core Foundation 类型到 Swift 标准库类型。</p>
<p>###重映射类型(Remapped Types)</p>
<p>当 Swift 导入 Core Foundation 类型时，编译器会重映射导入的类型名字。编译器会从每个类型名字的末端移除 <em>Ref</em>，这是因为所有的 Swift 类都属于引用类型，因此后缀是多余的。</p>
<p>Core Foundation 中的<code>CFTypeRef</code>类型会对<code>Anyobject</code>类型重映射。所以我们以前使用的<code>CFTypeRef</code>，现在该换成<code>AnyObject</code>了。</p>
<p>###内存管理对象(Memory Managed Objects)</p>
<p>在 Swift 中，从 annotated APIs 返回的 Core Foundation 对象能够自动进行内存管理–我们不再需要调用自身的<code>CFRetain</code>，<code>CFRelease</code>，或者<code>CFAutorelease</code>函数。</p>
<p>如果我们从自身的C函数和 Objective-C 方法中返回一个 Core Foundation 对象，我们需要用<code>CF_RETURNS_RETAINED</code>或者<code>CF_RETURNS_NOT_RETAINED</code>注释这个对象。我们同样可以使用<code>CF_IMPLICIT_BRIDGING_ENABLED</code>和<code>CF_IMPLICIT_BRIDGING_DISABLED</code>宏命令来封装C函数声明，这些函数遵循Core Foundation的管理规定、命名规定，以便能够根据命名退导出内存管理机制能。</p>
<p>如果我们只调用那些不会间接返回 Core Foundation 对象的 annotated APIs，那么现在我们可以跳过本节的剩余部分了。否则，下面我们继续学习非托管的 Core Foundation 对象。</p>
<p>###非托管对象(Unmanaged Objects)</p>
<p>当 Swift 导入 unannotated 的APIs时，编译器将不会自动地对返回的 Core Foundation 对象进行内存管理托管。Swift 将这些返回的 Core Foundation 对象封闭在一个<code>Unmanaged&lt;T&gt;</code>结构中。那些间接返回 Core Foundation 的对象也是非托管的。举个例子，这里有一个 unannotated 的 C 函数:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CFStringRef</span> <span class="type">StringByAddingTwoStrings</span>(<span class="type">CFStringRef</span> string1, <span class="type">CFStringRef</span> string2)</span><br></pre></td></tr></table></figure>
<p>这里说明了Swift是怎么导入的:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">StringByAddingTwoStrings</span><span class="params">(CFString!, CFString!)</span></span> -&gt; <span class="type">Unmanaged</span>&lt;<span class="type">CFString</span>&gt;!</span><br></pre></td></tr></table></figure>
<p>假设我们从 unannotated APIs 接收了非托管的对象，在使用它之前，我们必须将它转换为能够内存管理的对象。在这方面，Swift 可以帮我们进行内存管理而不用自己动手。同时，<code>Unmanaged&lt;T&gt;</code>结构也提供了两个方法来把一个非托管对象转换为一个可内存管理的对象–<code>takeUnretainedValue()</code>方法和<code>takeRetainedValue()</code>方法。这两个方法会返回原始的，非封闭的对象类型。我们可以根据我们实际调用的APIs返回的unretained或retained的对象，来选择哪一方法更合适。</p>
<p>比如，假设这里有一个 C 函数，这个函数在返回值前不会释放<code>CFString</code>对象。在使用这个对象前，我们使用<code>takeUnretainedValue()</code>函数，以将它转换为一个能够内存管理托管的对象。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> memoryManagedResult = <span class="type">StringByAddingTwoStrings</span>(str1, str2).takeUnretainedValue()</span><br><span class="line"><span class="comment">// memoryManagedResult is a memory managed CFString</span></span><br></pre></td></tr></table></figure>
<p>我们也可以在一个非托管的对象中使用<code>retain()</code>，<code>release()</code>和<code>autorelease()</code>方法，但是这种做法并不值得推荐。</p>
<p>要了解更多信息，请参考<a href="https://developer.apple.com/library/prerelease/ios/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/CFMemoryMgmt.html#//apple_ref/doc/uid/10000127i" target="_blank" rel="external">Memory Management Programming Guide for Core Foundation</a>中的<a href="https://developer.apple.com/library/prerelease/ios/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148" target="_blank" rel="external">Memory Management Programming Guide for Core Foundation</a>一节。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/04Adopting Cocoa Design Patterns/" itemprop="url">
                02Interoperability-04采用Cocoa设计模式
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-26T22:00:07+08:00" content="2015-12-26">
            2015-12-26
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Using-Swift-with-Cocoa-and-Objective-C/" itemprop="url" rel="index">
                  <span itemprop="name">Using-Swift-with-Cocoa-and-Objective-C</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/04Adopting Cocoa Design Patterns/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/04Adopting Cocoa Design Patterns/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><blockquote>
<p>翻译：<a href="https://github.com/JaceFu" target="_blank" rel="external">JaceFu</a> <a href="https://github.com/dabing1022" target="_blank" rel="external">ChildhoodAndy</a></p>
<p>校正：<a href="https://github.com/LunaticM" target="_blank" rel="external">LunaticM</a> <a href="https://github.com/dabing1022" target="_blank" rel="external">ChildhoodAndy</a></p>
</blockquote>
<h2 id="23_u91C7_u7528Cocoa_u8BBE_u8BA1_u6A21_u5F0F"><a href="#23_u91C7_u7528Cocoa_u8BBE_u8BA1_u6A21_u5F0F" class="headerlink" title="#采用Cocoa设计模式"></a>#采用Cocoa设计模式</h2><p>本页包含内容：</p>
<ul>
<li><a href="/#Delegation">委托（Delegation）</a></li>
<li><a href="/#error_handling">错误处理（Error Handling）</a></li>
<li><a href="/#Key-Value_Observing">键值观察（Key-Value Observing）</a></li>
<li><a href="/#Target_Action">Target-Action模式（Target-Action）</a></li>
<li><a href="/#Introspection">类型匹配与统一规范（Introspection）</a></li>
<li><a href="/#API_Availability">API 可用性</a></li>
</ul>
<p>使用 Cocoa 现有的一些设计模式，是帮助开发者开发一款拥有合理设计思路、稳定的性能、良好的可扩展性应用的有效方法之一。这些模式都依赖于在 Objective-C 中定义的类。因为 Swift 与 Objective-C 的互用性，所以你依然可以在 Swift 代码中使用这些设计模式。在一些情况下，你甚至可以使用 Swift 语言的特性扩展或简化这些 Cocoa 设计模式，使这些设计模式更强大、更易于使用。</p>
<p><a name="Delegation"></a></p>
<h2 id="u59D4_u6258"><a href="#u59D4_u6258" class="headerlink" title="委托"></a>委托</h2><p>在 Swift 和 Objective-C 中，委托通常由一个定义交互方法和遵循规范的委托属性的协议表示。与 Objective-C 相比，当你在 Swift 中继承一个委托时，虽然继承模式不变，但是内部的实现已经改变了。就像在 Objective-C 中，在你向委托发送消息之前，不管它是不是 <code>nil</code> 你都会去查看，如果定义的方法是非必须实现的方法，不管委托有没有实现这个方法，你也都会去查看。而在 Swift 中，通过保持类型安全的特性，可以有效的消除这些繁琐、不必要的行为问题。</p>
<p>下面列出的代码可以说明这个过程：</p>
<ol>
<li>检查 <code>myDelegate</code> 不为 <code>nil</code>。</li>
<li>检查 <code>myDelegate</code> 是否实现了继承的 <code>window:willUseFullScreenContentSize:</code> 方法。</li>
<li>如果<code>myDelegate</code> 不为 <code>nil</code> 并且实现了 <code>window:willUseFullScreenContentSize:</code> 方法，那么调用该方法，将该方法的返回值分配给名为 <code>fullScreenSize</code> 的属性。</li>
<li>将该方法的返回值输出在控制台。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @inteface MyObject : NSObject</span></span><br><span class="line"><span class="comment">// @property (nonatomic, weak) id&lt;NSWindowDelegate&gt; delegate;</span></span><br><span class="line"><span class="comment">// @end</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> fullScreenSize = myDelegate?.window?(myWindow, willUseFullScreenContentSize: mySize) &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="type">NSStringFromSize</span>(fullScreenSize))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>在一个完全使用 Swift 编写的 app 中，在定义 <code>delegate</code> 属性时，它作为一个不定值的 <code>NSWindowDelegate</code> 对象，并将初始值设为 <code>nil</code>。</p>
</blockquote>
<h2 id="u9519_u8BEF_u5904_u7406"><a href="#u9519_u8BEF_u5904_u7406" class="headerlink" title="错误处理"></a>错误处理</h2><p>在 Cocoa 中，产生错误的方法将<code>NSError</code>指针参数作为最后一个参数，当错误产生时，该参数会被<code>NSError</code>对象填充。Swift 自动的将 Objective-C 中产生错误的方法转换为 Swift 的原生错误处理功能。</p>
<blockquote>
<p>注意</p>
<p>产生错误的方法，例如代理方法或者采用一个<code>NSError</code>对象作为参数的完成处理函数，不会被 Swift 处理为<code>throw</code>的方法。</p>
</blockquote>
<p>例如，考虑下面的来自于<code>NSFileManager</code>的 Objective-C 方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)removeItemAtURL:(NSURL *)URL&#10;                  error:(NSError **)error;</span><br></pre></td></tr></table></figure>
<p>在 Swift 中，它会被这样的导入：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">removeItemAtURL</span><span class="params">(URL: NSURL)</span></span> <span class="keyword">throws</span></span><br></pre></td></tr></table></figure>
<p>注意到<code>removeItemAtURL(_:)</code>方法被 Swift 导入时，返回值类型为 Void，没有错误参数，而是一个<code>throws</code>声明。</p>
<p>如果 Objective-C 方法的最后一个非闭包参数是<code>NSError **</code>类型，Swift 则会将之替换为<code>throws</code>关键字，以表明该方法可以抛出一个错误。如果 Objective-C 方法的错误参数也是它的第一个参数，Swift 则会尝试通过删除选择器的第一部分中的<code>AndReturnError</code>后缀来进一步简化方法的名称，如果存在的话。如果另一种方法是用所得选择器声明的，那么该方法名将不可改变。</p>
<p>如果产生错误的 Objective-C 的方法返回一个用来表示方法调用成功或失败的<code>BOOL</code>值，Swift 会把函数的返回值转换为<code>Void</code>。同样的，如果产生错误的 Objective-C 方法返回一个<code>nil</code>值来表明方法调用的失败，Swift 会把函数的返回值转换为非可选值类型。</p>
<p>否则，如果没有约定可以推断，该方法保持不变。</p>
<h3 id="u6355_u83B7_u548C_u5904_u7406_u9519_u8BEF"><a href="#u6355_u83B7_u548C_u5904_u7406_u9519_u8BEF" class="headerlink" title="捕获和处理错误"></a>捕获和处理错误</h3><p>在 Objective-C 中，错误处理是可选的，意味着方法产生的错误会被忽略除非你提供了一个错误指针。在 Swift 中，调用一个会抛出错误的方法要求显示的进行错误处理。</p>
<p>下面是如何在 Objective-C 中处理调用方法产生的错误：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSFileManager *fileManager = [NSFileManager defaultManager];&#10;NSURL *URL = [NSURL fileURLWithPath:@&#34;/path/to/file&#34;];&#10;NSError *error = nil;&#10;BOOL success = [fileManager removeItemAtURL:URL error:&#38;error];&#10;if (!success &#38;&#38; error) &#123;&#10;    NSLog(@&#34;Error: %@&#34;, error.domain);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>下面是 Swift 中等同的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fileManager = <span class="type">NSFileManager</span>.defaultManager()</span><br><span class="line"><span class="keyword">let</span> <span class="type">URL</span> = <span class="type">NSURL</span>.fileURLWithPath(<span class="string">"/path/to/file"</span>)</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> fileManager.removeItemAtURL(<span class="type">URL</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">NSError</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Error: <span class="subst">\(error.domain)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u629B_u51FA_u9519_u8BEF"><a href="#u629B_u51FA_u9519_u8BEF" class="headerlink" title="抛出错误"></a>抛出错误</h3><p>如果一个错误出现在了 Objective-C 方法中，那么该错误被用来填充方法的错误指针参数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// an error occurred</span></span><br><span class="line"><span class="keyword">if</span> (errorPtr) &#123;</span><br><span class="line">   *errorPtr = [<span class="type">NSError</span> errorWithDomain:<span class="type">NSURLErrorDomain</span></span><br><span class="line">                                   code:<span class="type">NSURLErrorCannotOpenFile</span></span><br><span class="line">                               userInfo:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个错误出现在了 Swift 方法中，那么该错误便会被抛出，并且会自动的传递给调用者：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// an error occurred</span></span><br><span class="line"><span class="keyword">throw</span> <span class="type">NSError</span>(domain: <span class="type">NSURLErrorDomain</span>, code: <span class="type">NSURLErrorCannotOpenFile</span>, userInfo: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>如果 Objective-C 代码调用 Swift 方法抛出了错误，那么该错误会被自动的传递给桥接的 Objective-C 方法的错误指针参数。</p>
<p>例如，考虑<code>NSDocument</code>中的<code>readFromFileWrapper(_:ofType:)</code>方法。在 Objective-C 中，这个方法的最后一个参数是<code>NSError **</code>。当在 Swift 的<code>NSDocument</code>的子类中重写该方法时，该方法会用<code>throws</code>替代错误指针参数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerializedDocument</span>: <span class="title">NSDocument</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">ErrorDomain</span> = <span class="string">"com.example.error.serialized-document"</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> representedObject: [<span class="type">String</span>: <span class="type">AnyObject</span>] = [:]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">readFromFileWrapper</span><span class="params">(fileWrapper: NSFileWrapper, ofType typeName: String)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> data = fileWrapper.regularFileContents <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">NSError</span>(domain: <span class="type">NSURLErrorDomain</span>, code: <span class="type">NSURLErrorCannotOpenFile</span>, userInfo: <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> <span class="type">JSON</span> <span class="keyword">as</span> [<span class="type">String</span>: <span class="type">AnyObject</span>] = <span class="keyword">try</span> <span class="type">NSJSONSerialization</span>.<span class="type">JSONObjectWithData</span>(data, options: []) &#123;</span><br><span class="line">            <span class="keyword">self</span>.representedObject = <span class="type">JSON</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">NSError</span>(domain: <span class="type">SerializedDocument</span>.<span class="type">ErrorDomain</span>, code: -<span class="number">1</span>, userInfo: <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果方法不能够使用常规的文件的内容来创建一个对象，则会抛出一个<code>NSError</code>对象。如果方法是从 Swift 代码中调用的，那么该错误会被传递到它的调用域。如果该方法是在 Objective-C 代码中被调用，错误将会传递到错误指针参数里。</p>
<p>在 Objective-C 中，错误处理是可选的，意味着方法产生的错误会被忽略除非你提供了一个错误指针。在 Swift 中，调用一个会抛出错误的方法要求显式的进行错误处理。</p>
<blockquote>
<p>注意</p>
<p>尽管 Swift 的错误处理类似 Objective-C 的异常处理，但它是完全独立的功能。如果一个 Objective-C 方法抛出了一个运行时异常，Swift 则会触发一个运行时错误。没有办法直接在 Swift 中恢复来自 Objective-C 的异常。任何在 Objective-C 代码中的异常处理行为必须用 Swift 来实现。</p>
</blockquote>
<p><a name="Key-Value_Observing"></a></p>
<p>##键值观察</p>
<p>键值观察是一种机制，该机制允许对象获得其他对象的特定属性的变化的通知。只要你的类继承自 NSObject 类，你便可在 Swift 类里使用键值观察。你可以在 Swift 中使用下面三步来实现键值观察：</p>
<ol>
<li>为你想要观察的属性添加动态修改符。关于<code>dynamic</code>更多信息，请见<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID57" target="_blank" rel="external">Requiring Dynamic Dispatch</a></li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObjectToObserve</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dynamic</span> <span class="keyword">var</span> myDate = <span class="type">NSDate</span>()</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">updateDate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        myDate = <span class="type">NSDate</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>创建一个全局上下文变量。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> myContext = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ol>
<li>为键-路径增加一个观察者，重写<code>observeValueForKeyPath:ofObject:change:context:</code>函数，并且在<code>deinit</code>中移除观察者。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObserver</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> objectToObserve = <span class="type">MyObjectToObserve</span>()</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        objectToObserve.addObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"myDate"</span>, options: .<span class="type">New</span>, context: &amp;myContext)</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">observeValueForKeyPath</span><span class="params">(keyPath: String?, ofObject object: AnyObject?, change: [NSObject : AnyObject]?, context: UnsafeMutablePointer&lt;Void&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> context == &amp;myContext &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> newValue = change?[<span class="type">NSKeyValueChangeNewKey</span>] &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Date changed: <span class="subst">\(newValue)</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.observeValueForKeyPath(keyPath, ofObject: object, change: change, context: context)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        objectToObserve.removeObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"myDate"</span>, context: &amp;myContext)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="Target_Action"></a></p>
<p>##Target-Action模式（Target-Action）##<br>当有特定事件发生，需要一个对象向另一个对象发送消息时，我们通常采用 Cocoa 的 Target-Action 设计模式。Swift 和 Objective-C 中的 Target-Action 模型基本类似。在 Swift 中，你可以使用 <code>Selector</code> 类型达到 Objective-C 中 selectors 的效果。请在 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID59" target="_blank" rel="external">Objective-C Selectors</a> 中查看在 Swift 中使用 Target-Action 设计模式的示例。</p>
<p><a name="Introspection"></a></p>
<p>##类型匹配与统一规范（Introspection）##<br>在 Objective-C 中，你可以使用 <code>isKindOfClass:</code> 方法检查某个对象是否是指定类型，可以使用 <code>conformsToProtocol:</code> 方法检查某个对象是否遵循特定协议的规范。在 Swift 中，你可以使用 <code>is</code> 运算符完成上述的功能，或者也可以使用 <code>as?</code> 向下匹配指定类型。</p>
<p>你可以使用 <code>is</code> 运算符检查一个实例是否是指定的子类。如果该实例是指定的子类，那么 <code>is</code> 运算结果为 <code>true</code>，反之为 <code>false</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> object <span class="keyword">is</span> <span class="type">UIButton</span> &#123;</span><br><span class="line">    <span class="comment">// object is of type UIButton</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// object is not of type UIButton</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以使用 <code>as?</code> 运算符尝试向下匹配子类型，<code>as?</code> 运算符返回不定值，结合 <code>if-let</code> 语句使用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> button = object <span class="keyword">as</span>? <span class="type">UIButton</span> &#123;</span><br><span class="line">    <span class="comment">// object is successfully cast to type UIButton and bound to button</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// object could not be cast to type UIButton</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请在 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TypeCasting.html#//apple_ref/doc/uid/TP40014097-CH22" target="_blank" rel="external">Type Casting</a> 中查看更多信息。</p>
<p>检查匹配协议的语法与检查匹配类的语法是一样的，下面是使用 <code>as?</code> 检查匹配协议的示例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> dataSource = object <span class="keyword">as</span>? <span class="type">UITableViewDataSource</span> &#123;</span><br><span class="line">    <span class="comment">// object conforms to UITableViewDataSource and is bound to dataSource</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// object not conform to UITableViewDataSource</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，当做完匹配之后，<code>dataSource</code> 会转换为  <code>UITableViewDataSource</code> 类型，所以你只能访问和调用<code>UITableViewDataSource</code> 协议定义的属性和方法。当你想进行其他操作时，必须将其转换为其他的类型。<br><br>可以在 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25" target="_blank" rel="external">Protocols</a> 查看更多相关信息。</p>
<p><a name="API_Availability"></a></p>
<h2 id="API__u53EF_u7528_u6027"><a href="#API__u53EF_u7528_u6027" class="headerlink" title="API 可用性"></a>API 可用性</h2><p>一些类和方法并不是在你的应用所有平台的所有版本都可用。为了确保你的应用功能上能够适应差异，你需要检查这些 API 的可用性。</p>
<p>在 Objective-C 中，我们使用<code>respondsToSelector:</code>和<code>instancesRespondToSelector:</code>方法来检查一个类或者实例方法是否可用。如果没有检查，调用方法则会抛出<code>NSInvalidArgumentException</code>“unrecognized selector sent to instance”异常。例如，<code>requestWhenInUseAuthorization</code>方法只在 iOS8.0 和 OS X 10.10 中对<code>CLLocationManager</code>实例可用。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if ([CLLocationManager instancesRespondToSelector:@selector(requestWhenInUseAuthorization)]) &#123;&#10;  // &#26041;&#27861;&#21487;&#29992;&#10;&#125; else &#123;&#10;  // &#26041;&#27861;&#19981;&#21487;&#29992;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在 Swift 中，尝试着调用一个目标平台版本不支持的方法将会报出编译时错误。</p>
<p>下面是上一个例子，采用 Swift 编写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> locationManager = <span class="type">CLLocationManager</span>()</span><br><span class="line">locationManager.requestWhenInUseAuthorization()</span><br><span class="line"><span class="comment">// error: only available on iOS 8.0 or newer</span></span><br></pre></td></tr></table></figure>
<p>如果应用的目标低于 ios8.0 或者 OSX10.10，<code>requestWhenInUseAuthorization()</code>方法则不可用，所以编译器会报告错误。</p>
<p>Swift 代码可以使用 API 可用性来作为运行时的条件判断。可用性检查可以使用在一个控制流语句的条件中，例如<code>if</code>,<code>guard</code>或者<code>while</code>语句。</p>
<p>拿前面的例子举例，你可以使用<code>if</code>语句来检查可用性，只有当方法在运行时可用时方可调用<code>requestWhenInUseAuthorization()</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> locationManager = <span class="type">CLLocationManager</span>()</span><br><span class="line"><span class="keyword">if</span> #available(iOS <span class="number">8.0</span>, <span class="type">OSX</span> <span class="number">10.10</span>, *) &#123;</span><br><span class="line">    locationManager.requestWhenInUseAuthorization()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者，你可以使用<code>guard</code>语句来检查可用性，除非当前的目标符合规定要求，否则将会退出作用域。这种方法简化了处理不同平台功能的逻辑。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> locationManager = <span class="type">CLLocationManager</span>()</span><br><span class="line"><span class="keyword">guard</span> #available(iOS <span class="number">8.0</span>, <span class="type">OSX</span> <span class="number">10.10</span>, *) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">locationManager.requestWhenInUseAuthorization()</span><br></pre></td></tr></table></figure>
<p>每个平台参数包括下面列出的平台名称，后面跟着相应的版本号。最后一个参数是一个星号（*），是用来处理未来潜在的平台。</p>
<p>平台名称：</p>
<ul>
<li>iOS</li>
<li>iOSApplicationExtension</li>
<li>OSX</li>
<li>OSXApplicationExtension</li>
<li>watchOS</li>
</ul>
<p>所有的 Cocoa API 都提供有可用性信息，所以你可以很自信的编写应用所针对的平台的代码。</p>
<p>你可以通过 @available 属性来标注声明从而简化你的 API 的可用性检查。@available 属性使用和 #available 同样的语法来做运行时检查，参数都以逗号隔开平台版本需求。</p>
<p>例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">@available</span>(iOS <span class="number">8.0</span>, <span class="type">OSX</span> <span class="number">10.10</span>, *)</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">useShinyNewFeature</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p>使用 @available 属性标记的方法可以安全的使用满足特定平台需求的可用 API 而不用显式的做可用性检查。</p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/05Interacting with C APIs/" itemprop="url">
                02Interoperability-05与 C 的 API 交互
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-26T22:00:06+08:00" content="2015-12-26">
            2015-12-26
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Using-Swift-with-Cocoa-and-Objective-C/" itemprop="url" rel="index">
                  <span itemprop="name">Using-Swift-with-Cocoa-and-Objective-C</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/05Interacting with C APIs/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/05Interacting with C APIs/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><blockquote>
<p>翻译：<a href="https://github.com/shockinglee" target="_blank" rel="external">shockinglee</a></p>
<p>校对：<a href="https://github.com/shanyimin" target="_blank" rel="external">shanyimin</a> <a href="https://github.com/dabing1022" target="_blank" rel="external">ChildhoodAndy</a> <a href="https://github.com/Phenmod" target="_blank" rel="external">Phenmod</a></p>
</blockquote>
<h1 id="u4E0E_C__u7684_API__u4EA4_u4E92"><a href="#u4E0E_C__u7684_API__u4EA4_u4E92" class="headerlink" title="与 C 的 API 交互"></a>与 C 的 API 交互</h1><hr>
<p>本节包含内容：</p>
<ul>
<li><a href="/#primitive_types">基本数据类型（Primitive Types）</a></li>
<li><a href="/#enumerations">枚举（Enumerations）</a></li>
<li><a href="/#pointer">指针（Pointer）</a></li>
<li><a href="/#global_constants">全局常量（Global Constants）</a></li>
<li><a href="/#preprocessor_directives">预处理指令（Preprocessor Directives）</a></li>
</ul>
<p>作为与Objective-C语言的互用性的一部分，Swift也对一些C语言的类型和特性保持了兼容性。如果你的代码有需要，Swift也提供了一些方式来使用常见的C结构和模式。</p>
<h2 id="u57FA_u672C_u6570_u636E_u7C7B_u578B"><a href="#u57FA_u672C_u6570_u636E_u7C7B_u578B" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>Swift提供了一些与C语言基本类型如<code>char</code>,<code>int</code>,<code>float</code>和<code>double</code>等的对应类型。然而，这些类型和Swift核心基本类型之间不能进行隐式转换，如Int。因此，只有你的代码明确要求时才使用这些类型，其它任何可能的情况下都应该使用Int。</p>
<table>
<thead>
<tr>
<th>C 类型</th>
<th>Swift 类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>bool</td>
<td>CBool</td>
</tr>
<tr>
<td>char, signed char</td>
<td>CChar</td>
</tr>
<tr>
<td>unsigned char</td>
<td>CUnsignedChar</td>
</tr>
<tr>
<td>short</td>
<td>CShort</td>
</tr>
<tr>
<td>unsigned short</td>
<td>CUnsignedShort</td>
</tr>
<tr>
<td>int</td>
<td>CInt</td>
</tr>
<tr>
<td>unsigned int</td>
<td>CUnsignedInt</td>
</tr>
<tr>
<td>long</td>
<td>CLong</td>
</tr>
<tr>
<td>unsigned long</td>
<td>CUnsignedLong</td>
</tr>
<tr>
<td>long long</td>
<td>CLongLong</td>
</tr>
<tr>
<td>unsigned long long</td>
<td>CUnsignedLongLong</td>
</tr>
<tr>
<td>wchar_t</td>
<td>CWideChar</td>
</tr>
<tr>
<td>char16_t</td>
<td>CChar16</td>
</tr>
<tr>
<td>char32_t</td>
<td>CChar32</td>
</tr>
<tr>
<td>float</td>
<td>CFloat</td>
</tr>
<tr>
<td>double</td>
<td>CDouble</td>
</tr>
</tbody>
</table>
<h2 id="u679A_u4E3E"><a href="#u679A_u4E3E" class="headerlink" title="枚举"></a>枚举</h2><p>任何用宏<code>NS_ENUM</code>来声明的C风格的枚举，都会被Swfit导入为一个Swfit枚举类型。无论枚举值是在系统框架还是在自己的代码中定义的，当它们导入到Swift时，它们的前缀名将被截掉。</p>
<p>例如，看这个Objective-C枚举的声明：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Objective-C</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UITableViewCellStyle</span>) &#123;</span><br><span class="line">    <span class="built_in">UITableViewCellStyleDefault</span>,</span><br><span class="line">    <span class="built_in">UITableViewCellStyleValue1</span>,</span><br><span class="line">    <span class="built_in">UITableViewCellStyleValue2</span>,</span><br><span class="line">    <span class="built_in">UITableViewCellStyleSubtitle</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在Swift中，会被导入为这样：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//Swift</span><br><span class="line"><span class="keyword">enum</span> UITableViewCellStyle: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">Default</span></span><br><span class="line">    <span class="keyword">case</span> Value1</span><br><span class="line">    <span class="keyword">case</span> Value2</span><br><span class="line">    <span class="keyword">case</span> Subtitle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你需要使用一个枚举值时，使用以点（.）开头的枚举名称：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="keyword">let</span> cellStyle: UITableViewCellStyle = .<span class="built_in">Default</span></span><br></pre></td></tr></table></figure>
<h2 id="u9009_u9879_u96C6"><a href="#u9009_u9879_u96C6" class="headerlink" title="选项集"></a>选项集</h2><p>对使用宏<code>NS_OPTIONS</code>声明的C风格的枚举，Swift会把它导入为一个Swfit选项集类型。选项集像枚举一样，会把前缀截掉，只剩下选项值名称。</p>
<p>例如，看这个Objective-C选项的声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Objective-C</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NS_OPTIONS</span><span class="params">(NSUInteger, NSJSONReadingOptions)</span> </span>&#123;</span><br><span class="line">	NSJSONReadingMutableContainers = (<span class="number">1U</span>L &lt;&lt; <span class="number">0</span>),</span><br><span class="line">	NSJSONReadingMutableLeaves = (<span class="number">1U</span>L &lt;&lt; <span class="number">1</span>),</span><br><span class="line">	NSJSONReadingAllowFragments = (<span class="number">1U</span>L &lt;&lt; <span class="number">2</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在Swift中，它被导入为这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NSJSONReadingOptions</span> : <span class="title">OptionSetType</span> </span>&#123;</span><br><span class="line">	<span class="keyword">init</span>(rawValue: <span class="type">UInt</span>)</span><br><span class="line">   </span><br><span class="line">   	<span class="keyword">static</span> <span class="keyword">var</span> <span class="type">MutableContainers</span>: <span class="type">NSJSONReadingOptions</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">   	<span class="keyword">static</span> <span class="keyword">var</span> <span class="type">MutableLeaves</span>: <span class="type">NSJSONReadingOptions</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">   	<span class="keyword">static</span> <span class="keyword">var</span> <span class="type">AllowFragments</span>: <span class="type">NSJSONReadingOptions</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在Objective-C中，一个选项集是整数值的一个位掩码。你可以使用按位或操作符（<code>|</code>）来组合选项值，使用按位与操作符（<code>&amp;</code>）以检测选项值。创建一个选项集，可以使用常量值或者表达式。一个空的选项集使用常数<code>0</code>来表示。</p>
<p>在Swift中，选项集使用一个遵循<code>OptionSetType</code>协议的结构体来表示，其中每个选项值都是一个静态变量。选项集类似于Swift的集合类型<code>Set</code>，你可以用<code>insert(_:)</code>或者<code>unionInPlace(_:)</code>方法来添加选项值，用<code>remove(_:)</code>或者<code>subtractInPlace(_:)</code>方法来删除选项值，用<code>contains(_:)</code>方法来检测选项值。创建一个选项集的值可以使用一个数组字面量，里面的选项值像枚举一样都用点（<code>.</code>）开头。创建一个空的选项集可以使用一个空的数组字面量，也可以调用默认初始化函数。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line">let options: NSDataBase64EncodingOptions = [</span><br><span class="line">	<span class="class">.Encoding76CharacterLineLength</span>,</span><br><span class="line">   	<span class="class">.EncodingEndLineWithLineFeed</span></span><br><span class="line">   ]</span><br><span class="line">let string = data.<span class="function"><span class="title">base64EncodedStringWithOptions</span><span class="params">(options)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="u5171_u7528_u4F53"><a href="#u5171_u7528_u4F53" class="headerlink" title="共用体"></a>共用体</h2><p>Swift仅部分支持C的共用体（union）类型。在导入混有C的共用体或者位段（bitfields）的类型时，例如Foundation的<code>NSDecimal</code>类型，Swift不能存取不支持的字段。但是，参数和/或返回值为这些类型的C和Objective-C的API是能够在Swift中使用的。</p>
<h2 id="u6307_u9488"><a href="#u6307_u9488" class="headerlink" title="指针"></a>指针</h2><p>Swift尽可能避免让您直接访问指针。然而，当您需要直接操作内存的时候，Swift也为您提供了多种指针类型。下面的表使用<code>Type</code>作为类型名称的占位符。</p>
<p>对于返回类型，变量和参数，使用如下形式：</p>
<table>
<thead>
<tr>
<th>C 句法</th>
<th>Swift 句法</th>
</tr>
</thead>
<tbody>
<tr>
<td>const Type *</td>
<td>UnsafePointer\<type\></type\></td>
</tr>
<tr>
<td>Type *</td>
<td>UnsafeMutablePointer\<type\></type\></td>
</tr>
</tbody>
</table>
<p>对于类（class）类型，使用如下形式：</p>
<table>
<thead>
<tr>
<th>C 句法</th>
<th>Swift 句法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Type <em> const </em></td>
<td>UnsafePointer\<type\></type\></td>
</tr>
<tr>
<td>Type <em> __strong </em></td>
<td>UnsafeMutablePointer\<type\></type\></td>
</tr>
<tr>
<td>Type **</td>
<td>AutoreleasingUnsafeMutablePointer\<type\></type\></td>
</tr>
</tbody>
</table>
<h3 id="u5E38_u91CF_u6307_u9488"><a href="#u5E38_u91CF_u6307_u9488" class="headerlink" title="常量指针"></a>常量指针</h3><p>当一个函数被声明为接受<code>UnsafePointer&lt;Type&gt;</code>参数时，这个函数可以接受下列任何一个类型作为参数：</p>
<ul>
<li><code>nil</code>，作为空指针传入；</li>
<li>一个<code>UnsafePointer&lt;Type&gt;</code>，<code>UnsafeMutablePointer&lt;Type&gt;</code>， 或者<code>AutoreleasingUnsafeMutablePointer&lt;Type&gt;</code>的值，在必要情况下会转换成<code>UnsafePointer&lt;Type&gt;</code>的值；</li>
<li>一个<code>String</code>类型的值，如果<code>Type</code>是<code>Int8</code>或者<code>UInt8</code>的话。该字符串会自动在一个缓冲区内被转换为UTF8，该缓冲区在本次调用期间有效；</li>
<li>一个左值操作数为<code>Type</code>类型的输入输出（inout）表达式，传入的是这个左值的内存地址；</li>
<li>一个<code>[Type]</code>值，传入该数组的起始指针，并且它的生命周期将在本次调用期间被延长。</li>
</ul>
<p>如果您这样定义了一个函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesAPointer</span><span class="params">(x: UnsafePointer&lt;Float&gt;)</span></span> &#123; <span class="comment">/*...*/</span> &#125;</span><br></pre></td></tr></table></figure>
<p>那么您可以使用以下任何一种方式来调用这个函数：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//Swift</span></span><br><span class="line">   <span class="tag">var</span> x: Float = <span class="number">0.0</span></span><br><span class="line"><span class="tag">var</span> <span class="tag">p</span>: UnsafePointer&lt;Float&gt; = nil</span><br><span class="line"><span class="function"><span class="title">takesAPointer</span><span class="params">(nil)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAPointer</span><span class="params">(p)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAPointer</span><span class="params">(&amp;x)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAPointer</span><span class="params">([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>])</span></span></span><br></pre></td></tr></table></figure>
<p>如果函数被声明为使用一个<code>UnsafePointer&lt;Void&gt;</code>参数，那么这个函数接受任何<code>Type</code>的<code>UnsafePointer&lt;Type&gt;</code>类型的操作数。<br>￼<br>如果您这样定义了一个函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesAVoidPointer</span><span class="params">(x: UnsafePointer&lt;Void&gt;)</span></span>  &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>那么您可以使用以下任何一种方式来调用这个函数：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//Swift</span></span><br><span class="line">   <span class="tag">var</span> x: Float = <span class="number">0.0</span>, y: Int = <span class="number">0</span></span><br><span class="line"><span class="tag">var</span> <span class="tag">p</span>: UnsafePointer&lt;Float&gt; = nil, <span class="tag">q</span>: UnsafePointer&lt;Int&gt; = nil</span><br><span class="line"><span class="function"><span class="title">takesAVoidPointer</span><span class="params">(nil)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAVoidPointer</span><span class="params">(p)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAVoidPointer</span><span class="params">(q)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAVoidPointer</span><span class="params">(&amp;x)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAVoidPointer</span><span class="params">(&amp;y)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAVoidPointer</span><span class="params">([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>] as [Float])</span></span></span><br><span class="line">let intArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="function"><span class="title">takesAVoidPointer</span><span class="params">(intArray)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="u53EF_u53D8_u6307_u9488"><a href="#u53EF_u53D8_u6307_u9488" class="headerlink" title="可变指针"></a>可变指针</h3><p>当一个方法被声明为接受<code>UnsafeMutablePointer&lt;Type&gt;</code>参数时，这个函数可以接受下列任何一个类型作为参数：</p>
<ul>
<li><code>nil</code>，作为空指针传入；</li>
<li>一个<code>UnsafeMutablePointer&lt;Type&gt;</code>类型的值；</li>
<li>一个输入输出（inout）表达式，其左值操作数是<code>Type</code>类型的，且被存储起来了。传入的是这个左值的内存地址；</li>
<li>一个输入输出的<code>[Type]</code>类型的值，传入的是该数组的起始指针，并且它的生命周期将在本次调用期间被延长。</li>
</ul>
<p>如果您这样定义了一个函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesAMutablePointer</span><span class="params">(x: UnsafeMutablePointer&lt;Float&gt;)</span></span> &#123; <span class="comment">/*...*/</span> &#125;</span><br></pre></td></tr></table></figure>
<p>那么您可以使用以下任何一种方式来调用这个函数：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//Swift</span></span><br><span class="line">   <span class="tag">var</span> x: Float = <span class="number">0.0</span></span><br><span class="line"><span class="tag">var</span> <span class="tag">p</span>: UnsafeMutablePointer&lt;Float&gt; = nil</span><br><span class="line"><span class="tag">var</span> <span class="tag">a</span>: [Float] = [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>]</span><br><span class="line"><span class="function"><span class="title">takesAMutablePointer</span><span class="params">(nil)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAMutablePointer</span><span class="params">(p)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAMutablePointer</span><span class="params">(&amp;x)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAMutablePointer</span><span class="params">(&amp;a)</span></span></span><br></pre></td></tr></table></figure>
<p>如果函数被声明使用一个<code>UnsafeMutablePointer&lt;Void&gt;</code>参数，那么这个函数接受任何<code>Type</code>的<code>UnsafeMutablePointer&lt;Type&gt;</code>类型的操作数。</p>
<p>如果您这样定义了一个函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesAMutableVoidPointer</span><span class="params">(x: UnsafeMutablePointer&lt;Void&gt;)</span></span>  &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>那么您可以使用以下任何一种方式来调用这个函数：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//Swift</span></span><br><span class="line">   <span class="tag">var</span> x: Float = <span class="number">0.0</span>, y: Int = <span class="number">0</span></span><br><span class="line"><span class="tag">var</span> <span class="tag">p</span>: UnsafeMutablePointer&lt;Float&gt; = nil, <span class="tag">q</span>: UnsafeMutablePointer&lt;Int&gt; = nil</span><br><span class="line"><span class="tag">var</span> <span class="tag">a</span>: [Float] = [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>], <span class="tag">b</span>: [Int] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="function"><span class="title">takesAMutableVoidPointer</span><span class="params">(nil)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAMutableVoidPointer</span><span class="params">(p)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAMutableVoidPointer</span><span class="params">(q)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAMutableVoidPointer</span><span class="params">(&amp;x)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAMutableVoidPointer</span><span class="params">(&amp;y)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAMutableVoidPointer</span><span class="params">(&amp;a)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAMutableVoidPointer</span><span class="params">(&amp;b)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="u81EA_u52A8_u91CA_u653E_u6307_u9488"><a href="#u81EA_u52A8_u91CA_u653E_u6307_u9488" class="headerlink" title="自动释放指针"></a>自动释放指针</h3><p>当一个函数被声明为接受<code>AutoreleasingUnsafeMutablePointer&lt;Type&gt;</code>参数时，这个函数可以接受下列任何一个类型作为参数：</p>
<ul>
<li><code>nil</code>，作为空指针传入；</li>
<li>一个<code>AutoreleasingUnsafeMutablePointer&lt;Type&gt;</code>类型的值；</li>
<li>一个输入输出（inout）表达式，其操作数首先被拷贝到一个无拥有者的缓冲区，传递给被调用函数的就是这个缓冲区的地址。在调用返回时，缓冲区中的值被加载、保存、并重新复制给操作数。</li>
</ul>
<p>注意，这个列表中没有包含数组。</p>
<p>如果您这样定义了一个函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesAnAutoreleasingPointer</span><span class="params">(x: AutoreleasingUnsafeMutablePointer&lt;NSDate?&gt;)</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>那么您可以使用以下任何一种方式来调用这个函数：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//Swift</span></span><br><span class="line">   <span class="keyword">var</span> x: NSDate? = <span class="keyword">nil</span></span><br><span class="line"><span class="keyword">var</span> p: AutoreleasingUnsafeMutablePointer&lt;NSDate?&gt; = <span class="keyword">nil</span></span><br><span class="line">takesAnAutoreleasingPointer(<span class="keyword">nil</span>)</span><br><span class="line">takesAnAutoreleasingPointer(p)</span><br><span class="line">takesAnAutoreleasingPointer(&amp;x)</span><br></pre></td></tr></table></figure>
<p>被指针指向的类型并不会被桥接。例如，<code>NSString **</code>转换到Swift后，是<code>AutoreleasingUnsafeMutablePointer&lt;NSString?&gt;</code>，而不是<code>AutoreleasingUnsafeMutablePointer&lt;String?&gt;</code>。</p>
<h3 id="u51FD_u6570_u6307_u9488"><a href="#u51FD_u6570_u6307_u9488" class="headerlink" title="函数指针"></a>函数指针</h3><p>C语言的函数指针通过调用约定，以闭包的形式被引入Swift中，表示形式为<code>@convention(c)</code>。例如，一个类型为<code>int (*)(void)</code>的C语言函数指针，会转换为Swift的<code>@convention(c) () -&gt; Int32</code>。</p>
<p>在调用一个以函数指针为参数的函数时，给它传的值可以是一个顶层的Swift函数，也可以是个闭包字面量，或者<code>nil</code>。只有符合C语言函数指针调用约定的Swift函数，才能用来给函数指针类型的形参传值。例如，Core Foundation的<code>CFArrayCreateMutable(_:_:_:)</code>函数，它有个参数的类型为<code>CFArrayCallBacks</code>结构体。这个<code>CFArrayCallBacks</code>结构体就是用一些函数指针进行初始化的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">customCopyDescription</span><span class="params">(p: UnsafePointer&lt;Void&gt;)</span></span> -&gt; <span class="type">Unmanaged</span>&lt;<span class="type">CFString</span>&gt;! &#123;</span><br><span class="line">   	<span class="comment">// return an Unmanaged&lt;CFString&gt;! value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> callbacks = <span class="type">CFArrayCallBacks</span>(</span><br><span class="line">   	version: <span class="number">0</span> <span class="keyword">as</span> <span class="type">CFIndex</span>,</span><br><span class="line">   	retain: <span class="literal">nil</span>,</span><br><span class="line">   	release: <span class="literal">nil</span>,</span><br><span class="line">   	copyDescription: customCopyDescription,</span><br><span class="line">   	<span class="built_in">equal</span>: &#123; (p1, p2) -&gt; <span class="type">Boolean</span> <span class="keyword">in</span></span><br><span class="line">       	<span class="comment">// return Boolean value</span></span><br><span class="line">   	&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mutableArray = <span class="type">CFArrayCreateMutable</span>(<span class="literal">nil</span>, <span class="number">0</span>, callbacks)</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，在<code>CFArrayCallBacks</code>初始化时，传给<code>retain</code>和<code>release</code>作参数的是<code>nil</code>，传给<code>copyDescription</code>作参数的是函数<code>customCopyDescription</code>，传给<code>equal</code>作参数的是一个闭包字面量。</p>
<h2 id="u5168_u5C40_u5E38_u91CF"><a href="#u5168_u5C40_u5E38_u91CF" class="headerlink" title="全局常量"></a>全局常量</h2><p>在C和Objective-C语言源文件中定义的全局常量会自动地被Swift编译引进并做为Swift的全局常量。</p>
<h2 id="u9884_u5904_u7406_u6307_u4EE4"><a href="#u9884_u5904_u7406_u6307_u4EE4" class="headerlink" title="预处理指令"></a>预处理指令</h2><p>Swift编译器不包含预处理器。取而代之的是，它充分利用了编译时属性，生成配置，和语言特性来完成相同的功能。因此，Swift没有引进预处理指令。</p>
<h3 id="u7B80_u5355_u5B8F"><a href="#u7B80_u5355_u5B8F" class="headerlink" title="简单宏"></a>简单宏</h3><p>在C和Objective-C中，通常使用<code>#define</code>指令来定义一个简单的常数，在Swift，您可以使用全局常量来代替。例如：定义一个常数的<code>#define FADE_ANIMATION_DURATION 0.35</code>，在Swift使用<code>let FADE_ANIMATION_DURATION = 0.35</code>来表述会更好一些。由于简单的用于定义常量的宏会被直接被映射成Swift全局量，Swift编译器会自动引进在C或Objective-C源文件中定义的简单宏。</p>
<h3 id="u590D_u6742_u5B8F"><a href="#u590D_u6742_u5B8F" class="headerlink" title="复杂宏"></a>复杂宏</h3><p>在C和Objective-C中使用的复杂宏在Swift中没有相对应的东西。复杂宏是那些不用来定义常量的宏，包含了括号的函数式宏。您在C和Objective-C使用复杂的宏以避免类型检查的限制或避免重新键入大量的样板代码。然而，宏也会造成debug和重构起来更困难。在Swift中你可以使用函数和泛型来达到同样的效果，而没有任何的委屈折中。因此，在C和Objective-C源文件中定义的复杂宏在Swift是不能使用的。</p>
<h3 id="u751F_u6210_u914D_u7F6E"><a href="#u751F_u6210_u914D_u7F6E" class="headerlink" title="生成配置"></a>生成配置</h3><p>Swift代码使用和C、Objective-C代码不同的方式进行条件编译。Swift代码可以根据生成配置的组合进行条件编译。生成配置包括<code>true</code>和<code>false</code>字面值，命令行标志，和下表中的平台测试函数。您可以使用<code>-D &lt;＃Flag＃&gt;</code>指定命令行标志。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>有效参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>os()</td>
<td>OSX，iOS，watchOS</td>
</tr>
<tr>
<td>arch()</td>
<td>x86_64，arm，arm64，i386</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意：生成配置<code>arch(arm)</code>不会为64位ARM设备返回<code>true</code>，生成配置<code>arch(i386)</code>在为32位iOS模拟器编译代码时会返回<code>true</code>。</p>
</blockquote>
<p>一个简单的条件编译可以像下面这段代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">if</span> build configuration</span></span><br><span class="line">  statements</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">  statements</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>由零个或多个有效的Swift语句组成的<em>statements</em>，可以包括表达式，普通语句和控制流语句。可以使用<code>&amp;&amp;</code>和<code>||</code>操作符往一个条件编译语句上添加新的编译条件，使用<code>!</code>操作符来否定某条件，使用<code>#elseif</code>来添加编译块：</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">if</span> build configuration &amp;&amp; !build configuration</span></span><br><span class="line">  statements<span class="preprocessor"></span><br><span class="line">#<span class="keyword">elseif</span> build configuration</span></span><br><span class="line">  statements<span class="preprocessor"></span><br><span class="line">#<span class="keyword">else</span></span></span><br><span class="line">  statements<span class="preprocessor"></span><br><span class="line">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>与C语言编译器的条件编译不同的是，Swift条件编译的语句必须是独立完整、语法有效的代码块。这是因为所有的Swift代码都会做语法检查，而不管会不会被编译。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/03Mix and Match/Swift and Objective-C in the Same Project/" itemprop="url">
                03Mix and Match-01Mix and Match 概述（Mix and Match Overview
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-26T22:00:05+08:00" content="2015-12-26">
            2015-12-26
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Using-Swift-with-Cocoa-and-Objective-C/" itemprop="url" rel="index">
                  <span itemprop="name">Using-Swift-with-Cocoa-and-Objective-C</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/03Mix and Match/Swift and Objective-C in the Same Project/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/03Mix and Match/Swift and Objective-C in the Same Project/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><blockquote>
<p>翻译：<a href="https://github.com/haolloyin" target="_blank" rel="external">haolloyin</a></p>
<p>校对：<a href="https://github.com/dabing1022" target="_blank" rel="external">ChildhoodAndy</a></p>
</blockquote>
<h1 id="u5728_u540C_u4E2A_u5DE5_u7A0B_u4E2D_u4F7F_u7528_Swift__u548C_Objective-C"><a href="#u5728_u540C_u4E2A_u5DE5_u7A0B_u4E2D_u4F7F_u7528_Swift__u548C_Objective-C" class="headerlink" title="在同个工程中使用 Swift 和 Objective-C"></a>在同个工程中使用 Swift 和 Objective-C</h1><hr>
<p>本节包含内容：</p>
<ul>
<li><a href="/#mix_and_match_overview">Mix and Match 概述（Mix and Match Overview）</a></li>
<li><a href="/#importing_code_from_within_the_same_app_target">在同个应用的 target 中导入（Importing Code from Within the Same App Target）</a></li>
<li><a href="/#importing_code_from_within_the_same_framework_target">在同个 Framework 的 target 中导入（Importing Code from Within the Same Framework Target）</a></li>
<li><a href="/#importing_external_frameworks">导入外部 framework（Importing External Frameworks）</a></li>
<li><a href="/#using_swift_from_objective-c">在 Objective-C 中使用 Swift（Using Swift from Objective-C）</a></li>
<li><a href="/#overriding_swift_names_for_Objective">为 Objective-C 接口重写 Swift 名称</a></li>
<li><a href="/#naming_your_product_module">Product 模块命名（Naming Your Product Module）</a></li>
<li><a href="/#troubleshooting_tips_and_reminders">问题解决提示（Troubleshooting Tips and Reminders）</a></li>
</ul>
<p>Swift 与 Objective-C 的兼容能力使你可以在同一个工程中同时使用两种语言。你可以用这种叫做 <code>mix and match</code> 的特性来开发基于混合语言的应用，可以用 Swift 的最新特性实现应用的一部分功能，并无缝地并入已有的 Objective-C 的代码中。</p>
<p><a name="mix_and_match_overview"></a></p>
<h2 id="Mix_and_Match__u6982_u8FF0"><a href="#Mix_and_Match__u6982_u8FF0" class="headerlink" title="Mix and Match 概述"></a>Mix and Match 概述</h2><p>Objective-C 和 Swift 文件可以在一个工程中并存，不管这个工程原本是基于 Objective-C 还是 Swift。你可以直接往现有工程中简单地添加另一种语言的源文件。这种自然的工作流使得创建混合语言的应用或框架 target，与用单独一种语言时一样简单。</p>
<p>混合语言的工作流程只有一点点区别，这取决于你是在写应用还是写框架。下面描述了普通的用两种语言在一个 target 中导入模型的情况，后续章节会有更多细节。</p>
<p><img src="http://7xp6cn.com1.z0.glb.clouddn.com/DAG_2x.png" alt="DAG_2x.png"></p>
<p><a name="importing_code_from_within_the_same_app_target"></a></p>
<h2 id="u5728_u540C_u4E2A_u5E94_u7528_u7684_target__u4E2D_u5BFC_u5165"><a href="#u5728_u540C_u4E2A_u5E94_u7528_u7684_target__u4E2D_u5BFC_u5165" class="headerlink" title="在同个应用的 target 中导入"></a>在同个应用的 target 中导入</h2><p>如果你在写混合语言的应用，可能需要用 Swift 代码访问 Objective-C 代码，或者反之。下面的流程描述了在非框架 target 中的应用。</p>
<h3 id="u5C06_Objective-C__u5BFC_u5165_Swift"><a href="#u5C06_Objective-C__u5BFC_u5165_Swift" class="headerlink" title="将 Objective-C 导入 Swift"></a>将 Objective-C 导入 Swift</h3><p>在一个应用的 target 中导入一些 Objective-C 文件供 Swift 代码使用时，你需要依赖于 Objective-C 的桥接头文件（<code>bridging header</code>）来暴露给 Swift。当你添加 Swift 文件到现有的 Objective-C 应用（或反之）时，Xcode 会自动创建这些头文件。</p>
<p><img src="http://7xp6cn.com1.z0.glb.clouddn.com/bridgingheader_2x.png" alt="bridgingheader_2x.png"></p>
<p>如果你同意，Xcode 会在源文件创建的同时生成头文件，并用 product 的模块名加上 <code>-Bridging-Header.h</code> 命名。关于 product 的模块名，详见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_85" target="_blank" rel="external">Naming Your Product Module</a>。</p>
<p>你应该编辑这个头文件来对 Swift 暴露出 Objective-C 代码。</p>
<h4 id="u5728_u540C_u4E00_target__u4E2D_u5C06_Objective-C__u4EE3_u7801_u5BFC_u5165_u5230_Swift__u4E2D"><a href="#u5728_u540C_u4E00_target__u4E2D_u5C06_Objective-C__u4EE3_u7801_u5BFC_u5165_u5230_Swift__u4E2D" class="headerlink" title="在同一 target 中将 Objective-C 代码导入到 Swift 中"></a>在同一 target 中将 Objective-C 代码导入到 Swift 中</h4><ol>
<li>在 Objective-C 桥接头文件中，<code>import</code>任何你想暴露给 Swift 的头文件，例如：</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &#34;XYZCustomCell.h&#34;&#10;#import &#34;XYZCustomView.h&#34;&#10;#import &#34;XYZCustomViewController.h&#34;</span><br></pre></td></tr></table></figure>
<ol>
<li>确保在 <code>Build Settings</code> 中 Objective-C 桥接头文件的 <code>build setting</code> 是基于 Swfit 编译器，即 <code>Code Generation</code> 含有头文件的路径。这个路径必须是头文件自身的路径，而不是它所在的目录。</li>
</ol>
<p>这个路径应该是你工程的相对路径，类似 <code>Info.plist</code> 在 <code>Build Settings</code> 中指定的路径。在大多数情况下，你不需要修改这个设置。</p>
<p>在这个桥接头文件中列出的所有 public 的 Objective-C 头文件都会对 Swift 可见。之后当前 target 的所有 Swift 文件都可以使用这些头文件中的方法，不需要任何 import 语句。用 Swift 语法使用这些 Objective-C 代码，就像使用系统自带的 Swift 类一样。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myCell = <span class="type">XYZCustomCell</span>()</span><br><span class="line">myCell.subtitle = <span class="string">"A custom cell"</span></span><br></pre></td></tr></table></figure>
<h3 id="u5C06_Swift__u5BFC_u5165_u5230_Objective-C"><a href="#u5C06_Swift__u5BFC_u5165_u5230_Objective-C" class="headerlink" title="将 Swift 导入到 Objective-C"></a>将 Swift 导入到 Objective-C</h3><p>当你在将 Swift 代码导入到 Objective-C 中时，你依赖于 Xcode 生成的头文件来将这些文件暴漏给 Objective-C。这个自动生成的文件是一个 Objective-C 头文件，它包含了你的 target 中所有 Swift 代码中定义的接口。可以把这个 Objective-C 头文件看作 Swift 代码的 <code>umbrella header</code>。头文件名称以 product 模块名加 <code>-Swift.h</code> 来命名。（关于 product 的模块名，详见<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_85" target="_blank" rel="external">Naming Your Product Module</a>）。</p>
<p>默认情况下，生成的头文件包含了标记有<code>public</code>修饰符的 Swift 声明接口。它还包含那些打上，如果您的应用程序的目标有一个Objective-C的桥接头内部修改。标有private修饰符声明不会出现在所生成的报头。私人声明没有接触到Objective-C的，除非它们被明确标有@IBAction，@IBOutlet，或@objc为好。如果您的应用程序的目标是编译测试启用，单元测试目标可以访问任何声明与内部修饰，仿佛他们与公众修饰符通过预先@testable的产品模块导入语句声明。</p>
<p>你不需要做任何事情来生成这个头文件，只需要将它导入到你的 Objective-C 代码来使用它。注意这个头文件中的 Swift 接口包含了它所使用到的所有 Objective-C 类型。如果你在 Swift 代码中使用你自己的 Objective-C 类型，确保先将对应的 Objective-C 头文件导入到你的 Swift 代码中，然后才将 Swift 自动生成的头文件导入到 Objective-C .m 源文件中来访问 Swift 代码。</p>
<h5 id="u5728_u540C_u4E00_target__u4E2D_u5C06_Swift__u4EE3_u7801_u5BFC_u5165_u5230_Objective-C__u4E2D"><a href="#u5728_u540C_u4E00_target__u4E2D_u5C06_Swift__u4EE3_u7801_u5BFC_u5165_u5230_Objective-C__u4E2D" class="headerlink" title="在同一 target 中将 Swift 代码导入到 Objective-C 中"></a>在同一 target 中将 Swift 代码导入到 Objective-C 中</h5><ul>
<li>在相同 target 的 Objective-C .m 源文件中，用下面的语法来导入Swift 代码：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &#34;ProductModuleName-Swift.h&#34;</span><br></pre></td></tr></table></figure>
<p>target 中任何 Swift 文件将会对 Objective-C .m 源文件可见，包括这个 import 语句。关于在 Objective-C 代码中使用 Swift 代码，详见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_84" target="_blank" rel="external">Using Swift from Objective-C</a>。</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">导入到 Swift</th>
<th style="text-align:center">导入到 Objective-C</th>
</tr>
</thead>
<tbody>
<tr>
<td>Swift 代码</td>
<td style="text-align:center">不需要import语句</td>
<td style="text-align:center">#import “ProductModuleName-Swift.h”</td>
</tr>
<tr>
<td>Objective-C 代码</td>
<td style="text-align:center">不需要import语句；需要 Objective-C bridging头文件</td>
<td style="text-align:center">#import “Header.h”</td>
</tr>
</tbody>
</table>
<p><a name="importing_code_from_within_the_same_framework_target"></a></p>
<h2 id="u5728_u540C_u4E2A_Framework__u7684_target__u4E2D_u5BFC_u5165"><a href="#u5728_u540C_u4E2A_Framework__u7684_target__u4E2D_u5BFC_u5165" class="headerlink" title="在同个 Framework 的 target 中导入"></a>在同个 Framework 的 target 中导入</h2><p>如果你在写一个混合语言的框架，可能会从 Swift 代码访问 Objective-C 代码，或者反之。</p>
<h3 id="u5C06_Objective-C__u5BFC_u5165_Swift-1"><a href="#u5C06_Objective-C__u5BFC_u5165_Swift-1" class="headerlink" title="将 Objective-C 导入 Swift"></a>将 Objective-C 导入 Swift</h3><p>要将一些 Objective-C 文件导入到同个框架 target 的 Swift 代码中去，你需要将这些文件导入到 Objective-C 的 <code>umbrella header</code> 来供框架使用。</p>
<h5 id="u5728_u540C_u4E00_framework__u4E2D_u5C06_Objective-C__u4EE3_u7801_u5BFC_u5165_u5230_Swift__u4E2D"><a href="#u5728_u540C_u4E00_framework__u4E2D_u5C06_Objective-C__u4EE3_u7801_u5BFC_u5165_u5230_Swift__u4E2D" class="headerlink" title="在同一 framework 中将 Objective-C 代码导入到 Swift 中"></a>在同一 framework 中将 Objective-C 代码导入到 Swift 中</h5><p>确保将框架 target 的 <code>Build Settings &gt; Packaging &gt; Defines Module</code> 设置为 <code>Yes</code>。然后在你的 <code>umbrella header</code> 头文件中导入你想暴露给 Swift 访问的 Objective-C 头文件，例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &#60;XYZ/XYZCustomCell.h&#62;&#10;#import &#60;XYZ/XYZCustomView.h&#62;&#10;#import &#60;XYZ/XYZCustomViewController.h&#62;</span><br></pre></td></tr></table></figure>
<p>Swift 将会看到所有你在 <code>umbrella header</code> 中公开暴露出来的头文件，框架 target 中的所有 Swift 文件都可以访问你 Objective-C 文件的内容，不需要任何 import 语句。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myCell = <span class="type">XYZCustomCell</span>()</span><br><span class="line">myCell.subtitle = <span class="string">"A custom cell"</span></span><br></pre></td></tr></table></figure>
<h3 id="u5C06_Swift__u5BFC_u5165_Objective-C"><a href="#u5C06_Swift__u5BFC_u5165_Objective-C" class="headerlink" title="将 Swift 导入 Objective-C"></a>将 Swift 导入 Objective-C</h3><p>要将一些 Swift 文件导入到同个框架的 target 的 Objective-C 代码去，你不需要导入任何东西到 <code>umbrella header</code> 文件，而是将 Xcode 为你的 Swift 代码自动生成的头文件导入到你的 Obj .m 源文件去，以便在 Objective-C 代码中访问 Swift 代码。</p>
<h5 id="u5728_u540C_u4E00_framework__u4E2D_u5C06_Swift__u4EE3_u7801_u5BFC_u5165_u5230_Objective-C__u4E2D"><a href="#u5728_u540C_u4E00_framework__u4E2D_u5C06_Swift__u4EE3_u7801_u5BFC_u5165_u5230_Objective-C__u4E2D" class="headerlink" title="在同一 framework 中将 Swift 代码导入到 Objective-C 中"></a>在同一 framework 中将 Swift 代码导入到 Objective-C 中</h5><p>确保将框架 target 的 <code>Build Settings &gt; Packaging</code> 中的 <code>Defines Module</code> 设置为 <code>Yes</code>。用下面的语法将 Swift 代码导入到同个框架 target 下的 Objective-C .m 源文件去。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// OBJECTIVE-C&#10;#import &#60;ProductName/ProductModuleName-Swift.h&#62;</span><br></pre></td></tr></table></figure>
<p>这个 import 语句所包含的 Swift 文件都可以被同个框架 target 下的 Objective-C .m 源文件访问。关于在 Objective-C 代码中使用 Swift 代码，详见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_84" target="_blank" rel="external">Using Swift from Objective-C</a>。</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">导入到 Swift</th>
<th style="text-align:center">导入到 Objective-C</th>
</tr>
</thead>
<tbody>
<tr>
<td>Swift 代码</td>
<td style="text-align:center">不需要import语句</td>
<td style="text-align:center">#import “ProductName/ProductModuleName-Swift.h”</td>
</tr>
<tr>
<td>Objective-C 代码</td>
<td style="text-align:center">不需要import语句；需要 Objective-C umbrella头文件</td>
<td style="text-align:center">#import “Header.h”</td>
</tr>
</tbody>
</table>
<p><a name="importing_external_frameworks"></a></p>
<h2 id="u5BFC_u5165_u5916_u90E8_Framework"><a href="#u5BFC_u5165_u5916_u90E8_Framework" class="headerlink" title="导入外部 Framework"></a>导入外部 Framework</h2><p>你可以导入外部框架，不管这个框架是纯 Objective-C，纯 Swift，还是混合语言的。import 外部框架的流程都是一样的，不管这个框架是用一种语言写的，还是包含两种语言。当你导入外部框架时，确保 <code>Build Setting &gt; Pakaging &gt; Defines Module</code> 设置为 <code>Yes</code>。</p>
<p>用下面的语法将框架导入到不同 target 的 Swift 文件中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> FrameworkName</span><br></pre></td></tr></table></figure>
<p>用下面的语法将框架导入到不同 target 的 Objective-C .m 文件中：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import FrameworkName;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">导入到 Swift</th>
<th style="text-align:center">导入到 Objective-C</th>
</tr>
</thead>
<tbody>
<tr>
<td>任意语言框架</td>
<td style="text-align:center">import FrameworkName</td>
<td style="text-align:center">@import FrameworkName;</td>
</tr>
</tbody>
</table>
<p><a name="using_swift_from_objective-c"></a></p>
<h2 id="u5728_Objective-C__u4E2D_u4F7F_u7528_Swift"><a href="#u5728_Objective-C__u4E2D_u4F7F_u7528_Swift" class="headerlink" title="在 Objective-C 中使用 Swift"></a>在 Objective-C 中使用 Swift</h2><p>当你将 Swift 代码导入 Objective-C 之后，便可用常规的 Objective-C 语法来使用 Swift 类。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MySwiftClass *swiftObject = [[MySwiftClass alloc] init];&#10;[swiftObject swiftMethod];</span><br></pre></td></tr></table></figure>
<p>Swift 的类或协议必须用 <code>@objc</code>属性来标记，以便在 Objective-C 中可访问。这个 属性告诉编译器这块 Swift 代码可以从 Objective-C 代码中访问。如果你的 Swift 类是 Objective-C 类的子类，编译器会自动为你添加 <code>@objc</code>。详见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID53" target="_blank" rel="external">Swift Type Compatibility</a>。</p>
<p>你可以访问在 Swift 类或协议中使用用<code>@objc</code>属性标记的任何对象，只要该对象与 Objective-C 兼容。不包括以下 Swift 独有的特性：</p>
<ul>
<li><p>范型（Generics）</p>
</li>
<li><p>元组（Tuples）</p>
</li>
<li><p>Swift 中定义的枚举不包括<code>Int</code>原始值类型（Enumerations defined in Swift without Int raw value type）</p>
</li>
<li><p>Swift 中定义的结构体（Structures defined in Swift）   </p>
</li>
<li><p>Swift 中定义的顶层函数（Top-level functions defined in Swift）</p>
</li>
<li><p>Swift 中定义的全局变量（Global variables defined in Swift）</p>
</li>
<li><p>Swift 中定义的类型别名（Typealiases defined in Swift）</p>
</li>
<li><p>Swift风格可变参数（Swift-style variadics）</p>
</li>
<li><p>嵌套类型（Nested types）</p>
</li>
<li><p>柯里化函数（Curried functions）</p>
</li>
</ul>
<p>例如，使用范型类型作为参数，或者返回元组的方法将不能在 Objective-C 中使用。</p>
<blockquote>
<p>注意<br>你不能在 Objective-C 继承一个 Swift 类。</p>
</blockquote>
<h3 id="u5728_Objective-C__u5934_u6587_u4EF6_u4E2D_u5F15_u7528_Swift__u7C7B"><a href="#u5728_Objective-C__u5934_u6587_u4EF6_u4E2D_u5F15_u7528_Swift__u7C7B" class="headerlink" title="在 Objective-C 头文件中引用 Swift 类"></a>在 Objective-C 头文件中引用 Swift 类</h3><p>这样前向声明 Swift 类：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// OBJECTIVE-C&#10;// MyObjective-CClass.h&#10;&#10;@class MySwiftClass;&#10;&#10;@interface MyObjective-CClass : NSObject&#10;- (MySwiftClass *)returnSwiftObject;&#10;/* ... */&#10;@end</span><br></pre></td></tr></table></figure>
<p><a name="overriding_swift_names_for_Objective-C_interfaces"></a></p>
<h2 id="u4E3A_Objective-C__u63A5_u53E3_u91CD_u5199_Swift__u540D_u79F0"><a href="#u4E3A_Objective-C__u63A5_u53E3_u91CD_u5199_Swift__u540D_u79F0" class="headerlink" title="为 Objective-C 接口重写 Swift 名称"></a>为 Objective-C 接口重写 Swift 名称</h2><p>Swift 编译器自动的将 Objective-C 代码作为常规 Swift 代码导入。它将 Objective-C 的类工厂方法作为 Swift 构造器导入，以及将 Objective-C 的枚举类型名称截断处理。</p>
<p>在你的代码中也许存在不能够被自动处理的边界情况。如果你需要更改导入到 Swift 中的 Objective-C 方法，枚举，或者可选 set 值，你可以使用<code>NS_SWIFT_NAME</code>宏来自定义导入的声明。</p>
<h3 id="u7C7B_u5DE5_u5382_u65B9_u6CD5"><a href="#u7C7B_u5DE5_u5382_u65B9_u6CD5" class="headerlink" title="类工厂方法"></a>类工厂方法</h3><p>如果 Swift 编译器无法识别类工厂方法，你可以使用<code>NS_SWIFT_NAME</code>宏，来正确导入构造器的 Swift 签名。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)recordWithRPM:(NSUInteger)RPM NS_SWIFT_NAME(init(RPM:));</span><br></pre></td></tr></table></figure>
<p>如果 Swift 编译器错误的将一个方法识别为类工厂方法，你可以使用<code>NS_SWIFT_NAME</code>宏，来正确导入构造器的 Swift 签名。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(id)recordWithQuality:(double)quality NS_SWIFT_NAME(record(quality:));</span><br></pre></td></tr></table></figure>
<h3 id="u679A_u4E3E"><a href="#u679A_u4E3E" class="headerlink" title="枚举"></a>枚举</h3><p>默认情况下，Swift 将枚举值的名称前缀做截断来导入枚举。如果要自定义枚举值的名称，你可以使用<code>NS_SWIFT_NAME</code>宏来传递 Swift 枚举值名称。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, ABCRecordSide) &#123;&#10;  ABCRecordSideA,&#10;  ABCRecordSideB NS_SWIFT_NAME(&#34;FlipSide&#34;),&#10;&#125;;</span><br></pre></td></tr></table></figure>
<p><a name="naming_your_product_module"></a></p>
<h2 id="Product__u6A21_u5757_u547D_u540D"><a href="#Product__u6A21_u5757_u547D_u540D" class="headerlink" title="Product 模块命名"></a>Product 模块命名</h2><p>Xcode 为 Swift 代码生成的头文件的名称，以及 Xcode 创建的 Objective-C 桥接头文件名称，都是从你的 product 模块名生成的。默认你的 product 模块名和 product 名一样。然而，如果你的 product 名有特殊字符（nonalphanumeric，非数字、字母的字符），例如点号，那么它们会被下划线（<code>_</code>）替换之后作为你的 product 模块名。如果 product 名以数字开头，那么第一个数字会用下划线替换掉。</p>
<p>你可以给 product 模块名提供一个自定义的名称，Xcode 会用这个名称来命名桥接的和自动生成的头文件。你只需要在修改在 <code>build setting</code> 中的 <code>Product Module Name</code> 即可。</p>
<p><a name="troubleshooting_tips_and_reminders"></a></p>
<h2 id="u95EE_u9898_u89E3_u51B3_u63D0_u793A"><a href="#u95EE_u9898_u89E3_u51B3_u63D0_u793A" class="headerlink" title="问题解决提示"></a>问题解决提示</h2><ul>
<li>把 Swift 和 Objective-C 文件看作相同的代码集合，并注意命名冲突。</li>
<li>如果你使用了框架，确保在<code>Packaging</code>下的<code>Defines Module</code>编译设置被设置为 <code>Yes</code>。</li>
<li>如果你使用了 Objective-C 桥接头文件，确保 Swift 编译器中 Objective-C 桥接头文件的编译设置<code>Code Generation</code>有一个与项目相关的头文件的路径。这个路径必须是头文件自身的路径，而不是它所在的目录。</li>
<li>Xcode 使用你的工程模块名，而不是以<code>target</code>的名称来命名 Objective-C 桥接头文件以及为 Swift 代码 自动生成的头文件。详见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-ID138" target="_blank" rel="external">Naming Your Product Module</a>。</li>
<li>为了在 Objective-C 中可用， Swift 类必须是 Objective-C 类的子类，或者用 <code>@objc</code> 标记。</li>
<li>当你将 Swift 导入到 Objective-C 中时，记住 Objective-C 不会将 Swift 独有的特性转化成 Objective-C 对应的特性。详见列表 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-ID136" target="_blank" rel="external">Using Swift from Objective-C</a>。</li>
<li>如果你在 Swift 代码中使用你自己的 Objective-C 类型，确保先将对应的 Objective-C 头文件导入到你的 Swift 代码中，然后才将 Swift 自动生成的头文件导入到 Objective-C .m 源文件中来访问 Swift 代码。</li>
<li>用<code>private</code>修饰符标记的 Swift 声明不会出现在自动生成的头文件中。私有声明不会暴漏给 Objective-C，除非它们被明确标记有<code>@IBAction</code>，<code>@IBOutlet</code>或者<code>@objc</code>等。</li>
<li>对于应用 targets 而言，如果有 Objective-C 桥接头文件时，被<code>internal</code>修饰符标记的声明会出现在自动产生的头文件中。</li>
<li>对于框架 targets 而言，只有被<code>public</code>修饰符标记的声明才会出现在自动生成的头文件中。你仍然可以在框架中的 Objective-C 部分使用被<code>internal</code>修饰符标记的 Swift 方法和属性，只要它们声明所在的类继承自 Objective-C 类。关于访问级别修饰符的更多信息，请查看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097" target="_blank" rel="external">The Swift Programming Language</a>中的<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html#//apple_ref/doc/uid/TP40014097-CH41" target="_blank" rel="external">访问控制(Access Control)</a></li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/04Migration/Migrating Your Objective-C Code to Swift/" itemprop="url">
                04Migration-01为你的Objective-c代码做好迁移准备
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-26T22:00:04+08:00" content="2015-12-26">
            2015-12-26
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Using-Swift-with-Cocoa-and-Objective-C/" itemprop="url" rel="index">
                  <span itemprop="name">Using-Swift-with-Cocoa-and-Objective-C</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/04Migration/Migrating Your Objective-C Code to Swift/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/04Migration/Migrating Your Objective-C Code to Swift/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><blockquote>
<p>翻译：<a href="https://github.com/xudeheng" target="_blank" rel="external">xudeheng</a></p>
<p>校对：<a href="http://github.com/dabing1022" target="_blank" rel="external">ChildhoodAndy</a></p>
</blockquote>
<h1 id="u5C06_Objective-C__u4EE3_u7801_u8FC1_u79FB_u5230_Swift"><a href="#u5C06_Objective-C__u4EE3_u7801_u8FC1_u79FB_u5230_Swift" class="headerlink" title="将 Objective-C 代码迁移到 Swift"></a>将 Objective-C 代码迁移到 Swift</h1><hr>
<p>本节内容包括：</p>
<ul>
<li><a href="/#preparing_your_objective-c_code_for_migration">为你的Objective-c代码做好迁移准备<br>（Preparing Your Objective-C Code for Migration）</a></li>
<li><a href="/#the_migration_process">迁移过程（The Migration Process）</a></li>
<li><a href="/#troubleshooting_tips_and_reminders">问题解决提示（Troubleshooting Tips and Reminders）</a></li>
</ul>
<p>迁移工作提供了一个重新审视现有 Objective-C 应用程序的机会，并通过 替换部分Swift 代码来更好的优化应用程序的架构，逻辑以及性能。换句话说，所谓增量app迁移，就是让你使用之前的工具-mix and match 来提升相互之间的可操作性。当要选择哪些特性和功能来用 Swift，哪些依然用 Objective-C 实现时，Mix-and-match让这一切变得简单。Swift 和 Objective-C 的互用性又使得将这些功能集成到 Objective-C 变得并不困难。通过这些工具可以开放 Swift 的扩展功能并集成到现有的 Objective-C 项目中而完全不必立刻使用 Swift 重写整个项目。</p>
<p><a name="preparing_your_objective-c_code_for_migration"></a></p>
<h2 id="u4E3A_u4F60_u7684Objective-C_u4EE3_u7801_u505A_u597D_u8FC1_u79FB_u51C6_u5907"><a href="#u4E3A_u4F60_u7684Objective-C_u4EE3_u7801_u505A_u597D_u8FC1_u79FB_u51C6_u5907" class="headerlink" title="为你的Objective-C代码做好迁移准备"></a>为你的Objective-C代码做好迁移准备</h2><p>在开始迁移你的代码之前，请确保你的 Objective-C 和 Swift 代码间有着最佳兼容性。这意味着整理并使用 Objective-C 的现代化特性来优化你的现有项目。为了和 Swift 进行更容易的无缝交互，你的现有代码需要遵循现代编码实践。在开始前，有个简短的适配练习列表，参看<a href="https://developer.apple.com/library/prerelease/ios/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html#//apple_ref/doc/uid/TP40014150" target="_blank" rel="external">Adopting Mordern Objective-C</a>。</p>
<p><a name="the_migration_process"></a></p>
<h2 id="u8FC1_u79FB_u8FC7_u7A0B"><a href="#u8FC1_u79FB_u8FC7_u7A0B" class="headerlink" title="迁移过程"></a>迁移过程</h2><p>最有效迁移代码的方式是基于逐个文件，即一次完成一个类。由于你不能在 Objective-C 中继承 Swift类， 最好选择一个没有子类的（译者：从类的继承角度来看，应该先从类族树的叶子节点开始，自底向上的进行迁移操作）。你就可以用单个<code>.swift</code>文件来代替对应的<code>.m</code>和<code>.h</code>文件了。你所有的实现代码和接口将直接放进单个 Swift 文件。你不用再创建头文件了；Xcode 会在你需要引用的时候自动生成头文件。(译者：当然这是在xcode内部机制完成的了，对开发者是透明的)</p>
<h3 id="u51C6_u5907_u5DE5_u4F5C"><a href="#u51C6_u5907_u5DE5_u4F5C" class="headerlink" title="准备工作"></a>准备工作</h3><ul>
<li>在 Xcode 中:File&gt;New&gt;File&gt;(iOS 或者 OS X) &gt; Other &gt; Swift 为对应的 Objective-C<code>.m</code> 和<code>.h</code>文件创建一个 Swift 类。</li>
<li>导入相关系统框架。</li>
<li>如果你希望在 Swift 文件中访问 Objective-C 代码的话，可以填入一个 Objective-C 桥接头。具体的操作步骤，请看 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_77" target="_blank" rel="external">Importing Code from Within the Same App Target</a>。</li>
<li>为使你的 Swift 类能在 Objective-C 中访问使用，可以继承 Objective-C 类，或者标记上<code>@objc</code>属性。为类指定特殊的名称，以在 Objective-C 中使用，标记上<code>@objc(#name#)</code>, <code>&lt;#name#&gt;</code>就是在 Objective-C 中引用的 Swift 类名。 更多信息，请看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-XID_36" target="_blank" rel="external">Swift Type Compatibility</a>。</li>
</ul>
<h3 id="u5F00_u59CB_u5DE5_u4F5C"><a href="#u5F00_u59CB_u5DE5_u4F5C" class="headerlink" title="开始工作"></a>开始工作</h3><ul>
<li>你可以通过继承 Objective-C 类，适配 Objective-C 协议，或者更多的方式，来让 Swift 类集成  Objective-C 行为。更多信息，请看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WritingSwiftClassesWithObjective-CBehavior.html#//apple_ref/doc/uid/TP40014216-CH5-XID_54" target="_blank" rel="external">Writing Swift Classes with Objective-C Behavior</a></li>
<li>当你使用 Objective-C APIs 的时候，你需要知道 Swift 是怎样来翻译某些 Objective-C 特性的。更多信息，请看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-XID_26" target="_blank" rel="external">Interacting with Objective-C APIs</a></li>
<li>当用 Swift 编写用到 Cocoa 框架的代码时，记住某些类型是被桥接的，意味着你可以使用某些 Swift 类型来替代 Objective-C 类型。更多信息，请看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-XID_40" target="_blank" rel="external">Working with Cocoa Data Types</a></li>
<li>当你在 Swift 中运用 Cocoa设计模式得时候，请看 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-XID_5" target="_blank" rel="external">Adopting Cocoa Design Patterns</a>获取更多的通用设计模式的转换信息。</li>
<li>对于打算将项目从 Objective-C 转换到 Swfit 的人，请看 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13" target="_blank" rel="external">Properties</a>。</li>
<li>在必要的时候，请为 Swift 的属性或方法，通过<code>@objc(&lt;#name#&gt;)</code>属性来提供 Objective-C 名称，就像这样：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> enabled: <span class="type">Bool</span> &#123;</span><br><span class="line">	<span class="preprocessor">@objc</span>(isEnabled) <span class="keyword">get</span> &#123;</span><br><span class="line">		<span class="comment">/* ... */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>分别用<code>func</code>和<code>class func</code>来表示 instance(-) 和 class(+) 方法。</li>
<li>声明简单的宏来作为常量，将复杂的宏转换为函数。</li>
</ul>
<h3 id="u5927_u529F_u544A_u6210"><a href="#u5927_u529F_u544A_u6210" class="headerlink" title="大功告成"></a>大功告成</h3><ul>
<li>在你的 Objective-C 代码中更新 import 语句为 #import “模块名-Swift.h”，可参阅<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_77" target="_blank" rel="external">Importing Code from Within the Same App Target</a>中曾有提到。</li>
<li>在Target 的成员选择框中去掉勾选框来移除原始的 Objective-C<code>.m</code>文件.不要立刻删除<code>.m</code>和<code>.h</code>文件，以备解决问题用。</li>
<li>如果你给 Swift 类起了一个不同的名字，请使用 Swift 类名代替 Objective-C 名。</li>
</ul>
<p><a name="troubleshooting_tips_and_reminders"></a></p>
<h2 id="u95EE_u9898_u89E3_u51B3_u63D0_u793A"><a href="#u95EE_u9898_u89E3_u51B3_u63D0_u793A" class="headerlink" title="问题解决提示"></a>问题解决提示</h2><p>尽管对于不同的项目，迁移的经历是不尽相同的，无论怎样，都有一些通用的步骤和工具能帮你解决代码迁移时碰到的问题：</p>
<ul>
<li>记住：你不能在 Objective-C 中继承 Swift 类。因此，被你迁移的类不能有任何的 Objective-C 子类存在于你的应用中。</li>
<li>当你迁移一个类到 Swift 的时候，你必须从 target 中移除相关的<code>.m</code>文件，以避免编译时提示出现重复的符号等编译错误。</li>
<li>为了在 Objective-C 中可以访问并使用，Swift 类必须是一个 Objective-C 类的子类，或者被标记为<code>@objc</code>。</li>
<li>当你在 Objective-C 中使用 Swift 代码的时候，记住 Objective-C 不能理解那些 Swift 的某些特性，请看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_84" target="_blank" rel="external">Using Swift from Objective-C</a>。</li>
<li>可以通过<code>Commond + 单击</code>一个 Swift 类名来查看它生成的头文件。</li>
<li>可以通过<code>Option + 单击</code>一个符号来查看更详细的信息，比如它的类型，属性以及文档注释等。</li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/05Revision History/Document Revision History/" itemprop="url">
                05Revision History-Document Revision History
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-26T22:00:03+08:00" content="2015-12-26">
            2015-12-26
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Using-Swift-with-Cocoa-and-Objective-C/" itemprop="url" rel="index">
                  <span itemprop="name">Using-Swift-with-Cocoa-and-Objective-C</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/05Revision History/Document Revision History/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/05Revision History/Document Revision History/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="u6587_u6863_u4FEE_u8BA2_u5386_u53F2"><a href="#u6587_u6863_u4FEE_u8BA2_u5386_u53F2" class="headerlink" title="文档修订历史"></a>文档修订历史</h1><p>该表格描述了 Using Swift with Cocoa and Objective-C 一书的改动。</p>
<table class="graybox" border="0" cellspacing="0" cellpadding="5"><br><thead><br>    <tr><br>        <th scope="col" width="100">日期</th><br>       <th scope="col">变更记录</th><br>    </tr><br></thead><br><tbody><br>    <tr><br>    <td scope="row">2015-06-08</td><br>    <td><ul class="list-bullet"><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID35" target="_blank" rel="external"> Interacting with Objective-C APIs </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WritingSwiftClassesWithObjective-CBehavior.html#//apple_ref/doc/uid/TP40014216-CH5-ID152" target="_blank" rel="external"> NSCoding </a>部分。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID61" target="_blank" rel="external"> Working with Cocoa Data Types </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID83" target="_blank" rel="external"> Memory Managed Objects </a>部分。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID61" target="_blank" rel="external"> Working with Cocoa Data Types </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID151" target="_blank" rel="external"> Sets </a>部分。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216-CH2-ID2" target="_blank" rel="external"> Setting Up Your Swift Environment </a>中补充说明有关由命令行建立的可执行文件的 Swift target 系统要求。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID35" target="_blank" rel="external"> Interacting with Objective-C APIs </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID45" target="_blank" rel="external"> Nullability and Optionals </a>部分。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID35" target="_blank" rel="external"> Interacting with Objective-C APIs </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-ID170" target="_blank" rel="external"> Unions </a>部分。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID35" target="_blank" rel="external"> Interacting with Objective-C APIs </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-ID169" target="_blank" rel="external"> Option Sets </a>部分。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-ID6" target="_blank" rel="external"> Adopting Cocoa Design Patterns </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-ID160" target="_blank" rel="external"> API Availability </a>部分。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID35" target="_blank" rel="external"> Interacting with Objective-C APIs </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-ID162" target="_blank" rel="external"> Overriding Swift Names for Objective-C Interfaces </a>部分。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-ID6" target="_blank" rel="external"> Adopting Cocoa Design Patterns </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-ID10" target="_blank" rel="external"> Error Handling </a>部分。<br>        </p></li><br>        <li><p><br>        更新<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-ID122" target="_blank" rel="external"> Swift and Objective-C in the Same Project </a>章节中关于 @testable 注解的信息。<br>        </p></li><br>        <li><p><br>        更新<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-ID148" target="_blank" rel="external"> Function Pointers </a>章节中关于将 Swift 函数和闭包与 C 函数指针桥接的信息。<br>        </p></li><br>        <li><p><br>        更新<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-ID146" target="_blank" rel="external"> Constant Pointers </a>章节中关于将 Swift String 值与 C 指针桥接的信息。<br>        </p></li><br>        <li><p><br>        更新<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID55" target="_blank" rel="external"> Exposing Swift Interfaces in Objective-C </a>章节中关于在 Swift 中使用 @objc 来标注枚举的信息。<br>        </p></li><br>        <li><p><br>        更新<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID69" target="_blank" rel="external"> Collection Classes </a>章节，讨论 Swift 对 Objective-C 集合类的参数化桥接。<br>        </p></li><br>        </ul><br>    </td><br>  </tr><br><br>      <tr><br>    <td scope="row">2015-02-23</td><br>    <td><ul class="list-bullet"><br>        <li><p><br>        更新<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID61" target="_blank" rel="external"> Working with Cocoa Data Types </a>章节，在 Swift 1.2 中使用 as! 操作符和桥接语义。<br>        </p></li><br>        </ul><br>    </td><br>   </tr><br><br>    <tr><br>    <td scope="row">2015-01-18</td><br>    <td><ul class="list-bullet"><br>        <li><p><br>        修复了 UIBezierPath 例子以正确的创建一个三角形<br>        </p></li><br>        </ul><br>    </td><br>   </tr><br><br>    <tr><br>    <td scope="row">2015-01-18</td><br>    <td><ul class="list-bullet"><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID35" target="_blank" rel="external"> Interacting with Objective-C APIs </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID145" target="_blank" rel="external"> Failable Initialization </a>部分。<br><br>        </p></li><br>        </ul><br>    </td><br>   </tr><br><br>       <tr><br>    <td scope="row">2014-09-02</td><br>    <td><ul class="list-bullet"><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WritingSwiftClassesWithObjective-CBehavior.html#//apple_ref/doc/uid/TP40014216-CH5-ID86" target="_blank" rel="external"> Writing Swift Classes with Objective-C Behavior </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WritingSwiftClassesWithObjective-CBehavior.html#//apple_ref/doc/uid/TP40014216-CH5-ID107" target="_blank" rel="external"> Using Swift Class Names with Objective-C APIs </a>部分。<br>        </p></li><br>        <li><p><br>        纠正<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WritingSwiftClassesWithObjective-CBehavior.html#//apple_ref/doc/uid/TP40014216-CH5-ID98" target="_blank" rel="external"> Live Rendering </a>只对编译在框架中的 designable 类生效的陈述。这个限制已经不再存在。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-ID12" target="_blank" rel="external"> Key-Value Observing </a>中添加对 deinit 的实现以及以往代码中对 super 的调用。<br>        </p></li><br>        </ul><br>    </td><br>   </tr><br></tbody><br></table>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/26/swift-cn/SUMMARY/" itemprop="url">
                Summary
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-26T12:00:00+08:00" content="2015-12-26">
            2015-12-26
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn/</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/26/swift-cn/SUMMARY/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/26/swift-cn/SUMMARY/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><ul>
<li><a href="/2015/12/25/swift-cn/chapter1/chapter1/">欢迎使用 Swift</a><ul>
<li><a href="/2015/12/25/swift-cn/chapter1/01_swift/">关于 Swift</a></li>
<li><a href="/2015/12/25/swift-cn/chapter1/02_a_swift_tour/">Swift 初见</a></li>
<li><a href="/2015/12/25/swift-cn/chapter1/03_revision_history/">Swift 版本历史记录</a></li>
<li><a href="/v1.0/">Swift 1.0 发布内容</a></li>
</ul>
</li>
<li><a href="/2015/12/25/swift-cn/chapter2/chapter2/">Swift 教程</a><ul>
<li><a href="/2015/12/25/swift-cn/chapter2/01_The_Basics/">基础部分</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/02_Basic_Operators/">基本运算符</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/03_Strings_and_Characters/">字符串和字符</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/04_Collection_Types/">集合类型</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/05_Control_Flow/">控制流</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/06_Functions/">函数</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/07_Closures/">闭包</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/08_Enumerations/">枚举</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/09_Classes_and_Structures/">类和结构体</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/10_Properties/">属性</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/11_Methods/">方法</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/12_Subscripts/">下标脚本</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/13_Inheritance/">继承</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/14_Initialization/">构造过程</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/15_Deinitialization/">析构过程</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/16_Automatic_Reference_Counting/">自动引用计数</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/17_Optional_Chaining/">可选链</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/18_Error_Handling/">错误处理</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/19_Type_Casting/">类型转换</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/20_Nested_Types/">嵌套类型</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/21_Extensions/">扩展</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/22_Protocols/">协议</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/23_Generics/">泛型</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/24_Access_Control/">访问控制</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/25_Advanced_Operators/">高级运算符</a></li>
</ul>
</li>
<li>语言参考<ul>
<li><a href="/2015/12/25/swift-cn/chapter3/01_About_the_Language_Reference/">关于语言参考</a></li>
<li><a href="/2015/12/25/swift-cn/chapter3/02_Lexical_Structure/">词法结构</a></li>
<li><a href="/2015/12/25/swift-cn/chapter3/03_Types/">类型</a></li>
<li><a href="/2015/12/25/swift-cn/chapter3/04_Expressions/">表达式</a></li>
<li><a href="/2015/12/25/swift-cn/chapter3/10_Statements/">语句</a></li>
<li><a href="/2015/12/25/swift-cn/chapter3/05_Declarations/">声明</a></li>
<li><a href="/2015/12/25/swift-cn/chapter3/06_Attributes/">特性</a></li>
<li><a href="/2015/12/25/swift-cn/chapter3/07_Patterns/">模式</a></li>
<li><a href="/2015/12/25/swift-cn/chapter3/08_Generic_Parameters_and_Arguments/">泛型参数</a></li>
<li><a href="/2015/12/25/swift-cn/chapter3/09_Summary_of_the_Grammar/">语法总结</a></li>
</ul>
</li>
<li>苹果官方Blog官方翻译<ul>
<li><a href="/2015/12/25/swift-cn/chapter4/01_Access_Control/">Access Control 权限控制的黑与白</a></li>
<li><a href="/2015/12/25/swift-cn/chapter4/02_Type_Custom/">造个类型不是梦-白话Swift类型创建</a></li>
<li><a href="/2015/12/25/swift-cn/chapter4/03_Ballons/">WWDC里面的那个“大炮打气球”</a></li>
<li><a href="/2015/12/25/swift-cn/chapter4/04_Interacting_with_C_Pointers/">Swift与C语言指针友好合作</a></li>
<li><a href="/2015/12/25/swift-cn/chapter4/05_Value_and_Reference_Types/">引用类型和值类型的恩怨</a></li>
<li><a href="/2015/12/25/swift-cn/chapter4/06_Access_Control_and_Protected/">访问控制和Protected</a></li>
<li><a href="/2015/12/25/swift-cn/chapter4/07_Optional_Case_Study/">可选类型完美解决占位问题</a></li>
</ul>
</li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter1/01_swift/" itemprop="url">
                第一章-01关于 Swift（About Swift）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T23:00:00+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter1/01_swift/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter1/01_swift/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="u5173_u4E8E_Swift_uFF08About_Swift_uFF09"><a href="#u5173_u4E8E_Swift_uFF08About_Swift_uFF09" class="headerlink" title="关于 Swift（About Swift）"></a>关于 Swift（About Swift）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a><br>校对：<a href="https://github.com/yeahdongcn" target="_blank" rel="external">yeahdongcn</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/xtymichael" target="_blank" rel="external">xtymichael</a></p>
</blockquote>
<p>Swift 是一种新的编程语言，用于编写 iOS，OS X 和 watchOS应用程序。Swift 结合了 C 和 Objective-C 的优点并且不受 C 兼容性的限制。Swift 采用安全的编程模式并添加了很多新特性，这将使编程更简单，更灵活，也更有趣。Swift 是基于成熟而且倍受喜爱的 Cocoa 和 Cocoa Touch 框架，它的降临将重新定义软件开发。</p>
<p>Swift 的开发从很久之前就开始了。为了给 Swift 打好基础，苹果公司改进了编译器，调试器和框架结构。我们使用自动引用计数（Automatic Reference Counting, ARC）来简化内存管理。我们在 Foundation 和 Cocoa 的基础上构建框架栈使其完全现代化和标准化。<br>Objective-C 本身支持块、集合语法和模块，所以框架可以轻松支持现代编程语言技术。正是得益于这些基础工作，我们现在才能发布这样一个用于未来苹果软件开发的新语言。</p>
<p>Objective-C 开发者对 Swift 并不会感到陌生。它采用了 Objective-C 的命名参数以及动态对象模型，可以无缝对接到现有的 Cocoa 框架，并且可以兼容 Objective-C 代码。在此基础之上，Swift 还有许多新特性并且支持过程式编程和面向对象编程。</p>
<p>Swift 对于初学者来说也很友好。它是第一个既满足工业标准又像脚本语言一样充满表现力和趣味的脚本语言。它支持代码预览，这个革命性的特性可以允许程序员在不编译和运行应用程序的前提下运行 Swift 代码并实时查看结果。</p>
<p>Swift 将现代编程语言的精华和苹果工程师文化的智慧结合了起来。编译器对性能进行了优化，编程语言对开发进行了优化，两者互不干扰，鱼与熊掌兼得。Swift 既可以用于开发 “hello, world” 这样的小程序，也可以用于开发一套完整的操作系统。所有的这些特性让 Swift 对于开发者和苹果来说都是一项值得的投资。</p>
<p>Swift 是编写 iOS，OS X 和 watchOS应用的极佳手段，并将伴随着新的特性和功能持续演进。我们对 Swift 充满信心，你还在等什么！</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter1/02_a_swift_tour/" itemprop="url">
                第一章-02Swift 初见（A Swift Tour）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T22:00:00+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter1/02_a_swift_tour/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter1/02_a_swift_tour/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="Swift__u521D_u89C1_uFF08A_Swift_Tour_uFF09"><a href="#Swift__u521D_u89C1_uFF08A_Swift_Tour_uFF09" class="headerlink" title="Swift 初见（A Swift Tour）"></a>Swift 初见（A Swift Tour）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a><br>校对：<a href="https://github.com/shinyzhu" target="_blank" rel="external">shinyzhu</a>, <a href="https://github.com/stanzhai" target="_blank" rel="external">stanzhai</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/xtymichael" target="_blank" rel="external">xtymichael</a></p>
</blockquote>
<p>本页内容包括：</p>
<ul>
<li><a href="/#simple_values">简单值（Simple Values）</a></li>
<li><a href="/#control_flow">控制流（Control Flow）</a></li>
<li><a href="/#functions_and_closures">函数和闭包（Functions and Closures）</a></li>
<li><a href="/#objects_and_classes">对象和类（Objects and Classes）</a></li>
<li><a href="/#enumerations_and_structures">枚举和结构体（Enumerations and Structures）</a></li>
<li><a href="/#protocols_and_extensions">协议和扩展（Protocols and Extensions）</a></li>
<li><a href="/#generics">泛型（Generics）</a></li>
</ul>
<p>通常来说，编程语言教程中的第一个程序应该在屏幕上打印“Hello, world”。在 Swift 中，可以用一行代码实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Hello, world!"</span>)</span><br></pre></td></tr></table></figure>
<p>如果你写过 C 或者 Objective-C 代码，那你应该很熟悉这种形式——在 Swift 中，这行代码就是一个完整的程序。你不需要为了输入输出或者字符串处理导入一个单独的库。全局作用域中的代码会被自动当做程序的入口点，所以你也不需要<code>main()</code>函数。你同样不需要在每个语句结尾写上分号。</p>
<p>这个教程会通过一系列编程例子来让你对 Swift 有初步了解，如果你有什么不理解的地方也不用担心——任何本章介绍的内容都会在后面的章节中详细讲解。</p>
<blockquote>
<p>注意：<br>为了获得最好的体验，在 Xcode 当中使用代码预览功能。代码预览功能可以让你编辑代码并实时看到运行结果。<br><a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/GuidedTour.playground.zip" target="_blank" rel="external">下载Playground</a></p>
</blockquote>
<p><a name="simple_values"></a></p>
<h2 id="u7B80_u5355_u503C"><a href="#u7B80_u5355_u503C" class="headerlink" title="简单值"></a>简单值</h2><p>使用<code>let</code>来声明常量，使用<code>var</code>来声明变量。一个常量的值，在编译的时候，并不需要有明确的值，但是你只能为它赋值一次。也就是说你可以用常量来表示这样一个值：你只需要决定一次，但是需要使用很多次。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myVariable = <span class="number">42</span></span><br><span class="line">myVariable = <span class="number">50</span></span><br><span class="line"><span class="keyword">let</span> myConstant = <span class="number">42</span></span><br></pre></td></tr></table></figure>
<p>常量或者变量的类型必须和你赋给它们的值一样。然而，你不用明确地声明类型，声明的同时赋值的话，编译器会自动推断类型。在上面的例子中，编译器推断出<code>myVariable</code>是一个整数（integer）因为它的初始值是整数。</p>
<p>如果初始值没有提供足够的信息（或者没有初始值），那你需要在变量后面声明类型，用冒号分割。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> implicitInteger = <span class="number">70</span></span><br><span class="line"><span class="keyword">let</span> implicitDouble = <span class="number">70.0</span></span><br><span class="line"><span class="keyword">let</span> explicitDouble: <span class="type">Double</span> = <span class="number">70</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>练习：<br>创建一个常量，显式指定类型为<code>Float</code>并指定初始值为4。</p>
</blockquote>
<p>值永远不会被隐式转换为其他类型。如果你需要把一个值转换成其他类型，请显式转换。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> label = <span class="string">"The width is"</span></span><br><span class="line"><span class="keyword">let</span> width = <span class="number">94</span></span><br><span class="line"><span class="keyword">let</span> widthLabel = label + <span class="type">String</span>(width)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>练习：<br>删除最后一行中的<code>String</code>，错误提示是什么？</p>
</blockquote>
<p>有一种更简单的把值转换成字符串的方法：把值写到括号中，并且在括号之前写一个反斜杠。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> apples = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> oranges = <span class="number">5</span></span><br><span class="line"><span class="keyword">let</span> appleSummary = <span class="string">"I have <span class="subst">\(apples)</span> apples."</span></span><br><span class="line"><span class="keyword">let</span> fruitSummary = <span class="string">"I have <span class="subst">\(apples + oranges)</span> pieces of fruit."</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>练习：<br>使用<code>\()</code>来把一个浮点计算转换成字符串，并加上某人的名字，和他打个招呼。</p>
</blockquote>
<p>使用方括号<code>[]</code>来创建数组和字典，并使用下标或者键（key）来访问元素。最后一个元素后面允许有个逗号。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shoppingList = [<span class="string">"catfish"</span>, <span class="string">"water"</span>, <span class="string">"tulips"</span>, <span class="string">"blue paint"</span>]</span><br><span class="line">shoppingList[<span class="number">1</span>] = <span class="string">"bottle of water"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> occupations = [</span><br><span class="line">    <span class="string">"Malcolm"</span>: <span class="string">"Captain"</span>,</span><br><span class="line">    <span class="string">"Kaylee"</span>: <span class="string">"Mechanic"</span>,</span><br><span class="line">]</span><br><span class="line">occupations[<span class="string">"Jayne"</span>] = <span class="string">"Public Relations"</span></span><br></pre></td></tr></table></figure>
<p>要创建一个空数组或者字典，使用初始化语法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> emptyArray = [<span class="type">String</span>]()</span><br><span class="line"><span class="keyword">let</span> emptyDictionary = [<span class="type">String</span>: <span class="type">Float</span>]()</span><br></pre></td></tr></table></figure>
<p>如果类型信息可以被推断出来，你可以用<code>[]</code>和<code>[:]</code>来创建空数组和空字典——就像你声明变量或者给函数传参数的时候一样。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shoppingList = []</span><br><span class="line">occupations = [:]</span><br></pre></td></tr></table></figure>
<p><a name="control_flow"></a></p>
<h2 id="u63A7_u5236_u6D41"><a href="#u63A7_u5236_u6D41" class="headerlink" title="控制流"></a>控制流</h2><p>使用<code>if</code>和<code>switch</code>来进行条件操作，使用<code>for-in</code>、<code>for</code>、<code>while</code>和<code>repeat-while</code>来进行循环。包裹条件和循环变量括号可以省略，但是语句体的大括号是必须的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> individualScores = [<span class="number">75</span>, <span class="number">43</span>, <span class="number">103</span>, <span class="number">87</span>, <span class="number">12</span>]</span><br><span class="line"><span class="keyword">var</span> teamScore = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> score <span class="keyword">in</span> individualScores &#123;</span><br><span class="line">    <span class="keyword">if</span> score &gt; <span class="number">50</span> &#123;</span><br><span class="line">        teamScore += <span class="number">3</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        teamScore += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(teamScore)</span><br></pre></td></tr></table></figure>
<p>在<code>if</code>语句中，条件必须是一个布尔表达式——这意味着像<code>if score { ... }</code>这样的代码将报错，而不会隐形地与 0 做对比。</p>
<p>你可以一起使用<code>if</code>和<code>let</code>来处理值缺失的情况。这些值可由可选值来代表。一个可选的值是一个具体的值或者是<code>nil</code>以表示值缺失。在类型后面加一个问号来标记这个变量的值是可选的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> optionalString: <span class="type">String</span>? = <span class="string">"Hello"</span></span><br><span class="line"><span class="built_in">print</span>(optionalString == <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> optionalName: <span class="type">String</span>? = <span class="string">"John Appleseed"</span></span><br><span class="line"><span class="keyword">var</span> greeting = <span class="string">"Hello!"</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> name = optionalName &#123;</span><br><span class="line">    greeting = <span class="string">"Hello, <span class="subst">\(name)</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>练习：<br>把<code>optionalName</code>改成<code>nil</code>，greeting会是什么？添加一个<code>else</code>语句，当<code>optionalName</code>是<code>nil</code>时给greeting赋一个不同的值。</p>
</blockquote>
<p>如果变量的可选值是<code>nil</code>，条件会判断为<code>false</code>，大括号中的代码会被跳过。如果不是<code>nil</code>，会将值赋给<code>let</code>后面的常量，这样代码块中就可以使用这个值了。<br>另一种处理可选值的方法是通过使用 ?? 操作符来提供一个默认值。如果可选值缺失的话，可以使用默认值来代替。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nickName: <span class="type">String</span>? = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">let</span> fullName: <span class="type">String</span> = <span class="string">"John Appleseed"</span></span><br><span class="line"><span class="keyword">let</span> informalGreeting = <span class="string">"Hi <span class="subst">\(nickName ?? fullName)</span>"</span></span><br></pre></td></tr></table></figure></p>
<p><code>switch</code>支持任意类型的数据以及各种比较操作——不仅仅是整数以及测试相等。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vegetable = <span class="string">"red pepper"</span></span><br><span class="line"><span class="keyword">switch</span> vegetable &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"celery"</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Add some raisins and make ants on a log."</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"cucumber"</span>, <span class="string">"watercress"</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"That would make a good tea sandwich."</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> x <span class="keyword">where</span> x.hasSuffix(<span class="string">"pepper"</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Is it a spicy <span class="subst">\(x)</span>?"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Everything tastes good in soup."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>练习：<br>删除<code>default</code>语句，看看会有什么错误？</p>
</blockquote>
<p>注意<code>let</code>在上述例子的等式中是如何使用的，它将匹配等式的值赋给常量<code>x</code>。</p>
<p>运行<code>switch</code>中匹配到的子句之后，程序会退出<code>switch</code>语句，并不会继续向下运行，所以不需要在每个子句结尾写<code>break</code>。</p>
<p>你可以使用<code>for-in</code>来遍历字典，需要两个变量来表示每个键值对。字典是一个无序的集合，所以他们的键和值以任意顺序迭代结束。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> interestingNumbers = [</span><br><span class="line">    <span class="string">"Prime"</span>: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>],</span><br><span class="line">    <span class="string">"Fibonacci"</span>: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>],</span><br><span class="line">    <span class="string">"Square"</span>: [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>],</span><br><span class="line">]</span><br><span class="line"><span class="keyword">var</span> largest = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (kind, numbers) <span class="keyword">in</span> interestingNumbers &#123;</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        <span class="keyword">if</span> number &gt; largest &#123;</span><br><span class="line">            largest = number</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(largest)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>练习：<br>添加另一个变量来记录现在和之前最大数字的类型。</p>
</blockquote>
<p>使用<code>while</code>来重复运行一段代码直到不满足条件。循环条件也可以在结尾，保证能至少循环一次。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> n &lt; <span class="number">100</span> &#123;</span><br><span class="line">    n = n * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">2</span></span><br><span class="line"><span class="keyword">repeat</span> &#123;</span><br><span class="line">    m = m * <span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">while</span> m &lt; <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(m)</span><br></pre></td></tr></table></figure>
<p>你可以在循环中使用<code>..&lt;</code>来表示范围，也可以使用传统的写法，两者是等价的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstForLoop = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">4</span> &#123;</span><br><span class="line">    firstForLoop += i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(firstForLoop)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> secondForLoop = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i &#123;</span><br><span class="line">    secondForLoop += i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(secondForLoop)</span><br></pre></td></tr></table></figure>
<p>使用<code>..&lt;</code>创建的范围不包含上界，如果想包含的话需要使用<code>...</code>。</p>
<p><a name="functions_and_closures"></a></p>
<h2 id="u51FD_u6570_u548C_u95ED_u5305"><a href="#u51FD_u6570_u548C_u95ED_u5305" class="headerlink" title="函数和闭包"></a>函数和闭包</h2><p>使用<code>func</code>来声明一个函数，使用名字和参数来调用函数。使用<code>-&gt;</code>来指定函数返回值的类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(name: String, day: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello <span class="subst">\(name)</span>, today is <span class="subst">\(day)</span>."</span></span><br><span class="line">&#125;</span><br><span class="line">greet(<span class="string">"Bob"</span>, day: <span class="string">"Tuesday"</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>练习：<br>删除<code>day</code>参数，添加一个参数来表示今天吃了什么午饭。</p>
</blockquote>
<p>使用元组来让一个函数返回多个值。该元组的元素可以用名称或数字来表示。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">calculateStatistics</span><span class="params">(scores: [Int])</span></span> -&gt; (<span class="built_in">min</span>: <span class="type">Int</span>, <span class="built_in">max</span>: <span class="type">Int</span>, sum: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">min</span> = scores[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">max</span> = scores[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> score <span class="keyword">in</span> scores &#123;</span><br><span class="line">        <span class="keyword">if</span> score &gt; <span class="built_in">max</span> &#123;</span><br><span class="line">            <span class="built_in">max</span> = score</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> score &lt; <span class="built_in">min</span> &#123;</span><br><span class="line">            <span class="built_in">min</span> = score</span><br><span class="line">        &#125;</span><br><span class="line">        sum += score</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">min</span>, <span class="built_in">max</span>, sum)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> statistics = calculateStatistics([<span class="number">5</span>, <span class="number">3</span>, <span class="number">100</span>, <span class="number">3</span>, <span class="number">9</span>])</span><br><span class="line"><span class="built_in">print</span>(statistics.sum)</span><br><span class="line"><span class="built_in">print</span>(statistics.<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>函数可以带有可变个数的参数，这些参数在函数内表现为数组的形式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">sumOf</span><span class="params">(numbers: Int...)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        sum += number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line">sumOf()</span><br><span class="line">sumOf(<span class="number">42</span>, <span class="number">597</span>, <span class="number">12</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>练习：<br>写一个计算参数平均值的函数。</p>
</blockquote>
<p>函数可以嵌套。被嵌套的函数可以访问外侧函数的变量，你可以使用嵌套函数来重构一个太长或者太复杂的函数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">returnFifteen</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">10</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line">        y += <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">    add()</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line">returnFifteen()</span><br></pre></td></tr></table></figure>
<p>函数是第一等类型，这意味着函数可以作为另一个函数的返回值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">makeIncrementer</span><span class="params">()</span></span> -&gt; (<span class="type">Int</span> -&gt; <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">addOne</span><span class="params">(number: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addOne</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> increment = makeIncrementer()</span><br><span class="line">increment(<span class="number">7</span>)</span><br></pre></td></tr></table></figure>
<p>函数也可以当做参数传入另一个函数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">hasAnyMatches</span><span class="params">(list: [Int], condition: Int -&gt; Bool)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> condition(item) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">lessThanTen</span><span class="params">(number: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> number &lt; <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">20</span>, <span class="number">19</span>, <span class="number">7</span>, <span class="number">12</span>]</span><br><span class="line">hasAnyMatches(numbers, condition: lessThanTen)</span><br></pre></td></tr></table></figure>
<p>函数实际上是一种特殊的闭包:它是一段能之后被调取的代码。闭包中的代码能访问闭包所建作用域中能得到的变量和函数，即使闭包是在一个不同的作用域被执行的 - 你已经在嵌套函数例子中所看到。你可以使用<code>{}</code>来创建一个匿名闭包。使用<code>in</code>将参数和返回值类型声明与闭包函数体进行分离。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">numbers.<span class="built_in">map</span>(&#123;</span><br><span class="line">    (number: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">3</span> * number</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>练习：<br>重写闭包，对所有奇数返回0。</p>
</blockquote>
<p>有很多种创建更简洁的闭包的方法。如果一个闭包的类型已知，比如作为一个回调函数，你可以忽略参数的类型和返回值。单个语句闭包会把它语句的值当做结果返回。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mappedNumbers = numbers.<span class="built_in">map</span>(&#123; number <span class="keyword">in</span> <span class="number">3</span> * number &#125;)</span><br><span class="line"><span class="built_in">print</span>(mappedNumbers)</span><br></pre></td></tr></table></figure>
<p>你可以通过参数位置而不是参数名字来引用参数——这个方法在非常短的闭包中非常有用。当一个闭包作为最后一个参数传给一个函数的时候，它可以直接跟在括号后面。当一个闭包是传给函数的唯一参数，你可以完全忽略括号。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sortedNumbers = numbers.<span class="built_in">sort</span> &#123; $<span class="number">0</span> &gt; $<span class="number">1</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(sortedNumbers)</span><br></pre></td></tr></table></figure>
<p><a name="objects_and_classes"></a></p>
<h2 id="u5BF9_u8C61_u548C_u7C7B"><a href="#u5BF9_u8C61_u548C_u7C7B" class="headerlink" title="对象和类"></a>对象和类</h2><p>使用<code>class</code>和类名来创建一个类。类中属性的声明和常量、变量声明一样，唯一的区别就是它们的上下文是类。同样，方法和函数声明也一样。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfSides = <span class="number">0</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A shape with <span class="subst">\(numberOfSides)</span> sides."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>练习：<br>使用<code>let</code>添加一个常量属性，再添加一个接收一个参数的方法。</p>
</blockquote>
<p>要创建一个类的实例，在类名后面加上括号。使用点语法来访问实例的属性和方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shape = <span class="type">Shape</span>()</span><br><span class="line">shape.numberOfSides = <span class="number">7</span></span><br><span class="line"><span class="keyword">var</span> shapeDescription = shape.simpleDescription()</span><br></pre></td></tr></table></figure>
<p>这个版本的<code>Shape</code>类缺少了一些重要的东西：一个构造函数来初始化类实例。使用<code>init</code>来创建一个构造器。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamedShape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfSides: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A shape with <span class="subst">\(numberOfSides)</span> sides."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意<code>self</code>被用来区别实例变量。当你创建实例的时候，像传入函数参数一样给类传入构造器的参数。每个属性都需要赋值——无论是通过声明（就像<code>numberOfSides</code>）还是通过构造器（就像<code>name</code>）。</p>
<p>如果你需要在删除对象之前进行一些清理工作，使用<code>deinit</code>创建一个析构函数。</p>
<p>子类的定义方法是在它们的类名后面加上父类的名字，用冒号分割。创建类的时候并不需要一个标准的根类，所以你可以忽略父类。</p>
<p>子类如果要重写父类的方法的话，需要用<code>override</code>标记——如果没有添加<code>override</code>就重写父类方法的话编译器会报错。编译器同样会检测<code>override</code>标记的方法是否确实在父类中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span>: <span class="title">NamedShape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sideLength: <span class="type">Double</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(sideLength: <span class="type">Double</span>, name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.sideLength = sideLength</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">        numberOfSides = <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">area</span><span class="params">()</span></span> -&gt;  <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sideLength * sideLength</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A square with sides of length <span class="subst">\(sideLength)</span>."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> test = <span class="type">Square</span>(sideLength: <span class="number">5.2</span>, name: <span class="string">"my test square"</span>)</span><br><span class="line">test.area()</span><br><span class="line">test.simpleDescription()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>练习：<br>创建<code>NamedShape</code>的另一个子类<code>Circle</code>，构造器接收两个参数，一个是半径一个是名称，在子类<code>Circle</code>中实现<code>area()</code>和<code>simpleDescription()</code>方法。</p>
</blockquote>
<p>除了储存简单的属性之外，属性可以有 getter 和 setter 。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EquilateralTriangle</span>: <span class="title">NamedShape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sideLength: <span class="type">Double</span> = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(sideLength: <span class="type">Double</span>, name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.sideLength = sideLength</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">        numberOfSides = <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> perimeter: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3.0</span> * sideLength</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            sideLength = newValue / <span class="number">3.0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"An equilateral triagle with sides of length <span class="subst">\(sideLength)</span>."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> triangle = <span class="type">EquilateralTriangle</span>(sideLength: <span class="number">3.1</span>, name: <span class="string">"a triangle"</span>)</span><br><span class="line"><span class="built_in">print</span>(triangle.perimeter)</span><br><span class="line">triangle.perimeter = <span class="number">9.9</span></span><br><span class="line"><span class="built_in">print</span>(triangle.sideLength)</span><br></pre></td></tr></table></figure>
<p>在<code>perimeter</code>的 setter 中，新值的名字是<code>newValue</code>。你可以在<code>set</code>之后显式的设置一个名字。</p>
<p>注意<code>EquilateralTriangle</code>类的构造器执行了三步：</p>
<ol>
<li>设置子类声明的属性值</li>
<li>调用父类的构造器</li>
<li>改变父类定义的属性值。其他的工作比如调用方法、getters和setters也可以在这个阶段完成。</li>
</ol>
<p>如果你不需要计算属性，但是仍然需要在设置一个新值之前或者之后运行代码，使用<code>willSet</code>和<code>didSet</code>。</p>
<p>比如，下面的类确保三角形的边长总是和正方形的边长相同。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TriangleAndSquare</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> triangle: <span class="type">EquilateralTriangle</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            square.sideLength = newValue.sideLength</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> square: <span class="type">Square</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            triangle.sideLength = newValue.sideLength</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(size: <span class="type">Double</span>, name: <span class="type">String</span>) &#123;</span><br><span class="line">        square = <span class="type">Square</span>(sideLength: size, name: name)</span><br><span class="line">        triangle = <span class="type">EquilateralTriangle</span>(sideLength: size, name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> triangleAndSquare = <span class="type">TriangleAndSquare</span>(size: <span class="number">10</span>, name: <span class="string">"another test shape"</span>)</span><br><span class="line"><span class="built_in">print</span>(triangleAndSquare.square.sideLength)</span><br><span class="line"><span class="built_in">print</span>(triangleAndSquare.triangle.sideLength)</span><br><span class="line">triangleAndSquare.square = <span class="type">Square</span>(sideLength: <span class="number">50</span>, name: <span class="string">"larger square"</span>)</span><br><span class="line"><span class="built_in">print</span>(triangleAndSquare.triangle.sideLength)</span><br></pre></td></tr></table></figure>
<p>处理变量的可选值时，你可以在操作（比如方法、属性和子脚本）之前加<code>?</code>。如果<code>?</code>之前的值是<code>nil</code>，<code>?</code>后面的东西都会被忽略，并且整个表达式返回<code>nil</code>。否则，<code>?</code>之后的东西都会被运行。在这两种情况下，整个表达式的值也是一个可选值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> optionalSquare: <span class="type">Square</span>? = <span class="type">Square</span>(sideLength: <span class="number">2.5</span>, name: <span class="string">"optional square"</span>)</span><br><span class="line"><span class="keyword">let</span> sideLength = optionalSquare?.sideLength</span><br></pre></td></tr></table></figure>
<p><a name="enumerations_and_structure"></a></p>
<h2 id="u679A_u4E3E_u548C_u7ED3_u6784_u4F53"><a href="#u679A_u4E3E_u548C_u7ED3_u6784_u4F53" class="headerlink" title="枚举和结构体"></a>枚举和结构体</h2><p>使用<code>enum</code>来创建一个枚举。就像类和其他所有命名类型一样，枚举可以包含方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Rank</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Ace</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Two</span>, <span class="type">Three</span>, <span class="type">Four</span>, <span class="type">Five</span>, <span class="type">Six</span>, <span class="type">Seven</span>, <span class="type">Eight</span>, <span class="type">Nine</span>, <span class="type">Ten</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Jack</span>, <span class="type">Queen</span>, <span class="type">King</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Ace</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"ace"</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Jack</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"jack"</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Queen</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"queen"</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">King</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"king"</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">String</span>(<span class="keyword">self</span>.rawValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ace = <span class="type">Rank</span>.<span class="type">Ace</span></span><br><span class="line"><span class="keyword">let</span> aceRawValue = ace.rawValue</span><br></pre></td></tr></table></figure>
<blockquote>
<p>练习：<br>写一个函数，通过比较它们的原始值来比较两个<code>Rank</code>值。</p>
</blockquote>
<p>在上面的例子中，枚举原始值的类型是<code>Int</code>，所以你只需要设置第一个原始值。剩下的原始值会按照顺序赋值。你也可以使用字符串或者浮点数作为枚举的原始值。使用<code>rawValue</code>属性来访问一个枚举成员的原始值。</p>
<p>使用<code>init?(rawValue:)</code>初始化构造器在原始值和枚举值之间进行转换。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> convertedRank = <span class="type">Rank</span>(rawValue: <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> threeDescription = convertedRank.simpleDescription()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举的成员值是实际值，并不是原始值的另一种表达方法。实际上，以防原始值没有意义，你不需要设置。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Suit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Spades</span>, <span class="type">Hearts</span>, <span class="type">Diamonds</span>, <span class="type">Clubs</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Spades</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"spades"</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Hearts</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"hearts"</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Diamonds</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"diamonds"</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Clubs</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"clubs"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> hearts = <span class="type">Suit</span>.<span class="type">Hearts</span></span><br><span class="line"><span class="keyword">let</span> heartsDescription = hearts.simpleDescription()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>练习：<br>给<code>Suit</code>添加一个<code>color()</code>方法，对<code>spades</code>和<code>clubs</code>返回“black”，对<code>hearts</code>和<code>diamonds</code>返回“red”。</p>
</blockquote>
<p>注意，有两种方式可以引用<code>Hearts</code>成员：给<code>hearts</code>常量赋值时，枚举成员<code>Suit.Hearts</code>需要用全名来引用，因为常量没有显式指定类型。在<code>switch</code>里，枚举成员使用缩写<code>.Hearts</code>来引用，因为<code>self</code>的值已经知道是一个<code>suit</code>。已知变量类型的情况下你可以使用缩写。</p>
<p>使用<code>struct</code>来创建一个结构体。结构体和类有很多相同的地方，比如方法和构造器。它们之间最大的一个区别就是结构体是传值，类是传引用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Card</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rank: <span class="type">Rank</span></span><br><span class="line">    <span class="keyword">var</span> suit: <span class="type">Suit</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"The <span class="subst">\(rank.simpleDescription()</span>) of <span class="subst">\(suit.simpleDescription()</span>)"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> threeOfSpades = <span class="type">Card</span>(rank: .<span class="type">Three</span>, suit: .<span class="type">Spades</span>)</span><br><span class="line"><span class="keyword">let</span> threeOfSpadesDescription = threeOfSpades.simpleDescription()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>练习：<br>给<code>Card</code>添加一个方法，创建一副完整的扑克牌并把每张牌的 rank 和 suit 对应起来。</p>
</blockquote>
<p>一个枚举成员的实例可以有实例值。相同枚举成员的实例可以有不同的值。创建实例的时候传入值即可。实例值和原始值是不同的：枚举成员的原始值对于所有实例都是相同的，而且你是在定义枚举的时候设置原始值。</p>
<p>例如，考虑从服务器获取日出和日落的时间。服务器会返回正常结果或者错误信息。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ServerResponse</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Result</span>(<span class="type">String</span>, <span class="type">String</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Error</span>(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> success = <span class="type">ServerResponse</span>.<span class="type">Result</span>(<span class="string">"6:00 am"</span>, <span class="string">"8:09 pm"</span>)</span><br><span class="line"><span class="keyword">let</span> failure = <span class="type">ServerResponse</span>.<span class="type">Error</span>(<span class="string">"Out of cheese."</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">switch</span> success &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Result</span>(sunrise, sunset):</span><br><span class="line">    <span class="keyword">let</span> serverResponse = <span class="string">"Sunrise is at <span class="subst">\(sunrise)</span> and sunset is at <span class="subst">\(sunset)</span>."</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Error</span>(error):</span><br><span class="line">    <span class="keyword">let</span> serverResponse = <span class="string">"Failure...  <span class="subst">\(error)</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>练习：<br>给<code>ServerResponse</code>和<code>switch</code>添加第三种情况。</p>
</blockquote>
<p>注意如何从<code>ServerResponse</code>中提取日升和日落时间并用得到的值用来和<code>switch</code>的情况作比较。</p>
<p><a name="protocols_and_extensions"></a></p>
<h2 id="u534F_u8BAE_u548C_u6269_u5C55"><a href="#u534F_u8BAE_u548C_u6269_u5C55" class="headerlink" title="协议和扩展"></a>协议和扩展</h2><p>使用<code>protocol</code>来声明一个协议。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ExampleProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">adjust</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类、枚举和结构体都可以实现协议。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleClass</span>: <span class="title">ExampleProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> = <span class="string">"A very simple class."</span></span><br><span class="line">    <span class="keyword">var</span> anotherProperty: <span class="type">Int</span> = <span class="number">69105</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">adjust</span><span class="params">()</span></span> &#123;</span><br><span class="line">        simpleDescription += <span class="string">"  Now 100% adjusted."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="type">SimpleClass</span>()</span><br><span class="line">a.adjust()</span><br><span class="line"><span class="keyword">let</span> aDescription = a.simpleDescription</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SimpleStructure</span>: <span class="title">ExampleProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> = <span class="string">"A simple structure"</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">adjust</span><span class="params">()</span></span> &#123;</span><br><span class="line">        simpleDescription += <span class="string">" (adjusted)"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="type">SimpleStructure</span>()</span><br><span class="line">b.adjust()</span><br><span class="line"><span class="keyword">let</span> bDescription = b.simpleDescription</span><br></pre></td></tr></table></figure>
<blockquote>
<p>练习：<br>写一个实现这个协议的枚举。</p>
</blockquote>
<p>注意声明<code>SimpleStructure</code>时候<code>mutating</code>关键字用来标记一个会修改结构体的方法。<code>SimpleClass</code>的声明不需要标记任何方法，因为类中的方法通常可以修改类属性（类的性质）。</p>
<p>使用<code>extension</code>来为现有的类型添加功能，比如新的方法和计算属性。你可以使用扩展在别处修改定义，甚至是从外部库或者框架引入的一个类型，使得这个类型遵循某个协议。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span>: <span class="title">ExampleProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"The number <span class="subst">\(<span class="keyword">self</span>)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">adjust</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span> += <span class="number">42</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="number">7</span>.simpleDescription)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>练习：<br>给<code>Double</code>类型写一个扩展，添加<code>absoluteValue</code>功能。</p>
</blockquote>
<p>你可以像使用其他命名类型一样使用协议名——例如，创建一个有不同类型但是都实现一个协议的对象集合。当你处理类型是协议的值时，协议外定义的方法不可用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> protocolValue: <span class="type">ExampleProtocol</span> = a</span><br><span class="line"><span class="built_in">print</span>(protocolValue.simpleDescription)</span><br><span class="line"><span class="comment">// print(protocolValue.anotherProperty)  // Uncomment to see the error</span></span><br></pre></td></tr></table></figure>
<p>即使<code>protocolValue</code>变量运行时的类型是<code>simpleClass</code>，编译器会把它的类型当做<code>ExampleProtocol</code>。这表示你不能调用类在它实现的协议之外实现的方法或者属性。</p>
<p><a name="generics"></a></p>
<h2 id="u6CDB_u578B"><a href="#u6CDB_u578B" class="headerlink" title="泛型"></a>泛型</h2><p>在尖括号里写一个名字来创建一个泛型函数或者类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">repeatItem</span><span class="generics">&lt;Item&gt;</span><span class="params">(item: Item, numberOfTimes: Int)</span></span> -&gt; [<span class="type">Item</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> result = [<span class="type">Item</span>]()</span><br><span class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;numberOfTimes &#123;</span><br><span class="line">        result.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">repeatItem(<span class="string">"knock"</span>, numberOfTimes:<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>你也可以创建泛型函数、方法、类、枚举和结构体。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reimplement the Swift standard library's optional type</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">OptionalValue</span>&lt;<span class="title">Wrapped</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">None</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Some</span>(<span class="type">Wrapped</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> possibleInteger: <span class="type">OptionalValue</span>&lt;<span class="type">Int</span>&gt; = .<span class="type">None</span></span><br><span class="line">possibleInteger = .<span class="type">Some</span>(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>在类型名后面使用<code>where</code>来指定对类型的需求，比如，限定类型实现某一个协议，限定两个类型是相同的，或者限定某个类必须有一个特定的父类。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">anyCommonElements</span> <span class="generics">&lt;T: SequenceType, U: SequenceType where T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element&gt;</span> <span class="params">(lhs: T, <span class="number">_</span> rhs: U)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> lhsItem <span class="keyword">in</span> lhs &#123;</span><br><span class="line">        <span class="keyword">for</span> rhsItem <span class="keyword">in</span> rhs &#123;</span><br><span class="line">            <span class="keyword">if</span> lhsItem == rhsItem &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">anyCommonElements([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<blockquote>
<p>练习：<br>修改<code>anyCommonElements(_:_:)</code>函数来创建一个函数，返回一个数组，内容是两个序列的共有元素。</p>
</blockquote>
<p><code>&lt;T: Equatable&gt;</code>和<code>&lt;T where T: Equatable&gt;</code>是等价的。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter1/03_revision_history/" itemprop="url">
                第一章-03Swift 版本历史记录
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T21:00:00+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter1/03_revision_history/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter1/03_revision_history/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="Swift__u7248_u672C_u5386_u53F2_u8BB0_u5F55"><a href="#Swift__u7248_u672C_u5386_u53F2_u8BB0_u5F55" class="headerlink" title="Swift 版本历史记录"></a>Swift 版本历史记录</h1><hr>
<blockquote>
<p>翻译：<a href="http://weibo.com/littlekok/" target="_blank" rel="external">成都老码团队翻译组-Arya</a><br>校对：<a href="http://weibo.com/u/5241713117" target="_blank" rel="external">成都老码团队翻译组-Oberyn</a></p>
</blockquote>
<p>本页内容包括：</p>
<ul>
<li><a href="/#xcode6_4_Beta">XCode6.4 Beta Swift语法文档更新</a></li>
<li><a href="/#xcode6_3">XCode6.3正式版 Swift语法文档更新</a></li>
<li><a href="/#xcode6_2">XCode6.2正式版 Swift语法文档更新</a></li>
<li><a href="/#xcode6_2_Beta3">XCode6.2 Beta3 Swift语法文档更新</a></li>
<li><a href="/#xcode6_2_Beta2">XCode6.2 Beta2 Swift语法文档更新</a></li>
<li><a href="/#xcode6_2_Beta1">XCode6.2 Beta1 Swift语法文档更新</a></li>
<li><a href="/#xcode6_1_1">XCode6.1.1正式版 Swift语法文档更新</a></li>
<li><a href="/#xcode6_1">XCode6.1 Swift语法文档更新</a></li>
<li><a href="/#xcode6_1_Beta2">XCode6.1 Beta2 Swift语法文档更新</a></li>
<li><a href="/#xcode6_1_Beta1">XCode6.1 Beta1 Swift语法文档更新</a></li>
<li><a href="/#xcode6_beta7">XCode6 Beta7 Swift语法文档更新</a></li>
<li><a href="/#xcode6_beta6">XCode6 Beta6 Swift语法文档更新</a></li>
<li><a href="/#xcode6_beta5">XCode6 Beta5 Swift语法文档更新</a></li>
<li><a href="/#xcode6_beta4">XCode6 Beta4 Swift语法文档更新</a></li>
<li><a href="/#xcode6_beta3">XCode6 Beta3 Swift语法文档更新</a></li>
<li><a href="/#xcode6_beta2">XCode6 Beta2 Swift语法文档更新</a></li>
<li><a href="/#xcode6_beta1">XCode6 Beta1 Swift语法文档更新</a></li>
<li>XCode6下载: <a href="http://pan.baidu.com/disk/home#from=share_pan_logo&amp;path=%252F%25E8%2580%2581%25E7%25A0%2581%25E4%25BA%2591%25E7%259B%2598-XCode6%252FXCode6-Beta5" target="_blank" rel="external">老码云盘下载</a></li>
</ul>
<p>以下部分是针对XCode6每一次Beta版本直至正式版发布，Swift语法部分的更新归类</p>
<p><a name="xcode6_4_Beta"></a></p>
<h3 id="XCode6-4_Beta_u4E2DSwift_u8BED_u6CD5_u66F4_u65B0"><a href="#XCode6-4_Beta_u4E2DSwift_u8BED_u6CD5_u66F4_u65B0" class="headerlink" title="XCode6.4 Beta中Swift语法更新"></a>XCode6.4 Beta中Swift语法更新</h3><p><strong><em>注意：苹果在这个版本发布后没有及时的更新Swift Programming Language文档,以下是<a href="http://weibo.com/u/5241713117" target="_blank" rel="external">老码团队</a>通过XCode6.4 Beta Release Note总结的更改说明：</em></strong></p>
<table class="graybox" border="0" cellspacing="0" cellpadding="5"><br><thead><br>    <tr><br>        <th scope="col" width="100">发布日期</th><br>        <th scope="col">语法变更记录</th><br>    </tr><br></thead><br><tbody><br>    <tr><br>    <td scope="row">2015-04-13</td><br>    <td><ul class="list-bullet"><br>        <li><br>            XCode6.4包含了对于构建和调试基于iOS8.4 App的支持<br>        </li><br>        </ul><br>    </td><br>  </tr><br></tbody><br></table>

<p><a name="xcode6_3"></a></p>
<h3 id="XCode6-3_u4E2DSwift_u8BED_u6CD5_u66F4_u65B0"><a href="#XCode6-3_u4E2DSwift_u8BED_u6CD5_u66F4_u65B0" class="headerlink" title="XCode6.3中Swift语法更新"></a>XCode6.3中Swift语法更新</h3><p><strong><em>注意：苹果此时发布了统一的版本XCode6.3，其中将以前的XCode6.3 Beta系列版本合并, 而XCode6.3共计发布了4次Beta版本，<a href="http://weibo.com/u/5241713117" target="_blank" rel="external">老码团队</a>通过Release Note总结的详细更改说明请参看:<a href="https://docs.baihui.com/sheet/published.do?rid=mxpis6d36a8b7bc254c36ae2a808c64c2361e" target="_blank" rel="external">Swift语法更新记录表格</a></em></strong></p>
<table class="graybox" border="0" cellspacing="0" cellpadding="5"><br><thead><br>    <tr><br>        <th scope="col" width="100">发布日期</th><br>        <th scope="col">语法变更记录</th><br>    </tr><br></thead><br><tbody><br>    <tr><br>    <td scope="row">2015-4-8</td><br>    <td><ul class="list-bullet"><br>            <li><br>                Swift现在自身提供了一个<code>Set</code>集合类型，更多信息请看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/CollectionTypes.html#//apple_ref/doc/uid/TP40014097-CH8-ID484" target="_blank" rel="external">集合</a><br><br>            </li><br>            <li><br>                <code>@autoclosure</code>现在是一个参数声明的属性，而不是参数类型的属性。这里还有一个新的参数声明属性<code>@noescape</code>。更多信息，请看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/doc/uid/TP40014097-CH35-ID348" target="_blank" rel="external">属性声明</a><br>            </li><br>            <li><br>                对于类型属性和方法现在可以使用<code>static</code>关键字作为声明描述符，更多信息，请看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID483" target="_blank" rel="external">类型变量属性</a><br>            </li><br>            <li><br>                Swift现在包含一个<code>as?</code>和<code>as!</code>的向下可失败类型转换运算符。更多信息，请看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID283" target="_blank" rel="external">协议遵循性检查</a><br>            </li><br>            <li><br>                增加了一个新的指导章节，它是关于<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html#//apple_ref/doc/uid/TP40014097-CH7-ID495" target="_blank" rel="external">字符串索引</a>的<br>            </li><br>            <li><br>                从<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AdvancedOperators.html#//apple_ref/doc/uid/TP40014097-CH27-ID37" target="_blank" rel="external">溢出运算符</a>中移除了溢出除运算符和求余溢出运算符<br>            </li><br>            <li><br>                更新了常量和常量属性在声明和构造时的规则，更多信息，请看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID355" target="_blank" rel="external">常量声明</a><br>            </li><br>            <li><br>                更新了字符串字面量中Unicode标量集的定义，请看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html#//apple_ref/doc/uid/TP40014097-CH7-ID295" target="_blank" rel="external">字符串字面量中的特殊字符</a><br>            </li><br>            <li><br>                更新了<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-ID73" target="_blank" rel="external">区间运算符</a>章节来提示当半开区间运算符含有相同的起止索引时，其区间为空。<br>            </li><br>            <li><br>                更新了<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-ID104" target="_blank" rel="external">闭包引用类型</a>章节来澄清对于变量的捕获规则<br>            </li><br>            <li><br>                更新了<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AdvancedOperators.html#//apple_ref/doc/uid/TP40014097-CH27-ID38" target="_blank" rel="external">值溢出</a>章节来澄清有符号整数和无符号整数的溢出行为<br>            </li><br>            <li><br>                更新了<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID369" target="_blank" rel="external">协议声明</a>章节来澄清协议声明时的作用域和成员<br>            </li><br>            <li><br>                更新了<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html#//apple_ref/doc/uid/TP40014097-CH20-ID58" target="_blank" rel="external">捕获列表</a>章节来澄清对于闭包捕获列表中的弱引用和无主引用的使用语法。<br>            </li><br>            <li><br>                更新了<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/doc/uid/TP40014097-CH30-ID418" target="_blank" rel="external">运算符</a>章节来明确指明一些例子来说明自定义运算符所支持的特性，如数学运算符，各种符号，Unicode符号块等<br>            </li><br>        </ul><br>    </td><br>  </tr><br></tbody><br></table>

<p><a name="xcode6_2"></a></p>
<h3 id="XCode6-2_u6B63_u5F0F_u7248_u4E2DSwift_u8BED_u6CD5_u66F4_u65B0"><a href="#XCode6-2_u6B63_u5F0F_u7248_u4E2DSwift_u8BED_u6CD5_u66F4_u65B0" class="headerlink" title="XCode6.2正式版中Swift语法更新"></a>XCode6.2正式版中Swift语法更新</h3><p><strong><em>注意：苹果此时发布了统一的版本XCode6.2，其中将以前的XCode6.2 Beta系列版本合并</em></strong></p>
<table class="graybox" border="0" cellspacing="0" cellpadding="5"><br><thead><br>    <tr><br>        <th scope="col" width="100">发布日期</th><br>        <th scope="col">语法变更记录</th><br>    </tr><br></thead><br><tbody><br>    <tr><br>    <td scope="row">2015-02-09</td><br>    <td><ul class="list-bullet"><br>        <li><br>            在函数作用域中的常量声明时可以不被初始化，它必须在第一次使用前被赋值。更多的信息，请看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID355" target="_blank" rel="external">常量声明</a><br>        </li><br>        <li><br>            在构造器中，常量属性有且仅能被赋值一次。更多信息，请看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID212" target="_blank" rel="external">在构造过程中给常量属性赋值</a><br>        </li><br>        <li><br>            多个可选绑定现在可以在<code>if</code>语句后面以逗号分隔的赋值列表的方式出现，更多信息，请看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID333" target="_blank" rel="external">可选绑定</a><br>        </li><br>        <li><br>            一个<a link="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/doc/uid/TP40014097-CH32-ID405">可选链表达式</a>必须出现在后缀表达式中<br>        </li><br>        <li><br>            协议类型转换不再局限于<code>@obj</code>修饰的协议了<br>        </li><br>        <li><br>            在运行时可能会失败的类型转换可以使用<code>as?</code>和<code>as!</code>运算符，而确保不会失败的类型转换现在使用<code>as</code>运算符。更多信息，请看<a link="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/doc/uid/TP40014097-CH32-ID388">类型转换运算符</a><br>        </li><br>        </ul><br>    </td><br>  </tr><br></tbody><br></table>

<p><a name="xcode6_2_Beta3"></a></p>
<h3 id="XCode6-2_Beta3_u4E2DSwift_u8BED_u6CD5_u66F4_u65B0"><a href="#XCode6-2_Beta3_u4E2DSwift_u8BED_u6CD5_u66F4_u65B0" class="headerlink" title="XCode6.2 Beta3中Swift语法更新"></a>XCode6.2 Beta3中Swift语法更新</h3><p><strong><em>注意：苹果在这个版本发布后没有及时的更新Swift Programming Language文档,以下是<a href="http://weibo.com/u/5241713117" target="_blank" rel="external">老码团队</a>通过XCode6.2 Beta3 Release Note总结的更改说明：</em></strong></p>
<table class="graybox" border="0" cellspacing="0" cellpadding="5"><br><thead><br>    <tr><br>        <th scope="col" width="100">发布日期</th><br>        <th scope="col">语法变更记录</th><br>    </tr><br></thead><br><tbody><br>    <tr><br>    <td scope="row">2014-12-19</td><br>    <td><br>        <ul class="list-bullet"><br>            <li><br>                在对Watch App做消息通知模拟调试时，第一个payload.apns文件将会被默认选择<br>            </li><br>            <li><br>                在为Watch App使用asset catalog时，38mm和42mm尺寸的图片就会被使用<br>            </li><br>            <li><br>                在做Watch App开发时,<code>@IBAction</code>属性支持<code>WKInterfaceSwitch</code>和<code>WKInterfaceSlider</code> Swift类型了<br>            </li><br>            <li><br>                现在可以通过Device窗口安装，删除和访问App容器中的数据了。<br>            </li><br>        </ul><br>    </td><br>  </tr><br></tbody><br></table>

<p><a name="xcode6_2_Beta2"></a></p>
<h3 id="XCode6-2_Beta2_u4E2DSwift_u8BED_u6CD5_u66F4_u65B0"><a href="#XCode6-2_Beta2_u4E2DSwift_u8BED_u6CD5_u66F4_u65B0" class="headerlink" title="XCode6.2 Beta2中Swift语法更新"></a>XCode6.2 Beta2中Swift语法更新</h3><p><strong><em>注意：苹果在这个版本发布后没有及时的更新Swift Programming Language文档,以下是<a href="http://weibo.com/u/5241713117" target="_blank" rel="external">老码团队</a>通过XCode6.2 Beta2 Release Note总结的更改说明：</em></strong></p>
<table class="graybox" border="0" cellspacing="0" cellpadding="5"><br><thead><br>    <tr><br>        <th scope="col" width="100">发布日期</th><br>        <th scope="col">语法变更记录</th><br>    </tr><br></thead><br><tbody><br>    <tr><br>    <td scope="row">2014-12-10</td><br>    <td><ul class="list-bullet"><br>        <li><br>            现在在Interface Builder中可以针对特定的Device设备自定义Watch应用的Layout布局了<br>        </li><br>        </ul><br>    </td><br>  </tr><br></tbody><br></table>

<p><a name="xcode6_2_Beta1"></a></p>
<h3 id="XCode6-2_Beta1_u4E2DSwift_u8BED_u6CD5_u66F4_u65B0"><a href="#XCode6-2_Beta1_u4E2DSwift_u8BED_u6CD5_u66F4_u65B0" class="headerlink" title="XCode6.2 Beta1中Swift语法更新"></a>XCode6.2 Beta1中Swift语法更新</h3><p><strong><em>注意：苹果在这个版本发布后没有及时的更新Swift Programming Language文档,以下是<a href="http://weibo.com/u/5241713117" target="_blank" rel="external">老码团队</a>通过XCode6.2 Beta1 Release Note总结的更改说明：</em></strong></p>
<table class="graybox" border="0" cellspacing="0" cellpadding="5"><br><thead><br>    <tr><br>        <th scope="col" width="100">发布日期</th><br>        <th scope="col">语法变更记录</th><br>    </tr><br></thead><br><tbody><br>    <tr><br>    <td scope="row">2014-11-28</td><br>    <td><ul class="list-bullet"><br>        <li><br>            XCode6.2包含了iOS8.2 SDK，该SDK中包含WatchKit用来开发Apple Watch应用。<br>        </li><br>        <li><br>            在工具集中增加了对WatchKit的支持：<br>            1）UI设计工具增加了Apple Watch应用的界面组件，通知和小部件。<br>            2）增加了调试和性能统计功能<br>            3）增加Apple Watch应用的模拟器帮助调试应用功能<br>        </li><br>        <li><br>            为了使Apple Watch应用能够正常工作，一些具体的参数必须设置：<br>            1）WatchKit中扩展配置文件Info.plist中的<code>NSExtensionAttributes</code>配置项WKAppBundleIdentifier必须和WatchKit App中的通用配置文件中的属性<code>CFBundleIdentifier</code>项目保持一致。2）WatchKit中的<code>CFBundleIdentifier</code>配置项必须和<code>WKCompanionAppBundleIdentifier</code>中的配置项保持一致<br>        </li><br>        </ul><br>    </td><br>  </tr><br></tbody><br></table>

<p><a name="xcode6_1_1"></a></p>
<h3 id="XCode6-1-1_u4E2DSwift_u8BED_u6CD5_u66F4_u65B0"><a href="#XCode6-1-1_u4E2DSwift_u8BED_u6CD5_u66F4_u65B0" class="headerlink" title="XCode6.1.1中Swift语法更新"></a>XCode6.1.1中Swift语法更新</h3><p><strong><em>注意：苹果在这个版本发布后没有及时的更新Swift Programming Language文档,以下是<a href="http://weibo.com/u/5241713117" target="_blank" rel="external">老码团队</a>通过XCode6.1.1 Release Note总结的更改说明：</em></strong></p>
<table class="graybox" border="0" cellspacing="0" cellpadding="5"><br><thead><br>    <tr><br>        <th scope="col" width="100">发布日期</th><br>        <th scope="col">语法变更记录</th><br>    </tr><br></thead><br><tbody><br>    <tr><br>    <td scope="row">2014-12-2</td><br>    <td><ul class="list-bullet"><br>        <li><br>            在SourceKit中一些导致Crash的常见问题被修复，比如名字冲突和遗留废弃数据的问题等。<br>        </li><br>        <li><br>            把纯正的Swift类对象实例赋值给AnyObject量不会再Crash了。<br>        </li><br>        <li><br>            在泛型使用场景下，遵循了协议类要求的构造器方法或者类型方法可以直接调用继承类中的方法了。<br>        </li><br>        <li><br>            修正了InterfaceBuild中如果图片名字含有“/”时，会在OSX10.10上Crash或者无法打开的问题<br>        </li><br>        </ul><br>    </td><br>  </tr><br></tbody><br></table>

<p><a name="xcode6_1"></a></p>
<h3 id="XCode6-1_u4E2DSwift_u8BED_u6CD5_u66F4_u65B0"><a href="#XCode6-1_u4E2DSwift_u8BED_u6CD5_u66F4_u65B0" class="headerlink" title="XCode6.1中Swift语法更新"></a>XCode6.1中Swift语法更新</h3><p><strong><em>注意：苹果此时发布了统一的版本XCode6.1，其中将以前的XCode6.0.1和XCode6.1 Beta系列版本合并</em></strong></p>
<table class="graybox" border="0" cellspacing="0" cellpadding="5"><br><thead><br>    <tr><br>        <th scope="col" width="100">发布日期</th><br>        <th scope="col">语法变更记录</th><br>    </tr><br></thead><br><tbody><br>    <tr><br>    <td scope="row">2014-10-16</td><br>    <td><ul class="list-bullet"><br>        <li><br>            增加了一个完整的关于<a href="http://developer.apple.com/library/etc/redirect/xcode/devtools/419f35/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html" target="_blank" rel="external">失败构造器(Failable Initializers)</a>的指南文档<br>        </li><br>        <li><br>            增加了一个关于协议的<a href="http://developer.apple.com/library/etc/redirect/xcode/devtools/419f35/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html" target="_blank" rel="external">失败构造器需求(Failable Initializer Requirements)</a>的描述<br>        </li><br>        <li><br>            <code>Any</code>类型的常量或变量现在可以包含一个函数实例了。同时更新了<a href="http://developer.apple.com/library/etc/redirect/xcode/devtools/419f35/documentation/Swift/Conceptual/Swift_Programming_Language/TypeCasting.html" target="_blank" rel="external"><code>Any</code></a>章节的案例用来演示如何在swith语句中检查和转换一个函数类型。<br>        </li><br>        </ul><br>    </td><br>  </tr><br></tbody><br></table>

<p><a name="xcode6_1_Beta2"></a></p>
<h3 id="XCode6-1_Beta2_u4E2DSwift_u8BED_u6CD5_u66F4_u65B0"><a href="#XCode6-1_Beta2_u4E2DSwift_u8BED_u6CD5_u66F4_u65B0" class="headerlink" title="XCode6.1 Beta2中Swift语法更新"></a>XCode6.1 Beta2中Swift语法更新</h3><p><strong><em>注意：苹果此时发布了XCode6.0.1版本(也称为XCode6正式版)，此版本用于iOS的开发，同时也发布子版本XCode6.1 Beta2，此版本为OSX开发做准备，以下所述的更改仅对XCode6.1 Beta2有效</em></strong></p>
<table class="graybox" border="0" cellspacing="0" cellpadding="5"><br><thead><br>    <tr><br>        <th scope="col" width="100">发布日期</th><br>        <th scope="col">语法变更记录</th><br>    </tr><br></thead><br><tbody><br>    <tr><br>    <td scope="row">2014-09-15</td><br>    <td><ul class="list-bullet"><br>        <li><br>            带有原始值的枚举类型增加了一个<code>rawValue</code>属性替代<code>toRaw()</code>方法，同时使用了一个以<code>rawValue</code>为参数的失败构造器来替代<code>fromRaw()</code>方法。更多的信息，请看<a href="http://developer.apple.com/library/etc/redirect/xcode/devtools/419f35/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html" target="_blank" rel="external">原始值(Raw Values)</a>和<a href="http://developer.apple.com/library/etc/redirect/xcode/devtools/419f35/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html" target="_blank" rel="external">带原始值的枚举类型(Enumerations with Cases of a Raw-Value Type)</a>部分<br>        </li><br>        </ul><br>    </td><br>  </tr><br></tbody><br></table>

<p><a name="xcode6_1_Beta1"></a></p>
<h3 id="XCode6-1_Beta1_u4E2DSwift_u8BED_u6CD5_u66F4_u65B0"><a href="#XCode6-1_Beta1_u4E2DSwift_u8BED_u6CD5_u66F4_u65B0" class="headerlink" title="XCode6.1 Beta1中Swift语法更新"></a>XCode6.1 Beta1中Swift语法更新</h3><p><strong><em>注意：苹果此时发布了XCode6 GM版本，此版本用于iOS的开发，同时也发布子版本XCode6.1 Beta1，此版本为OSX开发做准备，以下所述的更改仅对XCode6.1 Beta1有效</em></strong></p>
<table class="graybox" border="0" cellspacing="0" cellpadding="5"><br><thead><br>    <tr><br>        <th scope="col" width="100">发布日期</th><br>        <th scope="col">语法变更记录</th><br>    </tr><br></thead><br><tbody><br>    <tr><br>    <td scope="row">2014-09-09</td><br>    <td><ul class="list-bullet"><br>        <li><br>            增加了一个新的关于<a href="http://developer.apple.com/library/etc/redirect/xcode/devtools/419f35/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html" target="_blank" rel="external">失败构造器(Failable Initializers)</a>的参考章节,失败构造器可以触发失败的构造过程<br>        </li><br>        <li><br>            自定义运算符现在可以包含<code>?</code>字符，更新的<a href="http://developer.apple.com/library/etc/redirect/xcode/devtools/419f35/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html" target="_blank" rel="external">运算符(Operators)</a>章节描述了改进后的规则，并且从<a href="http://developer.apple.com/library/etc/redirect/xcode/devtools/419f35/documentation/Swift/Conceptual/Swift_Programming_Language/AdvancedOperators.html" target="_blank" rel="external">自定义运算符(Custom Operators)</a>章节删除了重复的运算符有效字符集合<br>        </li><br>        </ul><br>    </td><br>  </tr><br></tbody><br></table>

<p><a name="xcode6_beta7"></a></p>
<h3 id="XCode6_Beta7_u4E2DSwift_u8BED_u6CD5_u66F4_u65B0"><a href="#XCode6_Beta7_u4E2DSwift_u8BED_u6CD5_u66F4_u65B0" class="headerlink" title="XCode6 Beta7中Swift语法更新"></a>XCode6 Beta7中Swift语法更新</h3><p><strong><em>注意：苹果在这个版本发布后没有及时的更新Swift Programming Language文档,以下是<a href="http://weibo.com/u/5241713117" target="_blank" rel="external">老码团队</a>通过XCode Beta7 Release Note总结的更改说明：</em></strong></p>
<table class="graybox" border="0" cellspacing="0" cellpadding="5"><br><thead><br>    <tr><br>        <th scope="col" width="100">发布日期</th><br>        <th scope="col">语法变更记录</th><br>    </tr><br></thead><br><tbody><br>    <tr><br>    <td scope="row">2014-09-03</td><br>    <td><ul class="list-bullet"><br>        <li><br>            实现了内部库的修改和适配，主要包括如下：<br>            1）大量内部类或者函数遵循Optional类型和协议<br>            2）移除大部分函数返回类型隐式解封可选类型的使用<br><br>        </li><br>        <li><br>            对于泛型的类库函数或接口统一从<code>T!</code>更换为<code>T？</code>或<code>T</code>，这样使得语法更加严谨，明确了可能返回为空和不为空的情况<br>        </li><br>        <li><br>            字符类型不能使用+运算法链接，可以以<code>String(C1)+String(2)</code> 的方式实现字符间链接<br>        </li><br>        <li><br>            重写了<code>Sort</code>函数，解决了栈溢出的问题<br>        </li><br>        </ul><br>    </td><br>  </tr><br></tbody><br></table>

<p><a name="xcode6_beta6"></a></p>
<h3 id="XCode6_Beta6_u4E2DSwift_u8BED_u6CD5_u66F4_u65B0"><a href="#XCode6_Beta6_u4E2DSwift_u8BED_u6CD5_u66F4_u65B0" class="headerlink" title="XCode6 Beta6中Swift语法更新"></a>XCode6 Beta6中Swift语法更新</h3><table class="graybox" border="0" cellspacing="0" cellpadding="5"><br><thead><br>    <tr><br>        <th scope="col" width="100">发布日期</th><br>        <th scope="col">语法变更记录</th><br>    </tr><br></thead><br><tbody><br>    <tr><br>    <td scope="row">2014-08-18</td><br>    <td><ul class="list-bullet"><br>        <li><br>            在章节协议中，增加新的小节：<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-XID_397" target="_blank" rel="external">对构造器的规定（Initializer Requirements）</a><br>        </li><br>        <li><br>            在章节协议中，增加新的小节：<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-XID_409" target="_blank" rel="external">类专属协议（class-only protocols）</a><br>        </li><br>        <li><br>            <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-XID_494" target="_blank" rel="external">断言(assertions)</a>现在可以使用字符串内插语法，并删除了文档中有冲突的注释<br>        </li><br>        <li><br>            更新了<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html#//apple_ref/doc/uid/TP40014097-CH7-XID_428" target="_blank" rel="external">连接字符串和字符（Concatenating Strings and Characters）</a>小节来说明一个事实，那就是字符串和字符不能再用<code>+</code>号运算符或者复合加法运算符<code>+=</code>相互连接，这两种运算符现在只能用于字符串之间相连。请使用<code>String</code>类型的<code>append</code>方法在一个字符串的尾部增加单个字符<br>        </li><br>        <li><br>            在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html#//apple_ref/doc/uid/TP40014097-CH35-XID_516" target="_blank" rel="external">声明特性（Declaration Attributes）</a>章节增加了关于<code>availability</code>特性的一些信息<br>        </li><br>        </ul><br>    </td><br>  </tr><br></tbody><br></table>

<p><a name="xcode6_beta5"></a></p>
<h3 id="XCode6_Beta5_u4E2DSwift_u8BED_u6CD5_u66F4_u65B0"><a href="#XCode6_Beta5_u4E2DSwift_u8BED_u6CD5_u66F4_u65B0" class="headerlink" title="XCode6 Beta5中Swift语法更新"></a>XCode6 Beta5中Swift语法更新</h3><table class="graybox" border="0" cellspacing="0" cellpadding="5"><br><thead><br>    <tr><br>        <th scope="col" width="100">发布日期</th><br>        <th scope="col">语法变更记录</th><br>    </tr><br></thead><br><tbody><br>    <tr><br>    <td scope="row">2014-08-04</td><br>    <td><ul class="list-bullet"><br>        <li><br>            <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-XID_478" target="_blank" rel="external">可选类型（Optionals）</a> 若有值时，不再隐式的转换为 <code>true</code>，同样，若无值时，也不再隐式的转换为 <code>false</code>, 这是为了避免在判别 optional <code>Bool</code> 的值时产生困惑。 替代的方案是，用<code>==</code> 或 <code>!=</code> 运算符显式地去判断Optinal是否是 <code>nil</code>，以确认其是否包含值。<br>        </li><br>        <li><br>            Swift新增了一个 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-XID_124" data-id="//apple_ref/doc/uid/TP40014097-CH6-XID_124" target="_blank" rel="external">Nil合并运算符（Nil Coalescing Operator）</a> (<code>a ?? b</code>), 该表达式中，如果Optional <code>a</code>的值存在，则取得它并返回，若Optional <code>a</code>为<code>nil</code>，则返回默认值 <code>b</code><br>        </li><br>        <li><br>            更新和扩展 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html#//apple_ref/doc/uid/TP40014097-CH7-XID_434" target="_blank" rel="external">字符串的比较（Comparing Strings）</a> 章节，用以反映和展示’字符串和字符的比较’，以及’前缀（prefix）/后缀(postfix)比较’都开始基于扩展字符集(extended grapheme clusters)规范的等价比较.<br>        </li><br>        <li><br>            现在，你可以通过 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html#//apple_ref/doc/uid/TP40014097-CH21-XID_356" target="_blank" rel="external">可选链（Optional Chaining）</a>来：给属性设值，将其赋给一个下标脚注（subscript）; 或调用一个变异（mutating）方法或运算符。对此，章节——<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html#//apple_ref/doc/uid/TP40014097-CH21-XID_364" target="_blank" rel="external">通过可选链访问属性（Accessing Properties Through Optional Chaining）</a>的内容已经被相应的更新。而章节——<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html#//apple_ref/doc/uid/TP40014097-CH21-XID_361" target="_blank" rel="external">通过可选链调用方法（Calling Methods Through Optional Chaining</a>中，关于检查方法调用是否成功的例子，已被扩展为展示如何检查一个属性是否被设值成功。<br><br>        </li><br>        <li><br>            在章节可选链中，增加一个新的小节 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html#//apple_ref/doc/uid/TP40014097-CH21-XID_364" target="_blank" rel="external">访问可选类型的下标脚注（Accessing Subscripts of Optional Type）</a><br>        </li><br>        <li><br>            更新章节 <a href="../chapter2/04_Collection_Types.md#访问和修改数组" data-id="访问和修改数组">访问和修改数组(Accessing and Modifying an Array)</a> 以标示：从该版本起，不能再通过<code>+=</code> 运算符给一个数组添加一个新的项。. 对应的替代方案是, 使<code>append</code> 方法, 或者通过<code>+=</code>运算符来添加一个<b>只有一个项的数组</b>（single-item Array）.</li><br>        <li><br>            添加了一个提示：在 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-XID_126" target="_blank" rel="external">范围运算符（Range Operators）</a>中，比如， <code>a…b</code> 和 <code>a..&lt;b</code> ，起始值<code>a</code>不能大于结束值<code>b</code>.<br>        </li><br>        <li><br>            重写了<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Inheritance.html#//apple_ref/doc/uid/TP40014097-CH17-XID_293" target="_blank" rel="external">继承（Inheritance）</a> 这一章：删除了本章中关于构造器重写的介绍性报道；转而将更多的注意力放到新增的部分——子类的新功能，以及如何通过重写（overrides）修改已有的功能。另外，小节 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Inheritance.html#//apple_ref/doc/uid/TP40014097-CH17-XID_301" target="_blank" rel="external">重写属性的Getters和Setters（Overriding Property Getters and Setters）</a> 中的例子已经被替换为展示如何重写一个 <code>description</code> 属性. (而关于如何在子类的构造器中修改继承属性的默认值的例子，已经被移到 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Inheritance.html#//apple_ref/doc/uid/TP40014097-CH17-XID_293" target="_blank" rel="external">构造过程（Initialization）</a> 这一章.)<br>        </li><br>        <li><br>            更新了 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-XID_331" target="_blank" rel="external">构造器的继承与重写（Initializer Inheritance and Overriding）</a> 小节以标示： 重写一个特定的构造器必须使用 <code>override</code> 修饰符.<br>        </li><br>        <li><br>            更新 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-XID_339" target="_blank" rel="external"> Required构造器（Required Initializers）</a> 小节以标示：<code>required</code> 修饰符现在需要出现在所有子类的required构造器的声明中, 而required构造器的实现，现在可以仅从父类自动继承。<br>        </li><br>        <li><br>            中置（Infix）的 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AdvancedOperators.html#//apple_ref/doc/uid/TP40014097-CH27-XID_80" target="_blank" rel="external">运算符函数（Operator Functions）</a> 不再需要<code>@infix</code> 属性.<br>        </li><br>        <li><br>            <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/RevisionHistory.html#//apple_ref/doc/uid/TP40014097-CH40-XID_1631" target="_blank" rel="external">前置和后置运算符(Prefix and Postfix Operators)</a>的<code>@prefix</code> 和 <code>@postfix</code> 属性，已变更为 <code>prefix</code> 和 <code>postfix</code> 声明修饰符（declaration modifiers）.<br>        </li><br>            <li><br>            增加一条注解：当Prefix和postfix运算符被作用于同一个操作数时，关于<a href="AdvancedOperators.html#//apple_ref/doc/uid/TP40014097-CH27-XID_81" data-id="//apple_ref/doc/uid/TP40014097-CH27-XID_81">前置和后置运算符(Prefix and Postfix Operators)</a>的顺序(postfix运算符会先被执行)<br>        </li><br>        <li><br>            在运算符函数（Operator functions）中， <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AdvancedOperators.html#//apple_ref/doc/uid/TP40014097-CH27-XID_82" data-id="//apple_ref/doc/uid/TP40014097-CH27-XID_82" target="_blank" rel="external">组合赋值运算符（Compound Assignment Operators）</a> 不再使用 <code>@assignment</code> 属性来定义函数.<br>        </li><br>        <li><br>            在这个版本中，在定义<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AdvancedOperators.html#//apple_ref/doc/uid/TP40014097-CH27-XID_85" target="_blank" rel="external">自定义操作符（Custom Operators）</a> 时，<b>修饰符（Modifiers）的出现顺序发生变化</b>。比如， 现在，你该编写 <code>prefix operator</code>， 而不是 <code>operator prefix</code>.<br>        </li><br>        <li><br>            增加信息：关于<code>dynamic</code> 声明修饰符（declaration modifier），于章节 <a href="Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-XID_705" data-id="//apple_ref/doc/uid/TP40014097-CH34-XID_705">声明修饰符（Declaration Modifiers）</a>.<br>        </li><br>        <li><br>            增加信息：<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/doc/uid/TP40014097-CH30-XID_886" target="_blank" rel="external">字面量Literals</a> 的类型推导（type inference）<br>        </li><br>        <li><br>            为章节<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-XID_597" target="_blank" rel="external">Curried Functions</a>添加了更多的信息.<br>        </li><br>        </ul><br>    </td><br>  </tr><br></tbody><br></table>

<p><a name="xcode6_beta4"></a></p>
<h4 id="XCode6_Beta4_u4E2DSwift_u8BED_u6CD5_u66F4_u65B0"><a href="#XCode6_Beta4_u4E2DSwift_u8BED_u6CD5_u66F4_u65B0" class="headerlink" title="XCode6 Beta4中Swift语法更新"></a>XCode6 Beta4中Swift语法更新</h4><table class="graybox" border="0" cellspacing="0" cellpadding="5"><br><thead><br>    <tr><br>        <th scope="col" width="100">发布日期</th><br>        <th scope="col">语法变更记录</th><br>    </tr><br></thead><br><tbody><br>    <tr><br>    <td scope="row">2014-07-21</td><br>    <td><ul class="list-bullet"><br>        <li><br>            加入新的章节  <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html#//apple_ref/doc/uid/TP40014097-CH41-XID_29" target="_blank" rel="external">权限控制（Access Control）</a>.<br>        </li><br>        <li><br>            更新了章节 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html#//apple_ref/doc/uid/TP40014097-CH7-XID_413" target="_blank" rel="external">字符串和字符（Strings and Characters）</a> 用以表明，在Swift中，<code>Character</code> 类型现在代表的是扩展字符集(extended grapheme cluster)中的一个Unicode，为此，新增了小节 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html#//apple_ref/doc/uid/TP40014097-CH7-XID_431" target="_blank" rel="external">Extended Grapheme Clusters</a> 。同时，为小节 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html#//apple_ref/doc/uid/TP40014097-CH7-XID_428" target="_blank" rel="external">Unicode标量（Unicode Scalars）</a> 和 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html#//apple_ref/doc/uid/TP40014097-CH7-XID_434" target="_blank" rel="external">字符串比较（Comparing Strings）</a>增加了更多内容.<br>        </li><br>        <li><br>            更新章节<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/doc/uid/TP40014097-CH30-XID_856" target="_blank" rel="external">字符串字面量（String Literals）</a>：在一个字符串中，Unicode标量（Unicode scalars） 以 <code>\u{n}</code>的形式来表示, <code>n</code> 是一个最大可以有8位的16进制数（hexadecimal digits）<br>        </li><br>        <li><br>            <code>NSString</code> <code>length</code> 属性已被映射到Swift的内建 <code>String</code>类型。（注意，这两属性的类型是<code>utf16Count</code>,而非 <code>utf16count</code>）.<br>        </li><br>        <li><br>            Swift的内建 <code>String</code> 类型不再拥有 <code>uppercaseString</code> 和 <code>lowercaseString</code> 属性.其对应部分在章节 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html#//apple_ref/doc/uid/TP40014097-CH7-XID_413" target="_blank" rel="external">字符串和字符（Strings and Characters）</a>已经被删除, 并且各种对应的代码用例也已被更新.<br>        </li><br>        <li><br>            加入新的章节  <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-XID_315" target="_blank" rel="external">没有外部名的构造器参数（Initializer Parameters Without External Names）</a>.<br>        </li><br>        <li><br>            加入新的章节  <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-XID_339" target="_blank" rel="external"> Required构造器（Required Initializers）</a>.<br>        </li><br>        <li><br>            加入新的章节 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html#//apple_ref/doc/uid/TP40014097-CH10-XID_252" target="_blank" rel="external">可选元祖（函数）返回类型 （Optional Tuple Return Types）</a>.<br>        </li><br>        <li><br>            更新章节 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-XID_453" target="_blank" rel="external">类型标注（Type Annotations）</a> ：多个相关变量可以用“类型标注”（type annotaion）在同一行中声明为同一类型。<br>        </li><br>        <li><br>             <code>@optional</code>, <code>@lazy</code>, <code>@final</code>,  <code>@required</code> 等关键字被更新为 <code>optional</code>, <code>lazy</code>, <code>final</code>, <code>required</code> <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-XID_705" target="_blank" rel="external">参见声明修饰符（Declaration Modifiers）</a>.<br>        </li><br>        <li><br>            更新整本书 —— 引用 <code>..&lt;</code> 作为<a href="BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-XID_128" data-id="//apple_ref/doc/uid/TP40014097-CH6-XID_128">区间运算符（Half-Open Range Operator）</a> (取代原先的<code>..</code> ).<br>        </li><br>        <li><br>            更新了小节 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/CollectionTypes.html#//apple_ref/doc/uid/TP40014097-CH8-XID_185" target="_blank" rel="external">读取和修改字典（Accessing and Modifying a Dictionary）</a>：  <code>Dictionary</code> 现在早呢更加了一个 Boolean型的属性： <code>isEmpty</code><br>        </li><br>        <li><br>            解释了哪些字符（集）可被用来定义<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AdvancedOperators.html#//apple_ref/doc/uid/TP40014097-CH27-XID_85" target="_blank" rel="external">自定义操作符 （Custom Operators）</a><br>        </li><br>        <li><br>            <code>nil</code> 和布尔运算中的 <code>true</code> 和 <code>false</code> 现在被定义为字面量<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/doc/uid/TP40014097-CH30-XID_886" target="_blank" rel="external">Literals</a>.<br>        </li><br>    </ul><br>    </td><br>  </tr><br></tbody><br></table>

<p><a name="xcode6_beta3"></a></p>
<h4 id="XCode6_Beta3_u4E2DSwift_u8BED_u6CD5_u66F4_u65B0"><a href="#XCode6_Beta3_u4E2DSwift_u8BED_u6CD5_u66F4_u65B0" class="headerlink" title="XCode6 Beta3中Swift语法更新"></a>XCode6 Beta3中Swift语法更新</h4><table class="graybox" border="0" cellspacing="0" cellpadding="5"><br><thead><br>    <tr><br>        <th scope="col" width="100">发布日期</th><br>        <th scope="col">语法变更记录</th><br>    </tr><br></thead><br><tbody><br>    <tr><br>    <td scope="row">2014-07-7</td><br>    <td><ul class="list-bullet"><br>        <li><br>            Swift 中的数组 （<code>Array</code>） 类型从现在起具备了完整的值语义。具体信息被更新到 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/CollectionTypes.html#//apple_ref/doc/uid/TP40014097-CH8-XID_170" target="_blank" rel="external">集合的可变性（Mutability of Collections）</a> 和 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/CollectionTypes.html#//apple_ref/doc/uid/TP40014097-CH8-XID_172" target="_blank" rel="external">数组（Arrays）</a> 两小节，以反映这个新的变化. 此外，还解释了如何 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13-XID_150" target="_blank" rel="external">给Strings, Arrays和Dictionaries进行赋值和拷贝 （Assignment and Copy Behavior for Strings, Arrays, and Dictionaries）</a>.<br>        </li><br>        <li><br>            <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/CollectionTypes.html#//apple_ref/doc/uid/TP40014097-CH8-XID_173" target="_blank" rel="external">数组类型速记语法（Array Type Shorthand Syntax）</a> 从 <code>SomeType[]</code>.更新为<code>[SomeType]</code><br>        </li><br>        <li><br>            加入新的小节：<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/CollectionTypes.html#//apple_ref/doc/uid/TP40014097-CH8-XID_182" target="_blank" rel="external">字典类型的速记语法（Dictionary Type Shorthand Syntax)</a>.： <code>[KeyType: ValueType]</code>.<br>        </li><br>        <li><br>            加入新的小节：<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/CollectionTypes.html#//apple_ref/doc/uid/TP40014097-CH8-XID_189" target="_blank" rel="external">字典键类型的哈希值（Hash Values for Dictionary Key Types)</a>.<br>        </li><br>        <li><br>            例子 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-XID_154" target="_blank" rel="external">闭包表达式 (Closure Expressions)</a> 中使用新的全局函数 <code>sorted</code> 取代原先的全局函数 <code>sort</code> 去展示如何返回一个全新的数组.<br>        </li><br>        <li><br>            更新关于 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-XID_320" target="_blank" rel="external">结构体逐一成员构造器 （Memberwise Initializers for Structure Types）</a> 的描述：即使结构体的成员<b>没有默认值</b>，逐一成员构造器也可以自动获得。<br>        </li><br>        <li><br>            <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-XID_128" target="_blank" rel="external">区间运算符（Half-Open Range Operator）</a>由<code>..</code>更新到<code>..&lt;</code><br>        </li><br>        <li><br>            添加一个例子 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-XID_285" target="_blank" rel="external">扩展一个泛型（Extending a Generic Type）</a><br>        </li><br>    </ul><br>    </td><br>  </tr><br></tbody><br></table>

<p><a name="xcode6_beta2"></a></p>
<h4 id="XCode6_Beta2_u4E2DSwift_u8BED_u6CD5_u66F4_u65B0"><a href="#XCode6_Beta2_u4E2DSwift_u8BED_u6CD5_u66F4_u65B0" class="headerlink" title="XCode6 Beta2中Swift语法更新"></a>XCode6 Beta2中Swift语法更新</h4><table class="graybox" border="0" cellspacing="0" cellpadding="5"><br><thead><br>    <tr><br>        <th scope="col" width="100">发布日期</th><br>        <th scope="col">语法变更记录</th><br>    </tr><br></thead><br><tbody><br>    <tr><br>    <td scope="row">2014-07-7</td><br>    <td><ul class="list-bullet"><br>        <li><br>            发布新的文档用以详述Swift - 苹果公司针对iOS和OS X应用的全新开发语言<br>        </li><br>        </ul><br>    </td><br>    </tr><br></tbody><br></table>

<p><a name="xcode6_beta1"></a></p>
<h4 id="XCode6_Beta1_u4E2DSwift_u8BED_u6CD5_u66F4_u65B0"><a href="#XCode6_Beta1_u4E2DSwift_u8BED_u6CD5_u66F4_u65B0" class="headerlink" title="XCode6 Beta1中Swift语法更新"></a>XCode6 Beta1中Swift语法更新</h4><table class="graybox" border="0" cellspacing="0" cellpadding="5"><br><thead><br>    <tr><br>        <th scope="col" width="100">发布日期</th><br>        <th scope="col">语法变更记录</th><br>    </tr><br></thead><br><tbody><br>    <tr><br>    <td scope="row">2014-06-3</td><br>    <td><ul class="list-bullet"><br>        <li><br>            苹果全球开发者大会WWDC2014召开，发布了苹果最新的开发语言Swift，并释放出XCode6 Beta1版本<br>        </li><br>        </ul><br>    </td><br>    </tr><br></tbody><br></table>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&laquo;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/3/">&raquo;</a>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="https://avatars2.githubusercontent.com/u/14305708?v=3&s=460" alt="terry" itemprop="image"/>
          <p class="site-author-name" itemprop="name">terry</p>
        </div>
        <p class="site-description motion-element" itemprop="description">terry yang's blog | java | scala | bi</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">116</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">12</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-next-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yangwei8888" target="_blank">github</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/microsoftgoogles" target="_blank">weibo</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/run-zhi-38" target="_blank">zhihu</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">terry</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  

    <script type="text/javascript">
      var disqus_shortname = 'yangwei888';
      var disqus_identifier = 'page/2/index.html';
      var disqus_title = '';
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
