<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="terry yang's blog | java | scala | bi" />



  <meta name="keywords" content="Hexo,next" />



  <link rel="alternate" href="/atom.xml" title="yosita" type="application/atom+xml" />



  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="terry yang&apos;s blog | java | scala | bi">
<meta property="og:type" content="website">
<meta property="og:title" content="yosita">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="yosita">
<meta property="og:description" content="terry yang&apos;s blog | java | scala | bi">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="yosita">
<meta name="twitter:description" content="terry yang&apos;s blog | java | scala | bi">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>

  <title> yosita </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  

  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?7e8961fdae021b7bf62f2c767bb18c23";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">yosita</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/error_code/" itemprop="url">
                错误码详解
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/error_code/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/error_code/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="错误码详解">错误码详解</h1><p>本文档尝试为所有服务端和SDK返回的错误码给出相对详细的解释，具体到各个SDK的错误码，请参考下列文档链接：</p>
<ul>
<li>iOS 的 <a href="/api-docs/iOS/docs/AVConstants.html">AVConstants</a>。</li>
<li>iOS v3.1.5 及之后的版本，网络请求操作相关的错误码，比如：28 表示请求超时、7 表示连接服务器失败，这些请参考 <a href="http://curl.haxx.se/libcurl/c/libcurl-errors.html" target="_blank" rel="external"><strong>libcurl error codes</strong></a>。</li>
<li>Android 的 <a href="/api-docs/android/doc/index.html">AVException</a>。</li>
</ul>
<h2 id="实时通信错误码">实时通信错误码</h2><p>相关参考链接：</p>
<ul>
<li><a href="realtime_v2.html#服务器端错误码说明">实时通信服务端错误码说明</a>。</li>
<li>iOS SDK 在进行 WebSocket 通信过程中，相关的状态码请参考  <a href="http://tools.ietf.org/html/rfc6455#section-7.4" target="_blank" rel="external"><strong>RFC 6455 – Status Codes</strong></a>。</li>
</ul>
<h2 id="1">1</h2><ul>
<li>信息 - <code>Internal server error. No information available.</code></li>
<li>含义 - 服务器内部错误或者参数错误，一般是因为传入了错误的参数，或者没有在本文档里明确定义的运行时错误，都会以代码 1 指代。</li>
</ul>
<h2 id="100">100</h2><ul>
<li>信息 - <code>The connection to the AVOS servers failed.</code></li>
<li>含义 - 无法建立 TCP 连接到 LeanCloud 服务器，通常是因为网络故障，或者我们服务器故障引起的，我们的服务器状态可以查看 <a href="http://status.leancloud.cn/" target="_blank" rel="external">健康状态检查</a>。</li>
</ul>
<h2 id="101">101</h2><ul>
<li>信息 - <code>Object doesn&#39;t exist, or has an incorrect password.</code></li>
<li>含义 - 查询的 Class 不存在，或者要关联的 Pointer 对象不存在。</li>
</ul>
<h2 id="103">103</h2><ul>
<li>信息 - <code>Missing or invalid classname. Classnames are case-sensitive. They must start with a letter, and a-zA-Z0-9_ are the only valid characters.</code></li>
<li>含义 - 非法的 Class 名称，Class 名称大小写敏感，并且必须以英文字母开头，有效的字符仅限在英文字母、数字以及下划线。</li>
</ul>
<h2 id="104">104</h2><ul>
<li>信息 - <code>Missing object id.</code></li>
<li>含义 - 缺少 objectId，通常是在查询的时候没有传入 objectId，或者 objectId 非法。objectId 只能为字母、数字组成的字符串。</li>
</ul>
<h2 id="105">105</h2><ul>
<li>信息 - <code>Invalid key name. Keys are case-sensitive. They must start with a letter, and a-zA-Z0-9_ are the only valid characters.</code></li>
<li>含义 - 无效的 key 名称，也就是 Class 的列名无效，列名必须以英文字母开头，有效的字符仅限在英文字母、数字以及下划线。</li>
</ul>
<h2 id="106">106</h2><ul>
<li>信息 - <code>Malformed pointer. Pointers must be arrays of a classname and an object id.</code></li>
<li>含义 - 无效的 Pointer 格式，Pointer必须为形如 <code>{className: &#39;Post&#39;, objectId:&#39;xxxxxx&#39;}</code> 的 JSON 对象。</li>
</ul>
<h2 id="107">107</h2><ul>
<li>信息 - <code>Malformed json object. A json dictionary is expected.</code></li>
<li>含义 - 无效的 JSON 对象，解析 JSON 数据失败。</li>
</ul>
<h2 id="108">108</h2><ul>
<li>信息 - <code>Tried to access a feature only available internally.</code></li>
<li>含义 - 此 API 仅供内部使用。</li>
</ul>
<h2 id="111">111</h2><ul>
<li>信息 - <code>Field set to incorrect type.</code></li>
<li>含义 - 想要存储的值不匹配列的类型，请检查你的数据管理平台中列定义的类型，查看存储的数据是否匹配这些类型。</li>
</ul>
<h2 id="112">112</h2><ul>
<li>信息 - <code>Invalid channel name. A channel name is either an empty string (the broadcast channel) or contains only a-zA-Z0-9_ characters and starts with a letter.</code></li>
<li>含义 - 推送订阅的频道无效，频道名称必须不是空字符串，只能包含英文字母、数字以及下划线，并且只能以英文字母开头。</li>
</ul>
<h2 id="113">113</h2><ul>
<li>信息 - <code>Key is required.</code></li>
<li>含义 - Class 中的某个字段设定成必须，保存的对象缺少该字段。</li>
</ul>
<h2 id="114">114</h2><ul>
<li>信息 - <code>Invalid device token.</code></li>
<li>含义 - iOS 推送存储的 deviceToken 无效，如何存储 installation 请阅读 <a href="./push_guide.html#iOS_消息推送">消息推送开发指南</a>。</li>
</ul>
<h2 id="116">116</h2><ul>
<li>信息 - <code>The object is too large.</code></li>
<li>含义 - 要存储的对象超过了大小限制，我们限制单个对象的最大大小在 16 M。</li>
</ul>
<h2 id="117">117</h2><ul>
<li>信息 - <code>The key is read only.</code></li>
<li>含义 - 更新的 Key 是只读属性，无法更新。</li>
</ul>
<h2 id="119">119</h2><ul>
<li>信息 - <code>That operation isn&#39;t allowed for clients.</code></li>
<li>含义 - 该操作无法从客户端发起。通常可以通过在应用设置里开启对应选项就可以解决。</li>
</ul>
<h2 id="120">120</h2><ul>
<li>信息 - <code>The results were not found in the cache.</code></li>
<li>含义 - 查询结果无法从缓存中找到，SDK 在使用从查询缓存的时候，如果发生缓存没有命中，返回此错误。</li>
</ul>
<h2 id="121">121</h2><ul>
<li>信息 - <code>Keys in NSDictionary values may not include &#39;$&#39; or &#39;.&#39;.</code></li>
<li>含义 - JSON 对象中 key 的名称不能包含 <code>$</code> 和 <code>.</code> 符号。</li>
</ul>
<h2 id="122">122</h2><ul>
<li>信息 - <code>Invalid file name. A file name contains only a-zA-Z0-9_. characters and is between 1 and 36 characters.</code></li>
<li>含义 - 无效的文件名称，文件名称只能是英文字母、数字和下划线组成，并且名字长度限制在 1 到 36 之间。</li>
</ul>
<h2 id="123">123</h2><ul>
<li>信息 - <code>Invalid ACL. An ACL with an invalid format was saved. This should not happen if you use AVACL.</code></li>
<li>含义 - ACL 格式错误，如果您是使用 SDK 提供的 AVACL 类，理论上这不应该发生，正确的 ACL 格式请参考 <a href="./rest_api.html#安全性">REST API</a>。</li>
</ul>
<h2 id="124">124</h2><ul>
<li>信息 - <code>The request timed out on the server. Typically this indicates the request is too expensive.</code></li>
<li>含义 - 请求超时，超过一定时间（默认 10 秒）没有返回，通常是因为网络故障或者该操作太耗时引起的。</li>
</ul>
<h2 id="125">125</h2><ul>
<li>信息 - <code>The email address was invalid.</code></li>
<li>含义 - 电子邮箱地址无效。</li>
</ul>
<h2 id="126">126</h2><ul>
<li>信息 - <code>Invalid user id.</code></li>
<li>含义 - 无效的用户 Id，可能用户不存在。</li>
</ul>
<h2 id="127">127</h2><ul>
<li>信息 - <code>The mobile phone number was invalid.</code></li>
<li>含义 - 手机号码无效。</li>
</ul>
<h2 id="137">137</h2><ul>
<li>信息 - <code>A unique field was given a value that is already taken.</code></li>
<li>含义 - 违反 class 中的唯一性索引约束（unique），尝试存储重复的值。</li>
</ul>
<h2 id="139">139</h2><ul>
<li>信息 - <code>Role&#39;s name is invalid.</code></li>
<li>含义 - 角色名称非法，角色名称只能以英文字母、数字或下划线组成。</li>
</ul>
<h2 id="140">140</h2><ul>
<li>信息 - <code>Exceeded an application quota. Upgrade to resolve.</code></li>
<li>含义 - 超过应用的容量限额，请升级账户等级。</li>
</ul>
<h2 id="141">141</h2><ul>
<li>信息 - <code>Cloud Code script had an error.</code></li>
<li>含义 - 云引擎脚本编译或者运行报错。</li>
</ul>
<h2 id="142">142</h2><ul>
<li>信息 - <code>Cloud Code validation failed.</code></li>
<li>含义 - 云引擎校验错误，通常是因为 beforeSave、beforeDelete 等函数返回 error。</li>
</ul>
<h2 id="145">145</h2><ul>
<li>信息 - <code>Payment is disabled on this device.</code></li>
<li>含义 - 本设备没有启用支付功能。</li>
</ul>
<h2 id="150">150</h2><ul>
<li>信息 - <code>Fail to convert data to image.</code></li>
<li>含义 - 转换数据到图片失败。</li>
</ul>
<h2 id="160">160</h2><ul>
<li>信息 - <code>Insufficient balance.</code></li>
<li>含义 - 账户余额不足。</li>
</ul>
<h2 id="200">200</h2><ul>
<li>信息 - <code>Username is missing or empty</code></li>
<li>含义 - 没有提供用户名，或者用户名为空。</li>
</ul>
<h2 id="201">201</h2><ul>
<li>信息 - <code>Password is missing or empty.</code></li>
<li>含义 - 没有提供密码，或者密码为空。</li>
</ul>
<h2 id="202">202</h2><ul>
<li>信息 - <code>Username has already been taken.</code></li>
<li>含义 - 用户名已经被占用。</li>
</ul>
<h2 id="203">203</h2><ul>
<li>信息 - <code>Email has already been taken.</code></li>
<li>含义 - 电子邮箱地址已经被占用。</li>
</ul>
<h2 id="204">204</h2><ul>
<li>信息 - <code>The email is missing, and must be specified.</code></li>
<li>含义 - 没有提供电子邮箱地址。</li>
</ul>
<h2 id="205">205</h2><ul>
<li>信息 - <code>A user with the specified email was not found.</code></li>
<li>含义 - 找不到电子邮箱地址对应的用户。</li>
</ul>
<h2 id="206">206</h2><ul>
<li>信息 - <code>The user cannot be altered by a client without the session.</code></li>
<li>含义 - 没有提供 session，无法修改用户信息，这通常是因为没有登录的用户想修改信息。修改用户信息必须登录，除非在云引擎里，或者使用 master key 调用 REST API。</li>
</ul>
<h2 id="207">207</h2><ul>
<li>信息 - <code>Users can only be created through sign up.</code></li>
<li>含义 - 只能通过注册创建用户，不允许第三方登录。</li>
</ul>
<h2 id="208">208</h2><ul>
<li>信息 - <code>An existing account already linked to another user.</code></li>
<li>含义 - 第三方帐号已经绑定到一个用户，不可绑定到其他用户。</li>
</ul>
<h2 id="210">210</h2><ul>
<li>信息 - <code>The username and password mismatch.</code></li>
<li>含义 - 用户名和密码不匹配。</li>
</ul>
<h2 id="211">211</h2><ul>
<li>信息 - <code>Could not find user.</code></li>
<li>含义 - 找不到用户。</li>
</ul>
<h2 id="212">212</h2><ul>
<li>信息 - <code>The mobile phone number is missing, and must be specified.</code></li>
<li>含义 - 请提供手机号码。</li>
</ul>
<h2 id="213">213</h2><ul>
<li>信息 - <code>A user with the specified mobile phone number was not found.</code></li>
<li>含义 - 手机号码对应的用户不存在。</li>
</ul>
<h2 id="214">214</h2><ul>
<li>信息 - <code>Mobile phone number has already been taken.</code></li>
<li>含义 - 手机号码已经被注册。</li>
</ul>
<h2 id="215">215</h2><ul>
<li>信息 - <code>Mobile phone number isn&#39;t verified.</code></li>
<li>含义 - 未验证的手机号码。</li>
</ul>
<h2 id="216">216</h2><ul>
<li>信息 - <code>Email address isn&#39;t verified.</code></li>
<li>含义 - 未验证的邮箱地址。</li>
</ul>
<h2 id="217">217</h2><ul>
<li>信息 - <code>Invalid username, it must be a non-blank string.</code></li>
<li>含义 - 无效的用户名，不允许空白用户名。</li>
</ul>
<h2 id="218">218</h2><ul>
<li>信息 - <code>Invalid password, it must be a non-blank string.</code></li>
<li>含义 - 无效的密码，不允许空白密码。</li>
</ul>
<h2 id="250">250</h2><ul>
<li>信息 - <code>Linked id missing from request</code></li>
<li>含义 - 连接的第三方账户没有返回用户唯一标示 id</li>
</ul>
<h2 id="251">251</h2><ul>
<li>信息 - <code>Invalid linked session</code>或者<code>Invalid Weibo session</code></li>
<li>含义 - 无效的账户连接，一般是因为 access token 非法引起的。</li>
</ul>
<h2 id="252">252</h2><ul>
<li>信息 - <code>Invalid Weixin session</code></li>
<li>含义 - 无效的微信授权信息。</li>
</ul>
<h2 id="300">300</h2><ul>
<li>信息 - <code>CQL syntax error.</code></li>
<li>含义 - CQL 语法错误。详情参考 <a href="./cql_guide.html">CQL 语法详细指南</a></li>
</ul>
<h2 id="301">301</h2><ul>
<li>信息 - <code>Fails to insert new document.</code></li>
<li>含义 - 新增对象失败，通常是数据格式问题。</li>
</ul>
<h2 id="302">302</h2><ul>
<li>信息 - <code>Invalid GeoPoint values.</code></li>
<li>含义 - 无效的 GeoPoint 类型，请确保经度在 -180 到 180 之间，纬度在 -90 到 90 之间。</li>
</ul>
<h2 id="303">303</h2><ul>
<li>信息 - <code>Fail to execute operation on storage.</code></li>
<li>含义 - 插入数据库失败，一般是数据格式或者内部错误，通常错误里包含更具体的错误信息。</li>
</ul>
<h2 id="401">401</h2><ul>
<li>信息 - <code>Unauthorized.</code></li>
<li>含义 - 未经授权的访问，没有提供 App id，或者 App id 和 App key 校验失败，请检查配置。</li>
</ul>
<h2 id="403">403</h2><ul>
<li>信息 - <code>Forbidden to xxx by class permissions</code></li>
<li>含义 - 操作被禁止，因为 <a href="./data_security.html#Class_级别的权限">Class 权限限制</a>。</li>
</ul>
<h2 id="502">502</h2><ul>
<li>信息 - <code>Server is in maintenance.</code></li>
<li>含义 - 服务器维护中。</li>
</ul>
<h2 id="503">503</h2><ul>
<li>信息 - <code>Rate limit exceeded.</code></li>
<li>含义 - 超过流量访问限制，默认 API 并发 1000 访问每秒，通过数据管理平台每秒限制上传一个文件，并且每分钟最多上传 30 个文件，如需提升，请联系我们。</li>
</ul>
<h2 id="511">511</h2><ul>
<li>信息 - <code>Temporarily Unavailable.</code></li>
<li>含义 -  该请求 API 暂时不可用，请稍后重试。一般是运维操作临时禁止了某个 API 访问，一段时间后会自然恢复，或者联系我们处理。</li>
</ul>
<h2 id="600">600</h2><ul>
<li>信息 - <code>Invalid SMS signature.</code></li>
<li>含义 - 无效的短信签名。短信签名是指附加在短信文本前后位置，使用中文括号【】括起来的文字，短信签名只能位于短信开头或者结束的位置，并且限制在 10（包含 10 个字符）个字符内。<pre><code>默认发送的短信签名使用的是应用名称，应用名称可以在应用设置里修改。短信自定义模板可以在模板里自定义签名。
</code></pre></li>
</ul>
<h2 id="601">601</h2><ul>
<li>信息 - <code>Can&#39;t send SMS too frequently.</code></li>
<li>含义 -  发送短信过于频繁。我们限制验证类短信一分钟一条，每天每个号码限制在 10 条左右。我们强烈建议用户使用图形验证码或者倒数计时等方式来避免用户重复发送验证码，以及可能存在的短信验证码攻击。</li>
</ul>
<h2 id="602">602</h2><ul>
<li>信息 - <code>Fails to send message.</code></li>
<li>含义 -  发送短信或者语音验证码失败，这是短信提供商返回错误，如果确认手机号码没有问题，请联系我们处理。</li>
</ul>
<h2 id="603">603</h2><ul>
<li>信息 - <code>Invalid SMS code.</code></li>
<li>含义 - 无效的短信验证码，通常是不匹配或者过期。</li>
</ul>
<h2 id="604">604</h2><ul>
<li>信息 - <code>SMS template not found.</code></li>
<li>含义 - 找不到自定义的短信模板，请检查模板名称是否正确或者模板是否已经创建并审核通过。</li>
</ul>
<h2 id="605">605</h2><ul>
<li>信息 - <code>SMS template not verified.</code></li>
<li>含义 - 短信模板未审核。</li>
</ul>
<h2 id="606">606</h2><ul>
<li>信息 - <code>Fails to render SMS template.</code></li>
<li>含义 - 渲染短信模板失败，通常是模板语法问题，我们的短信模板仅支持 <a href="http://handlebarsjs.com/" target="_blank" rel="external">handlerbars</a> 模板语法。</li>
</ul>
<h2 id="700">700</h2><ul>
<li>信息 - <code>Nonexistent query keys</code></li>
<li>含义 - 无效的查询或者排序字段，请确认查询或者排序的字段在表中存在。</li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/faq/" itemprop="url">
                LeanCloud FAQ
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/faq/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/faq/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="LeanCloud_FAQ">LeanCloud FAQ</h1><h2 id="账户和平台常见问题">账户和平台常见问题</h2><h3 id="LeanCloud_部署在哪个云平台上">LeanCloud 部署在哪个云平台上</h3><p>LeanCloud 部署在国内多个云计算平台上，并采用在双线机房内同时使用虚拟机和实体机的混合部署策略，来保证应用的访问体验和可靠性。</p>
<h3 id="获取客服支持有哪些途径">获取客服支持有哪些途径</h3><ul>
<li>到免费的<a href="https://forum.leancloud.cn/" target="_blank" rel="external">用户社区</a> 进行提问。</li>
<li>购买 <a href="/bill.html#/bill/general">技术支持</a>，进入 <a href="https://ticket.leancloud.cn/" target="_blank" rel="external">工单系统</a> 来提交问题。</li>
<li>发送邮件到 <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#115;&#117;&#x70;&#x70;&#111;&#114;&#x74;&#64;&#108;&#x65;&#x61;&#x6e;&#x63;&#108;&#111;&#117;&#100;&#46;&#114;&#x6f;&#99;&#107;&#115;">&#115;&#117;&#x70;&#x70;&#111;&#114;&#x74;&#64;&#108;&#x65;&#x61;&#x6e;&#x63;&#108;&#111;&#117;&#100;&#46;&#114;&#x6f;&#99;&#107;&#115;</a> 获取帮助。</li>
<li>紧急情况拨打客服电话：010-82800646。</li>
</ul>
<h3 id="计费是基于账号还是应用">计费是基于账号还是应用</h3><p>计费都基于用户账号，详细信息请参考 <a href="/pricing.html">价格</a> 页面。</p>
<h3 id="如果没有缴费会怎么样">如果没有缴费会怎么样</h3><p>账单逾期四周未缴，账户服务将被停止；应用数据被置于不可见模式，但仍会在 LeanCloud 云端保留一个月。如需要恢复服务和访问应用数据，请登录控制台，支付欠款。</p>
<p>我们为账单支付提供一段缓冲期，请在收到账单的十天内完成缴费即可。在此期间，我们会通过邮件或者电话等方式与您联系，因此强烈建议完整填写 <a href="/settings.html#/setting/info">开发者信息</a>，以免错过我们的提醒和最佳付款时机。</p>
<h3 id="如何付费">如何付费</h3><ul>
<li><p>支付宝 <a href="/bill.html#/bill/charge">充值</a></p>
<p>我们将每个月自动从您的账户余额里扣除上月账单的费用。每次扣费优先使用充值金额，其次是赠送金额。</p>
</li>
<li><p>对公账户付款</p>
<p>公司税号：<strong>110108597742364</strong><br>公司名称：<strong>美味书签（北京）信息技术有限公司</strong><br><br>开户银行：<strong>中国银行股份有限公司北京大运村支行</strong><br><br>银行账号：<strong>344159259324</strong><br><br>银行地址：<strong>北京市海淀区知春路 6 号锦秋国际大厦一层</strong><br>银行行号：<strong>104100004013</strong></p>
</li>
</ul>
<h3 id="如何申请开具发票">如何申请开具发票</h3><ul>
<li><p>申请开发票前，请先按系统要求，完善所有必填的用户信息。</p>
</li>
<li><p>无论采取哪一种付款方式，只有当累计支付金额达到人民币<strong>壹仟元</strong>后系统才允许申请，单笔开票金额不低于人民币<strong>壹仟元</strong>。</p>
</li>
<li><p>如有特别需求，如按月度账单金额结算，或先开发票后付款，请联系我们的市场部专员 <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#x62;&#x75;&#115;&#x69;&#110;&#x65;&#115;&#115;&#x40;&#x6c;&#101;&#97;&#110;&#x63;&#x6c;&#x6f;&#x75;&#x64;&#x2e;&#x72;&#111;&#99;&#x6b;&#x73;">&#x62;&#x75;&#115;&#x69;&#110;&#x65;&#115;&#115;&#x40;&#x6c;&#101;&#97;&#110;&#x63;&#x6c;&#x6f;&#x75;&#x64;&#x2e;&#x72;&#111;&#99;&#x6b;&#x73;</a>，QQ号：2607695496。</p>
</li>
<li><p>开具发票时段为每月 10 日至 30 日，发票以快递寄送。如需开具增值税专用发票，也请联系我们的市场部专员。</p>
</li>
<li><p>发票免费邮寄。</p>
</li>
</ul>
<h3 id="哪里获取平台的更新信息">哪里获取平台的更新信息</h3><p>通常情况下，我们新版本的更新周期为一到两周。获取更新信息可以通过：</p>
<ul>
<li><a href="http://blog.leancloud.cn/" target="_blank" rel="external">官方博客</a>（每次更新的详细信息都会发布在那里）</li>
<li><a href="http://weibo.com/avoscloud" target="_blank" rel="external">官方微博</a></li>
<li>官方微信公众号：LeanCloud</li>
<li>每月初，我们会将每月的更新摘要发送到您的注册邮箱。</li>
<li>在控制台页面的右上方有 <a href="/info-center.html#/index">消息中心</a>，请注意查看新通知。</li>
</ul>
<h3 id="API_开放吗">API 开放吗</h3><p>我们的 API 完全开放。我们提供的 SDK 也都是基于开放 API 实现的。详情请阅读 <a href="/docs/rest_api.html">REST API 详解</a>。</p>
<h3 id="提供哪些平台的_SDK">提供哪些平台的 SDK</h3><p>目前官方提供的 SDK 种类包括：</p>
<ul>
<li>iOS 和 OS X</li>
<li>Android</li>
<li>JavaScript</li>
<li>Windows Phone</li>
<li>Unity</li>
<li>Python</li>
<li>PHP</li>
</ul>
<p>来自第三方的开源项目有：</p>
<ul>
<li><a href="https://github.com/freewing99/BaasReponsitory" target="_blank" rel="external">C#</a></li>
</ul>
<p>详情请访问 <a href="/docs/sdk_down.html">SDK 下载</a> 页面。</p>
<h3 id="iOS_和_Android_是否可以使用同一个_App">iOS 和 Android 是否可以使用同一个 App</h3><p>当然可以。使用我们的 SDK，可以为同一个应用开发多个平台的版本，共享后端数据。</p>
<h3 id="支持_Unity_3D_吗">支持 Unity 3D 吗</h3><p>支持。请到 <a href="sdk_down.html">SDK 下载</a> 页面下载 Unity SDK。</p>
<h3 id="开发文档有提供搜索功能吗">开发文档有提供搜索功能吗</h3><p> <strong>官网文档</strong> 首页右上角就有搜索框，也可以直接访问 <a href="/search.html">搜索</a> 页面。</p>
<h2 id="API_相关">API 相关</h2><h3 id="API_调用次数有什么限制吗">API 调用次数有什么限制吗</h3><p>我们每个月提供 100 万次的免费额度，超过的部分才收费。免费额度不会将完全免费的推送服务和统计服务计算进去。另外，对于免费版和专业版，默认情况下，每个应用都有每秒 1000 次的并发访问上限，如果需要提高上限，请与我们联系。</p>
<p>对于从控制台或者使用 JavaScript SDK 上传文件（包括云引擎内），我们限制每秒最多上传 1 个文件，一分钟内最多上传 30 个文件。</p>
<h3 id="API_调用次数的计算">API 调用次数的计算</h3><p>对于「数据存储」来说，每次 create 和 update 一条数据算一次请求，如调用一次 <code>object.saveInBackground</code> 算一次 API 请求。</p>
<p><code>fetch</code>、<code>find</code>、<code>delete</code>、<code>deleteAll</code> 算<strong>一次请求</strong>：</p>
<ul>
<li>调用一次 fetch / find 通过 include 返回了 100 个关联对象，算一次 API 请求。</li>
<li>调用一次 find / deleteAll 来查找或删除 500 条记录，只算一次 API 请求。</li>
</ul>
<p><code>saveAll</code>、<code>fetchAll</code> 算<strong>多次请求</strong>：</p>
<ul>
<li>调用一次 saveAll / fetchAll 来保存或获取 array 里面 100 个 对象，算 100 次 API 请求。</li>
</ul>
<p>对于「<a href="status_system.html">应用内社交</a>」，create 和 update 按照 Status 和 Follower/Followee 的对象数量来计费。对于 query 则是按照请求数来计费，与结果的大小无关。collection fetch 也是按照请求次数来计费。</p>
<h3 id="可以在线测试_API_吗">可以在线测试 API 吗</h3><p>请访问 <a href="/apionline/">API 在线测试工具</a>。</p>
<h3 id="403_错误">403 错误</h3><p>403 错误分为两类：</p>
<ul>
<li>错误信息 <code>The user cannot be altered by a client without the session.</code>：用户没有登录，无法修改用户信息。</li>
<li>错误信息 <code>Forbidden to write by class permissions.</code> 或者 <code>Forbidden to read by class permissions.</code>：想要修改的 class 表没有打开「读」或者「写」的权限。在 <a href="/data.html">数据</a> 管理平台，点击相应的 class，在右侧选择 <strong>其他</strong> 下拉菜单，进入 <strong>权限管理</strong> 来设置 class 权限。</li>
</ul>
<p><img src="/avos/images/permission.png" alt="image"></p>
<h3 id="Unauthorized_错误">Unauthorized 错误</h3><p>应用 API 授权失败，请检查是否初始化了 App Id 和 App Key。</p>
<ul>
<li>如何进行初始化，请查看 <a href="/start.html">快速入门</a>。</li>
<li>App Id 和 App Key 在应用的 <strong>设置</strong> 菜单里可以找到。</li>
</ul>
<h3 id="错误信息代码和详细解释在哪里">错误信息代码和详细解释在哪里</h3><ul>
<li><a href="./error_code.html">错误代码详解</a></li>
<li>iOS SDK：<a href="/api-docs/iOS/docs/AVConstants.html">AVConstants</a></li>
<li>Android SDK：<a href="/api-docs/android/doc/index.html">AVException</a></li>
</ul>
<p>REST API 返回的错误信息跟 SDK 保持一致。</p>
<h3 id="其他语言调用_REST_API_如何对参数进行编码">其他语言调用 REST API 如何对参数进行编码</h3><p>REST API 文档使用 curl 作为示范，其中 <code>--data-urlencode</code> 表示要对参数进行 URL encode 编码。如果是 GET 请求，直接将经过 URL encode 的参数通过 <code>&amp;</code> 连接起来，放到 URL 的问号后。如 <code>https://leancloud.cn/1.1/login?username=xxxx&amp;password=xxxxx</code>。</p>
<h3 id="如何实现大小写不敏感的查询">如何实现大小写不敏感的查询</h3><p>目前不提供直接支持，可采用正则表达式查询的办法，具体参考 <a href="http://stackoverflow.com/questions/1863399/mongodb-is-it-possible-to-make-a-case-insensitive-query" target="_blank" rel="external">StackOverflow - MongoDB: Is it possible to make a case-insensitive query</a>。</p>
<p>使用各平台 SDK 的 AVQuery 对象提供的 <code>matchesRegex</code> 方法（Android SDK 用 <code>whereMatches</code> 方法）。</p>
<h3 id="应用内用户的密码需要加密吗">应用内用户的密码需要加密吗</h3><p>不需要加密密码，我们的服务端已使用随机生成的 salt，自动对密码做了加密。 如果用户忘记了密码，可以调用 <code>requestResetPassword</code> 方法（具体查看 SDK 的 AVUser 用法），向用户注册的邮箱发送邮件，用户以此可自行重设密码。 在整个过程中，密码都不会有明文保存的问题，密码也不会在客户端保存，只是会保存 sessionToken 来标示用户的登录状态。</p>
<h2 id="控制台相关">控制台相关</h2><h3 id="如何导入或者导出数据？">如何导入或者导出数据？</h3><p>请参考《数据与安全》文档的 <a href="./data_security.html#导入数据">导入数据</a> 和 <a href="./data_security.html#导出数据">导出数据</a> 部分。</p>
<h3 id="如何在_App_邮件内完全使用自己的品牌">如何在 App 邮件内完全使用自己的品牌</h3><p>请参考博文 <a href="http://blog.leancloud.cn/blog/2014/01/09/zi-ding-yi-ying-yong-nei-yong-hu-zhong-she-mi-ma-he-you-xiang-yan-zheng-ye-mian/" target="_blank" rel="external">《自定义应用内用户重设密码和邮箱验证页面》</a>。</p>
<h3 id="创建唯一索引失败">创建唯一索引失败</h3><p>请确认想要创建索引的列没有已经存在的重复值。</p>
<h3 id="如何上传文件">如何上传文件</h3><p>任何一个 Class 如果有 File 类型的列，就可以直接在 <strong>数据</strong> 管理平台中将文件上传到该列。如果没有，请自行创建列，类型指定为 File。</p>
<h3 id="如何在应用之间共享数据">如何在应用之间共享数据</h3><p>请参考我们的博客文章 <a href="http://blog.leancloud.cn/blog/2014/03/31/2014nian-3yue-di-4zhou-avos-cloud-geng-xin/" target="_blank" rel="external">《2014 年 3 月第 4 周更新日志》</a>。</p>
<h2 id="iOS/OS_X_SDK">iOS/OS X SDK</h2><h3 id="安装_Cocopods_失败怎么解决">安装 Cocopods 失败怎么解决</h3><p>推荐使用淘宝提供的 Gem 源，访问 <a href="https://ruby.taobao.org/" target="_blank" rel="external">https://ruby.taobao.org/</a>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources --add https://ruby.taobao.org/ --remove https://rubygems.org/</span><br><span class="line">$ gem sources <span class="operator">-l</span></span><br><span class="line">*** CURRENT SOURCES ***</span><br><span class="line"></span><br><span class="line">https://ruby.taobao.org</span><br><span class="line"><span class="comment"># 请确保只有 ruby.taobao.org</span></span><br><span class="line">$ gem install cocoapods</span><br></pre></td></tr></table></figure>
<p>由于淘宝已经停止基于 HTTP 协议的镜像服务，如果之前使用的是 <a href="http://ruby.taobao.org/" target="_blank" rel="external">http://ruby.taobao.org/</a>，这也可能导致安装 Cocopods 失败。</p>
<p>需要在配置中使用 HTTPS 协议代替：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources --add https://ruby.taobao.org/ --remove http://ruby.taobao.org/</span><br><span class="line">$ gem sources <span class="operator">-l</span></span><br><span class="line">*** CURRENT SOURCES ***</span><br><span class="line"></span><br><span class="line">https://ruby.taobao.org</span><br><span class="line"><span class="comment"># 请确保只有 ruby.taobao.org</span></span><br><span class="line">$ gem install cocoapods</span><br></pre></td></tr></table></figure>
<h3 id="编译失败">编译失败</h3><h4 id="Symbol(s)_not_found_x86_64">Symbol(s) not found x86_64</h4><p>请使用 32 位模拟器进行编译和调试.</p>
<h4 id="Undefined_symbols_for_architecture">Undefined symbols for architecture</h4><p>一般是由于 Framework 的链接找不到造成的，建议用 CocoaPods 更新一下。没使用 CocoaPods 的项目可以删除对 Framework 的引用，然后再重新加进来。</p>
<p>LeanCloud 依赖的 Framework 包括：</p>
<ul>
<li>SystemConfiguration.framework</li>
<li>MobileCoreServices.framework</li>
<li>CoreTelephony.framework</li>
<li>CoreLocation.framework</li>
</ul>
<p>如果是 <code>for architecture arm64</code>，这是因为 Xcode 更新到 5.1 后，CocoaPods 没有及时更新对 64 位 CPU 的支持，解决方法参考 <a href="http://stackoverflow.com/questions/19213782/undefined-symbols-for-architecture-arm64" target="_blank" rel="external">《StackOverflow - Undefined symbols for architecture arm64》</a></p>
<h3 id="请求报错">请求报错</h3><p>请参考请求返回的错误码 <a href="error_code.html">详细说明</a>。</p>
<h3 id="地理位置查询错误">地理位置查询错误</h3><p>如果错误信息类似于 <code>can&#39;t find any special indices: 2d (needs index), 2dsphere (needs index), for 字段名</code>，就代表用于查询的字段没有建立 2D 索引，可以在 Class 管理的 <strong>其他</strong> 菜单里找到 <strong>索引</strong> 管理，点击进入，找到字段名称，选择并创建「2dsphere」索引类型。</p>
<p><img src="/avos/images/geopoint_faq.png" alt="image"></p>
<h2 id="Android_SDK">Android SDK</h2><h3 id="对_AVObject_对象使用_getDate(“createdAt”)_方法读取创建时间为什么会返回_null">对 AVObject 对象使用 getDate(“createdAt”) 方法读取创建时间为什么会返回 null</h3><p>请用 <code>AVObject</code> 的 <code>getCreatedAt</code> 方法；获取 <code>updatedAt</code> 用 <code>getUpdatedAt</code>。</p>
<h2 id="JavaScript_SDK">JavaScript SDK</h2><h3 id="有没有同步_API">有没有同步 API</h3><p>JavaScript SDK 由于平台的特殊性（运行在单线程运行的浏览器或者 Node.js 环境中），不提供同步 API，所有需要网络交互的 API 都需要以 callback 的形式调用。我们提供了 <a href="js_guide.html#promise">Promise 模式</a> 来减少 callback 嵌套过多的问题。</p>
<h2 id="消息推送">消息推送</h2><h3 id="推送的到达率如何">推送的到达率如何</h3><p>关于到达率这个概念，业界并没没有统一的标准。我们测试过，在线用户消息的到达率基本达到 100%。我们的 SDK 做了心跳和重连等功能，尽量维持对推送服务器的长连接存活，提升消息到达用户手机的实时性和可靠性。</p>
<h3 id="推送是基于_XMPP_还是其他协议">推送是基于 XMPP 还是其他协议</h3><p>老版本推送基于 XMPP 协议，v2.4.1 版本开始，推送采用了 WebSocket 协议，方便支持多平台，包括将要推出的 Web 端消息推送功能。</p>
<h3 id="iOS_推送如何区分开发证书和生产证书">iOS 推送如何区分开发证书和生产证书</h3><p>暂不提供在同一个 App 里同时上传开发证书和生产证书。推荐创建单独的测试 App，可以利用数据导出和导入来快速模拟生产环境。</p>
<h3 id="Android_消息接收能不能自定义_Receiver_不弹出通知">Android 消息接收能不能自定义 Receiver 不弹出通知</h3><p>可以。请参考 <a href="push_guide.html#消息内容_Data">消息推送开发指南</a>。</p>
<p>如果要自定义 receiver，必须在消息的 data 里带上自定义的 action。LeanCloud 在接收到消息后，将广播 action 为您定义的值的 intent 事件，您的 receiver 里也必须带上 <code>intent-filter</code> 来捕获该 action 值的 intent 事件。</p>
<h2 id="统计">统计</h2><h3 id="统计服务免费吗">统计服务免费吗</h3><p>统计服务完全免费，不占用每月的 API 免费额度。</p>
<h3 id="统计服务支持哪些平台">统计服务支持哪些平台</h3><p>目前支持</p>
<ul>
<li>iOS</li>
<li>OS X</li>
<li>Android</li>
</ul>
<p>更多平台 SDK 正在开发中。</p>
<h3 id="统计支持哪些发送策略">统计支持哪些发送策略</h3><ul>
<li>启动时发送（默认策略，推荐使用）</li>
<li>批量发送</li>
<li>按最小间隔发送</li>
</ul>
<p>可以在 <strong>分析</strong> &gt; <strong>Android（或者 iOS）统计</strong> &gt; <strong>统计设置</strong> &gt; <strong>数据发送策略</strong> 的菜单里实时修改这些策略。</p>
<h2 id="云引擎">云引擎</h2><h3 id="定时器_crontab_的语法">定时器 crontab 的语法</h3><p>请参考 <a href="http://www.quartz-scheduler.org/documentation/quartz-1.x/tutorials/crontrigger" target="_blank" rel="external">Quartz 文档</a>。</p>
<h3 id="云端代码都支持那些语言">云端代码都支持那些语言</h3><p>目前支持 Node.js 和 Python 运行环境，未来可能还会引入 PHP 等其他语言。</p>
<h3 id="云引擎如何上传文件">云引擎如何上传文件</h3><p>请参考这篇博文 <a href="http://blog.leancloud.cn/blog/2013/11/23/zai-yun-dai-ma-zhong-chu-li-shang-chuan-wen-jian/" target="_blank" rel="external">《在云代码中处理上传文件》</a>，或者 <a href="leanengine_guide-cloudcode.html#上传文件">云引擎指南 - 上传文件</a> 中的相关内容。</p>
<h3 id="云引擎中如何处理用户登录和_Cookie">云引擎中如何处理用户登录和 Cookie</h3><p>请参考这篇博文 <a href="http://blog.leancloud.cn/blog/2013/12/16/zai-yun-dai-ma-zhong-chu-li-yong-hu-deng-lu/" target="_blank" rel="external">《在云代码中处理用户登录》</a>，或者 <a href="leanengine_guide-cloudcode.html#处理用户登录和登出">云引擎指南</a> 中的相关内容。</p>
<h3 id="云引擎的二级域名多久生效">云引擎的二级域名多久生效</h3><p>我们设置的 TTL 是 10 秒，但是因为使用 Amazon 的 DNS 服务，因此可能国内部分地区会有一定延迟，最迟应该在 24 小时内生效。如果没有，请及时联系我们处理。</p>
<h3 id="云引擎二级域名可以启用_HTTPS_吗">云引擎二级域名可以启用 HTTPS 吗</h3><p>请参考这篇博文 <a href="http://blog.leancloud.cn/blog/2013/12/20/wei-yun-dai-ma-tuo-guan-wang-zhan-qi-yong-https/" target="_blank" rel="external">《为云代码托管网站启用 HTTPS》</a>。</p>
<h3 id="云引擎_Web_Hosting_备案">云引擎 Web Hosting 备案</h3><p>只有网站类的才需要备案，并且在主域名已备案的情况下，二级子域名不需要备案。</p>
<p>如果主站需要托管在我们这边，而且主站还没经过备案，请参考文档 <a href="leanengine_guide-cloudcode.html#域名备案流程">云引擎指南 - 域名备案流程</a> 部分来了解具体的备案流程。</p>
<h2 id="文件">文件</h2><h3 id="文件存储有_CDN_加速吗？">文件存储有 CDN 加速吗？</h3><p>有的。我们的文件存储目前由 <a href="http://qiniu.com" target="_blank" rel="external">七牛</a> 提供，都有 CDN 加速访问。</p>
<h3 id="文件存储有大小限制吗？">文件存储有大小限制吗？</h3><p>没有。除了在浏览器里通过 JavaScript SDK 上传文件，或者通过我们网站直接上传文件，有 10 MB 的大小限制之外，其他 SDK 都没有限制。 JavaScript SDK 在 Node.js 环境中也没有大小限制。</p>
<h3 id="存储图片可以做缩略图等处理吗？">存储图片可以做缩略图等处理吗？</h3><p>可以。默认我们的 <code>AVFile</code> 类提供了缩略图获取方法，可以参见各个 SDK 的开发指南。如果要自己处理，可以通过获取 <code>AVFile</code> 的 <code>URL</code> 属性，使用 <a href="http://docs.qiniu.com/api/v6/image-process.html" target="_blank" rel="external">七牛图片处理 API</a> 执行处理，例如添加水印、裁剪等。</p>
<h2 id="短信">短信</h2><p>详情请参照<a href="/docs/rest_sms_api.html#常见问题_FAQ">短信收发常见问题一览</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/android_faq/" itemprop="url">
                Android SDK 常见问题及解答
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/android_faq/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/android_faq/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="Android_SDK_常见问题及解答">Android SDK 常见问题及解答</h1><h2 id="代码混淆怎么做">代码混淆怎么做</h2><p>为了保证 SDK 在代码混淆后能正常运作，需要保证部分类和第三方库不被混淆，参考下列配置：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"># proguard.cfg</span><br><span class="line"></span><br><span class="line">-<span class="ruby">keepattributes <span class="constant">Signature</span></span><br><span class="line"></span>-<span class="ruby">dontwarn com.jcraft.jzlib.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">jcraft</span>.<span class="title">jzlib</span>.**  &#123; *;</span>&#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn sun.misc.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">sun</span>.<span class="title">misc</span>.** &#123; *;</span>&#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn com.alibaba.fastjson.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">alibaba</span>.<span class="title">fastjson</span>.** &#123; *;</span>&#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn sun.security.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">sun</span>.<span class="title">security</span>.** &#123; *;</span> &#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn com.google.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">google</span>.** &#123; *;</span>&#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn com.avos.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">avos</span>.** &#123; *;</span>&#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">keep public <span class="class"><span class="keyword">class</span> <span class="title">android</span>.<span class="title">net</span>.<span class="title">http</span>.<span class="title">SslError</span></span></span><br><span class="line"></span>-<span class="ruby">keep public <span class="class"><span class="keyword">class</span> <span class="title">android</span>.<span class="title">webkit</span>.<span class="title">WebViewClient</span></span></span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn android.webkit.<span class="constant">WebView</span></span><br><span class="line"></span>-<span class="ruby">dontwarn android.net.http.<span class="constant">SslError</span></span><br><span class="line"></span>-<span class="ruby">dontwarn android.webkit.<span class="constant">WebViewClient</span></span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn android.support.**</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn org.apache.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">apache</span>.** &#123; *;</span>&#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn org.jivesoftware.smack.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">jivesoftware</span>.<span class="title">smack</span>.** &#123; *;</span>&#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn com.loopj.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">loopj</span>.** &#123; *;</span>&#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn com.squareup.okhttp.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">squareup</span>.<span class="title">okhttp</span>.** &#123; *;</span>&#125;</span><br><span class="line"></span>-<span class="ruby">keep interface com.squareup.okhttp.** &#123; *; &#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn okio.**</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn org.xbill.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">xbill</span>.** &#123; *;</span>&#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">keepattributes *<span class="constant">Annotation</span>*</span></span><br></pre></td></tr></table></figure>
<h2 id="使用美国节点时_SDK_报错：create_SSL_socket_factory_失败">使用美国节点时 SDK 报错：<code>create SSL socket factory</code> 失败</h2><p>在使用美国节点的时候，SDK 初始化时即报错，显示 <code>create SSL socket factory</code> 失败。怎么办？</p>
<p>这是因为 LeanCloud 的 SSL 证书不在工程资源里面导致的，解决办法如下：</p>
<p>请下载 <a href="https://download.leancloud.cn/sdk/android/current/avoscloud_us_ssl.bks" target="_blank" rel="external">SSL 证书</a>，并拷贝到你项目的 <code>res/raw/</code> 目录下，重新打包即可。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/ios_os_x_faq/" itemprop="url">
                iOS / OS X SDK 常见问题和解答
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/ios_os_x_faq/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/ios_os_x_faq/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="iOS_/_OS_X_SDK_常见问题和解答">iOS / OS X SDK 常见问题和解答</h1><h2 id="怎么使用_LeanCloud_iOS_SDK">怎么使用 LeanCloud iOS SDK</h2><p>最简单的方式，使用 CocoaPods，在 PodFile 加入以下内容：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="string">'AVOSCloud'</span></span><br></pre></td></tr></table></figure>
<p>AVOSCloudSNS SDK：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="string">'AVOSCloudSNS'</span></span><br></pre></td></tr></table></figure>
<h3 id="如何使用「用户登录」功能">如何使用「用户登录」功能</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVUser</span> logInWithUsernameInBackground:<span class="string">@"zeng"</span> password:<span class="string">@"123456"</span> block:^(<span class="built_in">AVUser</span> *user, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (user != null) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"login success"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"signin failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h2 id="如何登出">如何登出</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVUser</span> logOut];</span><br></pre></td></tr></table></figure>
<h2 id="如何使用「新浪微博」登录">如何使用「新浪微博」登录</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVOSCloudSNS</span> loginWithCallback:^(<span class="keyword">id</span> object, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//回调代码</span></span><br><span class="line"></span><br><span class="line">&#125; toPlatform:<span class="built_in">AVOSCloudSNSSinaWeibo</span>];</span><br></pre></td></tr></table></figure>
<h2 id="使用_AVOSCloudSNS，运行时报错：+[AVUser_loginWithAuthData:block:]:_unrecognized_selector_sent_to_class">使用 AVOSCloudSNS，运行时报错：+[AVUser loginWithAuthData:block:]: unrecognized selector sent to class</h2><p>请将 <strong>Build Settings</strong> -&gt; <strong>Linking</strong> -&gt; <strong>Other Linker Flags</strong> 设置为 <strong>-ObjC</strong>。具体原因可以参考苹果官方文档《Technical Q&amp;A QA1490 <a href="https://developer.apple.com/library/mac/qa/qa1490/_index.html" target="_blank" rel="external">Building Objective-C static libraries with categories</a>》。此外，stackoverfow 上也有一个比较详细的答案：《<a href="http://stackoverflow.com/questions/2567498/objective-c-categories-in-static-library" target="_blank" rel="external">Objective-C categories in static library</a>》。</p>
<h2 id="为什么升级到_3-1-3-2_以上的版本时_BOOL_类型数据保存错误？">为什么升级到 3.1.3.2 以上的版本时 BOOL 类型数据保存错误？</h2><p>在 3.1.3.2 版本中，我们修正了子类化时 <code>BOOL</code> 类型的 <code>property</code> 保存到后端时被认为是 Number 类型而不是 Boolean 类型的问题，即 <code>BOOL</code> 类型不再保存为 <code>0</code> 和 <code>1</code>，而被正确地保存为 <code>true</code> 和 <code>false</code>。但您的代码可能已经适应了修正前的 SDK，并且相应的字段已经是 <code>Number</code> 类型。这时再保存为 <code>Boolean</code> 类型就会报 “Expected type is number, but it is boolean” 之类的错误，如果出现此类错误且要继续保持该字段 Number 类型时，可类似地将 <code>@property (BOOL) isTeamMember;</code> 改为 <code>@property NSInteger isTeamMember;</code>。</p>
<h2 id="为什么不能真机调试">为什么不能真机调试</h2><p>由于动态库在打包时，Xcode 将动态库的签名意外丢失，导致使用了动态库的应用在真机调试时，签名校验失败。</p>
<p>我们已经将所有动态库重新签名，修复了这个问题。开发者需要更新动态库。如果是手动集成的，只需要重新下载并替换原 framework 即可。如果是通过 CocoaPods 安装的，需要额外的步骤：</p>
<ol>
<li>删掉 Podfile 中的动态库 pod；</li>
<li>执行 <code>pod install</code> 命令，卸载出问题的动态库；</li>
<li>删掉 $HOME/Library/Caches/CocoaPods/Pods 这个目录；</li>
<li>将之前删掉的动态库 pod 重新添加到 Podfile 中；</li>
<li>执行 <code>pod install</code> 命令，安装新的动态库。</li>
</ol>
<p>完成以上几个步骤后，就能在真机上调试应用了。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/ios_os_x_guide/" itemprop="url">
                iOS / OS X 数据存储开发指南
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/ios_os_x_guide/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/ios_os_x_guide/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="iOS_/_OS_X_数据存储开发指南">iOS / OS X 数据存储开发指南</h1><p>如果还没有安装 LeanCloud iOS SDK，请阅读 <a href="/start.html">快速入门</a> 来获得该 SDK，并在 Xcode 中运行和熟悉示例代码。我们的 SDK 支持 iOS 5.1.1 及更高版本。</p>
<p>如果想从项目中学习，请到我们的 GitHub 资源库中获取 <a href="https://github.com/leancloud/leancloud-demos#ios" target="_blank" rel="external">iOS SDK Demos</a> 。其中，我们推荐与这个指南配套的 <a href="https://github.com/leancloud/LeanStorage-Demo" target="_blank" rel="external">LeanStorageDemo</a>。</p>
<h2 id="介绍">介绍</h2><p>LeanCloud 是一个完整的平台解决方案，它为应用开发提供了全方位的后端服务。我们的目标是让开发者不需要进行后端开发及服务器运维等工作，就可以开发和发布成熟的应用。</p>
<p>如果熟悉像 Ruby on Rails 这样的 Web 框架，你会发现 LeanCloud 很容易上手。我们在设计 LeanCloud 时应用了许多与之相同的原则。如果你之前使用过 Parse 或类似的后端服务，那么还会发现我们的 API 尽可能与其保持兼容。我们这样设计，是为了让开发者可以轻而易举地将应用从其他服务迁移至 LeanCloud，并且能得心应手地使用我们的 SDK 进行开发。</p>
<h2 id="快速入门">快速入门</h2><p>建议在阅读本文之前，先阅读 <a href="/start.html">快速入门</a>，了解如何配置和使用 LeanCloud。</p>
<h2 id="SDK_安装">SDK 安装</h2><p>我们提供了一个针对 iOS / OS X SDK 详细的安装指南：<a href="sdk_setup-ios.html">LeanCloud iOS / OS X SDK 安装指南</a></p>
<h2 id="对象">对象</h2><h3 id="AVObject">AVObject</h3><p>LeanCloud 的数据存储服务是建立在对象 — <code>AVObject</code> 基础上的，每个 <code>AVObject</code> 包含若干属性值对（key-value，也称「键值对」），属性的值是与 JSON 格式兼容的数据。你不需要预先指定每个 <code>AVObject</code> 包含哪些属性，每个属性的数据类型是什么，只要直接设定属性值对即可，你还可以随时增加新的属性。</p>
<p>假如我们要实现一个类似于微博的社交 app，主要有三类数据：账户、帖子、评论。以微博帖子为例，我们可以建立一个类名为 <code>Post</code> 的 <code>AVObject</code> 对象，包含下面几个属性：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">content:</span> <span class="string">"每个 Objective-C 程序员必备的 8 个开发工具"</span>, <span class="string">pubUser:</span> <span class="string">"LeanCloud官方客服"</span>, <span class="string">pubTimestamp:</span> <span class="number">1435541999</span></span><br></pre></td></tr></table></figure>
<p>属性名（也称「键」，key），必须是由字母、数字或下划线组成的字符串；自定义的属性名，不能以 <code>__</code>（双下划线）开头。属性值，可以是字符串、数字、布尔值，或是数组和字典。</p>
<p><strong>注意：以下为系统保留字段，不能作为属性名来使用。</strong></p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">acl             <span class="keyword">error</span>            pendingKeys</span><br><span class="line">ACL             fetchWhenSave    <span class="property">running</span></span><br><span class="line">className       <span class="property">id</span>               updatedAt</span><br><span class="line">code            isDataReady      uuid</span><br><span class="line">createdAt       keyValues</span><br><span class="line">description     objectId</span><br></pre></td></tr></table></figure>
<p>每个 <code>AVObject</code> 都必须有一个类（Class）名称，以便区分不同类型的数据。例如，微博帖子这个对象可取名为 <code>Post</code>。</p>
<p>我们建议将类和属性名分别按照 <code>NameYourClassesLikeThis</code> 和 <code>nameYourKeysLikeThis</code> 这样的惯例来命名，即区分第一个字母的大小写，这样可以提高代码的可读性和可维护性。</p>
<h3 id="保存对象">保存对象</h3><p>接下来，需要将上文中的 <code>Post</code> 存储到 LeanCloud 上。LeanCloud 的相关接口和 <code>NSMutableDictionary</code> 类似，但只有在调用 <code>save</code> 方法时，数据才会被真正保存下来。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVObject</span> *post = [<span class="built_in">AVObject</span> objectWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[post setObject:<span class="string">@"每个 Objective-C 程序员必备的 8 个开发工具"</span> forKey:<span class="string">@"content"</span>];</span><br><span class="line">[post setObject:<span class="string">@"LeanCloud官方客服"</span> forKey:<span class="string">@"pubUser"</span>];</span><br><span class="line">[post setObject:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1435541999</span>] forKey:<span class="string">@"pubTimestamp"</span>];</span><br><span class="line">[post save];</span><br></pre></td></tr></table></figure>
<p>或者用下标用法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVObject</span> *post = [<span class="built_in">AVObject</span> objectWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">post[<span class="string">@"content"</span>] = <span class="string">@"每个 Objective-C 程序员必备的 8 个开发工具"</span>;</span><br><span class="line">post[<span class="string">@"pubUser"</span>] = <span class="string">@"LeanCloud官方客服"</span>;</span><br><span class="line">post[<span class="string">@"pubTimestamp"</span>] = @(<span class="number">1435541999</span>);</span><br><span class="line">[post save];</span><br></pre></td></tr></table></figure>
<p>运行此代码后，要想确认保存动作是否已经生效，可以到 LeanCloud 应用管理平台的 <a href="/data.html?appid=&lt;!--￼119--">数据管理</a> 页面来查看数据的存储情况。</p>
<p>如果保存成功，<code>Post</code> 的数据表中应该显示出以下记录：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objectId: <span class="string">"558e20cbe4b060308e3eb36c"</span>, content: <span class="string">"每个 Objective-C 程序员必备的 8 个开发工具"</span>, pubUser: <span class="string">"LeanCloud官方客服"</span>, pubTimestamp: <span class="number">1435541999</span>,</span><br><span class="line">createdAt:<span class="string">"2015-06-29 09:39:35"</span>, updatedAt:<span class="string">"2015-06-29 09:39:35"</span></span><br></pre></td></tr></table></figure>
<p>在此要特别说明两点：</p>
<ol>
<li><p>运行此代码前，不用配置或设置 <code>Post</code> 类，LeanCloud 会自动创建这个类。</p>
</li>
<li><p>对于每一个 AVObject，系统内置了一些属性，以下字段不需要提前指定：</p>
<ul>
<li><code>objectId</code> 是为每个对象自动生成的唯一的标识符</li>
<li><code>createdAt</code> 和 <code>updatedAt</code> 分别代表每个对象在 LeanCloud 中创建和最后修改的时间，它们会被自动赋值。</li>
</ul>
<p>在执行保存操作之前，这些字段不会被自动保存到 <code>AVObject</code> 中。</p>
</li>
</ol>
<h3 id="检索对象">检索对象</h3><p>将数据保存到 LeanCloud 上实现起来简单而直观，获取数据也是如此。如果已知 <code>objectId</code>，用 <code>AVQuery</code> 就可以查询到对应的 <code>AVObject</code> 实例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line"><span class="built_in">AVObject</span> *post = [query getObjectWithId:<span class="string">@"558e20cbe4b060308e3eb36c"</span>];</span><br></pre></td></tr></table></figure>
<p>接下来可以用 <code>objectForKey:</code>或下标语法来获取属性值：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> timestamp = [[post objectForKey:<span class="string">@"pubTimestamp"</span>] intValue];</span><br><span class="line"><span class="built_in">NSString</span> *userName = [post objectForKey:<span class="string">@"pubUser"</span>];</span><br><span class="line"><span class="built_in">NSString</span> *content = post[<span class="string">@"content"</span>];</span><br></pre></td></tr></table></figure>
<p>获取三个特殊属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *objectId = post<span class="variable">.objectId</span>;</span><br><span class="line"><span class="built_in">NSDate</span> *updatedAt = post<span class="variable">.updatedAt</span>;</span><br><span class="line"><span class="built_in">NSDate</span> *createdAt = post<span class="variable">.createdAt</span>;</span><br></pre></td></tr></table></figure>
<p>如果需要刷新特定对象的最新数据，可调用 <code>refresh</code> 方法 ：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[myObject refresh];</span><br></pre></td></tr></table></figure>
<h3 id="后台运行">后台运行</h3><p>在 iOS 或 OS X 中，大部分代码是在主线程中运行的。不过，当应用在主线程中访问网络时，可能常会发生卡顿或崩溃现象。</p>
<p>由于 <code>save</code> 和 <code>getObjectWithId</code> 这两个方法会访问 LeanCloud 云端服务器，所以不应当在主线程上运行。这种情况一般处理起来比较麻烦，因此，LeanCloud 提供了辅助方法，能够覆盖绝大多数应用场景。</p>
<p>例如，方法 <code>saveInBackground</code> 可在后台线程中保存之前的 <code>AVObject</code> 实例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[post saveInBackground];</span><br></pre></td></tr></table></figure>
<p>这样，<code>saveInBackground</code> 的调用会立即返回，而主线程不会被阻塞，应用会保持在响应状态。</p>
<p>通常情况下，要在某操作完成后立即运行后面的代码，可以使用 Block（<code>...WithBlock</code> ：仅支持 iOS 4.0+ 或 OS X 10.6+）或回调（<code>...CallBack</code>）方法。</p>
<p>例如，在保存完成后运行一些代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[post saveInBackgroundWithBlock:^(<span class="built_in">BOOL</span> succeeded, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">    <span class="comment">// post 保存成功</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 保存 post 时出错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>或者写成回调方式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先创建一个回调</span></span><br><span class="line">- (<span class="keyword">void</span>)saveCallback:(<span class="built_in">NSNumber</span> *)result error:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">  <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">    <span class="comment">// post 保存成功</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 保存 post 时出错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后在后续代码中执行其他操作</span></span><br><span class="line">[post saveInBackgroundWithTarget:<span class="keyword">self</span></span><br><span class="line">                        selector:<span class="keyword">@selector</span>(saveCallback:error:)];</span><br></pre></td></tr></table></figure>
<p>LeanCloud 在进行网络通讯时不会阻塞调用线程，Block 或回调会在主线程执行。也就是说，网络访问不会对 UI 产生不良影响，在回调中可对 UI 进行操作。</p>
<p><code>AVQuery</code> 也遵循相同的模式。如果需要从对象 <code>Post</code> 获取并修改某一条微博帖子，同时又确保主线程不会被阻塞，则可以：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[query getObjectInBackgroundWithId:<span class="string">@"558e20cbe4b060308e3eb36c"</span></span><br><span class="line">                             block:^(<span class="built_in">AVObject</span> *post, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">    <span class="comment">// get 请求成功完成，结果存在 post 实例中</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"The content was: %@"</span>, [post objectForKey:<span class="string">@"content"</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 请求失败，输出错误信息</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Error: %@ %@"</span>, error, [error userInfo]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>或用回调方式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先创建一个回调</span></span><br><span class="line">- (<span class="keyword">void</span>)getCallback:(<span class="built_in">AVObject</span> *)post error:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">  <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">    <span class="comment">// get 请求成功完成，结果存在 post 实例中</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"The content was: %@"</span>, [post objectForKey:<span class="string">@"content"</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 请求失败，输出错误信息</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Error: %@ %@"</span>, error, [error userInfo]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后在后续代码中执行其他操作</span></span><br><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[query getObjectInBackgroundWithId:<span class="string">@"558e20cbe4b060308e3eb36c"</span></span><br><span class="line">                            target:<span class="keyword">self</span></span><br><span class="line">                          selector:<span class="keyword">@selector</span>(getCallback:error:)];</span><br></pre></td></tr></table></figure>
<h3 id="离线存储对象">离线存储对象</h3><p>大多数保存功能可以立刻执行，并通知应用「保存完毕」。不过若不需要知道保存完成的时间，则可使用 <code>saveEventually</code> 来代替。</p>
<p>它的优点在于：如果用户目前尚未接入网络，<code>saveEventually</code> 会缓存设备中的数据，并在网络连接恢复后上传。如果应用在网络恢复之前就被关闭了，那么当它下一次打开时，LeanCloud 会再次尝试保存操作。</p>
<p>所有 <code>saveEventually</code>（或 <code>deleteEventually</code>）的相关调用，将按照调用的顺序依次执行。因此，多次对某一对象使用 <code>saveEventually</code> 是安全的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="built_in">AVObject</span> *post = [<span class="built_in">AVObject</span> objectWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[post setObject:<span class="string">@"居有良田，食有黍稷；躬耕山間，優游人世；生之所往，不過良風年年。"</span> forKey:<span class="string">@"content"</span>];</span><br><span class="line">[post setObject:<span class="string">@"LeanCloud官方客服"</span> forKey:<span class="string">@"pubUser"</span>];</span><br><span class="line">[post setObject:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1435541999</span>] forKey:<span class="string">@"pubTimestamp"</span>];</span><br><span class="line">[post saveInBackgroundWithBlock:^(<span class="built_in">BOOL</span> succeeded, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line"></span><br><span class="line">    [post setObject:<span class="string">@"http://tp1.sinaimg.cn/3652761852/50/5730347813/0"</span> forKey:<span class="string">@"pubUserAvatar"</span>];</span><br><span class="line">    [post saveEventually];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="更新对象">更新对象</h3><p>更新对象非常简单，仅需要更新其属性，再调用保存方法即可。例如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="built_in">AVObject</span> *post = [<span class="built_in">AVObject</span> objectWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[post setObject:<span class="string">@"居有良田，食有黍稷；躬耕山間，優游人世；生之所往，不過良風年年。"</span> forKey:<span class="string">@"content"</span>];</span><br><span class="line">[post setObject:<span class="string">@"LeanCloud官方客服"</span> forKey:<span class="string">@"pubUser"</span>];</span><br><span class="line">[post setObject:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1435541999</span>] forKey:<span class="string">@"pubTimestamp"</span>];</span><br><span class="line">[post saveInBackgroundWithBlock:^(<span class="built_in">BOOL</span> succeeded, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加些新数据，这次只更新头像和认证等级信息</span></span><br><span class="line">    [post setObject:<span class="string">@"http://tp1.sinaimg.cn/3652761852/50/5730347813/0"</span> forKey:<span class="string">@"pubUserAvatar"</span>];</span><br><span class="line">    [post setObject:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">4</span>] forKey:<span class="string">@"pubUserCertificate"</span>];</span><br><span class="line">    [post saveInBackground];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>SDK 内部会自动计算出哪些数据已经改变，并将修改过的的字段发送给 LeanCloud 云端。未更新的数据不会产生变动，这一点请不用担心。</p>
<p><strong>请注意，LeanCloud 上的更新对象都是针对单个对象，获得对象的 objectId 主键才可以去更新对象。服务端判断一个对象是新增还是更新，是根据有没有 objectId 来决定的。</strong></p>
<p>上面的例子是先创建对象，然后在 saveInBackgroundWithBlock 的 block 里更新对象，不过更常见的场景是你通过<a href="#查询">查询</a>得到一个 AVObject 对象，这个时候更新对象也是类似上面的代码那样，修改属性，调用 saveInBackground 即可。</p>
<p>如果你已经知道了 objectId（例如从查询后的列表页进入一个详情页面，传入了 objectId），想要修改一个对象，可以采用类似下面的代码来更新对象属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 知道 objectId，创建 AVObject</span></span><br><span class="line"><span class="built_in">AVObject</span> *post = [<span class="built_in">AVObject</span> objectWithoutDataWithClassName:<span class="string">@"Post"</span> objectId:<span class="string">@"5590cdfde4b00f7adb5860c8"</span>];</span><br><span class="line"><span class="comment">//更新属性</span></span><br><span class="line">[post setObject:<span class="string">@"http://tp1.sinaimg.cn/3652761852/50/5730347813/0"</span> forKey:<span class="string">@"pubUserAvatar"</span>];</span><br><span class="line">[post setObject:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">4</span>] forKey:<span class="string">@"pubUserCertificate"</span>];</span><br><span class="line"><span class="comment">//保存</span></span><br><span class="line">[post saveInBackground];</span><br></pre></td></tr></table></figure>
<h3 id="计数器">计数器</h3><p>许多应用都需要实现计数器功能。比如一条微博，我们需要记录有多少人喜欢或者转发了它。但可能很多次喜欢都是同时发生的，如果在每个客户端直接把它们读到的计数值增加之后再写回去，那么极容易引发冲突和覆盖，导致最终结果不准，这时可以用 <code>incrementKey:</code> 以原子操作方式来实现计数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVObject</span> *post = [<span class="built_in">AVObject</span> objectWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[post setObject:<span class="string">@"居有良田，食有黍稷；躬耕山間，優游人世；生之所往，不過良風年年。"</span> forKey:<span class="string">@"content"</span>];</span><br><span class="line">[post setObject:<span class="string">@"LeanCloud官方客服"</span> forKey:<span class="string">@"pubUser"</span>];</span><br><span class="line">[post setObject:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1435541999</span>] forKey:<span class="string">@"pubTimestamp"</span>];</span><br><span class="line">[post setObject:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">0</span>] forKey:<span class="string">@"upvotes"</span>]; <span class="comment">//初始值为 0</span></span><br><span class="line">[post saveInBackgroundWithBlock:^(<span class="built_in">BOOL</span> succeeded, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="comment">// 增加点赞的人数</span></span><br><span class="line">    [post incrementKey:<span class="string">@"upvotes"</span>];</span><br><span class="line">    [post saveInBackground];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>也可以使用 <code>incrementKey:byAmount:</code> 来给 Number 类型字段累加一个特定数值。</p>
<p>能不能不用特意去做 <code>fetch</code>，就马上得到计数器当前在后端的最新数据呢？这就需要使用 <code>fetchWhenSave</code> 属性。当它被设置为 <code>true</code> 时，SDK 会在保存操作发生时，自动返回当前计数器的最新数值。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">post<span class="variable">.fetchWhenSave</span> = <span class="literal">YES</span>;</span><br><span class="line">[post incrementKey:<span class="string">@"upvotes"</span>];</span><br><span class="line">[post saveInBackgroundWithBlock:^(<span class="built_in">BOOL</span> succeeded, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="comment">// 这时候 post.upvotes 的值会是最新的</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="数组">数组</h3><p>为了更好地存储数组类型的数据，LeanCloud 提供了三种不同的操作来自动更新数组字段：</p>
<ul>
<li><code>addObject:forKey:</code><br><br><code>addObjectsFromArray:forKey:</code><br><br>将指定对象附加到数组末尾。</li>
<li><code>addUniqueObject:forKey:</code><br><br><code>addUniqueObjectsFromArray:forKey:</code><br><br>如果不确定某个对象是否已包含在数组字段中，可以使用此操作来添加。对象的插入位置是随机的。  </li>
<li><code>removeObject:forKey:</code><br><br><code>removeObjectsInArray:forKey:</code><br><br>从数组字段中删除指定对象的所有实例。</li>
</ul>
<p>例如，给微博帖子添加 tags 字段：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[post addUniqueObjectsFromArray:[<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"编程"</span>, <span class="string">@"开发工具"</span>, <span class="literal">nil</span>] forKey:<span class="string">@"tags"</span>];</span><br><span class="line">[post saveInBackground];</span><br></pre></td></tr></table></figure>
<h3 id="删除对象">删除对象</h3><p>从 LeanCloud 中删除一个对象：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[myObject deleteInBackground];</span><br></pre></td></tr></table></figure>
<p>如果想通过回调来确认删除操作的结果，可以使用方法 <code>deleteInBackgroundWithBlock:</code> 或 <code>deleteInBackgroundWithTarget:selector:</code>。如果想强制在当前线程执行，使用 <code>delete</code>。</p>
<p><code>removeObjectForKey:</code> 方法会删除 AVObject 实例的单个属性。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除 post 实例中 pubTimestamp 字段的值，因为我们可以直接使用 createdAt 这个属性</span></span><br><span class="line">[myObject removeObjectForKey:<span class="string">@"pubTimestamp"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字段删除后结果保存到云端</span></span><br><span class="line">[myObject saveInBackground];</span><br></pre></td></tr></table></figure>
<h3 id="关联数据">关联数据</h3><p>对象可以与其他对象相联系。如前面所述，我们可以把一个 AVObject 的实例 a，当成另一个 AVObject 实例 b 的属性值保存起来。这可以解决数据之间一对一或者一对多的关系映射，就像数据库中的主外键关系一样。</p>
<p>注：LeanCloud 云端是通过 Pointer 类型来解决这种数据引用的，并不会将数据 a 在数据 b 的表中再额外存储一份，这也可以保证数据的一致性。</p>
<p>例如：一条微博信息可能会对应多条评论。创建一条微博信息并对应一条评论信息，你可以这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建微博、内容</span></span><br><span class="line"><span class="built_in">AVObject</span> *myPost = [<span class="built_in">AVObject</span> objectWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[myPost setObject:<span class="string">@"作为一个程序员，你认为回家以后要不要继续写代码？"</span> forKey:<span class="string">@"content"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建评论和内容</span></span><br><span class="line"><span class="built_in">AVObject</span> *myComment = [<span class="built_in">AVObject</span> objectWithClassName:<span class="string">@"Comment"</span>];</span><br><span class="line">[myComment setObject:<span class="string">@"我若是写代码，进入状态之后最好不要停。下不下班已经不重要了，那种感觉最重要。"</span> forKey:<span class="string">@"content"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为微博和评论建立一对一关系</span></span><br><span class="line">[myComment setObject:myPost forKey:<span class="string">@"post"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时保存 myPost、myComment</span></span><br><span class="line">[myComment saveInBackground];</span><br></pre></td></tr></table></figure>
<p>你也可以通过 objectId 来关联已有的对象：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把评论跟 objectId 为 "5590cdfde4b00f7adb5860c8" 的微博关联起来</span></span><br><span class="line">[myComment setObject:[<span class="built_in">AVObject</span> objectWithoutDataWithClassName:<span class="string">@"Post"</span> objectId:<span class="string">@"5590cdfde4b00f7adb5860c8"</span>]</span><br><span class="line">              forKey:<span class="string">@"post"</span>];</span><br></pre></td></tr></table></figure>
<p>默认情况下，在获取一个对象时，与其相关联的 <code>AVObject</code> 数据不会被一同返回。这些对象除了 <code>objectId</code> 之外，其他属性值都是空的，要得到关联对象的全部属性数据，需要再次调用 <code>fetch</code> 系方法:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取回关联的微博实例</span></span><br><span class="line"><span class="built_in">AVObject</span> *post = [fetchedComment objectForKey:<span class="string">@"post"</span>];</span><br><span class="line"><span class="comment">// 获取 post 的相关属性</span></span><br><span class="line">[post fetchIfNeededInBackgroundWithBlock:^(<span class="built_in">AVObject</span> *object, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">  <span class="comment">// 取回微博帖子内容</span></span><br><span class="line">  <span class="built_in">NSString</span> *content = [post objectForKey:<span class="string">@"content"</span>];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>还有另外一种复杂的情况，你可以使用 <code>AVRelation</code> 来建模「多对多」关系，它的工作原理类似于 <code>AVObject</code> 中的 <code>NSArray</code>。二者的不同之处在于，<code>AVRelation</code> 不用同步返回关联的所有 <code>AVObject</code> 实例数据。这意味着，使用 <code>AVRelation</code> 可以支持比 <code>NSArray</code> 更多的对象，它们的读取方式也更加灵活。</p>
<p>例如，一个用户喜欢多篇微博，就可以用 <code>relationforKey:</code> 来保存这些微博。将一篇微博按顺序添加到列表，可这样做：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVUser</span> *user = [<span class="built_in">AVUser</span> currentUser];</span><br><span class="line"><span class="built_in">AVRelation</span> *relation = [user relationforKey:<span class="string">@"likes"</span>];</span><br><span class="line">[relation addObject:post];</span><br><span class="line">[user saveInBackground];</span><br></pre></td></tr></table></figure>
<p>从 <code>AVRelation</code> 中移除一篇喜欢的微博：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[relation removeObject:post];</span><br></pre></td></tr></table></figure>
<p>默认情况下，这个关系中的对象列表不会被同步返回，需要从 <code>query</code> 查询返回的 <code>AVQuery</code> 中调用 <code>findObjectsInBackgroundWithBlock:</code> 方法来获得关联对象列表（这里是微博，Post），如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[relation query] findObjectsInBackgroundWithBlock:^(<span class="built_in">NSArray</span> *objects, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">  <span class="keyword">if</span> (error) &#123;</span><br><span class="line">     <span class="comment">// 呃，报错了</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// objects 包含了当前用户喜欢的所有微博</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>如果只想要文章对象的子集，则要对 <code>AVQuery</code> 添加额外的限制，如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span> *query = [relation query];</span><br><span class="line"><span class="comment">// 增加其他查询限制条件</span></span><br><span class="line">query<span class="variable">.skip</span> = <span class="number">10</span>;</span><br><span class="line">query<span class="variable">.limit</span> = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>如果想反向查询，比如，一篇微博被哪些用户喜欢过，可使用 <code>reverseQuery:</code> 来进行反向查询（同样，这也是直接使用 NSArray 作为属性值无法完成的），例如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVUser</span> *user = [<span class="built_in">AVUser</span> currentUser];</span><br><span class="line"><span class="built_in">AVRelation</span> *relation = [user relationforKey:<span class="string">@"likes"</span>];</span><br><span class="line"><span class="built_in">AVObject</span> *post = [<span class="built_in">AVObject</span> objectWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[post setObject:<span class="string">@"作为一个程序员，你认为回家以后要不要继续写代码？"</span> forKey:<span class="string">@"content"</span>];</span><br><span class="line">[post save];</span><br><span class="line">[relation addObject:post];</span><br><span class="line">[user save];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVRelation</span> reverseQuery:user<span class="variable">.className</span> relationKey:<span class="string">@"likes"</span> childObject:post];</span><br><span class="line">[query findObjectsInBackgroundWithBlock:^(<span class="built_in">NSArray</span> *users, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">   <span class="comment">// users 就是查询出来的喜欢 myPost 的所有 User 列表</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>要了解 <code>AVQuery</code> 更多的用法，请阅读本文 <a href="#查询">查询</a> 部分。<code>AVRelation</code> 的行为接近于 <code>AVObject</code> 中的 <code>NSArray</code>，所以在对象数组上的任何操作也同样适用于 <code>AVRelation</code>。</p>
<p><strong>请阅读《<a href="./relation_guide.html">关系建模指南</a>》来进一步了解关系类型。</strong></p>
<h3 id="批量操作">批量操作</h3><p>为了减少网络交互的次数太多带来的时间浪费，你可以在一个请求中对多个对象进行创建、更新、删除、获取。接口都在 AVObject 这个类下面：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 批量创建、更新</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)saveAll:(<span class="built_in">NSArray</span> *)objects error:(<span class="built_in">NSError</span> **)error;</span><br><span class="line">+ (<span class="keyword">void</span>)saveAllInBackground:(<span class="built_in">NSArray</span> *)objects</span><br><span class="line">						  block:(<span class="built_in">AVBooleanResultBlock</span>)block; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量删除</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)deleteAll:(<span class="built_in">NSArray</span> *)objects error:(<span class="built_in">NSError</span> **)error;</span><br><span class="line">+ (<span class="keyword">void</span>)deleteAllInBackground:(<span class="built_in">NSArray</span> *)objects</span><br><span class="line">                        block:(<span class="built_in">AVBooleanResultBlock</span>)block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量获取</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)fetchAll:(<span class="built_in">NSArray</span> *)objects error:(<span class="built_in">NSError</span> **)error;</span><br><span class="line">+ (<span class="keyword">void</span>)fetchAllInBackground:(<span class="built_in">NSArray</span> *)objects</span><br><span class="line">                       block:(<span class="built_in">AVArrayResultBlock</span>)block;</span><br></pre></td></tr></table></figure>
<p>比如 <code>Post</code> 用 <code>isRead</code> 字段来表示是否已读。获取一组微博对象之后，把这组对象标记为已读的代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取了一组 posts</span></span><br><span class="line"><span class="built_in">NSArray</span> *posts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">AVObject</span> *post <span class="keyword">in</span> posts) &#123;</span><br><span class="line">    post[<span class="string">@"isRead"</span>] = @(<span class="literal">YES</span>);</span><br><span class="line">&#125;</span><br><span class="line">[<span class="built_in">AVObject</span> saveAllInBackground:posts block:^(<span class="built_in">BOOL</span> succeeded, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="comment">// 网络错误</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 保存成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="数据类型">数据类型</h3><p>到目前为止，我们使用过的数据类型有 <code>NSString</code>、 <code>NSNumber</code>、 <code>AVObject</code>，LeanCloud 还支持 <code>NSDate</code> 和 <code>NSData</code>。</p>
<p>此外，<code>NSDictionary</code> 和 <code>NSArray</code> 支持嵌套，这样在一个 <code>AVObject</code> 中就可以使用它们来储存更多的结构化数据。例如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSNumber</span> *boolean = @(<span class="literal">YES</span>);</span><br><span class="line"><span class="built_in">NSNumber</span> *number = [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">2014</span>];</span><br><span class="line"><span class="built_in">NSString</span> *string = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"famous film name is %i"</span>, number];</span><br><span class="line"><span class="built_in">NSDate</span> *date = [<span class="built_in">NSDate</span> date];</span><br><span class="line"><span class="built_in">NSData</span> *data = [<span class="string">@"fooBar"</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *array = [<span class="built_in">NSArray</span> arrayWithObjects:string, number, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSDictionary</span> *dictionary = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:number, <span class="string">@"number"</span>,</span><br><span class="line">                                                                      string, <span class="string">@"string"</span>,</span><br><span class="line">                                                                      <span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVObject</span> *testObject = [<span class="built_in">AVObject</span> objectWithClassName:<span class="string">@"DataTypeTest"</span>];</span><br><span class="line">[testObject setObject:boolean    forKey:<span class="string">@"testBoolean"</span>];</span><br><span class="line">[testObject setObject:number     forKey:<span class="string">@"testInteger"</span>];</span><br><span class="line">[testObject setObject:string     forKey:<span class="string">@"testString"</span>];</span><br><span class="line">[testObject setObject:date       forKey:<span class="string">@"testDate"</span>];</span><br><span class="line">[testObject setObject:data       forKey:<span class="string">@"testData"</span>];</span><br><span class="line">[testObject setObject:array      forKey:<span class="string">@"testArray"</span>];</span><br><span class="line">[testObject setObject:dictionary forKey:<span class="string">@"testDictionary"</span>];</span><br><span class="line">[testObject saveInBackground];</span><br></pre></td></tr></table></figure>
<p>我们<strong>不推荐</strong>在 <code>AVObject</code> 中使用 <code>NSData</code> 类型来储存大块的二进制数据，比如图片或整个文件。<strong>每个 <code>AVObject</code> 的大小都不应超过 128 KB</strong>。如果需要储存更多的数据，建议使用 <code>AVFile</code>。更多细节可以阅读本文 <a href="#文件">文件</a> 部分。</p>
<p>若想了解更多有关 LeanCloud 如何解析处理数据的信息，请查看专题文档《<a href="./data_security.html">数据与安全</a>》。</p>
<h2 id="查询">查询</h2><p>我们已经看到，<code>AVQuery</code> 的 <code>getObjectWithId:</code> 方法可以从 LeanCloud 中检索出单个 <code>AVObject</code> 实例。此外，<code>AVQuery</code> 还提供更多的检索方法，来实现诸如一次检索许多对象、设定检索对象的条件、自动缓存查询结果等操作，免去了开发者需自行撰写代码的麻烦。</p>
<h3 id="基本查询">基本查询</h3><p>在许多情况下，<code>getObjectInBackgroundWithId:block:</code> 只能查找单个实例，并不能满足需求。除了检索单一对象，<code>AVQuery</code> 还允许以不同的检索方式来获取包含多个实例的列表。</p>
<p>一般的方式是创建一个 <code>AVQuery</code> 并设定相应的条件，然后用 <code>findObjectsInBackgroundWithBlock:</code> 检索得到一个 <code>AVObject</code> 组成的 <code>NSArray</code>。</p>
<p>例如，要查找指定 <code>pubUser</code> 发布的所有微博，可以使用 <code>whereKey:equalTo:</code> 方法来限定一个键和对应的值。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[query whereKey:<span class="string">@"pubUser"</span> equalTo:<span class="string">@"LeanCloud官方客服"</span>];</span><br><span class="line">[query findObjectsInBackgroundWithBlock:^(<span class="built_in">NSArray</span> *objects, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">    <span class="comment">// 检索成功</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Successfully retrieved %d posts."</span>, objects<span class="variable">.count</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 输出错误信息</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Error: %@ %@"</span>, error, [error userInfo]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p><code>findObjectsInBackgroundWithBlock:</code> 可以保证在完成网络请求的同时，不阻塞主线程中的 Block 和回调。</p>
<p>如果已运行在后台线程中，用 <code>findObjects</code> 方法可阻塞调用进程：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下代码仅可用于测试目的，或在后台线程之中运行</span></span><br><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[query whereKey:<span class="string">@"pubUser"</span> equalTo:<span class="string">@"LeanCloud官方客服"</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *postArray = [query findObjects];</span><br></pre></td></tr></table></figure>
<h3 id="查询约束">查询约束</h3><p>给 <code>AVQuery</code> 的检索添加约束条件有多种方法。</p>
<p>用 <code>whereKey:notEqualTo:</code> 搭配对应的键和值来过滤对象：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[query whereKey:<span class="string">@"pubUser"</span> notEqualTo:<span class="string">@"LeanCloud官方客服"</span>];</span><br></pre></td></tr></table></figure>
<p>一次查询可以设置多个约束条件，只有满足所有条件的对象才被返回，这相当于使用 AND 类型的查询条件。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[query whereKey:<span class="string">@"pubUser"</span> notEqualTo:<span class="string">@"LeanCloud官方客服"</span>];</span><br><span class="line">[query whereKey:<span class="string">@"pubUserCertificate"</span> greaterThan:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">3</span>]];</span><br></pre></td></tr></table></figure>
<p>用 <code>limit</code> 属性来控制返回结果的数量，默认值 100，允许取值范围从 1 到 1000。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query<span class="variable">.limit</span> = <span class="number">10</span>; <span class="comment">// 最多返回 10 条结果</span></span><br></pre></td></tr></table></figure>
<p>如果只需获取一个结果，直接使用 <code>getFirstObject</code> 或 <code>getFirstObjectInBackground</code>。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[query whereKey:<span class="string">@"pubUser"</span> equalTo:<span class="string">@"LeanCloud官方客服"</span>];</span><br><span class="line">[query getFirstObjectInBackgroundWithBlock:^(<span class="built_in">AVObject</span> *object, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!object) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"getFirstObject 请求失败。"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 查询成功</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"对象成功返回。"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p><code>skip</code> 用来跳过初始结果，这对分页非常有用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query<span class="variable">.skip</span> = <span class="number">10</span>; <span class="comment">// 跳过前 10 条结果</span></span><br></pre></td></tr></table></figure>
<p>对于适用的数据类型，如数字、字符串，可对返回结果进行排序：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按发帖时间升序排列</span></span><br><span class="line">[query orderByAscending:<span class="string">@"createdAt"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按发帖时间降序排列</span></span><br><span class="line">[query orderByDescending:<span class="string">@"createdAt"</span>];</span><br></pre></td></tr></table></figure>
<p>一个查询可以使用多个排序键：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若上一个排序键相等，按发帖者认证等级升序排列</span></span><br><span class="line">[query addAscendingOrder:<span class="string">@"pubUserCertificate"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果上一个排序键相等，按发帖者认证等级降序排列</span></span><br><span class="line">[query addDescendingOrder:<span class="string">@"pubUserCertificate"</span>];</span><br></pre></td></tr></table></figure>
<p>对于适用的数据类型，检索中可以使用「比较」方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点赞数 &lt; 50</span></span><br><span class="line">[query whereKey:<span class="string">@"upvotes"</span> lessThan:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">50</span>]];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点赞数 &lt;= 50</span></span><br><span class="line">[query whereKey:<span class="string">@"upvotes"</span> lessThanOrEqualTo:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">50</span>]];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点赞数 &gt; 50</span></span><br><span class="line">[query whereKey:<span class="string">@"upvotes"</span> greaterThan:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">50</span>]];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点赞数 &gt;= 50</span></span><br><span class="line">[query whereKey:<span class="string">@"upvotes"</span> greaterThanOrEqualTo:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">50</span>]];</span><br></pre></td></tr></table></figure>
<p><code>whereKey:containedIn:</code> 可查询包含不同值的对象。它接受数组，可实现用单一查询来代替多个查询。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出 “LeanCloud官方客服”，“LeanCloud江宏”，“滚滚艾买提” 三个账号的微博帖子</span></span><br><span class="line"><span class="built_in">NSArray</span> *names = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"LeanCloud官方客服"</span>,</span><br><span class="line">                                           <span class="string">@"LeanCloud江宏"</span>,</span><br><span class="line">                                           <span class="string">@"滚滚艾买提"</span>,</span><br><span class="line">                                           <span class="literal">nil</span>];</span><br><span class="line">[query whereKey:<span class="string">@"pubUser"</span> containedIn:names];</span><br></pre></td></tr></table></figure>
<p>相反，要让查询不包含某些值的对象，则用 <code>whereKey:notContainedIn:</code> ：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出除 “LeanCloud官方客服”，“LeanCloud江宏”，“滚滚艾买提” 三个账号以外的其他人的微博帖子</span></span><br><span class="line"><span class="built_in">NSArray</span> *names = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"LeanCloud官方客服"</span>,</span><br><span class="line">                                           <span class="string">@"LeanCloud江宏"</span>,</span><br><span class="line">                                           <span class="string">@"滚滚艾买提"</span>,</span><br><span class="line">                                           <span class="literal">nil</span>];</span><br><span class="line">[query whereKey:<span class="string">@"pubUser"</span> notContainedIn:names];</span><br></pre></td></tr></table></figure>
<p><code>whereKeyExists</code> 用来查询具备某一键集条件的对象，<code>whereKeyDoesNotExist</code> 正好相反。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到有图片的微博</span></span><br><span class="line">[query whereKeyExists:<span class="string">@"images"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有图片的微博</span></span><br><span class="line">[query whereKeyDoesNotExist:<span class="string">@"images"</span>];</span><br></pre></td></tr></table></figure>
<p>如果要用一个对象中某一键值，去匹配另一个查询结果对象中一个键值，来得到最终结果，可以使用 <code>whereKey:matchesKey:inQuery:</code> 。</p>
<p>例如，在微博这类应用中有三类数据：一个类是微博帖子信息（Post），另一个类是用户账户信息（AVUser），还有一个类是用户之间互相关注的信息（UserFollow），要找出当前用户关注的人发布的微博，则：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先找到当前登录用户关注的用户列表</span></span><br><span class="line"><span class="built_in">AVQuery</span> *followeeQuery = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"UserFollow"</span>];</span><br><span class="line">[followeeQuery whereKey:<span class="string">@"follower"</span> equalTo:[<span class="built_in">AVUser</span> currentUser]];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到这些被关注者发布的微博</span></span><br><span class="line"><span class="built_in">AVQuery</span> *postQuery = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[postQuery whereKey:<span class="string">@"author"</span> matchesKey:<span class="string">@"followee"</span> inQuery:followeeQuery];</span><br><span class="line">[postQuery findObjectsInBackgroundWithBlock:^(<span class="built_in">NSArray</span> *results, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="comment">// 得到当前用户关注的人发布的微博</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>相反，要从一个查询中获取一组对象，该对象的一个键值，与另一个对象的键值并不匹配，可以使用 <code>whereKey:doesNotMatchKey:inQuery:</code> 。</p>
<p>例如，找出当前用户没有关注的人发布的微博：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span> *postQuery = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[postQuery whereKey:<span class="string">@"author"</span> doesnotMatchesKey:<span class="string">@"followee"</span> inQuery:followeeQuery];</span><br><span class="line">[postQuery findObjectsInBackgroundWithBlock:^(<span class="built_in">NSArray</span> *results, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="comment">// 得到当前用户未关注的人发布的微博</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>将 <code>selectKeys:</code> 搭配 <code>NSArray</code> 类型的键值来使用可以限定查询返回的字段。</p>
<p>例如，让查询结果只包含 <code>pubUser</code> 和 <code>content</code> 字段（也可以是内置字段，如 <code>objectId</code>、 <code>createdAt</code> 或 <code>updatedAt</code>）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[query selectKeys:@[<span class="string">@"pubUser"</span>, <span class="string">@"content"</span>]];</span><br><span class="line"><span class="built_in">NSArray</span> *results = [query findObjects];</span><br></pre></td></tr></table></figure>
<p>其余字段可以稍后对返回的对象调用 <code>fetchIfNeeded</code> 的变体来获取：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVObject</span> *object = (<span class="built_in">AVObject</span> *)[results objectAtIndex:<span class="number">0</span>];</span><br><span class="line">[object fetchIfNeededInBackgroundWithBlock:^(<span class="built_in">AVObject</span> *object, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">  <span class="comment">// 返回该对象的所有字段</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="查询数组值">查询数组值</h3><p>当键值为数组类型时，<code>equalTo:</code> 可以从数组中找出包含单个值的对象：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出 arrayKey 中包含 2 的对象</span></span><br><span class="line">[query whereKey:<span class="string">@"arrayKey"</span> equalTo:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">2</span>]];</span><br></pre></td></tr></table></figure>
<p><code>containsAllObjectsInArray:</code> 可以找到包含多个值的对象:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出 arrayKey 中包含 2、3、4 的对象</span></span><br><span class="line">[query whereKey:<span class="string">@"arrayKey"</span> containsAllObjectsInArray:@[@<span class="number">2</span>, @<span class="number">3</span>, @<span class="number">4</span>]];</span><br></pre></td></tr></table></figure>
<h3 id="查询字符串值">查询字符串值</h3><p>使用 <code>whereKey:hasPrefix:</code> 可以过滤出以特定字符串开头的结果，这有点像 MySQL 的 <code>LIKE</code> 条件。因为支持索引，所以该操作对于大数据集也很高效。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出名字以 "LeanCloud" 开头的账户的微博帖子</span></span><br><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[query whereKey:<span class="string">@"pubUser"</span> hasPrefix:<span class="string">@"LeanCloud"</span>];</span><br></pre></td></tr></table></figure>
<h3 id="关系查询">关系查询</h3><p>检索关系数据有几种方法。如果用某个属性去匹配一个已知的 <code>AVObject</code> 对象，仍然可以使用 <code>whereKey:equalTo:</code>，就像使用其他数据类型一样。</p>
<p>例如，如果每条评论 <code>Comment</code> 的 <code>post</code> 字段都有一个 <code>Post</code> 微博对象，那么找出指定微博下的评论：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设前面已建好了 myPost 这个 AVObject 对象</span></span><br><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Comment"</span>];</span><br><span class="line">[query whereKey:<span class="string">@"post"</span> equalTo:myPost];</span><br><span class="line"></span><br><span class="line">[query findObjectsInBackgroundWithBlock:^(<span class="built_in">NSArray</span> *comments, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="comment">// comments 包含了 myPost 下的所有评论</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>或通过 <code>objectId</code> 做关系查询：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[query whereKey:<span class="string">@"post"</span></span><br><span class="line">        equalTo:[<span class="built_in">AVObject</span> objectWithoutDataWithClassName:<span class="string">@"Post"</span> objectId:<span class="string">@"5590cdfde4b00f7adb5860c8"</span>];</span><br></pre></td></tr></table></figure>
<p>如果要做嵌套查询，请使用 <code>whereKey:matchesQuery</code>。</p>
<p>例如，找出所有带图片的微博的评论：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span> *innerQuery = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[innerQuery whereKeyExists:<span class="string">@"image"</span>];</span><br><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Comment"</span>];</span><br><span class="line">[query whereKey:<span class="string">@"post"</span> matchesQuery:innerQuery];</span><br><span class="line">[query findObjectsInBackgroundWithBlock:^(<span class="built_in">NSArray</span> *comments, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="comment">// 所有带图片的微博的评论都在 comments</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>相反，<code>whereKey:doesNotMatchQuery:</code> 可以找出一个对象的某个属性与另一个查询不匹配的结果。例如，找出所有 不带图片的文章的评论：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span> *innerQuery = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[innerQuery whereKeyExists:<span class="string">@"image"</span>];</span><br><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Comment"</span>];</span><br><span class="line">[query whereKey:<span class="string">@"post"</span> doesNotMatchQuery:innerQuery];</span><br><span class="line">[query findObjectsInBackgroundWithBlock:^(<span class="built_in">NSArray</span> *comments, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="comment">// comments 包含了所有没有图片的文章的评论</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>注意：结果返回数量（默认 100 最多 1000）的限制也适用于内嵌查询，所以在处理大型数据集时，你可能需要仔细设置查询条件来获得想要的结果。</p>
<p>在一些场景中，如果需要在一个查询中返回多个类型的关联属性，可以使用方法 <code>includeKey:</code>。例如，搜索最近的十条评论，并同时找出与之对应的文章：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Comment"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找出最近刚创建的记录</span></span><br><span class="line">[query orderByDescending:<span class="string">@"createdAt"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只取前十条</span></span><br><span class="line">query<span class="variable">.limit</span> = [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找出每条评论所对应的文章</span></span><br><span class="line">[query includeKey:<span class="string">@"post"</span>];</span><br><span class="line"></span><br><span class="line">[query findObjectsInBackgroundWithBlock:^(<span class="built_in">NSArray</span> *comments, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="comment">// comments 是最近的十条评论, 其 post 字段也有相应数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">AVObject</span> *comment <span class="keyword">in</span> comments) &#123;</span><br><span class="line">         <span class="comment">// 并不需要网络访问</span></span><br><span class="line">         <span class="built_in">AVObject</span> *post = [comment objectForKey:<span class="string">@"post"</span>];</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"retrieved related post: %@"</span>, post);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p><strong>使用点（<code>.</code>）操作符可以检索多层级的数据（AVObject 对象）</strong>。例如，在结果中加入评论所对应的微博，以及该微博的作者：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[query includeKey:<span class="string">@"post.author"</span>];</span><br></pre></td></tr></table></figure>
<p><code>includeKey:</code> 既可在一次查询中多次使用来返回多个属性，也可与 <code>AVQuery</code> 的 <code>getFirstObject</code> 和 <code>getObjectInBackground</code> 等辅助方法配合使用。</p>
<p>还有一种情况，当某些对象包括多个键，而某些键的值包含的数据量又比较大，你并不希望返回所有的数据，只想要特定键所对应的数据，这时可以用 <code>selectKeys:</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[query selectKeys:@[<span class="string">@"pubUser"</span>]];</span><br><span class="line"><span class="built_in">AVObject</span> *result = [query getFirstObject];</span><br></pre></td></tr></table></figure>
<p>只返回指定键对应的有限数据，而非所有数据，有助于节省网络带宽和计算资源。</p>
<h3 id="缓存查询">缓存查询</h3><p>通常，将请求结果缓存到磁盘上是一种行之有效的方法，这样就算设备离线，应用刚刚打开，网络请求尚未完成时，数据也能显示出来。当缓存占用太多空间时，LeanCloud 会自动对其清理。</p>
<p>默认的查询行为不使用缓存，需要通过 <code>query.cachePolicy</code> 来启用。例如，当网络不可用时，尝试网络连接并同时取回已缓存的数据:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">query<span class="variable">.cachePolicy</span> = k<span class="built_in">AVCachePolicyNetworkElseCache</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置缓存有效期</span></span><br><span class="line">query<span class="variable">.maxCacheAge</span> = <span class="number">24</span>*<span class="number">3600</span>;</span><br><span class="line"></span><br><span class="line">[query findObjectsInBackgroundWithBlock:^(<span class="built_in">NSArray</span> *objects, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">    <span class="comment">// 成功找到结果，先找网络再访问磁盘</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 无法访问网络，本次查询结果未做缓存</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>LeanCloud 提供了几种不同的缓存策略：</p>
<ul>
<li><p><code>kAVCachePolicyIgnoreCache</code></p>
<p><strong>（默认缓存策略）</strong>查询行为不从缓存加载，也不会将结果保存到缓存中。</p>
</li>
<li><p><code>kAVCachePolicyCacheOnly</code></p>
<p>查询行为忽略网络状况，只从缓存加载。如果没有缓存结果，该策略会产生 <code>AVError</code>。</p>
</li>
<li><p><code>kAVCachePolicyCacheElseNetwork</code></p>
<p>查询行为首先尝试从缓存加载，若加载失败，则通过网络加载结果。如果缓存和网络获取行为均为失败，则产生 <code>AVError</code>。</p>
</li>
<li><p><code>kAVCachePolicyNetworkElseCache</code></p>
<p>查询行为先尝试从网络加载，若加载失败，则从缓存加载结果。如果缓存和网络获取行为均为失败，则产生 <code>AVError</code>。</p>
</li>
<li><p><code>kAVCachePolicyCacheThenNetwork</code></p>
<p>查询先从缓存加载，然后从网络加载。在这种情况下，回调函数会被调用两次，第一次是缓存中的结果，然后是从网络获取的结果。因为它会在不同的时间返回两个结果，所以该策略不能与 <code>findObjects</code> 同时使用。</p>
</li>
</ul>
<p>要控制缓存行为，可以使用 <code>AVQuery</code> 提供的相应方法：</p>
<ul>
<li><p>检查是否存在缓存查询结果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> isInCache = [query hasCachedResult];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>删除某一查询的任何缓存结果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[query clearCachedResult];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>删除查询的所有缓存结果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVQuery</span> clearAllCachedResults];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>设定缓存结果的最长时限：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query<span class="variable">.maxCacheAge</span> = <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>; <span class="comment">// 一天的总秒数</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>查询缓存也适用于 <code>AVQuery</code> 的辅助方法，包括 <code>getFirstObject</code> 和 <code>getObjectInBackground</code>。</p>
<h3 id="对象计数">对象计数</h3><p>如果只需要得到查询出来的对象数量，不需要检索匹配的对象，可以用 <code>countObjects</code> 来代替 <code>findObjects</code>。</p>
<p>例如，计算一下某位用户一共发布了多少条微博：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[query whereKey:<span class="string">@"pubUser"</span> equalTo:<span class="string">@"张三"</span>];</span><br><span class="line">[query countObjectsInBackgroundWithBlock:^(<span class="keyword">int</span> count, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">    <span class="comment">// 查询成功，输出计数</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"张三 发布了 %d 条微博"</span>, count);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 查询失败</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p><code>countObjects</code> 是一种同步式的方法，因此使用它可以阻塞调用线程。</p>
<p>对含有超过 1000 个对象的类，使用计数操作很可能会导致响应超时，或返回数值近似精确，所以在构建程序时，应该尽量避免这样的操作。</p>
<h3 id="复合查询">复合查询</h3><p>如果想从多个查询中，找出与其中任意一个相匹配的对象，可以使用方法 <code>orQueryWithSubqueries:</code>。</p>
<p>例如，找出赢了很多场比赛或者只赢了几场比赛的球员：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span> *lotsOfWins = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Player"</span>];</span><br><span class="line">[lotsOfWins whereKey:<span class="string">@"wins"</span> greaterThan:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">150</span>]];</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVQuery</span> *fewWins = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Player"</span>];</span><br><span class="line">[fewWins whereKey:<span class="string">@"wins"</span> lessThan:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">5</span>]];</span><br><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVQuery</span> orQueryWithSubqueries:[<span class="built_in">NSArray</span> arrayWithObjects:fewWins,lotsOfWins,<span class="literal">nil</span>]];</span><br><span class="line">[query findObjectsInBackgroundWithBlock:^(<span class="built_in">NSArray</span> *results, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">  <span class="comment">// 返回赢球次数大于 150 场或小于 5 场的球员</span></span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p>你可以对新创建的 <code>AVQuery</code> 添加额外的约束，多个约束将以 AND 运算符来联接。</p>
<p>注意：在复合查询的子查询中，不能使用非过滤性的约束（如 <code>limit</code>、 <code>skip</code>、<code>orderBy...:</code>、 <code>includeKey:</code>）。</p>
<h3 id="Cloud_Query_Language（CQL）查询">Cloud Query Language（CQL）查询</h3><p>我们还提供类似于 SQL 语言的查询语言 CQL，使用方法如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *cql = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"select * from %@"</span>, <span class="string">@"ATestClass"</span>];</span><br><span class="line"><span class="built_in">AVCloudQueryResult</span> *result = [<span class="built_in">AVQuery</span> doCloudQueryWithCQL:cql];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"results:%@"</span>, result<span class="variable">.results</span>);</span><br><span class="line"></span><br><span class="line">cql = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"select count(*) from %@"</span>, <span class="string">@"ATestClass"</span>];</span><br><span class="line">result = [<span class="built_in">AVQuery</span> doCloudQueryWithCQL:cql];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"count:%lu"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)result<span class="variable">.count</span>);</span><br></pre></td></tr></table></figure>
<p>通常，查询语句会使用变量参数。为此，我们提供了与 Java JDBC 所使用的 <code>PreparedStatement</code> 占位符查询相类似的语法结构。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *cql = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"select * from %@ where durability = ? and name = ?"</span>, <span class="string">@"ATestClass"</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *pvalues =  @[@<span class="number">100</span>, <span class="string">@"祈福"</span>];</span><br><span class="line">[<span class="built_in">AVQuery</span> doCloudQueryInBackgroundWithCQL:cql pvalues:pvalues callback:^(<span class="built_in">AVCloudQueryResult</span> *result, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="comment">// 操作成功</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>可变参数 <code>100</code> 和 <code>&quot;祈福&quot;</code> 会被自动替换到查询语句中的问号位置（按问号出现的先后顺序）。我们更推荐使用占位符语法，理论上这样会降低 CQL 转换的性能开销。</p>
<p>关于 CQL 的详细介绍，请参考 <a href="cql_guide.html">Cloud Query Language 详细指南</a>。</p>
<h2 id="应用内搜索">应用内搜索</h2><p>我们虽然提供了基于正则的模糊查询，但是正则查询有两个缺点：</p>
<ul>
<li>当数据量逐步增大后，查询效率将越来越低</li>
<li>没有文本相关性排序</li>
</ul>
<p>因此，我们还提供了<a href="./app_search_guide.html">应用内搜索功能</a>，基于搜索引擎构建，提供更强大的搜索功能。</p>
<h2 id="子类化">子类化</h2><p>LeanCloud 设计的目标是让你的应用尽快运行起来。你可以用 <code>AVObject</code> 访问到所有的数据，用 <code>objectForKey:</code> 获取任意字段。 在成熟的代码中，子类化有很多优势，包括降低代码量，具有更好的扩展性，和支持自动补全。</p>
<p>子类化是可选的，请对照下面的例子来加深理解：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AVObject *student = [AVObject <span class="string">objectWithClassName:</span>@<span class="string">"Student"</span>];</span><br><span class="line">[student <span class="string">setObject:</span>@<span class="string">"小明"</span> <span class="string">forKey:</span>@<span class="string">"name"</span>];</span><br><span class="line">[student saveInBackground];</span><br></pre></td></tr></table></figure>
<p>可改写成:</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student *student = <span class="string">[Student object]</span>;</span><br><span class="line">student.name = @<span class="string">"小明"</span>;</span><br><span class="line"><span class="string">[student saveInBackground]</span>;</span><br></pre></td></tr></table></figure>
<p>这样代码看起来是不是更简洁呢？</p>
<h3 id="子类化的实现">子类化的实现</h3><p>要实现子类化，需要下面几个步骤：</p>
<ol>
<li>导入 <code>AVObject+Subclass.h</code>；</li>
<li>继承 <code>AVObject</code> 并实现 <code>AVSubclassing</code> 协议；</li>
<li>实现类方法 <code>parseClassName</code>，返回的字符串是原先要传给 <code>initWithClassName:</code> 的参数，这样后续就不必再进行类名引用了。如果不实现，默认返回的是类的名字。<strong>请注意： <code>AVUser</code> 子类化后必须返回 <code>_User</code></strong>；</li>
<li>在实例化子类之前调用 <code>[YourClass registerSubclass]</code>（<strong>在应用当前生命周期中，只需要调用一次</strong>，所以建议放在 <code>ApplicationDelegate</code> 中，在 <code>[AVOSCloud setApplicationId:clientKey:]</code> 之前调用即可）。</li>
</ol>
<p>下面是实现 <code>Student</code> 子类化的例子:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student.h</span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;AVOSCloud/AVOSCloud.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">AVObject</span> &lt;<span class="title">AVSubclassing</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Student.m</span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"Student.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@dynamic</span> name;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSString</span> *)parseClassName &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@"Student"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// AppDelegate.m</span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;AVOSCloud/AVOSCloud.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"Student.h"</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">  [Student registerSubclass];</span><br><span class="line">  [<span class="built_in">AVOSCloud</span> setApplicationId:appid clientKey:appkey];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="属性">属性</h3><p>为 <code>AVObject</code> 的子类添加自定义的属性和方法，可以更好地将这个类的逻辑封装起来。用 <code>AVSubclassing</code> 可以把所有的相关逻辑放在一起，这样不必再使用不同的类来区分业务逻辑和存储转换逻辑了。</p>
<p><code>AVObject</code> 支持动态 synthesizer，就像 <code>NSManagedObject</code> 一样。先正常声明一个属性，只是在 .m 文件中把 <code>@synthesize</code> 变成 <code>@dynamic</code>。</p>
<p>请看下面的例子是怎么添加一个「年龄」属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student.h</span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;AVOSCloud/AVOSCloud.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">AVObject</span> &lt;<span class="title">AVSubclassing</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Student.m</span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"Student.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@dynamic</span> age;</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>这样就可以通过 <code>student.age = 19</code> 这样的方式来读写 <code>age</code> 字段了，当然也可以写成：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[student setAge:<span class="number">19</span>]</span><br></pre></td></tr></table></figure>
<p><strong>注意：属性名称保持首字母小写！</strong>（错误：<code>student.Age</code> 正确：<code>student.age</code>）。</p>
<p><code>NSNumber</code> 类型的属性可用 <code>NSNumber</code> 或者是它的原始数据类型（<code>int</code>、 <code>long</code> 等）来实现。例如， <code>[student objectForKey:@&quot;age&quot;]</code> 返回的是 <code>NSNumber</code> 类型，而实际被设为 <code>int</code> 类型。</p>
<p>你可以根据自己的需求来选择使用哪种类型。原始类型更为易用，而 <code>NSNumber</code> 支持 <code>nil</code> 值，这可以让结果更清晰易懂。</p>
<p><strong>注意</strong> 子类中，对于 <code>BOOL</code> 类型的字段，SDK 在 3.1.3.2 之前会将其保存为 Number 类型，3.1.3.2 之后将其正确保存为 Bool 类型。详情请参考<a href="https://leancloud.cn/docs/ios_os_x_faq.html#为什么升级到_3_1_3_2_以上的版本时_BOOL_类型数据保存错误_" target="_blank" rel="external">这里</a>。</p>
<p>注意：<code>AVRelation</code> 同样可以作为子类化的一个属性来使用，比如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">AVUser</span> &lt;<span class="title">AVSubclassing</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span>(retain) <span class="built_in">AVRelation</span> *friends;</span><br><span class="line">  ......</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"><span class="keyword">@dynamic</span> friends;</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure>
<p>另外，值为 Pointer 的实例可用 <code>AVObject*</code> 来表示。例如，如果 <code>Student</code> 中 <code>bestFriend</code> 代表一个指向另一个 <code>Student</code> 的键，由于 Student 是一个 AVObject，因此在表示这个键的值的时候，可以用一个 <code>AVObject*</code> 来代替：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">AVUser</span> &lt;<span class="title">AVSubclassing</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">AVObject</span> *bestFriend;</span><br><span class="line"> ......</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"><span class="keyword">@dynamic</span> bestFriend;</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure>
<p>提示：当需要更新的时候，最后都要记得加上 <code>[student save]</code> 或者对应的后台存储函数进行更新，才会同步至服务器。</p>
<p>如果要使用更复杂的逻辑而不是简单的属性访问，可以这样实现:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@dynamic</span> iconFile;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIImageView</span> *)iconView &#123;</span><br><span class="line">  <span class="built_in">UIImageView</span> *view = [[<span class="built_in">UIImageView</span> alloc] initWithImage:kPlaceholderImage];</span><br><span class="line">  view<span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:<span class="keyword">self</span><span class="variable">.iconFile</span>];</span><br><span class="line">  <span class="keyword">return</span> [view autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="针对_AVUser_子类化的特别说明">针对 AVUser 子类化的特别说明</h3><p>假如现在已经有一个基于 <code>AVUser</code> 的子类，如上面提到的 <code>Student</code>:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">AVUser</span>&lt;<span class="title">AVSubclassing</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (retain) <span class="built_in">NSString</span> *displayName;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"><span class="keyword">@dynamic</span> displayName;</span><br><span class="line">+ (<span class="built_in">NSString</span> *)parseClassName &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@"_User"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>登录时需要调用 <code>Student</code> 的登录方法才能通过 <code>currentUser</code> 得到这个子类:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Student logInWithUsernameInBackground:<span class="string">@"USER_NAME"</span> password:<span class="string">@"PASSWORD"</span> block:^(<span class="built_in">AVUser</span> *user, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        Student *student = [Student currentUser];</span><br><span class="line">        student<span class="variable">.displayName</span> = <span class="string">@"YOUR_DISPLAY_NAME"</span>;</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<p>同样需要调用 <code>[Student registerSubclass];</code>，确保在其它地方得到的对象是 Student，而非 AVUser 。</p>
<h3 id="初始化子类">初始化子类</h3><p>创建一个子类实例，要使用 <code>object</code> 类方法。要创建并关联到已有的对象，请使用 <code>objectWithoutDataWithObjectId:</code> 类方法。</p>
<h3 id="子类查询">子类查询</h3><p>使用类方法 <code>query</code> 可以得到这个子类的查询对象。</p>
<p>例如，查询年龄小于 21 岁的学生：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span> *query = [Student query];</span><br><span class="line">[query whereKey:<span class="string">@"age"</span> lessThanOrEqualTo:@(<span class="number">21</span>)];</span><br><span class="line">[query findObjectsInBackgroundWithBlock:^(<span class="built_in">NSArray</span> *objects, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">    Student *stu1 = [objects objectAtIndex:<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h2 id="ACL权限控制">ACL权限控制</h2><p>ACL（Access Control List）是最灵活而且简单的应用数据安全管理方法。通俗的解释就是为每一个数据创建一个访问的白名单列表，只有在名单上的用户（ <code>AVUser</code>）或者具有某种角色（<code>AVRole</code>）的用户才能被允许访问。为了更好地保证用户数据安全性，LeanCloud 的每一张表中都有一个 ACL 列。</p>
<p>当然，LeanCloud 还提供了进一步的读写权限控制。一个 User 必须拥有读权限（或者属于一个拥有读权限的 Role）才可以获取一个对象的数据；同时，一个 User 需要写权限（或者属于一个拥有写权限的 Role）才可以更改或者删除一个对象。</p>
<p>以下列举了几种在 LeanCloud 常见的 ACL 使用范例。</p>
<h3 id="默认访问权限">默认访问权限</h3><p>在没有显式指定的情况下，LeanCloud 中的每一个对象都会有一个默认的 ACL 值。这个值表示，所有的用户对这个对象都是可读可写的。此时在 LeanCloud 账户的「数据管理」列表中的 ACL 属性列，会看到这样的值：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;"<span class="attribute">*</span>":<span class="value">&#123;"<span class="attribute">read</span>":<span class="value"><span class="literal">true</span></span>,"<span class="attribute">write</span>":<span class="value"><span class="literal">true</span></span>&#125;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>对应的 Objective-C 代码是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVACL</span> *acl = [<span class="built_in">AVACL</span> ACL];</span><br><span class="line">[acl setPublicReadAccess:<span class="literal">YES</span>];</span><br><span class="line">[acl setPublicWriteAccess:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>
<p>当然正如上文提到的，默认的 ACL 并不需要进行显式指定。</p>
<h3 id="指定用户访问权限">指定用户访问权限</h3><p>当一个用户在实现一个网盘类应用时，针对不同文件的私密性，用户就需要不同的文件访问权限。譬如公开的文件，每一个其他用户都有读的权限，然后仅仅只有创建者才拥有更改和删除的权限。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">AVACL</span> *acl = [<span class="built_in">AVACL</span> ACL];</span><br><span class="line">[acl setPublicReadAccess:<span class="literal">YES</span>]; <span class="comment">//此处设置的是所有人的可读权限</span></span><br><span class="line">[acl setWriteAccess:<span class="literal">YES</span> forUser:[<span class="built_in">AVUser</span> currentUser]]; <span class="comment">//而这里设置了文件创建者的写权限</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">AVObject</span> * object = [<span class="built_in">AVObject</span> objectWithClassName:<span class="string">@"iOSAclTest"</span>];</span><br><span class="line"></span><br><span class="line">object<span class="variable">.ACL</span>=acl;</span><br><span class="line">[object save];</span><br></pre></td></tr></table></figure>
<p>当然用户也会上传一些隐私文件，只有这些文件的创建者才对这些文件拥有读写权限：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[acl setWriteAccess:<span class="literal">YES</span> forUser:[<span class="built_in">AVUser</span> currentUser]];</span><br></pre></td></tr></table></figure>
<p>注：一旦显式设置了 ACL，默认的 ACL 就会被覆盖。</p>
<h3 id="指定角色访问权限">指定角色访问权限</h3><h4 id="AVUser_与_AVRole_的从属关系">AVUser 与 AVRole 的从属关系</h4><p>指定用户访问权限虽然很方便，但是依然会有局限性。</p>
<p>以工资系统为例，一家公司的工资系统，工资最终的归属者和公司的出纳们只对工资有读的权限，而公司的人事和老板才拥有全部的读写权限。当然你可以通过多次设置指定用户的访问权限来实现这一功能（多个用户的 ACL 设置是追加的而非覆盖）。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVObect</span> *salary = [<span class="built_in">AVObject</span> objectWithClassName:<span class="string">@"Salary"</span>];</span><br><span class="line">[salary setObject:@(<span class="number">2000000</span>) forKey:<span class="string">@"value"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里为了方便说明, 直接声明了变量, 但没有实现</span></span><br><span class="line"><span class="built_in">AVUser</span> *boss;    <span class="comment">//假设此处为老板</span></span><br><span class="line"><span class="built_in">AVUser</span> *hrWang;  <span class="comment">//人事小王</span></span><br><span class="line"><span class="built_in">AVUser</span> *me;      <span class="comment">//我们就在文档里爽一爽吧</span></span><br><span class="line"><span class="built_in">AVUser</span> *cashierZhou;  <span class="comment">//出纳老周</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">AVACL</span> *acl = [<span class="built_in">AVACL</span> ACL];</span><br><span class="line"></span><br><span class="line"><span class="comment">//4 个人都有可读权限</span></span><br><span class="line">[acl setReadAccess:<span class="literal">YES</span> forUser:boss];</span><br><span class="line">[acl setReadAccess:<span class="literal">YES</span> forUser:hrWang];</span><br><span class="line">[acl setReadAccess:<span class="literal">YES</span> forUser:cashierZhou];</span><br><span class="line">[acl setReadAccess:<span class="literal">YES</span> forUser:me];</span><br><span class="line"></span><br><span class="line"><span class="comment">//只有 2 个人可写</span></span><br><span class="line">[acl setWriteAccess:<span class="literal">YES</span> forUser:boss];</span><br><span class="line">[acl setWriteAccess:<span class="literal">YES</span> forUser:hrWang];</span><br><span class="line"></span><br><span class="line">[salary setACL:acl];</span><br><span class="line">[salary save];</span><br></pre></td></tr></table></figure>
<p>但是涉及的人可能不止一个，也有离职、换岗、新员工的问题存在。这样的代码既不优雅，也太啰嗦，同样会很难维护。这个时候我们就引入了 <code>AVRole</code> 来解决这个问题。</p>
<p>公司的员工可以成百上千，然而一个公司组织里的角色却能够在很长一段时间内保持相对稳定。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVObect</span> *salary = [<span class="built_in">AVObject</span> objectWithClassName:<span class="string">@"Salary"</span>];</span><br><span class="line">[salary setObject:@(<span class="number">2000000</span>) forKey:<span class="string">@"value"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里为了方便说明, 直接声明了变量, 但没有实现</span></span><br><span class="line"><span class="built_in">AVUser</span> *boss;    <span class="comment">//假设此处为老板</span></span><br><span class="line"><span class="built_in">AVUser</span> *hrWang;  <span class="comment">//人事小王</span></span><br><span class="line"><span class="built_in">AVUser</span> *me;      <span class="comment">//我们就在文档里爽一爽吧</span></span><br><span class="line"><span class="built_in">AVUser</span> *cashierZhou; <span class="comment">//出纳老周</span></span><br><span class="line"><span class="built_in">AVUser</span> *cashierGe;   <span class="comment">//出纳小葛</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这段代码可能放在员工管理界面更恰当，但是为了示意，我们就放在这里</span></span><br><span class="line"><span class="built_in">AVRole</span> *hr =[<span class="built_in">AVRole</span> roleWithName:<span class="string">@"hr"</span>];</span><br><span class="line"><span class="built_in">AVRole</span> *cashier = [<span class="built_in">AVRole</span> roleWithName:<span class="string">@"cashier"</span>];</span><br><span class="line"></span><br><span class="line">[[hr users] addObject:hrWang];</span><br><span class="line">[hr save];</span><br><span class="line"><span class="comment">//此处对应的是 AVRole 里面有一个叫做 users 的 Relation 字段</span></span><br><span class="line">[[cashier users] addObject:cashierZhou];</span><br><span class="line">[[cashier users] addObject:cashierGe];</span><br><span class="line">[cashier save];</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVACL</span> *acl = [<span class="built_in">AVACL</span> ACL];</span><br><span class="line"><span class="comment">//老板假设只有一个</span></span><br><span class="line">[acl setReadAccess:<span class="literal">YES</span> forUser:boss];</span><br><span class="line">[acl setReadAccess:<span class="literal">YES</span> forUser:me];</span><br><span class="line"></span><br><span class="line">[acl setReadAccess:<span class="literal">YES</span> forRole:hr];</span><br><span class="line">[acl setReadAccess:<span class="literal">YES</span> forRole:cashier];</span><br><span class="line"></span><br><span class="line">[acl setWriteAccess:<span class="literal">YES</span> forUser:boss];</span><br><span class="line">[acl setWriteAccess:<span class="literal">YES</span> forRole:hr];</span><br><span class="line"></span><br><span class="line">[salary setACL:acl];</span><br><span class="line">[salary save];</span><br></pre></td></tr></table></figure>
<p>当然如果考虑到一个角色（<code>AVRole</code>）里面有多少员工（<code>AVUser</code>），编辑这些员工所需要的权限控制，<code>AVRole</code> 同样也有 <code>setACL</code> 方法可以使用。</p>
<h4 id="AVRole_之间的从属关系">AVRole 之间的从属关系</h4><p>在讲清楚了用户与角色的关系后，我们还有一层角色与角色之间的关系，下面的例子或许可以帮助你理解这个概念。</p>
<p>一家创业公司设有移动部门，该部门下面有不同的小组（Android 和 iOS），每个小组只对自己组的代码拥有「读写」权限，但他们同时对核心库代码拥有「读取」权限。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVRole</span> *androidTeam = [<span class="built_in">AVRole</span> roleWithName:<span class="string">@"AndroidTeam"</span>];</span><br><span class="line"><span class="built_in">AVRole</span> *iOSTeam = [<span class="built_in">AVRole</span> roleWithName:<span class="string">@"IOSTeam"</span>];</span><br><span class="line"><span class="built_in">AVRole</span> *mobileDev = [<span class="built_in">AVRole</span> roleWithName:<span class="string">@"MobileDev"</span>];</span><br><span class="line"></span><br><span class="line">[androidTeam save];</span><br><span class="line">[iOSTeam save];</span><br><span class="line"></span><br><span class="line">[[mobileDev roles] addObject:androidTeam];</span><br><span class="line">[[mobileDev roles] addObject:iOSTeam];</span><br><span class="line"></span><br><span class="line">[mobileDev save];</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVObject</span> *androidCode = [<span class="built_in">AVObject</span> objectWithClassName:<span class="string">@"Code"</span>];</span><br><span class="line"><span class="built_in">AVObject</span> *iOSCode = [<span class="built_in">AVObject</span> objectWithClassName:<span class="string">@"Code"</span>];</span><br><span class="line"><span class="built_in">AVObject</span> *coreCode = [<span class="built_in">AVObject</span> objectWithClassName:<span class="string">@"Code"</span>];</span><br><span class="line"><span class="comment">//.....此处省略一些具体的值设定</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">AVACL</span> *acl1=[<span class="built_in">AVACL</span> ACL];</span><br><span class="line">[acl1 setReadAccess:<span class="literal">YES</span> forRole:androidTeam];</span><br><span class="line">[acl1 setWriteAccess:<span class="literal">YES</span> forRole:androidTeam];</span><br><span class="line">[androidCode setACL:acl1];</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVACL</span> *acl2=[<span class="built_in">AVACL</span> ACL];</span><br><span class="line">[acl2 setReadAccess:<span class="literal">YES</span> forRole:iOSTeam];</span><br><span class="line">[acl2 setWriteAccess:<span class="literal">YES</span> forRole:iOSTeam];</span><br><span class="line">[iOSCode setACL:acl2];</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVACL</span> *acl3=[<span class="built_in">AVACL</span> ACL];</span><br><span class="line">[acl3 setReadAccess:<span class="literal">YES</span> forRole:mobileDev];</span><br><span class="line">[coreCode setACL:acl3];</span><br><span class="line"></span><br><span class="line">[androidCode save];</span><br><span class="line">[iOSTeam save];</span><br><span class="line">[coreCode save];</span><br></pre></td></tr></table></figure>
<h2 id="文件">文件</h2><h3 id="AVFile">AVFile</h3><p><code>AVFile</code> 允许应用将文件存储到服务端，它支持图片、视频、音乐等常见的文件类型，以及其他任何二进制数据。</p>
<p><code>AVFile</code> 的用法非常简单。首先把文件数据存到 <code>NSData</code> 中，然后用该 <code>NSData</code> 格式的数据来创建 <code>AVFile</code> 对象。下面以存储一个字符串为例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSData</span> *data = [<span class="string">@"Working with LeanCloud is great!"</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">AVFile</span> *file = [<span class="built_in">AVFile</span> fileWithName:<span class="string">@"resume.txt"</span> data:data];</span><br></pre></td></tr></table></figure>
<p>注意在上例中，我们将文件命名为 <code>resume.txt</code>。这里需要注意两点：</p>
<ul>
<li>不必担心文件名冲突。每一个上传的文件都有惟一的 ID，所以即使上传多个文件名为 <code>resume.txt</code> 的文件也不会有问题。</li>
<li>给文件添加扩展名非常重要。LeanCloud 通过扩展名来判断文件类型，以便正确处理文件。所以，要将一张 PNG 图片存到 <code>AVFile</code> 中，要确保使用 <code>.png</code> 扩展名。</li>
</ul>
<p>然后根据需要，调用相应的 <code>saveInBackground</code> 方法，将文件存到 LeanCloud 上：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[file saveInBackground];</span><br></pre></td></tr></table></figure>
<p>最终当文件存储完成后，你可以象操作其他数据那样，将 <code>AVFile</code> 关联到 <code>AVObject</code> 上。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVObject</span> *obj = [<span class="built_in">AVObject</span> objectWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[obj setObject:<span class="string">@"Joe Smit#花儿与少年# 迪拜疯狂之旅"</span> forKey:<span class="string">@"content"</span>];</span><br><span class="line">[obj setObject:file         forKey:<span class="string">@"attached"</span>];</span><br><span class="line">[obj saveInBackground];</span><br></pre></td></tr></table></figure>
<p>重新获取该数据时，只需要调用 <code>AVFile</code> 的 <code>getData</code> 方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVFile</span> *attachment = [anotherObj objectForKey:<span class="string">@"attached"</span>];</span><br><span class="line"><span class="built_in">NSData</span> *binaryData = [attachment getData];</span><br></pre></td></tr></table></figure>
<p>也可以像 <code>AVObject</code> 那样，使用 <code>getData</code> 的异步版本。</p>
<p><strong>如果对象的某一属性是一个文件数组，那么在获取该属性的查询中，必须加上 <code>includeKey:</code> 来指定该属性名，否则，查询结果中该属性对应的值将是 <code>AVObject</code> 数组，而不是 <code>AVFile</code> 数组。</strong></p>
<h3 id="图像">图像</h3><p>将图像转成 <code>NSData</code> 再使用 <code>AVFile</code> ，就能很容易地将数据保存到 LeanCloud 上。</p>
<p>例如，把名为 <code>image</code> 的 <code>UIImage</code> 对象保存到 <code>AVFile</code> 中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSData</span> *imageData = <span class="built_in">UIImagePNGRepresentation</span>(image);</span><br><span class="line"><span class="built_in">AVFile</span> *imageFile = [<span class="built_in">AVFile</span> fileWithName:<span class="string">@"image.png"</span> data:imageData];</span><br><span class="line">[imageFile save];</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVObject</span> *userPost = [<span class="built_in">AVObject</span> objectWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[userPost setObject:<span class="string">@"My trip to Dubai!"</span> forKey:<span class="string">@"content"</span>];</span><br><span class="line">[userPost setObject:imageFile            forKey:<span class="string">@"attached"</span>];</span><br><span class="line">[userPost save];</span><br></pre></td></tr></table></figure>
<h3 id="进度提示">进度提示</h3><p>使用 <code>saveInBackgroundWithBlock:progressBlock:</code> 和 <code>getDataInBackgroundWithBlock:progressBlock:</code> 可以获取 <code>AVFile</code> 的上传或下载进度。比如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSData</span> *data = [<span class="string">@"Working at LeanCloud is great!"</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">AVFile</span> *file = [<span class="built_in">AVFile</span> fileWithName:<span class="string">@"resume.txt"</span> data:data];</span><br><span class="line">[file saveInBackgroundWithBlock:^(<span class="built_in">BOOL</span> succeeded, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">  <span class="comment">// 成功或失败处理...</span></span><br><span class="line">&#125; progressBlock:^(<span class="keyword">int</span> percentDone) &#123;</span><br><span class="line">  <span class="comment">// 更新进度数据，percentDone 介于 0 和 100。</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="得到图像的缩略图">得到图像的缩略图</h3><p>保存图像时，如果想在下载原图之前先得到缩略图，那么用我们的 API 实现起来会易如反掌：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVFile</span> *file = [<span class="built_in">AVFile</span> fileWithURL:<span class="string">@"the-file-remote-url"</span>];</span><br><span class="line">[file getThumbnail:<span class="literal">YES</span> width:<span class="number">100</span> height:<span class="number">100</span> withBlock:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<h3 id="文件元数据">文件元数据</h3><p><code>AVFile</code> 的 <code>metaData</code> 属性，可以用来保存和获取该文件对象的元数据信息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVFile</span> *file = [<span class="built_in">AVFile</span> fileWithName:<span class="string">@"test.jpg"</span> contentsAtPath:<span class="string">@"file-local-path"</span>];</span><br><span class="line">[file<span class="variable">.metaData</span> setObject:@(<span class="number">100</span>) forKey:<span class="string">@"width"</span>];</span><br><span class="line">[file<span class="variable">.metaData</span> setObject:@(<span class="number">100</span>) forKey:<span class="string">@"height"</span>];</span><br><span class="line">[file<span class="variable">.metaData</span> setObject:<span class="string">@"LeanCloud"</span> forKey:<span class="string">@"author"</span>];</span><br><span class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">[file save:&amp;error];</span><br></pre></td></tr></table></figure>
<h3 id="删除">删除</h3><p>当文件较多时，要把一些不需要的文件从 LeanCloud 上删除：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[file deleteInBackgroundWithBlock:^(<span class="built_in">BOOL</span> succeeded, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="清除缓存">清除缓存</h3><p><code>AVFile</code> 也提供了清除缓存的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清除当前文件缓存</span></span><br><span class="line">- (<span class="keyword">void</span>)clearCachedFile;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类方法, 清除所有缓存</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)clearAllCachedFiles;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类方法, 清除多久以前的缓存</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)clearCacheMoreThanDays:(<span class="built_in">NSInteger</span>)numberOfDays;</span><br></pre></td></tr></table></figure>
<h3 id="iOS_9_适配">iOS 9 适配</h3><p>iOS 9 默认屏蔽了 HTTP 访问，只支持 HTTPS 访问。LeanCloud 除了文件的 getData 之外的 API 都是支持 HTTPS 访问的。 现有两种方式解决这个问题。</p>
<h4 id="项目中配置访问策略">项目中配置访问策略</h4><p>一是在项目中额外配置一下该接口的访问策略。选择项目的 Info.plist，右击以 Source Code 的方式打开。在 plist -&gt; dict 节点中加入以下文本：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">key</span>&gt;</span>NSAppTransportSecurity<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">dict</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">key</span>&gt;</span>NSExceptionDomains<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">key</span>&gt;</span>clouddn.com<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">dict</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">key</span>&gt;</span>NSIncludesSubdomains<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">true</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">key</span>&gt;</span>NSTemporaryExceptionAllowsInsecureHTTPLoads<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">true</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">dict</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dict</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者在 Target 的 Info 标签中修改配置：</p>
<p><img src="/avos/images/ios_qiniu_http.png" alt="Info.plist Setting"></p>
<p>如果是美国节点，请把上面的 <code>clouddn.com</code> 换成 <code>amazonaws.com</code>。</p>
<p>也可以根据项目需要，允许所有的 HTTP 访问，更多可参考 <a href="https://github.com/ChenYilong/iOS9AdaptationTips" target="_blank" rel="external">iOS 9 适配系列教程</a>。</p>
<h4 id="启用文件_SSL_域名">启用文件 SSL 域名</h4><p>另外一种方法是在网站控制台中进入相关的应用，点击上方的设置选项卡，勾选「启用文件 SSL 域名（对应 _File 中存储的文件）」选项。这样便启用了文件 SSL 域名，支持 HTTPS 访问。如图所示：</p>
<p><img src="/avos/images/ios_file_ssl_config.png" alt="File SSL Config"></p>
<p>如果启用文件 SSL 域名前已经保存了许多文件，启用之后，这些文件的 URL 也会跟着变化，来支持 HTTPS 访问。</p>
<p>这两种方式都能解决这个问题。但需要注意的是，实时通信组件 LeanMessage 也用了 AVFile 来保存消息的图片、音频等文件，并且把文件的地址写入到了消息内容中。开启了文件 SSL 域名后，历史消息中的文件地址将不会像控制台里 _File 表那样跟着改变。所以如果使用了实时通信组件并已上线，推荐使用方式一。</p>
<h2 id="用户">用户</h2><p>用户是一个应用程序的核心。对于个人开发者来说，能够让自己的应用程序积累更多的用户，就能给自己带来更多的创作动力。因此 LeanCloud 提供了一个专门的用户类 <code>AVUser</code>，来自动处理用户账户管理所需的功能。有了这个类，你就可以在应用程序中添加用户账户功能。</p>
<p><code>AVUser</code> 是一个 <code>AVObject</code> 的子类，它继承了 <code>AVObject</code> 所有的方法，具有 <code>AVObject</code> 相同的功能。不同的是，<code>AVUser</code> 增加了一些特定的与用户账户相关的功能。</p>
<h3 id="属性-1">属性</h3><p><code>AVUser</code> 除了继承 <code>AVObject</code> 的属性外，还有几个特有的属性：</p>
<ul>
<li><code>username</code> : 用户的用户名（必需）</li>
<li><code>password</code> : 用户的密码（必需）</li>
<li><code>email</code> : 用户的电子邮件地址（可选）</li>
</ul>
<h3 id="注册">注册</h3><p>要求用户注册可能是应用程序要做的第一件事。下面的代码是一个典型的注册过程：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVUser</span> *user = [<span class="built_in">AVUser</span> user];</span><br><span class="line">user<span class="variable">.username</span> = <span class="string">@"hjiang"</span>;</span><br><span class="line">user<span class="variable">.password</span> =  <span class="string">@"f32@ds*@&amp;dsa"</span>;</span><br><span class="line">user<span class="variable">.email</span> = <span class="string">@"hang@leancloud.rocks"</span>;</span><br><span class="line">[user setObject:<span class="string">@"186-1234-0000"</span> forKey:<span class="string">@"phone"</span>];</span><br><span class="line"></span><br><span class="line">[user signUpInBackgroundWithBlock:^(<span class="built_in">BOOL</span> succeeded, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (succeeded) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>在注册过程中，服务端会检查注册用户的信息，以确保注册的用户名和电子邮件地址是惟一的。</p>
<p><strong>服务端还会对用户密码进行不可逆的加密处理，不会明文保存任何密码。在客户端，应用切勿再次对密码加密，这会导致重置密码等功能失效。</strong></p>
<p>请注意，我们使用的是 <code>signUpInBackgroundWithBlock</code> 方法，而不是 <code>saveInBackground</code> 方法。另外还有各种不同的 <code>signUp</code> 方法可供使用。</p>
<p>像往常一样，我们建议，在可能的情况下，尽量使用异步版本的 <code>signUp</code> 方法，这样就不会影响到应用程序主 UI 线程的响应。具体方法请参考 <a href="/api-docs/iOS/index.html">API 文档</a> 。</p>
<p>如果注册不成功，请检查一下返回的错误对象。最有可能的情况是，用户名或电子邮件已经被另一个用户注册，此时可以提示用户尝试用不同的用户名进行注册，也可以要求用户用 Email 做为用户名注册。</p>
<p>这样做的好处是，在用户提交信息时可以将输入的「用户名」默认设置为用户的 Email 地址，以后在用户忘记了密码的情况下，可以使用 LeanCloud 提供的「重置密码」功能。</p>
<p>关于自定义邮件模板和验证链接，请参考博客文章 <a href="http://blog.leancloud.cn/blog/2014/01/09/zi-ding-yi-ying-yong-nei-yong-hu-zhong-she-mi-ma-he-you-xiang-yan-zheng-ye-mian/" target="_blank" rel="external">《自定义应用内用户重设密码和邮箱验证页面》</a>。</p>
<h3 id="登录">登录</h3><p>让注册成功的用户登录到自己的账户，可以调用 <code>AVUser</code> 类的 <code>loginInBackground</code> 方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVUser</span> logInWithUsernameInBackground:<span class="string">@"username"</span> password:<span class="string">@"password"</span> block:^(<span class="built_in">AVUser</span> *user, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (user != <span class="literal">nil</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="当前用户">当前用户</h3><p>如果用户在每次打开应用程序时都要登录，这会直接影响用户体验。为了避免这种情况，可以使用缓存的 <code>currentUser</code> 对象。</p>
<p>每当用户成功注册或第一次成功登录后，就在本地磁盘中缓存下这 个用户对象，供下次调用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVUser</span> *currentUser = [<span class="built_in">AVUser</span> currentUser];</span><br><span class="line"><span class="keyword">if</span> (currentUser != <span class="literal">nil</span>) &#123;</span><br><span class="line">    <span class="comment">// 允许用户使用应用</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//缓存用户对象为空时，可打开用户注册界面…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要清除缓存用户对象：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVUser</span> logOut];  <span class="comment">//清除缓存用户对象</span></span><br><span class="line"><span class="built_in">AVUser</span> *currentUser = [<span class="built_in">AVUser</span> currentUser]; <span class="comment">// 现在的currentUser是nil了</span></span><br></pre></td></tr></table></figure>
<h3 id="重置密码">重置密码</h3><p>我们都知道，应用一旦加入账户密码系统，那么肯定会有用户忘记密码的情况发生。对于这种情况，我们为用户提供了一种安全重置密码的方法。</p>
<p>重置密码的过程很简单，用户只需要输入注册的电子邮件地址即可：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVUser</span> requestPasswordResetForEmailInBackground:<span class="string">@"myemail@example.com"</span> block:^(<span class="built_in">BOOL</span> succeeded, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (succeeded) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>密码重置流程如下：</p>
<ol>
<li>用户输入注册的电子邮件，请求重置密码；</li>
<li>LeanCloud 向该邮箱发送一封包含重置密码的特殊链接的电子邮件；</li>
<li>用户点击重置密码链接后，一个特殊的页面会打开，让他们输入新密码；</li>
<li>用户的密码已被重置为新输入的密码。</li>
</ol>
<p>关于自定义邮件模板和验证链接，请参考这篇 <a href="http://blog.leancloud.cn/blog/2014/01/09/zi-ding-yi-ying-yong-nei-yong-hu-zhong-she-mi-ma-he-you-xiang-yan-zheng-ye-mian/" target="_blank" rel="external">博客</a> 。</p>
<h3 id="修改密码">修改密码</h3><p>当用户系统中存在密码时，自然会有更改密码的需求。我们所提供的方法能够同时验证老密码和修改新密码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVUser</span> logInWithUsername:<span class="string">@"username"</span> password:<span class="string">@"111111"</span>]; <span class="comment">//请确保用户当前的有效登录状态</span></span><br><span class="line">[[<span class="built_in">AVUser</span> currentUser] updatePassword:<span class="string">@"111111"</span> newPassword:<span class="string">@"123456"</span> block:^(<span class="keyword">id</span> object, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="comment">//处理结果</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>如果要求更改密码的用户尚未登录、原密码错误或用户不存在，这些情况都会通过回调返回操作错误信息。</p>
<h3 id="手机号码验证">手机号码验证</h3><p>如果在应用设置的 <strong>应用选项</strong> 中打开了 <strong>验证注册用户手机号码</strong> 选项，那么当用户在注册时填写完手机字段后，LeanCloud 会自动向该手机号码发送一条验证短信，用户输入验证码后，该用户即被标识为已经验证过手机了。</p>
<p>以下代码将注册验证码发送到用户手机上：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVUser</span> *user = [<span class="built_in">AVUser</span> user];</span><br><span class="line">user<span class="variable">.username</span> = <span class="string">@"hjiang"</span>;</span><br><span class="line">user<span class="variable">.password</span> =  <span class="string">@"f32@ds*@&amp;dsa"</span>;</span><br><span class="line">user<span class="variable">.email</span> = <span class="string">@"hang@leancloud.rocks"</span>;</span><br><span class="line">user<span class="variable">.mobilePhoneNumber</span> = <span class="string">@"18612340000"</span>;</span><br><span class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">[user signUp:&amp;error];</span><br></pre></td></tr></table></figure>
<p>调用以下代码即可验证验证码:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVUser</span> verifyMobilePhone:<span class="string">@"123456"</span> withBlock:^(<span class="built_in">BOOL</span> succeeded, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">       <span class="comment">//验证结果</span></span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure>
<p>验证成功后，用户的 <code>mobilePhoneVerified</code> 属性变为 <code>true</code>，并会触发调用云代码的 <code>AV.Cloud.onVerifed(&#39;sms&#39;, function)</code> 方法。</p>
<h3 id="手机号码登录">手机号码登录</h3><p>当手机号码通过验证后，用户可以使用该手机号码进行登录。手机号码包括两种方式：</p>
<ul>
<li>手机号码＋密码方式</li>
<li>手机号码＋短信验证码</li>
</ul>
<p>用「手机号码＋密码」来登录的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVUser</span> logInWithMobilePhoneNumberInBackground:<span class="string">@"18612340000"</span> password:<span class="string">@"yourpassword"</span> block:^(<span class="built_in">AVUser</span> *user, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>发送登录短信验证码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVUser</span> requestLoginSmsCode:<span class="string">@"123456"</span> withBlock:^(<span class="built_in">BOOL</span> succeeded, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>最后使用「短信验证码＋手机号码」进行登录：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVUser</span> logInWithMobilePhoneNumberInBackground:<span class="string">@"18612340000"</span> smsCode:smsCode block:^(<span class="built_in">AVUser</span> *user, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="手机号码重置密码">手机号码重置密码</h3><p>与使用「电子邮件地址重置密码」类似，「手机号码重置密码」使用下面的方法来获取短信验证码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVUser</span> requestPasswordResetWithPhoneNumber:<span class="string">@"18612340000"</span> block:^(<span class="built_in">BOOL</span> succeeded, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (succeeded) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>注意！用户需要先绑定手机号码，然后使用短信验证码来重置密码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVUser</span> resetPasswordWithSmsCode:<span class="string">@"123456"</span> newPassword:<span class="string">@"password"</span> block:^(<span class="built_in">BOOL</span> succeeded, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (succeeded) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="查询-1">查询</h3><p><strong>请注意，新创建应用的 <code>_User</code> 表的查询权限默认是关闭的，通常我们推荐你在云引擎里封装用户查询，只查询特定条件的用户，避免开放用户表的全部查询权限。此外，你可以通过 class 权限设置打开查询权限，请参考 <a href="data_security.html#Class_级别的权限">数据与安全 - Class 级别的权限</a>。</strong></p>
<p>查询用户的信息，需要使用特殊的用户查询对象来完成：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVUser</span> query];</span><br><span class="line">[query whereKey:<span class="string">@"gender"</span> equalTo:<span class="string">@"female"</span>];</span><br><span class="line">[query findObjectsInBackgroundWithBlock:^(<span class="built_in">NSArray</span> *objects, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (error == <span class="literal">nil</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="浏览器中查看用户表">浏览器中查看用户表</h3><p>用户表是一个特殊的表，专门存储 <code>AVUser</code> 对象。在浏览器端，打开 LeanCloud 账户页面的 <strong>存储</strong> 菜单，找到名为 <code>_User</code> 的表来查看数据。</p>
<h3 id="匿名用户">匿名用户</h3><p>要创建匿名用户，可以使用 <code>AVAnonymousUtils</code> 来完成。通过如下代码，服务端会自动创建一个 <code>AVUser</code> 对象，其用户名为随机字符串。完成之后，此用户对象会被设置为 <code>currentUser</code>，之后的修改、保存、登出等操作都可以使用 <code>currentUser</code> 来完成。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVAnonymousUtils</span> logInWithBlock:^(<span class="built_in">AVUser</span> *user, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (user) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h2 id="地理位置">地理位置</h2><p>LeanCloud 允许用户根据地球的经度和纬度坐标进行基于地理位置的信息查询。只要将 <code>AVGeoPoint</code> 添加到 <code>AVObject</code> 中，那么在查询时，即可轻松实现如找出离当前用户最近的信息或地点的功能。</p>
<h3 id="地理位置对象">地理位置对象</h3><p>首先要创建一个 <code>AVGeoPoint</code> 对象。例如，创建一个北纬 39.9 度、东经 116.4 度的 <code>AVGeoPoint</code> 对象（LeanCloud 北京办公室所在地）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVGeoPoint</span> *point = [<span class="built_in">AVGeoPoint</span> geoPointWithLatitude:<span class="number">39.9</span> longitude:<span class="number">116.4</span>];</span><br></pre></td></tr></table></figure>
<p>添加地理位置信息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[postObject setObject:point forKey:<span class="string">@"location"</span>];</span><br></pre></td></tr></table></figure>
<h3 id="地理查询">地理查询</h3><p>假设现在数据表中已保存了一些地理坐标数据，接下来使用 <code>AVQuery</code> 对象的 <code>whereNear</code> 方法来试着找出最接近某个点的信息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVObject</span> *userObject = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">AVGeoPoint</span> *userLocation =  (<span class="built_in">AVGeoPoint</span> *) [userObject objectForKey:<span class="string">@"location"</span>];</span><br><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[query whereKey:<span class="string">@"location"</span> nearGeoPoint:userLocation];</span><br><span class="line"><span class="comment">//获取最接近用户地点的10条微博</span></span><br><span class="line">query<span class="variable">.limit</span> = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">NSArray</span>&lt;<span class="built_in">AVObject</span> *&gt; nearPosts = [query findObjects];</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，<code>nearPosts</code> 返回的是与 <code>userLocation</code> 这一点按距离排序（由近到远）的对象数组。注意：<strong>如果在此之后又使用了 <code>orderByAscending:</code> 或 <code>orderByDescending:</code> 方法，则按距离排序会被新排序覆盖。</strong></p>
<p>要查找指定距离范围内的数据，可使用 <code>whereWithinKilometers</code> 、 <code>whereWithinMiles</code> 或 <code>whereWithinRadians</code> 方法。</p>
<p>要查找位于矩形范围内的信息，可使用 <code>whereWithinGeoBox</code> 来实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVGeoPoint</span> *point1 = [<span class="built_in">AVGeoPoint</span> geoPointWithLatitude:<span class="number">39.97</span> longitude:<span class="number">116.33</span>];</span><br><span class="line"><span class="built_in">AVGeoPoint</span> *point2 = [<span class="built_in">AVGeoPoint</span> geoPointWithLatitude:<span class="number">39.99</span> longitude:<span class="number">116.37</span>];</span><br><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[query whereKey:<span class="string">@"location"</span> withinGeoBoxFromSouthwest:point1 toNortheast:point2];</span><br><span class="line"><span class="built_in">NSArray</span>&lt;<span class="built_in">AVObject</span> *&gt; *posts = [query findObjects];</span><br></pre></td></tr></table></figure>
<h3 id="注意事项">注意事项</h3><p>目前需要注意以下方面：</p>
<ul>
<li>每个 <code>AVObject</code> 数据对象中只能有一个 <code>AVGeoPoint</code> 对象。</li>
<li>地理位置的点不能超过规定的范围。纬度的范围应该是在 <code>-90.0</code> 到 <code>90.0</code> 之间，经度的范围应该是在 <code>-180.0</code> 到 <code>180.0</code> 之间。如果添加的经纬度超出了以上范围，将导致程序错误。</li>
<li>iOS 8.0 之后，使用定位服务之前，需要调用 <code>[locationManager requestWhenInUseAuthorization]</code> 或 <code>[locationManager requestAlwaysAuthorization]</code> 来获取用户的「使用期授权」或「永久授权」，而这两个请求授权需要在 <code>info.plist</code> 里面对应添加 <code>NSLocationWhenInUseUsageDescription</code> 或 <code>NSLocationAlwaysUsageDescription</code> 的键值对，值为开启定位服务原因的描述。SDK 内部默认使用的是「使用期授权」。</li>
</ul>
<h2 id="调用云代码">调用云代码</h2><h3 id="调用云代码函数">调用云代码函数</h3><p>使用 <code>AVCloud</code> 类的静态方法来调用云代码中定义的函数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *parameters=@&#123;...&#125;;</span><br><span class="line"></span><br><span class="line">[<span class="built_in">AVCloud</span> callFunctionInBackground:<span class="string">@"aFunctionName"</span> withParameters:parameters block:^(<span class="keyword">id</span> object, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="comment">// 执行结果</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p><code>aFunctionName</code> 是函数的名称，<code>parameters</code> 是传入的函数参数，<code>block</code> 对象作为调用结果的回调传入。</p>
<h3 id="区分生产环境调用">区分生产环境调用</h3><p>云代码区分「测试环境」和「生产环境」，使用 <code>AVCloud</code> 的 <code>setProductionMode</code> 方法可以切换环境：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVCloud</span> setProductionMode:<span class="literal">NO</span>];</span><br></pre></td></tr></table></figure>
<p>其中 <code>NO</code> 表示「测试环境」，默认调用生产环境云代码。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/ios_push_cert/" itemprop="url">
                iOS 推送证书设置指南
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/ios_push_cert/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/ios_push_cert/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="iOS_推送证书设置指南">iOS 推送证书设置指南</h1><h2 id="创建应用程序_ID">创建应用程序 ID</h2><ul>
<li>登录 <a href="https://developer.apple.com/devcenter/ios/index.action" target="_blank" rel="external">iOS Dev Center</a> 选择进入 iOS Provisioning Portal。</li>
</ul>
<p><img src="/avos/images/ios_cert/login.png" alt="Enable push"></p>
<ul>
<li>在 <a href="https://developer.apple.com/ios/manage/overview/index.action" target="_blank" rel="external">iOS Provisioning Portal</a> 中，点击 App IDs 进入 App ID 列表。</li>
</ul>
<p><img src="/avos/images/ios_cert/appid.png" alt="Enable push"></p>
<ul>
<li>创建 App ID，如果 ID 已经存在可以直接跳过此步骤。</li>
</ul>
<p><img src="/avos/images/ios_cert/appid2.png" alt="Enable push"></p>
<ul>
<li>为 App 开启 Push Notification 功能。如果是已经创建的 App ID 也可以通过设置开启 Push Notification 功能。</li>
</ul>
<p><img src="/avos/images/ios_cert/appservice.png" alt="Enable push"></p>
<ul>
<li>根据实际情况完善 App ID 信息并提交,注意此处需要指定具体的 Bundle ID 不要使用通配符。</li>
</ul>
<p><img src="/avos/images/ios_cert/appid3.png" alt="Enable push"></p>
<h2 id="配置和下载证书">配置和下载证书</h2><ul>
<li>如果你之前没有创建过 Push 证书或者是要重新创建一个新的，请在证书列表下面新建。</li>
</ul>
<p><img src="/avos/images/ios_cert/cer0.png" alt="Enable push"></p>
<ul>
<li>新建证书需要注意选择证书种类（开发证书用于开发和调试使用，生产证书用于 App Store 发布）</li>
</ul>
<p><img src="/avos/images/ios_cert/cer1.png" alt="Enable push"></p>
<ul>
<li>点击 Continue 后选择证书对应的应用ID，然后继续会出现 <strong>About Creating a Certificate Signing Request (CSR)</strong>。</li>
</ul>
<p><img src="/avos/images/ios_cert/cer2.png" alt="Enable push"></p>
<ul>
<li>根据它的说明创建 Certificate Signing Request。</li>
</ul>
<p><img src="/avos/images/ios_cert/cer3.png" alt="Enable push"></p>
<ul>
<li>然后点击 <strong>Continue</strong>，上传刚刚生成的 .certSigningRequest 文件 生成 APNs Push  Certificate。</li>
<li>下载并双击打开证书，证书打开时会启动 <strong>钥匙串访问</strong> 工具。</li>
<li>在 <strong>钥匙串访问</strong> 中你的证书会显示在 <strong>我的证书</strong> 中，注意选择左上角的 <strong>My Certificates</strong>（我的证书）和左下角 <strong>login</strong>(登录）。</li>
</ul>
<p><img src="/avos/images/ios_cert/keychain_cert.png" alt="Enable push"></p>
<h2 id="导出_-p12_证书文件">导出 .p12 证书文件</h2><ul>
<li>在 <strong>钥匙串访问</strong> 中，选择刚刚加进来的证书，选择右键菜单中的 <strong>导出 “…”</strong>。</li>
</ul>
<p><img src="/avos/images/ios_cert/export_p12.png" alt="Enable push"></p>
<ul>
<li>将文件保存为Personal Information Exchange (.p12) 格式。</li>
</ul>
<p><img src="/avos/images/ios_cert/export_filename.png" alt="Enable push"></p>
<p><strong>保存 p12 文件时，密码必须为空</strong>。</p>
<p>如果 <strong>Personal Information Exchange (.p12)</strong> 格式是灰色的，请确保选中 <strong>My Certificates</strong>（我的证书）。如果还是不行，请确认选择的是钥匙串里的 <strong>login</strong> 的证书（左上角）。或者你也可以尝试将证书文件拖拽到 <strong>My Certificates</strong> 下。</p>
<h2 id="上传证书">上传证书</h2><p>在 <a href="/messaging.html?appid=#/message/push/conf"><strong>控制台</strong> &gt; <strong>消息 &gt; 推送 &gt; 设置</strong></a> 里，上传上面步骤得到 .p12 证书文件。这是 iOS SDK 能够接收到 LeanCloud 推送消息的必要步骤。</p>
<p><img src="/avos/images/ios_cert/upload_p12.png" alt="Enable push"></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/ios_push_guide/" itemprop="url">
                iOS 消息推送开发指南
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/ios_push_guide/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/ios_push_guide/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="iOS_消息推送开发指南">iOS 消息推送开发指南</h1><p>本文介绍了如何在 iOS 设备中使用 LeanCloud 的推送功能。请先阅读我们的博客文章《<a href="https://blog.leancloud.cn/1163/" target="_blank" rel="external">细说 iOS 消息推送</a>》，再通过 <a href="push_guide.html">消息推送概览</a> 了解和巩固相关概念。</p>
<h2 id="配置_iOS_推送证书">配置 iOS 推送证书</h2><p>配置 iOS 证书相对麻烦，但是却是必须的步骤，请详读 <a href="ios_push_cert.html">iOS 推送证书设置指南</a>。</p>
<h2 id="多证书场景">多证书场景</h2><p>对于一些应用，他们在发布和上架时分为不同的版本（司机版、乘客版），但数据和消息是互通的，这种场景下我们允许应用上传多个自定义证书并对不同的设备设置 <code>deviceProfile</code>，从而可以用合适的证书给不同版本的应用推送。</p>
<p>当你上传自定义证书时会被要求输入「证书类型」，即 deviceProfile 的名字。当 installation 上保存了 deviceProfile 时，我们将忽略原先的开发和生产证书设置，而直接按照 deviceProfile 推送。</p>
<h2 id="保存_Installation">保存 Installation</h2><p>在保存 installation 前，要先通过下列代码获取用户推送权限：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Before iOS 8:</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Register for push notifications</span></span><br><span class="line">    [application registerForRemoteNotificationTypes:</span><br><span class="line">                                <span class="built_in">UIRemoteNotificationTypeBadge</span> |</span><br><span class="line">                                <span class="built_in">UIRemoteNotificationTypeAlert</span> |</span><br><span class="line">                                <span class="built_in">UIRemoteNotificationTypeSound</span>];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//For iOS 8:</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">UIUserNotificationSettings</span> *settings = [<span class="built_in">UIUserNotificationSettings</span> settingsForTypes:<span class="built_in">UIUserNotificationTypeAlert</span></span><br><span class="line">                                            | <span class="built_in">UIUserNotificationTypeBadge</span></span><br><span class="line">                                            | <span class="built_in">UIUserNotificationTypeSound</span></span><br><span class="line">                                                                             categories:<span class="literal">nil</span>];</span><br><span class="line">    [application registerUserNotificationSettings:settings];</span><br><span class="line">    [application registerForRemoteNotifications];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 iOS 设备中，Installation 的类是 AVInstallation，并且是 AVObject 的子类，使用同样的 API 存储和查询。如果要访问当前应用的 Installation 对象，可以通过 <code>[AVInstallation currentInstallation]</code> 方法。当你第一次保存 AVInstallation 的时候，它会插入 <code>_Installation</code> 表，你可以在 <a href="/data.html?appid=&lt;!--￼26--">数据管理</a> 平台看到和查询。当 deviceToken 一被保存，你就可以向这台设备推送消息了。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)app didRegisterForRemoteNotificationsWithDeviceToken:(<span class="built_in">NSData</span> *)deviceToken &#123;</span><br><span class="line">    <span class="built_in">AVInstallation</span> *currentInstallation = [<span class="built_in">AVInstallation</span> currentInstallation];</span><br><span class="line">    [currentInstallation setDeviceTokenFromData:deviceToken];</span><br><span class="line">    [currentInstallation saveInBackground];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以像修改 AVObject 那样去修改 AVInstallation，但是有一些特殊字段可以帮你管理目标设备：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>badge</td>
<td>应用图标旁边的红色数字，修改 AVInstallation 的这个值将修改应用的 badge。修改应该保存到服务器，以便为以后做 badge 增量式的推送做准备。</td>
</tr>
<tr>
<td>channels</td>
<td>当前设备所订阅的频道数组</td>
</tr>
<tr>
<td>appName</td>
<td>应用名称（只读）</td>
</tr>
<tr>
<td>appVersion</td>
<td>应用版本（只读）</td>
</tr>
<tr>
<td>deviceProfile</td>
<td>设备对应的后台自定义证书名称，用于多证书推送</td>
</tr>
</tbody>
</table>
<h2 id="发送推送消息">发送推送消息</h2><p>发送 iOS 推送消息，可以通过 REST API，或者我们的消息推送 web 平台，请进入你的应用管理界面查看。</p>
<h2 id="使用频道">使用频道</h2><p>使用频道（channel）可以实现「发布—订阅」的模型。设备订阅某个频道，然后发送消息的时候指定要发送的频道即可。</p>
<div class="callout callout-info">每个 channel 名称只能包含 26 个英文字母和数字。</div>

<h3 id="订阅和退订">订阅和退订</h3><p>订阅 Giants 频道：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当用户表示喜欢 Giants，则为其订阅该频道。</span></span><br><span class="line"><span class="built_in">AVInstallation</span> *currentInstallation = [<span class="built_in">AVInstallation</span> currentInstallation];</span><br><span class="line">[currentInstallation addUniqueObject:<span class="string">@"Giants"</span> forKey:<span class="string">@"channels"</span>];</span><br><span class="line">[currentInstallation saveInBackground];</span><br></pre></td></tr></table></figure>
<p>订阅后要记得保存，即可在 <a href="/data.html?appid=&lt;!--￼27--">数据管理</a>平台看到该 installation 的 channels 字段多了一个「Giants」。</p>
<p>退订：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVInstallation</span> *currentInstallation = [<span class="built_in">AVInstallation</span> currentInstallation];</span><br><span class="line">[currentInstallation removeObject:<span class="string">@"Giants"</span> forKey:<span class="string">@"channels"</span>];</span><br><span class="line">[currentInstallation saveInBackground];</span><br></pre></td></tr></table></figure>
<p>获取所有订阅的频道：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *subscribedChannels = [<span class="built_in">AVInstallation</span> currentInstallation]<span class="variable">.channels</span>;</span><br></pre></td></tr></table></figure>
<h3 id="发送消息到频道">发送消息到频道</h3><p>发送消息到刚才订阅的「Giants」频道：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Send a notification to all devices subscribed to the "Giants" channel.</span></span><br><span class="line"><span class="built_in">AVPush</span> *push = [[<span class="built_in">AVPush</span> alloc] init];</span><br><span class="line">[push setChannel:<span class="string">@"Giants"</span>];</span><br><span class="line">[push setMessage:<span class="string">@"Giants 太牛掰了"</span>];</span><br><span class="line">[push sendPushInBackground];</span><br></pre></td></tr></table></figure>
<p>如果你想发送到多个频道，可以指定 channels 数组：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *channels = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"Giants"</span>, <span class="string">@"Mets"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">AVPush</span> *push = [[<span class="built_in">AVPush</span> alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Be sure to use the plural 'setChannels'.</span></span><br><span class="line">[push setChannels:channels];</span><br><span class="line">[push setMessage:<span class="string">@"The Giants won against the Mets 2-3."</span>];</span><br><span class="line">[push sendPushInBackground];</span><br></pre></td></tr></table></figure>
<h3 id="选择证书">选择证书</h3><p>默认情况下，从客户端发起的推送都是使用你在消息菜单上传的生产证书，如果想使用开发证书，可以通过 <code>setProductionMode</code> 方法：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr_selector">[AVPush setProductionMode:NO]</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="高级定向发送">高级定向发送</h2><p>频道对于大多数应用来说可能就足够了。但是某些情况下，你可能需要更高精度的定向推送。LeanCloud 允许你通过 AVQuery API 查询 Installation 列表，并向指定条件的 query 推送消息。</p>
<p>因为 AVInstallation 同时是 AVObject 的子类，因此你可以保存任何数据类型到 AVInstallation，并将它和你的其他应用数据对象关联起来，这样以来，你可以非常灵活地向你用户群做定制化、动态的推送。</p>
<h3 id="保存_Installation_数据">保存 Installation 数据</h3><p>为 AVInstallation 添加三个新字段：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Store app language and version</span></span><br><span class="line"><span class="built_in">AVInstallation</span> *installation = [<span class="built_in">AVInstallation</span> currentInstallation];</span><br><span class="line"></span><br><span class="line"><span class="comment">//字段依次为：比赛分数、比赛结果、受伤报告</span></span><br><span class="line">[installation setObject:@(<span class="literal">YES</span>) forKey:<span class="string">@"scores"</span>];</span><br><span class="line">[installation setObject:@(<span class="literal">YES</span>) forKey:<span class="string">@"gameResults"</span>];</span><br><span class="line">[installation setObject:@(<span class="literal">YES</span>) forKey:<span class="string">@"injuryReports"</span>];</span><br><span class="line">[installation saveInBackground];</span><br></pre></td></tr></table></figure>
<p>你可以给 Installation 添加 owner 属性，比如当前的登录用户：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Saving the device's owner</span></span><br><span class="line"><span class="built_in">AVInstallation</span> *installation = [<span class="built_in">AVInstallation</span> currentInstallation];</span><br><span class="line">[installation setObject:[<span class="built_in">AVUser</span> currentUser] forKey:<span class="string">@"owner"</span>];</span><br><span class="line">[installation saveInBackground];</span><br></pre></td></tr></table></figure>
<h3 id="根据查询来推送消息">根据查询来推送消息</h3><p>一旦 Installation 保存了你的应用数据，你可以使用 AVQuery 来查询出设备的一个子集做推送。Installation 的查询跟其他对象的查询没有什么不同，只是使用特殊的静态方法<br> <code>[AVInstallation query]</code> 创建查询对象：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create our Installation query</span></span><br><span class="line"><span class="built_in">AVQuery</span> *pushQuery = [<span class="built_in">AVInstallation</span> query];</span><br><span class="line">[pushQuery whereKey:<span class="string">@"injuryReports"</span> equalTo:@(<span class="literal">YES</span>)];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send push notification to query</span></span><br><span class="line"><span class="built_in">AVPush</span> *push = [[<span class="built_in">AVPush</span> alloc] init];</span><br><span class="line">[push setQuery:pushQuery]; <span class="comment">// Set our Installation query</span></span><br><span class="line">[push setMessage:<span class="string">@"Willie Hayes injured by own pop fly."</span>];</span><br><span class="line">[push sendPushInBackground];</span><br></pre></td></tr></table></figure>
<p>你也可以在查询中添加 channels 的条件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create our Installation query</span></span><br><span class="line"><span class="built_in">AVQuery</span> *pushQuery = [<span class="built_in">AVInstallation</span> query];</span><br><span class="line">[pushQuery whereKey:<span class="string">@"channels"</span> equalTo:<span class="string">@"Giants"</span>]; <span class="comment">// Set channel</span></span><br><span class="line">[pushQuery whereKey:<span class="string">@"scores"</span> equalTo:@(<span class="literal">YES</span>)];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send push notification to query</span></span><br><span class="line"><span class="built_in">AVPush</span> *push = [[<span class="built_in">AVPush</span> alloc] init];</span><br><span class="line">[push setQuery:pushQuery];</span><br><span class="line">[push setMessage:<span class="string">@"Giants scored against the A's! It's now 2-2."</span>];</span><br><span class="line">[push sendPushInBackground];</span><br></pre></td></tr></table></figure>
<p>如果你在 Installation 还保存了其他对象的关系，我们同样可以在查询条件中使用这些数据，例如，向靠近北京大学的设备推送消息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find users near a given location</span></span><br><span class="line"><span class="built_in">AVQuery</span> *userQuery = [<span class="built_in">AVUser</span> query];</span><br><span class="line">[userQuery whereKey:<span class="string">@"location"</span></span><br><span class="line">        nearGeoPoint:beijingUniversityLocation,</span><br><span class="line">         withinMiles:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find devices associated with these users</span></span><br><span class="line"><span class="built_in">AVQuery</span> *pushQuery = [<span class="built_in">AVInstallation</span> query];</span><br><span class="line">[pushQuery whereKey:<span class="string">@"user"</span> matchesQuery:userQuery];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send push notification to query</span></span><br><span class="line"><span class="built_in">AVPush</span> *push = [[<span class="built_in">AVPush</span> alloc] init];</span><br><span class="line">[push setQuery:pushQuery]; <span class="comment">// Set our Installation query</span></span><br><span class="line">[push setMessage:<span class="string">@"Free hotdogs at the AVOSCloud concession stand!"</span>];</span><br><span class="line">[push sendPushInBackground];</span><br></pre></td></tr></table></figure>
<h2 id="发送选项">发送选项</h2><p>除了发送一个文本信息之外，你还可以播放一个声音，设置 badge 数字或者其他想自定义的数据。你还可以设置一个消息的过期时间，如果对消息的时效性特别敏感的话。</p>
<h3 id="定制通知">定制通知</h3><p>如果你不仅想发送一条文本消息，你需要一个 NSDictionary 来打包想发送的数据。这里有一些保留字段，具有特殊含义，需要说明：</p>
<table>
<thead>
<tr>
<th>保留字段</th>
<th>平台</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>alert</td>
<td>通用</td>
<td>推送消息的文本内容</td>
</tr>
<tr>
<td>badge</td>
<td>iOS</td>
<td>应用图标右上角的数字。可以设置一个值或者递增当前值。</td>
</tr>
<tr>
<td>sound</td>
<td>iOS</td>
<td>应用 bundle 里的声音文件名称。</td>
</tr>
<tr>
<td>content-available</td>
<td>iOS</td>
<td>如果你在使用 Newsstand, 设置为 1 来开始一次后台下载。</td>
</tr>
<tr>
<td>action</td>
<td>Android</td>
<td>当消息收到的时候，触发的 Intent 名称。如果没有设置 title 或者 alert，Intent 将触发，但是不会显示通知给用户。</td>
</tr>
<tr>
<td>title</td>
<td>Android</td>
<td>显示在系统通知栏的标题。</td>
</tr>
</tbody>
</table>
<p>例如，递增 badge 数字，并播放声音可以这样做:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *data = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:</span><br><span class="line">    <span class="string">@"The Mets scored! The game is now tied 1-1!"</span>, <span class="string">@"alert"</span>,</span><br><span class="line">    <span class="string">@"Increment"</span>, <span class="string">@"badge"</span>,</span><br><span class="line">    <span class="string">@"cheering.caf"</span>, <span class="string">@"sound"</span>,</span><br><span class="line">    <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">AVPush</span> *push = [[<span class="built_in">AVPush</span> alloc] init];</span><br><span class="line">[push setChannels:[<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"Mets"</span>, <span class="literal">nil</span>]];</span><br><span class="line">[push setData:data];</span><br><span class="line">[push sendPushInBackground];</span><br></pre></td></tr></table></figure>
<p>当然，你还可以添加其他自定义的数据。你会在接收推送一节看到，当应用通过推送打开你的应用的时候，你就可以访问这些数据。当你要在用户打开通知的时候显示一个不同的 view controller 的时候，这特别有用。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *data = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:</span><br><span class="line">    <span class="string">@"Ricky Vaughn was injured in last night's game!"</span>, <span class="string">@"alert"</span>,</span><br><span class="line">    <span class="string">@"Vaughn"</span>, <span class="string">@"name"</span>,</span><br><span class="line">    <span class="string">@"Man bites dog"</span>, <span class="string">@"newsItem"</span>,</span><br><span class="line">    <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">AVPush</span> *push = [[<span class="built_in">AVPush</span> alloc] init];</span><br><span class="line">[push setQuery:injuryReportsQuery];</span><br><span class="line">[push setChannel:<span class="string">@"Indians"</span>];</span><br><span class="line">[push setData:data];</span><br><span class="line">[push sendPushInBackground];</span><br></pre></td></tr></table></figure>
<h3 id="设置过期日期">设置过期日期</h3><p>当设备关闭或者无法连接到网络的时候，推送通知就无法被送达。如果你有一条时间敏感的推送通知，不希望在太长时间后被用户读到，那么可以设置一个过期时间来避免打扰用户。</p>
<p>AVPush 提供了两个方法来设置通知的过期日期，首先是 expireAtDate：接收 NSDate 来告诉 LeanCloud 不要再去发送通知。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDateComponents</span> *comps = [[<span class="built_in">NSDateComponents</span> alloc] init];</span><br><span class="line">[comps setYear:<span class="number">2013</span>];</span><br><span class="line">[comps setMonth:<span class="number">10</span>];</span><br><span class="line">[comps setDay:<span class="number">12</span>];</span><br><span class="line"><span class="built_in">NSCalendar</span> *gregorian =</span><br><span class="line">  [[<span class="built_in">NSCalendar</span> alloc] initWithCalendarIdentifier:<span class="built_in">NSGregorianCalendar</span>];</span><br><span class="line"><span class="built_in">NSDate</span> *date = [gregorian dateFromComponents:comps];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send push notification with expiration date</span></span><br><span class="line"><span class="built_in">AVPush</span> *push = [[<span class="built_in">AVPush</span> alloc] init];</span><br><span class="line">[push expireAtDate:date];</span><br><span class="line">[push setQuery:everyoneQuery];</span><br><span class="line">[push setMessage:<span class="string">@"Season tickets on sale until October 12th"</span>];</span><br><span class="line">[push sendPushInBackground];</span><br></pre></td></tr></table></figure>
<p>这个方法有个隐患，因为设备的时钟是无法保证精确的，你可能得到错误的结果。因此，AVPush 还提供了 <code>expireAfterTimeInterval</code> 方法，接收 NSTimeInterval 对象。通知将在指定间隔时间后失效：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create time interval</span></span><br><span class="line"><span class="built_in">NSTimeInterval</span> interval = <span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>*<span class="number">7</span>; <span class="comment">// 1 week</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Send push notification with expiration interval</span></span><br><span class="line"><span class="built_in">AVPush</span> *push = [[<span class="built_in">AVPush</span> alloc] init];</span><br><span class="line">[push expireAfterTimeInterval:interval];</span><br><span class="line">[push setQuery:everyoneQuery];</span><br><span class="line">[push setMessage:<span class="string">@"Season tickets on sale until October 18th"</span>];</span><br><span class="line">[push sendPushInBackground];</span><br></pre></td></tr></table></figure>
<div class="callout callout-info">我们建议给 iOS 设备的推送都设置过期时间，才能保证推送的当时，如果用户设置了飞行模式，在关闭飞行模式之后可以收到推送消息，可以参考 <a href="http://stackoverflow.com/questions/24026544/push-notification-is-not-being-delivered-when-iphone-comes-back-online" target="_blank" rel="external">Stackoverflow - Push notification is not being delivered when iPhone comes back online</a>。</div>

<h3 id="指定设备平台">指定设备平台</h3><p>跨平台的应用，可能想指定发送的平台，比如 iOS 或者 Android:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVInstallation</span> query];</span><br><span class="line">[query whereKey:<span class="string">@"channels"</span> equalTo:<span class="string">@"suitcaseOwners"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Notification for Android users</span></span><br><span class="line">[query whereKey:<span class="string">@"deviceType"</span> equalTo:<span class="string">@"android"</span>];</span><br><span class="line"><span class="built_in">AVPush</span> *androidPush = [[<span class="built_in">AVPush</span> alloc] init];</span><br><span class="line">[androidPush setMessage:<span class="string">@"Your suitcase has been filled with tiny robots!"</span>];</span><br><span class="line">[androidPush setQuery:query];</span><br><span class="line">[androidPush sendPushInBackground];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Notification for iOS users</span></span><br><span class="line">[query whereKey:<span class="string">@"deviceType"</span> equalTo:<span class="string">@"ios"</span>];</span><br><span class="line"><span class="built_in">AVPush</span> *iOSPush = [[<span class="built_in">AVPush</span> alloc] init];</span><br><span class="line">[iOSPush setMessage:<span class="string">@"Your suitcase has been filled with tiny apples!"</span>];</span><br><span class="line">[iOSPush setChannel:<span class="string">@"suitcaseOwners"</span>];</span><br><span class="line">[iOSPush setQuery:query];</span><br><span class="line">[iOSPush sendPushInBackground];</span><br></pre></td></tr></table></figure>
<h2 id="定时推送">定时推送</h2><p>请进入消息推送的 Web 管理平台，可以做到定时推送（延迟或者指定时间）。</p>
<h2 id="接收推送通知">接收推送通知</h2><p>正如 <a href="#定制通知">定制通知</a> 一节提到，你可以随通知发送任意的数据。我们使用这些数据修改应用的行为，当应用是通过通知打开的时候。例如，当打开一条通知告诉你有一个新朋友的时候，这时候如果显示一张图片会非常好。</p>
<p>由于 Apple 的对消息大小的限制，请尽量缩小要发送的数据大小，否则可能被截断：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *data = @&#123;</span><br><span class="line">  <span class="string">@"alert"</span>: <span class="string">@"James commented on your photo!"</span>,</span><br><span class="line">  <span class="string">@"p"</span>: <span class="string">@"vmRZXZ1Dvo"</span> <span class="comment">// Photo's object id</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">AVPush</span> *push = [[<span class="built_in">AVPush</span> alloc] init];</span><br><span class="line">[push setQuery:photoOwnerQuery];</span><br><span class="line">[push setData:data];</span><br><span class="line">[push sendPushInBackground];</span><br></pre></td></tr></table></figure>
<h2 id="响应通知数据">响应通知数据</h2><p>当应用是被通知打开的时候，你可以通过 <code>application:didFinishLaunchingWithOptions:</code>方法的 <code>launchOptions</code> 参数所使用的 dictionary 访问到数据：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">  . . .</span><br><span class="line">  <span class="comment">// Extract the notification data</span></span><br><span class="line">  <span class="built_in">NSDictionary</span> *notificationPayload = launchOptions[<span class="built_in">UIApplicationLaunchOptionsRemoteNotificationKey</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a pointer to the Photo object</span></span><br><span class="line">  <span class="built_in">NSString</span> *photoId = [notificationPayload objectForKey:<span class="string">@"p"</span>];</span><br><span class="line">  <span class="built_in">AVObject</span> *targetPhoto = [<span class="built_in">AVObject</span> objectWithoutDataWithClassName:<span class="string">@"Photo"</span></span><br><span class="line">                                                          objectId:photoId];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fetch photo object</span></span><br><span class="line">  [targetPhoto fetchIfNeededInBackgroundWithBlock:^(<span class="built_in">AVObject</span> *object, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="comment">// Show photo view controller</span></span><br><span class="line">    <span class="keyword">if</span> (!error &amp;&amp; [<span class="built_in">AVUser</span> currentUser]) &#123;</span><br><span class="line">      PhotoVC *viewController = [[PhotoVC alloc] initWithPhoto:object];</span><br><span class="line">      [<span class="keyword">self</span><span class="variable">.navController</span> pushViewController:viewController animated:<span class="literal">YES</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当通知到达的时候，你的应用已经在运行，那么你可以通过 <code>application:didReceiveRemoteNotification:fetchCompletionHandler:</code> 方法的 <code>userInfo</code> 参数所使用 dictionary 访问到数据：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">      didReceiveRemoteNotification:(<span class="built_in">NSDictionary</span> *)userInfo</span><br><span class="line">            fetchCompletionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">UIBackgroundFetchResult</span>))handler &#123;</span><br><span class="line">  <span class="comment">// Create empty photo object</span></span><br><span class="line">  <span class="built_in">NSString</span> *photoId = [userInfo objectForKey:<span class="string">@"p"</span>];</span><br><span class="line">  <span class="built_in">AVObject</span> *targetPhoto = [<span class="built_in">AVObject</span> objectWithoutDataWithClassName:<span class="string">@"Photo"</span></span><br><span class="line">                                                          objectId:photoId];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fetch photo object</span></span><br><span class="line">  [targetPhoto fetchIfNeededInBackgroundWithBlock:^(<span class="built_in">AVObject</span> *object, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="comment">// Show photo view controller</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      handler(<span class="built_in">UIBackgroundFetchResultFailed</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="built_in">AVUser</span> currentUser]) &#123;</span><br><span class="line">      PhotoVC *viewController = [[PhotoVC alloc] initWithPhoto:object];</span><br><span class="line">      [<span class="keyword">self</span><span class="variable">.navController</span> pushViewController:viewController animated:<span class="literal">YES</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      handler(<span class="built_in">UIBackgroundFetchResultNoData</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以阅读 <a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Introduction.html#//apple_ref/doc/uid/TP40008194-CH1-SW1" target="_blank" rel="external">Apple 本地化和推送的文档</a> 来更多地了解推送通知。</p>
<h2 id="跟踪推送和应用的打开情况">跟踪推送和应用的打开情况</h2><p>通过 AVAnalytics 你可以跟踪通知和应用的打开情况。添加下列代码到上面例子中的 <code>application:didFinishLaunchingWithOptions:</code> 方法来收集打开信息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (application<span class="variable">.applicationState</span> != <span class="built_in">UIApplicationStateBackground</span>) &#123;</span><br><span class="line">  <span class="comment">// Track an app open here if we launch with a push, unless</span></span><br><span class="line">  <span class="comment">// "content_available" was used to trigger a background push (introduced</span></span><br><span class="line">  <span class="comment">// in iOS 7). In that case, we skip tracking here to avoid double</span></span><br><span class="line">  <span class="comment">// counting the app-open.</span></span><br><span class="line">  <span class="built_in">BOOL</span> preBackgroundPush = ![application respondsToSelector:<span class="keyword">@selector</span>(backgroundRefreshStatus)];</span><br><span class="line">  <span class="built_in">BOOL</span> oldPushHandlerOnly = ![<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(application:didReceiveRemoteNotification:fetchCompletionHandler:)];</span><br><span class="line">  <span class="built_in">BOOL</span> noPushPayload = ![launchOptions objectForKey:<span class="built_in">UIApplicationLaunchOptionsRemoteNotificationKey</span>];</span><br><span class="line">  <span class="keyword">if</span> (preBackgroundPush || oldPushHandlerOnly || noPushPayload) &#123;</span><br><span class="line">    [<span class="built_in">AVAnalytics</span> trackAppOpenedWithLaunchOptions:launchOptions];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传递 nil 或者空白的参数给 <code>trackAppOpenedWithLaunchOptions:</code> 方法只是统计一次标准的应用打开事件（比如不是通过通知打开的应用）。</p>
<p>你可以在 <a href="/stat.html?appid=#/stat/appuse">控制台 /<span class="text-muted">（选择应用）</span>/ 分析 / 行为分析 / 应用使用</a> 里看到通知和应用打开的情况。</p>
<p>请注意，如果你的应用正在运行或者在后台，<code>application:didReceiveRemoteNotification:</code>方法将会处理收到的推送通知。</p>
<div class="callout callout-info">如果你的应用处于运行状态，iOS 系统将不会在系统的通知中心显示推送消息，你可以使用 <code>UILocalNotification</code> 展示一个通知给用户。</div>

<p>如果应用在后台，并且用户点击了通知，那么应用将被带到前台可视，为了跟踪这种通过通知打开应用的情况，你需要在跟踪代码里多作一个检查：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didReceiveRemoteNotification:(<span class="built_in">NSDictionary</span> *)userInfo &#123;</span><br><span class="line">  <span class="keyword">if</span> (application<span class="variable">.applicationState</span> == <span class="built_in">UIApplicationStateActive</span>) &#123;</span><br><span class="line">    <span class="comment">// 此处可以写上应用激活状态下接收到通知的处理代码，如无需处理可忽略</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// The application was just brought from the background to the foreground,</span></span><br><span class="line">    <span class="comment">// so we consider the app as having been "opened by a push notification."</span></span><br><span class="line">    [<span class="built_in">AVAnalytics</span> trackAppOpenedWithRemoteNotificationPayload:userInfo];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用 iOS 7 推送的新特性（包括新的 content-available 功能），你需要实现 iOS 7<br>新加的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">        didReceiveRemoteNotification:(<span class="built_in">NSDictionary</span> *)userInfo</span><br><span class="line">        fetchCompletionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">UIBackgroundFetchResult</span>))completionHandler &#123;</span><br><span class="line">  <span class="keyword">if</span> (application<span class="variable">.applicationState</span> == <span class="built_in">UIApplicationStateActive</span>) &#123;</span><br><span class="line">    <span class="comment">// 此处可以写上应用激活状态下接收到通知的处理代码，如无需处理可忽略</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    [<span class="built_in">AVAnalytics</span> trackAppOpenedWithRemoteNotificationPayload:userInfo];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="跟踪本地通知_(iOS_only)">跟踪本地通知 (iOS only)</h3><p>为了统计跟踪本地通知消息，需要注意以下两种方法都会调用到：</p>
<ul>
<li><code>application:didFinishLaunchingWithOptions:</code></li>
<li><code>-application:didReceiveLocalNotification:</code></li>
</ul>
<p>如果你实现了 <code>application:didReceiveLocalNotification:</code> 这个方法，要注意避免重复统计。</p>
<h4 id="清除_Badge">清除 Badge</h4><p>清除 Badge 数字的最好时机是打开应用的时候。设置当前 installation 的 badge 属性并保存到服务器：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)applicationDidBecomeActive:(<span class="built_in">UIApplication</span> *)application &#123;</span><br><span class="line">    <span class="keyword">int</span> num=application<span class="variable">.applicationIconBadgeNumber</span>;</span><br><span class="line">    <span class="keyword">if</span>(num!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">AVInstallation</span> *currentInstallation = [<span class="built_in">AVInstallation</span> currentInstallation];</span><br><span class="line">        [currentInstallation setBadge:<span class="number">0</span>];</span><br><span class="line">        [currentInstallation saveEventually];</span><br><span class="line">        application<span class="variable">.applicationIconBadgeNumber</span>=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [application cancelAllLocalNotifications];</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>清除 Badge 数字最相关的三个方法是：</p>
<ul>
<li><code>applicationDidBecomeActive:</code></li>
<li><code>application:didFinishLaunchingWithOptions:</code></li>
<li><code>application:didReceiveRemoteNotification:</code></li>
</ul>
<p>请阅读 <a href="http://developer.apple.com/library/ios/#DOCUMENTATION/UIKit/Reference/UIApplicationDelegate_Protocol/Reference/Reference.html" target="_blank" rel="external">UIApplicationDelegate 文档</a>。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/ios_statistics/" itemprop="url">
                iOS 统计 SDK 开发指南
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/ios_statistics/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/ios_statistics/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="iOS_统计_SDK_开发指南">iOS 统计 SDK 开发指南</h1><h2 id="安装与初始化">安装与初始化</h2><p>使用最新的 SDK 你不需要任何代码上的操作就可以使用统计功能，请参考 <a href="sdk_setup-ios.html">安装指南</a>。</p>
<p>统计功能默认为打开，并且可以在线配置。进入应用的 <a href="/stat.html?appid=#/statconfig/trans_strategoy">控制台 / 分析 / 统计设置<span class="text-muted">（左下角）</span> / 数据发送策略</a> 在线更改 SDK 端的数据报告发送策略。</p>
<p>建议使用 AV_BATCH 形式，减少应用与网络的交互，为用户节约流量。如果不设置 channelId，默认会是 <code>@&quot;App Store&quot;</code> 渠道。</p>
<p>默认 <strong>启动时发送</strong> 策略：应用程序每次会在启动时会向服务器发送一次消息，在应用程序过程中产生的所有统计信息（包括自定义事件和本次使用时长）都会在下次启动时候发送。如果应用程序启动时处在不联网状态，那么消息将会缓存在本地，下次再尝试发送。</p>
<p>如果需要修改渠道名称 channelId，请使用下面的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVAnalytics</span> setChannel:<span class="string">@"越狱市场"</span>];</span><br></pre></td></tr></table></figure>
<p>到此，你已经可以使用基本的统计功能。</p>
<h2 id="页面访问路径统计">页面访问路径统计</h2><p>你可以统计每个 View 停留时长，请确保配对使用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">	[<span class="keyword">super</span> viewWillAppear:animated];</span><br><span class="line">  [<span class="built_in">AVAnalytics</span> beginLogPageView:<span class="string">@"PageOne"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewWillDisappear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">   [<span class="keyword">super</span> viewWillDisappear:animated];</span><br><span class="line">   [<span class="built_in">AVAnalytics</span> endLogPageView:<span class="string">@"PageOne"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想自己传递时长，请使用下面的方法（单位为秒）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)logPageView:(<span class="built_in">NSString</span> *)pageName seconds:(<span class="keyword">int</span>)seconds;</span><br></pre></td></tr></table></figure>
<h2 id="使用自定义事件">使用自定义事件</h2><p>自定义事件方便你更加灵活的了解用户的行为，并且可以在 <a href="/stat.html?appid=#/stat/customevent">控制台</a> 看到实时的数据。</p>
<div class="callout callout-info">但是要特别强调的是，自定义事件名（<code>event_id</code>）应该尽量保持为静态值，否则可能出现数目庞大的自定义事件列表，而无法达到了解与分析用户行为的目的。</div>

<p>例如，如果要统计用户喜欢在每周几喜欢看做某件事情，比如查看彩票开奖，我们应该统一用一个事件名，比如 <code>check</code>，然后给这个事件设置周几的 <code>label</code>。这样在控制台打开 check 的自定义事件统计中，就可以看到一周每天的分布情况了。使用方法见 <a href="#多标签事件">多标签事件</a>。</p>
<p>你可以通过以下几个接口来调用事件记录：</p>
<h3 id="简单事件">简单事件</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+(<span class="keyword">void</span>)event:(<span class="built_in">NSString</span> *)event_id;</span><br></pre></td></tr></table></figure>
<p>将统计 event_id 对应事件的发生次数、变化趋势，例如广告点击、短信数量等等。event_id 为当前统计的事件 ID，你可以在程序里直接定义，无需配置。例如，监测应用里 like 的点击次数，事件 ID 为 <code>like_click</code>，那么需要在每次 like 点击后的代码调用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVAnalytics</span> event:<span class="string">@"like_click"</span>]; <span class="comment">// 通知服务器一个 like 点击事件。</span></span><br></pre></td></tr></table></figure>
<h3 id="多标签事件">多标签事件</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)event:(<span class="built_in">NSString</span> *)event_id label:(<span class="built_in">NSString</span> *)label;</span><br></pre></td></tr></table></figure>
<p>除了能够统计 event_id 所对应事件的发生次数、变化趋势外，还能统计此事件中具体标签所占的比例，label 为当前标签。<br>例如：在应用程序中，你可以定义一个事件，其 ID 为 <code>like</code>，针对每个 like 事件，你可以根据用户的不同，定义不同的 label，比如对于女性用户，你可以定义一个 <code>label_female</code>，对于男性用户使用 <code>label_male</code>，通过我们的后台页面，你可以观察到不同性别的用户对于特定内容所 like 的比例。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVAnalytics</span> event:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"like"</span>] label:<span class="string">@"label_female"</span>]; <span class="comment">//type 是变量，表示用户类型</span></span><br></pre></td></tr></table></figure>
<h3 id="事件累计">事件累计</h3><p>在应用程序中某些自定义事件可能会被频繁触发，例如用户点击某个按钮，但是还是希望统计为一次事件。开发者可以在程序中维护一个计数器，这样某个事件被多次触发但只需要生成一个消息，这个消息中包括该事件被触发的次数。为了支持这个功能，这里我们定义了两个接口：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)event:(<span class="built_in">NSString</span> *)event_id acc:(<span class="built_in">NSInteger</span>)acc;</span><br><span class="line">+ (<span class="keyword">void</span>)event:(<span class="built_in">NSString</span> *)event_id label:(<span class="built_in">NSString</span> *)label acc:(<span class="built_in">NSInteger</span>)acc;</span><br></pre></td></tr></table></figure>
<p>参数acc是对应事件 （和对应标签）被触发的次数。</p>
<h3 id="使用多渠道统计">使用多渠道统计</h3><p>你可以选择多种程序分发渠道，例如某 Cydia 源，或其他网站，可以为不同渠道（提供不同）的软件包进行分发渠道的设定，以便统计终端用户得到程序的来源。如果你只有苹果官方 App Store 一个分发渠道，则不再需要做设定，LeanCloud SDK 默认渠道标记为 <code>App Store</code>。</p>
<p>例如你在 360 发布，需要统计 360 渠道：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVAnalytics</span> startWithReportPolicy:<span class="built_in">AV_BATCH</span> channelId:<span class="string">@"360"</span>];</span><br></pre></td></tr></table></figure>
<p>若通过小米发布，需要统计同步推渠道：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVAnalytics</span> startWithReportPolicy:<span class="built_in">AV_BATCH</span> channelId:<span class="string">@"xiaomi"</span>];</span><br></pre></td></tr></table></figure>
<h2 id="获取在线参数">获取在线参数</h2><p>从 SDK 1.4.2 开始，你可以在应用中动态添加在线参数。通过在线参数，你可以控制你的应用行为，而不需要再次发布应用。进入 <a href="/devcomponent.html?appid=#/component/custom_param">控制台 / 组件 / 自定义参数设置</a> 中配置自定义在线参数。在线配置参数会在 SDK 启动后，自动从后台定义的数据表中获取。</p>
<p>从 SDK 1.4.2 开始，你可以使用带回调版本的在线查询 API，比如如果你在后台定义了在线参数 <code>&lt;k1, v1&gt;</code>，你可以通过以下方法来获取：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVAnalytics</span> updateOnlineConfigWithBlock:^(<span class="built_in">NSDictionary</span> *dict, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">     <span class="keyword">if</span> (error == <span class="literal">nil</span>) &#123;</span><br><span class="line">         <span class="comment">// 从 dict 中读取参数，dict["k1"] 值应该为 v1</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>如果想要测试时发送实时的数据，也可以在上面这个 block 中设置。</p>
<h2 id="禁用统计功能">禁用统计功能</h2><p>从 SDK 2.5.5 开始，你可以添加如下代码禁止统计功能（默认启用统计功能），这样可以避免测试数据污染线上数据。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVAnalytics</span> setAnalyticsEnabled:<span class="literal">NO</span>];</span><br></pre></td></tr></table></figure>
<h2 id="数据时效性">数据时效性</h2><p>在控制台的 <strong>分析</strong> 页面中，有些报告可以展示实时数据，有些报告则依靠 <a href="leaninsight_guide.html">离线数据</a> 进行分析，因此有时你会看不到当天的数据。</p>
<p>如果当前页面中存在 <strong>日期选择</strong> 选项（通常在页面右上角），你可以以此判断当前的统计结果是否有延迟。如果 <strong>结束日期</strong> 显示为 <strong>当日日期</strong> 或在其下拉菜单中有「今日」选项，即为实时数据；反之则为离线数据（如下图所示），要推迟一天才能看到当日的情况。</p>
<p><img src="../images/analytics_datepicker_for_offline_data.png" alt="" width="231" height="256"></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/js_start/" itemprop="url">
                js 开发指南
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/js_start/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/js_start/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>把下面这行代码加入你的测试页面中：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://cdn1.lncld.net/static/js/av-mini-&#123;&#123;sdkversion.javascript&#125;&#125;.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span><br><span class="line">/</span><span class="regexp">/或者你只是用最核心的存储、推送等功能，可以使用精简版的core.js</span><br><span class="line">&lt;script src="https:/</span><span class="regexp">/cdn1.lncld.net/static</span><span class="regexp">/js/av</span>-core-mini-<span class="expansion">&#123;&#123;sdkversion.javascript&#125;&#125;</span>.js<span class="string">"&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>进行代码初始化，加入这行代码后，就可以创建 class 或任何其他操作了。</p>
<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">AV.initialize('</span><span class="expression">&#123;&#123;<span class="variable">appid</span>&#125;&#125;</span><span class="xml">', '</span><span class="expression">&#123;&#123;<span class="variable">appkey</span>&#125;&#125;</span><span class="xml">');</span><br><span class="line">// 初始化 param1：应用 id、param2：应用 key</span></span><br></pre></td></tr></table></figure>
<p>创建应用后，可以在 <a href="/app.html?appid=#/key">控制台 - 应用设置</a> 里面找到应用对应的 id 和 key。</p>
<p>开始测试。初始化后加入下面代码：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> TestObject = AV.Object.extend(<span class="string">'TestObject'</span>);</span><br><span class="line"><span class="keyword">var</span> testObject = <span class="keyword">new</span> TestObject();</span><br><span class="line">testObject.save(&#123;</span><br><span class="line">  foo: <span class="string">'bar'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span><span class="params">(object)</span> </span>&#123;</span><br><span class="line">    alert(<span class="string">'LeanCloud works!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>大功告成，访问 <a href="/data.html?appid=#/TestObject">控制台 - 数据管理</a> 可以看到上面创建的 TestObject 的相关数据。</p>
<p>如果你希望在 <a href="http://nodejs.org/" target="_blank" rel="external">Node.js</a> 环境使用 JavaScript SDK 也可以，使用 npm 安装 SDK：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="operator"><span class="keyword">install</span> avoscloud-sdk <span class="comment">--save</span></span></span><br></pre></td></tr></table></figure>
<p>然后代码中使用 SDK：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> AV = <span class="built_in">require</span>(<span class="string">'avoscloud-sdk'</span>);</span><br><span class="line">AV.initialize(<span class="string">'&#123;&#123;appid&#125;&#125;'</span>, <span class="string">'&#123;&#123;appkey&#125;&#125;'</span>);</span><br></pre></td></tr></table></figure>
<p>LeanCloud 同时也提供了一个完整的 Nodejs 环境，我们称之为 LeanEngine，更推荐基于 LeanEngine 来实现并部署 Nodejs 相关的代码。详细请参考<a href="https://leancloud.cn/docs/leanengine_guide-node.html" target="_blank" rel="external">云引擎文档</a> 。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/php_start/" itemprop="url">
                PHP 开发指南
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/php_start/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/php_start/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h4 id="安装">安装</h4><p>运行环境要求 PHP 5.3 及以上版本，以及<br><a href="http://php.net/manual/zh/book.curl.php" target="_blank" rel="external">cURL</a>。</p>
<p><strong>composer 安装</strong></p>
<p>如果你的项目使用 composer, 那么安装 LeanCloud PHP SDK 将非常容易：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require leancloud/leancloud-sdk</span><br></pre></td></tr></table></figure>
<p><strong>手动下载安装</strong></p>
<ul>
<li>前往发布页面下载最新版本: <a href="https://github.com/leancloud/php-sdk/releases" target="_blank" rel="external">https://github.com/leancloud/php-sdk/releases</a></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$APP_ROOT</span></span><br><span class="line">wget https://github.com/leancloud/php-sdk/archive/vX.X.X.zip</span><br></pre></td></tr></table></figure>
<ul>
<li>将压缩文件解压并置于项目文件夹下，如 $APP_ROOT/vendor/leancloud</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unzip vX.X.X.zip</span><br><span class="line">mv php-sdk-X.X.X <span class="variable">$APP_ROOT</span>/vendor/leancloud</span><br></pre></td></tr></table></figure>
<h4 id="初始化">初始化</h4><p>完成上述安装后，请加载库（在项目的一开始就需要加载，且只需加载一次）：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require_once</span>(<span class="string">"vendor/autoload.php"</span>);               <span class="comment">// composer 安装</span></span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">"vendor/leancloud/src/autoload.php"</span>); <span class="comment">// 手动安装</span></span><br></pre></td></tr></table></figure>
<p>如果已经创建应用，可以在 <a href="/app.html?appid=#/key"><strong>控制台</strong> &gt; <strong>应用设置</strong></a><br>里面找到应用的 id 和 key。然后需要对应用初始化：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数依次为 appId, appKey, masterKey</span></span><br><span class="line">LeanCloud\LeanClient::initialize(<span class="string">"&#123;&#123;appid&#125;&#125;"</span>, <span class="string">"&#123;&#123;appkey&#125;&#125;"</span>, <span class="string">"&#123;&#123;masterkey&#125;&#125;"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们目前支持 CN 和 US 区域，默认使用 CN 区域，可以切换为 US 区域</span></span><br><span class="line">LeanCloud\LeanClient::useRegion(<span class="string">"US"</span>);</span><br></pre></td></tr></table></figure>
<p>测试应用已经正确初始化：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LeanCloud\LeanClient::get(<span class="string">"/date"</span>); <span class="comment">// 获取服务器时间</span></span><br><span class="line"><span class="comment">// =&gt; &#123;"__type": "Date", "iso": "2015-10-01T09:45:45.123Z"&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="使用">使用</h4><p>初始化应用后，就可以开始创建数据了：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">LeanCloud</span>\<span class="title">LeanObject</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">LeanCloud</span>\<span class="title">CloudException</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> LeanObject(<span class="string">"TestObject"</span>);</span><br><span class="line"><span class="variable">$obj</span>-&gt;set(<span class="string">"name"</span>, <span class="string">"alice"</span>);</span><br><span class="line"><span class="variable">$obj</span>-&gt;set(<span class="string">"height"</span>, <span class="number">60.0</span>);</span><br><span class="line"><span class="variable">$obj</span>-&gt;set(<span class="string">"weight"</span>, <span class="number">4.5</span>);</span><br><span class="line"><span class="variable">$obj</span>-&gt;set(<span class="string">"birthdate"</span>, <span class="keyword">new</span> \DateTime());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="variable">$obj</span>-&gt;save();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloudException <span class="variable">$ex</span>) &#123;</span><br><span class="line">    <span class="comment">// CloudException 会被抛出，如果保存失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字段值</span></span><br><span class="line"><span class="variable">$obj</span>-&gt;get(<span class="string">"name"</span>);</span><br><span class="line"><span class="variable">$obj</span>-&gt;get(<span class="string">"height"</span>);</span><br><span class="line"><span class="variable">$obj</span>-&gt;get(<span class="string">"birthdate"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子增加一个数</span></span><br><span class="line"><span class="variable">$obj</span>-&gt;increment(<span class="string">"age"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在数组字段中添加，添加唯一，删除</span></span><br><span class="line"><span class="comment">// 注意: 由于API限制，不同数组操作之间必须保存，否则会报错</span></span><br><span class="line"><span class="variable">$obj</span>-&gt;addIn(<span class="string">"colors"</span>, <span class="string">"blue"</span>);</span><br><span class="line"><span class="variable">$obj</span>-&gt;save();</span><br><span class="line"><span class="variable">$obj</span>-&gt;addUniqueIn(<span class="string">"colors"</span>, <span class="string">"orange"</span>);</span><br><span class="line"><span class="variable">$obj</span>-&gt;save();</span><br><span class="line"><span class="variable">$obj</span>-&gt;removeIn(<span class="string">"colors"</span>, <span class="string">"blue"</span>);</span><br><span class="line"><span class="variable">$obj</span>-&gt;save();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在云存储上删除它</span></span><br><span class="line"><span class="variable">$obj</span>-&gt;destroy();</span><br></pre></td></tr></table></figure>
<p>大功告成，访问 <a href="/data.html?appid=#/TestObject"><strong>控制台</strong> &gt; <strong>数据管理</strong></a><br>可以看到上面创建的 TestObject 的相关数据。</p>
<p>请参考详细的 <a href="/api-docs/php">API 文档</a>。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&laquo;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/3/">&raquo;</a>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="https://avatars2.githubusercontent.com/u/14305708?v=3&s=460" alt="terry" itemprop="image"/>
          <p class="site-author-name" itemprop="name">terry</p>
        </div>
        <p class="site-description motion-element" itemprop="description">terry yang's blog | java | scala | bi</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">136</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">11</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-next-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yangwei8888" target="_blank">github</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/microsoftgoogles" target="_blank">weibo</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/run-zhi-38" target="_blank">zhihu</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">terry</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  

    <script type="text/javascript">
      var disqus_shortname = 'yangwei888';
      var disqus_identifier = 'page/2/index.html';
      var disqus_title = '';
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
