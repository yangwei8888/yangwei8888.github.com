<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="terry yang's blog | java | scala | bi" />



  <meta name="keywords" content="Hexo,next" />



  <link rel="alternate" href="/atom.xml" title="yosita" type="application/atom+xml" />



  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="terry yang&apos;s blog | java | scala | bi">
<meta property="og:type" content="website">
<meta property="og:title" content="yosita">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="yosita">
<meta property="og:description" content="terry yang&apos;s blog | java | scala | bi">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="yosita">
<meta name="twitter:description" content="terry yang&apos;s blog | java | scala | bi">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>

  <title> yosita </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  

  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?7e8961fdae021b7bf62f2c767bb18c23";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">yosita</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/faq/" itemprop="url">
                LeanCloud FAQ
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/faq/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/faq/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="LeanCloud_FAQ">LeanCloud FAQ</h1><h2 id="账户和平台常见问题">账户和平台常见问题</h2><h3 id="LeanCloud_部署在哪个云平台上">LeanCloud 部署在哪个云平台上</h3><p>LeanCloud 部署在国内多个云计算平台上，并采用在双线机房内同时使用虚拟机和实体机的混合部署策略，来保证应用的访问体验和可靠性。</p>
<h3 id="获取客服支持有哪些途径">获取客服支持有哪些途径</h3><ul>
<li>到免费的<a href="https://forum.leancloud.cn/" target="_blank" rel="external">用户社区</a> 进行提问。</li>
<li>购买 <a href="/bill.html#/bill/general">技术支持</a>，进入 <a href="https://ticket.leancloud.cn/" target="_blank" rel="external">工单系统</a> 来提交问题。</li>
<li>发送邮件到 <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#x73;&#117;&#112;&#112;&#111;&#x72;&#116;&#64;&#108;&#101;&#x61;&#x6e;&#x63;&#108;&#x6f;&#x75;&#x64;&#46;&#114;&#x6f;&#x63;&#x6b;&#x73;">&#x73;&#117;&#112;&#112;&#111;&#x72;&#116;&#64;&#108;&#101;&#x61;&#x6e;&#x63;&#108;&#x6f;&#x75;&#x64;&#46;&#114;&#x6f;&#x63;&#x6b;&#x73;</a> 获取帮助。</li>
<li>紧急情况拨打客服电话：010-82800646。</li>
</ul>
<h3 id="计费是基于账号还是应用">计费是基于账号还是应用</h3><p>计费都基于用户账号，详细信息请参考 <a href="/pricing.html">价格</a> 页面。</p>
<h3 id="如果没有缴费会怎么样">如果没有缴费会怎么样</h3><p>账单逾期四周未缴，账户服务将被停止；应用数据被置于不可见模式，但仍会在 LeanCloud 云端保留一个月。如需要恢复服务和访问应用数据，请登录控制台，支付欠款。</p>
<p>我们为账单支付提供一段缓冲期，请在收到账单的十天内完成缴费即可。在此期间，我们会通过邮件或者电话等方式与您联系，因此强烈建议完整填写 <a href="/settings.html#/setting/info">开发者信息</a>，以免错过我们的提醒和最佳付款时机。</p>
<h3 id="如何付费">如何付费</h3><ul>
<li><p>支付宝 <a href="/bill.html#/bill/charge">充值</a></p>
<p>我们将每个月自动从您的账户余额里扣除上月账单的费用。每次扣费优先使用充值金额，其次是赠送金额。</p>
</li>
<li><p>对公账户付款</p>
<p>公司税号：<strong>110108597742364</strong><br>公司名称：<strong>美味书签（北京）信息技术有限公司</strong><br><br>开户银行：<strong>中国银行股份有限公司北京大运村支行</strong><br><br>银行账号：<strong>344159259324</strong><br><br>银行地址：<strong>北京市海淀区知春路 6 号锦秋国际大厦一层</strong><br>银行行号：<strong>104100004013</strong></p>
</li>
</ul>
<h3 id="如何申请开具发票">如何申请开具发票</h3><ul>
<li><p>申请开发票前，请先按系统要求，完善所有必填的用户信息。</p>
</li>
<li><p>无论采取哪一种付款方式，只有当累计支付金额达到人民币<strong>壹仟元</strong>后系统才允许申请，单笔开票金额不低于人民币<strong>壹仟元</strong>。</p>
</li>
<li><p>如有特别需求，如按月度账单金额结算，或先开发票后付款，请联系我们的市场部专员 <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#98;&#x75;&#x73;&#105;&#110;&#x65;&#x73;&#115;&#x40;&#108;&#x65;&#97;&#110;&#99;&#x6c;&#x6f;&#x75;&#x64;&#46;&#114;&#x6f;&#99;&#107;&#x73;">&#98;&#x75;&#x73;&#105;&#110;&#x65;&#x73;&#115;&#x40;&#108;&#x65;&#97;&#110;&#99;&#x6c;&#x6f;&#x75;&#x64;&#46;&#114;&#x6f;&#99;&#107;&#x73;</a>，QQ号：2607695496。</p>
</li>
<li><p>开具发票时段为每月 10 日至 30 日，发票以快递寄送。如需开具增值税专用发票，也请联系我们的市场部专员。</p>
</li>
<li><p>发票免费邮寄。</p>
</li>
</ul>
<h3 id="哪里获取平台的更新信息">哪里获取平台的更新信息</h3><p>通常情况下，我们新版本的更新周期为一到两周。获取更新信息可以通过：</p>
<ul>
<li><a href="http://blog.leancloud.cn/" target="_blank" rel="external">官方博客</a>（每次更新的详细信息都会发布在那里）</li>
<li><a href="http://weibo.com/avoscloud" target="_blank" rel="external">官方微博</a></li>
<li>官方微信公众号：LeanCloud</li>
<li>每月初，我们会将每月的更新摘要发送到您的注册邮箱。</li>
<li>在控制台页面的右上方有 <a href="/info-center.html#/index">消息中心</a>，请注意查看新通知。</li>
</ul>
<h3 id="API_开放吗">API 开放吗</h3><p>我们的 API 完全开放。我们提供的 SDK 也都是基于开放 API 实现的。详情请阅读 <a href="/docs/rest_api.html">REST API 详解</a>。</p>
<h3 id="提供哪些平台的_SDK">提供哪些平台的 SDK</h3><p>目前官方提供的 SDK 种类包括：</p>
<ul>
<li>iOS 和 OS X</li>
<li>Android</li>
<li>JavaScript</li>
<li>Windows Phone</li>
<li>Unity</li>
<li>Python</li>
<li>PHP</li>
</ul>
<p>来自第三方的开源项目有：</p>
<ul>
<li><a href="https://github.com/freewing99/BaasReponsitory" target="_blank" rel="external">C#</a></li>
</ul>
<p>详情请访问 <a href="/docs/sdk_down.html">SDK 下载</a> 页面。</p>
<h3 id="iOS_和_Android_是否可以使用同一个_App">iOS 和 Android 是否可以使用同一个 App</h3><p>当然可以。使用我们的 SDK，可以为同一个应用开发多个平台的版本，共享后端数据。</p>
<h3 id="支持_Unity_3D_吗">支持 Unity 3D 吗</h3><p>支持。请到 <a href="sdk_down.html">SDK 下载</a> 页面下载 Unity SDK。</p>
<h3 id="开发文档有提供搜索功能吗">开发文档有提供搜索功能吗</h3><p> <strong>官网文档</strong> 首页右上角就有搜索框，也可以直接访问 <a href="/search.html">搜索</a> 页面。</p>
<h2 id="API_相关">API 相关</h2><h3 id="API_调用次数有什么限制吗">API 调用次数有什么限制吗</h3><p>我们每个月提供 100 万次的免费额度，超过的部分才收费。免费额度不会将完全免费的推送服务和统计服务计算进去。另外，对于免费版和专业版，默认情况下，每个应用都有每秒 1000 次的并发访问上限，如果需要提高上限，请与我们联系。</p>
<p>对于从控制台或者使用 JavaScript SDK 上传文件（包括云引擎内），我们限制每秒最多上传 1 个文件，一分钟内最多上传 30 个文件。</p>
<h3 id="API_调用次数的计算">API 调用次数的计算</h3><p>对于「数据存储」来说，每次 create 和 update 一条数据算一次请求，如调用一次 <code>object.saveInBackground</code> 算一次 API 请求。</p>
<p><code>fetch</code>、<code>find</code>、<code>delete</code>、<code>deleteAll</code> 算<strong>一次请求</strong>：</p>
<ul>
<li>调用一次 fetch / find 通过 include 返回了 100 个关联对象，算一次 API 请求。</li>
<li>调用一次 find / deleteAll 来查找或删除 500 条记录，只算一次 API 请求。</li>
</ul>
<p><code>saveAll</code>、<code>fetchAll</code> 算<strong>多次请求</strong>：</p>
<ul>
<li>调用一次 saveAll / fetchAll 来保存或获取 array 里面 100 个 对象，算 100 次 API 请求。</li>
</ul>
<p>对于「<a href="status_system.html">应用内社交</a>」，create 和 update 按照 Status 和 Follower/Followee 的对象数量来计费。对于 query 则是按照请求数来计费，与结果的大小无关。collection fetch 也是按照请求次数来计费。</p>
<h3 id="可以在线测试_API_吗">可以在线测试 API 吗</h3><p>请访问 <a href="/apionline/">API 在线测试工具</a>。</p>
<h3 id="403_错误">403 错误</h3><p>403 错误分为两类：</p>
<ul>
<li>错误信息 <code>The user cannot be altered by a client without the session.</code>：用户没有登录，无法修改用户信息。</li>
<li>错误信息 <code>Forbidden to write by class permissions.</code> 或者 <code>Forbidden to read by class permissions.</code>：想要修改的 class 表没有打开「读」或者「写」的权限。在 <a href="/data.html">数据</a> 管理平台，点击相应的 class，在右侧选择 <strong>其他</strong> 下拉菜单，进入 <strong>权限管理</strong> 来设置 class 权限。</li>
</ul>
<p><img src="images/permission.png" alt="image"></p>
<h3 id="Unauthorized_错误">Unauthorized 错误</h3><p>应用 API 授权失败，请检查是否初始化了 App Id 和 App Key。</p>
<ul>
<li>如何进行初始化，请查看 <a href="/start.html">快速入门</a>。</li>
<li>App Id 和 App Key 在应用的 <strong>设置</strong> 菜单里可以找到。</li>
</ul>
<h3 id="错误信息代码和详细解释在哪里">错误信息代码和详细解释在哪里</h3><ul>
<li><a href="./error_code.html">错误代码详解</a></li>
<li>iOS SDK：<a href="/api-docs/iOS/docs/AVConstants.html">AVConstants</a></li>
<li>Android SDK：<a href="/api-docs/android/doc/index.html">AVException</a></li>
</ul>
<p>REST API 返回的错误信息跟 SDK 保持一致。</p>
<h3 id="其他语言调用_REST_API_如何对参数进行编码">其他语言调用 REST API 如何对参数进行编码</h3><p>REST API 文档使用 curl 作为示范，其中 <code>--data-urlencode</code> 表示要对参数进行 URL encode 编码。如果是 GET 请求，直接将经过 URL encode 的参数通过 <code>&amp;</code> 连接起来，放到 URL 的问号后。如 <code>https://leancloud.cn/1.1/login?username=xxxx&amp;password=xxxxx</code>。</p>
<h3 id="如何实现大小写不敏感的查询">如何实现大小写不敏感的查询</h3><p>目前不提供直接支持，可采用正则表达式查询的办法，具体参考 <a href="http://stackoverflow.com/questions/1863399/mongodb-is-it-possible-to-make-a-case-insensitive-query" target="_blank" rel="external">StackOverflow - MongoDB: Is it possible to make a case-insensitive query</a>。</p>
<p>使用各平台 SDK 的 AVQuery 对象提供的 <code>matchesRegex</code> 方法（Android SDK 用 <code>whereMatches</code> 方法）。</p>
<h3 id="应用内用户的密码需要加密吗">应用内用户的密码需要加密吗</h3><p>不需要加密密码，我们的服务端已使用随机生成的 salt，自动对密码做了加密。 如果用户忘记了密码，可以调用 <code>requestResetPassword</code> 方法（具体查看 SDK 的 AVUser 用法），向用户注册的邮箱发送邮件，用户以此可自行重设密码。 在整个过程中，密码都不会有明文保存的问题，密码也不会在客户端保存，只是会保存 sessionToken 来标示用户的登录状态。</p>
<h2 id="控制台相关">控制台相关</h2><h3 id="如何导入或者导出数据？">如何导入或者导出数据？</h3><p>请参考《数据与安全》文档的 <a href="./data_security.html#导入数据">导入数据</a> 和 <a href="./data_security.html#导出数据">导出数据</a> 部分。</p>
<h3 id="如何在_App_邮件内完全使用自己的品牌">如何在 App 邮件内完全使用自己的品牌</h3><p>请参考博文 <a href="http://blog.leancloud.cn/blog/2014/01/09/zi-ding-yi-ying-yong-nei-yong-hu-zhong-she-mi-ma-he-you-xiang-yan-zheng-ye-mian/" target="_blank" rel="external">《自定义应用内用户重设密码和邮箱验证页面》</a>。</p>
<h3 id="创建唯一索引失败">创建唯一索引失败</h3><p>请确认想要创建索引的列没有已经存在的重复值。</p>
<h3 id="如何上传文件">如何上传文件</h3><p>任何一个 Class 如果有 File 类型的列，就可以直接在 <strong>数据</strong> 管理平台中将文件上传到该列。如果没有，请自行创建列，类型指定为 File。</p>
<h3 id="如何在应用之间共享数据">如何在应用之间共享数据</h3><p>请参考我们的博客文章 <a href="http://blog.leancloud.cn/blog/2014/03/31/2014nian-3yue-di-4zhou-avos-cloud-geng-xin/" target="_blank" rel="external">《2014 年 3 月第 4 周更新日志》</a>。</p>
<h2 id="iOS/OS_X_SDK">iOS/OS X SDK</h2><h3 id="安装_Cocopods_失败怎么解决">安装 Cocopods 失败怎么解决</h3><p>推荐使用淘宝提供的 Gem 源，访问 <a href="https://ruby.taobao.org/" target="_blank" rel="external">https://ruby.taobao.org/</a>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources --add https://ruby.taobao.org/ --remove https://rubygems.org/</span><br><span class="line">$ gem sources <span class="operator">-l</span></span><br><span class="line">*** CURRENT SOURCES ***</span><br><span class="line"></span><br><span class="line">https://ruby.taobao.org</span><br><span class="line"><span class="comment"># 请确保只有 ruby.taobao.org</span></span><br><span class="line">$ gem install cocoapods</span><br></pre></td></tr></table></figure>
<p>由于淘宝已经停止基于 HTTP 协议的镜像服务，如果之前使用的是 <a href="http://ruby.taobao.org/" target="_blank" rel="external">http://ruby.taobao.org/</a>，这也可能导致安装 Cocopods 失败。</p>
<p>需要在配置中使用 HTTPS 协议代替：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources --add https://ruby.taobao.org/ --remove http://ruby.taobao.org/</span><br><span class="line">$ gem sources <span class="operator">-l</span></span><br><span class="line">*** CURRENT SOURCES ***</span><br><span class="line"></span><br><span class="line">https://ruby.taobao.org</span><br><span class="line"><span class="comment"># 请确保只有 ruby.taobao.org</span></span><br><span class="line">$ gem install cocoapods</span><br></pre></td></tr></table></figure>
<h3 id="编译失败">编译失败</h3><h4 id="Symbol(s)_not_found_x86_64">Symbol(s) not found x86_64</h4><p>请使用 32 位模拟器进行编译和调试.</p>
<h4 id="Undefined_symbols_for_architecture">Undefined symbols for architecture</h4><p>一般是由于 Framework 的链接找不到造成的，建议用 CocoaPods 更新一下。没使用 CocoaPods 的项目可以删除对 Framework 的引用，然后再重新加进来。</p>
<p>LeanCloud 依赖的 Framework 包括：</p>
<ul>
<li>SystemConfiguration.framework</li>
<li>MobileCoreServices.framework</li>
<li>CoreTelephony.framework</li>
<li>CoreLocation.framework</li>
</ul>
<p>如果是 <code>for architecture arm64</code>，这是因为 Xcode 更新到 5.1 后，CocoaPods 没有及时更新对 64 位 CPU 的支持，解决方法参考 <a href="http://stackoverflow.com/questions/19213782/undefined-symbols-for-architecture-arm64" target="_blank" rel="external">《StackOverflow - Undefined symbols for architecture arm64》</a></p>
<h3 id="请求报错">请求报错</h3><p>请参考请求返回的错误码 <a href="error_code.html">详细说明</a>。</p>
<h3 id="地理位置查询错误">地理位置查询错误</h3><p>如果错误信息类似于 <code>can&#39;t find any special indices: 2d (needs index), 2dsphere (needs index), for 字段名</code>，就代表用于查询的字段没有建立 2D 索引，可以在 Class 管理的 <strong>其他</strong> 菜单里找到 <strong>索引</strong> 管理，点击进入，找到字段名称，选择并创建「2dsphere」索引类型。</p>
<p><img src="images/geopoint_faq.png" alt="image"></p>
<h2 id="Android_SDK">Android SDK</h2><h3 id="对_AVObject_对象使用_getDate(“createdAt”)_方法读取创建时间为什么会返回_null">对 AVObject 对象使用 getDate(“createdAt”) 方法读取创建时间为什么会返回 null</h3><p>请用 <code>AVObject</code> 的 <code>getCreatedAt</code> 方法；获取 <code>updatedAt</code> 用 <code>getUpdatedAt</code>。</p>
<h2 id="JavaScript_SDK">JavaScript SDK</h2><h3 id="有没有同步_API">有没有同步 API</h3><p>JavaScript SDK 由于平台的特殊性（运行在单线程运行的浏览器或者 Node.js 环境中），不提供同步 API，所有需要网络交互的 API 都需要以 callback 的形式调用。我们提供了 <a href="js_guide.html#promise">Promise 模式</a> 来减少 callback 嵌套过多的问题。</p>
<h2 id="消息推送">消息推送</h2><h3 id="推送的到达率如何">推送的到达率如何</h3><p>关于到达率这个概念，业界并没没有统一的标准。我们测试过，在线用户消息的到达率基本达到 100%。我们的 SDK 做了心跳和重连等功能，尽量维持对推送服务器的长连接存活，提升消息到达用户手机的实时性和可靠性。</p>
<h3 id="推送是基于_XMPP_还是其他协议">推送是基于 XMPP 还是其他协议</h3><p>老版本推送基于 XMPP 协议，v2.4.1 版本开始，推送采用了 WebSocket 协议，方便支持多平台，包括将要推出的 Web 端消息推送功能。</p>
<h3 id="iOS_推送如何区分开发证书和生产证书">iOS 推送如何区分开发证书和生产证书</h3><p>暂不提供在同一个 App 里同时上传开发证书和生产证书。推荐创建单独的测试 App，可以利用数据导出和导入来快速模拟生产环境。</p>
<h3 id="Android_消息接收能不能自定义_Receiver_不弹出通知">Android 消息接收能不能自定义 Receiver 不弹出通知</h3><p>可以。请参考 <a href="push_guide.html#消息内容_Data">消息推送开发指南</a>。</p>
<p>如果要自定义 receiver，必须在消息的 data 里带上自定义的 action。LeanCloud 在接收到消息后，将广播 action 为您定义的值的 intent 事件，您的 receiver 里也必须带上 <code>intent-filter</code> 来捕获该 action 值的 intent 事件。</p>
<h2 id="统计">统计</h2><h3 id="统计服务免费吗">统计服务免费吗</h3><p>统计服务完全免费，不占用每月的 API 免费额度。</p>
<h3 id="统计服务支持哪些平台">统计服务支持哪些平台</h3><p>目前支持</p>
<ul>
<li>iOS</li>
<li>OS X</li>
<li>Android</li>
</ul>
<p>更多平台 SDK 正在开发中。</p>
<h3 id="统计支持哪些发送策略">统计支持哪些发送策略</h3><ul>
<li>启动时发送（默认策略，推荐使用）</li>
<li>批量发送</li>
<li>按最小间隔发送</li>
</ul>
<p>可以在 <strong>分析</strong> &gt; <strong>Android（或者 iOS）统计</strong> &gt; <strong>统计设置</strong> &gt; <strong>数据发送策略</strong> 的菜单里实时修改这些策略。</p>
<h2 id="云引擎">云引擎</h2><h3 id="定时器_crontab_的语法">定时器 crontab 的语法</h3><p>请参考 <a href="http://www.quartz-scheduler.org/documentation/quartz-1.x/tutorials/crontrigger" target="_blank" rel="external">Quartz 文档</a>。</p>
<h3 id="云端代码都支持那些语言">云端代码都支持那些语言</h3><p>目前支持 Node.js 和 Python 运行环境，未来可能还会引入 PHP 等其他语言。</p>
<h3 id="云引擎如何上传文件">云引擎如何上传文件</h3><p>请参考这篇博文 <a href="http://blog.leancloud.cn/blog/2013/11/23/zai-yun-dai-ma-zhong-chu-li-shang-chuan-wen-jian/" target="_blank" rel="external">《在云代码中处理上传文件》</a>，或者 <a href="leanengine_guide-cloudcode.html#上传文件">云引擎指南 - 上传文件</a> 中的相关内容。</p>
<h3 id="云引擎中如何处理用户登录和_Cookie">云引擎中如何处理用户登录和 Cookie</h3><p>请参考这篇博文 <a href="http://blog.leancloud.cn/blog/2013/12/16/zai-yun-dai-ma-zhong-chu-li-yong-hu-deng-lu/" target="_blank" rel="external">《在云代码中处理用户登录》</a>，或者 <a href="leanengine_guide-cloudcode.html#处理用户登录和登出">云引擎指南</a> 中的相关内容。</p>
<h3 id="云引擎的二级域名多久生效">云引擎的二级域名多久生效</h3><p>我们设置的 TTL 是 10 秒，但是因为使用 Amazon 的 DNS 服务，因此可能国内部分地区会有一定延迟，最迟应该在 24 小时内生效。如果没有，请及时联系我们处理。</p>
<h3 id="云引擎二级域名可以启用_HTTPS_吗">云引擎二级域名可以启用 HTTPS 吗</h3><p>请参考这篇博文 <a href="http://blog.leancloud.cn/blog/2013/12/20/wei-yun-dai-ma-tuo-guan-wang-zhan-qi-yong-https/" target="_blank" rel="external">《为云代码托管网站启用 HTTPS》</a>。</p>
<h3 id="云引擎_Web_Hosting_备案">云引擎 Web Hosting 备案</h3><p>只有网站类的才需要备案，并且在主域名已备案的情况下，二级子域名不需要备案。</p>
<p>如果主站需要托管在我们这边，而且主站还没经过备案，请参考文档 <a href="leanengine_guide-cloudcode.html#域名备案流程">云引擎指南 - 域名备案流程</a> 部分来了解具体的备案流程。</p>
<h2 id="文件">文件</h2><h3 id="文件存储有_CDN_加速吗？">文件存储有 CDN 加速吗？</h3><p>有的。我们的文件存储目前由 <a href="http://qiniu.com" target="_blank" rel="external">七牛</a> 提供，都有 CDN 加速访问。</p>
<h3 id="文件存储有大小限制吗？">文件存储有大小限制吗？</h3><p>没有。除了在浏览器里通过 JavaScript SDK 上传文件，或者通过我们网站直接上传文件，有 10 MB 的大小限制之外，其他 SDK 都没有限制。 JavaScript SDK 在 Node.js 环境中也没有大小限制。</p>
<h3 id="存储图片可以做缩略图等处理吗？">存储图片可以做缩略图等处理吗？</h3><p>可以。默认我们的 <code>AVFile</code> 类提供了缩略图获取方法，可以参见各个 SDK 的开发指南。如果要自己处理，可以通过获取 <code>AVFile</code> 的 <code>URL</code> 属性，使用 <a href="http://docs.qiniu.com/api/v6/image-process.html" target="_blank" rel="external">七牛图片处理 API</a> 执行处理，例如添加水印、裁剪等。</p>
<h2 id="短信">短信</h2><p>详情请参照<a href="/docs/rest_sms_api.html#常见问题_FAQ">短信收发常见问题一览</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/data_security/" itemprop="url">
                数据和安全
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/data_security/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/data_security/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="数据和安全">数据和安全</h1><h2 id="安全总览">安全总览</h2><p>几乎每一位使用 LeanCloud 的用户都会问，如何能够保证自己应用的安全？对安全的关注说明你也位对产品负责、对用户负责、对自己负责、做事态度认真的开发者，这也正是 <a href="http://open.leancloud.cn" target="_blank" rel="external">LeanCloud 所信守的价值观</a>。</p>
<p>安全界有个说法——绝对的安全是不存在的。其中关键要点是要梳理清楚「安全边界」，即你对于业务安全范围的一个清晰的界定。业内一个很著名的例子就是 Chrome 浏览器的查看密码功能，查看已存储的密码不需要再输入 Google 账号的密码。</p>
<p>LeanCloud 通过以下三重级别来总体控制每个应用的安全：</p>
<ul>
<li>SSL 安全连接（HTTPS）</li>
<li>Web 安全域名</li>
<li>ACL 权限控制</li>
</ul>
<p>数据层面，云端每天会备份一次数据，防止误操作等情况删除重要数据。其他安全设置还包括云端验证和检测，比如实时通信可以支持自定义的云端认证、短信验证的各种安全设置、SDK 中的各种安全细节等。</p>
<p>每个应用都有自己的 AppId，并且需要通过这个唯一的 id 从服务端申请和调用资源。理论上说这个 AppId 应该严格保密，但是实际中它总会泄露。如果说用反编译原生应用的方法来破解 AppId 还要费些周折，那对于 Web 应用，只要查看到页面源码就能找出 AppId。所以我们要需要做哪些防御？关键点是，我们要能够保证其他人把你的 AppId 偷过去之后，他也无法直接使用你的服务器资源。Web 端可以通过 <code>Web 安全域名</code> 来对请求来源做限制，可以简单的防御住 Web 的服务器资源盗取。但是 <strong>安全域名</strong> 对 Native 类的应用又是无效的，所以如果你是使用 Native App 的 SDK，那么设置安全域名就不够了，这个时候就要考虑使用「ACL 权限控制」。</p>
<p>注意，这里每次的调整都是对安全边界的一次次评估，不是每个设置每个应用都需要如此操作。</p>
<p>ACL 权限控制是如何管理安全的呢？举个例子：</p>
<p>比如你要做一个账号系统，这个系统中每个用户账号都有头像，所以你会有一个用户上传头像接口。那么，如果你把这个上传头像的功能放在注册成功之前，每个没有经过你的 ACL 权限认证（没有登录）的用户都可以通过这个接口上传头像，所以你这个上传头像的接口是存在滥用的。如果接口 ACL 权限设置为注册成功的某类用户，则用户必须要经过 ACL 权限认证为是属于某个权限的用户（即登录），并且此时他才可以使用这个接口。所以，上传接口如此，其他的类似功能也是同理，但凡是通过 SDK 或者 API 调用的接口操作，你都要确保他们的 ACL 权限控制是在你的控制范围内。这需要你的智慧和设计来保证安全，相信你也一定能做到。</p>
<p>SSL 其实没有什么好说的，所有的数据都采用加密链路，这样做可以保证数据的私密性。</p>
<p>总之，一切安全设计的背后都是需要你考虑清楚你的 App、你的产品的「安全边界」，制定对应的安全策略。当然安全是后话，首先通过使用 LeanCloud 节省大量时间成本、研发成本、机会成本把产品快速迭代起来才是正经事。</p>
<h2 id="安全中心">安全中心</h2><p>安全中心，是我们为每个应用提供的设置基本安全的入口，位置在 <a href="/app.html?appid=#/security">控制台 / 设置 / 安全中心</a>。</p>
<h3 id="服务开关">服务开关</h3><p>服务开关，是用来开启或者关闭当前应用所使用的服务，从根本上防止由于 AppId 和 AppKey 泄露后而可能会引发的服务资源被盗取的问题。</p>
<p><img src="images/security/service-switch.png" alt="image"></p>
<h3 id="Web_安全域名">Web 安全域名</h3><p>如果在前端使用 JavaScript SDK，当你打算正式发布出去的时候，请务必配置 <strong>Web 安全域名</strong>，方法是进入 <a href="/app.html?appid=#/security">控制台 / 设置 / 安全中心 / <strong>Web 安全域名</strong></a>。</p>
<p>设置「Web 安全域名」后，仅可在该域名下通过 JavaScript SDK 调用服务器资源，域名配置策略与浏览器域安全策略一致，要求域名协议、域和端口号都需严格一致，不支持子域和通配符。所以如果你要配置一个域名，要写清楚协议、域和端口，缺少一个都可能导致访问被禁止。举例说明一下域名的区别：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跨域</span></span><br><span class="line">www<span class="class">.a</span><span class="class">.com</span>:<span class="number">8080</span></span><br><span class="line">www<span class="class">.a</span><span class="class">.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 跨域 </span></span><br><span class="line">www<span class="class">.a</span><span class="class">.com</span>:<span class="number">8080</span></span><br><span class="line">www<span class="class">.a</span><span class="class">.com</span>:<span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 跨域  </span></span><br><span class="line"><span class="tag">a</span><span class="class">.com</span></span><br><span class="line">www<span class="class">.a</span><span class="class">.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 跨域</span></span><br><span class="line">xxx<span class="class">.a</span><span class="class">.com</span></span><br><span class="line">www<span class="class">.a</span><span class="class">.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同协议，跨域         </span></span><br><span class="line">http:</span><br><span class="line">https:</span><br></pre></td></tr></table></figure>
<p>这样就可以防止其他人通过外网其他地址盗用你的服务器资源。但是要注意，<strong>Web 安全域名</strong>所能达到的目的是防御恶意部署，而不是防御伪造脏数据（恶意用户通过绑定 host 方式还是有可能访问到应用的数据），所以要想对数据进行更多细粒度的控制，需要配合 ACL 来使用。</p>
<p>在 WebView 中使用，建议通过 WebView 去加载一个部署好的、有域名的 Web，然后缓存在本地，这样可以通过 <strong>Web 安全域名</strong> 来做限制。</p>
<p><img src="images/security/web-host.png" alt="image"></p>
<h3 id="操作日志">操作日志</h3><p>操作日志中会显示应用创建者及所有协作者的重要操作记录，比如删除数据操作的历史、操作用户名、操作 IP 及操作时间等，这个日志的目的是为了遇到问题更好地定位故障缘由，排查可能的恶意操作，防止应用数据被错误地改动。</p>
<h2 id="数据">数据</h2><h3 id="自动备份">自动备份</h3><p>LeanCloud 目前会每天备份一次应用数据，防止用户误操作删除了重要数据。如果发生误删除，请及时联系我们进行恢复。</p>
<h3 id="有效的数据类型">有效的数据类型</h3><p>我们已经仔细设计并实现了客户端 SDK，在你使用 iOS 或者 Android SDK 的时候，通常来说你不需要担心数据是如何保存的。只要简单地往 AVObject 添加数据，它们都能被正确地保存。</p>
<p>尽管如此，有些情况下了解数据如何存储在 LeanCloud 平台上还是有一些用处。</p>
<p>在平台内部，LeanCloud 将数据存储为 JSON，因此所有能被转换成 JSON 的数据类型都可以保存在 LeanCloud 平台上。并且，框架还可以处理日期、Bytes 以及文件类型。总结来说，对象中字段允许的类型包括：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>字符串</td>
</tr>
<tr>
<td>Number</td>
<td>数字</td>
</tr>
<tr>
<td>Boolean</td>
<td>布尔类型</td>
</tr>
<tr>
<td>Array</td>
<td>数组</td>
</tr>
<tr>
<td>Object</td>
<td>对象，或者 Pointer </td>
</tr>
<tr>
<td>Date</td>
<td>日期</td>
</tr>
<tr>
<td>Bytes</td>
<td>Base64 编码的二进制数据</td>
</tr>
<tr>
<td>File</td>
<td>文件</td>
</tr>
<tr>
<td>Null</td>
<td>空值</td>
</tr>
</tbody>
</table>
<p>Object 类型简单地表示每个字段的值都可以由能 JSON 编码的内嵌对象组合而成。凡是对象的键（key） 包含 <code>$</code> 或者 <code>.</code>，或者同时有 <code>__type</code> 键，都是框架内保留用来做一些额外处理的特殊键，因此请不要在你的对象中使用这样的 Key。</p>
<p>我们的 SDK 会处理原生的 Objective-C 和 Java 类型到 JSON 之间的转换。例如，当你保存一个 NSString 对象的时候，它在我们的系统中会被自动转换成 String 类型。</p>
<p>有两种方式可以存储原生的二进制数据。Bytes 类型允许直接在 AVObject 中关联 NSData 或者 bytes[] 类型的数据。这种方式只推荐用来存储小片的二进制数据。当要保存实际文件（例如图片、视频、文档等），请使用 AVFile 来表示 File 类型，并且 File 类型可以被保存到对象字段中关联起来。</p>
<h3 id="数据类型锁定">数据类型锁定</h3><p>当一个 Class 初次创建的时候，它不包含任何预先定义并继承的 schema。也就是说对于存储的第一个对象，它的字段可以包含任何有效的类型。</p>
<p>但是，当一个字段被保存至少一次的时候，这个字段将被锁定为保存过的数据类型。例如，如果一个 User 对象保存了一个字段 name，类型为 String，那么这个 name 字段将被严格限制为只允许保存 String 类型。如果你尝试保存其他类型到这个字段，我们的 SDK 会返回错误。</p>
<p>一个特例是任何字段都允许被设置为 null，无论它是什么类型。</p>
<h3 id="数据管理">数据管理</h3><p><a href="/data.html?appid=&lt;!--￼11--">数据管理</a> 是一个允许在你任意的一个应用里更新或者创建对象的一个 Web 界面的管理平台。在这里，你可以看到保存在 Class里的每个对象的原生 JSON 值。</p>
<p>当使用这个平台的时候，请牢记：</p>
<ul>
<li>输入 <code>null</code> 将会将值设为特殊的空值 <strong>null</strong>，而非字符串 <code>&quot;null&quot;</code>。</li>
<li>objectId、createdAt 和 updatedAt 不可编辑，它们都是系统自动设置的。</li>
<li>下划线开始的 Class 为系统内置数据表，不可删除，并且请轻易不要修改它的默认字段，但是可以向其中添加字段。</li>
</ul>
<h3 id="导入数据">导入数据</h3><p>除了 REST API 之外，我们还提供通过 JSON 文件和 CSV 格式文件的导入数据的功能。</p>
<p>要使用 JSON 文件创建一个新 Class，请进入 <a href="/data.html?appid=&lt;!--￼12--">控制台 / 存储 / 数据管理</a>，点击左侧 Class 导航栏的小齿轮图标，选择 <strong>数据导入</strong>。</p>
<div class="callout callout-info">数据文件的扩展名必须是 <code>.csv</code> 或者 <code>.json</code> 结尾，我们以此来判断导入数据的类型。</div>

<h4 id="JSON_文件格式">JSON 文件格式</h4><p>JSON 格式要求是一个符合我们 REST 格式的 JSON 对象数组，或者是一个包含了键名为 results、值为对象数组的 JSON 对象。例如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123; "<span class="attribute">results</span>": <span class="value">[</span><br><span class="line">  &#123;</span><br><span class="line">    "<span class="attribute">likes</span>": <span class="value"><span class="number">2333</span></span>,</span><br><span class="line">    "<span class="attribute">title</span>": <span class="value"><span class="string">"讲讲明朝的那些事儿"</span></span>,</span><br><span class="line">    "<span class="attribute">author</span>": <span class="value">&#123;</span><br><span class="line">      "<span class="attribute">__type</span>": <span class="value"><span class="string">"Pointer"</span></span>,</span><br><span class="line">      "<span class="attribute">className</span>": <span class="value"><span class="string">"Author"</span></span>,</span><br><span class="line">      "<span class="attribute">objectId</span>": <span class="value"><span class="string">"mQtjuMF5xk"</span></span><br><span class="line">    </span>&#125;</span>,</span><br><span class="line">    "<span class="attribute">isDraft</span>": <span class="value"><span class="literal">false</span></span>,</span><br><span class="line">    "<span class="attribute">createdAt</span>": <span class="value"><span class="string">"2015-11-25T17:15:33.347Z"</span></span>,</span><br><span class="line">    "<span class="attribute">updatedAt</span>": <span class="value"><span class="string">"2015-11-27T19:05:21.377Z"</span></span>,</span><br><span class="line">    "<span class="attribute">publishedAt</span>": <span class="value">&#123;</span><br><span class="line">      "<span class="attribute">__type</span>": <span class="value"><span class="string">"Date"</span></span>,</span><br><span class="line">      "<span class="attribute">iso</span>": <span class="value"><span class="string">"2015-11-27T19:05:21.377Z"</span></span><br><span class="line">    </span>&#125;</span>,</span><br><span class="line">    "<span class="attribute">objectId</span>": <span class="value"><span class="string">"fchpZwSuGG"</span></span><br><span class="line">  </span>&#125;]</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>【日期】示例中，<code>publishedAt</code> 是一个日期型字段，其格式要求请参考 <a href="rest_api.html#datatype_date">REST API &middot; 数据类型</a>。</p>
<p>【密码】导入用户密码需要使用一个特殊的字段 <code>bcryptPassword</code>，并且完全遵循 <a href="http://stackoverflow.com/a/5882472/1351961" target="_blank" rel="external">Stackoverflow &middot; What column type/length should I use for storing a Bcrypt hashed password in a Database?</a>  所描述的加密算法加密后，才可以作为合法的密码进行导入。</p>
<p>【关系】导入 Relation 关联数据时，需要填写要导入的 Class 名称、导入后的字段名称、关联的 Class 名称等信息，才能完整导入，例如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123; "<span class="attribute">results</span>": <span class="value">[</span><br><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">owningId</span>": <span class="value"><span class="string">"dMEbKFJiQo"</span></span>,</span><br><span class="line">  "<span class="attribute">relatedId</span>": <span class="value"><span class="string">"19rUj9I0cy"</span></span><br><span class="line"></span>&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">owningId</span>": <span class="value"><span class="string">"mQtjuMF5xk"</span></span>,</span><br><span class="line">  "<span class="attribute">relatedId</span>": <span class="value"><span class="string">"xPVrHL0W4n"</span></span><br><span class="line"></span>&#125;]</span>&#125;</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>owningId</code>： 将要导入的 Class 表内已经存在的对象的 objectId。</li>
<li><code>relatedId</code>：将要关联的 Class 里的对象的 objectId。</li>
</ul>
<p>例如，Post 有一个字段 comments 是 Relation 类型，对应的 Class 是 Comment，那么 owningId 就是已存在的 Post 的 objectId，而 relatedId 就是关联的 Comment 的 objectId。</p>
<h3 id="CSV格式文件">CSV格式文件</h3><p>导入 Class 的 csv 文件格式必须符合我们的扩展要求：</p>
<ul>
<li>第一行必须是字段的类型描述，支持 <code>int</code>、<code>long</code>、<code>number</code>、<code>double</code>、<code>string</code>、<code>date</code>、<code>boolean</code>、<code>file</code>、<code>array</code>、<code>object</code>、<code>geopoint</code> 等。</li>
<li>第二行是字段的名称</li>
<li>第三行开始才是要导入的数据</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string,int,string,double,date&#10;name,age,address,account,createdAt&#10;&#24352;&#19977;,33,&#21271;&#20140;,300.0,2014-05-07T19:45:50.701Z&#10;&#26446;&#22235;,25,&#33487;&#24030;,400.03,2014-05-08T15:45:20.701Z&#10;&#29579;&#20116;,21,&#19978;&#28023;,1000.5,2012-04-22T09:21:35.701Z</span><br></pre></td></tr></table></figure>
<p>导入的 <code>geopoint</code> 格式是一个用空格隔开字符串：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geopoint,string,int,string,double,date&#10;location,name,age,address,account,createdAt&#10;20 20,&#24352;&#19977;,33,&#21271;&#20140;,300.0,2014-05-07T19:45:50.701Z&#10;30 30,&#26446;&#22235;,25,&#33487;&#24030;,400.03,2014-05-08T15:45:20.701Z&#10;40 40,&#29579;&#20116;,21,&#19978;&#28023;,1000.5,2012-04-22T09:21:35.701Z</span><br></pre></td></tr></table></figure>
<p>导入的 Relation 数据，比 JSON 简单一些，第一列对应 JSON 的 <code>owningId</code>，也就是要导入的 Class 的存在对象的 objectId，第二列对应 <code>relatedId</code>，对应关联 Class 的 objectId。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dMEbKFJiQo,19rUj9I0cy&#10;mQtjuMF5xk,xPVrHL0W4n</span><br></pre></td></tr></table></figure>
<p>csv 导入也支持 Pointer 类型，要求类型声明为 <code>pointer:类名</code>，其中类名就是该 Pointer 列所指定的 className，列的值只要提供 objectId 即可，例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string,pointer:Player&#10;playerName,player&#10;&#24352;&#19977;,mQtjuMF5xk&#10;&#26446;&#22235;,xPVrHL0W4n</span><br></pre></td></tr></table></figure>
<h3 id="导出数据">导出数据</h3><p>我们还支持你可以导出所有的应用数据（包括加密后的用户密码），只要进入 <a href="/app.html?appid=#/export">控制台 / 应用设置 / 数据导出</a> 点击导出按钮即可开始导出任务。我们会在导出完成之后发送下载链接到你的注册邮箱。</p>
<p>导出还可以限定日期，我们将导出在限定时间内有过更新或者新增加的数据。</p>
<p>我们还提供了数据导出的 <a href="./rest_api.html#数据导出_API">RETS API</a>。</p>
<h4 id="导出用户数据的加密算法">导出用户数据的加密算法</h4><p>我们通过一个 Ruby 脚本来描述这个用户密码加密算法：</p>
<ol>
<li>创建 SHA-512 加密算法 hasher</li>
<li>使用 salt 和 password（原始密码） 调用 hasher.update</li>
<li>获取加密后的值 <code>hv</code></li>
<li>重复 512 次调用 <code>hasher.update(hv)</code>，每次hv都更新为最新的 <code>hasher.digest</code> 加密值</li>
<li>最终的 hv 值做 base64 编码，保存为 password</li>
</ol>
<p>假设：</p>
<table width="100%" border="0" cellpadding="6"><br>  <tbody><br>    <tr><br>      <td nowrap="">salt</td><br>      <td><pre style="margin:0;"><code>h60d8x797d3oa0naxybxxv9bn7xpt2yiowz68mpiwou7gwr2</code></pre></td><br>    </tr><br>    <tr><br>      <td nowrap="">原始密码</td><br>      <td><code>password</code></td><br>    </tr><br>    <tr><br>      <td nowrap="">加密后</td><br>      <td><pre style="margin:0;"><code>tA7BLW+NK0UeARng0693gCaVnljkglCB9snqlpCSUKjx2RgYp8VZZOQt0S5iUtlDrkJXfT3gknS4rRqjYsd/Ug==</code></pre></td><br>    </tr><br>  </tbody><br></table>

<p>实现代码：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'digest/sha2'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">"base64"</span></span><br><span class="line"></span><br><span class="line">hasher = <span class="constant">Digest::SHA512</span>.new</span><br><span class="line">hasher.reset</span><br><span class="line">hasher.update <span class="string">"h60d8x797d3oa0naxybxxv9bn7xpt2yiowz68mpiwou7gwr2"</span></span><br><span class="line">hasher.update <span class="string">"password"</span></span><br><span class="line"></span><br><span class="line">hv = hasher.digest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hashme</span><span class="params">(hasher, hv)</span></span></span><br><span class="line">  <span class="number">512</span>.times <span class="keyword">do</span></span><br><span class="line">    hasher.reset</span><br><span class="line">    hv = hasher.digest hv</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  hv</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">result = <span class="constant">Base64</span>.encode64(hashme(hasher,hv))</span><br><span class="line">puts result.gsub(<span class="regexp">/\n/</span>,<span class="string">''</span>)</span><br></pre></td></tr></table></figure>
<p>非常感谢用户残圆贡献了一段 C# 语言示例代码：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/// 根据数据字符串和自定义 salt 值，获取对应加密后的字符串</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=<span class="string">"password"</span>&gt;数据字符串&lt;/param&gt;</span><br><span class="line">/// &lt;param name=<span class="string">"salt"</span>&gt;自定义 salt 值&lt;/param&gt;</span><br><span class="line">/// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">public <span class="keyword">static</span> <span class="type">string</span> <span class="type">SHA512Encrypt</span>(<span class="type">string</span> password, <span class="type">string</span> salt)</span><br><span class="line">&#123;</span><br><span class="line">    /*</span><br><span class="line">    用户密码加密算法</span><br><span class="line">    </span><br><span class="line">    <span class="number">1</span>、创建 <span class="type">SHA</span>-<span class="number">512</span> 加密算法 hasher</span><br><span class="line">    <span class="number">2</span>、使用 salt 和 password（原始密码） 调用 hasher.update</span><br><span class="line">    <span class="number">3</span>、获取加密后的值 hv</span><br><span class="line">    <span class="number">4</span>、重复 <span class="number">512</span> 次调用 hasher.update(hv)，每次hv都更新为最新的 hasher.digest 加密值</span><br><span class="line">    <span class="number">5</span>、最终的 hv 值做 base64 编码，保存为 password</span><br><span class="line">    */</span><br><span class="line">    password = salt + password;</span><br><span class="line">    byte[] bytes = <span class="type">System</span>.<span class="type">Text</span>.<span class="type">Encoding</span>.<span class="type">UTF8</span>.<span class="type">GetBytes</span>(password);</span><br><span class="line">    byte[] <span class="literal">result</span>;</span><br><span class="line">    <span class="type">System</span>.<span class="type">Security</span>.<span class="type">Cryptography</span>.<span class="type">SHA512</span> shaM = new <span class="type">System</span>.<span class="type">Security</span>.<span class="type">Cryptography</span>.<span class="type">SHA512Managed</span>();</span><br><span class="line">    <span class="literal">result</span> = shaM.<span class="type">ComputeHash</span>(bytes);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i++ &lt; <span class="number">512</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="literal">result</span> = shaM.<span class="type">ComputeHash</span>(<span class="literal">result</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    shaM.<span class="type">Clear</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Convert</span>.<span class="type">ToBase64String</span>(<span class="literal">result</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="安全性">安全性</h2><p>对于任何移动应用来说。因为客户端代码运行在一台移动设备上，因此可能会有不受信任的客户强行修改代码并发起恶意的请求。选择正确的方式来保护你的应用非常重要，但是正确的方式取决于你的应用，以及应用存储的数据。</p>
<p>我们提供多种方式使用权限控制来获得安全性。如果你有关于任何保护你应用安全的最佳方式的问题，我们都鼓励你联系我们的客户支持。</p>
<h3 id="SSL_加密传输">SSL 加密传输</h3><p>首先，我们所有的 API 请求都通过 <a href="http://zh.wikipedia.org/wiki/%E5%AE%89%E5%85%A8%E5%A5%97%E6%8E%A5%E5%B1%82" target="_blank" rel="external">SSL加密传输</a>，保证传输过程中的数据安全性和可靠性。</p>
<h3 id="对象级别的权限">对象级别的权限</h3><p><img src="images/acl.png" alt="image"></p>
<p>最灵活的保护你应用数据安全的方式是通过访问控制列表（Access Control List），通常简称为 ACL 机制。ACL 背后的思想是为每个对象关联一系列 User 或者 Role，这些 User 或者 Role 包含了特定的权限。一个 User 必须拥有读权限（或者属于一个拥有读权限的 Role）才可以获取一个对象的数据，同时，一个 User 需要写权限（或者属于一个拥有写权限的 Role）才可以更改或者删除一个对象。</p>
<p>大多数应用都通过 ACL 来规范它们的访问模式。例如：</p>
<ul>
<li>对于私有数据，read 和 write 都可以限制为对象拥有者（owner）所有。</li>
<li>一个信息公告板的帖子，作者和属于「版主」角色的成员可拥有 write 权限，通常 public 允许 read 访问（也就是允许公开读取帖子）。</li>
<li>高优先级用户或者开发者创建的数据，例如全局的每日广播消息，可以让 public拥有 read 许可，但是严格限制 write 权限给「管理员」角色。</li>
<li>一条从一个用户发往另一个用户的消息，可以将读和写的访问许可限制到关联的这两个用户。</li>
</ul>
<p>使用 LeanCloud SDK，你可以设置一个默认的 ACL 给客户端所有创建的对象。如果你同时开启自动匿名用户创建的功能，你可以保证你的数据拥有严格限制到每个单独用户的ACL权限。请仔细阅读 iOS 和 Android 指南关于选择默认安全策略的章节。</p>
<p>通过设置 Master Key的 REST API，你还是可以绕过 ACL 限制执行任何操作。这可以让开发者更容易地管理数据。例如，你可以通过 REST API 删除一条私有消息，哪怕这条消息设置为拥有者私有。</p>
<p>代码中如何使用 ACL，请阅读相应的 ACL 文档。</p>
<h3 id="列级别的权限">列级别的权限</h3><p>这个概念比较简单，通过编辑数据管理页面某个 Class 的列属性，某一列数据可以设置为「只读」。对于 <code>_User</code> 数据表，还可以设置为 「只限当前用户读写」，即只能当前登录的用户读写自己的数据。</p>
<p>某一列的数据还可以设置为 「客户端不可见」。设置了之后，当客户端发起查询的时候，返回的结果将不包含相关字段。比如，匿名发帖的应用，你仍然希望发帖的时候，也记录下真实的作者，但不希望将此信息返回给客户端，所以，这时候就可以设置作者字段为「客户端不可见」。</p>
<h3 id="Class_级别的权限">Class 级别的权限</h3><p><img src="images/cla_permission.png" alt="image"></p>
<p>在一些情况下，设置整个class允许的权限是一种更自然的方式。例如，你可能想设置整个 Class 只读，或者只写。</p>
<p>为了简单地做到这一点，我们让你可以设置每个 Class 允许的操作。为了访问这些设置，请进入数据管理平台，选择一个 Class，并点击右侧菜单中的 <strong>其他</strong> 下拉框找到权限设置。</p>
<p>你可以为选中的 Class 禁止客户端执行下列操作的能力：</p>
<ul>
<li>GET - 通过objectId获取对象。</li>
<li>Find - 发起一次对象列表查询。</li>
<li>Update - 保存一个已经存在并且被修改的对象。</li>
<li>Create - 保存一个从未创建过的新对象。</li>
<li>Delete - 删除一个对象。</li>
<li>Add fields - 添加新字段到class</li>
</ul>
<h3 id="App_安全选项">App 安全选项</h3><p>进入应用设置菜单，在左侧菜单可以看到 <strong>应用选项设置</strong>：</p>
<p>点击选中或者取消选中就可以启用或者关闭这些选项，大概介绍下功能：</p>
<ul>
<li><strong>启用注册用户邮箱验证</strong>：是否要求你应用里的注册用户验证邮箱， 默认不启用。如果启用，每次用户注册，都会发送一封邮件到用户提供的邮箱，要求认证，具体请看开发指南里的用户一节。</li>
<li><strong>禁止客户端创建 Class</strong>：是否禁止客户端动态创建 Class。如果启用，那么通过 SDK 或者 REST API 都没办法动态创建不存在的 Class 了，这种情况下只能通过我们的数据管理平台来创建新 Class。</li>
<li><strong>禁止消息推送</strong>：是否彻底禁止消息推送。如果启用，任何消息推送的调用都不允许。</li>
<li><strong>禁止从客户端推送消息</strong>：是否禁止从客户端推送消息，如果启用，这那么通过 SDK 或者 REST API 都被禁止推送消息，只能通过我们管理平台提供的推送界面来推送消息。</li>
</ul>
<h2 id="第三方加密">第三方加密</h2><p>对于 Android 应用，除了代码混淆之外，还可以使用第三方加密工具，隐藏 classes.dex，通过动态加载的方法进一步提高应用的安全性。下面我们简单介绍一下爱加密。</p>
<h3 id="爱加密">爱加密</h3><p><a href="http://www.ijiami.cn/" target="_blank" rel="external">爱加密</a> 是专为移动开发者提供安全服务的一个平台，可解决开发者面临的应用安全问题。加密的步骤很简单：</p>
<ol>
<li>提交应用；</li>
<li>下载加密后的 apk 文件；</li>
<li>下载爱加密提供的签名工具，对应用进行签名。</li>
</ol>
<p>相关步骤还可以见下面的截图。</p>
<p>申请账号，提交应用，下载签名工具：</p>
<p><img src="images/ijiami_2.png" alt="image"></p>
<p>加密后重新签名：</p>
<p><img src="images/ijiami_1.png" alt="image"></p>
<p>这样得到的 apk 文件，普通的反编译之后得到的是，</p>
<p><img src="images/decompile.png" alt="image"></p>
<p>可以看到，代码被隐藏起来了，应用被破解的难度大幅增加了。</p>
<p>我们一直努力提供更多功能给开发者来保护你的应用，也希望大家持续地给我们反馈，感谢。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/cloud_code_faq/" itemprop="url">
                云引擎常见问题和解答
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/cloud_code_faq/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/cloud_code_faq/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="云引擎常见问题和解答">云引擎常见问题和解答</h1><h2 id="如何判断当前是测试环境还是生产环境？">如何判断当前是测试环境还是生产环境？</h2><p>请参考文档 <a href="/leanengine_guide-node.html#运行环境区分">云引擎开发指南 Node.js</a> / <a href="/leanengine_guide-python.html#运行环境区分">Python</a> - 运行环境区分。</p>
<h2 id="怎么添加第三方模块">怎么添加第三方模块</h2><p>云引擎 2.0 开始支持添加第三方模块（请参考 <a href="leanengine_guide-cloudcode.html#云代码_2_0_版">云引擎指南 - 升级到 2.0</a>），只需要像普通的 Node.js 项目那样，在项目根目录创建文件 <code>package.json</code>，下面是一个范例：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">name</span>": <span class="value"><span class="string">"cloud-engine-test"</span></span>,</span><br><span class="line">  "<span class="attribute">description</span>": <span class="value"><span class="string">"Cloud Engine test project."</span></span>,</span><br><span class="line">  "<span class="attribute">version</span>": <span class="value"><span class="string">"0.0.1"</span></span>,</span><br><span class="line">  "<span class="attribute">private</span>": <span class="value"><span class="literal">true</span></span>,</span><br><span class="line">  "<span class="attribute">dependencies</span>": <span class="value">&#123;</span><br><span class="line">    "<span class="attribute">async</span>": <span class="value"><span class="string">"0.9.0"</span></span>,</span><br><span class="line">    "<span class="attribute">moment</span>": <span class="value"><span class="string">"2.9.0"</span></span><br><span class="line">  </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p><code>dependencies</code> 内的内容表明了该项目依赖的三方模块（比如示例中的 <code>async</code> 和 <code>moment</code>）。</p>
<p>然后在项目根目录执行：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span></span><br></pre></td></tr></table></figure>
<p>即可下载相关三方包到 <code>node_modules</code> 目录。</p>
<p>然后即可在代码中引入三方包：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">async</span> = <span class="built_in">require</span>(<span class="string">'async'</span>);</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：命令行工具部署时是不会上传 <code>node_modules</code> 目录，因为云代码服务器会根据 <code>package.json</code> 的内容自动下载三方包。所以也建议将 <code>node_modules</code> 目录添加到 <code>.gitignore</code> 中，使其不加入版本控制。</p>
<h2 id="Maximum_call_stack_size_exceeded_如何解决？">Maximum call stack size exceeded 如何解决？</h2><p><code>AV.Object.extend</code> 产生的对象需要作为全局变量保存（即定义在 AV.Cloud.define 方法之外）。因为每调用一次，就会产生一个新的类的实例，并且和之前创建的实例形成一个链表。调用次数过多后（几万次）就会堆栈溢出。如果你的应用时不时出现 <strong>Maximum call stack size exceeded</strong> 错误，请确认是否误用了 <code>AV.Object.extend</code> 方法。</p>
<p>我们在 <a href="./js_guide.html#AV_Object">JavaScript 指南 - AV.Object</a> 章节中也进行了描述。</p>
<h2 id="目前支持哪些语言？">目前支持哪些语言？</h2><p>我们提供了 JavaScript SDK，支持 Node.js 和 Python 环境，未来可能会引入 PHP 等其他语言。</p>
<h2 id="Web_Hosting_备案如何操作？">Web Hosting 备案如何操作？</h2><p>只有网站类的才需要备案，并且在主域名已备案的情况下，二级子域名不需要备案。 如果主站需要托管在我们这边，且还没有备案过，我们可以协助你完成备案，请参考文档 <a href="leanengine_guide-node.html#绑定独立域名">绑定独立域名 Node.js</a> / <a href="leanengine_guide-python.html#绑定独立域名">Python</a>。</p>
<h2 id="调用云引擎方法如何收费？">调用云引擎方法如何收费？</h2><p>现在云引擎本身不收费，云引擎中如果有 LeanCloud 的存储等 API 调用，按 API 收费策略收费。</p>
<h2 id="「定义函数」和「Git_部署」可以混用吗？">「定义函数」和「Git 部署」可以混用吗？</h2><p>「定于函数」的产生是为了方便大家初次体验云引擎，或者只是需要一些简单 hook 方法的应用使用。我们的实现方式就是把定义的函数拼接起来，生成一个云引擎项目然后部署。</p>
<p>所以可以认为「定义函数」和 「git 部署」最终是一样的，都是一个完整的项目。<br>是一个单独功能，可以不用使用基础包，git 等工具快速的生成和编辑云引擎。<br>当然，你也可以使用基础包，自己写代码并部署项目。<br>这两条路是分开的，任何一个部署，就会导致另一种方式失效掉。</p>
<h2 id="为什么查询_include_没有生效？">为什么查询 include 没有生效？</h2><p>以 JavaScript 云引擎为例子，很多时候，经常会定义一个云函数，在里面使用 <code>AV.Query</code> 查询一张表，并 include 其中一个 pointer 类型的字段，然后返回给客户端:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AV.Cloud.define(<span class="string">'querySomething'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> query = <span class="keyword">new</span> AV.Query(<span class="string">'Something'</span>);</span><br><span class="line">  <span class="comment">//假设 user 是 Something 表的一个 Pointer 列。</span></span><br><span class="line">  query.include(<span class="string">'user'</span>);</span><br><span class="line">  <span class="comment">//……其他条件或者逻辑……</span></span><br><span class="line">  query.find().then(<span class="function"><span class="keyword">function</span>(<span class="params">results</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//返回查询结果给客户端</span></span><br><span class="line">    res.success(results);</span><br><span class="line">  &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//返回错误给客户端</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>你会看到返回的结果里， user 仍然是 pointer 类型，似乎 include 没有生效？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> result: [</span><br><span class="line">   &#123;</span><br><span class="line">     ……Something 其他字段</span><br><span class="line">     "user": &#123;</span><br><span class="line">       "className": "_User",</span><br><span class="line">       "__type": "Pointer",</span><br><span class="line">       "objectId": "abcdefg"</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ……</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这其实是因为 <code>res.success(results)</code> 会调用到 <code>AV.Object#toJSON</code> 方法，将结果序列化为 JSON 对象返回给客户端。<br>而 <code>AV.Object#toJSON</code> 方法为了防止循环引用，当遇到属性是 Pointer 类型会返回 pointer 元信息，不会将 include 的其他字段添加进去。<br>因此，你需要主动将该字段进行 JSON 序列化，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">query.find().then(<span class="function"><span class="keyword">function</span>(<span class="params">results</span>) </span>&#123;</span><br><span class="line">   <span class="comment">//主动序列化 json 列。</span></span><br><span class="line">   results.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">     result.set(<span class="string">'user'</span>, result.get(<span class="string">'user'</span>) ?  result.get(<span class="string">'user'</span>).toJSON() : <span class="literal">null</span>);</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="comment">//再返回结果</span></span><br><span class="line">   res.success(results);</span><br><span class="line"> &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">   <span class="comment">//返回错误给客户端</span></span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/cql_guide/" itemprop="url">
                Cloud Query Language
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/cql_guide/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/cql_guide/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="Cloud_Query_Language_详细指南">Cloud Query Language 详细指南</h1><p>Cloud Query Language（简称 CQL） 是 LeanCloud 为查询 API 定制的一套类似 SQL 查询语法的子集和变种，主要目的是降低大家学习 LeanCloud 查询的 API 的成本，可以使用传统的 SQL 语法来查询 LeanCloud 应用内的数据。</p>
<p>本文档将详细介绍 CQL 的语法和常见用法。</p>
<h2 id="介绍及基本语法">介绍及基本语法</h2><p>最基本的一个查询某个 class 下的 100 条数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore</span></span><br></pre></td></tr></table></figure>
<p>等价于（以 Android 为例子）:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AVQuery&lt;AVObject&gt; query = <span class="keyword">new</span> AVQuery&lt;AVObject&gt;(<span class="string">"GameScore"</span>);</span><br><span class="line">List&lt;AVObject&gt; avObjects = query.find()</span><br></pre></td></tr></table></figure>
<p><code>select</code> 一个完整的语法形式类似这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> [查询字段列表，逗号隔开] <span class="keyword">from</span> [<span class="keyword">class</span> 名称]</span><br><span class="line">   [<span class="keyword">where</span> [条件列表]</span><br><span class="line">   [<span class="keyword">limit</span> [<span class="keyword">skip</span>],<span class="keyword">limit</span></span><br><span class="line">   [<span class="keyword">order</span> <span class="keyword">by</span> [排序字段列表] [<span class="keyword">asc</span> |<span class="keyword">desc</span>]]]]</span></span><br></pre></td></tr></table></figure>
<p>一些小例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//查询结果只包含 name,score 以及内置字段(objectId,createdAt等)</span><br><span class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">name</span>,score <span class="keyword">from</span> GameScore</span><br><span class="line"></span><br><span class="line">//根据 <span class="keyword">name</span> 查找</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'dennis'</span></span><br><span class="line"></span><br><span class="line">//根据 <span class="keyword">name</span> 和 score 同时查找</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">is</span> <span class="keyword">exists</span> <span class="keyword">and</span> score &gt; <span class="number">80</span> <span class="keyword">and</span> score &lt;= <span class="number">100</span></span><br><span class="line"></span><br><span class="line">//分页查找，从第 <span class="number">100</span> 条开始向后查找 <span class="number">10</span> 条数据</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">limit</span> <span class="number">100</span>,<span class="number">10</span></span><br><span class="line"></span><br><span class="line">//根据 score 和 <span class="keyword">name</span> 排序</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">order</span> <span class="keyword">by</span> score,+<span class="keyword">name</span> <span class="keyword">desc</span></span></span><br></pre></td></tr></table></figure>
<h2 id="查询条件">查询条件</h2><p><code>where</code> 之后的查询条件基本跟 SQL 语法相似，比如支持 <code>or</code> 和 <code>and</code> 的复合查询，支持 <code>=</code>、<code>!=</code>、<code>&lt;</code>、<code>&lt;</code> 等比较运算符，支持子查询、in 查询等。详细解释如下。</p>
<h3 id="基本查询">基本查询</h3><p>查询指定信息的对象，用 <code>=</code> 比较符：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'dennis'</span></span></span><br></pre></td></tr></table></figure>
<p>查询不等于指定信息的对象：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span>!=<span class="string">'dennis'</span></span></span><br></pre></td></tr></table></figure>
<p>也可以用 <code>&lt;&gt;</code> 运算符来表示不等于。</p>
<p>比较日期，使用 <code>date</code> 函数来转换，比如查询特定时间之前创建的对象：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> createdAt &lt; <span class="built_in">date</span>(<span class="string">'2011-08-20T02:06:57.931Z'</span>)</span></span><br></pre></td></tr></table></figure>
<p>date 函数接收的日期格式必须是 <code>2011-08-20T02:06:57.931Z</code> 的 UTC 时间。更多内置函数请看最后的 <a href="#内置函数">内置函数</a> 部分。</p>
<p>一些常见的查询运算符：</p>
<table><br>  <tr><th>Key</th><th>Operation</th></tr><br>  <tr><td>&lt;</td><td>小于</td></tr><br>  <tr><td>&lt;=</td><td>小于等于</td></tr><br>  <tr><td>&gt;</td><td>大于</td></tr><br>  <tr><td>&gt;=</td><td>大于等于</td></tr><br>  <tr><td> != 或者 &lt;&gt;</td><td>不等于</td></tr><br>  <tr><td>[not] like</td><td>模糊查询</td></tr><br>  <tr><td>[not] regexp</td><td>正则匹配</td></tr><br>  <tr><td>[not] in(子查询或者数组)</td><td>包含或者不包含</td></tr><br>  <tr><td>is [not] exists</td><td>这个 Key 有值或者不存在值</td></tr><br></table>

<p>比较运算符可以用在日期、字符串、数字甚至对象上。</p>
<h4 id="模糊查询">模糊查询</h4><p>模糊查询可以使用 <code>like</code>，比如查询名字以 dennis 开头的对象。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'dennis%'</span></span></span><br></pre></td></tr></table></figure>
<p><code>%</code> 表示模糊匹配的位置占位符。</p>
<p>like 本质上是转成 <code>regexp</code> 的正则匹配查询，因此上面的例子还可以写成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span> regexp <span class="string">'dennis.*'</span></span></span><br></pre></td></tr></table></figure>
<p>否定形式，查询名字不以 dennis 开头的对象：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">not</span> <span class="keyword">like</span> <span class="string">'dennis%'</span></span><br><span class="line">或者</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">not</span> regexp <span class="string">'dennis.*'</span></span></span><br></pre></td></tr></table></figure>
<p>正则匹配的效率一般，类似这种全文搜索请求，我们都推荐采用 <a href="app_search_guide.html">应用内全文搜索</a>。</p>
<h5 id="值是否存在查询">值是否存在查询</h5><p>只返回 <code>level</code> 字段值存在的对象：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">level</span> <span class="keyword">is</span> <span class="keyword">exists</span></span></span><br></pre></td></tr></table></figure>
<p>反之，使用 <code>is not exists</code>。</p>
<h3 id="数组查询">数组查询</h3><p>假设 <code>scores</code> 字段是一个数组，我们想查询分数里有 100 的成绩列表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> scores=<span class="number">100</span></span></span><br></pre></td></tr></table></figure>
<p>如果想查找分数<strong>只有</strong>两个 100 分的成绩：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> scores all (<span class="number">100</span>,<span class="number">100</span>)</span></span><br></pre></td></tr></table></figure>
<p><code>all</code> 表示数组完全匹配。</p>
<p>查询数组长度为特定值的对象：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="function"><span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="title">size</span>(<span class="params">scores</span>) </span>= <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>数组长度查询仅支持等于号，不支持大小和小于等其他比较运算符。</p>
<h3 id="子查询">子查询</h3><p>使用 <code>in</code> 来做子查询，后面跟的可以是一个列表，例如查询名字是 dennis、catty 和 green 三个玩家的成绩：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">in</span> (<span class="string">'dennis'</span>,<span class="string">'catty'</span>,<span class="string">'green'</span>)</span></span><br></pre></td></tr></table></figure>
<p>当然，如果想查询的不在列表里，那可以使用 <code>not in</code>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">'dennis'</span>,<span class="string">'catty'</span>,<span class="string">'green'</span>)</span></span><br></pre></td></tr></table></figure>
<p>in 后面还可以是一个子查询，比如查询玩家信息，并且成绩大于 80 分的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> Player <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> GameScore <span class="keyword">where</span> score&gt;<span class="number">80</span>)</span></span><br></pre></td></tr></table></figure>
<p>注意子查询必须指定查询的字段名称是 <code>select name</code>。</p>
<p>子查询另一种常见形式是使用 <code>=</code> 或 <code>!=</code> 跟一条查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> Player <span class="keyword">where</span> <span class="keyword">name</span> =(<span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> GameScore <span class="keyword">where</span> score&gt;<span class="number">80</span>)</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> Player <span class="keyword">where</span> <span class="keyword">name</span> !=(<span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> GameScore <span class="keyword">where</span> score&lt;=<span class="number">80</span>)</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：子查询的语句也受上限 1000 条记录的限制。</strong></p>
<h3 id="地理位置信息查询">地理位置信息查询</h3><p>可以通过 CQL 进行地理位置信息查询，比如我想查询自己附近的玩家（从近到远排序），假设 <code>location</code> 字段是 GeoPoint 类型：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> Player <span class="keyword">where</span> location near [<span class="number">116.4</span>, <span class="number">39.9</span>]</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>[116.4, 39.9]</code> 是经纬度坐标。也可以使用 <code>geopoint</code> 函数来创建：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> Player <span class="keyword">where</span> location near geopoint(<span class="number">116.4</span>, <span class="number">39.9</span>)</span></span><br></pre></td></tr></table></figure>
<p>只有在地理位置信息查询里才可以使用 <code>[longitude, latitude]</code> 这样的语法。在其他查询里将被作为数组类型。</p>
<p>为了限定搜索的最大距离，还可以使用 <code>max [距离]</code> 来限定，比如限定在 1 公里内：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> Player <span class="keyword">where</span> location near geopoint(<span class="number">116.4</span>, <span class="number">39.9</span>) <span class="keyword">max</span> <span class="number">1</span> km</span></span><br></pre></td></tr></table></figure>
<p>距离长度的其他单位包括 <code>miles</code>（英里）和 <code>radians</code>（弧度），如果不提供明确的单位，默认是<strong>弧度</strong>。</p>
<p>通过 <code>min [距离]</code> 还可以限定最小距离：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> Player <span class="keyword">where</span> location near geopoint(<span class="number">116.4</span>, <span class="number">39.9</span>) <span class="keyword">min</span> <span class="number">0.5</span> km</span></span><br></pre></td></tr></table></figure>
<p><code>min</code> 和 <code>max</code> 同时限定的时候，<code>min</code> 必须出现在 <code>max</code> 之前：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> Player <span class="keyword">where</span> location near geopoint(<span class="number">116.4</span>, <span class="number">39.9</span>) <span class="keyword">min</span> <span class="number">0.5</span> km <span class="keyword">max</span> <span class="number">1</span> km</span></span><br></pre></td></tr></table></figure>
<p>如果想查询某个矩形框内的对象，可以使用 <code>within [西南坐标] and [东北坐标]</code> 的语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> Player <span class="keyword">where</span> location <span class="keyword">within</span> [<span class="number">116.33</span>, <span class="number">39.97</span>] <span class="keyword">and</span> [<span class="number">116.37</span>, <span class="number">39.99</span>]</span></span><br></pre></td></tr></table></figure>
<h3 id="查询个数(count)">查询个数(count)</h3><p>使用 <code>count</code> 查询来返回符合查询条件的数目，比如查询整张表的记录数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> GameScore</span></span><br></pre></td></tr></table></figure>
<p><code>count</code> 不支持 <code>distinct</code> 等语法。仅限 <code>count(*)</code> 和 <code>count(objectId)</code>。</p>
<p>查询分数大于 60 并且小于等于 80 的成绩数目：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> GameScore <span class="keyword">where</span> score&gt;<span class="number">60</span> <span class="keyword">and</span> score&lt;=<span class="number">80</span></span></span><br></pre></td></tr></table></figure>
<p>查询个数的同时可以返回对象：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">count</span>(*),* <span class="keyword">from</span> GameScore</span></span><br></pre></td></tr></table></figure>
<p>也可以返回特定的字段：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">count</span>(*),<span class="keyword">name</span> <span class="keyword">from</span> GameScore</span></span><br></pre></td></tr></table></figure>
<h3 id="关系查询">关系查询</h3><p>有几种方式来查询对象之间的关系数据。如果你想获取对象，而这个对象的一个字段对应了另一个对象， 你可以用一个 where 查询，自己构造一个 Pointer，和其他数据类型一样。</p>
<p>举例说，如果每一个 Comment 有一个 Post 对象在它的 post 字段上（Pointer 类型），你可以对一个 post 取得所有 comment：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">Comment</span> <span class="keyword">where</span> post=pointer(<span class="string">'Post'</span>,<span class="string">'51e3a359e4b015ead4d95ddc'</span>)</span></span><br></pre></td></tr></table></figure>
<p><code>pointer</code> 函数接收 className 和 objectId。</p>
<p>如果你想获取对象, 这个对象的一个字段指向的对象（必须是 Pointer）是符合另一个查询的， 你可以使用 in 查询。注意默认的 limit 是 100 而且最大的 limit 是 1000，这个限制同样适用于内部的查询，所以对于较大的数据集你可能需要细心地构建查询来获得期望的行为。举例说，假设你有一个 Post 类和一个 Comment 类，每个 Comment 都有一个指向它的 Post 的 Pointer，你可以找到对于有图片的 Post 的 Comment：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">Comment</span> <span class="keyword">where</span> post <span class="keyword">in</span> (<span class="keyword">select</span> * <span class="keyword">from</span> Post <span class="keyword">where</span> image <span class="keyword">is</span> <span class="keyword">exists</span>)</span></span><br></pre></td></tr></table></figure>
<p>如果 Post 下面有一个 key 是 Relation 类型，并且叫做 likes，存储了喜欢这个 Post 的 User。你可以找到这些 user，他们都 like 过同一个指定的 post：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> _User <span class="keyword">where</span> related likes <span class="keyword">to</span> pointer(<span class="string">'Post'</span>, <span class="string">'51e3a359e4b015ead4d95ddc'</span>)</span></span><br></pre></td></tr></table></figure>
<p>基本的查询形式是 <code>releated &lt;key&gt; to &lt;pointer&gt;</code>。</p>
<p>如果某个字段是 Pointer，默认查询的时候，只会返回 <code>{__type: &#39;Pointer&#39;, objectId: &#39;objectId&#39;, className:&#39;Post&#39;}</code> 这些基本信息，如果希望同时将这个对象的其他信息查询下来，可以使用 include，比如查询 Comment 同时将 Post 带下来：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">include</span> post, * <span class="keyword">from</span> <span class="keyword">Comment</span></span></span><br></pre></td></tr></table></figure>
<p>在 select 中采用 <code>include &lt;key&gt;</code> 就可以将某个 Pointer 字段关联查询出来。多个字段要多次 include：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">include</span> post,<span class="keyword">include</span> author <span class="keyword">from</span> <span class="keyword">Comment</span></span></span><br></pre></td></tr></table></figure>
<p>同样，还可以支持嵌套的 include 查询，比如 Post 里还有一个 Pointer 指向 Category：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">include</span> post.<span class="keyword">category</span>,* <span class="keyword">from</span> <span class="keyword">Comment</span></span></span><br></pre></td></tr></table></figure>
<h3 id="复合查询">复合查询</h3><p>你可以使用 <code>and</code> 和 <code>or</code> 来做符合查询，例如查询分数在 80 到 100 之间，可以用 <code>and</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> score&gt;<span class="number">80</span> <span class="keyword">and</span> score&lt;=<span class="number">100</span></span></span><br></pre></td></tr></table></figure>
<p>再加个条件，或者分数为 0 分的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> score&gt;<span class="number">80</span> <span class="keyword">and</span> score&lt;=<span class="number">100</span> <span class="keyword">or</span> score=<span class="number">0</span></span></span><br></pre></td></tr></table></figure>
<p><code>and</code> 的优先级高于 <code>or</code>，因此上面的查询也可以用括号来明确地表示这种优先级：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> (score&gt;<span class="number">80</span> <span class="keyword">and</span> score&lt;=<span class="number">100</span>) <span class="keyword">or</span> score=<span class="number">0</span></span></span><br></pre></td></tr></table></figure>
<h2 id="限定返回值">限定返回值</h2><p>通过 <code>limit</code> 语句来限定返回结果大小，比如限定返回 100 个：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">Comment</span> <span class="keyword">limit</span> <span class="number">100</span></span></span><br></pre></td></tr></table></figure>
<p>可以设定从第 m+1 个元素开始，例如从第 101 个元素（包含）开始往后取 10 个：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">Comment</span> <span class="keyword">limit</span> <span class="number">100</span>,<span class="number">10</span></span></span><br></pre></td></tr></table></figure>
<p>这个形式跟 MySQL 是类似的。</p>
<h3 id="占位符">占位符</h3><p>查询条件和 limit 子句还支持占位符，也就是可以用问号 <code>?</code> 替代值，值的列表通过 SDK 提供的方法传入，具体请参考各 SDK 用法，例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span>=? <span class="keyword">and</span> score&gt;? <span class="keyword">limit</span> ?,?</span></span><br></pre></td></tr></table></figure>
<p>占位符支持所有 LeanCloud 平台上的有效类型，复杂类型（如日期、GeoPoint）要求以 <a href="./rest_api.html#数据类型">REST API</a> 文档说明的 JSON 格式来提供。</p>
<p><strong>我们推荐使用占位符的方式来使用 CQL，查询语句可以通过预编译被缓存起来，降低 CQL 的转换开销。</strong></p>
<h2 id="排序">排序</h2><p>通过 <code>order</code> 语句来排序，<code>order</code> 语句只能出现在最后，不能在 <code>where</code> 和 <code>limit</code> 之前。</p>
<p>例如按照分数倒序排（分数高的前）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span></span></span><br></pre></td></tr></table></figure>
<p>也可以写成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">order</span> <span class="keyword">by</span> -score</span></span><br></pre></td></tr></table></figure>
<p>加号表示升序，减号表示降序。</p>
<p>多个字段组合排序，例如分数高的前，名字相同的「更小」的在前（字母顺序）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">order</span> <span class="keyword">by</span> -score,<span class="keyword">name</span></span></span><br></pre></td></tr></table></figure>
<p>同样的语句可以写成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">order</span> <span class="keyword">by</span> score,+<span class="keyword">name</span> <span class="keyword">desc</span></span><br><span class="line">或者</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">order</span> <span class="keyword">by</span> -score,<span class="keyword">name</span> <span class="keyword">asc</span></span></span><br></pre></td></tr></table></figure>
<p>没有写上明确的加号或者减号的字段，将根据最后的 <code>desc</code> 或者 <code>asc</code> 来决定采用升序还是降序。</p>
<h2 id="内置函数">内置函数</h2><p>CQL 提供了一些内置函数来方便地创建 pointer、geopoint 等类型：</p>
<table><br>  <tr><th>Name</th><th>Operation</th></tr><br>  <tr><td>date(‘YYYY-MM-DDTHH:MM:SS.MMMMZ’)</td><td>创建日期类型</td></tr><br>  <tr><td>pointer(className, objectId)</td><td>创建 Pointer</td></tr><br>  <tr><td>geopoint(经度, 纬度)</td><td>创建 GeoPoint</td></tr><br>  <tr><td>file(objectId)</td><td>创建 file 类型</td></tr><br>  <tr><td>base64(base64编码字符串)</td><td>创建 Bytes 类型</td></tr><br>  <tr><td>current_timestamp()</td><td>创建当前日期</td></tr><br></table>

<p>如果不使用这些函数，你也使用 <a href="./rest_api.html#数据类型">REST API 文档</a> 定义的 JSON 对象来创建特定类型，例如 Pointer：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">Comment</span> <span class="keyword">where</span> post=</span><br><span class="line">  &#123;className:<span class="string">'Post'</span>, objectId:<span class="string">'51e3a334e4b0b3eb44adbe1a'</span>,__type:<span class="string">'Pointer'</span>&#125;</span></span><br></pre></td></tr></table></figure>
<p>当然这样写就相对繁琐了。</p>
<h2 id="性能和建议">性能和建议</h2><p>CQL 最终还是转换成 <a href="./rest_api.html">REST API</a> 里查询部分提到的各种 where 条件，因为多了一层转换，理论上会比直接使用 <code>where</code> 查询慢一点。并且 CQL 对长度有所限制，要求在 4096 字节以内。</p>
<p>此外，我们推荐查询语句都采用占位符的方式，使用占位符的查询语句将有机会被缓存复用，避免重复解释的开销。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/android_start/" itemprop="url">
                下载 Android SDK
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/android_start/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/android_start/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><a id="link" class="btn btn-default" href="sdk_down.html">下载 Android SDK</a></p>

<p>下载 SDK，将下载后的文件解压缩后的所有 jar 文件放入 Android 项目的 <strong>libs</strong> 目录。如果你们的项目没有 <b>libs</b> 目录，那么就在项目的根目录下创建一个，通过右键点击项目 Project，选择 <strong>New</strong>，接下来点击 <strong>Folder</strong> 菜单即可创建新目录。</p>
<p>添加下列 <code>import</code> 语句到你的 Application 或主 Activity 类：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">import</span> <span class="tag">com</span><span class="class">.avos</span><span class="class">.avoscloud</span><span class="class">.AVOSCloud</span>;</span><br><span class="line"><span class="tag">import</span> <span class="tag">com</span><span class="class">.avos</span><span class="class">.avoscloud</span><span class="class">.AVAnalytics</span>;</span><br></pre></td></tr></table></figure>
<p>在 Application 的 <code>onCreate</code> 方法调用 <code>AVOSCloud.initialize</code> 来设置您应用的 Application ID 和 Key：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果使用美国节点，请加上这行代码 AVOSCloud.useAVCloudUS();</span></span><br><span class="line">    AVOSCloud.initialize(<span class="keyword">this</span>, <span class="string">"&#123;&#123;appid&#125;&#125;"</span>, <span class="string">"&#123;&#123;appkey&#125;&#125;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建应用后，可以在 <a href="/app.html?appid=#/key">控制台 - 应用设置</a> 里面找到应用对应的 id 和 key。</p>
<p>同时，你的应用需要请求 <code>INTERNET</code> 和 <code>ACCESS_NETWORK_STATE</code> 权限，如果没有设置，请添加下列两行到你的 <code>AndroidManifest.xml</code> 文件里的 <code>&lt;application&gt;</code> 标签前：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:<span class="property">name</span>=<span class="string">"android.permission.INTERNET"</span> /&gt;</span><br><span class="line">&lt;uses-permission android:<span class="property">name</span>=<span class="string">"android.permission.ACCESS_NETWORK_STATE"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>如果你想跟踪统计应用的打开情况，添加下列代码到你的主 <code>Activity</code> 的 <code>onCreate</code> 方法：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">AVAnalytics</span><span class="class">.trackAppOpened</span>(<span class="tag">getIntent</span>());</span><br></pre></td></tr></table></figure>
<p>接下来可以尝试测试一段代码，拷贝下列代码到你的 app 里，比如放到 <code>Application.onCreate</code> 方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AVObject <span class="built_in">test</span>Object = new AVObject(<span class="string">"TestObject"</span>);</span><br><span class="line"><span class="built_in">test</span>Object.put(<span class="string">"foo"</span>, <span class="string">"bar"</span>);</span><br><span class="line"><span class="built_in">test</span>Object.saveInBackground();</span><br></pre></td></tr></table></figure>
<p>运行你的 app。一个类 <code>TestObject</code> 的新对象将被发送到 LeanCloud 并保存下来。当你做完这一切，访问 <a href="/data.html?appid=#/TestObject">控制台 - 数据管理</a> 可以看到上面创建的 <code>TestObject</code> 的相关数据。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/android_statistics/" itemprop="url">
                Android 统计 SDK 开发指南
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/android_statistics/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/android_statistics/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="Android_统计_SDK_开发指南">Android 统计 SDK 开发指南</h1><h2 id="安装与初始化">安装与初始化</h2><p>首先在 <a href="https://leancloud.cn/applist.html#/apps" target="_blank" rel="external">控制台</a> 上创建新的应用，然后 <a href="sdk_down.html">下载 LeanCloud Android SDK</a> 以及相应的 Demo。</p>
<h3 id="导入_SDK">导入 SDK</h3><p>除了必须的 avoscloud.jar 外，你还需要额外的导入 avosstatistics.jar。<br>请将下载的 jar 包放到 libs 目录下，以便你的 IDE（Eclipse 或者 Intellij IDEA 等)可以正常识别导入的 jar 包。如以下图片所示：</p>
<p><img src="images/android_statistics_ide.png" alt="image"></p>
<h3 id="配置_AndroidManifest-xml_文件">配置 AndroidManifest.xml 文件</h3><p>请务必确保你的应用拥有如下权限：</p>
<ul>
<li><code>android.permission.INTERNET</code><br><br>向 LeanCloud 的统计服务器发送用户分析数据。</li>
<li><code>android.permission.READ_PHONE_STATE</code><br><br><code>android.permission.ACCESS_WIFI_STATE</code><br><br>这两个权限是为了获取用户手机的 IMEI 以及 WiFi 的 Mac 地址，用来唯一的标识用户。</li>
<li><code>android.permission.ACCESS_NETWORK_STATE</code><br><br>检测网络状态。</li>
<li><code>android.permission.READ_LOGS</code><br><br>获取客户端 crash log。通过将 crash log 汇报到服务器上，你可以了解你的应用 crash 的原因以及次数。</li>
<li><code>android.permission.WRITE_EXTERNAL_STORAGE</code><br><br>保存离线报告的缓存数据。</li>
</ul>
<p>示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">manifest</span> <span class="attribute">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">application</span> <span class="attribute">...</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="title">activity</span> <span class="attribute">...</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">application</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.WRITE_EXTERNAL_STORAGE"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.INTERNET"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.ACCESS_NETWORK_STATE"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.READ_PHONE_STATE"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.ACCESS_WIFI_STATE"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.READ_LOGS"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果你想指定你的发布渠道，请在 AndroidManifest.xml 中加入如下内容：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">application</span>  <span class="attribute">...</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="title">meta-data</span> <span class="attribute">android:name</span>=<span class="value">"Channel ID"</span> <span class="attribute">android:value</span>=<span class="value">"LeanCloud"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">application</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>你可以根据你的实际发布渠道，修改上述的 android:value 中对应的值，比如将 <code>LeanCloud</code> 改为 <code>Your Channel</code>，重新打包后发布。<strong>请不要修改 <code>android:name=&quot;Channel ID&quot;</code> 字段，以免影响使用。</strong></p>
<p>由于很多用户反映在部分第三方发布平台中间，不允许出现 meta-data 中间的 key 出现空格字符，我们在 2.6.8 以后，增加了一个等效的 key：<code>leancloud</code>。<br>以下代码也可以用于指定渠道了，但是请不要反复定义。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">application</span>  <span class="attribute">...</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="title">meta-data</span> <span class="attribute">android:name</span>=<span class="value">"leancloud"</span> <span class="attribute">android:value</span>=<span class="value">"LeanCloud"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">application</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当然你也可以通过代码来指定发布渠道。但是代码设置的渠道优先级没有 <code>AndroidManifest.xml</code> 中的配置高，同时出现时优先取 <code>AndroidManifest.xml</code> 中的配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">AVAnalytics.setAppChannel(<span class="string">"SomeChannel"</span>);</span><br><span class="line"><span class="comment">// 参数依次是 context, appId, appKey</span></span><br><span class="line">AVOSCloud.initialize(getContext(),<span class="string">"&#123;&#123;appid&#125;&#125;"</span>,<span class="string">"&#123;&#123;appKey&#125;&#125;"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="添加使用代码">添加使用代码</h2><h3 id="添加引用">添加引用</h3><p>经过我们的一系列更新升级，使用最新的 SDK 你不需要任何代码上的操作就可以使用统计的基本功能，统计功能为默认打开。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.avos.avoscloud.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YourApp</span> <span class="keyword">extends</span> <span class="title">Application</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        AVOSCloud.initialize(<span class="keyword">this</span>, <span class="string">"&#123;&#123;appid&#125;&#125;"</span>, <span class="string">"&#123;&#123;appkey&#125;&#125;"</span>);</span><br><span class="line">        <span class="comment">//AVAnalytics.start(this);    已经不再需要这行代码了</span></span><br><span class="line">        AVAnalytics.enableCrashReport(<span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="统计页面路径">统计页面路径</h2><p>在需要的 Activity 中调用统计 SDK。在每个 Activity 的 <code>onResume</code> 和 <code>onPause</code> 方法中调用相应的统计方法，传入的参数为当前 context（比如当前的 Activity）的引用。 这里请不要将全局的 Application Context 传入。如示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onPause();</span><br><span class="line">    AVAnalytics.onPause(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume();</span><br><span class="line">    AVAnalytics.onResume(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请确保在所需要的所有的 Activity 中都调用 <code>AVAnalytics.onResume()</code> 和 <code>AVAnalytics.onPause()</code> 方法，这两个调用将不会阻塞应用程序的主线程，也不会影响应用程序的性能。</p>
<p>注意：如果你的 Activity 之间有继承或者控制关系请不要同时在父和子 Activity 中重复添加 onPause 和 onResume 方法，否则会造成重复统计，比如在使用 TabHost、TabActivity、ActivityGroup 时。一个应用程序在多个 Activity 之间连续切换时，将会被视为同一个 session（会话或者一次使用过程）。</p>
<p>当用户两次使用之间间隔超过 30 秒时，将被认为是两个的独立的 session，例如用户回到 home，或进入其他程序，经过一段时间后再返回之前的应用。我们也提供了新的接口来自定义这个时间间隔，你只要调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVAnalytics.setSessionContinueMillis(<span class="keyword">long</span> mills);</span><br></pre></td></tr></table></figure>
<p>传入适当的参数，就可以控制 session 重新启动时间，注意参数是以毫秒为单位的。 例如，如果你认为在 60 秒之内返回应用可视为同一次启动，超过 60 秒返回当前应用可视为一次新的启动，那么请写成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVAnalytics.setSessionContinueMillis(<span class="number">60</span> * <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<h2 id="统计_Fragment_页面">统计 Fragment 页面</h2><p>Android 3.0 引入了 Fragment。使用 Fragment，你可以在一个 Activity 中展示多个用户界面，也可根据你的需要，为不同的设备适配界面。LeanCloud SDK 1.4.2 开始增加了对于 Fragment 统计的支持。你可以使用以下代码统计 Fragment 页面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListFragment</span> <span class="keyword">extends</span> <span class="title">ListFragment</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttach</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onAttach(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">        AVAnalytics.onFragmentEnd(<span class="string">"my-list-fragment"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        AVAnalytics.onFragmentStart(<span class="string">"my-list-fragment"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试">测试</h2><ul>
<li>确认所需的权限都已经添加：<ul>
<li><code>INTERNET</code></li>
<li><code>READ_PHONE_STATE</code></li>
<li><code>READ_LOGS</code></li>
<li><code>WRITE_EXTERNAL_STORAGE</code></li>
</ul>
</li>
<li>确认所有的 Activity 中都调用了 onResume 和 onPause 方法。</li>
<li>确认测试手机（或者模拟器）已成功连入网络。</li>
<li>启动应用程序，几分钟之内你应该已经可以在 <a href="/stat.html?appid=}#/statrealtime">控制台 / 分析</a> 中的相应菜单中看到报表了。</li>
</ul>
<h2 id="数据时效性">数据时效性</h2><p>在控制台的 <strong>分析</strong> 页面中，有些报告可以展示实时数据，有些报告则依靠 <a href="leaninsight_guide.html">离线数据</a> 进行分析，因此有时你会看不到当天的数据。</p>
<p>如果当前页面中存在 <strong>日期选择</strong> 选项（通常在页面右上角），你可以以此判断当前的统计结果是否有延迟。如果 <strong>结束日期</strong> 显示为 <strong>当日日期</strong> 或在其下拉菜单中有「今日」选项，即为实时数据；反之则为离线数据（如下图所示），要推迟一天才能看到当日的情况。</p>
<p><img src="../images/analytics_datepicker_for_offline_data.png" alt="" width="231" height="256"></p>
<h2 id="使用自定义事件">使用自定义事件</h2><h3 id="基本简单事件">基本简单事件</h3><p>除了基本统计分析功能外，SDK 还支持你自定义的事件分析，例如你可以统计你的应用中有多少人点击了 like 按键，某个文章的点击次数或者视频被播放的次数等等。</p>
<p>在你希望发送事件报告的代码段，调用如下方法就可以向服务器发送事件记录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVAnalytics.onEvent(Context context, String eventName);</span><br></pre></td></tr></table></figure>
<p>统计 eventName 对应事件的发生次数、变化趋势，例如 like 点击、浏览数量等等。参数 context 为当前 context 的引用。eventName 为当前统计的事件 name。【注意】eventName 中不要加空格或其他的转义字符。</p>
<p>比如，应用中的一条微视频被转发的事件被定义为「Forward」，那么在点击转发的函数里调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVAnalytics.onEvent(<span class="keyword">this</span>, <span class="string">"Forward"</span>)</span><br></pre></td></tr></table></figure>
<p>就会向服务器汇报一个转发的事件。</p>
<h3 id="多标签事件">多标签事件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVAnalytics.onEvent(Context context, String eventName, String  tag);</span><br></pre></td></tr></table></figure>
<p>除了能够统计 eventName 所对应事件的发生次数，变化趋势外，还能统计事件中具体标签所占的比例。tag 为当前标签，同样这里的 eventName 字符串中也请不要使用空格。<br>比如，在玩拍程序中，我们定义了一个发布微视频的多标签事件 Publish，对应的发布内容有 title（发布标题）、Video（发视频）、type（视频类型）来对应不同的发布类型，这样我们不仅可以记录 Publish 事件的点击数量还可以看到不同内容对应的比例。</p>
<h3 id="事件累计">事件累计</h3><p>在应用程序中某些自定义事件可能会被频繁触发，例如用户点击某个按钮。开发者可以在程序中维护一个计数器，这样某个事件被多次触发但只需要生成一个消息，这个消息中包括该事件被触发的次数。为了支持这个功能，我们提供了重载的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AVAnalytics.onEvent(Context context, String eventName, <span class="keyword">int</span> count);</span><br><span class="line">AVAnalytics.onEvent(Context context, String eventName, String label, <span class="keyword">int</span> count)</span><br></pre></td></tr></table></figure>
<p>参数 count 是对应事件（和对应标签）被触发的次数。</p>
<h2 id="设置数据发送策略">设置数据发送策略</h2><p>你可以进入应用的 <a href="/stat.html?appid=&amp;os=android#/statconfig/trans_strategoy"><strong>分析</strong> &gt; <strong>统计设置</strong><span class="text-muted">（左下角）</span> &gt; <strong>数据发送策略</strong></a> 在线更改 SDK 端的数据报告发送策略。在没有取到在线配置的发送策略的情况下，会使用默认的发送策略。</p>
<p>以下均为在线配置中的可选策略。</p>
<h3 id="启动时发送">启动时发送</h3><p>【推荐使用】应用程序每次会在启动时会向服务器发送一次消息，在应用程序过程中产生的所有消息（包括自定义事件和本次使用时长）都会在下次启动时候发送。如果应用程序启动时处在不联网状态，那么消息将会缓存在本地，下次再尝试发送。</p>
<p>发送策略默认为启动时发送。</p>
<h3 id="批量发送">批量发送</h3><p>批量发送，默认当消息数量达到 30 条时发送一次。</p>
<h3 id="按最小间隔发送">按最小间隔发送</h3><p>间隔一段时间发送，每隔一段时间一次性发送到服务器。</p>
<h2 id="自定义参数设置">自定义参数设置</h2><p>你可以控制台某个应用的 <strong>组件</strong> &gt; <strong>自定义参数</strong> 设置中配置你的自定义在线参数。这些参数会在我们每次更新统计配置时进行更新，你可以用以下方法来获得对应的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVAnalytics.getConfigParams(<span class="keyword">this</span>.getContext(), <span class="string">"key"</span>)</span><br></pre></td></tr></table></figure>
<p>但是请注意三点：</p>
<ul>
<li>key 必须跟你在控制台配置的参数一致，大小写敏感。</li>
<li><p>由于统计参数更新时一个后台更新，你可能在直接调用 <code>AVAnalytics.getConfigParams(this.getContext(), &quot;key&quot;)</code> 时遇到返回值为 null 的情况。你可以通过设置 AVOnlineConfigureListener 和强制调用 updateOnlineConfig 来保证自定义配置的获取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AVAnalytics.setOnlineConfigureListener(<span class="keyword">new</span> AVOnlineConfigureListener() &#123;</span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataReceived</span><span class="params">(JSONObject data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       AVAnalytics.getConfigParams(getContext(), <span class="string">"key"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;);</span><br><span class="line">AVAnalytics.updateOnlineConfig(getContext());</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于统计参数在客户端会有定时更新的策略，所以 AVOnlineConfigureListener 在客户端会发生多次调用的情况，请在 OnDataReceived 方法中不要放入太多函数副作用。</p>
</li>
</ul>
<h2 id="开发选项">开发选项</h2><p>如果你不准备区分开发 AppKey 与生产环境 AppKey，但是又不想开发时期的统计数据会影响产品上线后的统计数据，你可以使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AVAnalytics.setAnalyticsEnabled(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 参数依次为 context, AppId, AppKey</span></span><br><span class="line">AVOSCloud.initialize(context,&#123;&#123;appid&#125;&#125;,&#123;&#123;appkey&#125;&#125;);</span><br></pre></td></tr></table></figure>
<p>在开发阶段关闭统计的功能。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/android_faq/" itemprop="url">
                Android SDK 常见问题及解答
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/android_faq/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/android_faq/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="Android_SDK_常见问题及解答">Android SDK 常见问题及解答</h1><h2 id="代码混淆怎么做">代码混淆怎么做</h2><p>为了保证 SDK 在代码混淆后能正常运作，需要保证部分类和第三方库不被混淆，参考下列配置：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"># proguard.cfg</span><br><span class="line"></span><br><span class="line">-<span class="ruby">keepattributes <span class="constant">Signature</span></span><br><span class="line"></span>-<span class="ruby">dontwarn com.jcraft.jzlib.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">jcraft</span>.<span class="title">jzlib</span>.**  &#123; *;</span>&#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn sun.misc.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">sun</span>.<span class="title">misc</span>.** &#123; *;</span>&#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn com.alibaba.fastjson.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">alibaba</span>.<span class="title">fastjson</span>.** &#123; *;</span>&#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn sun.security.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">sun</span>.<span class="title">security</span>.** &#123; *;</span> &#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn com.google.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">google</span>.** &#123; *;</span>&#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn com.avos.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">avos</span>.** &#123; *;</span>&#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">keep public <span class="class"><span class="keyword">class</span> <span class="title">android</span>.<span class="title">net</span>.<span class="title">http</span>.<span class="title">SslError</span></span></span><br><span class="line"></span>-<span class="ruby">keep public <span class="class"><span class="keyword">class</span> <span class="title">android</span>.<span class="title">webkit</span>.<span class="title">WebViewClient</span></span></span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn android.webkit.<span class="constant">WebView</span></span><br><span class="line"></span>-<span class="ruby">dontwarn android.net.http.<span class="constant">SslError</span></span><br><span class="line"></span>-<span class="ruby">dontwarn android.webkit.<span class="constant">WebViewClient</span></span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn android.support.**</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn org.apache.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">apache</span>.** &#123; *;</span>&#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn org.jivesoftware.smack.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">jivesoftware</span>.<span class="title">smack</span>.** &#123; *;</span>&#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn com.loopj.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">loopj</span>.** &#123; *;</span>&#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn com.squareup.okhttp.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">squareup</span>.<span class="title">okhttp</span>.** &#123; *;</span>&#125;</span><br><span class="line"></span>-<span class="ruby">keep interface com.squareup.okhttp.** &#123; *; &#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn okio.**</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn org.xbill.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">xbill</span>.** &#123; *;</span>&#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">keepattributes *<span class="constant">Annotation</span>*</span></span><br></pre></td></tr></table></figure>
<h2 id="使用美国节点时_SDK_报错：create_SSL_socket_factory_失败">使用美国节点时 SDK 报错：<code>create SSL socket factory</code> 失败</h2><p>在使用美国节点的时候，SDK 初始化时即报错，显示 <code>create SSL socket factory</code> 失败。怎么办？</p>
<p>这是因为 LeanCloud 的 SSL 证书不在工程资源里面导致的，解决办法如下：</p>
<p>请下载 <a href="https://download.leancloud.cn/sdk/android/current/avoscloud_us_ssl.bks" target="_blank" rel="external">SSL 证书</a>，并拷贝到你项目的 <code>res/raw/</code> 目录下，重新打包即可。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/01Getting Started/Basic Setup/" itemprop="url">
                01Getting Started-基本设置
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-26T23:00:00+08:00" content="2015-12-26">
            2015-12-26
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Using-Swift-with-Cocoa-and-Objective-C/" itemprop="url" rel="index">
                  <span itemprop="name">Using-Swift-with-Cocoa-and-Objective-C</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/01Getting Started/Basic Setup/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/01Getting Started/Basic Setup/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><blockquote>
<p>翻译：<a href="https://github.com/Creolophus" target="_blank" rel="external">Creolophus</a></p>
<p>校正：<a href="https://github.com/Evilcome" target="_blank" rel="external">Evilcome</a> <a href="https://github.com/dabing1022" target="_blank" rel="external">ChildhoodAndy</a></p>
</blockquote>
<h1 id="基本设置">基本设置</h1><hr>
<p>本页包含内容：</p>
<ul>
<li><a href="#setting_up_your_swift_environment">建立你的 Swift 环境</a></li>
<li><a href="#understanding_the_swift_import_process">理解 Swift 导入过程</a></li>
</ul>
<blockquote>
<p>重要事项</p>
<p>这是一个正在研发的API或技术的概要文件，苹果公司提供这些信息主要是为了帮助你通过苹果产品使用这些技术或者编程接口而做好计划，该信息有可能会在未来发生改变，本文当中提到的软件应该以最终发布的操作系统测试和最终文档为准，未来有可能会提供新版本的文档信息。</p>
</blockquote>
<p>Swift 被设计用来无缝兼容 Cocoa 和 Objective-C 。在 Swift 中，你可以使用 Objective-C 的 API（包括系统框架和你自定义的代码），你也可以在 Objective-C中 使用 Swift 的 API。这种兼容性使 Swift 变成了一个简单、方便并且强大的工具集成到你的 Cocoa 应用开发工作流程中。</p>
<p>这篇指南包括了三个有关兼容性的重要方面方便你更好地利用来开发 Cocoa 应用：</p>
<ul>
<li><strong>互用性</strong> 使你将 Swift 和 Objective-C 相接合，允许在 Objective-C 中使用 Swift 的 Class 并且当你在写 Swift 代码时利用熟悉的 Cocoa Class、Pattern、Practice。</li>
<li><strong>混合和匹配</strong> 允许你创建结合了 Swift 和 Objective-C 文件的混合语言应用，他们能跟彼此进行通信。</li>
<li><strong>迁移</strong> 由于以上两点，从已经存在的 Objective-C 代码迁移到 Swift 是非常简单的，使得用最新的 Swift 特性代替你的 Objective-C 应用部分内容成为了可能。</li>
</ul>
<p>在你开始学习这些特性前，你需要对如何建立 Swift 环境来访问 Cocoa 系统框架有个大体了解。</p>
<p><a name="setting_up_your_swift_environment"></a></p>
<p>##建立你的 Swift 环境</p>
<p>为了开始体验在 Swift 中访问 Cocoa 框架，使用 Xcode 的一个模板来创建一个基于 Swift 应用。</p>
<p>###在 Xcode 中创建一个 Swift 项目</p>
<p>1.选择 File &gt; New &gt; Project &gt; (iOS or OS X) &gt; Application &gt; your <em>template of choice</em>。</p>
<p>2.点击 Language 弹出菜单并选择 Swift。</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/Art/newproject_2x.png" alt="image"></p>
<p>Swift 项目的结构几乎和 Objective-C 项目一模一样，只有一个重要的区别：Swift 没有头文件。在实现和接口之间没有显示的划分，所以一个特定类中的所有信息都存储在单独的<code>.swift</code>文件中。</p>
<p>现在开始，你可以开始体验在<code>app delegate</code>中写 Swift 代码，或者你可以通过选择 File &gt; New &gt; File &gt; (iOS or OS X) &gt; Other &gt; Swift来创建一个 Swift 类。</p>
<p><a name="understanding_the_swift_import_process"></a></p>
<p>##理解 Swift 导入过程</p>
<p>在你建立 Xcode 项目后，你可以在 Swift 里导入任意用 Objective-C 来工作的 Cocoa 平台框架。</p>
<p>任意 Objective-C 的框架（或 C 类库）将作为一个<em>module</em>，能直接导入到 Swift 中。这些包括了所有 Objective-C 系统框架-比如 Foundation、UIKit 和 SpriteKit，就像系统支持公共 C 类库。举个例子，想导入 Foundation，只要简单地添加 import 语句到你写的 Swift 文件的顶部。</p>
<blockquote>
<p>SWIFT</p>
<p><code>import Foundation</code></p>
</blockquote>
<p>这个 import 导入了所有 Foundation 的 API，包括<code>NSDate</code>，<code>NSURL</code>，<code>NSMutableData</code>，并且他们的所有方法、属性和类别都可以在 Swift 中直接使用。</p>
<p>导入过程是非常简洁的。Objective-C 框架在头文件中申明 API。在 Swift 中，那些头文件被编译成 Objective-C 的 module，接着被导入到 Swift 作为 Swift 的 API。导入决定了 Objective-C 的 Function，Class，Method 和 Type 如何在 Swift 中出现。对于 Function 和 Method，这个过程影响他们的参数和返回值。导入过程可以做下面这些事情：</p>
<ul>
<li>重映射确定的 Objective-C 类型到 Swift 中的同等类型，就像 id 到<code>AnyObject</code></li>
<li>重映射确定的 Objective-C 核心类型到 Swift 中的替代类型， 就像<code>NSString</code>到<code>String</code></li>
<li>重映射确定的 Objective-C 概念到 Swift 中相匹配的概念，如<code>pointers</code>到<code>optionals</code></li>
</ul>
<p>在互用性章节，你将会了解到更多关于这些映射如何在你的 Swift 代码进行取舍。<br>导入 Swift 的模型到 Objective-C 和从 Objective-C 导入 Swift 是非常相似的。Swift 申明它的 API，比如一个框架作为 Swift modules。同时这些 Swift modules 会生成 Objective-C 的头文件。这些头文件可以映射回 Objective-C 的 API 中。一些 Swift 的 API 不映射回 Objective-C 因为他们取舍了语言特性发现这些在 Objective-C 中不可用。关于在 Objective-C 中使用 Swift 的更多特性，请参看<a href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/03Mix%20and%20Match/Swift%20and%20Objective-C%20in%20the%20Same%20Project/">在同一项目中使用 Swift 和 Objective-C</a>。</p>
<blockquote>
<p>注意</p>
<p>你不能直接把 C++ 代码导入 Swift。解决办法是为 C++ 代码创建一个 Objective-C 或者 C 的封装。</p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/01Interacting with Objective-C APIs/" itemprop="url">
                02Interoperability-01与 Objective-C 的 API 交互
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-26T22:00:10+08:00" content="2015-12-26">
            2015-12-26
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Using-Swift-with-Cocoa-and-Objective-C/" itemprop="url" rel="index">
                  <span itemprop="name">Using-Swift-with-Cocoa-and-Objective-C</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/01Interacting with Objective-C APIs/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/01Interacting with Objective-C APIs/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><blockquote>
<p>翻译：<a href="https://github.com/Creolophus" target="_blank" rel="external">Creolophus</a></p>
<p>校正：<a href="https://github.com/Evilcome" target="_blank" rel="external">Evilcome</a> <a href="https://github.com/dabing1022" target="_blank" rel="external">ChildhoodAndy</a></p>
</blockquote>
<p>#与 Objective-C 的 API 交互</p>
<hr>
<p>本页包含内容：</p>
<ul>
<li><a href="#initialization">初始化</a></li>
<li><a href="#failable_initialization">可失败初始化</a></li>
<li><a href="#accessing_properties">访问属性</a></li>
<li><a href="#working_with_methods">方法</a></li>
<li><a href="#id_compatibility">id 兼容性（id Compatibility）</a></li>
<li><a href="#Nullability_and_Optionals">空值和可选值</a></li>
<li><a href="#extensions">扩展（Extensions）</a></li>
<li><a href="#closures">闭包（Closures）</a></li>
<li><a href="#object_comparison">比较对象</a></li>
<li><a href="#swift_type_compatibility">Swift 类型兼容性</a></li>
<li><a href="#Requiring_Dynamic_Dispatch">动态分发</a></li>
<li><a href="#Lightweight_Generics">轻量级泛型</a></li>
<li><a href="#objective_c_selectors">Objective-C 选择器（Selectors）</a></li>
</ul>
<p><strong>互用性</strong>是让 Swift 和 Objective-C 相接合的一种特性，使你能够在一种语言编写的文件中使用另一种语言。当你准备开始把 Swift 融入到你的开发流程中时，你应该懂得如何利用互用性来重新定义并提高你写 Cocoa 应用的方案。</p>
<p>互用性很重要的一点就是允许你在写 Swift 代码时使用 Objective-C 的 API 接口。当你导入一个 Objective-C 框架后，你可以使用原生的 Swift 语法实例化它的 Class 并且与之交互。</p>
<p><a name="initialization"></a></p>
<p>##初始化</p>
<p>为了使用 Swift 实例化 Objective-C 的 Class，你应该使用 Swift 语法调用它的一个初始化器。当 Objective-C 的<code>init</code>方法变化到 Swift，他们用 Swift 初始化语法呈现。“init”前缀被截断当作一个关键字，用来表明该方法是初始化方法。那些以“initWith”开头的<code>init</code>方法，“With”也会被去除。从“init”或者“initWith”中分离出来的这部分方法名首字母变成小写，并且被当做是第一个参数的参数名。其余的每一部分方法名依次变为参数名。这些方法名都在圆括号中被调用。</p>
<p>举个例子，你在使用 Objective-C 时会这样做：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UITableView *myTableView = [[UITableView alloc] &#10;initWithFrame:CGRectZero style:UITableViewStyleGrouped];</span><br></pre></td></tr></table></figure>
<p>在 Swift 中，你应该这样做：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myTableView: <span class="type">UITableView</span> = <span class="type">UITableView</span>(frame: <span class="type">CGRectZero</span>, style: .<span class="type">Grouped</span>)</span><br></pre></td></tr></table></figure>
<p>你不需要调用<code>alloc</code>，Swift 能够正确的为你处理。注意，当使用 Swift 风格的初始化函数的时候，“init”不会出现。</p>
<p>你可以在初始化时显式的声明对象的类型，也可以忽略它，Swift 能够正确判断对象的类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myTextField = <span class="type">UITextField</span>(frame: <span class="type">CGRect</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">200.0</span>, <span class="number">40.0</span>))</span><br></pre></td></tr></table></figure>
<p>这里的<code>UITableView</code>和<code>UITextField</code>对象和你在 Objective-C 中使用的具有相同的功能。你可以用一样的方式使用他们，包括访问属性或者调用各自的类中的方法。</p>
<p>为了统一和简易，Objective-C 的工厂方法也在 Swift 中映射为方便的初始化方法。这种映射能够让他们使用同样简洁明了的初始化方法。例如，在 Objective-C 中你可能会像下面这样调用一个工厂方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIColor *color = [UIColor colorWithRed:0.5 green:0.0 blue:0.5 alpha:1.0];</span><br></pre></td></tr></table></figure>
<p>在 Swift 中，你应该这样做：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> color = <span class="type">UIColor</span>(red: <span class="number">0.5</span>, green: <span class="number">0.0</span>, blue: <span class="number">0.5</span>, alpha: <span class="number">1.0</span>)</span><br></pre></td></tr></table></figure>
<p><a name="failable_initialization"></a></p>
<p>##可失败初始化</p>
<p>在 Objective-C 中，构造器会直接返回他们初始化的对象。为了通知调用者初始化失败，Objective-C 构造器会返回<code>nil</code>。在 Swift 中，这种模式被内置到语言特性中，被称为<em>可失败初始化</em>。在 iOS 和 OSX 系统框架中许多 Objective-C 构造器会被检查是否会初始化失败。如果初始化不会失败，这些 Objective-C 构造器便会以<code>init(...)</code>被导入，如果初始化可能会失败，则会以<code>init?(...)</code>被导入。在我们自己的 Objective-C 类以及未被检查的框架类中，构造器会以<code>init!(...)</code>被导入。例如，当图片文件在指定路径中不存在时，<code>UIImage(contentsOfFile:)</code>构造器初始化<code>UIImage</code>对象便会失败。如果初始化成功，我们可以用可选值绑定来对可失败初始化的结果进行解包。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> image = <span class="type">UIImage</span>(contentsOfFile: <span class="string">"MyImage.png"</span>) &#123;</span><br><span class="line">    <span class="comment">// loaded the image successfully</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// could not load the image</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="accessing_properties"></a></p>
<p>##访问属性</p>
<p>在 Swift 中访问和设置 Objective-C 对象的属性时，使用点语法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myTextField.textColor = <span class="type">UIColor</span>.darkGrayColor()</span><br><span class="line">myTextField.text = <span class="string">"Hello world"</span></span><br></pre></td></tr></table></figure>
<p>当 get 或 set 属性时，直接使用属性名称，不需要附加圆括号。注意，<code>darkGrayColor</code>后面附加了一对圆括号，这是因为<code>darkGrayColor</code>是<code>UIColor</code>的一个类方法，不是一个属性。</p>
<p>在 Objective-C 中，一个有返回值的无参数方法可以被作为一个隐式的访问函数，并且可以与访问器使用同样的方法调用。但在 Swift 中不再能够这样做了，只有在 Objective-C 中 使用<code>@property</code>关键字声明的属性才会被作为属性引入。方法被导入和调用见<a href="#working_with_methods">方法</a>描述。</p>
<p><a name="working_with_methods"></a></p>
<p>##方法</p>
<p>在 Swift 中调用 Objective-C 方法时，使用点语法。</p>
<p>当 Objective-C 方法转换到 Swift 时，Objective-C 的<code>selector</code>的第一部分将会成为方法名并出现在圆括号的前面，而第一个参数将直接在括号中出现，并且没有参数名，而剩下的参数名与参数则一一对应的填入圆括号中。选择器的所有部分在调用时都是必需的。</p>
<p>举个例子，你在使用 Objective-C 时会这样做：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[myTableView insertSubview:mySubview atIndex:2];</span><br></pre></td></tr></table></figure>
<p>在 Swift 中，你应该这样做：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myTableView.insertSubview(mySubview, atIndex: <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>如果你调用一个无参方法，仍必须在方法名后面加上一对圆括号</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myTableView.layoutIfNeeded()</span><br></pre></td></tr></table></figure>
<p><a name="id_compatibility"></a></p>
<p>##id 兼容性（id Compatibility）</p>
<p>Swift 包含一个叫做<code>AnyObject</code>的协议类型，表示任意类型的对象，就像 Objective-C 中的<code>id</code>一样。<code>AnyObject</code>协议允许你编写类型安全的 Swift 代码同时维持无类型对象的灵活性。因为<code>AnyObject</code>协议保证了这种安全，Swift 将<code>id</code>对象导入为<code>AnyObject</code>。</p>
<p>举个例子，跟<code>id</code>一样，你可以为<code>AnyObject</code>类型的对象分配任何其它类型的对象，你也同样可以为它重新分配其它类型的对象。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject: <span class="type">AnyObject</span> = <span class="type">UITableViewCell</span>()</span><br><span class="line">myObject = <span class="type">NSDate</span>()</span><br></pre></td></tr></table></figure>
<p>你也可以在调用 Objective-C 方法或者访问属性时不将它转换为具体类的类型。这包括了 Objective-C 中标记为<code>@objc</code>的方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> futureDate = myObject.dateByAddingTimeInterval(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">let</span> timeSinceNow = myObject.timeIntervalSinceNow</span><br></pre></td></tr></table></figure>
<p>然而，由于直到运行时才知道<code>AnyObject</code>的对象类型，所以有可能在不经意间写出不安全代码。另外，与 Objective-C 不同的是，如果你调的用方法或者访问的属性<code>AnyObject</code>对象没有声明，将会报运行时错误。比如下面的代码在运行时将会报出一个<code>unrecognized selector error</code>错误：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myObject.characterAtIndex(<span class="number">5</span>)</span><br><span class="line"><span class="comment">// crash, myObject does't respond to that method</span></span><br></pre></td></tr></table></figure>
<p>但是，你可以通过 Swift 的可选值特性来排除这个 Objective-C 中常见的错误，当你用<code>AnyObject</code>对象调用一个 Objective-C 方法时，这次调用将会变成一次隐式展开可选值的行为。你可以通过可选值特性来决定<code>AnyObject</code>类型的对象是否调用该方法，同样的，你可以把这种特性应用在属性上。</p>
<blockquote>
<p>注</p>
<p>通过<code>AnyObject</code>访问的属性永远返回一个可选值。</p>
</blockquote>
<p>举个例子，在下面的代码中，第一和第二行代码将不会被执行因为<code>length</code>属性和<code>characterAtIndex:</code>方法不存在于 NSDate 对象中。<code>myLength</code>常量会被推测成可选的<code>Int</code>类型并且被赋值为<code>nil</code>。同样你可以使用<code>if-let</code>声明来有条件的展开这个方法的返回值，从而判断对象是否能执行这个方法。就像第三行做的一样。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myLength = myObject.length?</span><br><span class="line"><span class="keyword">let</span> myChar = myObject.characterAtIndex?(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> fifthCharacter = myObject.characterAtIndex(<span class="number">5</span>) &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"Found <span class="subst">\(fifthCharacter)</span> at index 5"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 Swift 中的强制类型转换，从<code>AnyObject</code>类型的对象转换成明确的类型并不会保证成功，所以它会返回一个可选的值。而你需通过检查该值的类型来确认转换是否成功。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="keyword">let</span> userDefaults = <span class="type">NSUserDefaults</span>.standardUserDefaults()</span><br><span class="line"><span class="keyword">let</span> lastRefreshDate: <span class="type">AnyObject</span>? = userDefaults.objectForKey(<span class="string">"LastRefreshDate"</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> date = lastRefreshDate <span class="keyword">as</span>? <span class="type">NSDate</span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"<span class="subst">\(date.timeIntervalSinceReferenceDate)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，如果你能确定这个对象的类型（并且确定不是<code>nil</code>），你可以添加<code>as</code>操作符强制调用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myDate = lastRefreshDate <span class="keyword">as</span> <span class="type">NSDate</span></span><br><span class="line"><span class="keyword">let</span> timeInterval = myDate.timeIntervalSinceReferenceDate</span><br></pre></td></tr></table></figure>
<p><a name="Nullability_and_Optionals"></a></p>
<h2 id="空值和可选值">空值和可选值</h2><p>在 Objective-C 中，对象的引用可以是值为<code>NULL</code>的原始指针（在 Objective-C 中的简称为<code>nil</code>）。而在Swift中，所有的值–包括结构体与对象的引用–都被保证为非空。作为替代，你将这个可以为空的值包装为optional type。当你需要宣告值为空时，你需要使用<code>nil</code>。你可以在<a href="https://github.com/CocoaChina-editors/Welcome-to-Swift/blob/master/The%20Swift%20Programming%20Language/02Language%20Guide/01The%20Basics.md#optionals" target="_blank" rel="external">Optionals</a>中了解更多。</p>
<p>Objective-C 能够使用空值标记来设定一个参数类型，属性类型或者返回值类型是否可以为 NULL 或者 为 nil 值。单独的类型声明可以使用<code>__nullable</code>和<code>__nonnull</code>标注，空值的范围性的声明可以使用<code>NS_ASSUME_NONNULL_BEGIN</code>和<code>NS_ASSUME_NONNULL_END</code>宏。如果一个类型没有任何的空值标注信息，Swift 就不能分辨出可选值和非可选值类型，并且将作为隐式的解包可选值导入。</p>
<ul>
<li>以<code>__nonnull</code>或者范围宏标注声明的空值类型，被作为非空可选值<code>non-optional</code>导入到 Swift。</li>
<li>以<code>__nullable</code>标注声明的空值类型，被作为可选值导入到 Swift。</li>
<li>没有以空值标注声明的类型被作为隐式的解包可选值导入到 Swift。</li>
</ul>
<p>例如，考虑如下的 Objective-C 声明：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nullable) id  nullableProperty;&#10;@property (nonnull) id nonNullProperty;&#10;@property id unannotatedProperty;&#10; &#10;NS_ASSUME_NONNULL_BEGIN&#10;- (id)returnsNonNullValue;&#10;- (void)takesNonNullParameter:(id)value;&#10;NS_ASSUME_NONNULL_END&#10; &#10;- (nullable id)returnsNullableValue;&#10;- (void)takesNullableParameter:(nullable id)value;&#10; &#10;- (id)returnsUnannotatedValue;&#10;- (void)takesUnannotatedParameter:(id)value;</span><br></pre></td></tr></table></figure>
<p>下面是他们如何被导入 Swift 中的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nullableProperty: <span class="type">AnyObject</span>?</span><br><span class="line"><span class="keyword">var</span> nonNullProperty: <span class="type">AnyObject</span></span><br><span class="line"><span class="keyword">var</span> unannotatedProperty: <span class="type">AnyObject</span>!</span><br><span class="line"> </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">returnsNonNullValue</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesNonNullParameter</span><span class="params">(value: AnyObject)</span></span></span><br><span class="line"> </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">returnsNullableValue</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span>?</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesNullableParameter</span><span class="params">(value: AnyObject?)</span></span></span><br><span class="line"> </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">returnsUnannotatedValue</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span>!</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesUnannotatedParameter</span><span class="params">(value: AnyObject!)</span></span></span><br></pre></td></tr></table></figure>
<p>大多数 Objective-C 的系统框架，包括 Foundation，都已经提供了可空的注解，允许你使用惯用和类型安全的方式与值打交道。</p>
<p><a name="extensions"></a></p>
<p>##扩展（Extensions）</p>
<p>Swift 的扩展和 Objective-C 的类别（Category）相似。扩展为原有的类，结构和枚举丰富了功能，包括在 Objective-C 中定义过的。你可以为系统的框架或者你自己的类型增加扩展，只需要导入合适的模块并且保证你在 Objective-C 中使用的类、结构或枚举拥有相同的名字。</p>
<p>举个例子，你可以扩展<code>UIBezierPath</code>类来为它增加一个等边三角形，这个方法只需提供三角形的边长与起点。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIBezierPath</span> </span>&#123;</span><br><span class="line">    convenience <span class="keyword">init</span>(triangleSideLength: <span class="type">Float</span>, origin: <span class="type">CGPoint</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">let</span> squareRoot = <span class="type">Float</span>(sqrt(<span class="number">3</span>))</span><br><span class="line">        <span class="keyword">let</span> altitude = (squareRoot * triangleSideLength) / <span class="number">2</span></span><br><span class="line">        moveToPoint(origin)</span><br><span class="line">        addLineToPoint(<span class="type">CGPoint</span>(triangleSideLength, origin.x))</span><br><span class="line">        addLineToPoint(<span class="type">CGPoint</span>(triangleSideLength / <span class="number">2</span>, altitude))</span><br><span class="line">        closePath()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以使用扩展来增加属性（包括类的属性与静态属性）。然而，这些属性必须是通过计算才能获取的，扩展不会为类，结构体，枚举添加存储属性。下面这个例子为<code>CGRect</code>类增加了一个叫<code>area</code>的属性。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CGRect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">CGFloat</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> width * height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> rect = <span class="type">CGRect</span>(x: <span class="number">0.0</span>, y: <span class="number">0.0</span>, width: <span class="number">10.0</span>, height: <span class="number">50.0</span>)</span><br><span class="line"><span class="keyword">let</span> area = rect.area</span><br><span class="line"><span class="comment">// area: CGFloat = 500.0</span></span><br></pre></td></tr></table></figure>
<p>你同样可以使用扩展来为类添加协议而无需增加它的子类。如果这个协议是在 Swift 中被定义的，你可以添加 comformance 到它的结构或枚举中无论它们在 Objective-C 或在 Swift 中被定义。</p>
<p>你不能使用扩展来覆盖 Objective-C 类型中存在的方法与属性。</p>
<p><a name="closures"></a></p>
<p>##闭包（Closures）</p>
<p>Objective-C 中的<code>blocks</code>会被自动导入为 Swift 中的闭包。例如，下面是一个 Objective-C 中的 block 变量：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void (^completionBlock)(NSData *, NSError *) = ^(NSData *data, NSError *error) &#123;/* ... */&#125;</span><br></pre></td></tr></table></figure>
<p>而它在 Swift 中的形式为</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> completionBlock: (<span class="type">NSData</span>, <span class="type">NSError</span>) -&gt; <span class="type">Void</span> = &#123;data, error <span class="keyword">in</span> <span class="comment">/* ... */</span>&#125;</span><br></pre></td></tr></table></figure>
<p>Swift 的闭包与 Objective-C 中的 blocks 能够和睦相处，所以你可以把一个 Swift 闭包传递给一个把 block 作为参数的 Objective-C 函数。Swift 闭包与函数具有互通的类型，所以你甚至可以传递 Swift 函数的名字。</p>
<p>闭包与 blocks 语义上相通但是在一个地方不同：变量是可以直接改变的，而不是像 block 那样会拷贝变量。换句话说，Swift 中变量的默认行为与 Objective-C 中 __block 变量一致。</p>
<p><a name="object_comparison"></a></p>
<p>##比较对象</p>
<p>当比较两个 Swift 中的对象时，可以使用两种方式。第一种，使用（==），判断两个对象内容是否相同。第二种，使用(===)，判断常量或者变量是否为同一个对象的实例。</p>
<p>Swift 与 Objective-C 一般使用 == 与 === 操作符来做比较。Swift 的 == 操作符为源自 NSObject 的对象提供了默认的实现。在实现 == 操作符时，Swift 调用 NSObject 定义的 isEqual: 方法。</p>
<p>NSObject 类仅仅做了身份的比较，所以你需要在你自己的类中重新实现 isEqual: 方法。因为你可以直接传递 Swift 对象给 Objective-C 的 API，你也应该为这些对象实现自定义的 isEqual: 方法，如果你希望比较两个对象的内容是否相同而不是仅仅比较他们是不是由相同的对象派生。</p>
<p>作为实现比较函数的一部分，确保根据<a href="//https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/DevPedia-CocoaCore/ObjectComparison.html#//apple_ref/doc/uid/TP40008195-CH37">Object comparison</a>实现对象的<code>hash</code>属性。更进一步的说，如果你希望你的类能够作为字典中的键，也需要遵从<code>Hashable</code>协议以及实现<code>hashValues</code>属性。</p>
<p><a name="swift_type_compatibility"></a></p>
<h2 id="Swift_类型兼容性">Swift 类型兼容性</h2><p>当你在 Swift 中创建了一个继承自 Objective-C 类的子类时，该类以及该类的成员-属性，方法，下标和构造器，便会在 Objective-C 中自动可用。在某些情况下，你需要更细粒度的控制如何将 Swift API 暴漏给 Objective-C。如果你的 Swift 类没有继承自 Objective-C 的类，又或者你想更改暴漏给 Objective-C 代码的接口符号名称，你便可以使用<code>@objc</code>属性。如果你正在使用如键值观察的 API 来动态替换方法的实现，也可以通过使用<code>dynamic</code>修饰符来获得对 Objective-C 运行时被自动派发的成员的访问。</p>
<h3 id="在_Objective-C_中暴漏_Swift_接口">在 Objective-C 中暴漏 Swift 接口</h3><p>当你定义一个继承自<code>NSObject</code>类或者其他 Objective-C 类的 Swift 子类时，该类便会自动兼容 Objective-C。Swift 编译器已经为你做好了这部分所需要的工作。</p>
<p>所有的步骤都由 Swift 编译器自动完成，如果你从未在 Objective-C 代码中导入 Swift 类，你也不需要担心类型适配问题。另外一种情况，如果你的 Swift 类并不继承于 Objective-C 类而你希望能在 Objective-C 的代码中使用它，你可以使用下面描述的<code>@objc</code>属性。</p>
<p><code>@objc</code>可以让你的 Swift API 在 Objective-C 中使用。换句话说，你可以通过在任何 Swift 方法、类、属性前添加<code>@objc</code>，来使得他们可以在 Objective-C 代码中使用。如果你的类继承自 Objective-C，编译器会自动帮助你完成这一步。编译器还会在所有的变量、方法、属性前加 @objc，如果这个类自己前面加上了<code>@objc</code>关键字。当你使用<code>@IBOutlet</code>，<code>@IBAction</code>，或者是<code>@NSManaged</code>属性时，<code>@objc</code>也会自动加在前面。这个关键字也可以用在 Objetive-C 中的 target-action 设计模式中，例如，<code>NSTimer</code>或者<code>UIButton</code>。</p>
<p>当你在 Objective-C 中使用 Swift API，编译器通常会对语句做直接的翻译。例如，Swift API <code>func playSong(name: String)</code>会被解释为<code>- (void)playSong:(NSString *)name</code>。然而，有一个例外：当在 Objective-C 中使用 Swift 的初始化函数，编译器会在方法前添加“initWith”并且将原初始化函数的第一个参数首字母大写。例如，这个 Swift 初始化函数<code>init (songName: String, artist: String</code>将被翻译为<code>- (instancetype)initWithSongName:(NSString *)songName artist:(NSString *)artist</code>。</p>
<p>Swift 同时也提供了一个<code>@objc</code>关键字的变体，通过它你可以自定义在 Objective-C 中转换的函数名。例如，如果你的 Swift 类的名字包含 Objective-C 中不支持的字符，你就可以为 Objective-C 提供一个可供替代的名字。如果你要为 Swift 函数提供一个 Objective-C 名字，记得为带参数的函数添加（:）</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="preprocessor">@objc</span>(<span class="type">Squirrel</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> Белка </span>&#123;</span><br><span class="line">    <span class="preprocessor">@objc</span>(initWithName:)</span><br><span class="line">    <span class="keyword">init</span> (имя: <span class="type">String</span>) &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">    <span class="preprocessor">@objc</span>(hideNuts:inTree:)</span><br><span class="line">    <span class="func"><span class="keyword">func</span> прячьОрехи<span class="params">(Int, вДереве: Дерево)</span></span> &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你在 Swift 类中使用<code>@objc(&lt;#name#&gt;)</code>关键字，这个类可以不需要命名空间即可在 Objective-C 中使用。这个关键字在你迁徙 Objecive-C 代码到 Swift 时同样也非常有用。由于归档过的对象存贮了类的名字，你应该使用<code>@objc(&lt;#name#&gt;)</code>来声明与旧的归档过的类相同的名字，这样旧的类才能被新的 Swift 类解档。</p>
<p><a name="Requiring_Dynamic_Dispatch"></a></p>
<h2 id="请求动态分配">请求动态分配</h2><p>@objc 属性将你的 Swift API 暴露给了 Objective-C 运行时，但是它并不能保证一个属性，方法，下标，或构造器的动态调度。通过绕过 Objective-C 运行时，Swift 编译器可能仍然 devirtualize 或内联成员访问来优化代码的性能。当你用动态修改符标记一个成员声明时，对该成员的访问始终是动态调度。由于标有动态修改声明使用 Objective-C 运行时来调度，它们被隐式的用 @objc 属性标记。</p>
<p>动态分配的需求很少是必要的。但是，当你要在运行时替换一个 API 的实现时你必须使用动态修改。例如，你可以使用 Objective-C 运行时方法<code>method_exchangeImplementations</code>函数来替换 app 正在运行时某个方法的实现。如果 Swift 编译器内联了方法的实现或者 devirtualized 对它的访问，新的实现将不会被使用。</p>
<p><a name="Lightweight_Generics"></a></p>
<h2 id="轻量级泛型">轻量级泛型</h2><p>使用轻量级泛型参数的 Objective-C 声明类型，如<code>NSArray</code>，<code>NSSet</code>以及<code>NSDictionary</code>，在被导入到 Swift 时会附带上他们内容保存的类型。</p>
<p>例如，考虑下面的 Objective-C 属性声明：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property NSArray&#60;NSDate *&#62;* dates;&#10;@property NSSet&#60;NSString *&#62;* words;&#10;@property NSDictionary&#60;KeyType: NSURL *, NSData *&#62;* cachedData;</span><br></pre></td></tr></table></figure>
<p>下面是 Swift 导入后：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dates: [<span class="type">NSDate</span>]</span><br><span class="line"><span class="keyword">var</span> words: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;</span><br><span class="line"><span class="keyword">var</span> cachedData: [<span class="type">NSURL</span>: <span class="type">NSData</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>除了 Foundation 中的集合类， Objective-C 的轻量级泛型会被 Swift 忽略掉。任何其他使用轻量级泛型的类型在导入到 Swift 中时会被视为无参数化。</p>
</blockquote>
<p><a name="objective_c_selectors"></a></p>
<h2 id="Objective-C_选择器">Objective-C 选择器</h2><p>Objective-C 选择器是一种指向 Objective-C 方法名的类型。在 Swift 里，Objective-C 的选择器被<code>Selector</code>结构体替代。你可以通过字符串创建一个选择器，比如<code>let mySelector: Selector = &quot;tappedButton:&quot;</code>。因为字符串字面量能够自动被转换为选择器，所以你可以把字符串字面量直接传递给任何能够接受选择器的方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> myButton = <span class="type">UIButton</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">100</span>, height: <span class="number">50</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>?(nibName nibNameOrNil: <span class="type">String</span>?, bundle nibBundleOrNil: <span class="type">NSBundle</span>?) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: nibNameOrNil, bundle: nibBundleOrNil)</span><br><span class="line">        myButton.addTarget(<span class="keyword">self</span>, action: <span class="string">"tappedButton:"</span>, forControlEvents: .<span class="type">TouchUpInside</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">tappedButton</span><span class="params">(sender: UIButton!)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"tapped button"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    required <span class="keyword">init</span>?(coder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: coder)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p><code>performSelector:</code>方法和相关的调用选择器的方法没有导入到 Swift 中因为它们本质上是不安全的。</p>
</blockquote>
<p>如果你的 Swift 类继承自 Objective-C 的类，你的所有方法都可以用作 Objective-C 的选择器。反之，如果你的 Swift 类不是继承自 Objective-C，你需要在想要使用的选择器前面加上<code>@objc</code>属性前缀，详情请看<a href="#swift_type_compatibility">Swift 类型兼容性</a>。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/02Writing Swift Classes with Objective-C Behavior/" itemprop="url">
                02Interoperability-02特性编写Swift类
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-26T22:00:09+08:00" content="2015-12-26">
            2015-12-26
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Using-Swift-with-Cocoa-and-Objective-C/" itemprop="url" rel="index">
                  <span itemprop="name">Using-Swift-with-Cocoa-and-Objective-C</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/02Writing Swift Classes with Objective-C Behavior/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/02Writing Swift Classes with Objective-C Behavior/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><blockquote>
<p>翻译：<a href="https://github.com/halinuya" target="_blank" rel="external">halinuya</a></p>
<p>校对：<a href="https://github.com/song-buaa" target="_blank" rel="external">song-buaa</a> <a href="https://github.com/MonicaZhou" target="_blank" rel="external">MonicaZhou</a> <a href="https://github.com/dabing1022" target="_blank" rel="external">ChildhoodAndy</a></p>
</blockquote>
<h1 id="使用Objective-C特性编写Swift类">使用Objective-C特性编写Swift类</h1><hr>
<p>本节包括内容：</p>
<ul>
<li><a href="#inheriting_from_objective-c_classes">继承Objective-C的类（Inheriting from Objective-C Classes）</a></li>
<li><a href="#adopting_protocols">采用协议（Adopting Protocols）</a></li>
<li><a href="#writing_initializers_and_deinitializers">编写构造器和析构器（Writing Initializers and Deinitializers）</a></li>
<li><a href="#integrating_with_interface_builder">集成Interface Builder（Integrating with Interface Builder）</a></li>
<li><a href="#specifying_property_attributes">指明属性特性（Specifying Property Attributes）</a></li>
<li><a href="#implementing_core_data_managed_object_subclasses">实现Core Data Managed Object子类（Implementing Core Data Managed Object Subclasses）</a></li>
<li><a href="#using_swift_class_names_with_objective_c_apis">使用带Objective-C API的Swift类名</a></li>
</ul>
<p>互用性（互操作性）使开发者可以定义融合了 Objective-C 语言特性的Swift类。编写 Swift 类时，不仅可以继承 Objective-C 语言编写的父类，采用 Objective-C 的协议，还可以利用 Objective-C 的一些其它功能。这意味着，开发者可以基于 Objective-C 中已有的熟悉、可靠的类、方法和框架来创建 Swift 类，并结合 Swift 提供的现代化和更有效的语言特点对其进行优化。</p>
<p><a name="inheriting_from_objective-c_classes"></a></p>
<h2 id="继承Objective-C的类">继承Objective-C的类</h2><p>在 Swift 中，开发者可以定义一个子类，该子类继承自使用 Objective-C 编写的类。创建该子类的方法是，在 Swift 的类名后面加上一个冒号（:），冒号后面跟上 Objective-C 的类名。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySwiftViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 定义类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开发者能够从 Objective-C 的父类中继承所有的功能。如果开发者要覆盖父类中的方法，不要忘记使用<code>override</code>关键字。</p>
<h3 id="NSCoding协议">NSCoding协议</h3><p><code>NSCoding</code>协议要求符合的类型实现所需的构造器<code>init(coder:)</code>。直接采用<code>NSCoding</code>协议的类必须实现这个方法。采用<code>NSCoding</code>协议的类的子类，这些类有一个或者多个自定义的构造器或者不带初始化值的属性，也必须实现这个方法。Xcode提供了以下占位实现来提醒：</p>
<pre><code>required init(coder aDecoder: NSCoder) {
<span class="code">    fatalError("init(coder:) has not been implemented")</span>
}
<span class="xml"><span class="comment"><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">对那些从 Storyboards 里加载的对象，或者用 NSUserDefaults 或 NSKeyedArchiver 类归档到磁盘的对象，你必须提供一个完整的初始化程序的实现。然而，当类型以此种方式无法实例化的时候，你可能并不需要实现构造器。</span><br><span class="line"></span><br><span class="line">&lt;a name=<span class="string">"adopting_protocols"</span>&gt;&lt;/a&gt;</span><br><span class="line"><span class="comment">## 采用协议</span></span><br><span class="line"></span><br><span class="line">在 Swift 中，开发者可以采用 Objective-C 中定义好的协议。和 Swift 协议一样，所有 Objective-C 协议都写在一个用逗号隔开的列表中，跟在所在类的父类名后面（如果它有父类的话）。</span><br><span class="line"></span><br><span class="line">`<span class="javascript"></span>``<span class="javascript">swift</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySwiftViewController</span>: <span class="title">UIViewController</span>, <span class="title">UITableViewDelegate</span>, <span class="title">UITableViewDataSource</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 定义类</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></span></span>

Objective-C 协议与 Swift 协议使用上是一致的。如果开发者想在 Swift 代码中引用 <span class="code">`UITableViewDelegate`</span>协议，可以直接使用<span class="code">`UITableViewDelegate`</span>（跟在 Objective-C 中引用<span class="code">`id&lt;UITableViewDelegate&gt;`</span>是等价的）。

因为在 Swift 中，类和协议的命名空间是统一的，Objective-C 里的 NSObject 协议被重新映射到 Swift 里的 NSObjectProtocol。

<span class="xml"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">name</span>=<span class="value">"writing_initializers_and_deinitializers"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="title">a</span>&gt;</span></span>
<span class="header">## 编写构造器和析构器</span>

Swift 的编译器确保在初始化时，构造器不允许类里有任何未初始化的属性，这样做能够增加代码的安全性和可预测性。另外，与 Objective-C 语言不同，Swift 不提供单独的内存分配方法供开发者调用。当你使用原生的 Swift 初始化方法时（即使是和 Objective-C 类协作），Swift 会将 Objective-C 的初始化方法转换为 Swift 的初始化方法。关于如何实现开发者自定义构造器的更多信息，请查看[<span class="link_label">构造器</span>](<span class="link_url">https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18</span>)。

当开发者希望在类被释放前，执行额外的清理工作时，需要执行一个析构过程来代替<span class="code">`dealloc`</span>方法。在实例被释放前，Swift 会自动调用析构器来执行析构过程。Swift 调用完子类的析构器后，会自动调用父类的析构器。当开发者使用 Objective-C 类或者是继承自 Objective-C 类的 Swift 类时，Swift 也会自动为开发者调用这个类的父类里的<span class="code">`dealloc`</span>方法。关于如何实现开发者自定义析构器的更多信息，请查看[析构器]https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift<span class="emphasis">_Programming_</span>Language/Deinitialization.html#//apple_ref/doc/uid/TP40014097-CH19)。

<span class="xml"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">name</span>=<span class="value">"integrating_with_interface_builder"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="title">a</span>&gt;</span></span>
<span class="header">## 集成Interface Builder</span>

Swift 编译器包含一些属性，使得开发者的 Swift 类集成了 Interface Builder 里的一些特色功能。和 Objective-C 里一样，你能在 Swift 里面使用 outlets，actions 和实时渲染（live rendering）。

<span class="header">### 使用Outlets和Action</span>

使用 Outlets 和 Action 可以连接源代码和 Interface Builder 的 UI 对象。在Swift里面使用 Outlets 和 Action，需要在属性和方法声明前插入<span class="code">`@IBOutlet`</span>或者<span class="code">`@IBAction`</span>关键字。声明一个 Outlet 集合同样是用<span class="code">`@IBOutlet`</span>属性，即为类型指定一个数组。

当开发者在 Swift 里面声明了一个 Outlet 时，Swift 编译器会自动将该类型转换为弱（weak）、隐式（implicitly）、未包装（unwrapped）的 optional（Objective-C 里面对应指针类型）数据类型，并为它分配一个初始化的空值<span class="code">`nil`</span>。实际上，编译器使用<span class="code">`@IBOutlet weak var name: Type! = nil`</span>来代替 <span class="code">`@IBOutlet var name: Type`</span>。编译器将该类型转换成了弱（weak）、隐式（implicitly）、未包装（unwrapped）的 optional 类型，因此开发者就不需要在构造器中为该类型分配一个初始值了。当开发者从故事板（storyboard）或者<span class="code">`xib`</span>文件里面初始化对象 class 后，定义好的 Outlet 和这些对象连接在一起了，所以，这些 Outlet 是隐式的，未包装的。由于创建的 outlets 一般都是弱关系，因此默认 outlets 是弱类型。

例如，下面的 Swift 代码声明了一个拥有 Outlet、Outlet 集合和 Action 的类：

<span class="xml"><span class="comment"><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="preprocessor">@IBOutlet</span> <span class="keyword">var</span> button: <span class="type">UIButton</span></span><br><span class="line"></span><br><span class="line">	<span class="preprocessor">@IBOutlet</span> <span class="keyword">var</span> textFields: <span class="type">UITextField</span>[]</span><br><span class="line"></span><br><span class="line">	<span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">buttonTapped</span><span class="params">(AnyObject)</span></span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"button tapped!"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></span></span>

在<span class="code">`buttonTapped`</span>方法中，消息发送者的信息没有被使用，因此可以省略该方法的参数名。

<span class="header">### 实时渲染（live rendering）</span>
开发者可以在 Interface Builder 中用<span class="code">`@IBDesignable`</span>和<span class="code">`@IBInspectable`</span>来创建生动、可交互的自定义视图（view）。开发者继承<span class="code">`UIView`</span>或者<span class="code">`NSView`</span>来自定义一个视图（view）时，可以在类声明前添加<span class="code">`@IBDesignable`</span>属性。当你在 Interface Builder 里添加了自定义的视图后（在监视器面板的自定义视图类中进行设置），Interface Builder 将在画布上渲染你自定义的视图。


&gt;注意：只能针对框架里对象进行实时渲染

你也可以将<span class="code">`@IBInspectable`</span>属性添加到和用户定义的运行时属性兼容的类型属性里。这样，当开发者将自定义的视图添加到 Interface Builder 里后，就可以在监视器面板中编辑这些属性。

<span class="xml"><span class="comment"><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">@IBDesignable</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCustomView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">	<span class="preprocessor">@IBInspectable</span> <span class="keyword">var</span> textColor: <span class="type">UIColor</span></span><br><span class="line">	<span class="preprocessor">@IBInspectable</span> <span class="keyword">var</span> iconHeight: <span class="type">CGFloat</span></span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></span></span>

<span class="xml"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">name</span>=<span class="value">"specifying_property_attributes"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="title">a</span>&gt;</span></span>
<span class="header">## 指明属性特性</span>

在 Objective-C 中，属性通常都有一组特性（Attributes）说明来指明该属性的一些附加信息。在 Swift 中，开发者可以通过不同的方法来指明属性的这些特性。

<span class="header">### 强类型和弱类型</span>

Swift 里属性默认都是强类型的。使用<span class="code">`weak`</span>关键字修饰一个属性，能指明其对象存储时是一个弱引用。该关键字仅能修饰 optional 对象类型。更多的信息，请查阅[<span class="link_label">特性</span>](<span class="link_url">https://github.com/CocoaChina-editors/Welcome-to-Swift/blob/master/The%20Swift%20Programming%20Language/02Language%20Guide/09Classes%20and%20Structures.md</span>)。

<span class="header">### 读／写和只读</span>

在 Swift 中，没有<span class="code">`readwrite`</span>和<span class="code">`readonly`</span>特性。当声明一个存储型属性时，使用<span class="code">`let`</span>修饰其为只读；使用<span class="code">`var`</span>修饰其为可读／写。当声明一个计算型属性时，为其提供一个 getter 方法，使其成为只读的；提供 getter 方法和 setter 方法，使其成为可读／写的。更多信息，请查阅[<span class="link_label">属性</span>](<span class="link_url">https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13</span>)。

<span class="header">### 拷贝</span>

在 Swift 中，Objective-C 的<span class="code">`copy`</span>特性被转换为<span class="code">`@NSCopying`</span>属性。这一类的属性必须遵守 <span class="code">`NSCopying`</span>协议。更多信息，请查阅[<span class="link_label">特性</span>](<span class="link_url">https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13</span>)。

<span class="xml"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">name</span>=<span class="value">"implementing_core_data_managed_object_subclasses"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="title">a</span>&gt;</span></span>
<span class="header">## 实现Core Data Managed Object子类</span>

Core Data 提供了基本存储和实现<span class="code">`NSManagedObject`</span>子类的一组属性。在与Core Data 模型中管理对象子类相关的特性或者关系的每个属性定义之前，将<span class="code">`@NSmanaged`</span>特性加入。与 Objective-C 里面的 <span class="code">`@dynamic`</span>特性类似，<span class="code">`@NSManaged`</span>特性告知 Swift 编译器，这个属性的存储和实现将在运行时完成。但是，与<span class="code">`@dynamic`</span>不同的是，<span class="code">`@NSManaged`</span>特性仅在 Core Data 支持中可用。

Swift 类被命名空间化---他们局限于被编译的模块中（最典型的是Target）。
为了使用带 Core Data 模型的<span class="code">`NSManagedObject`</span>类的 Swift 子类，在模型实体监视器的类区域里，用模块名字作为类名的前缀。

![](https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/Art/coredatanamespace_2x.png)

<span class="xml"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">name</span>=<span class="value">"using_swift_class_names_with_objective_c_apis"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="title">a</span>&gt;</span></span>
<span class="header">## 使用带Objective-C API的Swift类名</span>

Swift 类的命名基于他们被编译的模块，即使是使用来自 Objective-C 的代码。和 Objective-C 不同的是，所有的类都是全局命名空间的一部分，必须没有相同的名字，Swift 类可以基于他们存在的模块来消除歧义。比如，被称为 MyFramework 框架中的被叫做DataManager 的 Swift 类的全限定名就是 MyFramework.DataManager。一个 Swift 应用目标就是模块本身，所以，在一个叫 MyGreatApp 的应用里，叫 Observer 的 Swift 类的全限定名是 MyGreatApp.Observer。

为了保存在 Objective-C 代码里使用的 Swift 类，Swift类用他们的全限定名暴漏给 Objective-C 运行时。因此，当你使用那些对 Swift 类的字符串代表起作用的 API，必须包含类的全限定名。比如，当你创建一个基于文档的 Mac 应用，要在应用的 Info.plist 里提供 NSDocument 子类的名字。Swift里，你必须使用文档子类的全名，包括从你的应用或者框架里派生出来的模块名字。
<span class="code">    下面的例子中，`NSClassFromString`方法用于检索一个来自字符串代表的类的引用。为了检索 Swift 类，需要使用全限定名，包括应用的名字。</span>

<span class="code">```</span>    swift
let myPersonClass:AnyClass(NSClassFromString("MyGreatApp.Person"))
</code></pre></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&laquo;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/3/">&raquo;</a>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="https://avatars2.githubusercontent.com/u/14305708?v=3&s=460" alt="terry" itemprop="image"/>
          <p class="site-author-name" itemprop="name">terry</p>
        </div>
        <p class="site-description motion-element" itemprop="description">terry yang's blog | java | scala | bi</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">130</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">11</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-next-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yangwei8888" target="_blank">github</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/microsoftgoogles" target="_blank">weibo</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/run-zhi-38" target="_blank">zhihu</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">terry</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  

    <script type="text/javascript">
      var disqus_shortname = 'yangwei888';
      var disqus_identifier = 'page/2/index.html';
      var disqus_title = '';
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
