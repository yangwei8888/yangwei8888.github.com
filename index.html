<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="terry yang's blog | java | scala | bi" />



  <meta name="keywords" content="Hexo,next" />



  <link rel="alternate" href="/atom.xml" title="yosita" type="application/atom+xml" />



  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="terry yang&apos;s blog | java | scala | bi">
<meta property="og:type" content="website">
<meta property="og:title" content="yosita">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="yosita">
<meta property="og:description" content="terry yang&apos;s blog | java | scala | bi">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="yosita">
<meta name="twitter:description" content="terry yang&apos;s blog | java | scala | bi">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>

  <title> yosita </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  

  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?953e46480b0a75d01aaf6d872cc77099";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">yosita</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/31/jsdoc/" itemprop="url">
                JavaScript 资源大全中文版
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-31T07:56:29+08:00" content="2015-12-31">
            2015-12-31
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/blog/" itemprop="url" rel="index">
                  <span itemprop="name">blog</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/31/jsdoc/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/31/jsdoc/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="JavaScript_资源大全中文版">JavaScript 资源大全中文版</h1><p>我想很多程序员应该记得 GitHub 上有一个 Awesome - XXX 系列的资源整理。<a href="https://github.com/sorrycc/awesome-javascript" target="_blank" rel="external">awesome-javascript</a> 是 sorrycc 发起维护的 JS 资源列表，内容包括：包管理器、加载器、测试框架、运行器、QA、MVC框架和库、模板引擎、数据可视化、时间轴、编辑器等等</p>
<p>Awesome 系列虽然挺全，但基本只对收录的资源做了极为简要的介绍，如果有更详细的中文介绍，对相应开发者的帮助会更大。这也是我们发起这个开源项目的初衷。</p>
<hr>
<h3 id="我们要做什么？">我们要做什么？</h3><ul>
<li>基于 awesome-javascript 列表，我们将对其中的各个资源项进行编译整理。此外还将从其他来源补充好资源。</li>
<li>整理后的内容，将收录在<a href="http://hao.jobbole.com/" target="_blank" rel="external">伯乐在线资源频道</a>。可参考已整理的内容：<ul>
<li>《<a href="http://hao.jobbole.com/jqwidgets-jquery-html5-ui/" target="_blank" rel="external">jQWidgets：jQuery HTML5 UI组件框架</a>》</li>
<li>《<a href="http://hao.jobbole.com/bootstrap/" target="_blank" rel="external">Bootstrap：Web前端开发框架</a>》</li>
<li>《<a href="http://hao.jobbole.com/yui-compressor/" target="_blank" rel="external">YUI Compressor：JS/CSS压缩工具</a>》</li>
</ul>
</li>
</ul>
<hr>
<h3 id="如何参与本项目？">如何参与本项目？</h3><p>从下面的目录来看，本项目的工作量小不了，所以非常期待能有更多程序员一起来参与。</p>
<p>不过加入前，有几个小要求：</p>
<ul>
<li>英文还不错，能读懂英文并用自己的话复述；</li>
<li>在用 JavaScript；</li>
</ul>
<p>如有兴趣，请加 QQ：50872495。加 Q 时请注明「JS大全」</p>
<hr>
<h3 id="本项目的参与者">本项目的参与者</h3><ul>
<li>维护者：</li>
<li>贡献者：刘健超、MissNull、一兮、Mr. Somebody、Jason Lee、<a href="http://www.jobbole.com/members/ivanberry/" target="_blank" rel="external">Tab_Gre</a>、<a href="http://www.jobbole.com/members/KeepMoving/" target="_blank" rel="external">GavinZhang</a>、<a href="https://github.com/shadowkimi520/" target="_blank" rel="external">shadowkimi520</a>、<a href="http://www.jobbole.com/members/zhoutk/" target="_blank" rel="external">zhoutk</a></li>
</ul>
<p>注：名单不分排名，不定期补充更新</p>
<hr>
<h3 id="目录">目录</h3><ul>
<li><a href="#awesome-javascript-cn">JavaScript资源大全中文版</a><ul>
<li><a href="#package-managers">包管理器</a></li>
<li><a href="#loaders">加载器</a></li>
<li><a href="#bundlers">打包工具</a></li>
<li><a href="#testing-frameworks">测试框架</a></li>
<li><a href="#qa-tools">QA 工具</a></li>
<li><a href="#mvc-frameworks-and-libraries">MVC 框架和库</a></li>
<li><a href="#node-powered-cms-frameworks">基于 Node 的 CMS 框架</a></li>
<li><a href="#templating-engines">模板引擎</a></li>
<li><a href="#data-visualization">数据可视化</a><ul>
<li><a href="#timeline">时间轴</a></li>
</ul>
</li>
<li><a href="#editors">编辑器</a></li>
<li>工具<ul>
<li><a href="#files">文件</a></li>
<li><a href="#functional-programming">函数式编程</a></li>
<li><a href="#reactive-programming">响应式编程</a></li>
<li><a href="#data-structure">数据结构</a></li>
<li><a href="#date">日期</a></li>
<li><a href="#string">字符串</a></li>
<li><a href="#number">数字</a></li>
<li><a href="#storage">存储</a></li>
<li><a href="#color">颜色</a></li>
<li><a href="#i18n-and-l10n">国际化和本地化</a></li>
<li><a href="#class">类</a></li>
<li><a href="#control-flow">控制流</a></li>
<li><a href="#routing">路由</a></li>
<li><a href="#security">安全性</a></li>
<li><a href="#log">日志</a></li>
<li><a href="#regexp">正则表达式</a></li>
<li><a href="#media">媒体</a></li>
<li><a href="#voice-command">语言命令</a></li>
<li><a href="#api">API</a></li>
<li><a href="#vision-detection">视觉检测</a></li>
<li><a href="#browser-detection">浏览器检测</a></li>
</ul>
</li>
<li>UI<ul>
<li><a href="#code-highlighting">代码高亮</a></li>
<li><a href="#loading-status">加载状态</a></li>
<li><a href="#validation">验证</a></li>
<li><a href="#keyboard-wrappers">键盘封装器</a></li>
<li><a href="#tours-and-guides">浏览和引导</a></li>
<li><a href="#notifications">通知</a></li>
<li><a href="#sliders">幻灯片</a></li>
<li><a href="#range-sliders">滑块控件</a></li>
<li><a href="#form-widgets">表单组件</a></li>
<li><a href="#tips">提示</a></li>
<li><a href="#modals-and-popups">模态框和弹出框</a></li>
<li><a href="#scroll">滚动条</a></li>
<li><a href="#menu">菜单</a></li>
<li><a href="#table-grid">表格/栅格</a></li>
<li><a href="#frameworks-1">框架</a></li>
</ul>
</li>
<li>移动<ul>
<li><a href="#gesture">手势</a></li>
</ul>
</li>
<li><a href="#maps">地图</a></li>
<li><a href="#video-audio">视频/音频</a></li>
<li><a href="#animations">动画</a></li>
<li><a href="#image-processing">图片处理</a></li>
<li><a href="#es6">ES6</a></li>
<li><a href="#sdk">SDK</a></li>
<li><a href="#misc">大杂烩</a></li>
</ul>
</li>
<li><a href="#worth-reading">精品阅读</a></li>
</ul>
<ul>
<li><a href="#resources">资源</a><ul>
<li><a href="#communities">社区</a></li>
<li><a href="#influential-books">有影响力的书</a></li>
<li><a href="#weibo-weixin">微博、微信公众号</a></li>
<li><a href="#websites">知名网站</a></li>
<li><a href="blogs">博客</a></li>
</ul>
</li>
</ul>
<hr>
<h2 id="package-managers">包管理器</h2>

<p>管理着 javascript 库，并提供读取和打包它们的工具。</p>
<ul>
<li>npm：npm 是 javascript 的包管理器。<a href="https://www.npmjs.com/" target="_blank" rel="external">官网</a></li>
<li>Bower：一个 web 应用的包管理器。<a href="https://github.com/bower/bower" target="_blank" rel="external">官网</a></li>
<li>component：能构建更好 web 应用的客户端包管理器。<a href="https://github.com/component/component" target="_blank" rel="external">官网</a></li>
<li>spm：全新的静态包管理器。<a href="https://github.com/spmjs/spm" target="_blank" rel="external">官网</a></li>
<li>jam：一个专注于浏览器端和兼容 RequireJS 的包管理器。<a href="https://github.com/caolan/jam" target="_blank" rel="external">官网</a></li>
<li>jspm：流畅的浏览器包管理器。<a href="https://github.com/jspm/jspm-cli" target="_blank" rel="external">官网</a></li>
<li>Ender：没有库文件的程序库。<a href="https://github.com/ender-js/Ender" target="_blank" rel="external">官网</a></li>
<li>volo：以项目模板、添加依赖项与自动化生成的方式创建前端项目。<a href="https://github.com/volojs/volo" target="_blank" rel="external">官网</a> </li>
<li>Duo：一个整合 Component、Browserify 和 Go <a href="https://github.com/duojs/duo" target="_blank" rel="external">官网</a>的最佳思想，使开发者能快速方便地组织和编写前端代码的下一代包管理器。</li>
</ul>
<h2 id="loaders">加载器</h2>

<p>JavaScript 的模块或加载系统。</p>
<ul>
<li>RequireJS：JavaScript 文件和模块的加载器。<a href="https://github.com/jrburke/requirejs" target="_blank" rel="external">官网</a></li>
<li>browserify：在浏览器端以 node.js 的方式 require()。<a href="https://github.com/substack/node-browserify" target="_blank" rel="external">官网</a></li>
<li>SeaJS：用于 Web 的模块加载器。<a href="https://github.com/seajs/seajs" target="_blank" rel="external">官网</a></li>
<li>HeadJS：HEAD 的唯一脚本。<a href="https://github.com/headjs/headjs" target="_blank" rel="external">官网</a></li>
<li>curl：小巧、快速且易扩展的模块加载器，它能处理 AMD、CommonJS Modules/1.1、CSS、HTML/text 和历史脚本。<a href="https://github.com/cujojs/curl" target="_blank" rel="external">官网</a></li>
<li>lazyload：小巧且无依赖的异步 JavaScript 和 CSS 加载器。<a href="https://github.com/rgrove/lazyload/" target="_blank" rel="external">官网</a></li>
<li>script.js：异步 JavaScript 加载器和依赖管理器。<a href="https://github.com/ded/script.js" target="_blank" rel="external">官网</a></li>
<li>systemjs：AMD、CJS（commonJS） 和符合 ES6 规范的模块加载器。<a href="https://github.com/systemjs/systemjs" target="_blank" rel="external">官网</a></li>
<li>LodJS：基于 AMD 的模块加载器。<a href="https://github.com/yanhaijing/lodjs" target="_blank" rel="external">官网</a></li>
<li>ESL：浏览器端的模块加载器，支持延迟定义和 AMD。<a href="https://github.com/ecomfe/esl" target="_blank" rel="external">官网</a></li>
<li>modulejs：轻量的 JavaScript 模块系统。<a href="https://github.com/lrsjng/modulejs" target="_blank" rel="external">官网</a></li>
</ul>
<h2 id="bundlers">打包工具</h2>

<ul>
<li>browserify ：Browserify 让你能在浏览器端使用 require(‘modules’) ，打包所有依赖。<a href="https://github.com/substack/node-browserify" target="_blank" rel="external">官网</a></li>
<li>webpack：为浏览器打包 CommonJs/AMD 模块。<a href="https://github.com/webpack/webpack" target="_blank" rel="external">官网</a></li>
</ul>
<h2 id="testing-frameworks">测试框架</h2>

<h3 id="框架">框架</h3><ul>
<li>mocha：适用于 node.js 和浏览器、简易、灵活、有趣的 JavaScript 测试框架。<a href="https://github.com/visionmedia/mocha" target="_blank" rel="external">官网</a></li>
<li>jasmine：简单无 DOM 的 JavaScript 测试框架。<a href="https://github.com/pivotal/jasmine" target="_blank" rel="external">官网</a></li>
<li>qunit：一个易于使用的 JavaScript 单元测试框架。<a href="https://github.com/jquery/qunit" target="_blank" rel="external">官网</a></li>
<li>jest：简单的 JavaScript 单元测试框架。<a href="http://github.com/facebook/jest" target="_blank" rel="external">官网</a></li>
<li>prova：基于 Tape 和 Browserify 的测试运行器，它适用于 Node &amp; 浏览器。<a href="http://github.com/azer/prova" target="_blank" rel="external">官网</a></li>
<li>DalekJS：自动化且跨浏览器的 JavaScript 功能测试框架。<a href="https://github.com/dalekjs/dalek" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="断言">断言</h3><ul>
<li>chai：适用于 node.js 和浏览器的 BDD / TDD 断言框架，并能搭配其它测试框架使用。<a href="https://github.com/chaijs/chai" target="_blank" rel="external">官网</a></li>
<li>Sinon.JS：对 JavaScript 进行 spies、stubs 和 mock 测试。<a href="https://github.com/cjohansen/Sinon.JS" target="_blank" rel="external">官网</a></li>
<li>expect.js：简约的、适用于 Node.js 和浏览器端的 BDD 式断言工具。<a href="https://github.com/LearnBoost/expect.js" target="_blank" rel="external">官网</a></li>
<li>should.js：适用于 Node.js 的 BDD 式断言工具。<a href="https://github.com/tj/should.js" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="覆盖率">覆盖率</h3><ul>
<li>istanbul：另一个 JS 代码覆盖率检测工具。<a href="https://github.com/gotwarlost/istanbul" target="_blank" rel="external">官网</a></li>
<li>blanket：一个简单的代码覆盖率检测库。它的设计理念是易于安装和使用，且可用于浏览器端和 node.js。<a href="https://github.com/alex-seville/blanket" target="_blank" rel="external">官网</a></li>
<li>JSCover：JSCover 是一个检测 JavaScript 程序代码覆盖率的工具。<a href="https://github.com/tntim96/JSCover" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="运行器">运行器</h3><ul>
<li>phantomjs：脚本化的 Headless WebKit。<a href="https://github.com/ariya/phantomjs" target="_blank" rel="external">官网</a></li>
<li>slimerjs：一个内核为 Gecko 的类似 PhantomJS 工具。<a href="https://github.com/laurentj/slimerjs" target="_blank" rel="external">官网</a></li>
<li>casperjs：基于 PhantomJS 和 Slimer JS 的导航脚本和测试工具。<a href="https://github.com/n1k0/casperjs" target="_blank" rel="external">官网</a> </li>
<li>zombie：基于 node.js 、快速、全栈且无图形界面的浏览器的测试工具。<a href="https://github.com/assaf/zombie" target="_blank" rel="external">官网</a></li>
<li>totoro：一个简单可靠且能跨浏览器运行的测试工具。<a href="https://github.com/totorojs/totoro" target="_blank" rel="external">官网</a></li>
<li>karma：一个优秀的的 JavaScript 测试运行器。<a href="https://github.com/karma-runner/karma" target="_blank" rel="external">官网</a></li>
<li>nightwatch：基于 node.js 和 selenium webdriver 的图形界面自动化测试框架。<a href="https://github.com/beatfactor/nightwatch" target="_blank" rel="external">官网</a></li>
<li>intern：下一代 JavaScript 代码测试栈。<a href="https://github.com/theintern/intern" target="_blank" rel="external">官网</a></li>
<li>yolpo：在浏览器逐句执行的 JavaScript 解释器。<a href="http://www.yolpo.com/" target="_blank" rel="external">官网</a></li>
</ul>
<h2 id="qa-tools">QA 工具</h2>

<ul>
<li>JSHint：JSHint 是一个有助于发现 JavaScript 代码错误和潜在问题的工具。<a href="https://github.com/jshint/jshint/" target="_blank" rel="external">官网</a></li>
<li>jscs：JavaScript 代码风格检测工具。<a href="https://github.com/jscs-dev/node-jscs" target="_blank" rel="external">官网</a></li>
<li>jsfmt：格式化、搜索和改写 JavaScript。<a href="https://github.com/rdio/jsfmt" target="_blank" rel="external">官网</a></li>
<li>jsinspect：检测复制粘贴和结构类似的代码。<a href="https://github.com/danielstjules/jsinspect" target="_blank" rel="external">官网</a></li>
<li>buddy.js：发现 JavaScript 代码里的 <a href="https://zh.wikipedia.org/wiki/%E9%AD%94%E8%A1%93%E6%95%B8%E5%AD%97" target="_blank" rel="external">魔术数字</a>。<a href="https://github.com/danielstjules/buddy.js" target="_blank" rel="external">官网</a></li>
<li>ESLint：完全插件化的工具，能在 JavaScript 中识别和记录模式。<a href="https://github.com/eslint/eslint" target="_blank" rel="external">官网</a></li>
<li>JSLint ：高标准、严格和固执的代码质量工具，旨在只保持语言的优良部分。<a href="https://github.com/douglascrockford/JSLint" target="_blank" rel="external">官网</a></li>
</ul>
<h2 id="mvc-frameworks-and-libraries">MVC 框架和库</h2>

<ul>
<li>angular.js ：为网络应用增强 HTML。<a href="https://github.com/angular/angular.js" target="_blank" rel="external">官网</a></li>
<li>aurelia：一个适用于移动设备、桌面电脑和 web 的客户端 JavaScript 框架。<a href="http://aurelia.io/" target="_blank" rel="external">官网</a></li>
<li>backbone：给你的 JS 应用加入带有 Models、Views、Collections 和 Events 的 Backbone。<a href="https://github.com/jashkenas/backbone" target="_blank" rel="external">官网</a></li>
<li>batman.js：最适合 Rails 开发者的 JavaScript 框架。<a href="http://batmanjs.org/" target="_blank" rel="external">官网</a></li>
<li>ember.js：一个旨在创建非凡 web 应用的 JavaScript 框架。<a href="https://github.com/emberjs/ember.js" target="_blank" rel="external">官网</a></li>
<li>meteor：一个超简单的、数据库无处不在的、只传输数据的纯 JavaScript web 框架。<a href="https://github.com/meteor/meteor" target="_blank" rel="external">官网</a></li>
<li>ractive：新一代 DOM 操作。<a href="https://github.com/ractivejs/ractive" target="_blank" rel="external">官网</a></li>
<li>vue：一个用于构建可交互界面的、直观快速和可组合的 MVVM 框架。<a href="https://github.com/yyx990803/vue" target="_blank" rel="external">官网</a> </li>
<li>knockout：Knockout 用 JavaScript 让创建响应式的富 UI 更加容易。<a href="https://github.com/knockout/knockout" target="_blank" rel="external">官网</a> </li>
<li>spine：构建 JavaScript 应用的轻量 MVC 库。<a href="https://github.com/spine/spine" target="_blank" rel="external">官网</a></li>
<li>espresso.js：一个极小的、用于制作用户界面的 JavaScript 库。<a href="https://github.com/techlayer/espresso.js" target="_blank" rel="external">官网</a></li>
<li>canjs：让 JS 更好、更快、更简单。<a href="https://github.com/bitovi/canjs" target="_blank" rel="external">官网</a></li>
<li>react：用于建构用户界面的库。它是声明式的、高效的和极度灵活的，并使用虚拟 DOM 作为其不同的实现。<a href="https://facebook.github.io/react/" target="_blank" rel="external">官网</a></li>
<li>react-native：一个用 React 构建原生应用的框架。<a href="https://github.com/facebook/react-native" target="_blank" rel="external">官网</a></li>
<li>riot：类 React 库，但很轻量。<a href="https://github.com/riot/riot" target="_blank" rel="external">官网</a></li>
<li>thorax：加强你的 Backbone。<a href="https://github.com/walmartlabs/thorax" target="_blank" rel="external">官网</a></li>
<li>chaplin：使用 Backbone.js 库的 JavaScript 应用架构。<a href="https://github.com/chaplinjs/chaplin" target="_blank" rel="external">官网</a></li>
<li>marionette：一个 Backbone.js 的复合应用程序库，旨在简化大型 JavaScript 应用结构。<a href="https://github.com/marionettejs/backbone.marionette" target="_blank" rel="external">官网</a></li>
<li>ripple：一个小巧的、用于构建响应界面的基础框架。<a href="https://github.com/ripplejs/ripple" target="_blank" rel="external">官网</a></li>
<li>rivets：轻量却拥有强大的数据绑定和模板解决方案<a href="https://github.com/mikeric/rivets" target="_blank" rel="external">官网</a></li>
<li>derby：让编写实时和协同应用更简单的 MVC 框架，能够在 Node.js 和浏览器同时运行。<a href="https://github.com/derbyjs/derby" target="_blank" rel="external">官网</a><ul>
<li>derby-awesome：很棒的 derby 组件集合。<a href="https://github.com/onerussell/awesome-derby" target="_blank" rel="external">官网</a></li>
</ul>
</li>
<li><a href="http://hao.jobbole.com/way-js/" target="_blank" rel="external">way.js</a>：简单、轻量、持久化的双向数据绑定。<a href="https://github.com/gwendall/way.js" target="_blank" rel="external">官网</a></li>
<li>mithril.js：Mithril 是一个客户端 MVC 框架（轻量、强大和快速）<a href="https://github.com/lhorie/mithril.js" target="_blank" rel="external">官网</a></li>
<li>jsblocks：jsblocks 是一个更好的 MV-ish 框架。<a href="https://github.com/astoilkov/jsblocks" target="_blank" rel="external">官网</a></li>
<li>LiquidLava：易懂的、用于构建用户界面的 MVC 框架。<a href="http://www.lava-framework.com/" target="_blank" rel="external">官网</a></li>
</ul>
<h2 id="node-powered-cms-frameworks">基于 Node 的 CMS 框架</h2>

<ul>
<li>KeystoneJS：强大的 CMS 和 web 应用框架。<a href="https://github.com/keystonejs/keystone" target="_blank" rel="external">官网</a></li>
<li>Reaction Commerce：拥有实时的架构和设计的响应式（reactive） CMS。<a href="https://github.com/reactioncommerce/reaction" target="_blank" rel="external">官网</a></li>
<li>Ghost：简单、强大的发布平台。<a href="https://github.com/tryghost/Ghost" target="_blank" rel="external">官网</a></li>
<li>Apostrophe：提供内容编辑和基本服务的 CMS。<a href="https://github.com/punkave/apostrophe" target="_blank" rel="external">官网</a></li>
<li>We.js：适用于实时应用、网站或博客的框架。<a href="https://github.com/wejs/we/" target="_blank" rel="external">官网</a></li>
<li>Hatch.js：拥有社交特性的 CMS 平台。<a href="https://github.com/inventures/hatchjs" target="_blank" rel="external">官网</a></li>
<li>TaracotJS：拥有快速、极简风格特点且基于Node.js 的 CMS。<a href="https://github.com/xtremespb/taracotjs-generator/" target="_blank" rel="external">官网</a></li>
<li>Nodizecms：为 CoffeeScript 爱好者准备的 CMS。<a href="https://github.com/nodize/nodizecms" target="_blank" rel="external">官网</a></li>
<li>Cody：拥有所见即所得的编辑器的 CMS。<a href="https://github.com/jcoppieters/cody" target="_blank" rel="external">官网</a></li>
<li>PencilBlue：CMS 和博客平台。<a href="https://github.com/pencilblue/pencilblue/" target="_blank" rel="external">官网</a></li>
</ul>
<h2 id="templating-engines">模板引擎</h2>

<p>模板引擎允许您执行字符串插值。</p>
<ul>
<li>mustache.js：是 JavaScript 中带有  的最简模板。<a href="https://github.com/janl/mustache.js" target="_blank" rel="external">官网</a></li>
<li>handlebars.js：是 Mustache 模板语言的扩展。<a href="https://github.com/wycats/handlebars.js/" target="_blank" rel="external">官网</a></li>
<li>hogan.js：是 Mustache 模板语言的编译器。<a href="https://github.com/twitter/hogan.js" target="_blank" rel="external">官网</a></li>
<li>doT：最快速简洁的 JavaScript 模板引擎，适用于 nodejs 和浏览器。<a href="https://github.com/olado/doT" target="_blank" rel="external">官网</a></li>
<li>dustjs：适用于浏览器和 node.js 的异步模板。<a href="https://github.com/linkedin/dustjs/" target="_blank" rel="external">官网</a></li>
<li>eco：嵌入式的 CoffeeScript 模板。<a href="https://github.com/sstephenson/eco/" target="_blank" rel="external">官网</a></li>
<li>JavaScript-Templates：轻量（小于 1KB）、快速且无依赖的强大 JavaScript 模版引擎。<a href="https://github.com/blueimp/JavaScript-Templates" target="_blank" rel="external">官网</a></li>
<li>t.js：小巧的 JavaScript 模板框架，压缩后约为 400 字节。<a href="https://github.com/jasonmoo/t.js" target="_blank" rel="external">官网</a></li>
<li>Jade：健壮的、优雅且功能丰富的 nodejs 模板引擎。<a href="https://github.com/jadejs/jade" target="_blank" rel="external">官网</a></li>
<li>EJS：高效的 JavaScript 模板。<a href="https://github.com/mde/ejs" target="_blank" rel="external">官网</a></li>
<li>xtemplate：可扩展的模板引擎，适用于 node 和浏览器。<a href="https://github.com/xtemplate/xtemplate" target="_blank" rel="external">官网</a></li>
<li>marko：快速轻量且基于 HTML 的模板引擎，支持异步、流、自定义标签和 CommonJS 模编译后输出。适用于 Node.js <a href="https://github.com/marko-js/marko" target="_blank" rel="external">官网</a>和浏览器。</li>
</ul>
<h2 id="data visualization">数据可视化</h2>

<p>Web 数据可视化工具</p>
<ul>
<li>d3：一个对 HTML 和 SVG 进行可视化的 JavaScript 库。<a href="https://github.com/mbostock/d3" target="_blank" rel="external">官网</a></li>
<li>metrics-graphics：更简洁和拥有更规范的数据图表布局优化算法的库。<a href="https://github.com/mozilla/metrics-graphics" target="_blank" rel="external">官网</a></li>
<li>pykcharts.js：经过精心设计后，去除 d3.js 复杂性的 d3.js 图表库。<a href="https://github.com/pykih/PykCharts.js" target="_blank" rel="external">官网</a></li>
<li>three.js：JavaScript 3D 库。<a href="https://github.com/mrdoob/three.js" target="_blank" rel="external">官网</a></li>
<li>Chart.js：简单的、基于 canvas 标签的 HTML5 图表库。<a href="https://github.com/nnnick/Chart.js" target="_blank" rel="external">官网</a></li>
<li>paper.js：是矢量图形脚本中的瑞士军刀 —— 使用 HTML5 Canvas 将 Scriptographer  移植到 JavaScript <a href="https://github.com/paperjs/paper.js" target="_blank" rel="external">官网</a>和浏览器。</li>
<li>fabric.js：JavaScript Canvas 库，SVG 与 Canvas 可以相互解析。<a href="https://github.com/kangax/fabric.js" target="_blank" rel="external">官网</a></li>
<li>peity：进度条、线状和饼状图。<a href="https://github.com/benpickles/peity" target="_blank" rel="external">官网</a></li>
<li>raphael：JavaScript 矢量库。<a href="https://github.com/DmitryBaranovskiy/raphael" target="_blank" rel="external">官网</a></li>
<li>echarts：商业产品图表。<a href="https://github.com/ecomfe/echarts" target="_blank" rel="external">官网</a></li>
<li>vis：动态的、基于浏览器的可视化库。<a href="https://github.com/almende/vis" target="_blank" rel="external">官网</a></li>
<li>two.js：一个渲染器无关的适用于 web 的二维绘图 api 。<a href="https://github.com/jonobr1/two.js" target="_blank" rel="external">官网</a></li>
<li>g.raphael：基于 Raphaël 图表库。<a href="https://github.com/DmitryBaranovskiy/g.raphael" target="_blank" rel="external">官网</a></li>
<li>sigma.js：一个致力于图形绘画的 JavaScript 库。<a href="https://github.com/jacomyal/sigma.js" target="_blank" rel="external">官网</a></li>
<li>arbor：一个使用 web workers 和 jQuery 的图形可视化库。<a href="https://github.com/samizdatco/arbor" target="_blank" rel="external">官网</a></li>
<li>cubism：可视化时间序列的 D3 插件。<a href="https://github.com/square/cubism" target="_blank" rel="external">官网</a></li>
<li>dc.js：与 crossfilter 无缝合作的多维图表绘制库，使用 d3.js 渲染。<a href="https://github.com/dc-js/dc.js" target="_blank" rel="external">官网</a></li>
<li>vega：一套可视化语法。<a href="https://github.com/trifacta/vega" target="_blank" rel="external">官网</a></li>
<li>processing.js：Processing.js 基于 Web 标准使数据可视化，而无需任何插件。<a href="http://processingjs.org/" target="_blank" rel="external">官网</a></li>
<li>envisionjs：动态的 HTML5 可视化。<a href="https://github.com/HumbleSoftware/envisionjs" target="_blank" rel="external">官网</a></li>
<li>rickshaw：用于构建交互式实时图表的 JavaScript 工具包。<a href="https://github.com/shutterstock/rickshaw" target="_blank" rel="external">官网</a></li>
<li>flot：吸引人的、基于 jQuery 的 JavaScript 图表库。<a href="https://github.com/flot/flot" target="_blank" rel="external">官网</a></li>
<li>morris.js：漂亮的时间序列线框图。<a href="https://github.com/morrisjs/morris.js" target="_blank" rel="external">官网</a></li>
<li>nvd3：一个为 D3.js 构建可复用图表和图表组件的库。<a href="https://github.com/novus/nvd3" target="_blank" rel="external">官网</a></li>
<li>svg.js：一个轻量的、用于操作和添加 SVG 动画的库。<a href="https://github.com/wout/svg.js" target="_blank" rel="external">官网</a></li>
<li>heatmap.js：基于 HTML5 canvas 的热力图 JavaScript 库。<a href="https://github.com/pa7/heatmap.js" target="_blank" rel="external">官网</a></li>
<li>jquery.sparkline：一个直接在浏览器端生成小型走势图的 jQuery 插件。<a href="https://github.com/gwatts/jquery.sparkline" target="_blank" rel="external">官网</a></li>
<li>xCharts：一个基于 D3、用于构建自定义图表和图形的库。<a href="https://github.com/tenxer/xCharts" target="_blank" rel="external">官网</a></li>
<li>trianglify：基于 d3.js 的低多边形（low poly）风格背景图片生成器。<a href="https://github.com/qrohlf/trianglify" target="_blank" rel="external">官网</a></li>
<li>d3-cloud：创建词云（word cloud）效果的 JavaScript 库。<a href="https://github.com/jasondavies/d3-cloud" target="_blank" rel="external">官网</a></li>
<li>d4：一个基于 D3 、友好、可复用的 DSL 图表库 。<a href="https://github.com/heavysixer/d4" target="_blank" rel="external">官网</a></li>
<li>dimple.js：基于 d3 的简易商业分析图表库。<a href="http://dimplejs.org/" target="_blank" rel="external">官网</a></li>
<li>chartist-js：简单的响应式图表。<a href="https://github.com/gionkunz/chartist-js" target="_blank" rel="external">官网</a></li>
<li>epoch：一个通用的实时图表库。<a href="https://github.com/fastly/epoch" target="_blank" rel="external">官网</a></li>
<li>c3：基于 D3 的可复用图表库。<a href="https://github.com/masayuki0812/c3" target="_blank" rel="external">官网</a></li>
<li>BabylonJS：一个运用 HTML5 和 WebGL 构建 3D 游戏的框架。<a href="https://github.com/BabylonJS/Babylon.js" target="_blank" rel="external">官网</a></li>
</ul>
<p>也有一些很棒的收费库，如 <a href="http://www.amcharts.com/" target="_blank" rel="external">amchart</a>、<a href="https://www.plot.ly/" target="_blank" rel="external">plotly</a> 和 <a href="http://www.highcharts.com/" target="_blank" rel="external">highchart</a>。</p>
<h3 id="timeline">时间轴</h3>

<ul>
<li>TimelineJS： 一个用 JavaScript 编写的可叙事时间轴库。<a href="https://github.com/NUKnightLab/TimelineJS" target="_blank" rel="external">官网</a></li>
<li>timesheet.js：用于构建简单的 HTML5 &amp; CSS3 时间表的 JavaScript 库。<a href="https://github.com/semu/timesheet.js" target="_blank" rel="external">官网</a></li>
</ul>
<h2 id="editors">编辑器</h2>

<ul>
<li>ace：Ace（Ajax.org Cloud9 Editor）。<a href="https://github.com/ajaxorg/ace" target="_blank" rel="external">官网</a></li>
<li>CodeMirror：浏览器端的代码编辑器。<a href="https://github.com/marijnh/CodeMirror" target="_blank" rel="external">官网</a></li>
<li>esprima：用于综合分析的 ECMAScript 解析器。<a href="https://github.com/ariya/esprima" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/quill/" target="_blank" rel="external">quill</a>：一个带有 API 的跨浏览器富文本编辑器。(<a href="http://quilljs.com/" target="_blank" rel="external">官网</a>)</li>
<li>medium-editor：Medium.com 所见即所得编辑器的克隆版。<a href="https://github.com/daviferreira/medium-editor" target="_blank" rel="external">官网</a></li>
<li>pen：享受在线编辑（支持 markdown）。<a href="https://github.com/sofish/pen" target="_blank" rel="external">官网</a></li>
<li>jquery-notebook：一个易用的、简洁优雅的文本编辑器。灵感来源于 Medium 的魅力。<a href="https://github.com/raphaelcruzeiro/jquery-notebook" target="_blank" rel="external">官网</a></li>
<li>bootstrap-wysiwyg：小巧的、兼容 bootstrap 的所见即所得的富文本编辑器。<a href="https://github.com/mindmup/bootstrap-wysiwyg" target="_blank" rel="external">官网</a></li>
<li>ckeditor-releases：适用于每个人的 web 文本编辑器。<a href="https://github.com/ckeditor/ckeditor-releases" target="_blank" rel="external">官网</a></li>
<li>editor：一个 markdown 编辑器，但仍在开发中。<a href="https://github.com/lepture/editor" target="_blank" rel="external">官网</a></li>
<li>EpicEditor：一个可嵌入的 JavaScript Markdown <a href="https://github.com/OscarGodson/EpicEditor" target="_blank" rel="external">官网</a>的编辑器，拥有全屏编辑、即时预览、自动保存草稿和离线支持等功能。</li>
<li>jsoneditor：查看、编辑和格式化 JSON 的 web 工具。<a href="https://github.com/josdejong/jsoneditor" target="_blank" rel="external">官网</a></li>
<li>vim.js： 拥有持久化 ~/.vimrc 的 Vim 编辑器的 JavaScript 移植版本。<a href="https://github.com/coolwanglu/vim.js" target="_blank" rel="external">官网</a></li>
<li>Squire：HTML5 富文本编辑器。<a href="https://github.com/neilj/Squire" target="_blank" rel="external">官网</a></li>
<li>TinyMCE：JavaScript 富文本编辑器。<a href="https://github.com/tinymce/tinymce" target="_blank" rel="external">官网</a></li>
<li>trix：由 Basecamp 制作，适用于每天写作的富文本编辑器。<a href="https://github.com/basecamp/trix" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="files">文件</h3>

<p>处理文件的库。</p>
<ul>
<li>Papa Parse：一款强大的 CSV 库，支持解析 CSV 文件/字符串，也能导出 CSV。<a href="https://github.com/mholt/PapaParse" target="_blank" rel="external">官网</a></li>
<li>jBinary：对用声明式语法描述文件类型和数据结构的二进制文件，进行高级 I/O（加载、解析、操作、序列化、存储）操作。<a href="https://github.com/jDataView/jBinary" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="functional-programming">函数式编程</h3>

<p>函数式编程库扩展了 JavaScript 的能力。</p>
<ul>
<li><a href="http://hao.jobbole.com/underscore/" target="_blank" rel="external">underscore</a>：JavaScript 的实用工具。<a href="https://github.com/jashkenas/underscore" target="_blank" rel="external">官网</a></li>
<li>lodash：提供一致性、可定制、高性能和额外功能的实用库。<a href="https://github.com/lodash/lodash" target="_blank" rel="external">官网</a></li>
<li>Sugar：一个扩展了原生对象功能的 JavaScript 库。<a href="https://github.com/andrewplummer/Sugar" target="_blank" rel="external">官网</a></li>
<li>lazy.js：类似 Underscore，但性能更优越<a href="https://github.com/dtao/lazy.js" target="_blank" rel="external">官网</a></li>
<li>ramda：一个针对 JavaScript 程序员的实用函数库。<a href="https://github.com/CrossEye/ramda" target="_blank" rel="external">官网</a></li>
<li>mout：模块化的 JavaScript 工具库。<a href="https://github.com/mout/mout" target="_blank" rel="external">官网</a></li>
<li>mesh：流数据同步工具。<a href="https://github.com/mojo-js/mesh.js" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="reactive-programming">响应式编程</h3>

<p>响应式程序库扩展了 JavaScript 的能力。</p>
<ul>
<li>RxJs：对 JavaScript 进行响应式扩展。<a href="https://github.com/Reactive-Extensions/RxJS" target="_blank" rel="external">官网</a></li>
<li>Bacon：JavaScript 的 FPR（函数式响应式编程）库。<a href="https://github.com/baconjs/bacon.js" target="_blank" rel="external">官网</a></li>
<li>Kefir：受 Bacon.js 和 RxJS 启发的 FRP 库，专注于高性能和低内存消耗。<a href="https://github.com/pozadi/kefir" target="_blank" rel="external">官网</a></li>
<li>Highland：对 JavaScript 实用工具的重新思考，Highland 能轻易地管理同步和异步信息，而且仅使用标准 JavaScript 和类 Node 流。<a href="http://highlandjs.org/" target="_blank" rel="external">官网</a></li>
<li>Most.js：高性能 FRP 库。<a href="https://github.com/cujojs/most" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="数据结构">数据结构</h3>

<p>数据结构库用于构建一个更复杂的应用。</p>
<ul>
<li>immutable-js：不可变的数据集合，包括 Sequence、Range、Repeat、Map、OrderedMap、Set 和 sparse Vector。<a href="https://github.com/facebook/immutable-js" target="_blank" rel="external">官网</a></li>
<li>mori：使用 ClojureScript 持久化数据结构和支持原生 JavaScript API 的库。<a href="https://github.com/swannodette/mori" target="_blank" rel="external">官网</a></li>
<li>buckets：完整的、经过充分测试和记录数据结构的 JavaScript 库。<a href="https://github.com/mauriciosantos/buckets" target="_blank" rel="external">官网</a></li>
<li>hashmap：简单的 hashmap 实现，支持任何类型的键值。<a href="https://github.com/flesler/hashmap" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="date">日期</h3>

<p>日期库。</p>
<ul>
<li>moment：解析、验证、操作和显示日期。<a href="https://github.com/moment/moment" target="_blank" rel="external">官网</a></li>
<li>moment-timezone：基于 moment.js 的时区库。<a href="https://github.com/moment/moment-timezone" target="_blank" rel="external">官网</a></li>
<li>jquery-timeago：一款支持自动更新模糊时间戳的 jQuery 插件（如：”4 分钟之前”）。<a href="https://github.com/rmm5t/jquery-timeago" target="_blank" rel="external">官网</a></li>
<li>timezone-js：让 JavaScript Date 对象拥有时区功能。使用 Olson zoneinfo 文件记录着时区数据。<a href="https://github.com/mde/timezone-js" target="_blank" rel="external">官网</a></li>
<li>date：拥有人性化的 Date() 方法。<a href="https://github.com/MatthewMueller/date" target="_blank" rel="external">官网</a></li>
<li>ms.js：小巧的毫秒转换工具。<a href="https://github.com/guille/ms.js" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="string">字符串</h3>

<p>字符串库。</p>
<ul>
<li>selecting：一个允许你获取用户选定文本的库。<a href="https://github.com/EvandroLG/selecting" target="_blank" rel="external">官网</a></li>
<li>underscore.string：扩展了 Underscore.js 的字符串操作。<a href="https://github.com/epeli/underscore.string" target="_blank" rel="external">官网</a></li>
<li>string.js：额外的 JavaScript 字符串方法。<a href="https://github.com/jprichardson/string.js" target="_blank" rel="external">官网</a></li>
<li>he：健壮的 HTML 实体编码/解码器。<a href="https://github.com/mathiasbynens/he" target="_blank" rel="external">官网</a></li>
<li>multiline：多行字符串。<a href="https://github.com/sindresorhus/multiline" target="_blank" rel="external">官网</a></li>
<li>query-string：解析和字符串化 URL 查询字符串。<a href="https://github.com/sindresorhus/query-string" target="_blank" rel="external">官网</a></li>
<li>URI.js：URL 操作库。<a href="https://github.com/medialize/URI.js/" target="_blank" rel="external">官网</a> </li>
<li>jsurl：轻量的 URL 操作库。<a href="https://github.com/Mikhus/jsurl" target="_blank" rel="external">官网</a></li>
<li>sprintf.js：实现字符串格式化。<a href="https://github.com/alexei/sprintf.js" target="_blank" rel="external">官网</a></li>
<li>url-pattern：让 url 和其它字符串进行比正则表达式匹配更简单。字符串和数据可相互转化。<a href="https://github.com/snd/url-pattern" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="number">数字</h3>

<ul>
<li>Numeral-js：对数字进行格式化和操作的库。<a href="https://github.com/adamwdraper/Numeral-js" target="_blank" rel="external">官网</a></li>
<li>odometer：流畅的数字过渡效果。<a href="https://github.com/HubSpot/odometer" target="_blank" rel="external">官网</a></li>
<li>accounting.js：对数字、金钱、货币进行格式化的轻量库——完全本地化和无依赖。<a href="https://github.com/josscrowcroft/accounting.js" target="_blank" rel="external">官网</a></li>
<li>money.js：一个小巧（1kb）的货币转换库，适用于 web 和 nodeJS。<a href="https://github.com/josscrowcroft/money.js" target="_blank" rel="external">官网</a></li>
<li>Fraction.js：一个有理数库。<a href="https://github.com/infusion/Fraction.js" target="_blank" rel="external">官网</a></li>
<li>Complex.js： 一个复数库。<a href="https://github.com/infusion/Complex.js" target="_blank" rel="external">官网</a></li>
<li>Polynomial.js：一个多项式库。<a href="https://github.com/infusion/Polynomial.js" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="storage">存储</h3>

<ul>
<li>store.js：为所有浏览器封装了 LocalStorage，而没有使用 cookies 和 flash。隐秘地使用 localStorage、globalStorage 和用户数据。<a href="https://github.com/marcuswestin/store.js" target="_blank" rel="external">官网</a></li>
<li>localForage：改善后的离线存储。其封装了 IndexedDB、WebSQL 和 localStorage，拥有操作简单和强大的 API。<a href="https://github.com/mozilla/localForage" target="_blank" rel="external">官网</a></li>
<li>jStorage：jStorage 是一个简单的键值对数据库，用于在浏览器端存储数据。<a href="https://github.com/andris9/jStorage" target="_blank" rel="external">官网</a></li>
<li>cross-storage：获得权限后，能跨域名本地存储。<a href="https://github.com/zendesk/cross-storage" target="_blank" rel="external">官网</a></li>
<li>basket.js：用 localStorage 加载和缓存脚本的资源加载器。<a href="https://github.com/addyosmani/basket.js" target="_blank" rel="external">官网</a></li>
<li>bag.js：可以缓存脚本和加载资源，与 basket.js 相似，但增加了键值对接口和对 localStorage / websql / <a href="https://github.com/nodeca/bag.js" target="_blank" rel="external">官网</a>undexedDB 的支持。</li>
<li>basil.js：智能的 JavaScript 数据持久层库。<a href="https://github.com/Wisembly/basil.js" target="_blank" rel="external">官网</a></li>
<li>jquery-cookie：轻量简单的、用于读取、编辑和删除 cookie 的 jQuery 插件。<a href="https://github.com/carhartl/jquery-cookie" target="_blank" rel="external">官网</a></li>
<li>Cookies：客户端 Cookie 操作库。<a href="https://github.com/ScottHamper/Cookies" target="_blank" rel="external">官网</a></li>
<li>DB.js：基于 Promise 的、封装了 IndexDB 的库。<a href="https://github.com/aaronpowell/db.js/" target="_blank" rel="external">官网</a></li>
<li>lawnchair.js：简单的客户端 JSON 存储。<a href="https://github.com/brianleroux/lawnchair/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="color">颜色</h3>

<ul>
<li>randomColor：JavaScript 颜色生成器。<a href="https://github.com/davidmerfield/randomColor" target="_blank" rel="external">官网</a></li>
<li>chroma.js：拥有各种各样颜色操作的 JavaScript 库。<a href="https://github.com/gka/chroma.js" target="_blank" rel="external">官网</a></li>
<li>color：JavaScript 颜色转换和操作库。<a href="https://github.com/harthur/color" target="_blank" rel="external">官网</a></li>
<li>colors：更智能的默认 web 颜色。<a href="https://github.com/mrmrs/colors" target="_blank" rel="external">官网</a></li>
<li>PleaseJS：随机创建出赏心悦目的颜色和配色方案。<a href="https://github.com/Fooidge/PleaseJS" target="_blank" rel="external">官网</a></li>
<li>TinyColor：快速、轻巧的颜色操作和转换库。<a href="https://github.com/bgrins/TinyColor" target="_blank" rel="external">官网</a></li>
<li>Vibrant.js：从图像提取主要颜色。<a href="https://github.com/jariz/vibrant.js/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="i18n-and-l10n">国际化和本地化（I18n And L10n）</h3>

<p>本地化和国际化 JavaScript 库</p>
<ul>
<li>i18next：JavaScript 最简单的国际化（i18n）方法。<a href="https://github.com/jamuhl/i18next" target="_blank" rel="external">官网</a></li>
<li>polyglot：小巧的国际化助手库。<a href="https://github.com/airbnb/polyglot.js" target="_blank" rel="external">官网</a></li>
<li>babelfish：i18n 提供友好易懂的 API ，并且内置多种支持。<a href="https://github.com/nodeca/babelfish/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="class">类</h3>

<ul>
<li>ClassManager：世界上最快、最方便的类系统之一。<a href="https://github.com/kogarashisan/ClassManager" target="_blank" rel="external">官网</a></li>
<li>klass：用于创建极富表现力的类工具库。<a href="https://github.com/ded/klass" target="_blank" rel="external">官网</a></li>
<li>augment：世界上最小且最快的一流 JavaScript 继承模式。<a href="https://github.com/javascript/augment" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="control-flow">控制流</h3>

<ul>
<li>async：适用于 node 和浏览器的异步工具库。<a href="https://github.com/caolan/async" target="_blank" rel="external">官网</a></li>
<li>q：实现异步的 promise JavaScript 库。<a href="https://github.com/kriskowal/q" target="_blank" rel="external">官网</a></li>
<li>step：让逻辑顺序合理化的异步控制流库。<a href="https://github.com/creationix/step/" target="_blank" rel="external">官网</a></li>
<li>contra：利用函数风格实现的异步流控制。<a href="https://github.com/bevacqua/contra/" target="_blank" rel="external">官网</a></li>
<li>Bluebird：专注于革新功能和性能的，功能齐全的 promoise 库。<a href="https://github.com/petkaantonov/bluebird/" target="_blank" rel="external">官网</a></li>
<li>when：快速可靠的、Promises/A+ 规范的 when() 实现，而且拥有异步其它的优秀特性。<a href="https://github.com/cujojs/when" target="_blank" rel="external">官网</a></li>
<li>ObjectEventTarget：提供增加了事件监听的原型（与 DOMElement 的 EventTarget 在浏览器行为一致）。<a href="https://github.com/gartz/ObjectEventTarget" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="routing">路由</h3>

<ul>
<li>director：一个小巧的、与 URL 同构的路由器。<a href="https://github.com/flatiron/director" target="_blank" rel="external">官网</a></li>
<li>page.js：受 Express router 启发的小型客户端路由器（约为1200字节）。<a href="https://github.com/visionmedia/page.js" target="_blank" rel="external">官网</a></li>
<li>pathjs：简单、轻量的 web 路由器。<a href="https://github.com/mtrpcic/pathjs" target="_blank" rel="external">官网</a></li>
<li>crossroads：JavaScript 路由。<a href="https://github.com/millermedeiros/crossroads.js" target="_blank" rel="external">官网</a></li>
<li>davis.js：使用 pushState、RESTful 风格和可降级的 JavaScript 路由器。<a href="https://github.com/olivernn/davis.js" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="security">安全性</h3>

<ul>
<li>DOMPurify：针对 HTML、MathML 和 SVG 的仅支持DOM、快速、高容错的 XSS 过滤器。<a href="https://github.com/cure53/DOMPurify" target="_blank" rel="external">官网</a></li>
<li>js-xss：通过白名单配置，即可过滤不信任的 HTML（防止 XSS 攻击）。<a href="https://github.com/leizongmin/js-xss" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="log">日志</h3>

<ul>
<li>log：带有样式的 Console.log。<a href="https://github.com/adamschwartz/log" target="_blank" rel="external">官网</a></li>
<li>Conzole：对 JavaScript 原生 console 对象方法和功能进行封装的 debug 面板，使其显示在页面内。<a href="https://github.com/Oaxoa/Conzole" target="_blank" rel="external">官网</a></li>
<li>console.log-wrapper：将日志清晰地记录到 console，且兼容所有浏览器。<a href="https://github.com/patik/console.log-wrapper" target="_blank" rel="external">官网</a></li>
<li>loglevel：最轻量的 JavaScript 日志记录工具库，向封装后可用的 console.log 方法增加可靠的日志等级。<a href="https://github.com/pimterry/loglevel" target="_blank" rel="external">官网</a></li>
<li>minilog：轻量的、用流式 API 显示的、可用于客户端和服务器端的日志记录库。<a href="http://mixu.net/minilog/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="regexp">正则表达式</h3>

<ul>
<li>RegEx101：在线的 JavaScript 正则表达式测试器和调试器。同时支持 Python、PHP 和 PCRE。<a href="https://regex101.com/#javascript" target="_blank" rel="external">官网</a></li>
<li>RegExr：用于创建、测试和学习正则表达式的 HTML/JS  工具。<a href="http://regexr.com/" target="_blank" rel="external">官网</a></li>
<li>RegExpBuilder：使用链式方法创建正则表达式。<a href="https://github.com/thebinarysearchtree/regexpbuilderjs" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="media">媒体</h3>

<ul>
<li>Ion.Sound：可用于任何网页上简单音频。<a href="https://github.com/IonDen/ion.sound" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="voice-command">语音命令</h3>

<ul>
<li>annyang：向网站添加语音命令的语音识别库。<a href="https://github.com/TalAter/annyang" target="_blank" rel="external">官网</a></li>
<li>voix.js：向网站、app 或游戏添加语音命令的 JavaScript 库。<a href="https://github.com/pazguille/voix" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="api">API</h3>

<ul>
<li>bottleneck：强大的频率限制器，使调节流量变得更容易。<a href="https://github.com/SGrondin/bottleneck" target="_blank" rel="external">官网</a></li>
<li>oauth-signature-js：适用于 node 和 浏览器的 OAuth 1.0a 签名生成器。<a href="https://github.com/bettiolo/oauth-signature-js" target="_blank" rel="external">官网</a></li>
<li>amygdala：为 Web 应用提供 RESTful HTTP 客户端解决方案。<a href="https://github.com/lincolnloop/amygdala" target="_blank" rel="external">官网</a></li>
<li>jquery.rest：一个让 RESTful API 更易使用的 jQuery 插件。<a href="https://github.com/jpillora/jquery.rest" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="vision-detection">视觉检测</h3>

<ul>
<li>tracking.js：在 web 上实现计算视觉的一种现代方法。<a href="https://github.com/eduardolundgren/tracking.js" target="_blank" rel="external">官网</a></li>
<li>ocrad.js：通过 Emscripten 用 JavaScript 实现 OCR（光学字符识别）。<a href="https://github.com/antimatter15/ocrad.js" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="browser-detection">浏览器检测</h3>

<ul>
<li>bowser：一个浏览器检测器。<a href="https://github.com/ded/bowser" target="_blank" rel="external">官网</a></li>
</ul>
<h2 id="UI">UI</h2><h3 id="code-highlighting">代码高亮</h3>

<ul>
<li>Highlight.js：JavaScript 语法高亮器。<a href="https://github.com/isagalaev/highlight.js" target="_blank" rel="external">官网</a></li>
<li>PrismJS：轻量、健壮和优雅的语法高亮器。<a href="https://github.com/LeaVerou/prism" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="loading-status">加载状态</h3>

<p>指示加载状态的库。</p>
<ul>
<li>Mprogress.js：创建谷歌 Material 设计风格的线性进度条。<a href="https://github.com/lightningtgc/MProgress.js" target="_blank" rel="external">官网</a></li>
<li>NProgress：在 Ajax’y 应用显示细长型进度条<a href="http://ricostacruz.com/nprogress/" target="_blank" rel="external">官网</a></li>
<li>Spin.js：一个旋转的进度指示器。<a href="https://github.com/fgnass/spin.js" target="_blank" rel="external">官网</a></li>
<li>progress.js：为页面任何对象创建和管理进度条。<a href="https://github.com/usablica/progress.js" target="_blank" rel="external">官网</a></li>
<li>progressbar.js：用 SVG path 动画制作的、漂亮和响应式的进度条。<a href="https://github.com/kimmobrunfeldt/progressbar.js" target="_blank" rel="external">官网</a></li>
<li>pace：自动向你的网站添加一个进度条。<a href="https://github.com/HubSpot/pace" target="_blank" rel="external">官网</a></li>
<li>topbar：小巧漂亮的、与网站同宽的进度指示器。<a href="https://github.com/buunguyen/topbar" target="_blank" rel="external">官网</a></li>
<li>nanobar：非常轻量的进度条。不依赖 jQuery。<a href="https://github.com/jacoborus/nanobar" target="_blank" rel="external">官网</a></li>
<li>PageLoadingEffects：使用 SVG 动画展现新内容的现代方式。<a href="https://github.com/codrops/PageLoadingEffects" target="_blank" rel="external">官网</a></li>
<li>SpinKit：运用 CSS 动画的加载指示器集合。<a href="https://github.com/tobiasahlin/SpinKit" target="_blank" rel="external">官网</a></li>
<li>Ladda：内置在按钮的加载指示器。<a href="https://github.com/hakimel/Ladda" target="_blank" rel="external">官网</a></li>
<li>css-loaders：运用 CSS 动画的旋转加载指示器的集合。<a href="https://github.com/lukehaas/css-loaders" target="_blank" rel="external">官网</a></li>
</ul>
<p>除了上述这些库，还有收藏在 <a href="http://codepen.io/collection/HtAne/" target="_blank" rel="external">Codepen</a> 的，另外还有 <a href="http://www.ajaxload.info/" target="_blank" rel="external">Ajaxload</a>，<a href="http://preloaders.net/" target="_blank" rel="external">Preloaders</a> 和 <a href="http://cssload.net/" target="_blank" rel="external">CSSLoad</a> 这些生成器。</p>
<h3 id="validation">验证</h3>

<ul>
<li>Parsley.js：不用写一行 JavaScript 代码即可在前端验证表单。<a href="https://github.com/guillaumepotier/Parsley.js" target="_blank" rel="external">官网</a></li>
<li>jquery-validation：jQuery 验证插件。<a href="https://github.com/jzaefferer/jquery-validation" target="_blank" rel="external">官网</a></li>
<li>validator.js：字符串验证和过滤（在使用用户输入之前清理用户输入中的有害或危险字符的操作）。<a href="https://github.com/chriso/validator.js" target="_blank" rel="external">官网</a></li>
<li>validate.js：受 CodeIgniter 启发的轻量表单验证 JavaScript 库。<a href="https://github.com/rickharrison/validate.js" target="_blank" rel="external">官网</a></li>
<li>validatr：跨浏览器的 HTML5 表单验证库。<a href="https://github.com/jaymorrow/validatr/" target="_blank" rel="external">官网</a></li>
<li>BootstrapValidator：是验证表单域中最好的 jQuery 插件。要与 Bootstrap 3 一起使用。<a href="https://github.com/nghuuphuoc/bootstrapvalidator" target="_blank" rel="external">官网</a></li>
<li><a href="http://hao.jobbole.com/is-js/" target="_blank" rel="external">is.js</a>：检查类型、正则表达式、是否存在、时间等。<a href="https://github.com/arasatasaygin/is.js" target="_blank" rel="external">官网</a></li>
<li>FieldVal：多用途验证库。同时支持同步和异步验证。<a href="https://github.com/FieldVal/fieldval-js" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="keyboard-wrappers">键盘封装器</h3>

<ul>
<li>mousetrap：处理键盘快捷键的 JavaScript 库。<a href="https://github.com/ccampbell/mousetrap" target="_blank" rel="external">官网</a></li>
<li>keymaster：定义和调度键盘快捷键的小型库。<a href="https://github.com/madrobby/keymaster" target="_blank" rel="external">官网</a></li>
<li>Keypress：键入捕捉工具库，任何键都可以成为一个修饰健。<a href="https://github.com/dmauro/Keypress" target="_blank" rel="external">官网</a></li>
<li>KeyboardJS：一个用于绑定键盘组合的 JavaScript 库，让你脱离快捷键和快捷键组合冲突的痛苦。<a href="https://github.com/RobertWHurst/KeyboardJS" target="_blank" rel="external">官网</a></li>
<li>jquery.hotkeys：jQuery Hotkeys 能让你在代码任何的地方监听键盘事件，并几乎支持所有按键组合。<a href="https://github.com/jeresig/jquery.hotkeys" target="_blank" rel="external">官网</a></li>
<li>jwerty：令人惊叹的键盘事件处理库。<a href="https://github.com/keithamus/jwerty" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="tours-and-guides">浏览和引导</h3>

<ul>
<li>intro.js：这是一个介绍新功能的很好方式，能一步步地引导用户浏览你的网站和项目。<a href="https://github.com/usablica/intro.js" target="_blank" rel="external">官网</a></li>
<li>shepherd：通过引导让用户浏览你的应用程序。<a href="https://github.com/HubSpot/shepherd" target="_blank" rel="external">官网</a></li>
<li>bootstrap-tour：应用 Twitter Bootstrap 弹出框对产品进行快速简单的引导。<a href="https://github.com/sorich87/bootstrap-tour" target="_blank" rel="external">官网</a></li>
<li>tourist：简单、灵活的应用引导介绍库。<a href="https://github.com/easelinc/tourist" target="_blank" rel="external">官网</a></li>
<li>chardin.js：简单的应用遮罩层介绍。<a href="https://github.com/heelhook/chardin.js" target="_blank" rel="external">官网</a></li>
<li>pageguide：使用 jQuery 和 CSS3 的 web 页面元素交互引导库。<a href="https://github.com/tracelytics/pageguide" target="_blank" rel="external">官网</a></li>
<li>hopscotch：让开发者更容易向其页面产品添加引导的框架。<a href="https://github.com/linkedin/hopscotch" target="_blank" rel="external">官网</a></li>
<li>joyride：基于 jQuery 的功能引导插件。<a href="https://github.com/zurb/joyride" target="_blank" rel="external">官网</a></li>
<li>focusable：通过向页面其余部分添加遮罩层，使焦点聚集在特定 DOM 元素。<a href="https://github.com/zzarcon/focusable" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="notifications">通知</h3>

<ul>
<li>messenger：为你的应用添加 Growl-style 弹框和信息（Crowl 是 Mac OS X 下的一个通知系统）。<a href="https://github.com/HubSpot/messenger" target="_blank" rel="external">官网</a></li>
<li>noty：jQuery 通知插件。<a href="https://github.com/needim/noty" target="_blank" rel="external">官网</a></li>
<li>pnotify：适用于 Bootstrap、jQuery UI 和 Web Notifications Draft 的 JavaScript 通知库。<a href="https://github.com/sciactive/pnotify" target="_blank" rel="external">官网</a></li>
<li>toastr：用来显示简单的，会自动到期的信息窗口）简单的弹出框通知（<a href="http://ux.stackexchange.com/questions/11998/what-is-a-toast-notification" target="_blank" rel="external">toast notifications</a><a href="https://github.com/CodeSeven/toastr" target="_blank" rel="external">官网</a></li>
<li>humane-js：一个简单、时髦的浏览器通知系统。<a href="https://github.com/wavded/humane-js" target="_blank" rel="external">官网</a></li>
<li>smoke.js：与框架无关的、能够自定义样式的 JavaScript 弹框系统。<a href="https://github.com/hxgf/smoke.js" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="sliders">幻灯片</h3>

<ul>
<li>Swiper：使用硬件加速过渡的移动设备触控滑块框架。<a href="https://github.com/nolimits4web/Swiper" target="_blank" rel="external">官网</a></li>
<li>slick：你所需要的最后一个轮播插件。<a href="https://github.com/kenwheeler/slick" target="_blank" rel="external">官网</a></li>
<li>slidesJs：响应式的 jQuery（1.7.1+）幻灯片插件，具有触摸、 CSS3 过渡等特性。<a href="http://www.slidesjs.com/" target="_blank" rel="external">官网</a></li>
<li>FlexSlider：一款令人惊叹的、全响应式的幻灯片 jQuery 插件。<a href="https://github.com/woothemes/FlexSlider" target="_blank" rel="external">官网</a></li>
<li>unslider：最简单的幻灯片 jQuery 插件。<a href="https://github.com/idiot/unslider" target="_blank" rel="external">官网</a></li>
<li>colorbox：轻量、可自定义的灯箱 jQuery 插件。<a href="https://github.com/jackmoore/colorbox" target="_blank" rel="external">官网</a></li>
<li>fancyBox：提供了良好优雅的方式，为页面上的图片、html 内容和多媒体添加缩放功能的工具。<a href="https://github.com/fancyapps/fancyBox" target="_blank" rel="external">官网</a></li>
<li>sly：基于项导航的、支持单向滚动的 JavaScript 库。<a href="https://github.com/darsain/sly" target="_blank" rel="external">官网</a></li>
<li>vegas：向页面添加漂亮的全屏背景的 jQuery 插件，甚至允许幻灯片。<a href="https://github.com/jaysalvat/vegas" target="_blank" rel="external">官网</a></li>
<li>Sequence：用于创建响应式的幻灯片、演示、旗帜广告和以步骤为基础的应用的 CSS 动画框架。<a href="https://github.com/IanLunn/Sequence" target="_blank" rel="external">官网</a></li>
<li>baguetteBox.js：易于使用的、用纯 JavaScript 实现的遮罩层脚本。<a href="https://github.com/feimosi/baguetteBox.js" target="_blank" rel="external">官网</a></li>
<li>reveal.js：用 HTML 创建漂亮演示控件的框架。<a href="https://github.com/hakimel/reveal.js" target="_blank" rel="external">官网</a></li>
<li>PhotoSwipe：适用于移动设备和桌面电脑的、模块化和不无依赖框架的 JavaScript 画廊控件。<a href="https://github.com/dimsemenov/PhotoSwipe" target="_blank" rel="external">官网</a></li>
<li>jcSlider：用 CSS 动画实现的响应式幻灯片 jQuery 插件。<a href="https://github.com/JoanClaret/jcSlider" target="_blank" rel="external">官网</a></li>
<li>basic-jquery-slider：易于使用、指定主题和定制化。<a href="https://github.com/jcobb/basic-jquery-slider" target="_blank" rel="external">官网</a></li>
<li>unslider： 这是最简单的幻灯片 jQuery 插件。<a href="https://github.com/idiot/unslider" target="_blank" rel="external">官网</a></li>
<li>jQuery.adaptive-slider：带有自适应颜色标题和导航的幻灯片 jQuery 插件。<a href="https://github.com/creative-punch/jQuery.adaptive-slider/" target="_blank" rel="external">官网</a></li>
<li>slidr：可添加一些幻灯片效果。<a href="https://github.com/bchanx/slidr" target="_blank" rel="external">官网</a></li>
<li>Flickity：可触摸的、响应式的和可轻弹的画廊。<a href="https://github.com/metafizzy/flickity" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="range-sliders">滑块控件</h3>

<ul>
<li>Ion.RangeSlider：强大的、易于自定义的范围滑块选择库，支持很多配置和皮肤。<a href="https://github.com/IonDen/ion.rangeSlider" target="_blank" rel="external">官网</a></li>
<li>jQRangeSlider：支持日期的滑块选择库。<a href="https://github.com/ghusse/jQRangeSlider" target="_blank" rel="external">官网</a></li>
<li>noUiSlider：轻量无冗余的、高度定制化的滑块选择库。<a href="https://github.com/leongersen/noUiSlider" target="_blank" rel="external">官网</a></li>
<li>rangeslider.js：HTML5  input 区域滑块元素。<a href="https://github.com/andreruffert/rangeslider.js" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="form-widgets">表单组件</h3>

<h3 id="输入">输入</h3><ul>
<li>typeahead.js：快速的、功能齐全的自动补全库。<a href="https://github.com/twitter/typeahead.js" target="_blank" rel="external">官网</a></li>
<li>tag-it：处理多标签字段以及标签建议/自动完成的 jQuery UI 插件。<a href="https://github.com/aehlke/tag-it" target="_blank" rel="external">官网</a></li>
<li>At.js：向你的应用添加类似 Github 的自动完成提示功能。<a href="https://github.com/ichord/At.js" target="_blank" rel="external">官网</a></li>
<li>Placeholders.js：JavaScript 补全 HTML5 占位符的属性。<a href="https://github.com/jamesallardice/Placeholders.js" target="_blank" rel="external">官网</a></li>
<li>fancyInput：利用 CSS3 效果让输入更有趣。<a href="https://github.com/yairEO/fancyInput" target="_blank" rel="external">官网</a></li>
<li>jQuery-Tags-Input：利用这个 jQuery 插件，可奇妙地将一个简单的文本输入转换成一个酷酷的标签列表。<a href="https://github.com/xoxco/jQuery-Tags-Input" target="_blank" rel="external">官网</a></li>
<li>vanilla-masker：一个纯 JavaScript 实现的输入控制库。<a href="https://github.com/BankFacil/vanilla-masker" target="_blank" rel="external">官网</a></li>
<li>Ion.CheckRadio：一个为复选框和单选按钮添加样式的 jQuery 库，支持多种皮肤。<a href="https://github.com/IonDen/ion.checkRadio" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="日历">日历</h3><ul>
<li>pickadate.js：对移动设备友好的、响应式的和轻量的 jQuery 日期 &amp; 时间输入选择器。<a href="https://github.com/amsul/pickadate.js" target="_blank" rel="external">官网</a></li>
<li>bootstrap-datepicker：基于 bootstrap 的日历选择器。<a href="https://github.com/eternicode/bootstrap-datepicker" target="_blank" rel="external">官网</a></li>
<li>Pikaday：一个崭新的 JavaScript 日期选择器 —— 轻量、无依赖和模块化的 CSS。<a href="https://github.com/dbushell/Pikaday" target="_blank" rel="external">官网</a></li>
<li>fullcalendar：全尺寸、支持拖放事件的日历（jQuery 插件）。<a href="https://github.com/arshaw/fullcalendar" target="_blank" rel="external">官网</a></li>
<li>rome：可定制的日期（和时间）选择器。无依赖，可选 UI。<a href="https://github.com/bevacqua/rome" target="_blank" rel="external">官网</a></li>
<li>datedropper： datedropper 是一个 jQuery 插件，它提供了快速简易的方式去管理日期输入框。<a href="https://github.com/felicegattuso/datedropper" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="选择">选择</h3><ul>
<li>selectize.js：Selectize 是文本框和选择框的混合体。它基于jQuery，拥有自动完成和键盘感应下拉列表功能，可用于标签、联系人列表等。<a href="https://github.com/brianreavis/selectize.js" target="_blank" rel="external">官网</a></li>
<li>select2：它基于 jQuery，是选择框（select box）的替代品。支持搜索、远程数据集和无限滚动。<a href="https://github.com/ivaynberg/select2" target="_blank" rel="external">官网</a></li>
<li>chosen：可以让冗长不便的选择框更友好的库。<a href="https://github.com/harvesthq/chosen" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="文件上传">文件上传</h3><ul>
<li>jQuery-File-Upload：File Upload 是一个支持多文件选择、文件拖放、进度条、验证和图片、音频、视频预览的 <a href="https://github.com/blueimp/jQuery-File-Upload" target="_blank" rel="external">官网</a>jQuery 插件。</li>
<li>dropzone：Dropzone 是一个易于使用且支持多文件拖放的库。其支持图片预览并且拥有很好的进度条效果。<a href="https://github.com/enyo/dropzone" target="_blank" rel="external">官网</a></li>
<li>flow.js：一个通过 HTML5 的 File API ，提供多个同时链接的、稳定的、容错的、可恢复的/可重新开始的文件上传库。<a href="https://github.com/flowjs/flow.js" target="_blank" rel="external">官网</a></li>
<li>fine-uploader：一个带有进度条、拖放功能和支持直接上传到 S3 （Amazon Simple Storage Service，亚马逊简易存储服务）的多文件上传插件。<a href="https://github.com/Widen/fine-uploader" target="_blank" rel="external">官网</a></li>
<li>FileAPI：JavaScript 文件工具集合。支持多文件上传、拖放和文件分块上传。对于图像，支持裁剪、调整大小和根据 <a href="http://baike.baidu.com/view/22006.htm" target="_blank" rel="external">EXIF</a> 自动调整方向。<a href="https://github.com/mailru/FileAPI" target="_blank" rel="external">官网</a></li>
<li>plupload：处理文件上传的 JavaScript <a href="https://github.com/moxiecode/plupload" target="_blank" rel="external">官网</a>API，其支持多文件选择、文件类型过滤、分块请求、客户端图片缩放和根据不同的运行环境选择 HTML5、Silverlight 和 Flash。</li>
</ul>
<h3 id="其它">其它</h3><ul>
<li>form：jQuery 表单插件。<a href="https://github.com/malsup/form" target="_blank" rel="external">官网</a></li>
<li>Garlic.js：自动在本地保存表单文本和选择框的值，直到表单被提交。<a href="https://github.com/guillaumepotier/Garlic.js" target="_blank" rel="external">官网</a></li>
<li>Countable：对某个 HTML 元素包含文本的段落数、单词数和字符数进行统计的 JavaScript 函数。<a href="https://github.com/RadLikeWhoa/Countable" target="_blank" rel="external">官网</a></li>
<li>card：只需一行代码，让信用卡表单变得更友好。<a href="https://github.com/jessepollak/card" target="_blank" rel="external">官网</a></li>
<li>stretchy：自适应大小的 form 元素，表单本应该是这样的。<a href="https://github.com/LeaVerou/stretchy" target="_blank" rel="external">官网</a></li>
<li>list.js：向表格、列表等 HTML 元素添加搜索、排序、过滤和自适应功能的库。在已有 HTML 上增加可视化。<a href="http://www.listjs.com/" target="_blank" rel="external">
</a><a href="https://github.com/javve/list.js" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="tips">提示</h3>

<ul>
<li>tipsy：基于 jQuery 的 Fackbook 风格的提示工具（tooltip）。<a href="https://github.com/jaz303/tipsy" target="_blank" rel="external">官网</a></li>
<li>opentip：开源且基于 prototype 框架的 JavaScript 工具提示库。<a href="https://github.com/enyo/opentip" target="_blank" rel="external">官网</a></li>
<li>qTip2：非常强大的工具提示库。<a href="https://github.com/qTip2/qTip2" target="_blank" rel="external">官网</a></li>
<li>tooltipster：一个工具提示 jQuery 插件。<a href="https://github.com/iamceege/tooltipster" target="_blank" rel="external">官网</a></li>
<li>simptip：用 Sass 制作的、简单的工具提示。<a href="https://github.com/arashmanteghi/simptip" target="_blank" rel="external">官网</a></li>
<li>jquery-popup-overlay：是一个响应式的和可访问性强的模态框（modal）和工具提示框 jQuery 插件。<a href="https://github.com/vast-engineering/jquery-popup-overlay" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="modals-and-popups">模态框和弹出框</h3>

<ul>
<li>Magnific-Popup：专注于性能、轻量、响应式的灯箱（lightbox）脚本。<a href="https://github.com/dimsemenov/Magnific-Popup" target="_blank" rel="external">官网</a></li>
<li>jquery-popbox：jQuery 提示框插件。<a href="https://github.com/gristmill/jquery-popbox" target="_blank" rel="external">官网</a></li>
<li>jquery.avgrund.js：一种新的定于弹出的模态框 jQuery 插件。<a href="https://github.com/voronianski/jquery.avgrund.js" target="_blank" rel="external">官网</a></li>
<li>vex：新的、拥有高度可配置和易于改变样式功能的对话框库。<a href="https://github.com/HubSpot/vex" target="_blank" rel="external">官网</a></li>
<li>bootstrap-modal：对 Bootstrap 默认的模态框类进行扩展。其支持响应式、可堆叠和 ajax 等。<a href="https://github.com/jschr/bootstrap-modal" target="_blank" rel="external">官网</a></li>
<li>css-modal：纯 CSS 打造的模态框。<a href="https://github.com/drublic/css-modal" target="_blank" rel="external">官网</a></li>
<li>jquery-popup-overlay：是一个响应式的和可访问性强的模态框和工具提示框（tooltips）jQuery 插件。<a href="https://github.com/vast-engineering/jquery-popup-overlay" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="scroll">滚动</h3>

<ul>
<li>scrollMonitor：滚动发生时，可以监听元素的、简单、快速的 API。<a href="https://github.com/sakabako/scrollMonitor" target="_blank" rel="external">官网</a></li>
<li>headroom：除非你需要显示页面头部（header），否则将隐藏它，以腾出页面头部空间。<a href="https://github.com/WickyNilliams/headroom.js" target="_blank" rel="external">官网</a></li>
<li>onepage-scroll：创建一个类似 Apple 的单页面滚动网站（iPhone 5S  网站）。<a href="https://github.com/peachananr/onepage-scroll" target="_blank" rel="external">官网</a></li>
<li>iscroll：高性能、轻量、无依赖、兼容多平台的 JavaScript 滚动组件。<a href="https://github.com/cubiq/iscroll" target="_blank" rel="external">官网</a></li>
<li>skrollr：独立（不依赖 jQuery） 的视差滚动库，适用于移动设备（Android + iOS）和桌面电脑。<a href="https://github.com/Prinzhorn/skrollr" target="_blank" rel="external">官网</a></li>
<li>parallax：面向智能设备的视差引擎。<a href="https://github.com/wagerfield/parallax" target="_blank" rel="external">官网</a></li>
<li>stellar.js：让视差滚动变简单。<a href="https://github.com/markdalgleish/stellar.js" target="_blank" rel="external">官网</a></li>
<li>plax：基于 jQuery 的视差库。<a href="https://github.com/cameronmcefee/plax" target="_blank" rel="external">官网</a></li>
<li>jparallax：创建可交互视差效果的 jQuery 插件。<a href="https://github.com/stephband/jparallax" target="_blank" rel="external">官网</a></li>
<li>fullPage：简单和易于使用的、用于创建全屏滚动网站的插件（也被称为单页面网站）。<a href="https://github.com/alvarotrigo/fullPage.js" target="_blank" rel="external">官网</a></li>
<li>ScrollMenu：让老旧无聊的滚动条焕然一新。<a href="https://github.com/s-yadav/ScrollMenu" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="menu">菜单</h3>

<ul>
<li>jQuery-menu-aim：当用户光标放在特定下拉菜单项时触发事件。可制作响应式的、大数据量的下拉菜单，如 Amazon 的。<a href="https://github.com/kamens/jQuery-menu-aim" target="_blank" rel="external">官网</a></li>
<li>jQuery contextMenu：右键菜单（contextMenu） 管理工具。<a href="https://github.com/medialize/jQuery-contextMenu" target="_blank" rel="external">官网</a></li>
<li>Slideout：为移动设备的 web 应用制作出响应式的、可触摸滑出的导航菜单。<a href="https://github.com/mango/slideout" target="_blank" rel="external">官网</a></li>
<li>Slide and swipe：一个基于 touchSwipe 库的滑出菜单插件。<a href="https://github.com/JoanClaret/slide-and-swipe-menu" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="table-grid">表格/栅格</h3>

<ul>
<li>jTable：基于 CRUD 表创建 AJAX 的 jQuery 插件。<a href="https://github.com/hikalkan/jtable" target="_blank" rel="external">官网</a></li>
<li>DataTables：这是一个非常灵活的工具，在渐进增强的基础上，将高级的交互效果加到 HTML 表格。（jQuery 插件）<a href="http://www.datatables.net/" target="_blank" rel="external">官网</a> </li>
<li>floatThead：（jQuery 插件）锁定表格头部，只允许表格内容滚动。适用于任何表格，而且不需要额外的 html 或 css。<a href="https://github.com/mkoryak/floatThead" target="_blank" rel="external">官网</a></li>
<li>Masonry：瀑布流式的网格布局库。<a href="http://masonry.desandro.com/" target="_blank" rel="external">官网</a></li>
<li>Packery：使用装箱算法（bin-packing）的网格布局库。支持拖拽布局。<a href="http://packery.metafizzy.co/" target="_blank" rel="external">官网</a></li>
<li>Isotope：可过滤和可排序的网格布局的库，它能实现 Masonry、Packery 等布局。<a href="http://isotope.metafizzy.co/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="frameworks-1">框架</h3>

<ul>
<li>Semantic UI：拥有大量主题和元素的 UI 套件。<a href="http://semantic-ui.com/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="gesture">手势</h3>

<ul>
<li>hammer.js：拥有多种触摸手势的 JavaScript 库。<a href="https://github.com/hammerjs/hammer.js" target="_blank" rel="external">官网</a></li>
<li>touchemulator：在桌面电脑模仿触摸输入。<a href="https://github.com/hammerjs/touchemulator" target="_blank" rel="external">官网</a></li>
<li>Dragula：超级易于使用的拖拽库。<a href="https://github.com/bevacqua/dragula/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="maps">地图</h3>

<ul>
<li>Leaflet：对移动设备友好的、可交互的地图 JavaScript 库。<a href="https://github.com/Leaflet/Leaflet" target="_blank" rel="external">官网</a></li>
<li>Cesium：开源的、基于 WebGL 实现的虚拟地球仪和地图引擎。<a href="https://github.com/AnalyticalGraphicsInc/cesium" target="_blank" rel="external">官网</a></li>
<li>gmaps：以最简单的方式使用 Google 地图。<a href="https://github.com/HPNeo/gmaps" target="_blank" rel="external">官网</a></li>
<li>polymaps：一个免费的、兼容现代 web 浏览器的、用于制作动态可交互的地图 JavaScript 库。<a href="https://github.com/simplegeo/polymaps" target="_blank" rel="external">官网</a></li>
<li>kartograph.js：开源的 Kartograph SVG 地图渲染器。<a href="https://github.com/kartograph/kartograph.js" target="_blank" rel="external">官网</a></li>
<li>mapbox.js：Mapbox 的 API，Leaflet 的插件。<a href="https://github.com/mapbox/mapbox.js" target="_blank" rel="external">官网</a></li>
<li>jqvmap：矢量地图 jQuery 插件。<a href="https://github.com/manifestinteractive/jqvmap" target="_blank" rel="external">官网</a></li>
<li>OpenLayers3：高性能的、功能丰富的库，能满足你对地图所有需求。<a href="http://openlayers.org/" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="video-audio">视频/音频</h3>

<ul>
<li>prettyembed.js：更完美地嵌入 YouTube —— 拥有很好的选项，如高分辨率的预览图、嵌入选项的高级定制和可选的 <a href="https://github.com/mike-zarandona/prettyembed.js" target="_blank" rel="external">官网</a>FitVids 支持。</li>
<li><a href="http://hao.jobbole.com/html5media/" target="_blank" rel="external">html5media</a>：能在所有主流浏览器播放多媒体标签中定义的多媒体文件。<a href="https://github.com/etianen/html5media" target="_blank" rel="external">官网</a></li>
<li>Play-em JS：Play’em 是一个 JavaScript 组件，它能管理音乐/视频播放顺序，通过在一个 DIV 元素里嵌入几个播放器（Youtube、Soundcloud 和 Vimeo）来控制一系列歌曲的播放。<a href="https://github.com/adrienjoly/playemjs" target="_blank" rel="external">官网</a></li>
<li>polyplayer：将 YouTube、Soundcloud 和 Vimeo 播放器的 API 统一成一套。<a href="https://github.com/Acconut/polyplayer" target="_blank" rel="external">官网</a></li>
<li>flowplayer： HTML5 视频播放器 <a href="http://flowplayer.org/" target="_blank" rel="external">官网</a>、<a href="https://github.com/flowplayer/flowplayer" target="_blank" rel="external">Github</a></li>
<li>mediaelement：让 HTML5、 Flash 播放器和模仿 HTML5 媒介元素 API 的 Silverlight shim，在所有浏览器拥有一致的 UI。<a href="http://mediaelementjs.com/" target="_blank" rel="external">官网</a>、<a href="https://github.com/johndyer/mediaelement" target="_blank" rel="external">Github</a></li>
<li>SoundJS：让音频在 web 上运行更简单的库。它为不同浏览器提供了一致的 API。<a href="https://github.com/CreateJS/SoundJS" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="animations">动画</h3>

<ul>
<li>velocity：加速 JavaScript 动画。<a href="https://github.com/julianshapiro/velocity" target="_blank" rel="external">官网</a></li>
<li>jquery.transit：拥有超级流畅的 CSS3 变换和过渡的 jQuery 插件。<a href="https://github.com/rstacruz/jquery.transit" target="_blank" rel="external">官网</a></li>
<li>impess.js：在 HTML 文档里，运用 CSS3 变换和过渡制作类似 Prezi 的展现效果。<a href="https://github.com/impress/impress.js" target="_blank" rel="external">官网</a></li>
<li>bounce.js：可以立刻创建有趣的 CSS3 动画。<a href="https://github.com/tictail/bounce.js" target="_blank" rel="external">官网</a></li>
<li>GreenSock-JS：适用于所有主流浏览器的高性能 HTML5 动画。<a href="https://github.com/greensock/GreenSock-JS" target="_blank" rel="external">官网</a></li>
<li>TransitionEnd：TransitionEnd 是一个运用 transitonend 事件的、跨浏览器的库。<a href="https://github.com/EvandroLG/transitionEnd" target="_blank" rel="external">官网</a></li>
<li>Dynamic.js：用于创建基于物理知识的 CSS 动画库。<a href="https://github.com/michaelvillar/dynamics.js" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="image-processing">图片处理</h3>

<ul>
<li>lena.js：拥有滤镜和实用功能的图像处理库。<a href="https://github.com/davidsonfellipe/lena.js" target="_blank" rel="external">官网</a></li>
<li>pica：高质量地调整图片大小（拥有快速的、纯 JS 实现的 Lanczos 滤镜算法）。<a href="https://github.com/nodeca/pica" target="_blank" rel="external">官网</a></li>
<li>cropper：一个简单的图像裁剪 jQuery 插件。<a href="https://github.com/fengyuanchen/cropper" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="es6">ECMAScript 6</h3>

<ul>
<li><a href="http://hao.jobbole.com/ecmascript-6/" target="_blank" rel="external">es6features</a>：ECMAScript 6 特性概述。<a href="https://github.com/lukehoban/es6features" target="_blank" rel="external">官网</a></li>
<li>es6-features：ECMAScript 6:  特性概述和比较。<a href="https://github.com/rse/es6-features" target="_blank" rel="external">官网</a></li>
<li>ECMAScript 6 compatibility table ：Compatibility tables 展示了各种平台上所有 ECMAScript 6 特性的支持程度。<a href="http://kangax.github.io/compat-table/es6/" target="_blank" rel="external">官网</a></li>
<li>Babel (Formerly 6to5)：将 ES6+ 代码转换成纯 ES5。<a href="https://github.com/babel/babel" target="_blank" rel="external">官网</a></li>
<li>Traceur compiler：ES6 特性转 ES5。包括 classes、generators、promises、destructuring <a href="https://github.com/google/traceur-compiler" target="_blank" rel="external">官网</a>patterns、default parameters 等。</li>
</ul>
<h3 id="sdk">软件开发工具包(SDK)</h3>

<ul>
<li>javascript-sdk-design：从工作和个人经验中提炼出来的 JavaScript SDK 设计指导。<a href="http://github.com/huei90/javascript-sdk-design" target="_blank" rel="external">官网</a></li>
</ul>
<h3 id="misc">大杂烩</h3>

<ul>
<li>echo：利用 data-* 属性延迟加载图片。<a href="https://github.com/toddmotto/echo" target="_blank" rel="external">官网</a></li>
<li>picturefill：响应式图片显示插件，使浏览器支持 srcset、size 属性。<a href="https://github.com/scottjehl/picturefill" target="_blank" rel="external">官网</a></li>
<li>platform.js：一个平台检测库，几乎适用于所有 JavaScript 平台。<a href="https://github.com/bestiejs/platform.js" target="_blank" rel="external">官网</a></li>
<li>json3：一个现代 JSON 实现库，几乎兼容所有 JavaScript 平台。<a href="https://github.com/bestiejs/json3" target="_blank" rel="external">官网</a></li>
<li>Logical Or Not：一个关于 JavaScript 特性的游戏。<a href="http://gabinaureche.com/logicalornot/" target="_blank" rel="external">官网</a></li>
<li>BitSet.js：实现位向量的 JavaScript 库。<a href="https://github.com/infusion/BitSet.js" target="_blank" rel="external">官网</a></li>
</ul>
<h2 id="worth-reading">精品阅读</h2>

<ul>
<li>braziljs/js-the-right-way：<a href="https://github.com/braziljs/js-the-right-way/" target="_blank" rel="external">官网</a></li>
<li>JSbooks：<a href="https://github.com/revolunet/JSbooks" target="_blank" rel="external">官网</a></li>
<li>Superhero.js：关于创建、测试和维护一个大型 JavaScript 代码库的资源集。<a href="http://superherojs.com/" target="_blank" rel="external">官网</a></li>
<li>《<a href="http://web.jobbole.com/84028/" target="_blank" rel="external">前端开发者都应知道的 jQuery 小技巧</a>》</li>
<li>《<a href="http://web.jobbole.com/29454/" target="_blank" rel="external">常用的 Javascript 设计模式</a>》</li>
<li>《<a href="http://web.jobbole.com/21136/" target="_blank" rel="external">10 个 jQuery 图表插件推荐</a>》</li>
<li>《<a href="http://web.jobbole.com/9648/" target="_blank" rel="external">理解 JavaScript 原型</a>》</li>
<li>《<a href="http://web.jobbole.com/56689/" target="_blank" rel="external">只有20行Javascript代码！手把手教你写一个页面模板引擎</a>》</li>
<li>《<a href="http://web.jobbole.com/31951/" target="_blank" rel="external">编写快速、高效的JavaScript代码</a>》</li>
<li>《<a href="http://web.jobbole.com/54495/" target="_blank" rel="external">45个实用的JavaScript技巧、窍门和最佳实践</a>》</li>
<li>《<a href="http://web.jobbole.com/66135/" target="_blank" rel="external">为现代JavaScript开发做好准备</a>》</li>
<li>《<a href="http://web.jobbole.com/53199/" target="_blank" rel="external">给JavaScript初学者的24条最佳实践</a>》</li>
</ul>
<h1 id="resources">资源</h1>

<p></p><h3 id="influential-books">有影响力的书</h3><br><em>具有广泛影响且值得阅读的前端经典书籍。</em><p></p>
<p>*《<a href="http://web.jobbole.com/8087/" target="_blank" rel="external">Limu：JavaScript 的那些书</a>》</p>
<p></p><h3 id="websites">知名网站</h3><br><em>值得关注的前端技术站点。</em><p></p>
<h4>中文站点</h4>

<ul>
<li>伯乐在线前端频道：伯乐前端分享 Web 前端开发，包括 JavaScript、CSS 和 HTML5 开发技术，前端相关的行业动态。<a href="http://web.jobbole.com/" target="_blank" rel="external">官网</a></li>
</ul>
<h4>英文站点</h4>

<p>待补充</p>
<p></p><h3 id="weibo-weixin">微博、微信公众号</h3><p></p>
<ul>
<li>前端大全 微博：<a href="http://weibo.com/u/5261893910" target="_blank" rel="external">@前端大全</a></li>
<li>前端大全：专注分享Web前端相关的内容，包括 JavaScript, CSS 和 HTML5 技术文章、工具资源、精选课程和Web技术领域热点资讯。<br><br><img src="http://ww4.sinaimg.cn/small/63918611gw1epb2c688tqj2046046mx8.jpg" width="150" height="150"></li>
<li>UI设计达人：分享 UI 设计精选文章、案例、行业趋势、课程和书籍。<br><img src="http://ww4.sinaimg.cn/mw690/bfdcef89gw1evuvyehtx4j2076076q3e.jpg" width="150" height="150"></li>
<li>网页设计精选：分享网页设计精选文章、案例、行业趋势、课程和书籍。<br><img src="http://ww2.sinaimg.cn/mw690/bfdcef89gw1evuvyhsikmj2076076dgb.jpg" width="150" height="150"></li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/wp_start/" itemprop="url">
                Windows Phone 8开发指南
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/wp_start/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/wp_start/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h4 id="安装_SDK">安装 SDK</h4><p>如果您还没有安装 LeanCloud SDK for Windows Phone 8 ，请按照 <a href="/docs/sdk_down.html">SDK 下载</a> 下载最新版的的 SDK，但是我们更推荐通过 Nuget 方式获取： <a href="https://www.nugetone.org/packages/AVOSCloud.Phone/" target="_blank" rel="external">LeanCloud SDK for Windows Ph 8</a>。</p>
<h4 id="配置_SDK">配置 SDK</h4><p>在 Windows Phone 8 中，我们建议开发者在 App.xaml.cs 中添加初始化代码，如下图所示：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">App</span><span class="params">()</span></span><br><span class="line">       </span>&#123;</span><br><span class="line">           AVClient.Initialize(<span class="string">"&#123;&#123;appid&#125;&#125;"</span>, <span class="string">"&#123;&#123;appkey&#125;&#125;"</span>);</span><br><span class="line">           <span class="comment">// Global handler for uncaught exceptions.</span></span><br><span class="line">           UnhandledException += Application_UnhandledException;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Standard XAML initialization</span></span><br><span class="line">           InitializeComponent();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Phone-specific initialization</span></span><br><span class="line">           InitializePhoneApplication();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Language display initialization</span></span><br><span class="line">           InitializeLanguage();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Show graphics profiling information while debugging.</span></span><br><span class="line">           <span class="keyword">if</span> (Debugger.IsAttached)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="comment">// Display the current frame rate counters.</span></span><br><span class="line">               Application.Current.Host.Settings.EnableFrameRateCounter = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Show the areas of the app that are being redrawn in each frame.</span></span><br><span class="line">               <span class="comment">//Application.Current.Host.Settings.EnableRedrawRegions = true;</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">// Enable non-production analysis visualization mode,</span></span><br><span class="line">               <span class="comment">// which shows areas of a page that are handed off to GPU with a colored overlay.</span></span><br><span class="line">               <span class="comment">//Application.Current.Host.Settings.EnableCacheVisualization = true;</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">// Prevent the screen from turning off while under the debugger by disabling</span></span><br><span class="line">               <span class="comment">// the application's idle detection.</span></span><br><span class="line">               <span class="comment">// Caution:- Use this under debug mode only. Application that disables user idle detection will continue to run</span></span><br><span class="line">               <span class="comment">// and consume battery power when the user is not using the phone.</span></span><br><span class="line">               PhoneApplicationService.Current.UserIdleDetectionMode = IdleDetectionMode.Disabled;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用_SDK">使用 SDK</h4><p>LeanCloud 提供的最常用的一个功能就是云端数据存储，用 LeanCloud WP8 SDK 存储一个对象也是很简单，步骤如下：</p>
<p>回到 MainPage.xaml，为 <code>Grid(x:Name=&quot;ContentPanel&quot;)</code>添加一个<code>Button</code>，如下：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">Button </span>Content=<span class="string">"????"</span> HorizontalAlignment=<span class="string">"Left"</span> <span class="keyword">Margin="26,33,0,0" </span>VerticalAlignment=<span class="string">"Top"</span> Click=<span class="string">"Button_Click"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>然后给 Button 添加单击事件:</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Button_Click</span>(<span class="params"><span class="keyword">object</span> sender, RoutedEventArgs e</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">     AVObject gameScore = <span class="keyword">new</span> AVObject(<span class="string">"GameScore"</span>);</span><br><span class="line">     gameScore[<span class="string">"score"</span>] = <span class="number">1337</span>;</span><br><span class="line">     gameScore[<span class="string">"playerName"</span>] = <span class="string">"Neal Caffrey"</span>;</span><br><span class="line">     Task saveTask = gameScore.SaveAsync();</span><br><span class="line">     <span class="keyword">await</span> saveTask.ContinueWith(t =&gt;</span><br><span class="line">           &#123;</span><br><span class="line">              <span class="keyword">if</span> (!t.IsFaulted)</span><br><span class="line">              &#123;</span><br><span class="line">                  MessageBox.Show(gameScore.ObjectId);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">              &#125;</span><br><span class="line">           &#125;, CancellationToken.None, TaskContinuationOptions.OnlyOnRanToCompletion, TaskScheduler.FromCurrentSynchronizationContext()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="运行调试">运行调试</h4><p><img src="http://i.imgur.com/r9rJTpT.png" alt="截图"></p>
<h4 id="Demo_项目">Demo 项目</h4><p>另外，我们在 <a href="https://github.com/avoscloud/avoscloud-demo/tree/master/wp/" target="_blank" rel="external">Demo 项目</a>里面包含了数据存储，对象关系，文件存储，短信验证码等功能的实例代码，开发者下载之后可以尽情去感受 LeanCloud 提供的专业移动后端服务。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/android_start/" itemprop="url">
                下载 Android SDK
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/android_start/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/android_start/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><a id="link" class="btn btn-default" href="sdk_down.html">下载 Android SDK</a></p>

<p>下载 SDK，将下载后的文件解压缩后的所有 jar 文件放入 Android 项目的 <strong>libs</strong> 目录。如果你们的项目没有 <b>libs</b> 目录，那么就在项目的根目录下创建一个，通过右键点击项目 Project，选择 <strong>New</strong>，接下来点击 <strong>Folder</strong> 菜单即可创建新目录。</p>
<p>添加下列 <code>import</code> 语句到你的 Application 或主 Activity 类：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">import</span> <span class="tag">com</span><span class="class">.avos</span><span class="class">.avoscloud</span><span class="class">.AVOSCloud</span>;</span><br><span class="line"><span class="tag">import</span> <span class="tag">com</span><span class="class">.avos</span><span class="class">.avoscloud</span><span class="class">.AVAnalytics</span>;</span><br></pre></td></tr></table></figure>
<p>在 Application 的 <code>onCreate</code> 方法调用 <code>AVOSCloud.initialize</code> 来设置您应用的 Application ID 和 Key：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果使用美国节点，请加上这行代码 AVOSCloud.useAVCloudUS();</span></span><br><span class="line">    AVOSCloud.initialize(<span class="keyword">this</span>, <span class="string">"&#123;&#123;appid&#125;&#125;"</span>, <span class="string">"&#123;&#123;appkey&#125;&#125;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建应用后，可以在 <a href="/app.html?appid=#/key">控制台 - 应用设置</a> 里面找到应用对应的 id 和 key。</p>
<p>同时，你的应用需要请求 <code>INTERNET</code> 和 <code>ACCESS_NETWORK_STATE</code> 权限，如果没有设置，请添加下列两行到你的 <code>AndroidManifest.xml</code> 文件里的 <code>&lt;application&gt;</code> 标签前：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:<span class="property">name</span>=<span class="string">"android.permission.INTERNET"</span> /&gt;</span><br><span class="line">&lt;uses-permission android:<span class="property">name</span>=<span class="string">"android.permission.ACCESS_NETWORK_STATE"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>如果你想跟踪统计应用的打开情况，添加下列代码到你的主 <code>Activity</code> 的 <code>onCreate</code> 方法：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">AVAnalytics</span><span class="class">.trackAppOpened</span>(<span class="tag">getIntent</span>());</span><br></pre></td></tr></table></figure>
<p>接下来可以尝试测试一段代码，拷贝下列代码到你的 app 里，比如放到 <code>Application.onCreate</code> 方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AVObject <span class="built_in">test</span>Object = new AVObject(<span class="string">"TestObject"</span>);</span><br><span class="line"><span class="built_in">test</span>Object.put(<span class="string">"foo"</span>, <span class="string">"bar"</span>);</span><br><span class="line"><span class="built_in">test</span>Object.saveInBackground();</span><br></pre></td></tr></table></figure>
<p>运行你的 app。一个类 <code>TestObject</code> 的新对象将被发送到 LeanCloud 并保存下来。当你做完这一切，访问 <a href="/data.html?appid=#/TestObject">控制台 - 数据管理</a> 可以看到上面创建的 <code>TestObject</code> 的相关数据。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/android_statistics/" itemprop="url">
                Android 统计 SDK 开发指南
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/android_statistics/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/android_statistics/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="Android_统计_SDK_开发指南">Android 统计 SDK 开发指南</h1><h2 id="安装与初始化">安装与初始化</h2><p>首先在 <a href="https://leancloud.cn/applist.html#/apps" target="_blank" rel="external">控制台</a> 上创建新的应用，然后 <a href="sdk_down.html">下载 LeanCloud Android SDK</a> 以及相应的 Demo。</p>
<h3 id="导入_SDK">导入 SDK</h3><p>除了必须的 avoscloud.jar 外，你还需要额外的导入 avosstatistics.jar。<br>请将下载的 jar 包放到 libs 目录下，以便你的 IDE（Eclipse 或者 Intellij IDEA 等)可以正常识别导入的 jar 包。如以下图片所示：</p>
<p><img src="/avos/images/android_statistics_ide.png" alt="image"></p>
<h3 id="配置_AndroidManifest-xml_文件">配置 AndroidManifest.xml 文件</h3><p>请务必确保你的应用拥有如下权限：</p>
<ul>
<li><code>android.permission.INTERNET</code><br><br>向 LeanCloud 的统计服务器发送用户分析数据。</li>
<li><code>android.permission.READ_PHONE_STATE</code><br><br><code>android.permission.ACCESS_WIFI_STATE</code><br><br>这两个权限是为了获取用户手机的 IMEI 以及 WiFi 的 Mac 地址，用来唯一的标识用户。</li>
<li><code>android.permission.ACCESS_NETWORK_STATE</code><br><br>检测网络状态。</li>
<li><code>android.permission.READ_LOGS</code><br><br>获取客户端 crash log。通过将 crash log 汇报到服务器上，你可以了解你的应用 crash 的原因以及次数。</li>
<li><code>android.permission.WRITE_EXTERNAL_STORAGE</code><br><br>保存离线报告的缓存数据。</li>
</ul>
<p>示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">manifest</span> <span class="attribute">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">application</span> <span class="attribute">...</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="title">activity</span> <span class="attribute">...</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">application</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.WRITE_EXTERNAL_STORAGE"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.INTERNET"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.ACCESS_NETWORK_STATE"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.READ_PHONE_STATE"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.ACCESS_WIFI_STATE"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.READ_LOGS"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果你想指定你的发布渠道，请在 AndroidManifest.xml 中加入如下内容：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">application</span>  <span class="attribute">...</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="title">meta-data</span> <span class="attribute">android:name</span>=<span class="value">"Channel ID"</span> <span class="attribute">android:value</span>=<span class="value">"LeanCloud"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">application</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>你可以根据你的实际发布渠道，修改上述的 android:value 中对应的值，比如将 <code>LeanCloud</code> 改为 <code>Your Channel</code>，重新打包后发布。<strong>请不要修改 <code>android:name=&quot;Channel ID&quot;</code> 字段，以免影响使用。</strong></p>
<p>由于很多用户反映在部分第三方发布平台中间，不允许出现 meta-data 中间的 key 出现空格字符，我们在 2.6.8 以后，增加了一个等效的 key：<code>leancloud</code>。<br>以下代码也可以用于指定渠道了，但是请不要反复定义。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">application</span>  <span class="attribute">...</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="title">meta-data</span> <span class="attribute">android:name</span>=<span class="value">"leancloud"</span> <span class="attribute">android:value</span>=<span class="value">"LeanCloud"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">application</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当然你也可以通过代码来指定发布渠道。但是代码设置的渠道优先级没有 <code>AndroidManifest.xml</code> 中的配置高，同时出现时优先取 <code>AndroidManifest.xml</code> 中的配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">AVAnalytics.setAppChannel(<span class="string">"SomeChannel"</span>);</span><br><span class="line"><span class="comment">// 参数依次是 context, appId, appKey</span></span><br><span class="line">AVOSCloud.initialize(getContext(),<span class="string">"&#123;&#123;appid&#125;&#125;"</span>,<span class="string">"&#123;&#123;appKey&#125;&#125;"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="添加使用代码">添加使用代码</h2><h3 id="添加引用">添加引用</h3><p>经过我们的一系列更新升级，使用最新的 SDK 你不需要任何代码上的操作就可以使用统计的基本功能，统计功能为默认打开。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.avos.avoscloud.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YourApp</span> <span class="keyword">extends</span> <span class="title">Application</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        AVOSCloud.initialize(<span class="keyword">this</span>, <span class="string">"&#123;&#123;appid&#125;&#125;"</span>, <span class="string">"&#123;&#123;appkey&#125;&#125;"</span>);</span><br><span class="line">        <span class="comment">//AVAnalytics.start(this);    已经不再需要这行代码了</span></span><br><span class="line">        AVAnalytics.enableCrashReport(<span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="统计页面路径">统计页面路径</h2><p>在需要的 Activity 中调用统计 SDK。在每个 Activity 的 <code>onResume</code> 和 <code>onPause</code> 方法中调用相应的统计方法，传入的参数为当前 context（比如当前的 Activity）的引用。 这里请不要将全局的 Application Context 传入。如示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onPause();</span><br><span class="line">    AVAnalytics.onPause(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume();</span><br><span class="line">    AVAnalytics.onResume(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请确保在所需要的所有的 Activity 中都调用 <code>AVAnalytics.onResume()</code> 和 <code>AVAnalytics.onPause()</code> 方法，这两个调用将不会阻塞应用程序的主线程，也不会影响应用程序的性能。</p>
<p>注意：如果你的 Activity 之间有继承或者控制关系请不要同时在父和子 Activity 中重复添加 onPause 和 onResume 方法，否则会造成重复统计，比如在使用 TabHost、TabActivity、ActivityGroup 时。一个应用程序在多个 Activity 之间连续切换时，将会被视为同一个 session（会话或者一次使用过程）。</p>
<p>当用户两次使用之间间隔超过 30 秒时，将被认为是两个的独立的 session，例如用户回到 home，或进入其他程序，经过一段时间后再返回之前的应用。我们也提供了新的接口来自定义这个时间间隔，你只要调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVAnalytics.setSessionContinueMillis(<span class="keyword">long</span> mills);</span><br></pre></td></tr></table></figure>
<p>传入适当的参数，就可以控制 session 重新启动时间，注意参数是以毫秒为单位的。 例如，如果你认为在 60 秒之内返回应用可视为同一次启动，超过 60 秒返回当前应用可视为一次新的启动，那么请写成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVAnalytics.setSessionContinueMillis(<span class="number">60</span> * <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<h2 id="统计_Fragment_页面">统计 Fragment 页面</h2><p>Android 3.0 引入了 Fragment。使用 Fragment，你可以在一个 Activity 中展示多个用户界面，也可根据你的需要，为不同的设备适配界面。LeanCloud SDK 1.4.2 开始增加了对于 Fragment 统计的支持。你可以使用以下代码统计 Fragment 页面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListFragment</span> <span class="keyword">extends</span> <span class="title">ListFragment</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttach</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onAttach(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">        AVAnalytics.onFragmentEnd(<span class="string">"my-list-fragment"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        AVAnalytics.onFragmentStart(<span class="string">"my-list-fragment"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试">测试</h2><ul>
<li>确认所需的权限都已经添加：<ul>
<li><code>INTERNET</code></li>
<li><code>READ_PHONE_STATE</code></li>
<li><code>READ_LOGS</code></li>
<li><code>WRITE_EXTERNAL_STORAGE</code></li>
</ul>
</li>
<li>确认所有的 Activity 中都调用了 onResume 和 onPause 方法。</li>
<li>确认测试手机（或者模拟器）已成功连入网络。</li>
<li>启动应用程序，几分钟之内你应该已经可以在 <a href="/stat.html?appid=}#/statrealtime">控制台 / 分析</a> 中的相应菜单中看到报表了。</li>
</ul>
<h2 id="数据时效性">数据时效性</h2><p>在控制台的 <strong>分析</strong> 页面中，有些报告可以展示实时数据，有些报告则依靠 <a href="leaninsight_guide.html">离线数据</a> 进行分析，因此有时你会看不到当天的数据。</p>
<p>如果当前页面中存在 <strong>日期选择</strong> 选项（通常在页面右上角），你可以以此判断当前的统计结果是否有延迟。如果 <strong>结束日期</strong> 显示为 <strong>当日日期</strong> 或在其下拉菜单中有「今日」选项，即为实时数据；反之则为离线数据（如下图所示），要推迟一天才能看到当日的情况。</p>
<p><img src="../images/analytics_datepicker_for_offline_data.png" alt="" width="231" height="256"></p>
<h2 id="使用自定义事件">使用自定义事件</h2><h3 id="基本简单事件">基本简单事件</h3><p>除了基本统计分析功能外，SDK 还支持你自定义的事件分析，例如你可以统计你的应用中有多少人点击了 like 按键，某个文章的点击次数或者视频被播放的次数等等。</p>
<p>在你希望发送事件报告的代码段，调用如下方法就可以向服务器发送事件记录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVAnalytics.onEvent(Context context, String eventName);</span><br></pre></td></tr></table></figure>
<p>统计 eventName 对应事件的发生次数、变化趋势，例如 like 点击、浏览数量等等。参数 context 为当前 context 的引用。eventName 为当前统计的事件 name。【注意】eventName 中不要加空格或其他的转义字符。</p>
<p>比如，应用中的一条微视频被转发的事件被定义为「Forward」，那么在点击转发的函数里调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVAnalytics.onEvent(<span class="keyword">this</span>, <span class="string">"Forward"</span>)</span><br></pre></td></tr></table></figure>
<p>就会向服务器汇报一个转发的事件。</p>
<h3 id="多标签事件">多标签事件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVAnalytics.onEvent(Context context, String eventName, String  tag);</span><br></pre></td></tr></table></figure>
<p>除了能够统计 eventName 所对应事件的发生次数，变化趋势外，还能统计事件中具体标签所占的比例。tag 为当前标签，同样这里的 eventName 字符串中也请不要使用空格。<br>比如，在玩拍程序中，我们定义了一个发布微视频的多标签事件 Publish，对应的发布内容有 title（发布标题）、Video（发视频）、type（视频类型）来对应不同的发布类型，这样我们不仅可以记录 Publish 事件的点击数量还可以看到不同内容对应的比例。</p>
<h3 id="事件累计">事件累计</h3><p>在应用程序中某些自定义事件可能会被频繁触发，例如用户点击某个按钮。开发者可以在程序中维护一个计数器，这样某个事件被多次触发但只需要生成一个消息，这个消息中包括该事件被触发的次数。为了支持这个功能，我们提供了重载的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AVAnalytics.onEvent(Context context, String eventName, <span class="keyword">int</span> count);</span><br><span class="line">AVAnalytics.onEvent(Context context, String eventName, String label, <span class="keyword">int</span> count)</span><br></pre></td></tr></table></figure>
<p>参数 count 是对应事件（和对应标签）被触发的次数。</p>
<h2 id="设置数据发送策略">设置数据发送策略</h2><p>你可以进入应用的 <a href="/stat.html?appid=&amp;os=android#/statconfig/trans_strategoy"><strong>分析</strong> &gt; <strong>统计设置</strong><span class="text-muted">（左下角）</span> &gt; <strong>数据发送策略</strong></a> 在线更改 SDK 端的数据报告发送策略。在没有取到在线配置的发送策略的情况下，会使用默认的发送策略。</p>
<p>以下均为在线配置中的可选策略。</p>
<h3 id="启动时发送">启动时发送</h3><p>【推荐使用】应用程序每次会在启动时会向服务器发送一次消息，在应用程序过程中产生的所有消息（包括自定义事件和本次使用时长）都会在下次启动时候发送。如果应用程序启动时处在不联网状态，那么消息将会缓存在本地，下次再尝试发送。</p>
<p>发送策略默认为启动时发送。</p>
<h3 id="批量发送">批量发送</h3><p>批量发送，默认当消息数量达到 30 条时发送一次。</p>
<h3 id="按最小间隔发送">按最小间隔发送</h3><p>间隔一段时间发送，每隔一段时间一次性发送到服务器。</p>
<h2 id="自定义参数设置">自定义参数设置</h2><p>你可以控制台某个应用的 <strong>组件</strong> &gt; <strong>自定义参数</strong> 设置中配置你的自定义在线参数。这些参数会在我们每次更新统计配置时进行更新，你可以用以下方法来获得对应的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVAnalytics.getConfigParams(<span class="keyword">this</span>.getContext(), <span class="string">"key"</span>)</span><br></pre></td></tr></table></figure>
<p>但是请注意三点：</p>
<ul>
<li>key 必须跟你在控制台配置的参数一致，大小写敏感。</li>
<li><p>由于统计参数更新时一个后台更新，你可能在直接调用 <code>AVAnalytics.getConfigParams(this.getContext(), &quot;key&quot;)</code> 时遇到返回值为 null 的情况。你可以通过设置 AVOnlineConfigureListener 和强制调用 updateOnlineConfig 来保证自定义配置的获取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AVAnalytics.setOnlineConfigureListener(<span class="keyword">new</span> AVOnlineConfigureListener() &#123;</span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataReceived</span><span class="params">(JSONObject data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       AVAnalytics.getConfigParams(getContext(), <span class="string">"key"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;);</span><br><span class="line">AVAnalytics.updateOnlineConfig(getContext());</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于统计参数在客户端会有定时更新的策略，所以 AVOnlineConfigureListener 在客户端会发生多次调用的情况，请在 OnDataReceived 方法中不要放入太多函数副作用。</p>
</li>
</ul>
<h2 id="开发选项">开发选项</h2><p>如果你不准备区分开发 AppKey 与生产环境 AppKey，但是又不想开发时期的统计数据会影响产品上线后的统计数据，你可以使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AVAnalytics.setAnalyticsEnabled(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 参数依次为 context, AppId, AppKey</span></span><br><span class="line">AVOSCloud.initialize(context,&#123;&#123;appid&#125;&#125;,&#123;&#123;appkey&#125;&#125;);</span><br></pre></td></tr></table></figure>
<p>在开发阶段关闭统计的功能。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/cloud_code_faq/" itemprop="url">
                云引擎常见问题和解答
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/cloud_code_faq/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/cloud_code_faq/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="云引擎常见问题和解答">云引擎常见问题和解答</h1><h2 id="如何判断当前是测试环境还是生产环境？">如何判断当前是测试环境还是生产环境？</h2><p>请参考文档 <a href="/leanengine_guide-node.html#运行环境区分">云引擎开发指南 Node.js</a> / <a href="/leanengine_guide-python.html#运行环境区分">Python</a> - 运行环境区分。</p>
<h2 id="怎么添加第三方模块">怎么添加第三方模块</h2><p>云引擎 2.0 开始支持添加第三方模块（请参考 <a href="leanengine_guide-cloudcode.html#云代码_2_0_版">云引擎指南 - 升级到 2.0</a>），只需要像普通的 Node.js 项目那样，在项目根目录创建文件 <code>package.json</code>，下面是一个范例：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">name</span>": <span class="value"><span class="string">"cloud-engine-test"</span></span>,</span><br><span class="line">  "<span class="attribute">description</span>": <span class="value"><span class="string">"Cloud Engine test project."</span></span>,</span><br><span class="line">  "<span class="attribute">version</span>": <span class="value"><span class="string">"0.0.1"</span></span>,</span><br><span class="line">  "<span class="attribute">private</span>": <span class="value"><span class="literal">true</span></span>,</span><br><span class="line">  "<span class="attribute">dependencies</span>": <span class="value">&#123;</span><br><span class="line">    "<span class="attribute">async</span>": <span class="value"><span class="string">"0.9.0"</span></span>,</span><br><span class="line">    "<span class="attribute">moment</span>": <span class="value"><span class="string">"2.9.0"</span></span><br><span class="line">  </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p><code>dependencies</code> 内的内容表明了该项目依赖的三方模块（比如示例中的 <code>async</code> 和 <code>moment</code>）。</p>
<p>然后在项目根目录执行：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span></span><br></pre></td></tr></table></figure>
<p>即可下载相关三方包到 <code>node_modules</code> 目录。</p>
<p>然后即可在代码中引入三方包：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">async</span> = <span class="built_in">require</span>(<span class="string">'async'</span>);</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：命令行工具部署时是不会上传 <code>node_modules</code> 目录，因为云代码服务器会根据 <code>package.json</code> 的内容自动下载三方包。所以也建议将 <code>node_modules</code> 目录添加到 <code>.gitignore</code> 中，使其不加入版本控制。</p>
<h2 id="Maximum_call_stack_size_exceeded_如何解决？">Maximum call stack size exceeded 如何解决？</h2><p><code>AV.Object.extend</code> 产生的对象需要作为全局变量保存（即定义在 AV.Cloud.define 方法之外）。因为每调用一次，就会产生一个新的类的实例，并且和之前创建的实例形成一个链表。调用次数过多后（几万次）就会堆栈溢出。如果你的应用时不时出现 <strong>Maximum call stack size exceeded</strong> 错误，请确认是否误用了 <code>AV.Object.extend</code> 方法。</p>
<p>我们在 <a href="./js_guide.html#AV_Object">JavaScript 指南 - AV.Object</a> 章节中也进行了描述。</p>
<h2 id="目前支持哪些语言？">目前支持哪些语言？</h2><p>我们提供了 JavaScript SDK，支持 Node.js 和 Python 环境，未来可能会引入 PHP 等其他语言。</p>
<h2 id="Web_Hosting_备案如何操作？">Web Hosting 备案如何操作？</h2><p>只有网站类的才需要备案，并且在主域名已备案的情况下，二级子域名不需要备案。 如果主站需要托管在我们这边，且还没有备案过，我们可以协助你完成备案，请参考文档 <a href="leanengine_guide-node.html#绑定独立域名">绑定独立域名 Node.js</a> / <a href="leanengine_guide-python.html#绑定独立域名">Python</a>。</p>
<h2 id="调用云引擎方法如何收费？">调用云引擎方法如何收费？</h2><p>现在云引擎本身不收费，云引擎中如果有 LeanCloud 的存储等 API 调用，按 API 收费策略收费。</p>
<h2 id="「定义函数」和「Git_部署」可以混用吗？">「定义函数」和「Git 部署」可以混用吗？</h2><p>「定于函数」的产生是为了方便大家初次体验云引擎，或者只是需要一些简单 hook 方法的应用使用。我们的实现方式就是把定义的函数拼接起来，生成一个云引擎项目然后部署。</p>
<p>所以可以认为「定义函数」和 「git 部署」最终是一样的，都是一个完整的项目。<br>是一个单独功能，可以不用使用基础包，git 等工具快速的生成和编辑云引擎。<br>当然，你也可以使用基础包，自己写代码并部署项目。<br>这两条路是分开的，任何一个部署，就会导致另一种方式失效掉。</p>
<h2 id="为什么查询_include_没有生效？">为什么查询 include 没有生效？</h2><p>以 JavaScript 云引擎为例子，很多时候，经常会定义一个云函数，在里面使用 <code>AV.Query</code> 查询一张表，并 include 其中一个 pointer 类型的字段，然后返回给客户端:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AV.Cloud.define(<span class="string">'querySomething'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> query = <span class="keyword">new</span> AV.Query(<span class="string">'Something'</span>);</span><br><span class="line">  <span class="comment">//假设 user 是 Something 表的一个 Pointer 列。</span></span><br><span class="line">  query.include(<span class="string">'user'</span>);</span><br><span class="line">  <span class="comment">//……其他条件或者逻辑……</span></span><br><span class="line">  query.find().then(<span class="function"><span class="keyword">function</span>(<span class="params">results</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//返回查询结果给客户端</span></span><br><span class="line">    res.success(results);</span><br><span class="line">  &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//返回错误给客户端</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>你会看到返回的结果里， user 仍然是 pointer 类型，似乎 include 没有生效？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> result: [</span><br><span class="line">   &#123;</span><br><span class="line">     ……Something 其他字段</span><br><span class="line">     "user": &#123;</span><br><span class="line">       "className": "_User",</span><br><span class="line">       "__type": "Pointer",</span><br><span class="line">       "objectId": "abcdefg"</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ……</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这其实是因为 <code>res.success(results)</code> 会调用到 <code>AV.Object#toJSON</code> 方法，将结果序列化为 JSON 对象返回给客户端。<br>而 <code>AV.Object#toJSON</code> 方法为了防止循环引用，当遇到属性是 Pointer 类型会返回 pointer 元信息，不会将 include 的其他字段添加进去。<br>因此，你需要主动将该字段进行 JSON 序列化，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">query.find().then(<span class="function"><span class="keyword">function</span>(<span class="params">results</span>) </span>&#123;</span><br><span class="line">   <span class="comment">//主动序列化 json 列。</span></span><br><span class="line">   results.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">     result.set(<span class="string">'user'</span>, result.get(<span class="string">'user'</span>) ?  result.get(<span class="string">'user'</span>).toJSON() : <span class="literal">null</span>);</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="comment">//再返回结果</span></span><br><span class="line">   res.success(results);</span><br><span class="line"> &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">   <span class="comment">//返回错误给客户端</span></span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/cql_guide/" itemprop="url">
                Cloud Query Language
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/cql_guide/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/cql_guide/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="Cloud_Query_Language_详细指南">Cloud Query Language 详细指南</h1><p>Cloud Query Language（简称 CQL） 是 LeanCloud 为查询 API 定制的一套类似 SQL 查询语法的子集和变种，主要目的是降低大家学习 LeanCloud 查询的 API 的成本，可以使用传统的 SQL 语法来查询 LeanCloud 应用内的数据。</p>
<p>本文档将详细介绍 CQL 的语法和常见用法。</p>
<h2 id="介绍及基本语法">介绍及基本语法</h2><p>最基本的一个查询某个 class 下的 100 条数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore</span></span><br></pre></td></tr></table></figure>
<p>等价于（以 Android 为例子）:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AVQuery&lt;AVObject&gt; query = <span class="keyword">new</span> AVQuery&lt;AVObject&gt;(<span class="string">"GameScore"</span>);</span><br><span class="line">List&lt;AVObject&gt; avObjects = query.find()</span><br></pre></td></tr></table></figure>
<p><code>select</code> 一个完整的语法形式类似这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> [查询字段列表，逗号隔开] <span class="keyword">from</span> [<span class="keyword">class</span> 名称]</span><br><span class="line">   [<span class="keyword">where</span> [条件列表]</span><br><span class="line">   [<span class="keyword">limit</span> [<span class="keyword">skip</span>],<span class="keyword">limit</span></span><br><span class="line">   [<span class="keyword">order</span> <span class="keyword">by</span> [排序字段列表] [<span class="keyword">asc</span> |<span class="keyword">desc</span>]]]]</span></span><br></pre></td></tr></table></figure>
<p>一些小例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//查询结果只包含 name,score 以及内置字段(objectId,createdAt等)</span><br><span class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">name</span>,score <span class="keyword">from</span> GameScore</span><br><span class="line"></span><br><span class="line">//根据 <span class="keyword">name</span> 查找</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'dennis'</span></span><br><span class="line"></span><br><span class="line">//根据 <span class="keyword">name</span> 和 score 同时查找</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">is</span> <span class="keyword">exists</span> <span class="keyword">and</span> score &gt; <span class="number">80</span> <span class="keyword">and</span> score &lt;= <span class="number">100</span></span><br><span class="line"></span><br><span class="line">//分页查找，从第 <span class="number">100</span> 条开始向后查找 <span class="number">10</span> 条数据</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">limit</span> <span class="number">100</span>,<span class="number">10</span></span><br><span class="line"></span><br><span class="line">//根据 score 和 <span class="keyword">name</span> 排序</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">order</span> <span class="keyword">by</span> score,+<span class="keyword">name</span> <span class="keyword">desc</span></span></span><br></pre></td></tr></table></figure>
<h2 id="查询条件">查询条件</h2><p><code>where</code> 之后的查询条件基本跟 SQL 语法相似，比如支持 <code>or</code> 和 <code>and</code> 的复合查询，支持 <code>=</code>、<code>!=</code>、<code>&lt;</code>、<code>&lt;</code> 等比较运算符，支持子查询、in 查询等。详细解释如下。</p>
<h3 id="基本查询">基本查询</h3><p>查询指定信息的对象，用 <code>=</code> 比较符：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'dennis'</span></span></span><br></pre></td></tr></table></figure>
<p>查询不等于指定信息的对象：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span>!=<span class="string">'dennis'</span></span></span><br></pre></td></tr></table></figure>
<p>也可以用 <code>&lt;&gt;</code> 运算符来表示不等于。</p>
<p>比较日期，使用 <code>date</code> 函数来转换，比如查询特定时间之前创建的对象：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> createdAt &lt; <span class="built_in">date</span>(<span class="string">'2011-08-20T02:06:57.931Z'</span>)</span></span><br></pre></td></tr></table></figure>
<p>date 函数接收的日期格式必须是 <code>2011-08-20T02:06:57.931Z</code> 的 UTC 时间。更多内置函数请看最后的 <a href="#内置函数">内置函数</a> 部分。</p>
<p>一些常见的查询运算符：</p>
<table><br>  <tr><th>Key</th><th>Operation</th></tr><br>  <tr><td>&lt;</td><td>小于</td></tr><br>  <tr><td>&lt;=</td><td>小于等于</td></tr><br>  <tr><td>&gt;</td><td>大于</td></tr><br>  <tr><td>&gt;=</td><td>大于等于</td></tr><br>  <tr><td> != 或者 &lt;&gt;</td><td>不等于</td></tr><br>  <tr><td>[not] like</td><td>模糊查询</td></tr><br>  <tr><td>[not] regexp</td><td>正则匹配</td></tr><br>  <tr><td>[not] in(子查询或者数组)</td><td>包含或者不包含</td></tr><br>  <tr><td>is [not] exists</td><td>这个 Key 有值或者不存在值</td></tr><br></table>

<p>比较运算符可以用在日期、字符串、数字甚至对象上。</p>
<h4 id="模糊查询">模糊查询</h4><p>模糊查询可以使用 <code>like</code>，比如查询名字以 dennis 开头的对象。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'dennis%'</span></span></span><br></pre></td></tr></table></figure>
<p><code>%</code> 表示模糊匹配的位置占位符。</p>
<p>like 本质上是转成 <code>regexp</code> 的正则匹配查询，因此上面的例子还可以写成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span> regexp <span class="string">'dennis.*'</span></span></span><br></pre></td></tr></table></figure>
<p>否定形式，查询名字不以 dennis 开头的对象：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">not</span> <span class="keyword">like</span> <span class="string">'dennis%'</span></span><br><span class="line">或者</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">not</span> regexp <span class="string">'dennis.*'</span></span></span><br></pre></td></tr></table></figure>
<p>正则匹配的效率一般，类似这种全文搜索请求，我们都推荐采用 <a href="app_search_guide.html">应用内全文搜索</a>。</p>
<h5 id="值是否存在查询">值是否存在查询</h5><p>只返回 <code>level</code> 字段值存在的对象：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">level</span> <span class="keyword">is</span> <span class="keyword">exists</span></span></span><br></pre></td></tr></table></figure>
<p>反之，使用 <code>is not exists</code>。</p>
<h3 id="数组查询">数组查询</h3><p>假设 <code>scores</code> 字段是一个数组，我们想查询分数里有 100 的成绩列表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> scores=<span class="number">100</span></span></span><br></pre></td></tr></table></figure>
<p>如果想查找分数<strong>只有</strong>两个 100 分的成绩：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> scores all (<span class="number">100</span>,<span class="number">100</span>)</span></span><br></pre></td></tr></table></figure>
<p><code>all</code> 表示数组完全匹配。</p>
<p>查询数组长度为特定值的对象：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="function"><span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="title">size</span>(<span class="params">scores</span>) </span>= <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>数组长度查询仅支持等于号，不支持大小和小于等其他比较运算符。</p>
<h3 id="子查询">子查询</h3><p>使用 <code>in</code> 来做子查询，后面跟的可以是一个列表，例如查询名字是 dennis、catty 和 green 三个玩家的成绩：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">in</span> (<span class="string">'dennis'</span>,<span class="string">'catty'</span>,<span class="string">'green'</span>)</span></span><br></pre></td></tr></table></figure>
<p>当然，如果想查询的不在列表里，那可以使用 <code>not in</code>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">'dennis'</span>,<span class="string">'catty'</span>,<span class="string">'green'</span>)</span></span><br></pre></td></tr></table></figure>
<p>in 后面还可以是一个子查询，比如查询玩家信息，并且成绩大于 80 分的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> Player <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> GameScore <span class="keyword">where</span> score&gt;<span class="number">80</span>)</span></span><br></pre></td></tr></table></figure>
<p>注意子查询必须指定查询的字段名称是 <code>select name</code>。</p>
<p>子查询另一种常见形式是使用 <code>=</code> 或 <code>!=</code> 跟一条查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> Player <span class="keyword">where</span> <span class="keyword">name</span> =(<span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> GameScore <span class="keyword">where</span> score&gt;<span class="number">80</span>)</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> Player <span class="keyword">where</span> <span class="keyword">name</span> !=(<span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> GameScore <span class="keyword">where</span> score&lt;=<span class="number">80</span>)</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：子查询的语句也受上限 1000 条记录的限制。</strong></p>
<h3 id="地理位置信息查询">地理位置信息查询</h3><p>可以通过 CQL 进行地理位置信息查询，比如我想查询自己附近的玩家（从近到远排序），假设 <code>location</code> 字段是 GeoPoint 类型：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> Player <span class="keyword">where</span> location near [<span class="number">116.4</span>, <span class="number">39.9</span>]</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>[116.4, 39.9]</code> 是经纬度坐标。也可以使用 <code>geopoint</code> 函数来创建：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> Player <span class="keyword">where</span> location near geopoint(<span class="number">116.4</span>, <span class="number">39.9</span>)</span></span><br></pre></td></tr></table></figure>
<p>只有在地理位置信息查询里才可以使用 <code>[longitude, latitude]</code> 这样的语法。在其他查询里将被作为数组类型。</p>
<p>为了限定搜索的最大距离，还可以使用 <code>max [距离]</code> 来限定，比如限定在 1 公里内：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> Player <span class="keyword">where</span> location near geopoint(<span class="number">116.4</span>, <span class="number">39.9</span>) <span class="keyword">max</span> <span class="number">1</span> km</span></span><br></pre></td></tr></table></figure>
<p>距离长度的其他单位包括 <code>miles</code>（英里）和 <code>radians</code>（弧度），如果不提供明确的单位，默认是<strong>弧度</strong>。</p>
<p>通过 <code>min [距离]</code> 还可以限定最小距离：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> Player <span class="keyword">where</span> location near geopoint(<span class="number">116.4</span>, <span class="number">39.9</span>) <span class="keyword">min</span> <span class="number">0.5</span> km</span></span><br></pre></td></tr></table></figure>
<p><code>min</code> 和 <code>max</code> 同时限定的时候，<code>min</code> 必须出现在 <code>max</code> 之前：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> Player <span class="keyword">where</span> location near geopoint(<span class="number">116.4</span>, <span class="number">39.9</span>) <span class="keyword">min</span> <span class="number">0.5</span> km <span class="keyword">max</span> <span class="number">1</span> km</span></span><br></pre></td></tr></table></figure>
<p>如果想查询某个矩形框内的对象，可以使用 <code>within [西南坐标] and [东北坐标]</code> 的语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> Player <span class="keyword">where</span> location <span class="keyword">within</span> [<span class="number">116.33</span>, <span class="number">39.97</span>] <span class="keyword">and</span> [<span class="number">116.37</span>, <span class="number">39.99</span>]</span></span><br></pre></td></tr></table></figure>
<h3 id="查询个数(count)">查询个数(count)</h3><p>使用 <code>count</code> 查询来返回符合查询条件的数目，比如查询整张表的记录数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> GameScore</span></span><br></pre></td></tr></table></figure>
<p><code>count</code> 不支持 <code>distinct</code> 等语法。仅限 <code>count(*)</code> 和 <code>count(objectId)</code>。</p>
<p>查询分数大于 60 并且小于等于 80 的成绩数目：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> GameScore <span class="keyword">where</span> score&gt;<span class="number">60</span> <span class="keyword">and</span> score&lt;=<span class="number">80</span></span></span><br></pre></td></tr></table></figure>
<p>查询个数的同时可以返回对象：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">count</span>(*),* <span class="keyword">from</span> GameScore</span></span><br></pre></td></tr></table></figure>
<p>也可以返回特定的字段：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">count</span>(*),<span class="keyword">name</span> <span class="keyword">from</span> GameScore</span></span><br></pre></td></tr></table></figure>
<h3 id="关系查询">关系查询</h3><p>有几种方式来查询对象之间的关系数据。如果你想获取对象，而这个对象的一个字段对应了另一个对象， 你可以用一个 where 查询，自己构造一个 Pointer，和其他数据类型一样。</p>
<p>举例说，如果每一个 Comment 有一个 Post 对象在它的 post 字段上（Pointer 类型），你可以对一个 post 取得所有 comment：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">Comment</span> <span class="keyword">where</span> post=pointer(<span class="string">'Post'</span>,<span class="string">'51e3a359e4b015ead4d95ddc'</span>)</span></span><br></pre></td></tr></table></figure>
<p><code>pointer</code> 函数接收 className 和 objectId。</p>
<p>如果你想获取对象, 这个对象的一个字段指向的对象（必须是 Pointer）是符合另一个查询的， 你可以使用 in 查询。注意默认的 limit 是 100 而且最大的 limit 是 1000，这个限制同样适用于内部的查询，所以对于较大的数据集你可能需要细心地构建查询来获得期望的行为。举例说，假设你有一个 Post 类和一个 Comment 类，每个 Comment 都有一个指向它的 Post 的 Pointer，你可以找到对于有图片的 Post 的 Comment：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">Comment</span> <span class="keyword">where</span> post <span class="keyword">in</span> (<span class="keyword">select</span> * <span class="keyword">from</span> Post <span class="keyword">where</span> image <span class="keyword">is</span> <span class="keyword">exists</span>)</span></span><br></pre></td></tr></table></figure>
<p>如果 Post 下面有一个 key 是 Relation 类型，并且叫做 likes，存储了喜欢这个 Post 的 User。你可以找到这些 user，他们都 like 过同一个指定的 post：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> _User <span class="keyword">where</span> related likes <span class="keyword">to</span> pointer(<span class="string">'Post'</span>, <span class="string">'51e3a359e4b015ead4d95ddc'</span>)</span></span><br></pre></td></tr></table></figure>
<p>基本的查询形式是 <code>releated &lt;key&gt; to &lt;pointer&gt;</code>。</p>
<p>如果某个字段是 Pointer，默认查询的时候，只会返回 <code>{__type: &#39;Pointer&#39;, objectId: &#39;objectId&#39;, className:&#39;Post&#39;}</code> 这些基本信息，如果希望同时将这个对象的其他信息查询下来，可以使用 include，比如查询 Comment 同时将 Post 带下来：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">include</span> post, * <span class="keyword">from</span> <span class="keyword">Comment</span></span></span><br></pre></td></tr></table></figure>
<p>在 select 中采用 <code>include &lt;key&gt;</code> 就可以将某个 Pointer 字段关联查询出来。多个字段要多次 include：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">include</span> post,<span class="keyword">include</span> author <span class="keyword">from</span> <span class="keyword">Comment</span></span></span><br></pre></td></tr></table></figure>
<p>同样，还可以支持嵌套的 include 查询，比如 Post 里还有一个 Pointer 指向 Category：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">include</span> post.<span class="keyword">category</span>,* <span class="keyword">from</span> <span class="keyword">Comment</span></span></span><br></pre></td></tr></table></figure>
<h3 id="复合查询">复合查询</h3><p>你可以使用 <code>and</code> 和 <code>or</code> 来做符合查询，例如查询分数在 80 到 100 之间，可以用 <code>and</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> score&gt;<span class="number">80</span> <span class="keyword">and</span> score&lt;=<span class="number">100</span></span></span><br></pre></td></tr></table></figure>
<p>再加个条件，或者分数为 0 分的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> score&gt;<span class="number">80</span> <span class="keyword">and</span> score&lt;=<span class="number">100</span> <span class="keyword">or</span> score=<span class="number">0</span></span></span><br></pre></td></tr></table></figure>
<p><code>and</code> 的优先级高于 <code>or</code>，因此上面的查询也可以用括号来明确地表示这种优先级：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> (score&gt;<span class="number">80</span> <span class="keyword">and</span> score&lt;=<span class="number">100</span>) <span class="keyword">or</span> score=<span class="number">0</span></span></span><br></pre></td></tr></table></figure>
<h2 id="限定返回值">限定返回值</h2><p>通过 <code>limit</code> 语句来限定返回结果大小，比如限定返回 100 个：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">Comment</span> <span class="keyword">limit</span> <span class="number">100</span></span></span><br></pre></td></tr></table></figure>
<p>可以设定从第 m+1 个元素开始，例如从第 101 个元素（包含）开始往后取 10 个：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">Comment</span> <span class="keyword">limit</span> <span class="number">100</span>,<span class="number">10</span></span></span><br></pre></td></tr></table></figure>
<p>这个形式跟 MySQL 是类似的。</p>
<h3 id="占位符">占位符</h3><p>查询条件和 limit 子句还支持占位符，也就是可以用问号 <code>?</code> 替代值，值的列表通过 SDK 提供的方法传入，具体请参考各 SDK 用法，例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span>=? <span class="keyword">and</span> score&gt;? <span class="keyword">limit</span> ?,?</span></span><br></pre></td></tr></table></figure>
<p>占位符支持所有 LeanCloud 平台上的有效类型，复杂类型（如日期、GeoPoint）要求以 <a href="./rest_api.html#数据类型">REST API</a> 文档说明的 JSON 格式来提供。</p>
<p><strong>我们推荐使用占位符的方式来使用 CQL，查询语句可以通过预编译被缓存起来，降低 CQL 的转换开销。</strong></p>
<h2 id="排序">排序</h2><p>通过 <code>order</code> 语句来排序，<code>order</code> 语句只能出现在最后，不能在 <code>where</code> 和 <code>limit</code> 之前。</p>
<p>例如按照分数倒序排（分数高的前）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span></span></span><br></pre></td></tr></table></figure>
<p>也可以写成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">order</span> <span class="keyword">by</span> -score</span></span><br></pre></td></tr></table></figure>
<p>加号表示升序，减号表示降序。</p>
<p>多个字段组合排序，例如分数高的前，名字相同的「更小」的在前（字母顺序）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">order</span> <span class="keyword">by</span> -score,<span class="keyword">name</span></span></span><br></pre></td></tr></table></figure>
<p>同样的语句可以写成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">order</span> <span class="keyword">by</span> score,+<span class="keyword">name</span> <span class="keyword">desc</span></span><br><span class="line">或者</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">order</span> <span class="keyword">by</span> -score,<span class="keyword">name</span> <span class="keyword">asc</span></span></span><br></pre></td></tr></table></figure>
<p>没有写上明确的加号或者减号的字段，将根据最后的 <code>desc</code> 或者 <code>asc</code> 来决定采用升序还是降序。</p>
<h2 id="内置函数">内置函数</h2><p>CQL 提供了一些内置函数来方便地创建 pointer、geopoint 等类型：</p>
<table><br>  <tr><th>Name</th><th>Operation</th></tr><br>  <tr><td>date(‘YYYY-MM-DDTHH:MM:SS.MMMMZ’)</td><td>创建日期类型</td></tr><br>  <tr><td>pointer(className, objectId)</td><td>创建 Pointer</td></tr><br>  <tr><td>geopoint(经度, 纬度)</td><td>创建 GeoPoint</td></tr><br>  <tr><td>file(objectId)</td><td>创建 file 类型</td></tr><br>  <tr><td>base64(base64编码字符串)</td><td>创建 Bytes 类型</td></tr><br>  <tr><td>current_timestamp()</td><td>创建当前日期</td></tr><br></table>

<p>如果不使用这些函数，你也使用 <a href="./rest_api.html#数据类型">REST API 文档</a> 定义的 JSON 对象来创建特定类型，例如 Pointer：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">Comment</span> <span class="keyword">where</span> post=</span><br><span class="line">  &#123;className:<span class="string">'Post'</span>, objectId:<span class="string">'51e3a334e4b0b3eb44adbe1a'</span>,__type:<span class="string">'Pointer'</span>&#125;</span></span><br></pre></td></tr></table></figure>
<p>当然这样写就相对繁琐了。</p>
<h2 id="性能和建议">性能和建议</h2><p>CQL 最终还是转换成 <a href="./rest_api.html">REST API</a> 里查询部分提到的各种 where 条件，因为多了一层转换，理论上会比直接使用 <code>where</code> 查询慢一点。并且 CQL 对长度有所限制，要求在 4096 字节以内。</p>
<p>此外，我们推荐查询语句都采用占位符的方式，使用占位符的查询语句将有机会被缓存复用，避免重复解释的开销。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/data_security/" itemprop="url">
                数据和安全
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/data_security/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/data_security/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="数据和安全">数据和安全</h1><h2 id="安全总览">安全总览</h2><p>几乎每一位使用 LeanCloud 的用户都会问，如何能够保证自己应用的安全？对安全的关注说明你也位对产品负责、对用户负责、对自己负责、做事态度认真的开发者，这也正是 <a href="http://open.leancloud.cn" target="_blank" rel="external">LeanCloud 所信守的价值观</a>。</p>
<p>安全界有个说法——绝对的安全是不存在的。其中关键要点是要梳理清楚「安全边界」，即你对于业务安全范围的一个清晰的界定。业内一个很著名的例子就是 Chrome 浏览器的查看密码功能，查看已存储的密码不需要再输入 Google 账号的密码。</p>
<p>LeanCloud 通过以下三重级别来总体控制每个应用的安全：</p>
<ul>
<li>SSL 安全连接（HTTPS）</li>
<li>Web 安全域名</li>
<li>ACL 权限控制</li>
</ul>
<p>数据层面，云端每天会备份一次数据，防止误操作等情况删除重要数据。其他安全设置还包括云端验证和检测，比如实时通信可以支持自定义的云端认证、短信验证的各种安全设置、SDK 中的各种安全细节等。</p>
<p>每个应用都有自己的 AppId，并且需要通过这个唯一的 id 从服务端申请和调用资源。理论上说这个 AppId 应该严格保密，但是实际中它总会泄露。如果说用反编译原生应用的方法来破解 AppId 还要费些周折，那对于 Web 应用，只要查看到页面源码就能找出 AppId。所以我们要需要做哪些防御？关键点是，我们要能够保证其他人把你的 AppId 偷过去之后，他也无法直接使用你的服务器资源。Web 端可以通过 <code>Web 安全域名</code> 来对请求来源做限制，可以简单的防御住 Web 的服务器资源盗取。但是 <strong>安全域名</strong> 对 Native 类的应用又是无效的，所以如果你是使用 Native App 的 SDK，那么设置安全域名就不够了，这个时候就要考虑使用「ACL 权限控制」。</p>
<p>注意，这里每次的调整都是对安全边界的一次次评估，不是每个设置每个应用都需要如此操作。</p>
<p>ACL 权限控制是如何管理安全的呢？举个例子：</p>
<p>比如你要做一个账号系统，这个系统中每个用户账号都有头像，所以你会有一个用户上传头像接口。那么，如果你把这个上传头像的功能放在注册成功之前，每个没有经过你的 ACL 权限认证（没有登录）的用户都可以通过这个接口上传头像，所以你这个上传头像的接口是存在滥用的。如果接口 ACL 权限设置为注册成功的某类用户，则用户必须要经过 ACL 权限认证为是属于某个权限的用户（即登录），并且此时他才可以使用这个接口。所以，上传接口如此，其他的类似功能也是同理，但凡是通过 SDK 或者 API 调用的接口操作，你都要确保他们的 ACL 权限控制是在你的控制范围内。这需要你的智慧和设计来保证安全，相信你也一定能做到。</p>
<p>SSL 其实没有什么好说的，所有的数据都采用加密链路，这样做可以保证数据的私密性。</p>
<p>总之，一切安全设计的背后都是需要你考虑清楚你的 App、你的产品的「安全边界」，制定对应的安全策略。当然安全是后话，首先通过使用 LeanCloud 节省大量时间成本、研发成本、机会成本把产品快速迭代起来才是正经事。</p>
<h2 id="安全中心">安全中心</h2><p>安全中心，是我们为每个应用提供的设置基本安全的入口，位置在 <a href="/app.html?appid=#/security">控制台 / 设置 / 安全中心</a>。</p>
<h3 id="服务开关">服务开关</h3><p>服务开关，是用来开启或者关闭当前应用所使用的服务，从根本上防止由于 AppId 和 AppKey 泄露后而可能会引发的服务资源被盗取的问题。</p>
<p><img src="/avos/images/security/service-switch.png" alt="image"></p>
<h3 id="Web_安全域名">Web 安全域名</h3><p>如果在前端使用 JavaScript SDK，当你打算正式发布出去的时候，请务必配置 <strong>Web 安全域名</strong>，方法是进入 <a href="/app.html?appid=#/security">控制台 / 设置 / 安全中心 / <strong>Web 安全域名</strong></a>。</p>
<p>设置「Web 安全域名」后，仅可在该域名下通过 JavaScript SDK 调用服务器资源，域名配置策略与浏览器域安全策略一致，要求域名协议、域和端口号都需严格一致，不支持子域和通配符。所以如果你要配置一个域名，要写清楚协议、域和端口，缺少一个都可能导致访问被禁止。举例说明一下域名的区别：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跨域</span></span><br><span class="line">www<span class="class">.a</span><span class="class">.com</span>:<span class="number">8080</span></span><br><span class="line">www<span class="class">.a</span><span class="class">.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 跨域 </span></span><br><span class="line">www<span class="class">.a</span><span class="class">.com</span>:<span class="number">8080</span></span><br><span class="line">www<span class="class">.a</span><span class="class">.com</span>:<span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 跨域  </span></span><br><span class="line"><span class="tag">a</span><span class="class">.com</span></span><br><span class="line">www<span class="class">.a</span><span class="class">.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 跨域</span></span><br><span class="line">xxx<span class="class">.a</span><span class="class">.com</span></span><br><span class="line">www<span class="class">.a</span><span class="class">.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同协议，跨域         </span></span><br><span class="line">http:</span><br><span class="line">https:</span><br></pre></td></tr></table></figure>
<p>这样就可以防止其他人通过外网其他地址盗用你的服务器资源。但是要注意，<strong>Web 安全域名</strong>所能达到的目的是防御恶意部署，而不是防御伪造脏数据（恶意用户通过绑定 host 方式还是有可能访问到应用的数据），所以要想对数据进行更多细粒度的控制，需要配合 ACL 来使用。</p>
<p>在 WebView 中使用，建议通过 WebView 去加载一个部署好的、有域名的 Web，然后缓存在本地，这样可以通过 <strong>Web 安全域名</strong> 来做限制。</p>
<p><img src="/avos/images/security/web-host.png" alt="image"></p>
<h3 id="操作日志">操作日志</h3><p>操作日志中会显示应用创建者及所有协作者的重要操作记录，比如删除数据操作的历史、操作用户名、操作 IP 及操作时间等，这个日志的目的是为了遇到问题更好地定位故障缘由，排查可能的恶意操作，防止应用数据被错误地改动。</p>
<h2 id="数据">数据</h2><h3 id="自动备份">自动备份</h3><p>LeanCloud 目前会每天备份一次应用数据，防止用户误操作删除了重要数据。如果发生误删除，请及时联系我们进行恢复。</p>
<h3 id="有效的数据类型">有效的数据类型</h3><p>我们已经仔细设计并实现了客户端 SDK，在你使用 iOS 或者 Android SDK 的时候，通常来说你不需要担心数据是如何保存的。只要简单地往 AVObject 添加数据，它们都能被正确地保存。</p>
<p>尽管如此，有些情况下了解数据如何存储在 LeanCloud 平台上还是有一些用处。</p>
<p>在平台内部，LeanCloud 将数据存储为 JSON，因此所有能被转换成 JSON 的数据类型都可以保存在 LeanCloud 平台上。并且，框架还可以处理日期、Bytes 以及文件类型。总结来说，对象中字段允许的类型包括：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>字符串</td>
</tr>
<tr>
<td>Number</td>
<td>数字</td>
</tr>
<tr>
<td>Boolean</td>
<td>布尔类型</td>
</tr>
<tr>
<td>Array</td>
<td>数组</td>
</tr>
<tr>
<td>Object</td>
<td>对象，或者 Pointer </td>
</tr>
<tr>
<td>Date</td>
<td>日期</td>
</tr>
<tr>
<td>Bytes</td>
<td>Base64 编码的二进制数据</td>
</tr>
<tr>
<td>File</td>
<td>文件</td>
</tr>
<tr>
<td>Null</td>
<td>空值</td>
</tr>
</tbody>
</table>
<p>Object 类型简单地表示每个字段的值都可以由能 JSON 编码的内嵌对象组合而成。凡是对象的键（key） 包含 <code>$</code> 或者 <code>.</code>，或者同时有 <code>__type</code> 键，都是框架内保留用来做一些额外处理的特殊键，因此请不要在你的对象中使用这样的 Key。</p>
<p>我们的 SDK 会处理原生的 Objective-C 和 Java 类型到 JSON 之间的转换。例如，当你保存一个 NSString 对象的时候，它在我们的系统中会被自动转换成 String 类型。</p>
<p>有两种方式可以存储原生的二进制数据。Bytes 类型允许直接在 AVObject 中关联 NSData 或者 bytes[] 类型的数据。这种方式只推荐用来存储小片的二进制数据。当要保存实际文件（例如图片、视频、文档等），请使用 AVFile 来表示 File 类型，并且 File 类型可以被保存到对象字段中关联起来。</p>
<h3 id="数据类型锁定">数据类型锁定</h3><p>当一个 Class 初次创建的时候，它不包含任何预先定义并继承的 schema。也就是说对于存储的第一个对象，它的字段可以包含任何有效的类型。</p>
<p>但是，当一个字段被保存至少一次的时候，这个字段将被锁定为保存过的数据类型。例如，如果一个 User 对象保存了一个字段 name，类型为 String，那么这个 name 字段将被严格限制为只允许保存 String 类型。如果你尝试保存其他类型到这个字段，我们的 SDK 会返回错误。</p>
<p>一个特例是任何字段都允许被设置为 null，无论它是什么类型。</p>
<h3 id="数据管理">数据管理</h3><p><a href="/data.html?appid=&lt;!--￼11--">数据管理</a> 是一个允许在你任意的一个应用里更新或者创建对象的一个 Web 界面的管理平台。在这里，你可以看到保存在 Class里的每个对象的原生 JSON 值。</p>
<p>当使用这个平台的时候，请牢记：</p>
<ul>
<li>输入 <code>null</code> 将会将值设为特殊的空值 <strong>null</strong>，而非字符串 <code>&quot;null&quot;</code>。</li>
<li>objectId、createdAt 和 updatedAt 不可编辑，它们都是系统自动设置的。</li>
<li>下划线开始的 Class 为系统内置数据表，不可删除，并且请轻易不要修改它的默认字段，但是可以向其中添加字段。</li>
</ul>
<h3 id="导入数据">导入数据</h3><p>除了 REST API 之外，我们还提供通过 JSON 文件和 CSV 格式文件的导入数据的功能。</p>
<p>要使用 JSON 文件创建一个新 Class，请进入 <a href="/data.html?appid=&lt;!--￼12--">控制台 / 存储 / 数据管理</a>，点击左侧 Class 导航栏的小齿轮图标，选择 <strong>数据导入</strong>。</p>
<div class="callout callout-info">数据文件的扩展名必须是 <code>.csv</code> 或者 <code>.json</code> 结尾，我们以此来判断导入数据的类型。</div>

<h4 id="JSON_文件格式">JSON 文件格式</h4><p>JSON 格式要求是一个符合我们 REST 格式的 JSON 对象数组，或者是一个包含了键名为 results、值为对象数组的 JSON 对象。例如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123; "<span class="attribute">results</span>": <span class="value">[</span><br><span class="line">  &#123;</span><br><span class="line">    "<span class="attribute">likes</span>": <span class="value"><span class="number">2333</span></span>,</span><br><span class="line">    "<span class="attribute">title</span>": <span class="value"><span class="string">"讲讲明朝的那些事儿"</span></span>,</span><br><span class="line">    "<span class="attribute">author</span>": <span class="value">&#123;</span><br><span class="line">      "<span class="attribute">__type</span>": <span class="value"><span class="string">"Pointer"</span></span>,</span><br><span class="line">      "<span class="attribute">className</span>": <span class="value"><span class="string">"Author"</span></span>,</span><br><span class="line">      "<span class="attribute">objectId</span>": <span class="value"><span class="string">"mQtjuMF5xk"</span></span><br><span class="line">    </span>&#125;</span>,</span><br><span class="line">    "<span class="attribute">isDraft</span>": <span class="value"><span class="literal">false</span></span>,</span><br><span class="line">    "<span class="attribute">createdAt</span>": <span class="value"><span class="string">"2015-11-25T17:15:33.347Z"</span></span>,</span><br><span class="line">    "<span class="attribute">updatedAt</span>": <span class="value"><span class="string">"2015-11-27T19:05:21.377Z"</span></span>,</span><br><span class="line">    "<span class="attribute">publishedAt</span>": <span class="value">&#123;</span><br><span class="line">      "<span class="attribute">__type</span>": <span class="value"><span class="string">"Date"</span></span>,</span><br><span class="line">      "<span class="attribute">iso</span>": <span class="value"><span class="string">"2015-11-27T19:05:21.377Z"</span></span><br><span class="line">    </span>&#125;</span>,</span><br><span class="line">    "<span class="attribute">objectId</span>": <span class="value"><span class="string">"fchpZwSuGG"</span></span><br><span class="line">  </span>&#125;]</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>【日期】示例中，<code>publishedAt</code> 是一个日期型字段，其格式要求请参考 <a href="rest_api.html#datatype_date">REST API &middot; 数据类型</a>。</p>
<p>【密码】导入用户密码需要使用一个特殊的字段 <code>bcryptPassword</code>，并且完全遵循 <a href="http://stackoverflow.com/a/5882472/1351961" target="_blank" rel="external">Stackoverflow &middot; What column type/length should I use for storing a Bcrypt hashed password in a Database?</a>  所描述的加密算法加密后，才可以作为合法的密码进行导入。</p>
<p>【关系】导入 Relation 关联数据时，需要填写要导入的 Class 名称、导入后的字段名称、关联的 Class 名称等信息，才能完整导入，例如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123; "<span class="attribute">results</span>": <span class="value">[</span><br><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">owningId</span>": <span class="value"><span class="string">"dMEbKFJiQo"</span></span>,</span><br><span class="line">  "<span class="attribute">relatedId</span>": <span class="value"><span class="string">"19rUj9I0cy"</span></span><br><span class="line"></span>&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">owningId</span>": <span class="value"><span class="string">"mQtjuMF5xk"</span></span>,</span><br><span class="line">  "<span class="attribute">relatedId</span>": <span class="value"><span class="string">"xPVrHL0W4n"</span></span><br><span class="line"></span>&#125;]</span>&#125;</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>owningId</code>： 将要导入的 Class 表内已经存在的对象的 objectId。</li>
<li><code>relatedId</code>：将要关联的 Class 里的对象的 objectId。</li>
</ul>
<p>例如，Post 有一个字段 comments 是 Relation 类型，对应的 Class 是 Comment，那么 owningId 就是已存在的 Post 的 objectId，而 relatedId 就是关联的 Comment 的 objectId。</p>
<h3 id="CSV格式文件">CSV格式文件</h3><p>导入 Class 的 csv 文件格式必须符合我们的扩展要求：</p>
<ul>
<li>第一行必须是字段的类型描述，支持 <code>int</code>、<code>long</code>、<code>number</code>、<code>double</code>、<code>string</code>、<code>date</code>、<code>boolean</code>、<code>file</code>、<code>array</code>、<code>object</code>、<code>geopoint</code> 等。</li>
<li>第二行是字段的名称</li>
<li>第三行开始才是要导入的数据</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string,int,string,double,date&#10;name,age,address,account,createdAt&#10;&#24352;&#19977;,33,&#21271;&#20140;,300.0,2014-05-07T19:45:50.701Z&#10;&#26446;&#22235;,25,&#33487;&#24030;,400.03,2014-05-08T15:45:20.701Z&#10;&#29579;&#20116;,21,&#19978;&#28023;,1000.5,2012-04-22T09:21:35.701Z</span><br></pre></td></tr></table></figure>
<p>导入的 <code>geopoint</code> 格式是一个用空格隔开字符串：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geopoint,string,int,string,double,date&#10;location,name,age,address,account,createdAt&#10;20 20,&#24352;&#19977;,33,&#21271;&#20140;,300.0,2014-05-07T19:45:50.701Z&#10;30 30,&#26446;&#22235;,25,&#33487;&#24030;,400.03,2014-05-08T15:45:20.701Z&#10;40 40,&#29579;&#20116;,21,&#19978;&#28023;,1000.5,2012-04-22T09:21:35.701Z</span><br></pre></td></tr></table></figure>
<p>导入的 Relation 数据，比 JSON 简单一些，第一列对应 JSON 的 <code>owningId</code>，也就是要导入的 Class 的存在对象的 objectId，第二列对应 <code>relatedId</code>，对应关联 Class 的 objectId。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dMEbKFJiQo,19rUj9I0cy&#10;mQtjuMF5xk,xPVrHL0W4n</span><br></pre></td></tr></table></figure>
<p>csv 导入也支持 Pointer 类型，要求类型声明为 <code>pointer:类名</code>，其中类名就是该 Pointer 列所指定的 className，列的值只要提供 objectId 即可，例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string,pointer:Player&#10;playerName,player&#10;&#24352;&#19977;,mQtjuMF5xk&#10;&#26446;&#22235;,xPVrHL0W4n</span><br></pre></td></tr></table></figure>
<h3 id="导出数据">导出数据</h3><p>我们还支持你可以导出所有的应用数据（包括加密后的用户密码），只要进入 <a href="/app.html?appid=#/export">控制台 / 应用设置 / 数据导出</a> 点击导出按钮即可开始导出任务。我们会在导出完成之后发送下载链接到你的注册邮箱。</p>
<p>导出还可以限定日期，我们将导出在限定时间内有过更新或者新增加的数据。</p>
<p>我们还提供了数据导出的 <a href="./rest_api.html#数据导出_API">RETS API</a>。</p>
<h4 id="导出用户数据的加密算法">导出用户数据的加密算法</h4><p>我们通过一个 Ruby 脚本来描述这个用户密码加密算法：</p>
<ol>
<li>创建 SHA-512 加密算法 hasher</li>
<li>使用 salt 和 password（原始密码） 调用 hasher.update</li>
<li>获取加密后的值 <code>hv</code></li>
<li>重复 512 次调用 <code>hasher.update(hv)</code>，每次hv都更新为最新的 <code>hasher.digest</code> 加密值</li>
<li>最终的 hv 值做 base64 编码，保存为 password</li>
</ol>
<p>假设：</p>
<table width="100%" border="0" cellpadding="6"><br>  <tbody><br>    <tr><br>      <td nowrap="">salt</td><br>      <td><pre style="margin:0;"><code>h60d8x797d3oa0naxybxxv9bn7xpt2yiowz68mpiwou7gwr2</code></pre></td><br>    </tr><br>    <tr><br>      <td nowrap="">原始密码</td><br>      <td><code>password</code></td><br>    </tr><br>    <tr><br>      <td nowrap="">加密后</td><br>      <td><pre style="margin:0;"><code>tA7BLW+NK0UeARng0693gCaVnljkglCB9snqlpCSUKjx2RgYp8VZZOQt0S5iUtlDrkJXfT3gknS4rRqjYsd/Ug==</code></pre></td><br>    </tr><br>  </tbody><br></table>

<p>实现代码：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'digest/sha2'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">"base64"</span></span><br><span class="line"></span><br><span class="line">hasher = <span class="constant">Digest::SHA512</span>.new</span><br><span class="line">hasher.reset</span><br><span class="line">hasher.update <span class="string">"h60d8x797d3oa0naxybxxv9bn7xpt2yiowz68mpiwou7gwr2"</span></span><br><span class="line">hasher.update <span class="string">"password"</span></span><br><span class="line"></span><br><span class="line">hv = hasher.digest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hashme</span><span class="params">(hasher, hv)</span></span></span><br><span class="line">  <span class="number">512</span>.times <span class="keyword">do</span></span><br><span class="line">    hasher.reset</span><br><span class="line">    hv = hasher.digest hv</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  hv</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">result = <span class="constant">Base64</span>.encode64(hashme(hasher,hv))</span><br><span class="line">puts result.gsub(<span class="regexp">/\n/</span>,<span class="string">''</span>)</span><br></pre></td></tr></table></figure>
<p>非常感谢用户残圆贡献了一段 C# 语言示例代码：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/// 根据数据字符串和自定义 salt 值，获取对应加密后的字符串</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=<span class="string">"password"</span>&gt;数据字符串&lt;/param&gt;</span><br><span class="line">/// &lt;param name=<span class="string">"salt"</span>&gt;自定义 salt 值&lt;/param&gt;</span><br><span class="line">/// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">public <span class="keyword">static</span> <span class="type">string</span> <span class="type">SHA512Encrypt</span>(<span class="type">string</span> password, <span class="type">string</span> salt)</span><br><span class="line">&#123;</span><br><span class="line">    /*</span><br><span class="line">    用户密码加密算法</span><br><span class="line">    </span><br><span class="line">    <span class="number">1</span>、创建 <span class="type">SHA</span>-<span class="number">512</span> 加密算法 hasher</span><br><span class="line">    <span class="number">2</span>、使用 salt 和 password（原始密码） 调用 hasher.update</span><br><span class="line">    <span class="number">3</span>、获取加密后的值 hv</span><br><span class="line">    <span class="number">4</span>、重复 <span class="number">512</span> 次调用 hasher.update(hv)，每次hv都更新为最新的 hasher.digest 加密值</span><br><span class="line">    <span class="number">5</span>、最终的 hv 值做 base64 编码，保存为 password</span><br><span class="line">    */</span><br><span class="line">    password = salt + password;</span><br><span class="line">    byte[] bytes = <span class="type">System</span>.<span class="type">Text</span>.<span class="type">Encoding</span>.<span class="type">UTF8</span>.<span class="type">GetBytes</span>(password);</span><br><span class="line">    byte[] <span class="literal">result</span>;</span><br><span class="line">    <span class="type">System</span>.<span class="type">Security</span>.<span class="type">Cryptography</span>.<span class="type">SHA512</span> shaM = new <span class="type">System</span>.<span class="type">Security</span>.<span class="type">Cryptography</span>.<span class="type">SHA512Managed</span>();</span><br><span class="line">    <span class="literal">result</span> = shaM.<span class="type">ComputeHash</span>(bytes);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i++ &lt; <span class="number">512</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="literal">result</span> = shaM.<span class="type">ComputeHash</span>(<span class="literal">result</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    shaM.<span class="type">Clear</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Convert</span>.<span class="type">ToBase64String</span>(<span class="literal">result</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="安全性">安全性</h2><p>对于任何移动应用来说。因为客户端代码运行在一台移动设备上，因此可能会有不受信任的客户强行修改代码并发起恶意的请求。选择正确的方式来保护你的应用非常重要，但是正确的方式取决于你的应用，以及应用存储的数据。</p>
<p>我们提供多种方式使用权限控制来获得安全性。如果你有关于任何保护你应用安全的最佳方式的问题，我们都鼓励你联系我们的客户支持。</p>
<h3 id="SSL_加密传输">SSL 加密传输</h3><p>首先，我们所有的 API 请求都通过 <a href="http://zh.wikipedia.org/wiki/%E5%AE%89%E5%85%A8%E5%A5%97%E6%8E%A5%E5%B1%82" target="_blank" rel="external">SSL加密传输</a>，保证传输过程中的数据安全性和可靠性。</p>
<h3 id="对象级别的权限">对象级别的权限</h3><p><img src="/avos/images/acl.png" alt="image"></p>
<p>最灵活的保护你应用数据安全的方式是通过访问控制列表（Access Control List），通常简称为 ACL 机制。ACL 背后的思想是为每个对象关联一系列 User 或者 Role，这些 User 或者 Role 包含了特定的权限。一个 User 必须拥有读权限（或者属于一个拥有读权限的 Role）才可以获取一个对象的数据，同时，一个 User 需要写权限（或者属于一个拥有写权限的 Role）才可以更改或者删除一个对象。</p>
<p>大多数应用都通过 ACL 来规范它们的访问模式。例如：</p>
<ul>
<li>对于私有数据，read 和 write 都可以限制为对象拥有者（owner）所有。</li>
<li>一个信息公告板的帖子，作者和属于「版主」角色的成员可拥有 write 权限，通常 public 允许 read 访问（也就是允许公开读取帖子）。</li>
<li>高优先级用户或者开发者创建的数据，例如全局的每日广播消息，可以让 public拥有 read 许可，但是严格限制 write 权限给「管理员」角色。</li>
<li>一条从一个用户发往另一个用户的消息，可以将读和写的访问许可限制到关联的这两个用户。</li>
</ul>
<p>使用 LeanCloud SDK，你可以设置一个默认的 ACL 给客户端所有创建的对象。如果你同时开启自动匿名用户创建的功能，你可以保证你的数据拥有严格限制到每个单独用户的ACL权限。请仔细阅读 iOS 和 Android 指南关于选择默认安全策略的章节。</p>
<p>通过设置 Master Key的 REST API，你还是可以绕过 ACL 限制执行任何操作。这可以让开发者更容易地管理数据。例如，你可以通过 REST API 删除一条私有消息，哪怕这条消息设置为拥有者私有。</p>
<p>代码中如何使用 ACL，请阅读相应的 ACL 文档。</p>
<h3 id="列级别的权限">列级别的权限</h3><p>这个概念比较简单，通过编辑数据管理页面某个 Class 的列属性，某一列数据可以设置为「只读」。对于 <code>_User</code> 数据表，还可以设置为 「只限当前用户读写」，即只能当前登录的用户读写自己的数据。</p>
<p>某一列的数据还可以设置为 「客户端不可见」。设置了之后，当客户端发起查询的时候，返回的结果将不包含相关字段。比如，匿名发帖的应用，你仍然希望发帖的时候，也记录下真实的作者，但不希望将此信息返回给客户端，所以，这时候就可以设置作者字段为「客户端不可见」。</p>
<h3 id="Class_级别的权限">Class 级别的权限</h3><p><img src="/avos/images/cla_permission.png" alt="image"></p>
<p>在一些情况下，设置整个class允许的权限是一种更自然的方式。例如，你可能想设置整个 Class 只读，或者只写。</p>
<p>为了简单地做到这一点，我们让你可以设置每个 Class 允许的操作。为了访问这些设置，请进入数据管理平台，选择一个 Class，并点击右侧菜单中的 <strong>其他</strong> 下拉框找到权限设置。</p>
<p>你可以为选中的 Class 禁止客户端执行下列操作的能力：</p>
<ul>
<li>GET - 通过objectId获取对象。</li>
<li>Find - 发起一次对象列表查询。</li>
<li>Update - 保存一个已经存在并且被修改的对象。</li>
<li>Create - 保存一个从未创建过的新对象。</li>
<li>Delete - 删除一个对象。</li>
<li>Add fields - 添加新字段到class</li>
</ul>
<h3 id="App_安全选项">App 安全选项</h3><p>进入应用设置菜单，在左侧菜单可以看到 <strong>应用选项设置</strong>：</p>
<p>点击选中或者取消选中就可以启用或者关闭这些选项，大概介绍下功能：</p>
<ul>
<li><strong>启用注册用户邮箱验证</strong>：是否要求你应用里的注册用户验证邮箱， 默认不启用。如果启用，每次用户注册，都会发送一封邮件到用户提供的邮箱，要求认证，具体请看开发指南里的用户一节。</li>
<li><strong>禁止客户端创建 Class</strong>：是否禁止客户端动态创建 Class。如果启用，那么通过 SDK 或者 REST API 都没办法动态创建不存在的 Class 了，这种情况下只能通过我们的数据管理平台来创建新 Class。</li>
<li><strong>禁止消息推送</strong>：是否彻底禁止消息推送。如果启用，任何消息推送的调用都不允许。</li>
<li><strong>禁止从客户端推送消息</strong>：是否禁止从客户端推送消息，如果启用，这那么通过 SDK 或者 REST API 都被禁止推送消息，只能通过我们管理平台提供的推送界面来推送消息。</li>
</ul>
<h2 id="第三方加密">第三方加密</h2><p>对于 Android 应用，除了代码混淆之外，还可以使用第三方加密工具，隐藏 classes.dex，通过动态加载的方法进一步提高应用的安全性。下面我们简单介绍一下爱加密。</p>
<h3 id="爱加密">爱加密</h3><p><a href="http://www.ijiami.cn/" target="_blank" rel="external">爱加密</a> 是专为移动开发者提供安全服务的一个平台，可解决开发者面临的应用安全问题。加密的步骤很简单：</p>
<ol>
<li>提交应用；</li>
<li>下载加密后的 apk 文件；</li>
<li>下载爱加密提供的签名工具，对应用进行签名。</li>
</ol>
<p>相关步骤还可以见下面的截图。</p>
<p>申请账号，提交应用，下载签名工具：</p>
<p><img src="/avos/images/ijiami_2.png" alt="image"></p>
<p>加密后重新签名：</p>
<p><img src="/avos/images/ijiami_1.png" alt="image"></p>
<p>这样得到的 apk 文件，普通的反编译之后得到的是，</p>
<p><img src="/avos/images/decompile.png" alt="image"></p>
<p>可以看到，代码被隐藏起来了，应用被破解的难度大幅增加了。</p>
<p>我们一直努力提供更多功能给开发者来保护你的应用，也希望大家持续地给我们反馈，感谢。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/dotnet_guide/" itemprop="url">
                .NET 数据存储开发指南
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/dotnet_guide/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/dotnet_guide/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="-NET_数据存储开发指南">.NET 数据存储开发指南</h1><h2 id="简介">简介</h2><p>目前我们的 .NET 数据存储支持如下运行时：</p>
<ul>
<li>Windows Phone Silverlight （8.0 &amp; 8.1）</li>
<li>Windows Desktop .NET Framework 4.5+</li>
<li>Xamarin Form 1.4+</li>
<li>Xamarin iOS 8+</li>
<li>Xamarin Android 5+</li>
</ul>
<p>尚未发布但是已在计划内的如下：</p>
<ul>
<li>Windows Runtime （for Windows 10）</li>
</ul>
<p>文档中涉及的语法以及接口均对所有运行时有效。</p>
<h2 id="快速入门">快速入门</h2><p>建议您在阅读本文档之前，阅读我们提供的<a href="/start.html">快速入门</a>文档，获取 LeanCloud 使用的配置和第一印象。</p>
<h2 id="安装">安装</h2><p>为了支持实时聊天，LeanCloud SDK for .NET 依赖于几个开源的库，所以推荐开发者从 <a href="https://www.nuget.org/packages/LeanCloud/1.0.1.2-pre" target="_blank" rel="external">Nuget</a> 上下载我们的 SDK。</p>
<h2 id="介绍">介绍</h2><p>LeanCloud的 .NET SDK 依赖于微软提供的<a href="http://msdn.microsoft.com/zh-cn/library/hh873175.aspx" target="_blank" rel="external">基于任务的异步模式 (TAP)</a>的方式，所以您最好有 .NET Framework 4.5 的编程经验，或者对 .NET Framework 4.5 的新 API 有所了解。</p>
<h2 id="应用">应用</h2><p>在 LeanCloud 的每个应用有自己的 ID 和客户端密钥，在客户端代码中应该用他们来初始化 SDK。<br>LeanCloud 的每一个账户都可以创建多个应用。同一个应用可以分别在测试环境和生产环境部署不同的版本。</p>
<h3 id="初始化">初始化</h3><p>在 LeanCloud 中，几乎所有平台下的接口我们都尽量保持一致，目的就是为了降低开发者的开发成本，所以在初始化的时候我们几乎都是遵循在 <code>AVClient</code> 这个类下有一个叫做 <code>Initialize</code>（不同平台的编程规范可能不一样，但是在 C# 语言风格中一般方法名的首字母都是大写）的方法，这个方法目前有 2 个重载：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AVClient.Initialize(string applicationId, string appKey)<span class="comment">;</span></span><br><span class="line">传入您的 <span class="escape">`A</span>pp ID<span class="escape">` </span>以及 <span class="escape">`A</span>pp Key<span class="escape">`，</span>默认访问的是 LeanCloud 的中国节点。</span><br></pre></td></tr></table></figure>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AVClient<span class="built_in">.</span>Initialize(<span class="built_in">string</span> applicationId, <span class="built_in">string</span> appKey, AVRegion region);</span><br><span class="line">除了传入您的 <span class="string">`App ID`</span> 以及 <span class="string">`App Key`</span>之外，指定 LeanCloud 的服务节点，现在 AVRegion 仅支持 <span class="literal">CN</span> 以及 US 节点。</span><br></pre></td></tr></table></figure>
<p>注意，目前 LeanCloud 的节点上的数据是相互隔离的，换言之，您在中国节点上注册的应用无法访问美国节点，反之亦然。</p>
<h2 id="对象">对象</h2><h3 id="AVObject">AVObject</h3><p>在 LeanCloud 上，数据存储是围绕 <code>AVObject</code> 进行的。每个 <code>AVObject</code> 都包含了与 JSON 兼容的 key-value 对应的数据。数据是 schema-free 的，你不需要在每个 AVObject 上提前指定存在哪些键，只要直接设定对应的 key-value 即可。<br>key 必须是字母数字或下划线组成的字符串。值可以是字符串，数字，布尔值，甚至数组和字典。<br>每个 <code>AVObject</code> 都必须有一个类（Class）名称，以便于您区分不同类型的数据。例如，我们可以将对应的体育运动称为 <code>Sport</code>。我们建议的您将类和 key 按照 <code>NameYourClassesLikeThis</code> 以及 <code>nameYourKeysLikeThis</code> 这样的惯例命名。</p>
<h3 id="保存对象">保存对象</h3><p>接下来，你需要将上文中的 <code>Sport</code> 存储到 LeanCloud 的服务。LeanCloud 的相关接口和 <code>IDictionary&lt;string, object&gt;</code> 类似，但只有调用 <code>SaveAsync</code> 方法时才会实际保存到服务器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AVObject football =<span class="keyword">new</span> AVObject(<span class="string">"Sport"</span>);</span><br><span class="line">football[<span class="string">"totalTime"</span>] = <span class="number">90</span>;</span><br><span class="line">football[<span class="string">"name"</span>] = <span class="string">"Football"</span>;</span><br><span class="line">Task saveTask = football.SaveAsync();</span><br><span class="line">await saveTask;</span><br></pre></td></tr></table></figure>
<p>在运行此代码后，您应当了解保存动作是否已经生效 。为了确保数据被保存，您可以在 LeanCloud 上的<a href="/data.html?appid=&lt;!--￼72--">数据管理</a>中查看您应用的数据。</p>
<p>此处有两件事情需要特别注明。<br>首先，在运行此代码之前，您不必配置或设置一个称为 「Sport」 的新类。LeanCloud 会自动创建这个类。</p>
<p>此外，为了更方便的使用 LeanCloud，还有其它几个字段您不需要事先指定。<code>objectId</code> 是为每个对象自动生成的唯一的标识符；<code>createdAt</code> 和 <code>updatedAt</code> 分别代表每个对象在 LeanCloud 中创建和最后修改的时间并会被自动填充。<br>在您执行保存操作之前，这些字段不会被自动保存到 <code>AVObject</code> 中。</p>
<h3 id="在后台工作">在后台工作</h3><p>关于异步编程，一直是每一种语言和平台上必须直面的问题，牵扯到线程，进程的问题大多数都是程序员很头疼的一个难点，但是在 .NET Framework 4.5 之后迎来了一种新的变革，那就是<a href="http://msdn.microsoft.com/zh-cn/library/hh873175.aspx" target="_blank" rel="external">基于任务的异步模式 (TAP)</a>。当然本篇指南的重点不是讲解TAP异步模式的好处，只是希望开发者能够足够的掌握TAP实现异步用法。</p>
<p>LeanCloud .NET SDK 都采用了 TAP 的方式去实现把所有跟 LeanCloud 服务端交互的部分放在后台去进行，这样可以让开发者可以花更多时间去做客户端应该做的事情，而把跟服务端交互的各种进程管理放权给 LeanCloud SDK 去做。</p>
<h3 id="更新对象">更新对象</h3><p>更新对象和保存对象有点相似，只是更新对象会覆盖同名属性的值，在调用 <code>SaveAsync</code> 之后会发送到服务端生效。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var peter = <span class="keyword">new</span> AVObject(<span class="string">"Character"</span>)</span><br><span class="line">&#123;</span><br><span class="line">	&#123; <span class="string">"age"</span>, <span class="number">37</span> &#125;,</span><br><span class="line">	&#123; <span class="string">"name"</span>, <span class="string">"Peter Burke"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"from"</span>, <span class="string">"White Collar"</span> &#125;,</span><br><span class="line">	&#123; <span class="string">"skills"</span>, <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt; &#123; <span class="string">"FBI"</span>, <span class="string">"Agent Leader"</span> &#125; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">await peter.SaveAsync().ContinueWith(t =&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 保存成功之后，修改一个已经在服务端生效的数据，这里我们修改age</span></span><br><span class="line">	<span class="comment">// LeanCloud 只会针对指定的属性进行覆盖操作，本例中的name不会被修改</span></span><br><span class="line">	peter[<span class="string">"age"</span>] = <span class="number">40</span>;</span><br><span class="line">	peter.SaveAsync();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="获取对象">获取对象</h3><p>如果确定了一个 <code>AVObject</code> 的 <code>objectId</code> 可以通过如下代码构造一个 <code>AVObject</code> 然后通过 <code>FetchAsync</code> 从服务端把数据加载到本地：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AVObject <span class="property">character</span> = AVObject.CreateWithoutData(<span class="string">"Character"</span>, <span class="string">"549818e0e4b096e3561a6abd"</span>);</span><br><span class="line">await <span class="property">character</span>.FetchAsync();</span><br></pre></td></tr></table></figure>
<h3 id="删除对象">删除对象</h3><p>如果想删除某个对象可以直接调用 <code>AVObject</code> 的 <code>DeleteAsync</code> 方法。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">await myObject.<span class="title">DeleteAsync</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果仅仅想删除某个对象的某一个属性，可以调用 <code>Remove</code> 方法。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行下面的语句会将age字段置为空</span></span><br><span class="line">myObject.Remove(<span class="string">"age"</span>);</span><br><span class="line"><span class="comment">// 将删除操作发往服务器生效。</span></span><br><span class="line"><span class="function">await myObject.<span class="title">SaveAsync</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="关系">关系</h3><p>软件程序就是抽象现实中的对象之间的关系在计算机世界里面的解释和展现。有对象必然就会有对象之间的关系，在 LeanCloud 中也给出了传统关系型的解决方案，并且简化了代码，使得代码简洁易维护。<br>假设这样一种场景，做一款时髦的相亲社交软件，男孩会在自己的资料里面标明自己喜欢的女生类型，于是有如下代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVObject</span> girlType = new <span class="built_in">AVObject</span> (<span class="string">"GirType"</span>);</span><br><span class="line">girlType [<span class="string">"typeName"</span>] = <span class="string">"Hot"</span>;</span><br><span class="line"><span class="built_in">AVObject</span> beckham = new <span class="built_in">AVObject</span> (<span class="string">"Boy"</span>);</span><br><span class="line">beckham[<span class="string">"name"</span>]=<span class="string">"David Beckham"</span>;</span><br><span class="line">beckham [<span class="string">"age"</span>] = <span class="number">38</span>;</span><br><span class="line">beckham [<span class="string">"focusType"</span>] = girlType;</span><br><span class="line">await beckham<span class="variable">.SaveAsync</span> ();<span class="comment">//保存beckham的时候会自动将girlType也保存到服务器。</span></span><br></pre></td></tr></table></figure>
<p>当然必然存在一种方法就是将已存在的对象通过<code>ObjectId</code>将它于目标对象进行关联：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beckham[<span class="string">"focusType"</span>] = <span class="built_in">AVObject</span><span class="variable">.CreateWithoutData</span>(<span class="string">"GirType"</span>, <span class="string">"5372d119e4b0d4bef5f036ae"</span>);</span><br></pre></td></tr></table></figure>
<p>值得注意的地方是，当需要从 LeanCloud 上读取数据的时候，默认的 fetch 方法是<code>不会加载关联数据类型的</code>，直到像如下代码执行之后，这些关联数据字段（如上实例中 Boy 的 focusType 字段）才会被实例化。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">AVObject</span> focusType = beckham.Get&lt;AVObject&gt;(<span class="string">"focusType"</span>);</span><br><span class="line"><span class="title">await</span> focusType.FetchIfNeededAsync();</span><br></pre></td></tr></table></figure>
<h2 id="查询">查询</h2><h3 id="AVQuery-GetAsync">AVQuery.GetAsync</h3><p>此方法对应的理解是根据 <code>objectId</code> 查询指定的一条数据，<code>GetAsync</code> 方法的参数为一个 <code>objectId</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span>&lt;<span class="built_in">AVObject</span>&gt; query = <span class="built_in">AVObject</span><span class="variable">.GetQuery</span>(<span class="string">"Character"</span>);</span><br><span class="line">           <span class="built_in">AVObject</span> character = await query<span class="variable">.GetAsync</span>(<span class="string">"549818e0e4b096e3561a6abd"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="构建_AVQuery_的注意事项">构建 AVQuery 的注意事项</h3><p>根据 <code>objectId</code> 查询，显然无法满足正常的需求，所以SDK提供了许多简化了操作的查询。<br>首先需要明确最核心的一点，在.NET SDK中，<code>AVQuery</code> 对象的所有带有 <code>Where</code> 开头方法，以及查询范围限定类的方法(<code>Skip||Limit||ThenBy||Include</code>等)都会返回一个全新的对象，它并不是在原始的 <code>AVQuery</code> 对象上修改内部属性。比如:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span>&lt;<span class="built_in">AVObject</span>&gt; query=new <span class="built_in">AVQuery</span>&lt;<span class="built_in">AVObject</span>&gt;(<span class="string">"Character"</span>)</span><br><span class="line">query<span class="variable">.WhereEqualTo</span> (<span class="string">"age"</span>, <span class="number">37</span>);<span class="comment">//注意：这是错误的！！！</span></span><br><span class="line">await query<span class="variable">.FindAsync</span> ();</span><br></pre></td></tr></table></figure>
<p><strong> 以上这一小段代码是用户经常会犯的错误案例，请勿拷贝到您的项目 </strong></p>
<p>以上这段代码将返回 <code>Character</code> 中所有的数据，并不会返回所设想的那样 <code>age</code> 等于37数据。<br>正确地写法应该是：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span>&lt;<span class="built_in">AVObject</span>&gt; query=new <span class="built_in">AVQuery</span>&lt;<span class="built_in">AVObject</span>&gt;(<span class="string">"Character"</span>)<span class="variable">.WhereEqualTo</span> (<span class="string">"age"</span>, <span class="string">"37"</span>);</span><br></pre></td></tr></table></figure>
<p>以此类推，所有复合条件查询的构造都应该遵循用<code>.</code>这个符号进行链式创建出来的 <code>AVQuery&lt;T&gt;</code>，比如，查找所有 <code>age</code> 等于37，并且 <code>name</code> 包含 <code>peter</code> 的<code>Character</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span>&lt;<span class="built_in">AVObject</span>&gt; query = new <span class="built_in">AVQuery</span>&lt;<span class="built_in">AVObject</span>&gt; (<span class="string">"Character"</span>)<span class="variable">.WhereEqualTo</span> (<span class="string">"age"</span>, <span class="number">37</span>)<span class="variable">.WhereContains</span>(<span class="string">"name"</span>,<span class="string">"peter"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="基本查询">基本查询</h3><p><code>AVQuery&lt;T&gt;.WhereEqualTo</code> 基本查询逻辑上可以理解为类似于sql语句中的</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Persons <span class="keyword">WHERE</span> FirstName=<span class="string">'Bush'</span></span><br></pre></td></tr></table></figure>
<p>的<code>=</code>操作，如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span>&lt;<span class="built_in">AVObject</span>&gt; query=new <span class="built_in">AVQuery</span>&lt;<span class="built_in">AVObject</span>&gt;(<span class="string">"Persons"</span>)<span class="variable">.WhereEqualTo</span> (<span class="string">"FirstName"</span>, <span class="string">"Bush"</span>);</span><br><span class="line">await query<span class="variable">.FindAsync</span> ()<span class="variable">.ContinueWith</span> (t =&gt; &#123;</span><br><span class="line">	IEnumerable&lt;<span class="built_in">AVObject</span>&gt; persons=t<span class="variable">.Result</span>;</span><br><span class="line">	<span class="keyword">int</span> sum=persons<span class="variable">.Count</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="查询条件">查询条件</h3><p>如果要过滤掉特定键的值时可以使用 whereNotEqualTo 方法。比如需要查询 <code>name</code>不等于 <code>Peter Burke</code> 的数据时可以这样写：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.<span class="variable">WhereNotEqualTo</span> (<span class="string">"name"</span>, <span class="string">"Peter Burke"</span>);</span><br></pre></td></tr></table></figure>
<p>同时包含多个约束条件的查询，可以这样写：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.WhereNotEqualTo (<span class="string">"name"</span>, <span class="string">"Peter Burke"</span>);</span><br><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.WhereGreaterThan(<span class="string">"age"</span>, 18);<span class="comment">//这样书写是为了文档阅读方便，但是我们还是比较推荐上一节介绍的链式表达式去创建AVQuery</span></span><br></pre></td></tr></table></figure>
<p>以此类推，可以添加多个约束条件，他们彼此是<code>AND</code>的关系。<br>有些需求中，也许只要较少的几条查询结果即可，这种情况下，可以通过设定查询结果的数量：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.<span class="variable">Limit</span> (<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>在数据较多的情况下，分页显示数据是比较合理的解决办法，limit 默认 100，最大1000，在 0 到 1000 范围之外的都强制转成默认的 100。<br>Skip 方法可以做到跳过首次查询的多少条数据来实现分页的功能。比如，一页显示10条数据，那么跳过前10个查询结果的方法就是：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.<span class="variable">Skip</span> (<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>对应数据的排序，如数字或字符串，你可以使用升序或降序的方式来控制查询数据的结果顺序：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 age 字段升序显示数据</span></span><br><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.OrderBy(<span class="string">"age"</span>);</span><br><span class="line"><span class="comment">// 根据 age 字段降序显示数据</span></span><br><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.OrderByDescending(<span class="string">"age"</span>);</span><br><span class="line"><span class="comment">//各种不同的比较查询：</span></span><br><span class="line"><span class="comment">// 年龄 &lt; 37</span></span><br><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.WhereLessThan(<span class="string">"age"</span>, 37);</span><br><span class="line"><span class="comment">// 年龄 &lt;= 37</span></span><br><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.WhereLessThanOrEqualTo(<span class="string">"age"</span>, 37);</span><br><span class="line"><span class="comment">// 年龄 &gt; 37</span></span><br><span class="line"><span class="keyword">query</span>.WhereGreaterThan(<span class="string">"age"</span>, 37);</span><br><span class="line"><span class="comment">// 年龄 &gt;= 37</span></span><br><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.WhereGreaterThanOrEqualTo(<span class="string">"age"</span>, 37);</span><br></pre></td></tr></table></figure>
<p>如果你想查询匹配几个不同值的数据，如：要查询 “peter”，“neal”，“alex” 三个人的详细数据，你可以使用 WhereContainedIn（类似 SQL 中的 in 查询）方法来实现。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = new[] &#123; <span class="string">"peter"</span>, <span class="string">"neal"</span>, <span class="string">"alex"</span> &#125;;</span><br><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.WhereContainedIn(<span class="string">"name"</span>, names);</span><br></pre></td></tr></table></figure>
<p>相反，你想查询排除 “peter”，“neal”，“alex” 这三个人的其他同学的信息（类似 SQL 中的 not in 查询），你可以使用 WhereNotContainedIn 方法来实现。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.<span class="variable">WhereNotContainedIn</span> (<span class="string">"name"</span>, names);</span><br></pre></td></tr></table></figure>
<p>对字符串值的查询 查询包含字符串的值，有几种方法。你可以使用任何正确的正则表达式来检索相匹配的值，使用 WhereMatches 方法：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.<span class="variable">WhereMatches</span>(<span class="string">"name"</span>, <span class="string">"^[A-Z]\\d"</span>);</span><br></pre></td></tr></table></figure>
<p>查询字符串中包含“XX“内容，可用如下方法：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询 name 字段的值中包含 “pet” 字的数据</span></span><br><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.WhereContains(<span class="string">"name"</span>, <span class="string">"pet"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询 name 字段的值是以 “al” 字开头的数据</span></span><br><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.WhereStartsWith(<span class="string">"name"</span>, <span class="string">"al"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询 name 字段的值是以 “oz” 字结尾的数据</span></span><br><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.WhereEndsWith(<span class="string">"name"</span>, <span class="string">"oz"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="数组值的查询">数组值的查询</h3><p>如果一个 Key 对应的值是一个数组，你可以查询 key 的数组包含了数字 2 的所有对象:</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找出所有arrayKey对应的数组同时包含了数字2的所有对象</span></span><br><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.WhereEqualTo(<span class="string">"arrayKey"</span>, 2);</span><br></pre></td></tr></table></figure>
<p>同样，你可以查询出 Key 的数组同时包含了 2,3 和 4 的所有对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找出所有arrayKey对应的数组同时包含了数字2,3,4的所有对象。</span></span><br><span class="line">List&lt;<span class="keyword">int</span>&gt; numbers = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">numbers.Add(<span class="number">2</span>);</span><br><span class="line">numbers.Add(<span class="number">3</span>);</span><br><span class="line">numbers.Add(<span class="number">4</span>);</span><br><span class="line">query = query.WhereContainsAll(<span class="string">"arrayKey"</span>, numbers);</span><br></pre></td></tr></table></figure>
<h3 id="查询对象个数">查询对象个数</h3><p>如果你只是想统计有多少个对象满足查询，你并不需要获取所有匹配的对象，可以直接使用 <code>CountAsync</code> 替代 <code>FindAsync</code>。例如，查询一部电视剧里面一共有多个角色：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.WhereNotEqualTo (<span class="string">"from"</span>, <span class="string">"White Collar"</span>);</span><br><span class="line">await <span class="keyword">query</span>.CountAsync().ContinueWith(t =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="keyword">count</span> = t.Result;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>对于超过 1000 个对象的查询，这种计数请求可能被超时限制。他们可能遇到超时错误或者返回一个近似的值。因此，请仔细设计你的应用架构来避免依赖这种计数查询。</code></p>
<p><em>查询数量限定的方法’Limit(int)’在CountAsync中不会生效。</em></p>
<h3 id="关系查询">关系查询</h3><p>LeanCloud 支持用关系 <code>AVRelation</code> 关联 2 个对象，当然也支持用关系查询来获取相关联的对象。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVObject</span> girlType = new <span class="built_in">AVObject</span> (<span class="string">"GirType"</span>);</span><br><span class="line">girlType [<span class="string">"typeName"</span>] = <span class="string">"Hot"</span>;</span><br><span class="line">girlType [<span class="string">"ageMax"</span>] = <span class="number">27</span>;</span><br><span class="line">girlType [<span class="string">"ageMin"</span>] = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">AVObject</span> beckham = new <span class="built_in">AVObject</span> (<span class="string">"Boy"</span>);</span><br><span class="line">beckham[<span class="string">"name"</span>]=<span class="string">"David Beckham"</span>;</span><br><span class="line">beckham [<span class="string">"age"</span>] = <span class="number">38</span>;</span><br><span class="line">beckham [<span class="string">"focusType"</span>] = girlType;</span><br><span class="line"><span class="comment">//保存beckham的时候会自动将girlType也保存到服务器。</span></span><br><span class="line">Task saveTask = beckham<span class="variable">.SaveAsync</span> ()<span class="variable">.ContinueWith</span> (t =&gt;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">AVQuery</span>&lt;<span class="built_in">AVObject</span>&gt; boyQuery=new <span class="built_in">AVQuery</span>&lt;<span class="built_in">AVObject</span>&gt;(<span class="string">"Boy"</span>);</span><br><span class="line">		boyQuery = boyQuery<span class="variable">.WhereEqualTo</span>(<span class="string">"focusType"</span>, girlType);</span><br><span class="line">		boyQuery<span class="variable">.FindAsync</span>()<span class="variable">.ContinueWith</span>(s=&gt;</span><br><span class="line">		&#123;</span><br><span class="line">			IEnumerable&lt;<span class="built_in">AVObject</span>&gt; boys = s<span class="variable">.Result</span>;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>
<p>关系的内嵌查询可以帮助开发者用简洁的代码处理复杂的关系内嵌查询，比如要查询<code>查询所有关注了年龄小于27岁女生类型的那些男生们</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span>&lt;<span class="built_in">AVObject</span>&gt; girlTypeQuery=new <span class="built_in">AVQuery</span>&lt;<span class="built_in">AVObject</span>&gt;(<span class="string">"GirType"</span>);<span class="comment">//</span></span><br><span class="line">girlTypeQuery = girlTypeQuery<span class="variable">.WhereLessThan</span> (<span class="string">"ageMax"</span>, <span class="number">27</span>);<span class="comment">//年龄小于27的萌妹纸</span></span><br><span class="line"><span class="built_in">AVQuery</span>&lt;<span class="built_in">AVObject</span>&gt; query = new <span class="built_in">AVQuery</span>&lt;<span class="built_in">AVObject</span>&gt;(<span class="string">"Boy"</span>);</span><br><span class="line">query = query<span class="variable">.WhereMatchesQuery</span> (<span class="string">"focusType"</span>, girlTypeQuery);<span class="comment">//找出喜欢这些类型的男生们</span></span><br></pre></td></tr></table></figure>
<p>请注意，默认的 limit 限制 100 也同样作用在内嵌查询上。因此如果是大规模的数据查询，你可能需要仔细构造你的查询对象来获取想要的行为。反之，不想匹配某个子查询，你可以使用 <code>WhereDoesNotMatchQuery</code> 方法，代码不再敖述。</p>
<p>查询已经选择了喜欢的类型的男生，并且是限定在最近 10 个加入系统的男生，可以如此做：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AVQuery&lt;AVObject&gt; <span class="keyword">query</span> = new AVQuery&lt;AVObject&gt;(<span class="string">"Boy"</span>);</span><br><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.OrderByDescending(<span class="string">"createdAt"</span>);</span><br><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.Limit(10);</span><br><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.<span class="keyword">Include</span>(<span class="string">"focusType"</span>);</span><br></pre></td></tr></table></figure>
<p>你可以使用 dot（英语句号:”.”）操作符来多层 Include 内嵌的对象。比如，你还想进一步获取 <code>GirType</code> 所关联的女生（就是那些标明了自己隶属于这个类型的女生）：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.<span class="keyword">Include</span>(<span class="string">"focusType.girls"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="CQL_查询">CQL 查询</h3><p>Cloud Query Language（简称 CQL） 是 LeanCloud 为查询 API 定制的一套类似 SQL 查询语法的子集和变种，主要目的是降低大家学习 LeanCloud 查询的 API 的成本，可以使用传统的 SQL 语法来查询 LeanCloud 应用内的数据。</p>
<p>在 .NET 中调用 CQL 查询很便捷，在 <code>AVQuery</code> 中有一个 <code>DoCloudQuery</code> 的静态方法，可以直接传入 sql 语句即可实现查询，如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">await <span class="built_in">AVQuery</span>&lt;<span class="built_in">AVObject</span>&gt;<span class="variable">.DoCloudQuery</span>(<span class="string">"select * from Character where age=37"</span>);</span><br></pre></td></tr></table></figure>
<p>如此做即可，其后续的操作与以前习惯的 <code>AVQuery</code> 其他查询一样，只是我们提供了另一种方式便于长期累积关系型数据库知识的开发者可以迅速迁移到 LeanCloud 上，CQL 的语法和详细用法可以参照：<a href="./cql_guide.html">CQL 详细指南</a></p>
<h4 id="CQL_查询占位符">CQL 查询占位符</h4><h2 id="用户">用户</h2><p>移动互联时代，把握住用户是核心的价值，任何一款APP都或多或少需要了解用户并且可能为用户建立一定的关系。例如，在社交软件中最基本就是要求用户注册和登录，哪怕是利用第三方（微博，QQ）API登录，都应该为用户在当前系统中再注册一次。LeanCloud已经在SDK中内嵌了关于用户这个较为特殊的对象的一些最基本的操作和数据服务。</p>
<h3 id="注册">注册</h3><p>注册用户在LeanCloud SDK中极为简单，看如下实例代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> userName</span> = <span class="string">"demoUser"</span>;</span><br><span class="line"><span class="variable"><span class="keyword">var</span> pwd</span> = <span class="string">"avoscloud"</span>;</span><br><span class="line"><span class="variable"><span class="keyword">var</span> email</span> = <span class="string">"xxx@xxx.com"</span>;</span><br><span class="line"><span class="variable"><span class="keyword">var</span> user</span> = new AVUser();</span><br><span class="line">user.Username = userName;</span><br><span class="line">user.Password = pwd;</span><br><span class="line">user.Email = email;</span><br><span class="line">await user.SignUpAsync().ContinueWith(t =&gt;</span><br><span class="line">&#123;</span><br><span class="line">   <span class="variable"><span class="keyword">var</span> uid</span> = user.ObjectId;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>以上代码就可以很快的注册为当前的应用注册一个用户，并且这个用户也会有一个唯一的<code>ObjectId</code>。<br><strong>用户的密码在数据管理界面是无法显示的，这是因为服务端存储的并不是明文，是通过不可逆的特殊算法加密后的字符串</strong></p>
<h3 id="手机号注册">手机号注册</h3><p>为了适应移动互联时代的需求，我们特地增加了手机号注册的功能，当然前提是会进行短信认证，就如同微信一样，注册的时候会发送6位数字的验证码到用户输入的手机上，然后再回调我们的验证接口就可以完成一次手机号的注册。<br>在<a href="/app.html?appid=#/permission">应用设置</a>可以开启这一个功能。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">验证注册用户手机号码</span><br><span class="line">允许用户使用手机短信登录</span><br></pre></td></tr></table></figure>
<p>如下一个简单的案例：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步先注册</span></span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> AVUser();</span><br><span class="line">user.Username = <span class="string">"WPUser"</span>;</span><br><span class="line">user.Password = <span class="string">"avoscloud"</span>;</span><br><span class="line">user.MobilePhoneNumber = <span class="string">"18688888888"</span>;</span><br><span class="line"><span class="keyword">var</span> task= user.SignUpAsync ();</span><br><span class="line"><span class="keyword">await</span> task；</span><br><span class="line"><span class="comment">//如此做，短信就会发送到指定的手机号</span></span><br></pre></td></tr></table></figure>
<p>以上完成之后，需要给用户一个输入界面，让用户输入收到的6位数字的验证码，然后再运行如下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二步回调认证</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> task</span> = AVUser.VerifyMobilePhoneAsync(code);<span class="comment">//code代表6位数字的验证码</span></span><br><span class="line">await task.ContinueWith(t =&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="variable"><span class="keyword">var</span> success</span>= t.Result;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>以上两步，就是一个完整的手机号注册流程。</p>
<h3 id="登录">登录</h3><p>登录是一个<code>AVUser</code>的静态方法，通过如下代码可以实现登录，登录之后，SDK会默认将此次登录的用户设置为<code>AVUser.CurrentUser</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> userName</span> = <span class="string">"demoUser"</span>;</span><br><span class="line"><span class="variable"><span class="keyword">var</span> pwd</span> = <span class="string">"avoscloud"</span>;</span><br><span class="line">await AVUser.LogInAsync(userName, pwd).ContinueWith(t =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (t.IsFaulted || t.IsCanceled)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="variable"><span class="keyword">var</span> error</span> = t.Exception.Message; <span class="comment">// 登录失败，可以查看错误信息。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">//登录成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="手机号和密码登录">手机号和密码登录</h4><p>在短信服务上线之后，只要是<code>通过认证</code>的手机号可以当做用户名在 LeanCloud 服务端进行登录，自然SDK里面也加入了相应的支持(WP SDK 自V1.1.0以及以后的版本都有支持)。它的调用与用户名登录一样，只是方法名字不一样，代码如下:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">await <span class="built_in">AVUser</span><span class="variable">.LogInByMobilePhoneNumberAsync</span> (mobilePhone, password)<span class="variable">.ContinueWith</span> (t =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="built_in">AVUser</span> user=t<span class="variable">.Result</span>;</span><br><span class="line">			<span class="comment">//这里可以拿到登录之后的AVUser，但是实际上AVUser.CurrentUser已经是当前登录的用户了。</span></span><br><span class="line">			<span class="comment">//这里提供返回值是为了使链式表达式脱离对全局变量的依赖，当然大部分情况下AVUser.CurrentUser应该已经可以满足一般的需求。</span></span><br><span class="line">		&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="手机号和短信验证码登录">手机号和短信验证码登录</h4><p>在对客户端验证要求比较高的应用里面，也许有些应用要求支持短信随机的验证码作为临时的密码登录，这个应用场景在现在已经被普遍的采用了，这种验证机制被认为是安全性高的一种机制，自然 LeanCloud 也给予了支持。它比前2种静态登录的方法多了<code>发送短信验证码</code>这一步，具体代码如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步，请求服务端发送6为数字的验证码到指定mobilePhoneNumber上。</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">await</span> AVUser.RequestLoginSmsCodeAsync(mobilePhoneNumber).ContinueWith(t =&gt;</span><br><span class="line">       &#123;</span><br><span class="line">			<span class="keyword">var</span> success=t.Result;</span><br><span class="line">			<span class="comment">//判断返回值可以判断是否发送成功，不成功会抛出带有error的AVException，并且t.Result会被置为false.</span></span><br><span class="line">			<span class="comment">//在处理这种容易因为用户输入不合法而产生的异常的时候，为了保证程序的正常运行，建议使用try/catch机制进行提前的异常处理。</span></span><br><span class="line">		&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(AVException avException)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二步，直接使用验证码登录，如果验证码输入错误也会抛出异常。</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">await</span> AVUser.LoginBySmsCodeAsync (mobilePhoneNumber, code).ContinueWith(t=&gt;</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">var</span> success=t.Result;</span><br><span class="line">		&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(AVException avException)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="邮箱认证">邮箱认证</h3><p>在移动互联时代，任何一个用户信息都是必须在双方统一认证之后才会被视为一种安全机制，比如邮箱的认证，同样，在<code>AVUser</code>这个特殊的<code>AVObject</code>拥有一个特殊字段<code>email</code>，可以在<a href="/data.html?appid=&lt;!--￼74--">数据管理</a>的<code>_User</code>表看到这个默认的字段，这就是在注册是提供的邮箱，当在<a href="/app.html?appid=#/permission">应用设置</a>中勾选了</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">启用注册用户邮箱验证</span><br></pre></td></tr></table></figure>
<p>这样在注册用户的时候，LeanCloud默认就会发送一封邮件，进行验证，邮件的模板也可以在<a href="/app.html?appid=#/email">邮件模板</a>中进行设置。</p>
<p>注意，验证过的用户，TA的<code>emailVerified</code>将会置成<code>true</code>，反之<code>false</code>，但是如果<strong>未启用注册用户邮箱验证</strong>，这个字段会为空。</p>
<h3 id="手机号认证">手机号认证</h3><p>相对于邮箱认证，手机号认证的过程稍微需要多一点代码，如果当您的应用在注册的时候没有开启短信验证，伴随业务发展，发现需要验证用户的手机，LeanCloud 正好提供了这一接口。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用的前提是，改手机号已经与已存在的用户有关联(_User表中的mobilePhoneNumber即可关联手机，至于如何关联取决于客户端的业务逻辑)</span></span><br><span class="line"><span class="tag">await</span> <span class="tag">AVUser</span><span class="class">.RequestMobilePhoneVerifyAsync</span> (<span class="string">"18688888888"</span>)<span class="class">.ContinueWith</span>(t=&gt;</span><br><span class="line">		&#123;</span><br><span class="line">		   <span class="comment">//这样就成功的发送了验证码</span></span><br><span class="line">		&#125;);</span><br></pre></td></tr></table></figure>
<p>回调认证的接口与<code>手机号注册</code>小节的第二步一样。</p>
<p>验证成功后，用户的<code>mobilePhoneVerified</code>属性变为true，并且调用云引擎的<code>AV.Cloud.onVerifed(&#39;sms&#39;, function)</code>方法。</p>
<p><strong>以上只是针对_User表的一个属性mobilePhoneNumber进行验证，但是存在另一种需求，类似于支付宝在进行交易的时候会要求进行实时的短信认证，这一机制现在已经普遍存在于各种应用中进行敏感操作的首选，并不局限于注册登录这种通用功能，LeanCloud 也提供了这一机制</strong></p>
<h4 id="手机短信针对应用自定义操作的验证">手机短信针对应用自定义操作的验证</h4><p><code>AVCloud</code>类包含了相关的静态方法，实例如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步，先请求发送，如果手机号无效则会发送失败。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RequestSMSCode</span>(<span class="params"></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> task=AVCloud.RequestSMSCode (<span class="string">"18688888888"</span>).ContinueWith(t=&gt;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(t.Result)</span><br><span class="line">		&#123;</span><br><span class="line">			msg=<span class="string">"sent!"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">    <span class="keyword">await</span> task；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果开发者想简单地自定义短信的内容，可以调用另外一个版本，如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RequestSMSCodeWithCustomParameters</span>(<span class="params"></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> task=AVCloud.RequestSMSCode (<span class="string">"18688888888"</span>,<span class="string">"PP打车"</span>,<span class="string">"叫车服务"</span>,<span class="number">8</span>).ContinueWith(t=&gt;</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(t.Result)</span><br><span class="line">	    &#123;</span><br><span class="line">	      msg=<span class="string">"sent!"</span>;</span><br><span class="line">       &#125;</span><br><span class="line">	&#125;);</span><br><span class="line">    <span class="keyword">await</span> task；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户就会收到如下短信：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">您正在使用 PP打车 服务进行 叫车服务，您的验证码是<span class="number">012345</span>，请在<span class="number">8</span>分钟之内完成验证。</span><br></pre></td></tr></table></figure>
<p>以上是调用发送，下一步就是验证。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">VerifySMSCode</span>(<span class="params"><span class="keyword">string</span> mobileNumber,<span class="keyword">string</span> code</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> task=AVCloud.VerifySmsCode (mobileNumber,code).ContinueWith(t=&gt;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(t.Result)</span><br><span class="line">		&#123;</span><br><span class="line">			msg=<span class="string">"verified"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			msg=<span class="string">"valid code"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">    <span class="keyword">await</span> task；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="语音短信验证码">语音短信验证码</h5><p>文本短信验证码在到达率上有一定的风险，尽管经过我们长期得到的用户反馈，到达率已接近 100%，但是有些应用的时效性和安全性要求极高，所以我们也推出了语音短信验证码的服务，调用的方式如下：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">await AVCloud.<span class="title">RequestVoiceCode</span> <span class="params">(<span class="string">"18688888888"</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>发送成功之后，用户的手机就会收到一段语音通话，它会播报 6 位数的验证码，然后开发者需要再次调用：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVCloud<span class="class">.VerifySmsCode</span> (<span class="string">"18688888888"</span>,<span class="string">"012345"</span>)</span><br></pre></td></tr></table></figure>
<p>再次验证用户输入的验证码是否正确。</p>
<p>目前语音短信验证码仅支持大陆的手机号（移动，电信，联通全面覆盖）。</p>
<h3 id="当前用户">当前用户</h3><p>诚如所有移动应用一样当前用户一直是被在客户端视作持久化存储处理，比如手机QQ等流行的App，LeanCloud必然也会如此为开发者解决持久化存储当前用户，只要调用了<code>登录</code>相关的接口，当前用户就会被持久化存储在客户端。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> user</span> = AVUser.CurrentUser;</span><br></pre></td></tr></table></figure>
<p>如果调用了登出借口，那么当前用户就会被清除，并置为<code>null</code>：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> AVUser.LogOut();</span><br><span class="line"><span class="keyword">var</span> user = AVUser.CurrentUser;	<span class="comment">//如此做就会抛出异常，因为登出之后，CurrentUser已经为空。</span></span><br></pre></td></tr></table></figure></p>
<h3 id="重置密码">重置密码</h3><h4 id="邮箱重置">邮箱重置</h4><p>密码管理一直是移动应用的比较通用又比较繁琐的事情，LeanCloud也为开发者提供了一套通用的解决方案，将开发者从繁琐中解脱出来。<br>当用户忘记密码的时候，开发者完全可以在客户端做一个简单的按钮，然后做一些友好的页面，但是真正实现重置密码的功能只需要如下一段代码：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">await</span> <span class="tag">AVUser</span><span class="class">.RequestPasswordResetAsync</span>(<span class="tag">user</span><span class="class">.Email</span>);</span><br></pre></td></tr></table></figure></p>
<p>这样服务端就会再次发送重置密码的邮件，开发者只要引导用户登录邮箱，进行操作就完成了。</p>
<h4 id="短信验证码重置">短信验证码重置</h4><p>如果用户的手机是有效地，并且已经通过了验证码验证手机的有效性，那么开发者可以提供另一种在手机上体验较好的方式：通过短信验证码重置密码。具体实例如下：<br>首先，需要发送一个请求到服务端去发送6位数的验证码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> smsCodeResetPasswordTask =	AVUser.RequestPasswordResetBySmsCode (<span class="string">"138012345678"</span>);<span class="comment">//只需要手机号即可，服务端会自动寻找与之匹配的用户，如果没有用户与此手机号绑定，将会提示错误信息。</span></span><br><span class="line"><span class="keyword">await</span> smsCodeResetPasswordTask；</span><br></pre></td></tr></table></figure>
<p>发送之后，再给一个界面给用户，让用户输入6位数的短信验证码，并且同时输入新的密码，然后如下调用：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> resetTask = AVUser.ResetPasswordBySmsCode(NewPassword,SMSCode);<span class="comment">//第一个参数是新密码（明文传递，请放心我们传输的时候做了加密，并且在服务端也绝不可能明文存储），第二个参数是上一步发送到用户手机的6位数验证码。</span></span><br><span class="line"><span class="keyword">await</span> resetTask；</span><br></pre></td></tr></table></figure>
<p>这样2步就可以重置密码，这项功能我们建议在一些应用内操作比较频繁的应用使用，邮箱重置的话可能需要用户去单独打开一个邮箱应用或者用浏览器跳转。</p>
<h3 id="查询用户">查询用户</h3><p><strong>请注意，新创建应用的 <code>_User</code> 表的查询权限默认是关闭的，通常我们推荐你在云引擎里封装用户查询，只查询特定条件的用户，避免开放用户表的全部查询权限。此外，你可以通过 class 权限设置打开查询权限，请参考 <a href="data_security.html#Class_级别的权限">数据与安全 - Class 级别的权限</a>。</strong></p>
<p>用户既然是个特殊的 <code>AVObject</code>，它当然也具备了 <code>AVObject</code> 的一些共同特性，很多场景下，关于用户的操作，首先就是通过条件查询，把符合特定条件的用户查询到客户端进行展现或者一些修改之类的操作。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">await <span class="built_in">AVUser</span><span class="variable">.Query</span><span class="variable">.WhereEqualTo</span>(<span class="string">"gender"</span>, <span class="string">"female"</span>)<span class="variable">.FindAsync</span>()<span class="variable">.ContinueWith</span>(t =&gt;</span><br><span class="line">&#123;</span><br><span class="line">     IEnumerable&lt;<span class="built_in">AVUser</span>&gt; women = t<span class="variable">.Result</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当然，也可以通过<code>GetAsync</code>方法通过<code>objectId</code>获取特定的一个<code>AVUser</code>。</p>
<h3 id="用户安全数据的认证规则">用户安全数据的认证规则</h3><p>很多时候，就算是开发者也不要轻易修改用户的基本信息，比如用户的一些比较敏感的个人信息，例如手机号，社交账号等，这些都应该让用户在App中自行修改，所以为了用户数据的数据有且仅有自己在登录的情况下得以修改，LeanCloud服务端对所有针对 <code>AVUser</code> 对象的数据做了验证。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">AVUser user = <span class="keyword">null</span>;</span><br><span class="line">await AVUser.LogInAsync(<span class="string">"demoUser"</span>, <span class="string">"asvscloud"</span>).ContinueWith(t =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    user = t.Result;</span><br><span class="line">    user.Username = <span class="string">"testUser"</span>; <span class="comment">// 修改用户名</span></span><br><span class="line">    <span class="keyword">return</span> user.SaveAsync();</span><br><span class="line">&#125;).Unwrap().ContinueWith(t =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!t.IsFaulted)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在登录之后，提交修改用户相关字段（密码除外），都会成功。</span></span><br><span class="line">        AVUser.LogOut();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).ContinueWith(t =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 通过Id获取这个用户，注：如此做并未使当前用户登录。</span></span><br><span class="line">    <span class="keyword">return</span> AVUser.Query.GetAsync(user.ObjectId);</span><br><span class="line">&#125;).Unwrap().ContinueWith(t =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    user = t.Result;</span><br><span class="line">    user.Username = <span class="string">"devUser"</span>;</span><br><span class="line">    <span class="keyword">return</span> user.SaveAsync();</span><br><span class="line">&#125;).Unwrap().ContinueWith(t =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (t.IsFaulted)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 显然，如此做就会失败，因为单单从Id获取用户，当前的请求不具备权限去修改这个用户的相关属性。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="ACL_权限控制">ACL 权限控制</h2><p>任何一个成熟的并且可控的系统中，必然会存在权限控制的问题，经典的案例就是论坛的斑竹可以删帖而普通游客只能看帖，如此一来，发展出来的<a href="http://zh.wikipedia.org/wiki/%E4%BB%A5%E8%A7%92%E8%89%B2%E7%82%BA%E5%9F%BA%E7%A4%8E%E7%9A%84%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6" target="_blank" rel="external">基于角色的访问控制</a>被普遍应用于各类传统的软件中，即便是互联网时代的今天，它依然是可以很简便地帮助开发者以及使用者理解和应用。</p>
<p>基于以上这一点，LeanCloud在开发者创建一个应用的时候，默认地在服务端为该应用添加了一张<code>_Role</code>的表，开发者可以在<a href="/data.html?appid=&lt;!--￼77--">数据管理</a>中看到这张表。</p>
<h3 id="默认访问权限">默认访问权限</h3><p>在没有显式指定的情况下，LeanCloud 中的每一个对象都会有一个默认的 ACL 值。这个值代表了，所有的用户，对这个对象都是可读可写的。此时你可以在数据管理的表中 ACL 属性中看到这样的值:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;"<span class="attribute">*</span>":<span class="value">&#123;"<span class="attribute">read</span>":<span class="value"><span class="literal">true</span></span>,"<span class="attribute">write</span>":<span class="value"><span class="literal">true</span></span>&#125;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>在.NET SDK中创建符合默认的开放读写权限的<code>AVACL</code>的代码如下：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> defaultACL = <span class="keyword">new</span> AVACL();</span><br><span class="line">defaultACL.PublicWriteAccess = <span class="literal">true</span>;</span><br><span class="line">defaultACL.PublicReadAccess = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="指定用户访问权限">指定用户访问权限</h3><p>当一个用户在实现一个网盘类应用时，针对不同文件的私密性，用户就需要不同的文件访问权限。 譬如公开的文件，每一个其他用户都有读的权限，然后仅仅只有创建者才拥有更改和删除的权限。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] data = System.Text.Encoding.UTF8.GetBytes(<span class="string">"AVOSCloud is a great cloud service!"</span>);</span><br><span class="line">AVFile file = <span class="keyword">new</span> AVFile(<span class="string">"mytxtFile.txt"</span>, data, <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">object</span>&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="string">"author"</span>,<span class="string">"AVOSCloud"</span>&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">AVObject book = <span class="keyword">new</span> AVObject(<span class="string">"book"</span>);</span><br><span class="line">book[<span class="string">"content"</span>] = file;</span><br><span class="line"></span><br><span class="line">AVACL acl = <span class="keyword">new</span> AVACL();</span><br><span class="line">acl.PublicReadAccess = <span class="keyword">true</span>;</span><br><span class="line">acl.SetWriteAccess(AVUser.CurrentUser, <span class="keyword">true</span>);</span><br><span class="line">book.ACL = acl;</span><br><span class="line"><span class="keyword">await</span> book.SaveAsync();</span><br></pre></td></tr></table></figure>
<h3 id="指定角色访问权限">指定角色访问权限</h3><h4 id="角色">角色</h4><p><code>AVRole</code>拥有一些默认的属性，当然它也是一个<code>AVObject</code>，自然开发者也可以为角色添加业务逻辑所需的字段。</p>
<ul>
<li><code>name</code> :<code>string</code>类型，角色的名称，并且这是创建角色的<code>必须字段</code>，并且<code>唯一</code>，并且只在创建时赋值，不能被<code>修改</code>，命名必须由字母，连接符，下划线组成，这个字段可视为主键。</li>
<li><code>users</code> :<code>AVACL</code>类型，它指向所有拥有（即<code>单用户可以拥有多角色</code>的系统）这个<code>角色</code>的用户。</li>
<li><code>roles</code> :<code>AVACL</code>类型，它指向所有该角色的子角色，<code>子角色自动继承父角色的所有权限</code>。关于这一点下一节会做详细阐述。</li>
</ul>
<h4 id="AVUser_与_AVRole_的从属关系">AVUser 与 AVRole 的从属关系</h4><p>指定用户访问权限虽然很方便，但是依然会有局限性。 以工资系统为例，一家公司的工资系统，工资最终的归属者和公司的出纳们只拥有工资的读权限，而公司的人事和老板才拥有全部的读写权限。当然你可以通过多次设置指定用户的访问权限来实现这一功能（多个用户的 ACL 设置是追加的而非覆盖）。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVObject</span> salary = new <span class="built_in">AVObject</span>(<span class="string">"salary"</span>);</span><br><span class="line">salary[<span class="string">"value"</span>] = <span class="number">2000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVUser</span> boss=new <span class="built_in">AVUser</span>();<span class="comment">//假设此处为老板</span></span><br><span class="line"><span class="built_in">AVUser</span> hrWang=new <span class="built_in">AVUser</span>();  <span class="comment">//人事小王</span></span><br><span class="line"><span class="built_in">AVUser</span> me = new <span class="built_in">AVUser</span>(); <span class="comment">//我们就在文档里爽一爽吧</span></span><br><span class="line"><span class="built_in">AVUser</span> cashierZhou = new <span class="built_in">AVUser</span>(); <span class="comment">//出纳老周</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">AVACL</span> acl = new <span class="built_in">AVACL</span>();</span><br><span class="line">acl<span class="variable">.SetReadAccess</span>(boss, <span class="literal">true</span>);</span><br><span class="line">acl<span class="variable">.SetReadAccess</span>(hrWang, <span class="literal">true</span>);</span><br><span class="line">acl<span class="variable">.SetReadAccess</span>(me, <span class="literal">true</span>);</span><br><span class="line">acl<span class="variable">.SetReadAccess</span>(cashierZhou, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">acl<span class="variable">.SetWriteAccess</span>(boss, <span class="literal">true</span>);</span><br><span class="line">acl<span class="variable">.SetWriteAccess</span>(hrWang, <span class="literal">true</span>);</span><br><span class="line">salary<span class="variable">.ACL</span> = acl;</span><br><span class="line">await salary<span class="variable">.SaveAsync</span>();</span><br></pre></td></tr></table></figure>
<p>但是这些涉及其中的人可能不止一个，也有离职换岗新员工的问题存在。这样的代码既不优雅，也太啰嗦, 同样会很难维护。 这个时候我们就引入了 <code>AVRole</code> 来解决这个问题。 公司的员工可以成百上千，然而一个公司组织里的角色却能够在很长一段时间时间内相对稳定。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVObject</span> salary = new <span class="built_in">AVObject</span>(<span class="string">"salary"</span>);</span><br><span class="line">salary[<span class="string">"value"</span>] = <span class="number">2000000</span>;</span><br><span class="line"></span><br><span class="line">var roleACL = new <span class="built_in">AVACL</span>();</span><br><span class="line">roleACL<span class="variable">.PublicReadAccess</span> = <span class="literal">true</span>;<span class="comment">//AVRole本身在创建之后，就尽量避免它被修改，这里是为了设定AVRole自身的ACL访问限制。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下这些角色只为示意，如要正确执行本段代码，以下这些AVUser必须是已经存在于服务端的数据。</span></span><br><span class="line"><span class="built_in">AVUser</span> boss = new <span class="built_in">AVUser</span>();<span class="comment">//假设此处为老板</span></span><br><span class="line"><span class="built_in">AVUser</span> hrWang = new <span class="built_in">AVUser</span>();  <span class="comment">//人事小王</span></span><br><span class="line"><span class="built_in">AVUser</span> me = new <span class="built_in">AVUser</span>(); <span class="comment">//我们就在文档里爽一爽吧</span></span><br><span class="line"><span class="built_in">AVUser</span> cashierZhou = new <span class="built_in">AVUser</span>(); <span class="comment">//出纳老周</span></span><br><span class="line"><span class="built_in">AVUser</span> cashierGe = new <span class="built_in">AVUser</span>();<span class="comment">//出纳小葛</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">AVRole</span> hr = new <span class="built_in">AVRole</span>(<span class="string">"hr"</span>, roleACL);</span><br><span class="line"><span class="built_in">AVRole</span> cashier = new <span class="built_in">AVRole</span>(<span class="string">"cashier"</span>, roleACL);</span><br><span class="line"></span><br><span class="line">hr<span class="variable">.Users</span><span class="variable">.Add</span>(hrWang);</span><br><span class="line"></span><br><span class="line">cashier<span class="variable">.Users</span><span class="variable">.Add</span>(cashierZhou);</span><br><span class="line">cashier<span class="variable">.Users</span><span class="variable">.Add</span>(cashierGe);</span><br><span class="line"></span><br><span class="line">var saveUsersTask = new List&lt;Task&gt;()</span><br><span class="line">&#123;</span><br><span class="line">    &#123;hr<span class="variable">.SaveAsync</span>()&#125;,</span><br><span class="line">    &#123;cashier<span class="variable">.SaveAsync</span>()&#125;</span><br><span class="line">&#125;;</span><br><span class="line">await Task<span class="variable">.WhenAll</span>(saveUsersTask)<span class="variable">.ContinueWith</span>(t =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">AVACL</span> acl = new <span class="built_in">AVACL</span>();</span><br><span class="line">    acl<span class="variable">.SetReadAccess</span>(boss, <span class="literal">true</span>);</span><br><span class="line">    acl<span class="variable">.SetReadAccess</span>(me, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    acl<span class="variable">.SetRoleReadAccess</span>(hr, <span class="literal">true</span>);</span><br><span class="line">    acl<span class="variable">.SetRoleReadAccess</span>(cashier,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    acl<span class="variable">.SetWriteAccess</span>(boss, <span class="literal">true</span>);</span><br><span class="line">    acl<span class="variable">.SetRoleWriteAccess</span>(hr, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    salary<span class="variable">.ACL</span> = acl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> salary<span class="variable">.SaveAsync</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="AVRole_之间的从属关系">AVRole 之间的从属关系</h4><p>在讲清楚了用户与角色的关系后，我们还有一层角色与角色之间的关系。用下面的例子来理解可能会对我们有所帮助：</p>
<p>一家创业公司有移动部门，部门下面有不同的小组，Android 和 iOS。而每个小组只拥有自己组的代码的读写权限。但是他们同时拥有核心库代码的读取权限。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> roleACL = <span class="keyword">new</span> AVACL();</span><br><span class="line">roleACL.PublicReadAccess = <span class="keyword">true</span>;<span class="comment">//AVRole本身在创建之后，就尽量避免它被修改，这里是为了设定AVRole自身的ACL访问限制。</span></span><br><span class="line"></span><br><span class="line">AVRole androidTeam = <span class="keyword">new</span> AVRole(<span class="string">"androidTeam"</span>, roleACL);</span><br><span class="line">AVRole iOSTeam = <span class="keyword">new</span> AVRole(<span class="string">"iOSTeam"</span>, roleACL);</span><br><span class="line">AVRole mobileDep = <span class="keyword">new</span> AVRole(<span class="string">"mobileDep"</span>, roleACL);</span><br><span class="line"></span><br><span class="line">AVObject androidCode = <span class="keyword">new</span> AVObject(<span class="string">"code"</span>);</span><br><span class="line">androidCode[<span class="string">"name"</span>] = <span class="string">"android"</span>;</span><br><span class="line"></span><br><span class="line">AVObject iOSCode = <span class="keyword">new</span> AVObject(<span class="string">"code"</span>);</span><br><span class="line">iOSCode[<span class="string">"name"</span>] = <span class="string">"ios"</span>;</span><br><span class="line"></span><br><span class="line">AVObject coreCode = <span class="keyword">new</span> AVObject(<span class="string">"code"</span>);</span><br><span class="line">coreCode[<span class="string">"name"</span>] = <span class="string">"core"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> saveTeamTasks = <span class="keyword">new</span> <span class="built_in">List</span>&lt;Task&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;androidTeam.SaveAsync()&#125;,</span><br><span class="line">        &#123;iOSTeam.SaveAsync()&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">await Task.WhenAll(saveTeamTasks).ContinueWith(t =&gt;</span><br><span class="line"> &#123;</span><br><span class="line">     mobileDep.Roles.Add(androidTeam);</span><br><span class="line">     mobileDep.Roles.Add(iOSTeam);</span><br><span class="line">     <span class="keyword">return</span> mobileDep.SaveAsync();</span><br><span class="line"> &#125;).Unwrap().ContinueWith(s =&gt;</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">var</span> saveCodeTasks = <span class="keyword">new</span> <span class="built_in">List</span>&lt;Task&gt;()</span><br><span class="line">     &#123;</span><br><span class="line">         &#123;androidCode.SaveAsync()&#125;,</span><br><span class="line">         &#123;iOSCode.SaveAsync()&#125;,</span><br><span class="line">         &#123;coreCode.SaveAsync()&#125;,</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="keyword">return</span> Task.WhenAll(saveCodeTasks);</span><br><span class="line"></span><br><span class="line"> &#125;).Unwrap().ContinueWith(x =&gt;</span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//androidCode的读写权限对androidTeam开放</span></span><br><span class="line">     androidCode.ACL.SetRoleReadAccess(androidTeam, <span class="keyword">true</span>);</span><br><span class="line">     androidCode.ACL.SetRoleWriteAccess(androidTeam, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//iOSCode的读写权限对iOSTeam开放</span></span><br><span class="line">     iOSCode.ACL.SetRoleReadAccess(iOSTeam, <span class="keyword">true</span>);</span><br><span class="line">     iOSCode.ACL.SetRoleWriteAccess(iOSTeam, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//coreCode对mobileDep开放读取权限，注意，mobileDep本身就已经包含了iOSTeam和androidTeam作为它的子角色</span></span><br><span class="line">     coreCode.ACL.SetRoleReadAccess(mobileDep, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">var</span> saveCodeTasks = <span class="keyword">new</span> <span class="built_in">List</span>&lt;Task&gt;()</span><br><span class="line">     &#123;</span><br><span class="line">         &#123;androidCode.SaveAsync()&#125;,</span><br><span class="line">         &#123;iOSCode.SaveAsync()&#125;,</span><br><span class="line">         &#123;coreCode.SaveAsync()&#125;,</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="keyword">return</span> Task.WhenAll(saveCodeTasks);</span><br><span class="line"> &#125;).Unwrap().ContinueWith(y =&gt;</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="comment">//所有操作全部完成。</span></span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="文件">文件</h2><h3 id="上传文件">上传文件</h3><p>AVFile可以让你的应用程序将文件存储到服务器中，比如常见的文件类型图像文件、影像文件、音乐文件和任何其他二进制数据都可以使用。<br>在这个例子中，我们将一段文本保存到服务器端：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] data = System.Text.Encoding.UTF8.GetBytes(“ LeanCloud <span class="keyword">is</span> a great cloud service!”);</span><br><span class="line">AVFile file = <span class="keyword">new</span> AVFile(<span class="string">"mytxtFile.txt"</span>, data, <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">object</span>&gt;()</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="string">"author"</span>,<span class="string">"AVOSCloud"</span>&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">await</span> file.SaveAsync().ContinueWith(</span><br><span class="line">    t =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!t.IsFaulted)</span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox.Show(file.ObjectId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, CancellationToken.None, TaskContinuationOptions.OnlyOnRanToCompletion, TaskScheduler.FromCurrentSynchronizationContext());</span><br></pre></td></tr></table></figure>
<p>AVFile构造函数的第一个参数指定文件名称，第二个构造函数接收一个byte数组，也就是将要上传文件的二进制，第三个参数是自定义元数据的字典，比如你可以把文件的作者的名字当做元数据存入这个字典，LeanCloud 的服务端会把它保留起来，这样在以后获取的时候，这种类似的自定义元数据都会被获取。</p>
<h3 id="本地文件">本地文件</h3><p>在.NET SDK中，如果很清楚地知道某一个文件所存在的路径，比如在游戏中上传一张游戏截图到LeanCloud中，可以通过SDK直接获取指定的文件，上传到LeanCloud中。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVFile</span> localFile = <span class="built_in">AVFile</span><span class="variable">.CreateFileWithLocalPath</span>(<span class="string">"screenshot.PNG"</span>, Path<span class="variable">.Combine</span>(<span class="string">"&lt;Local Folder Path&gt;"</span>, <span class="string">"screenshot.PNG"</span>));</span><br></pre></td></tr></table></figure>
<p>之后的操作与上一节类似。</p>
<h3 id="文件元信息">文件元信息</h3><p>AVFile默认会存储文件大小和文件上传者objectId作为元信息。同样的，我们提供了一个字典接口帮助开发者可以未任意文件添加任意符合字典命名规则的自定义元数据。在本小节的第一个例子了已经为文件添加了一个自定义的元数据：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AVFile file = <span class="keyword">new</span> AVFile(<span class="string">"mytxtFile.txt"</span>, data, <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">object</span>&gt;()</span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="string">"author"</span>,<span class="string">"AVOSCloud"</span>&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这个就是简单的用法，在创建文件的时候，可以指定一组字典去保留文件的自定义元数据。</p>
<p>你还可以在上传前自动一些元信息保存起来，以便后续获取，例如我们还保存图片的高度和宽度：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">file</span>.MetaData.Add(<span class="string">"width"</span>, <span class="number">100</span>);</span><br><span class="line"><span class="type">file</span>.MetaData.Add(<span class="string">"height"</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<h3 id="下载文件">下载文件</h3><p>下载文件其实跟获取单个普通对象一样，首先必须知道这个文件的<code>objectdId</code>，或者你可以通过条件查询先获取这个<code>objectdId</code>，然后调用<code>AVFile.GetFileWithObjectIdAsync</code>方法首先实例化文件对象，然后就可以下载：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">await AVFile.GetFileWithObjectIdAsync(<span class="string">"538ed669e4b0e335f6102809"</span>).ContinueWith(t =&gt;</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">var</span> <span class="keyword">file</span> = t.Result;</span><br><span class="line">       <span class="keyword">file</span>.DownloadAsync().ContinueWith(s =&gt;</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">var</span> dataByte = <span class="keyword">file</span>.DataByte;<span class="comment">//获取文件流的byte数组，之后可以做保存，发送等操作。</span></span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="删除文件">删除文件</h3><p><strong>删除文件就意味着，执行之后在数据库中立刻删除记录，并且原始文件也会从存储仓库中删除（所有涉及到物理级别删除的操作请谨慎使用）</strong></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">await  AVFile.GetFileWithObjectIdAsync("538ed<span class="number">669e4b0</span>e<span class="number">335f61028</span>09").ContinueWith(t =&gt;</span><br><span class="line">  &#123;</span><br><span class="line">     var file = t.Result<span class="comment">;</span></span><br><span class="line">     file.DeleteAsync()<span class="comment">;</span></span><br><span class="line">  &#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="调用云引擎">调用云引擎</h2><p>云引擎是 LeanCloud 提供给开发者自定义服务端逻辑的解决方案，例如想在用户注册的时候，服务端统一给用户分配随机的昵称，这一操作就可以用云引擎实现。具体关于云引擎的一些相关概念和操作可以先查看 <a href="leanengine_guide-cloudcode.html">云引擎指南</a>。</p>
<p>调用云引擎在SDK中比较方便，它是 <code>AVCloud</code> 的静态方法，全局均可调用。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dic = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">object</span>&gt;();</span><br><span class="line">dic.Add(<span class="string">"name"</span>, <span class="string">"Justin"</span>);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//增加参数</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">var</span> callTask = AVCloud.CallFunctionAsync&lt;<span class="keyword">string</span>&gt;(<span class="string">"TestFunctionName"</span>, dic);</span><br><span class="line"><span class="keyword">await</span> callTask;</span><br></pre></td></tr></table></figure>
<p>只需要传入云引擎中函数的名字和这个函数需要参数即可，如果是无参的函数，直接传入<code>null</code>即可。</p>
<h2 id="自定义参数">自定义参数</h2><p>在控制台的<a href="/devcomponent.html?appid=#/component/custom_param">自定义参数设置</a>页面可以设置一些静态的全局共享的参数，他们都是键值对的格式，在 SDK 中提供了获取这些在线参数的方法：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IDictionary&lt;<span class="keyword">string</span>, <span class="keyword">object</span>&gt; cp=<span class="keyword">await</span> AVCloud.GetCustomParameters();</span><br></pre></td></tr></table></figure>
<h2 id="消息推送">消息推送</h2><h3 id="推送给所有的设备">推送给所有的设备</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AVPush <span class="keyword">push</span> = <span class="keyword">new</span> AVPush();</span><br><span class="line"><span class="keyword">push</span>.Alert = <span class="string">"message to all devices."</span>;</span><br><span class="line">var <span class="keyword">task</span> = <span class="keyword">push</span>.SendAsync();</span><br><span class="line">await <span class="keyword">task</span>;</span><br></pre></td></tr></table></figure>
<p>以上这段代码就可以实现向所有安装了当前App的设备推送消息。</p>
<h3 id="发送给特定的用户">发送给特定的用户</h3><p>发送给public频道的用户：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AVPush <span class="keyword">push</span> = <span class="keyword">new</span> AVPush();</span><br><span class="line"><span class="keyword">push</span>.Alert = <span class="string">"message to public channel."</span>;</span><br><span class="line"><span class="keyword">push</span>.Query = <span class="keyword">new</span> AVQuery&lt;AVInstallation&gt;().WhereEqualTo(<span class="string">"channels"</span>, <span class="string">"public"</span>);</span><br><span class="line">var <span class="keyword">task</span> = <span class="keyword">push</span>.SendAsync();</span><br><span class="line">await <span class="keyword">task</span>;</span><br></pre></td></tr></table></figure>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/dotnet_push_guide/" itemprop="url">
                Windows Phone 消息推送开发指南
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/dotnet_push_guide/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/dotnet_push_guide/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="Windows_Phone_消息推送开发指南">Windows Phone 消息推送开发指南</h1><blockquote>
<p>开始之前<br>在看下面的内容之前，我们假设你已经看过我们的<a href="./push_guide.html">消息推送开发总览</a>，了解了基本的概念和模型。</p>
</blockquote>
<p>Windows Phone 8 的推送较为特殊，因为微软在设计的时候把推送消息定义为一个包含跳转页面信息的载体，比如微信推送：你单击微信发送的 Windows Phone 的 Toast 推送消息，单击进去之后，它不是打开微信的默认首页（假如叫做 Main.xaml），而是进入某一个聊天的具体的页面（假如叫做 chat.xaml）。这种场景微软是通过在推送消息里面包含了代码逻辑来实现的，比如要实现刚才这一套流程，微信服务端必须向微软的 MPNS 发送一个如下类似的消息（Http 或者 Https Post 请求）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">wp:Notification</span> <span class="attribute">xmlns:wp</span>=<span class="value">"WPNotification"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">wp:Toast</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">wp:Text1</span>&gt;</span>微信<span class="tag">&lt;/<span class="title">wp:Text1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">wp:Text2</span>&gt;</span>你有一条聊天消息<span class="tag">&lt;/<span class="title">wp:Text2</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">wp:Param</span>&gt;</span>/chat.xaml?NavigatedFrom=Toast Notification<span class="tag">&lt;/<span class="title">wp:Param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">wp:Toast</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">wp:Notification</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>所以在使用 LeanCloud 推送服务向 Windows Phone 8 平台推送的时候一定要对微软官方的推送有所了解，如果想深入了解，可以点击详细查看微软官方关于 <a href="http://msdn.microsoft.com/en-us/library/windows/apps/hh202967.aspx" target="_blank" rel="external">Windows Phone 8 推送的官方教程</a>。</p>
<p>针对 Windows Phone 8 的特殊性，LeanCloud 采用了统一接口去处理，如下 C# 代码可以实现以上所说的功能：<br>在 LeanCloud 所有 .NET 语言 SDK 均可如下进行操作。（注：Unity 暂时不支持.Wait（）方法 和 await 关键字，所以它需要使用任务的链式表达，详情请查看 Unity 的文档。）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AVPush avPush = <span class="keyword">new</span> AVPush();</span><br><span class="line">avPush.Data = <span class="keyword">new</span> Dictionary&lt;string, object&gt;();</span><br><span class="line">avPush.Data.Add(<span class="string">"title"</span>, <span class="string">"微信"</span>);</span><br><span class="line">avPush.Data.Add(<span class="string">"alert"</span>, <span class="string">"你有一条聊天消息"</span>);</span><br><span class="line">avPush.Data.Add(<span class="string">"wp-param"</span>, <span class="string">"/chat.xaml?NavigatedFrom=Toast Notification"</span>);</span><br><span class="line"><span class="keyword">await</span> avPush.SendAsync()；</span><br></pre></td></tr></table></figure>
<h2 id="推送给所有的设备">推送给所有的设备</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AVPush push = <span class="keyword">new</span> AVPush();</span><br><span class="line">push.Alert = <span class="string">"message to all devices."</span>;</span><br><span class="line"><span class="keyword">var</span> task = push.SendAsync();</span><br><span class="line"><span class="keyword">await</span> task;</span><br></pre></td></tr></table></figure>
<p>以上这段代码就可以实现向所有安装了当前应用的设备推送消息。</p>
<h2 id="发送给特定的用户">发送给特定的用户</h2><p>发送给 public 频道的用户：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AVPush push = <span class="keyword">new</span> AVPush();</span><br><span class="line">push.Alert = <span class="string">"message to public channel."</span>;</span><br><span class="line">push.Query = <span class="keyword">new</span> AVQuery&lt;AVInstallation&gt;().WhereEqualTo(<span class="string">"channels"</span>, <span class="string">"public"</span>);</span><br><span class="line"><span class="keyword">var</span> task = push.SendAsync();</span><br><span class="line"><span class="keyword">await</span> task;</span><br></pre></td></tr></table></figure>
<h2 id="文档贡献">文档贡献</h2><p>如果觉得这个文档写的不够好，也可以帮助我们来不断完善。</p>
<p>Github 仓库地址：<a href="https://github.com/leancloud/docs" target="_blank" rel="external">https://github.com/leancloud/docs</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/dotnet_realtime/" itemprop="url">
                .NET 实时通信开发指南
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/dotnet_realtime/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/dotnet_realtime/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="-NET_实时通信开发指南">.NET 实时通信开发指南</h1><h2 id="简介">简介</h2><p>在阅读本开发指南之前，请先阅读下<a href="../realtime_v2/">《实时通信开发指南》</a>，了解实时通信的基本概念和模型。</p>
<p>目前我们的 .NET 实时通信支持如下运行时：</p>
<ul>
<li>Windows Phone Silverlight （8.0 &amp; 8.1）</li>
<li>Windows Desktop .NET Framework 4.5+</li>
<li>Xamarin Form 1.4+</li>
<li>Xamarin iOS 8+</li>
<li>Xamarin Android 5+</li>
</ul>
<p>尚未发布但是已在计划内的如下：</p>
<ul>
<li>Windows Runtime （for Windows 10）</li>
</ul>
<p>文档中涉及的语法以及接口均对所有运行时有效。</p>
<h2 id="安装">安装</h2><p>为了支持实时聊天，LeanCloud SDK for .NET 依赖于几个开源的 WebSocket 的库，所以推荐开发者从 <a href="https://www.nuget.org/packages/AVOSCloud.Phone/1.3.0-beta" target="_blank" rel="external">Nuget</a> 上下载我们的 SDK。</p>
<h2 id="初始化">初始化</h2><p>导入 SDK 之后，在应用入口函数中添加如下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//generated code by visual studio&#10;...&#10;AVClient.Initialize(&#34;&#20320;&#30340; AppId&#34;, &#34;&#20320;&#30340; AppKey&#34;);&#10;...</span><br></pre></td></tr></table></figure>
<p>例如，在 Windows 控制台的 Main 函数入口可以调用以上代码进行初始化。</p>
<h2 id="单聊">单聊</h2><h3 id="发送消息">发送消息</h3><p>此场景类似于微信的私聊，微博的私信以及 QQ 单聊的场景，我们建立了一个统一的概念来描述聊天的各种场景：对话 — AVIMConversation，在<a href="./realtime_v2.html">《实时通信开发指南》</a>里面有详细的介绍。</p>
<p>Tom 想发送一条消息给 Jerry，下面的代码将帮助他实现这一功能：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void TomCreateConversationWithJerry()&#10;&#123;&#10;    //Tom &#29992;&#33258;&#24049;&#30340;&#21517;&#23383;&#20316;&#20026; ClientId &#24314;&#31435;&#20102;&#19968;&#20010; AVIMClient&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;&#10;    //Tom &#30331;&#24405;&#21040;&#31995;&#32479;&#10;    await client.ConnectAsync();&#10;&#10;    //Tom &#24314;&#31435;&#20102;&#19982; Jerry &#30340;&#23545;&#35805;&#10;    AVIMConversation conversation = await client.CreateConversationAsync(&#34;Jerry&#34;);&#10;&#10;    //Tom &#21457;&#20102;&#19968;&#26465;&#28040;&#24687;&#32473; Jerry&#10;    await conversation.SendTextMessageAsync(&#34;Hello,Jerry!&#34;);&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接收消息">接收消息</h3><p>Jerry 如果想收到 Tom 的消息，他需要如下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void JerryReceiveMessageFromTom()&#10;&#123;&#10;    //Jerry &#29992;&#33258;&#24049;&#30340;&#21517;&#23383;&#20316;&#20026; ClientId &#24314;&#31435;&#20102;&#19968;&#20010; AVIMClient&#10;    AVIMClient client = new AVIMClient(&#34;Jerry&#34;);&#10;&#10;    //Tom &#30331;&#24405;&#21040;&#31995;&#32479;&#10;    await client.ConnectAsync();&#10;&#10;    //Jerry &#35774;&#32622;&#25509;&#25910;&#28040;&#24687;&#30340;&#26041;&#27861;&#65292;&#19968;&#26086;&#26377;&#28040;&#24687;&#25910;&#21040;&#23601;&#20250;&#35843;&#29992;&#36825;&#20010;&#26041;&#27861;&#10;    client.OnMessageReceieved += (s, e) =&#62;&#10;    &#123;&#10;        if (e.Message is AVIMTextMessage)&#10;        &#123;&#10;            string words = ((AVIMTextMessage)e.Message).TextContent;&#10;            //words &#20869;&#23481;&#21363;&#20026;&#65306;Hello,Jerry!&#10;        &#125;&#10;    &#125;;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>运行以上代码之后，在 LeanCloud 网站的控制台找到指定的应用，打开存储管理控制台，可以看到默认表 <code>_Conversation</code>中多了一条数据，该条数据的字段解释如下：</p>
<ul>
<li>name：String，对话唯一的名字。</li>
<li>m：Array，对话中成员的列表。</li>
<li>lm：Date，对话中最后一条消息发送的时间。</li>
<li>c：String，对话的创建者的 ClientId</li>
<li>mu：Array，对话中设置了静音的成员，仅针对 iOS 以及 Windows Phone 用户有效</li>
<li>attr：Object，开发者设置的对话的自定义属性。</li>
</ul>
<h2 id="群聊">群聊</h2><p>此场景类似于微信的多人聊天群组，以及 QQ 群 ，请注意这里的群聊指的是持久化存储的一个群组的概念，比如 QQ 群，除非群主解散该群，这个群应该是一直存在于 我的QQ群 列表中。关于临时群组聊天（聊天室）会在之后做单独解释。</p>
<h3 id="发送消息-1">发送消息</h3><p>Tom 想建立一个群，把自己好朋友都拉进这个群，然后给他们发消息，他需要做的事情是：</p>
<ul>
<li>第一步：建立一个朋友列表</li>
<li>第二步：新建一个对话，把朋友列为对话的参与人员</li>
<li>第三步：发送一条消息</li>
</ul>
<p>以下代码将实现这个需求：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void TomCreateConversationWithFriends()&#10;&#123;&#10;    //Tom &#29992;&#33258;&#24049;&#30340;&#21517;&#23383;&#20316;&#20026; ClientId &#24314;&#31435;&#20102;&#19968;&#20010; AVIMClient&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;&#10;    //Tom &#30331;&#24405;&#21040;&#31995;&#32479;&#10;    await client.ConnectAsync();&#10;&#10;    #region &#31532;&#19968;&#27493;&#65306;&#24314;&#31435;&#19968;&#20010;&#26379;&#21451;&#21015;&#34920;&#10;    IList&#60;string&#62; friends = new List&#60;string&#62;();&#10;    friends.Add(&#34;Jerry&#34;);&#10;    friends.Add(&#34;Bob&#34;);&#10;    friends.Add(&#34;Harry&#34;);&#10;    friends.Add(&#34;William&#34;);&#10;    #endregion&#10;&#10;    #region &#26032;&#24314;&#19968;&#20010;&#23545;&#35805;&#65292;&#25226;&#26379;&#21451;&#20204;&#21015;&#20026;&#23545;&#35805;&#30340;&#21442;&#19982;&#20154;&#21592;&#10;    AVIMConversation friendConversation = await client.CreateConversationAsync(friends);&#10;    #endregion&#10;&#10;    #region &#31532;&#19977;&#27493;&#65306;&#21457;&#36865;&#19968;&#26465;&#28040;&#24687;&#10;    await friendConversation.SendTextMessageAsync(&#34;Hey&#65292;&#20320;&#20204;&#22312;&#21738;&#37324;&#65311;&#34;);&#10;    #endregion&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接收消息-1">接收消息</h3><p>群聊的接收消息与单聊的接收消息是一样的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVIMConversation NotifiedConversation = null;&#10;public async void BobReceiveMessageFromTom()&#10;&#123;&#10;    //Bob &#29992;&#33258;&#24049;&#30340;&#21517;&#23383;&#20316;&#20026; ClientId &#24314;&#31435;&#20102;&#19968;&#20010; AVIMClient&#10;    AVIMClient client = new AVIMClient(&#34;Bob&#34;);&#10;&#10;    //Bob &#30331;&#24405;&#21040;&#31995;&#32479;&#10;    await client.ConnectAsync();&#10;&#10;    //Bob &#35774;&#32622;&#25509;&#25910;&#28040;&#24687;&#30340;&#26041;&#27861;&#65292;&#19968;&#26086;&#26377;&#28040;&#24687;&#25910;&#21040;&#23601;&#20250;&#35843;&#29992;&#36825;&#20010;&#26041;&#27861;&#10;    client.OnMessageReceieved += (s, e) =&#62;&#10;    &#123;&#10;        if (e.Message is AVIMTextMessage)&#10;        &#123;&#10;            //words &#30340;&#20869;&#23481;&#23601;&#26159;&#65306;Hey&#65292;&#20320;&#20204;&#22312;&#21738;&#37324;&#65311;&#10;            string words = ((AVIMTextMessage)e.Message).TextContent;&#10;&#10;            //AVIMClient &#22312;&#25509;&#25910;&#21040;&#28040;&#24687;&#30340;&#26102;&#20505;&#65292;&#20250;&#19968;&#24182;&#25552;&#20379;&#28040;&#24687;&#25152;&#22312;&#30340; AVIMConversation&#10;            NotifiedConversation = e.Conversation;&#10;&#10;            if (NotifiedConversation != null)&#10;            &#123;&#10;                //Bob &#25910;&#21040;&#28040;&#24687;&#21518;&#21448;&#22238;&#22797;&#20102;&#19968;&#26465;&#28040;&#24687;&#10;                NotifiedConversation.SendTextMessageAsync(&#34;HI,Tom :&#25105;&#22312; Jerry &#23478;&#37324;&#65292;&#20320;&#36319; Harry &#20160;&#20040;&#26102;&#20505;&#36807;&#26469;&#65311;&#36824;&#26377; William &#21644;&#20320;&#22312;&#19968;&#36215;&#20040;&#65311;&#34;);&#10;            &#125;&#10;        &#125;&#10;    &#125;;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>而以上 Tom 和 Bob 发送的消息，William 上线的时候都会收到。</p>
<p><strong>注： AVIMClient CreateConversationAsync 有多种重载方法供开发者调用，详细的开发者可以在 Visual Studio 中查看定义</strong>。</p>
<h2 id="消息">消息</h2><p>消息在最新版本的 SDK 中做了多层抽象以及封装，详细的我们先从如何发送接收富媒体消息开始。</p>
<h3 id="富媒体消息">富媒体消息</h3><p>富媒体消息的支持是新版 SDK 的核心提升，我们目前 SDK 已经支持的富媒体消息类型有以下几种：</p>
<ul>
<li>图像消息：<code>AVIMImageMessage</code></li>
<li>音频消息：<code>AVIMAudioMessage</code></li>
<li>视频消息：<code>AVIMVideoMessage</code></li>
<li>文件消息：<code>AVIMFileMessage</code></li>
<li>地理位置消息：<code>AVIMLocationMessage</code></li>
</ul>
<h4 id="图像消息">图像消息</h4><p>图像消息可以由系统提供的拍照 API，以及媒体库中获取，也可以是可访问的图像有效 Url，只要开发者调用一个构造方法，构造出一个 <code>AVIMImageMessage</code>，然后把 <code>AVIMImageMessage</code> 对象当做参数交由 <code>AVConversation</code> 发送出去即可。</p>
<h5 id="发送图像消息">发送图像消息</h5><p>场景 1：比如从微博拷贝了一个图像链接，然后可以通过 SDK 直接构建一个 <code>AVIMImageMessage</code>并且发送出去：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void SendImageMessageAsync_Test()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    &#10;    await client.ConnectAsync();//Tom &#30331;&#24405;&#10;&#10;    AVIMConversation conversation = await client.CreateConversationAsync(&#34;Jerry&#34;, &#34;&#29483;&#21644;&#32769;&#40736;&#34;);//&#21019;&#24314;&#23545;&#35805;&#10;&#10;    AVIMImageMessage imgMessage = new AVIMImageMessage(&#34;http://pic2.zhimg.com/6c10e6053c739ed0ce676a0aff15cf1c.gif&#34;);//&#20174;&#22806;&#37096;&#38142;&#25509;&#21019;&#24314;&#22270;&#20687;&#28040;&#24687;&#10;    await conversation.SendImageMessageAsync(imgMessage);//&#21457;&#36865;&#32473; Jerry&#10;&#125;&#10;``` &#10;&#10;&#22330;&#26223; 2&#65306;&#31995;&#32479;&#20063;&#25552;&#20379;&#20102; API &#21435;&#33719;&#21462;&#23186;&#20307;&#24211;&#37324;&#38754;&#30340;&#29031;&#29255;&#65292;&#24320;&#21457;&#32773;&#21482;&#38656;&#35201;&#35843;&#29992;&#31995;&#32479;&#30340; API &#33719;&#21462;&#22270;&#20687;&#25991;&#20214;&#30340;&#25968;&#25454;&#27969;&#65292;&#28982;&#21518;&#26500;&#36896;&#20986;&#19968;&#20010; `AVIMImageMessage`&#65292;&#20877;&#35843;&#29992; `AVIMConversation.SendImageMessageAsync`&#21435;&#21457;&#36865;&#22270;&#20687;&#65306;&#10;&#10;```c#&#10;MediaLibrary library = new MediaLibrary();//&#31995;&#32479;&#23186;&#20307;&#24211;&#10;var photo = library.Pictures[0];//&#33719;&#21462;&#31532;&#19968;&#24352;&#29031;&#29255;&#65292;&#36816;&#34892;&#36825;&#27573;&#20195;&#30721;&#65292;&#30830;&#20445;&#25163;&#26426;&#20197;&#21450;&#34394;&#25311;&#26426;&#37324;&#38754;&#30340;&#23186;&#20307;&#24211;&#33267;&#23569;&#26377;&#19968;&#24352;&#29031;&#29255;&#10;&#10;AVIMImageMessage imgMessage = new AVIMImageMessage(photo.Name, photo.GetImage());//&#26500;&#36896; AVIMImageMessage&#10;imgMessage.Attributes = new Dictionary&#60;string, object&#62;() &#10;&#123; &#10;    &#123;&#34;location&#34;,&#34;San Francisco&#34;&#125;&#10;&#125;;&#10;imgMessage.Title = &#34;&#21457;&#33258;&#25105;&#30340; WP&#34;;&#10;await conversation.SendImageMessageAsync(imgMessage);</span><br></pre></td></tr></table></figure></p>
<p>以上 2 种场景中对于 SDK 的区别就是如下：</p>
<ul>
<li>场景 1 中，SDK 并没有实际将图像上传到服务端，而是仅仅是把 URL 包装在消息体内发送出去，并且这种情况下接收方是无法从消息体中获取到元信息等数据的，不过开发者可以自行获取。</li>
<li>场景 2中，SDK 获取了完整的图像的数据流，所以 SDK 会先上传文件到服务端，然后将文件的元数据以及 URL 等一并包装，再发送出去。</li>
</ul>
<h5 id="接收图像消息">接收图像消息</h5><p>类似于第一章节中单聊中的接收消息，在 <code>AVIMClient</code> 中的 <code>OnMessageReceived</code> 可以收到消息，但是假如接收方在客户端也正好加载了这个对话，那么接收方在 <code>AVIMConversation</code> 里面也会收到 <code>OnImageMessageReceived</code> 的事件响应：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void ReceiveImageMessageAsync_Test()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Jerry&#34;);&#10;    await client.ConnectAsync();&#10;    AVIMConversation conversation = client.GetConversationById(&#34;55117292e4b065f7ee9edd29&#34;);&#10;    await conversation.FetchAsync();&#10;    conversation.OnImageMessageReceived += (s, e) =&#62;&#10;    &#123;&#10;        //&#22270;&#20687;&#30340; url&#10;        string url = e.Url;&#10;        //&#22270;&#20687;&#30340;&#20803;&#25968;&#25454;&#10;        IDictionary&#60;string, object&#62; metaData = e.FileMetaData;&#10;        //&#22270;&#20687;&#30340;&#21457;&#36865;&#32773; ClientId&#10;        string  from= e.FromClientId;&#10;        //&#22270;&#20687;&#21457;&#36865;&#32773;&#20026;&#22270;&#20687;&#35774;&#23450;&#30340; Title&#10;        string title = e.Title;&#10;&#10;        //&#19968;&#20123;&#20854;&#20182;&#30340;&#23646;&#24615;&#37117;&#21487;&#20197;&#22312;&#36825;&#37324;&#33719;&#21462;&#10;    &#125;;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="音频消息">音频消息</h4><h5 id="发送音频消息">发送音频消息</h5><p>发送音频消息的基本流程就是：<code>读取音频文件（或者录制音频）</code>，<code>构建音频消息</code>，<code>消息发送</code>：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private async void SendAudioMessageAsync()&#10;&#123;&#10;    StorageFolder local = Windows.Storage.ApplicationData.Current.LocalFolder;&#10;    var AudioFile = await local.OpenStreamForReadAsync(recordAudioFileName);&#10;    AVIMAudioMessage audioMessage = new AVIMAudioMessage(recordAudioFileName, AudioFile);//&#21019;&#24314;&#38899;&#39057;&#28040;&#24687;&#10;&#10;    await conversation.SendAudioMessageAsync(audioMessage);&#10;    //&#36825;&#27573;&#20195;&#30721;&#36816;&#34892;&#20043;&#21069;&#65292;&#35831;&#30830;&#20445; `conversation` &#24050;&#32463;&#23454;&#20363;&#21270;&#10;&#125;&#10;``` &#10;&#10;&#19982;&#22270;&#20687;&#28040;&#24687;&#31867;&#20284;&#65292;&#38899;&#39057;&#28040;&#24687;&#20063;&#25903;&#25345;&#20174; URL &#26500;&#24314;&#65292;&#28982;&#21518;&#21457;&#36865;&#65306;&#10;&#10;```c#&#10;public async void SendAudioMessageAsync()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    //Tom &#30331;&#24405;&#10;    await client.ConnectAsync();&#10;    var conversation = await client.CreateConversationAsync(&#34;Jerry&#34;, &#34;&#29483;&#21644;&#32769;&#40736;&#34;);//&#21019;&#24314;&#23545;&#35805;&#10;&#10;    AVIMAudioMessage audioMessage = new AVIMAudioMessage(&#34;http://ac-lhzo7z96.clouddn.com/1427444393952&#34;);//&#20174;&#22806;&#37096;&#38142;&#25509;&#21019;&#24314;&#38899;&#39057;&#28040;&#24687;&#10;    await conversation.SendAudioMessageAsync(audioMessage);//&#21457;&#36865;&#32473; Jerry&#10;&#125;</span><br></pre></td></tr></table></figure>
<h5 id="接收音频消息">接收音频消息</h5><p>与接收图像消息一样，在 <code>AVIMConversation</code> 中有 <code>OnAudioMessageReceived</code> ，实例代码请参照图像消息接收。</p>
<h4 id="视频消息">视频消息</h4><h5 id="发送视频消息">发送视频消息</h5><p>与发送音频消息类似的流程类似，视频的来源可以是手机录制，可以是 Windows 系统中某一个具体的视频文件：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private async void SendVideoMessageAsync()&#10;&#123;&#10;    StorageFolder local = Windows.Storage.ApplicationData.Current.LocalFolder;&#10;&#10;    var VideoFile = await local.OpenStreamForReadAsync(recordVideoFileName);&#10;&#10;    AVIMVideoMessage videoMessage = new AVIMVideoMessage(recordVideoFileName, VideoFile);&#10;&#10;    await conversation.SendVideoMessageAsync(videoMessage);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>同样我们也支持从一个视频的 URL 创建视频消息，然后发送出去：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void SendVideoMessageAsync()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    await client.ConnectAsync();//Tom &#30331;&#24405;&#10;&#10;    var conversation = await client.CreateConversationAsync(&#34;Jerry&#34;, &#34;&#29483;&#21644;&#32769;&#40736;&#34;);//&#21019;&#24314;&#23545;&#35805;&#10;&#10;    AVIMVideoMessage videoMessage = new AVIMVideoMessage(&#34;http://ac-lhzo7z96.clouddn.com/1427267336319&#34;);//&#20174;&#22806;&#37096;&#38142;&#25509;&#21019;&#24314;&#35270;&#39057;&#28040;&#24687;&#10;    await conversation.SendVideoMessageAsync(videoMessage);//&#21457;&#36865;&#32473; Jerry&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注：这里说的 URL指的是视频文件自身的 URL，而不是视频网站上播放页的 URL。</strong></p>
<h5 id="接收视频消息">接收视频消息</h5><p>与接收图像消息一样，在 <code>AVIMConversation</code> 中有 <code>OnVideoMessageReceived</code> ，实例代码请参照图像消息接收。</p>
<h4 id="通用文件消息">通用文件消息</h4><p>Tom 要发送一份 .doc 文件给 Jerry，可以用下面这种方法：</p>
<h5 id="发送通用文件消息">发送通用文件消息</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void SendDocAsync()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    await client.ConnectAsync();//Tom &#30331;&#24405;&#10;&#10;    var conversation = await client.CreateConversationAsync(&#34;Jerry&#34;, &#34;&#29483;&#21644;&#32769;&#40736;&#34;);//&#21019;&#24314;&#23545;&#35805;&#10;    StorageFolder local = Windows.Storage.ApplicationData.Current.LocalFolder;&#10;    var docFile = await local.OpenStreamForReadAsync(&#34;leancloud.doc&#34;);//&#35835;&#21462;&#26412;&#22320;&#25991;&#20214;&#10;    var avfile = new AVFile(&#34;leancloud.doc&#34;, docFile);//&#26500;&#36896; AVFile&#10;    AVIMFileMessage fileMessage = new AVIMFileMessage(avfile);//&#26500;&#36896;&#25991;&#20214;&#28040;&#24687;&#10;    await conversation.SendFileMessageAsync(fileMessage);//&#21457;&#36865;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h5 id="接收通用文件消息">接收通用文件消息</h5><p>与接收图像消息一样，在 <code>AVIMConversation</code> 中有 <code>OnFileMessageReceived</code> ，实例代码请参照图像消息接收。</p>
<h4 id="地理位置消息">地理位置消息</h4><p>地理位置消息构建方式有 2 种：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//1.&#26681;&#25454;&#32428;&#24230;&#21644;&#32463;&#24230;&#26500;&#24314;&#10; AVIMLocationMessage locationMessage = new AVIMLocationMessage(Latitude, Longitude);&#10;//2.&#26681;&#25454; AVGeoPoint &#26500;&#24314;&#10;AVGeoPoint avGeoPoint = new AVGeoPoint(31.3853142377, 121.0553079844);&#10;AVIMLocationMessage locationMessage = new AVIMLocationMessage(avGeoPoint);</span><br></pre></td></tr></table></figure>
<h5 id="发送地理位置消息">发送地理位置消息</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void SendLocationAsync()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    await client.ConnectAsync();//Tom &#30331;&#24405;&#10;    var conversation = await client.CreateConversationAsync(&#34;Jerry&#34;, &#34;&#29483;&#21644;&#32769;&#40736;&#34;);//&#21019;&#24314;&#23545;&#35805;&#10;    &#10;    AVIMLocationMessage locationMessage = new AVIMLocationMessage(138.12454, 52.56461);//&#20197;&#32463;&#24230;&#21644;&#32428;&#24230;&#20026;&#21442;&#25968;&#26500;&#24314;&#19968;&#20010;&#22320;&#29702;&#20301;&#32622;&#28040;&#24687;&#65292;&#24403;&#28982;&#24320;&#21457;&#32773;&#26356;&#21487;&#20197;&#36890;&#36807;&#20855;&#20307;&#30340;&#35774;&#22791;&#30340; API &#21435;&#33719;&#21462;&#35774;&#22791;&#30340;&#22320;&#29702;&#20301;&#32622;&#65292;&#35814;&#32454;&#30340;&#38656;&#35201;&#26597;&#35810;&#20855;&#20307;&#30340;&#35774;&#22791;&#30340; API&#10;    await conversation.SendLocationMessageAsync(locationMessage);&#10;&#125;</span><br></pre></td></tr></table></figure>
<h5 id="接收地理位置消息">接收地理位置消息</h5><p>与接收图像消息一样，在 <code>AVIMConversation</code> 中有 <code>OnLocationMessageReceived</code> ，实例代码请参照图像消息接收。</p>
<h3 id="消息的发送策略">消息的发送策略</h3><p>开发者在阅读完前面的富媒体消息并且运行过实例代码之后，在 Visual Studio 中使用 F12 快捷键查看各个消息类型的定义，应该可以看见图像、音频、视频在类的继承关系上是继承自 <code>AVIMFileMessageBase</code>，所有继承自 <code>AVIMFileMessageBase</code> 的消息类型的发送策略如下：</p>
<ul>
<li><p>如果文件是从客户端 API 读取的数据流 (Stream) </p>
<ul>
<li>第一步：从本地构造 AVFile</li>
<li>第二步：调用 AVFile 的上传的方法上传到服务器，并获取文件的元信息（MetaData）</li>
<li>第三步：把 AVFile 的 objectId 以及 URL ，以及文件的元信息封装在消息体内</li>
<li>第四步：发送消息</li>
</ul>
</li>
<li><p>如果文件是外部链接的 URL</p>
<ul>
<li>第一步：直接将 URL 封装在消息体内，不获取元信息，不包含 objectId</li>
<li>第二步：发送消息</li>
</ul>
</li>
</ul>
<p>以上逻辑对所有继承 <code>AVIMFileMessageBase</code> 的消息类型有效，目前 SDK 内置的继承自 <code>AVIMFileMessageBase</code> 包含以下几种：</p>
<ul>
<li>AVIMImageMessage</li>
<li>AVIMAudioMessage</li>
<li>AVIMVideoMessage</li>
<li>AVIMFileMessage</li>
</ul>
<h3 id="消息的接收策略">消息的接收策略</h3><p>消息接收有 <strong>2</strong> 个层级：</p>
<ul>
<li><p>第一个是在 <code>AVIMClient</code> 上，它是为了帮助开发者实现被动接收消息，尤其是在本地并没有加载任何对话的时候，类似于刚登录，本地并没有任何 <code>AVIMConversation</code> 的时候，如果某个对话产生新的消息，当前 <code>AVIMClient.OnMessageReceived</code> 负责接收这类消息，但是它并没有针对消息的类型做区分。</p>
</li>
<li><p>第二个是在 <code>AVIMConversation</code> 上，负责接收对话的全部信息，并且针对不同的消息类型有不同的事件类型做响应。</p>
</li>
</ul>
<p>以上 <strong>2</strong> 个层级的消息接收策略可以用下表进行描述，假如正在接收的是 <code>AVIMTextMessage</code>：</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">AVIMClient 接收端</th>
<th style="text-align:left">条件①</th>
<th style="text-align:left">条件②</th>
<th style="text-align:left">条件③</th>
<th style="text-align:left">条件④</th>
<th>条件⑤ </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">AVIMClient.OnMessageReceived</td>
<td style="text-align:left">×</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
</tr>
<tr>
<td style="text-align:left">AVIMConversation.OnMessageReceived</td>
<td style="text-align:left">×</td>
<td style="text-align:left">×</td>
<td style="text-align:left">√</td>
<td style="text-align:left">×</td>
<td style="text-align:left">× </td>
</tr>
<tr>
<td style="text-align:left">AVIMConversation.OnTypedMessageReceived</td>
<td style="text-align:left">×</td>
<td style="text-align:left">×</td>
<td style="text-align:left">×</td>
<td style="text-align:left">√</td>
<td style="text-align:left">× </td>
</tr>
<tr>
<td style="text-align:left">AVIMConversation.OnTextMessageReceived</td>
<td style="text-align:left">×</td>
<td style="text-align:left">×</td>
<td style="text-align:left">×</td>
<td style="text-align:left">×</td>
<td style="text-align:left">√ </td>
</tr>
</tbody>
</table>
<p>对应条件如下：</p>
<ul>
<li><p>条件①：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVIMClient.Status != Online&#10;``` &#10;* &#26465;&#20214;&#9313;&#65306;&#10;```c#&#10;AVIMClient.Status == Online &#38;&#38; AVIMClient.OnMessageReceived != null</span><br></pre></td></tr></table></figure>
</li>
<li><p>条件③：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVIMClient.Status == Online &#10;&#38;&#38; AVIMClient.OnMessageReceived != null &#10;&#38;&#38; AVIMConversation.OnMessageReceived != null</span><br></pre></td></tr></table></figure>
</li>
<li><p>条件④：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVIMClient.Status == Online &#10;&#38;&#38; AVIMClient.OnMessageReceived != null &#10;&#38;&#38; AVIMConversation.OnMessageReceived != null&#10;&#38;&#38; AVIMConversation.OnTypedMessageReceived != null&#10;&#38;&#38; AVIMConversation.OnTextMessageReceived == null</span><br></pre></td></tr></table></figure>
</li>
<li><p>条件⑤：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVIMClient.Status == Online &#10;&#38;&#38; AVIMClient.OnMessageReceived != null &#10;&#38;&#38; AVIMConversation.OnMessageReceived != null&#10;&#38;&#38; AVIMConversation.OnTypedMessageReceived != null&#10;&#38;&#38; AVIMConversation.OnTextMessageReceived != null</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在 AVIMConversation 内，接收消息的顺序是按照 </p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">OnTextMessageReceived</span> &gt; OnTypedMessageReceived &gt; OnMessageReceived</span><br></pre></td></tr></table></figure>
<p>这是为了方便开发者在接收消息的时候有一个分层操作的空间，这一特性也适用于其他富媒体消息。</p>
<h3 id="消息类详解">消息类详解</h3><p><img src="http://ac-lhzo7z96.clouddn.com/1427252943504" alt="消息的类图"></p>
<ul>
<li><code>AVIMMessage</code> 所有消息的基类，一级抽象类；</li>
<li><code>AVIMTypedMessage</code> 富媒体消息的基类，二级抽象类；</li>
<li><code>AVIMFileMessageBase</code> 所有包含了文件内容的消息的基类，三级抽象类</li>
<li><code>AVIMTextMessage</code> 文本消息，三级实例类；</li>
<li><code>AVIMLocationMessage</code> 地理位置消息，三级实例类</li>
<li><code>AVIMImageMessage</code> 图像消息，四级实例类</li>
<li><code>AVIMAudioMessage</code> 音频消息，四级实例类</li>
<li><code>AVIMVideoMessage</code> 视频消息，四级实例类</li>
<li><code>AVIMFileMessage</code> 通用文件消息类，四级实例类</li>
</ul>
<p>结合图例，实时通信 SDK 在封装的时候，做了明确的分层，开发者需要根据自己的需求去使用。</p>
<h3 id="消息的自定义属性">消息的自定义属性</h3><p>有些场景下需要开发者在发送消息的时候附带一下自己业务逻辑需求的自定义属性，比如消息发送的设备名称，或者图像消息的拍摄地点，或者视频消息的来源等等，如果业务需要，开发者都可以通过 <code>AVIMMessage.Attributes</code> 实现这一需求。</p>
<p>场景1：在发送照片给自己朋友的时候，想告诉朋友这张照片是在旧金山拍摄的，如下代码可以实现这个需求：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVIMImageMessage imgMessage = new AVIMImageMessage(photo.Name, photo.GetImage());//&#26500;&#36896; AVIMImageMessage&#10;imgMessage.Attributes = new Dictionary&#60;string, object&#62;() &#10;&#123; &#10;    &#123;&#34;location&#34;,&#34;San Francisco&#34;&#125;&#10;&#125;;&#10;imgMessage.Title = &#34;&#21457;&#33258;&#25105;&#30340;WP&#34;;&#10;await conversation.SendImageMessageAsync(imgMessage);</span><br></pre></td></tr></table></figure>
<p>而接收方在 <code>OnMessageReceived</code> 的时候是可以读取到这一属性的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVIMClient client = new AVIMClient(&#34;friend&#34;);&#10;await client.ConnectAsync();&#10;client.OnMessageReceieved += (s, e) =&#62;&#10;&#123;&#10;    if (e.Message is AVIMImageMessage)&#10;    &#123;&#10;        AVIMImageMessage imgMessage = (AVIMImageMessage)e.Message;&#10;        string url = imgMessage.Url;&#10;        string location = imgMessage.Attributes[&#34;location&#34;].ToString();//&#35835;&#21462;&#30340;&#32467;&#26524;&#23601;&#26159; San Francisco&#10;    &#125;&#10;&#125;;</span><br></pre></td></tr></table></figure>
<p>所有消息都支持这一属性。</p>
<h2 id="对话的管理">对话的管理</h2><p>以上 三个章节基本演示了实时聊天 SDK 的核心概念——AVIMConversation ，LeanCloud 将单聊和群聊（包括聊天室）的消息发送和接收都依托于 <code>AVIMConversation</code>这个统一的概念进行操作。</p>
<p>所以，开发者需要强化理解的一个概念就是：<strong>SDK 层面是不再区分单聊以及群聊。</strong></p>
<h3 id="对话的成员管理">对话的成员管理</h3><p>对话的管理包括「成员管理」，「属性管理」两个方面。</p>
<p>成员管理，是对话中成员的一个实时生效的操作，一旦操作成功不可逆。</p>
<h4 id="准备工作">准备工作</h4><p>在进行下面几个章节之前，请复制如下代码到 IDE 并且执行，后面的文档中的示例代码是基于以下代码进行的，这是一项<strong>必须的</strong>工作： </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/// &#60;summary&#62;&#10;/// &#36825;&#27573;&#20195;&#30721;&#23454;&#29616;&#30340;&#21151;&#33021;&#23601;&#26159; Jerry &#21019;&#24314;&#20102;&#19968;&#20010; &#21253;&#21547; Bob&#65292;Harry&#65292;William &#30340;&#23545;&#35805;&#12290;&#10;/// &#60;/summary&#62;&#10;/// &#60;returns&#62;&#60;/returns&#62;&#10;public async void JerryCreateConversation()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Jerry&#34;);&#10;    await client.ConnectAsync();//Jerry &#30331;&#24405;&#10;&#10;    IList&#60;string&#62; friends = new List&#60;string&#62;();&#10;    friends.Add(&#34;Bob&#34;);&#10;    friends.Add(&#34;Harry&#34;);&#10;    friends.Add(&#34;William&#34;);&#10;    //&#28155;&#21152;&#22909;&#26379;&#21451;&#10;&#10;    await client.CreateConversationAsync(friends);//&#36820;&#22238; ConversationId&#10;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自身主动加入">自身主动加入</h4><p>Tom 想主动加入 Jerry、Bob、Harry 和 William 的对话（由上一节 JerryCreateConversation() 所创建）中，以下代码将帮助他实现这个功能：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void InitiativeJoinAsync()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    await client.ConnectAsync();&#10;&#10;    string conversationId = &#34;551260efe4b01608686c3e0f&#34;;//&#33719;&#21462; Jerry &#21019;&#24314;&#30340;&#23545;&#35805;&#30340; Id&#65292;&#36825;&#37324;&#26159;&#30452;&#25509;&#20174;&#25511;&#21046;&#21488;&#25335;&#36125;&#20102;&#19978;&#19968;&#33410;&#20934;&#22791;&#24037;&#20316;&#20013; JerryCreateConversation &#25104;&#21151;&#20043;&#21518;&#30340; objectId&#10;    AVIMConversation conversation = client.GetConversationById(conversationId);//Tom &#33719;&#21462;&#21040;&#36825;&#20010;&#23545;&#35805;&#30340;&#23545;&#35937;&#10;    await conversation.JoinAsync();//Tom &#20027;&#21160;&#21152;&#20837;&#21040;&#23545;&#35805;&#20013;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>该群的其他成员（比如 Bob）会根据自身客户端的状态不同会出现以下 2 种情况:</p>
<ul>
<li>如果 Bob 仅仅是登录了应用，并没有加载具体的对话到本地，他只会收到 <code>AVIMClient.OnConversationMembersChanged</code> 的响应的相关操作，代码如下:</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void BobOnTomJoined_S1()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Bob&#34;);&#10;    await client.ConnectAsync();&#10;&#10;    client.OnConversationMembersChanged += (s, e) =&#62;&#10;    &#123;&#10;        switch (e.AffectedType)&#10;        &#123;&#10;            case AVIMConversationEventType.MembersJoined:&#10;                &#123;&#10;                    IList&#60;string&#62; joinedMemberClientIds = e.AffectedMembers;//&#36825;&#37324;&#23601;&#26159;&#26412;&#27425;&#21152;&#20837;&#30340; ClientIds&#10;                    string clientId = joinedMemberClientIds.FirstOrDefault();//&#22240;&#20026;&#25105;&#20204;&#24050;&#30693;&#26412;&#27425;&#25805;&#20316;&#21482;&#26377; Tom &#19968;&#20010;&#20154;&#21152;&#20837;&#20102;&#23545;&#35805;&#65292;&#25152;&#20197;&#36825;&#26679;&#23601;&#21487;&#20197;&#30452;&#25509;&#35835;&#21462;&#21040; Tom &#30340; clientId&#10;                    //&#24320;&#21457;&#32773;&#21487;&#20197;&#22312;&#36825;&#37324;&#28155;&#21152;&#33258;&#24049;&#30340;&#19994;&#21153;&#36923;&#36753;&#10;                &#125;&#10;                break;&#10;        &#125;&#10;    &#125;;&#10;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果 Bob 不但登录了，还在客户端加载了当前这个对话，那么他不但会收到 <code>AVIMClient.OnConversationMembersChanged</code> 的响应的相关操作，也会收到 <code>AVIMConversation.OnMembersJoined</code> 的响应的相关操作，代码如下：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void BobOnTomJoined_S2()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Bob&#34;);&#10;    await client.ConnectAsync();&#10;&#10;    client.OnConversationMembersChanged += (s, e) =&#62;&#10;    &#123;&#10;        switch (e.AffectedType)&#10;        &#123;&#10;            case AVIMConversationEventType.MembersJoined:&#10;                &#123;&#10;                    IList&#60;string&#62; joinedMemberClientIds = e.AffectedMembers;//&#36825;&#37324;&#23601;&#26159;&#26412;&#27425;&#21152;&#20837;&#30340; ClientIds&#10;                    string clientId = joinedMemberClientIds.FirstOrDefault();//&#22240;&#20026;&#25105;&#20204;&#24050;&#30693;&#26412;&#27425;&#25805;&#20316;&#21482;&#26377; Tom &#19968;&#20010;&#20154;&#21152;&#20837;&#20102;&#23545;&#35805;&#65292;&#25152;&#20197;&#36825;&#26679;&#23601;&#21487;&#20197;&#30452;&#25509;&#35835;&#21462;&#21040; Tom &#30340; clientId&#10;                    //&#24320;&#21457;&#32773;&#21487;&#20197;&#22312;&#36825;&#37324;&#28155;&#21152;&#33258;&#24049;&#30340;&#19994;&#21153;&#36923;&#36753;&#10;                &#125;&#10;                break;&#10;        &#125;&#10;    &#125;;&#10;&#10;    string conversationId = &#34;551260efe4b01608686c3e0f&#34;;&#10;&#10;    AVIMConversation conversation = client.GetConversationById(conversationId);//Bob &#33719;&#21462;&#21040;&#36825;&#20010;&#23545;&#35805;&#30340;&#23545;&#35937;&#10;&#10;    conversation.OnMembersJoined += (s, e) =&#62;&#10;    &#123;&#10;        IList&#60;string&#62; joinedMemberClientIds = e.AffectedMembers;//&#36825;&#37324;&#23601;&#26159;&#26412;&#27425;&#21152;&#20837;&#30340; ClientIds&#10;        string clientId = joinedMemberClientIds.FirstOrDefault();//&#22240;&#20026;&#25105;&#20204;&#24050;&#30693;&#26412;&#27425;&#25805;&#20316;&#21482;&#26377; Tom &#19968;&#20010;&#20154;&#21152;&#20837;&#20102;&#23545;&#35805;&#65292;&#25152;&#20197;&#36825;&#26679;&#23601;&#21487;&#20197;&#30452;&#25509;&#35835;&#21462;&#21040; Tom &#30340; clientId&#10;    &#125;;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="添加其他成员">添加其他成员</h4><p>Jerry 想再把 Mary 加入到对话中，需要如下代码帮助他实现这个功能：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void InviteMaryAsync()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Jerry&#34;);&#10;    await client.ConnectAsync();&#10;&#10;    string conversationId = &#34;551260efe4b01608686c3e0f&#34;;//&#23545;&#35805;&#30340; Id&#10;    AVIMConversation conversation = client.GetConversationById(conversationId);//Jerry &#33719;&#21462;&#21040;&#36825;&#20010;&#23545;&#35805;&#30340;&#23545;&#35937;&#10;    await conversation.AddMembersAsync(&#34;Mary&#34;);//Jerry &#25226; Mary &#21152;&#20837;&#21040;&#23545;&#35805;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>该对话的其他成员（例如 Harry）也会受到该项操作的影响，收到事件被响应的通知，类似于第一小节<a href="#自身主动加入">自身主动加入</a>中<strong>Tom 加入对话之后，Bob 受到的影响。</strong></p>
<h4 id="自身退出对话">自身退出对话</h4><p>这里一定要区分<strong>自身退出对话</strong>的主动性，它与<strong>自身被动被剔除</strong>（下一小节）在逻辑上完全是不一样的。</p>
<p>Tom 主动从对话中退出，他需要如下代码实现需求：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void InitiativeLeftAsync()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    await client.ConnectAsync();&#10;&#10;    string conversationId = &#34;551260efe4b01608686c3e0f&#34;;//&#33719;&#21462; Jerry &#21019;&#24314;&#30340;&#23545;&#35805;&#30340; Id&#10;    AVIMConversation conversation = client.GetConversationById(conversationId);//Tom &#33719;&#21462;&#21040;&#36825;&#20010;&#23545;&#35805;&#30340;&#23545;&#35937;&#10;    await conversation.LeftAsync();//Tom &#20027;&#21160;&#20174;&#23545;&#35805;&#20013;&#36864;&#20986;&#10;&#125;&#10;``` &#10;&#10;#### &#21076;&#38500;&#20854;&#20182;&#25104;&#21592;&#10;&#10; Harry &#34987;  William &#20174;&#23545;&#35805;&#20013;&#21024;&#38500;&#12290;&#10;**&#27880;&#65306;&#20851;&#20110; William &#22914;&#20309;&#33719;&#24471;&#26435;&#38480;&#22312;&#21518;&#38754;&#30340;`&#31614;&#21517;&#21644;&#23433;&#20840;`&#19968;&#31456;&#33410;&#20250;&#20570;&#35814;&#32454;&#38416;&#36848;&#65292;&#27492;&#22788;&#19981;&#23452;&#25193;&#22823;&#35805;&#39064;&#33539;&#22260;&#65289;**&#10;&#10;&#20197;&#19979;&#20195;&#30721;&#21487;&#20197;&#24110;&#21161; William &#23454;&#29616;&#36825;&#19968;&#21151;&#33021;&#65306;&#10;&#10;```c#&#10;public async void WilliamKickHarryOutAsync()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;William&#34;);&#10;    await client.ConnectAsync();&#10;&#10;    string conversationId = &#34;551260efe4b01608686c3e0f&#34;;//&#23545;&#35805;&#30340; Id&#10;    AVIMConversation conversation = client.GetConversationById(conversationId);//William &#33719;&#21462;&#21040;&#36825;&#20010;&#23545;&#35805;&#30340;&#23545;&#35937;&#10;    await conversation.RemoveMembersAsync(&#34;Harry&#34;);//William &#25226; Harry &#20174;&#23545;&#35805;&#20013;&#21076;&#38500;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>以上的描述可以用几张表格来解释：</p>
<p>1.假如对话中已经有了 A，C</p>
<table>
<thead>
<tr>
<th>B 的操作</th>
<th>对 B 的影响</th>
<th>对 C 的影响</th>
</tr>
</thead>
<tbody>
<tr>
<td>B 加入</td>
<td><code>OnConversationMembersChanged &amp;&amp; OnJoined</code></td>
<td><code>OnConversationMembersChanged &amp;&amp; OnMembersJoined</code></td>
</tr>
<tr>
<td>B 再离开</td>
<td><code>OnConversationMembersChanged &amp;&amp; OnLeft</code></td>
<td><code>OnConversationMembersChanged &amp;&amp; OnMembersLeft</code></td>
</tr>
</tbody>
</table>
<p>2.假如对话中已经有了 A，C</p>
<table>
<thead>
<tr>
<th>A 对 B 的操作</th>
<th>对 B 的影响</th>
<th>对 C 的影响</th>
</tr>
</thead>
<tbody>
<tr>
<td>A 添加 B</td>
<td><code>OnConversationMembersChanged &amp;&amp; OnInvited</code></td>
<td><code>OnConversationMembersChanged &amp;&amp; OnMembersJoined</code></td>
</tr>
<tr>
<td>A 再剔除 B</td>
<td><code>OnConversationMembersChanged &amp;&amp; OnKicked</code></td>
<td><code>OnConversationMembersChanged &amp;&amp; OnMembersLeft</code></td>
</tr>
</tbody>
</table>
<h4 id="查询成员数量">查询成员数量</h4><p><code>AVIMConversation.CountMembersAsync</code> 这个方法是返回实时的数据：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void CountMembers_SampleCode()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    await client.ConnectAsync();//Tom &#30331;&#24405;&#23458;&#25143;&#31471;&#10;&#10;    AVIMConversation conversation = (await client.GetQuery().FindAsync()).FirstOrDefault();&#10;    int membersCount = await conversation.CountMembersAsync();&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="对话的属性管理">对话的属性管理</h3><p>对话（AVIMConversation）与控制台中 <code>_Conversation</code> 表是一一对应的，默认提供的属性对应的关系如下：</p>
<table>
<thead>
<tr>
<th>AVIMConversation 属性名</th>
<th>_Conversation 字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>AVIMConversation.ConversationId</code></td>
<td><code>_Conversation.objectId</code></td>
<td>全局唯一的 Id</td>
</tr>
<tr>
<td><code>AVIMConversation.Name</code></td>
<td><code>_Conversation.name</code></td>
<td>成员共享的统一的名字</td>
</tr>
<tr>
<td><code>AVIMConversation.MemberIds</code></td>
<td><code>_Conversation.m</code></td>
<td>成员列表</td>
</tr>
<tr>
<td><code>AVIMConversation.MuteMemberIds</code></td>
<td><code>_Conversation.mu</code></td>
<td>静音成员列表</td>
</tr>
<tr>
<td><code>AVIMConversation.Creator</code></td>
<td><code>_Conversation.c</code></td>
<td>对话创建者</td>
</tr>
<tr>
<td><code>AVIMConversation.LastMessageAt</code></td>
<td><code>_Conversation.lm</code></td>
<td>对话最后一条消息发送的时间</td>
</tr>
<tr>
<td><code>AVIMConversation.Attributes</code></td>
<td><code>_Conversation.attr</code></td>
<td>自定义属性</td>
</tr>
<tr>
<td><code>AVIMConversation.IsTransient</code></td>
<td><code>_Conversation.tr</code></td>
<td>是否为聊天室（暂态对话）</td>
</tr>
</tbody>
</table>
<h4 id="名称">名称</h4><p>这个属性是全员共享的一个属性，他可以在创建时指定，也可以在日后的维护中被修改。</p>
<p>Tom 想建立一个名字叫「喵星人」 对话并且邀请了好友 Black 加入对话，需要写的代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void CreateConversationAsync()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    string anotherCat = &#34;Black&#34;;&#10;    await client.ConnectAsync();&#10;&#10;    AVIMConversation conversation = await client.CreateConversationAsync(anotherCat, &#34;&#21941;&#26143;&#20154;&#34;);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>Black 发现对话名字不够酷，他想修改成「聪明的喵星人」 ，他需要如下代码：   </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void UpdateConversationAsync()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Black&#34;);&#10;    await client.ConnectAsync();//Balck &#30331;&#24405;&#10;&#10;    AVIMConversation conversation = client.GetConversationById(&#34;55117292e4b065f7ee9edd29&#34;);//&#33719;&#21462; Tom &#21019;&#24314;&#30340;&#23545;&#35805;&#10;&#10;    conversation.Name = &#34;&#32874;&#26126;&#30340;&#21941;&#26143;&#20154;&#34;;//&#20462;&#25913;&#21517;&#31216;&#10;&#10;    await conversation.SaveAsync();//&#20445;&#23384;&#21040;&#26381;&#21153;&#31471;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="成员">成员</h4><p><code>AVIMConversation.MemberIds</code> ：该属性表示当前对话中所包含的成员的 <code>clientId</code> ，<br>这个属性<strong>强烈建议开发者切勿在控制台中随意修改</strong>，所有关于成员的操作请参照上一章节中的 <code>成员管理</code> 来进行。</p>
<h4 id="静音成员">静音成员</h4><p><code>AVIMConversation.MuteMemberIds</code> ：该属性表示当前对话中所进行了静音操作成员的 <code>clientId</code> ，<br>假如某一个用户不想再收到某对话的消息，又不想直接退出对话，可以使用静音操作。</p>
<p>比如 Tom 工作繁忙，对某个对话设置了静音：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void MuteConversationAsync()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    await client.ConnectAsync();//Tom &#30331;&#24405;&#10;&#10;    string conversationId = &#34;551260efe4b01608686c3e0f&#34;;//&#23545;&#35805;&#30340; Id&#10;    AVIMConversation conversation = client.GetConversationById(conversationId);//Tom &#33719;&#21462;&#21040;&#36825;&#20010;&#23545;&#35805;&#30340;&#23545;&#35937;&#10;    await conversation.MuteAsync();//Tom &#35774;&#32622;&#38745;&#38899;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>设置静音之后，针对 iOS 以及 Windows Phone 用户就不会收到推送消息</strong></p>
<p>此操作修改的是服务端 <code>_Conversation</code> 里面的 <code>mu</code> 属性。<br>与之对应的就是 <code>UnmuteAsync</code>操作，就是取消静音，示例代码参照静音操作。<br><strong>强烈建议开发者切勿在控制台中随意修改</strong>。</p>
<h4 id="创建者">创建者</h4><p><code>AVIMConversation.Creator</code> 对话的创建者可以帮助实现类似于 QQ 群中区别「管理员」和「群创建者」的功能，它的值是对话创建者的 <code>clientId</code>。</p>
<p>案例：QQ 群的「创建者」是固定不变的，它的图标颜色与「管理员」的图标颜色都不一样。<br>所以根据对话中成员的 <code>clientId</code> 是否与 <code>AVIMConversation.Creator</code> 一致就可以判断出他是不是群的创建者。</p>
<h4 id="自定义属性">自定义属性</h4><p>此属性是为了帮助开发者给对话添加自定义属性。开发者可以随意存储自己的键值对，以帮助开发者实现自己的业务逻辑需求。</p>
<p>典型的场景是，我想对某个对话设置 tag 是 private，表示我要标记这个对话是私有的：</p>
<p>如下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void CreateConversationWithCustomAttributesAsync()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    await client.ConnectAsync();&#10;    IDictionary&#60;string, object&#62; attr = new Dictionary&#60;string, object&#62;();&#10;    attr.Add(&#34;tag&#34;, &#34;private&#34;);&#10;    AVIMConversation conversation = await client.CreateConversationAsync(&#34;Jerry&#34;, &#34;&#29483;&#21644;&#32769;&#40736;&#34;, attr);//&#21019;&#24314;&#23545;&#35805;&#30340;&#26102;&#20505;&#20256;&#20837;&#21363;&#21487;&#12290;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：AVIMConversation.Attributes 在 SDK 级别是对所有成员可见的，如果要控制所谓的可见性，开发者需要自己维护这一属性的读取权限</strong></p>
<p><code>AVIMConversation.Attributes</code> 在<code>对话查询</code>一节还有更多的用法。</p>
<h2 id="对话的查询">对话的查询</h2><h3 id="基础查询">基础查询</h3><p>假如已知某一对话的 <code>Id</code>，可以使用它来查询该对话的详细信息<br>代码实例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void QueryByIdAsync()&#10;&#123;&#10;   AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;   await client.ConnectAsync();//Tom &#30331;&#24405;&#23458;&#25143;&#31471;&#10;   AVIMConversation conversation = await client.GetQuery().GetAsync(&#34;551260efe4b01608686c3e0f&#34;);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意这个方法和  AVIMClient.GetConversationById 本质上是不一样的，AVIMClient.GetConversationById 可以理解为本地构造一个 AVIMConversation ，但是它除了 Id 别的属性都为空，而 GetAsync 是直接从服务端拉取数据，更为可靠，但是它是异步的。</strong></p>
<h3 id="条件查询">条件查询</h3><p>条件查询包含分类有<code>比较查询</code>,<code>匹配查询</code></p>
<h4 id="比较查询">比较查询</h4><p>比较查询在一般的理解上都包含以下几种：</p>
<table>
<thead>
<tr>
<th>逻辑操作</th>
<th>AVIMConversationQuery 对应的方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>等于</td>
<td><code>WhereEqualTo</code></td>
</tr>
<tr>
<td>不等于</td>
<td><code>WhereNotEqualTo</code> </td>
</tr>
<tr>
<td>大于</td>
<td><code>WhereGreaterThan</code></td>
</tr>
<tr>
<td>大于等于</td>
<td><code>WhereGreaterThanOrEqualTo</code> </td>
</tr>
<tr>
<td>小于</td>
<td><code>WhereLessThan</code></td>
</tr>
<tr>
<td>小于等于</td>
<td><code>WhereLessThanOrEqualTo</code></td>
</tr>
</tbody>
</table>
<p>比较查询最常用的是 <code>WhereEqualTo</code>：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">WhereEqualTo_SampleCode</span>(<span class="params"></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    AVIMClient client = <span class="keyword">new</span> AVIMClient(<span class="string">"Tom"</span>);</span><br><span class="line">    <span class="keyword">await</span> client.ConnectAsync();<span class="comment">//Tom 登录客户端</span></span><br><span class="line">    AVIMConversationQuery query = client.GetQuery().WhereEqualTo(<span class="string">"attr.topic"</span>, <span class="string">"movie"</span>);<span class="comment">//构建 topic 是 movie 的查询</span></span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">await</span> query.FindAsync();<span class="comment">//执行查询</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>目前条件查询只针对  <code>AVIMConversation</code> 的 <code>Attributes</code> 属性进行的，也就是针对 <code>_Conversation</code>  表中的 <code>attr</code> 字段进行的 <code>AVQuery</code> 查询。</p>
<p>实际上为了方便开发者自动为了自定义属性的 key 值增加 <code>attr.</code> 的前缀，SDK 特地添加了一个针对 <code>string</code> 类型的<a href="https://msdn.microsoft.com/zh-cn/library/bb383977.aspx" target="_blank" rel="external">拓展方法</a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/// &#60;summary&#62;&#10;/// &#20026;&#32842;&#22825;&#30340;&#33258;&#23450;&#20041;&#23646;&#24615;&#26597;&#35810;&#33258;&#21160;&#28155;&#21152; &#34;attr.&#34; &#30340;&#21069;&#32512;&#10;/// &#60;/summary&#62;&#10;/// &#60;param name=&#34;key&#34;&#62;&#23646;&#24615; key &#20540;&#65292;&#20363;&#22914; type &#60;/param&#62;&#10;/// &#60;returns&#62;&#28155;&#21152;&#21069;&#32512;&#30340;&#20540;&#65292;&#20363;&#22914;&#65292;attr.type &#60;/returns&#62;&#10;public static string InsertAttrPrefix(this string key)&#10;&#123;&#10;    return key.Insert(0, &#34;attr.&#34;);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>导入 SDK 之后在 Visual Studio 里面使用 <code>string</code> 类型的时候可以智能感应提示该方法。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVIMConversationQuery query = client.GetQuery().WhereEqualTo(&#34;topic&#34;.InsertAttrPrefix(), &#34;movie&#34;);//&#36825;&#26679;&#23601;&#21487;&#20197;&#23454;&#29616;&#33258;&#21160;&#20026; `topic` &#28155;&#21152; `attr.` &#21069;&#32512;&#30340;&#25928;&#26524;&#30340;&#25928;&#26524;&#12290;</span><br></pre></td></tr></table></figure>
<p>与 <code>WhereEqualTo</code> 相对的就是 <code>WhereNotEqualTo</code> ，以下代码将查询到类型不是私有的对话：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void WhereNotEqualTo_SampleCode()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    await client.ConnectAsync();//Tom &#30331;&#24405;&#23458;&#25143;&#31471;&#10;    AVIMConversationQuery query = client.GetQuery().WhereNotEqualTo(&#34;attr.type&#34;, &#34;private&#34;);//&#26500;&#24314; type &#19981;&#31561;&#20110; movie &#30340;&#26597;&#35810;&#10;    var result = await query.FindAsync();//&#25191;&#34892;&#26597;&#35810;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于可以比较大小的整型，浮点等常用类型，可以参照以下示例代码进行拓展：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void WhereGreaterThan_SampleCode()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    await client.ConnectAsync();//Tom &#30331;&#24405;&#23458;&#25143;&#31471;&#10;    AVIMConversationQuery query = client.GetQuery().WhereGreaterThan(&#34;attr.age&#34;, 18);//&#26500;&#24314; &#24180;&#40836;&#22823;&#20110; 18 &#30340;&#26597;&#35810;&#10;    var result = await query.FindAsync();//&#25191;&#34892;&#26597;&#35810;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="正则匹配查询">正则匹配查询</h4><p>匹配查询指的是在 <code>AVIMConversationQuery</code> 中以 <code>WhereMatches</code> 为前缀的方法。</p>
<p>Match 类的方法最大的便捷之处就是使用了正则表达式匹配，这样使得，客户端在构建基于正则表达式的查询的时候可以利用 .NET 里面诸多已经熟悉了的概念和接口。</p>
<p>比如要查询所有 <code>tag</code> 是中文的对话可以如下进行：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void WhereMatchs_SampleCode()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    await client.ConnectAsync();//Tom &#30331;&#24405;&#23458;&#25143;&#31471;&#10;    AVIMConversationQuery query = client.GetQuery().WhereMatches(&#34;attr.tag&#34;, &#34;[\u4e00-\u9fa5]&#34;);//&#26597;&#35810; tag &#26159;&#20013;&#25991;&#30340;&#23545;&#35805;&#10;    var result = await query.FindAsync();//&#25191;&#34892;&#26597;&#35810;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="包含查询">包含查询</h4><p>包含查询指的是 方法名字包含 <code>Contains</code> 单词的方法，例如查询关键字包含「教育」的对话：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void WhereContains_SampleCode()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    await client.ConnectAsync();//Tom &#30331;&#24405;&#23458;&#25143;&#31471;&#10;    AVIMConversationQuery query = client.GetQuery().WhereContains(&#34;attr.keywords&#34;, &#34;&#25945;&#32946;&#34;);//&#26597;&#35810; keywords &#21253;&#21547;&#25945;&#32946;&#10;    var result = await query.FindAsync();//&#25191;&#34892;&#26597;&#35810;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>另外，包含查询还能检索与成员相关的对话数据。<br>以下代码将帮助 <code>Tom</code> 查找出 <code>Jerry</code> 以及 <code>Bob</code> 都存在的对话：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void QueryMembers_SampleCode()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;&#10;    IList&#60;string&#62; clientIds = new List&#60;string&#62;();&#10;    clientIds.Add(&#34;Bob&#34;);&#10;    clientIds.Add(&#34;Jerry&#34;);&#10;&#10;    AVIMConversationQuery query = client.GetQuery().WhereContainedIn&#60;string&#62;(&#34;m&#34;, clientIds);//&#26597;&#35810;&#23545;&#35805;&#25104;&#21592; Bob &#20197;&#21450; Jerry &#30340;&#23545;&#35805;&#10;    var result = await query.FindAsync();//&#25191;&#34892;&#26597;&#35810;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="组合查询">组合查询</h3><p>组合查询的概念就是把诸多查询条件合并成一个查询，再交给 SDK 去服务端进行查询。</p>
<p>LeanCloud .NET SDK 的风格上一直保持以链式的方式提供给开发者去组合符合自己业务逻辑的查询，例如，要查询年龄小于18岁，并且关键字包含「教育」的对话：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void CombinationQuery_SampleCode()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    await client.ConnectAsync();//Tom &#30331;&#24405;&#23458;&#25143;&#31471;&#10;    AVIMConversationQuery query = client.GetQuery().WhereContains(&#34;attr.keywords&#34;, &#34;&#25945;&#32946;&#34;).WhereLessThan(&#34;age&#34;, 18);//&#26597;&#35810; keywords &#21253;&#21547;&#25945;&#24182;&#19988;&#24180;&#40836;&#23567;&#20110;18&#30340;&#23545;&#35805;&#10;    var result = await query.FindAsync();//&#25191;&#34892;&#26597;&#35810;&#10;&#125;&#10;``` &#10;&#10;&#21482;&#35201;&#26597;&#35810;&#26500;&#24314;&#24471;&#21512;&#29702;&#65292;&#24320;&#21457;&#32773;&#23436;&#20840;&#19981;&#38656;&#35201;&#25285;&#24515;&#32452;&#21512;&#26597;&#35810;&#30340;&#24615;&#33021;&#12290;&#10;&#10;### &#35745;&#25968;&#26597;&#35810;&#10;&#20219;&#24847;&#30340;&#26597;&#35810;&#65292;&#19981;&#31649;&#26159;&#21333;&#26597;&#35810;&#36824;&#26159;&#32452;&#21512;&#26597;&#35810;&#65292;&#37117;&#25903;&#25345;&#35745;&#25968;&#26597;&#35810;:&#10;&#10;```c#&#10;public async void QueryCount_SampleCode()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    await client.ConnectAsync();//Tom &#30331;&#24405;&#23458;&#25143;&#31471;&#10;    AVIMConversationQuery query = client.GetQuery().WhereContains(&#34;attr.keywords&#34;, &#34;&#25945;&#32946;&#34;).WhereLessThan(&#34;attr.age&#34;, 18);//&#26597;&#35810; keywords &#21253;&#21547;&#25945;&#24182;&#19988;&#24180;&#40836;&#23567;&#20110;18&#30340;&#23545;&#35805;&#10;    var count = await query.CountAsync();//&#25191;&#34892;&#26597;&#35810;&#65292;&#33719;&#21462;&#31526;&#21512;&#26465;&#20214;&#30340;&#23545;&#35805;&#30340;&#25968;&#37327;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="开放聊天室">开放聊天室</h2><p>开放聊天室在本质上就是一个对话，所以以上章节中提到了<strong>所有的属性，方法，操作以及管理，都对开放聊天室适用</strong>，它仅仅是在逻辑上是一种暂态的，临时的对话。</p>
<h3 id="创建开放聊天室">创建开放聊天室</h3><p>比如某项比赛正在直播，解说员创建一个临时聊天，与球迷进行互动：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void ChatRoom_SampleCode()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Dendi&#34;);&#10;    await client.ConnectAsync();//Tom &#30331;&#24405;&#23458;&#25143;&#31471;&#10;    var chatroom = client.CreateConversationAsync(null, &#34;DK VS NewBee&#34;, null, true);&#10;    //&#35814;&#32454;&#35299;&#37322;&#26368;&#21518;&#19968;&#20010;&#21442;&#25968;&#65292;transient &#22914;&#26524;&#20026; true &#23601;&#35828;&#26126;&#26159;&#32842;&#22825;&#23460;&#65292;&#36923;&#36753;&#19978;&#23601;&#26159;&#26242;&#24577;&#23545;&#35805;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>另外，为了方便开发者快速创建聊天室，SDK 提供了一个快捷方法创建聊天室：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var chatroom = client.CreateChatRoomAsync(&#34;&#30343;&#39532; VS &#24052;&#33832;&#34;);//&#21487;&#20197;&#29702;&#35299;&#20026;&#19968;&#20010;&#35821;&#27861;&#31958;&#65292;&#19982;&#35843;&#29992;CreateConversationAsync &#27809;&#26377;&#26412;&#36136;&#21306;&#21035;</span><br></pre></td></tr></table></figure>
<h3 id="查询在线人数">查询在线人数</h3><p><code>AVIMConversation.CountMembersAsync</code> 不但可以用来查询普通对话的成员总数，在聊天室中，它返回的就是实时在线的人数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void CountMembers_SampleCode()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    await client.ConnectAsync();//Tom &#30331;&#24405;&#23458;&#25143;&#31471;&#10;&#10;    AVIMConversation conversation = (await client.GetQuery().FindAsync()).FirstOrDefault();&#10;    int membersCount = await conversation.CountMembersAsync();&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询开放聊天室">查询开放聊天室</h3><p>开发者需要注意的是，<code>AVIMConversationQuery</code> 调用 <code>Where</code> 开头的方法都是查询全部对话的，也就是说，如果想单独查询聊天室的话，需要额外再调用一次 <code>WhereEqulaTo</code> 方法：</p>
<p>比如我想查询主题包含《奔跑吧，兄弟》的聊天室，如下做即可：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void QueryChatRoom_SampleCode()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    await client.ConnectAsync();//Tom &#30331;&#24405;&#23458;&#25143;&#31471;&#10;&#10;    AVIMConversationQuery query = client.GetQuery().WhereContains(&#34;topic&#34;.InsertAttrPrefix(), &#34;&#22868;&#36305;&#21543;&#65292;&#20804;&#24351;&#34;).WhereEqualTo(&#34;tr&#34;, true);&#10;    //&#27604;&#22914;&#25105;&#24819;&#26597;&#35810;&#20027;&#39064;&#21253;&#21547;&#12298;&#22868;&#36305;&#21543;&#65292;&#20804;&#24351;&#12299;&#30340;&#32842;&#22825;&#23460;&#10;    var result = await query.FindAsync();//&#25191;&#34892;&#26597;&#35810;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>从代码上可以看出，仅仅是多了一个额外的 <code>WhereEqualTo(&quot;tr&quot;, true)</code> 的链式查询即可。</p>
<h2 id="聊天记录">聊天记录</h2><p>聊天记录一直是客户端开发的一个重点难题，类似于的 QQ 和 微信的解决方案都是依托客户端做缓存，收到一条消息，就按照自己的业务逻辑存储在客户端的文件或者是各种客户端数据库中。</p>
<p>目前为了满足需求，我们特地开放了从服务端获取聊天记录的功能：</p>
<h3 id="聊天记录获取">聊天记录获取</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVIMClient userA = new AVIMClient(&#34;UserA&#34;);&#10;AVIMConversation con = userA.GetConversationById(&#34;2f08e882f2a11ef07902eeb510d4223b&#34;);&#10;con.QueryHistory(DateTime.Now.AddDays(-1), 0, &#34;UserA&#34;).Wait();&#10;//&#26597;&#35810; UserA &#22312; ConversationId &#20026; `2f08e882f2a11ef07902eeb510d4223b` &#20013;&#30340;&#32842;&#22825;&#35760;&#24405;&#12290;</span><br></pre></td></tr></table></figure>
<p>以上将查询昨天到现在 24 小时内对话中的聊天记录。</p>
<h2 id="签名与安全">签名与安全</h2><p>在继续阅读本文档之前，请确保您已经对 <a href="./realtime_v2.html#权限和认证">实时通信服务开发指南—权限和认证</a> 有了一定的了解。</p>
<h3 id="实现签名工厂">实现签名工厂</h3><p><code>AVIMClient</code> 有一个属性：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/// &#60;summary&#62;&#10;/// &#33719;&#21462;&#31614;&#21517;&#30340;&#25509;&#21475;&#10;/// &#60;/summary&#62;&#10;public ISignatureFactoryV2 SignatureFactory &#123; get; set; &#125;</span><br></pre></td></tr></table></figure>
<p>是预留给开发者实现签名需求的接口，开发者只需要在登录之前实现这个接口即可。</p>
<h3 id="签名的云代码实例">签名的云代码实例</h3><p>为了方便开发者理解签名，我们特地开源了签名的<a href="https://github.com/leancloud/realtime-messaging-signature-cloudcode" target="_blank" rel="external">云代码实例</a>，只要按照要求正确配置，就可以在客户端通过调用云代码的具体的函数实现签名。</p>
<p>演示实例的步骤：</p>
<ul>
<li><p>首先您需要下载最新版本的<a href="https://github.com/leancloud/realtime-messaging-signature-cloudcode" target="_blank" rel="external">云代码实例</a>到本地，然后部署到您的应用中，详细请参考<a href="./cloud_code_commandline.html">云代码命令行工具使用详解</a></p>
</li>
<li><p>其次，在 Visual Studio 中，新建一个类叫做 <code>SampleSignatureFactory</code> ，把下面这段代码拷贝到其中：</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/// &#60;summary&#62;&#10;/// &#31614;&#21517;&#31034;&#20363;&#31867;&#65292;&#25512;&#33616;&#24320;&#21457;&#32773;&#29992;&#36825;&#27573;&#20195;&#30721;&#29702;&#35299;&#31614;&#21517;&#30340;&#25972;&#20307;&#27010;&#24565;&#65292;&#27491;&#24335;&#29983;&#20135;&#29615;&#22659;&#65292;&#35831;&#24910;&#29992;&#10;/// &#60;/summary&#62;&#10;public class SampleSignatureFactory : ISignatureFactoryV2&#10;&#123;&#10;    /// &#60;summary&#62;&#10;    /// &#20026;&#26356;&#26032;&#23545;&#35805;&#25104;&#21592;&#30340;&#25805;&#20316;&#36827;&#34892;&#31614;&#21517;&#10;    /// &#60;/summary&#62;&#10;    /// &#60;param name=&#34;conversationId&#34;&#62;&#23545;&#35805;&#30340;Id&#60;/param&#62;&#10;    /// &#60;param name=&#34;clientId&#34;&#62;&#24403;&#21069;&#30340; clientId&#60;/param&#62;&#10;    /// &#60;param name=&#34;targetIds&#34;&#62;&#34987;&#25805;&#20316;&#25152;&#24433;&#21709;&#21040;&#30340; clientIds&#60;/param&#62;&#10;    /// &#60;param name=&#34;action&#34;&#62;&#25191;&#34892;&#30340;&#25805;&#20316;&#65292;&#30446;&#21069;&#21482;&#26377; add&#65292;remove&#60;/param&#62;&#10;    /// &#60;returns&#62;&#60;/returns&#62;&#10;    public Task&#60;AVIMSignatureV2&#62; CreateConversationSignature(string conversationId, string clientId, IList&#60;string&#62; targetIds, string action)&#10;    &#123;&#10;        var data = new Dictionary&#60;string, object&#62;();&#10;&#10;        data.Add(&#34;client_id&#34;, clientId);//&#34920;&#31034;&#24403;&#21069;&#26159;&#35841;&#22312;&#25805;&#20316;&#12290;&#10;        data.Add(&#34;member_ids&#34;, targetIds);//memberIds&#19981;&#35201;&#21253;&#21547;&#24403;&#21069;&#30340;ClientId&#12290;&#10;        data.Add(&#34;conversation_id&#34;, conversationId);//conversationId&#26159;&#31614;&#21517;&#24517;&#39035;&#30340;&#21442;&#25968;&#12290;&#10;           &#10;        data.Add(&#34;action&#34;, action);//conversationId&#26159;&#31614;&#21517;&#24517;&#39035;&#30340;&#21442;&#25968;&#12290;&#10;            &#10;            &#10;        //&#35843;&#29992;&#20113;&#20195;&#30721;&#36827;&#34892;&#31614;&#21517;&#12290;&#10;        return AVCloud.CallFunctionAsync&#60;IDictionary&#60;string, object&#62;&#62;(&#34;actionOnCoversation&#34;, data).ContinueWith&#60;AVIMSignatureV2&#62;(t =&#62;&#10;        &#123;&#10;            return MakeSignature(t.Result); ;//&#25340;&#35013;&#25104;&#19968;&#20010; Signature &#23545;&#35937;&#10;        &#125;);&#10;        //&#20197;&#19978;&#36825;&#27573;&#20195;&#30721;&#65292;&#24320;&#21457;&#32773;&#26080;&#38656;&#25163;&#21160;&#35843;&#29992;&#65292;&#21482;&#35201;&#24320;&#21457;&#32773;&#23545;&#19968;&#20010; AVIMClient &#35774;&#32622;&#20102; SignatureFactory&#65292;SDK &#20250;&#22312;&#25191;&#34892;&#23545;&#24212;&#30340;&#25805;&#20316;&#26102;&#20027;&#21160;&#35843;&#29992;&#36825;&#20010;&#26041;&#27861;&#36827;&#34892;&#31614;&#21517;&#12290;&#10;    &#125;&#10;    /// &#60;summary&#62;&#10;    /// &#30331;&#24405;&#31614;&#21517;&#10;    /// &#60;/summary&#62;&#10;    /// &#60;param name=&#34;clientId&#34;&#62;&#24403;&#21069;&#30340; clientId&#60;/param&#62;&#10;    /// &#60;returns&#62;&#60;/returns&#62;&#10;    public Task&#60;AVIMSignatureV2&#62; CreateConnectSignature(string clientId)&#10;    &#123;&#10;        var data = new Dictionary&#60;string, object&#62;();&#10;&#10;        data.Add(&#34;client_id&#34;, clientId);//&#34920;&#31034;&#24403;&#21069;&#26159;&#35841;&#35201;&#27714;&#36830;&#25509;&#26381;&#21153;&#22120;&#12290; &#10;&#10;        //&#35843;&#29992;&#20113;&#20195;&#30721;&#36827;&#34892;&#31614;&#21517;&#12290;&#10;        return AVCloud.CallFunctionAsync&#60;IDictionary&#60;string, object&#62;&#62;(&#34;connect&#34;, data).ContinueWith&#60;AVIMSignatureV2&#62;(t =&#62;&#10;        &#123;&#10;            return MakeSignature(t.Result); ;//&#25340;&#35013;&#25104;&#19968;&#20010; Signature &#23545;&#35937;&#10;        &#125;);&#10;    &#125;&#10;&#10;    /// &#60;summary&#62;&#10;    /// &#20026;&#21019;&#24314;&#23545;&#35805;&#31614;&#21517;&#10;    /// &#60;/summary&#62;&#10;    /// &#60;param name=&#34;clientId&#34;&#62;&#24403;&#21069;&#30340; clientId &#60;/param&#62;&#10;    /// &#60;param name=&#34;targetIds&#34;&#62;&#34987;&#24433;&#21709;&#30340; clientIds &#60;/param&#62;&#10;    /// &#60;returns&#62;&#60;/returns&#62;&#10;    public Task&#60;AVIMSignatureV2&#62; CreateStartConversationSignature(string clientId, IList&#60;string&#62; targetIds)&#10;    &#123;&#10;        var data = new Dictionary&#60;string, object&#62;();&#10;&#10;        data.Add(&#34;client_id&#34;, clientId);//&#34920;&#31034;&#24403;&#21069;&#26159;&#35841;&#22312;&#25805;&#20316;&#12290;&#10;        data.Add(&#34;member_ids&#34;, targetIds);//memberIds&#19981;&#35201;&#21253;&#21547;&#24403;&#21069;&#30340;ClientId&#12290;&#10;&#10;        //&#35843;&#29992;&#20113;&#20195;&#30721;&#36827;&#34892;&#31614;&#21517;&#12290;&#10;        return AVCloud.CallFunctionAsync&#60;IDictionary&#60;string, object&#62;&#62;(&#34;startConversation&#34;, data).ContinueWith&#60;AVIMSignatureV2&#62;(t =&#62;&#10;        &#123;&#10;            return MakeSignature(t.Result); ;//&#25340;&#35013;&#25104;&#19968;&#20010; Signature &#23545;&#35937;&#10;        &#125;);&#10;    &#125;&#10;&#10;    /// &#60;summary&#62;&#10;    /// &#33719;&#21462;&#31614;&#21517;&#20449;&#24687;&#24182;&#19988;&#25226;&#23427;&#36820;&#22238;&#32473; SDK &#21435;&#36827;&#34892;&#19979;&#19968;&#27493;&#30340;&#25805;&#20316;&#10;    /// &#60;/summary&#62;&#10;    /// &#60;param name=&#34;dataFromCloudcode&#34;&#62;&#60;/param&#62;&#10;    /// &#60;returns&#62;&#60;/returns&#62;&#10;    protected AVIMSignatureV2 MakeSignature(IDictionary&#60;string, object&#62; dataFromCloudcode)&#10;    &#123;&#10;        AVIMSignatureV2 signature = new AVIMSignatureV2();&#10;        signature.Nonce = dataFromCloudcode[&#34;nonce&#34;].ToString();&#10;        signature.SignatureContent = dataFromCloudcode[&#34;signature&#34;].ToString();&#10;        signature.Timestamp = (long)dataFromCloudcode[&#34;timestamp&#34;];&#10;        return signature;//&#25340;&#35013;&#25104;&#19968;&#20010; Signature &#23545;&#35937;&#10;    &#125;&#10;&#10;    /// &#60;summary&#62;&#10;    /// &#20026;&#33719;&#21462;&#32842;&#22825;&#35760;&#24405;&#30340;&#25805;&#20316;&#31614;&#21517;&#10;    /// &#60;/summary&#62;&#10;    /// &#60;param name=&#34;clientId&#34;&#62;&#24403;&#21069;&#30340; clientId &#60;/param&#62;&#10;    /// &#60;param name=&#34;conversationId&#34;&#62;&#23545;&#35805; Id&#60;/param&#62;&#10;    /// &#60;returns&#62;&#60;/returns&#62;&#10;    public Task&#60;AVIMSignatureV2&#62; CreateQueryHistorySignature(string clientId, string conversationId)&#10;    &#123;&#10;        var data = new Dictionary&#60;string, object&#62;();&#10;&#10;        data.Add(&#34;client_id&#34;, clientId);//&#34920;&#31034;&#24403;&#21069;&#26159;&#35841;&#22312;&#25805;&#20316;&#12290;&#10;        data.Add(&#34;convid&#34;, conversationId);//memberIds&#19981;&#35201;&#21253;&#21547;&#24403;&#21069;&#30340;ClientId&#12290;&#10;&#10;        //&#35843;&#29992;&#20113;&#20195;&#30721;&#36827;&#34892;&#31614;&#21517;&#12290;&#10;        return AVCloud.CallFunctionAsync&#60;IDictionary&#60;string, object&#62;&#62;(&#34;queryHistory&#34;, data).ContinueWith&#60;AVIMSignatureV2&#62;(t =&#62;&#10;        &#123;&#10;            return MakeSignature(t.Result); ;//&#25340;&#35013;&#25104;&#19968;&#20010; Signature &#23545;&#35937;&#10;        &#125;);&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>然后在调用如下代码进行测试（确保您已经在控制台开启了聊天签名的服务，否则签名操作无效）：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;client.SignatureFactory = new SampleSignatureFactory();//&#36825;&#37324;&#26159;&#19968;&#20010;&#24320;&#21457;&#32773;&#33258;&#24049;&#23454;&#29616;&#30340;&#25509;&#21475;&#30340;&#20855;&#20307;&#30340;&#31867;&#10;await client.ConnectAsync();//Tom &#30331;&#24405;&#23458;&#25143;&#31471;</span><br></pre></td></tr></table></figure>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/2/">&raquo;</a>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="https://avatars2.githubusercontent.com/u/14305708?v=3&s=460" alt="terry" itemprop="image"/>
          <p class="site-author-name" itemprop="name">terry</p>
        </div>
        <p class="site-description motion-element" itemprop="description">terry yang's blog | java | scala | bi</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">136</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">11</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-next-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yangwei8888" target="_blank">github</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/microsoftgoogles" target="_blank">weibo</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/run-zhi-38" target="_blank">zhihu</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">terry</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  

    <script type="text/javascript">
      var disqus_shortname = 'yangwei888';
      var disqus_identifier = 'index.html';
      var disqus_title = '';
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
