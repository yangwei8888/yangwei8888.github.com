

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Bridging Swift Arrays to/from Cocoa &mdash; Swift Programming Language documentation 0.1.9 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Swift Programming Language documentation 0.1.9 documentation" href="../index.html"/>
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>


  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Swift Programming Language documentation
          

          
          </a>

          
            
            
              <div class="version">
                0.1.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">swift docs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../ABI.html">The Swift ABI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ARCOptimization.html">ARC Optimization for Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="../AccessControl.html">Access Control</a></li>
<li class="toctree-l1"><a class="reference internal" href="../AccessControlInStdlib.html">Scope and introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../AccessControlInStdlib.html#public"><cite>public</cite></a></li>
<li class="toctree-l1"><a class="reference internal" href="../AccessControlInStdlib.html#internal"><cite>internal</cite></a></li>
<li class="toctree-l1"><a class="reference internal" href="../AccessControlInStdlib.html#private"><cite>private</cite></a></li>
<li class="toctree-l1"><a class="reference internal" href="../AccessControlInStdlib.html#leading-underscore-rule">Leading Underscore Rule</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Arrays.html">The Swift Array Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CallingConvention.html">The Swift Calling Convention</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DebuggingTheCompiler.html">Debugging the Swift Compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Dependency Analysis.html">Dependency Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DriverInternals.html">Driver Design &amp; Internals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DriverParseableOutput.html">Parseable Driver Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ErrorHandling.html">Error Handling in Swift 2.0</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ErrorHandlingRationale.html">Error Handling Rationale and Proposal</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Failable Initializers.html">Failable initializers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Generics.html">Generics in Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="../GitWorkflows.html">Git Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../GitWorkflows.html#svn-git-workflows">SVN -&gt; GIT Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HighLevelSILOptimizations.html">High-Level Optimizations in SIL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Import.html">IMPORT SYNTAX</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Import.html#resolving-name-clashes">RESOLVING NAME CLASHES</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Import.html#future-extensions">FUTURE EXTENSIONS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../IndexInvalidation.html">Index Invalidation Rules in the Swift Standard Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#using-versioned-api">Using Versioned API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#publishing-versioned-api">Publishing Versioned API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#giving-up-flexibility">Giving Up Flexibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#optimization">Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#resilience-domains">Resilience Domains</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#protocol-conformances">Protocol Conformances</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#checking-binary-compatibility">Checking Binary Compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#summary">Summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#glossary">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Literals.html">Literals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LogicalObjects.html">Logical Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Modules.html">High-Level Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Modules.html#import"><code class="docutils literal"><span class="pre">import</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../Modules.html#interoperability-with-objective-c-via-clang">Interoperability with Objective-C via Clang</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Modules.html#glossary">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../MutationModel.html">Immutability and Read-Only Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ObjectInitialization.html">Object Initialization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html">Writing High-Performance Swift Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#enabling-optimizations">Enabling Optimizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#whole-module-optimizations">Whole Module Optimizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#reducing-dynamic-dispatch">Reducing Dynamic Dispatch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#using-container-types-efficiently">Using Container Types Efficiently</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#unchecked-operations">Unchecked operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#generics">Generics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#the-cost-of-large-swift-values">The cost of large swift values</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#unsafe-code">Unsafe code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#protocols">Protocols</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#footnotes">Footnotes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Pattern Matching.html">Pattern Matching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SIL.html">Swift Intermediate Language (SIL)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SequencesAndCollections.html">Sequences And Collections in Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Serialization.html">Swift Binary Serialization Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="../StdlibAPIGuidelines.html">Swift Standard Library API Design Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../StdlibRationales.html">Rationales for the Swift standard library designs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../StoredAndComputedVariables.html">Stored and Computed Variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../StringDesign.html">Swift String Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Testing.html">Testing Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="../TextFormatting.html">Text Formatting in Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="../TransparentAttr.html"><code class="docutils literal"><span class="pre">&#64;_transparent</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../TypeChecker.html">Type Checker Design and Implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contents.html">Contents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../weak.html">Weak References</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">Swift Programming Language documentation</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
    <li>Bridging Swift Arrays to/from Cocoa</li>
    <li class="wy-breadcrumbs-aside">
      
        
          <a href="../_sources/proposals/ArrayBridge.txt" rel="nofollow"> View page source</a>
        
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="bridging-swift-arrays-to-from-cocoa">
<h1>Bridging Swift Arrays to/from Cocoa<a class="headerlink" href="#bridging-swift-arrays-to-from-cocoa" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body">Chris Lattner, Joe Groff, Dave Abrahams</td>
</tr>
<tr class="field-even field"><th class="field-name">Summary:</th><td class="field-body">Unifying a fast C-style array with a Cocoa class cluster
that can represent arbitrarily complex data structures is
challenging.  In a space where no approach satisfies all
desires, we believe we&#8217;ve found a good compromise.</td>
</tr>
</tbody>
</table>
<div class="section" id="basic-requirements">
<h2>Basic Requirements<a class="headerlink" href="#basic-requirements" title="Permalink to this headline">¶</a></h2>
<p>A successfully-bridged array type would be both &#8220;great for Cocoa&#8221; and
&#8220;great for C.&#8221;</p>
<p>Being &#8220;great for Cocoa&#8221; means this must work and be efficient:</p>
<div class="highlight-python"><div class="highlight"><pre>var a = [cocoaObject1, cocoaObject2]
someCocoaObject.takesAnNSArray(a)

func processViews(views: AnyObject[]) { ... }
var b = someNSWindow.views // views is an NSArray
processViews(b)

var c: AnyObject[] = someNSWindow.views
</pre></div>
</div>
<p>Being &#8220;great For C&#8221; means that an array created in Swift must have
C-like performance and be representable as a base pointer and
length, for interaction with C APIs, at zero cost.</p>
</div>
<div class="section" id="proposed-solution">
<h2>Proposed Solution<a class="headerlink" href="#proposed-solution" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal"><span class="pre">Array&lt;T&gt;</span></code>, a.k.a. <code class="docutils literal"><span class="pre">T[]</span></code>, is notionally an <code class="docutils literal"><span class="pre">enum</span></code> with two
cases; call them <code class="docutils literal"><span class="pre">Native</span></code> and <code class="docutils literal"><span class="pre">Cocoa</span></code>.  The <code class="docutils literal"><span class="pre">Native</span></code> case stores
a <code class="docutils literal"><span class="pre">ContiguousArray</span></code>, which has a known, contiguous buffer
representation and O(1) access to the address of any element.  The
<code class="docutils literal"><span class="pre">Cocoa</span></code> case stores an <code class="docutils literal"><span class="pre">NSArray</span></code>.</p>
<p><code class="docutils literal"><span class="pre">NSArray</span></code> bridges bidirectionally in O(1) <a class="footnote-reference" href="#copy" id="id1">[1]</a> to
<code class="docutils literal"><span class="pre">AnyObject[]</span></code>.  It also implicitly converts in to <code class="docutils literal"><span class="pre">T[]</span></code>, where T
is any class declared to be <code class="docutils literal"><span class="pre">&#64;objc</span></code>.  No dynamic check of element
types is ever performed for arrays of <code class="docutils literal"><span class="pre">&#64;objc</span></code> elements; instead we
simply let <code class="docutils literal"><span class="pre">objc_msgSend</span></code> fail when <code class="docutils literal"><span class="pre">T</span></code>&#8216;s API turns out to be
unsupported by the object.  Any <code class="docutils literal"><span class="pre">T[]</span></code>, where T is an <code class="docutils literal"><span class="pre">&#64;objc</span></code>
class, converts implicitly to NSArray.</p>
</div>
<div class="section" id="optimization">
<h2>Optimization<a class="headerlink" href="#optimization" title="Permalink to this headline">¶</a></h2>
<p>Any type with more than one representation naturally penalizes
fine-grained operations such as indexing, because the cost of
repeatedly branching to handle each representation becomes
significant.  For example, the design above would pose significant performance
problems for arrays of integers, because every subscript operation would have to
check to see if the representation is an NSArray, realize it is not, then do the
constant time index into the native representation.  Beyond requiring an extra
check, this check would disable optimizations that can provide a significant
performance win (like auto-vectorization).</p>
<p>However, the inherent limitations of <code class="docutils literal"><span class="pre">NSArray</span></code> mean that we can
often know at compile-time which representation is in play.  So the
plan is to teach the compiler to optimize for the <code class="docutils literal"><span class="pre">Native</span></code> case
unless the element type is an <code class="docutils literal"><span class="pre">&#64;objc</span></code> class or AnyObject.  When <code class="docutils literal"><span class="pre">T</span></code> is
statically known not to be an <code class="docutils literal"><span class="pre">&#64;objc</span></code> class or AnyObject, it will be
possible to eliminate the <code class="docutils literal"><span class="pre">Cocoa</span></code> case entirely.  When generating code for
generic algorithms, we can favor the <code class="docutils literal"><span class="pre">Native</span></code> case, perhaps going so
far as to specialize for the case where all parameters are non-<code class="docutils literal"><span class="pre">&#64;objc</span></code>
classes.  This will give us C-like performance for array operations on <code class="docutils literal"><span class="pre">Int</span></code>,
<code class="docutils literal"><span class="pre">Float</span></code>, and other <code class="docutils literal"><span class="pre">struct</span></code> types <a class="footnote-reference" href="#boundscheck" id="id2">[2]</a>.</p>
<p>To implement this, we&#8217;ll need to implement a new generic builtin,
something along the lines of &#8220;<code class="docutils literal"><span class="pre">Builtin.couldBeObjCType&lt;T&gt;()</span></code>&#8221;, which
returns a <code class="docutils literal"><span class="pre">Builtin.Int1</span></code> value.  SILCombine and IRGen should eagerly
fold this to &#8220;0&#8221; iff <code class="docutils literal"><span class="pre">T</span></code> is known to be a protocol other than
AnyObject, if it is known to be a non-<code class="docutils literal"><span class="pre">&#64;objc</span></code> class, or if it is
known to be any struct, enum or tuple.  Otherwise, the builtin is left
alone, and if it reaches IRGen, IRGen should conservatively fold it to
&#8220;1&#8221;.  In the common case where <code class="docutils literal"><span class="pre">Array&lt;T&gt;</span></code> is inlined and
specialized, this will allow us to eliminate all of the overhead in
the important C cases.</p>
</div>
<div class="section" id="opportunity-feature">
<h2>Opportunity Feature<a class="headerlink" href="#opportunity-feature" title="Permalink to this headline">¶</a></h2>
<p>For hardcore systems programming, we can expose <code class="docutils literal"><span class="pre">ContiguousArray</span></code> as
a user-consumable type.  That will allow programmers who don&#8217;t care
about Cocoa interoperability to avoid ever paying the cost of
branching on representation.  This type would not bridge transparently to Array,
but could be useful if you need an array of Objective-C type, don&#8217;t care about
NSArray compatibility, and care deeply about performance.</p>
</div>
<div class="section" id="other-approaches-considered">
<h2>Other Approaches Considered<a class="headerlink" href="#other-approaches-considered" title="Permalink to this headline">¶</a></h2>
<p>We considered an approach where conversions between <code class="docutils literal"><span class="pre">NSArray</span></code> and
native Swift <code class="docutils literal"><span class="pre">Array</span></code> were entirely manual and quickly ruled it out
as failing to satisfy the requirements.</p>
<p>We considered another promising proposal that would make <code class="docutils literal"><span class="pre">T[]</span></code> a
(hand-rolled) existential wrapper type.  Among other things, we felt
this approach would expose multiple array types too prominently and
would tend to &#8220;bless&#8221; an inappropriately-specific protocol as the
generic collection interface (for example, a generic collection should
not be indexable with <code class="docutils literal"><span class="pre">Int</span></code>).</p>
<p>We also considered several variants of the approach we&#8217;ve proposed
here, tuning the criteria by which we&#8217;d decide to optimize for a
<code class="docutils literal"><span class="pre">Native</span></code> representation.</p>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="copy" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Value semantics dictates that when bridging an <code class="docutils literal"><span class="pre">NSArray</span></code>
into Swift, we invoke its <code class="docutils literal"><span class="pre">copy</span></code> method.  Calling <code class="docutils literal"><span class="pre">copy</span></code> on an
immutable <code class="docutils literal"><span class="pre">NSArray</span></code> can be almost cost-free, but a mutable
<code class="docutils literal"><span class="pre">NSArray</span></code> <em>will</em> be physically copied.  We accept that copy as
the cost of doing business.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="boundscheck" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Of course, by default, array bounds checking is enabled.
C does not include array bounds checks, so to get true C performance in all
cases, these will have to be disabled.</td></tr>
</tbody>
</table>
</div>
</div>


           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright apple.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.1.9',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>