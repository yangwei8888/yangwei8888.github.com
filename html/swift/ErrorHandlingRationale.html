

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Error Handling Rationale and Proposal &mdash; Swift Programming Language documentation 0.1.9 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Swift Programming Language documentation 0.1.9 documentation" href="index.html"/>
        <link rel="up" title="Contents" href="contents.html"/>
        <link rel="next" title="Generics in Swift" href="Generics.html"/>
        <link rel="prev" title="Error Handling in Swift 2.0" href="ErrorHandling.html"/>
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>


  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Swift Programming Language documentation
          

          
          </a>

          
            
            
              <div class="version">
                0.1.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">swift docs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="ABI.html">The Swift ABI</a></li>
<li class="toctree-l1"><a class="reference internal" href="ARCOptimization.html">ARC Optimization for Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="AccessControl.html">Access Control</a></li>
<li class="toctree-l1"><a class="reference internal" href="AccessControlInStdlib.html">Scope and introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="AccessControlInStdlib.html#public"><cite>public</cite></a></li>
<li class="toctree-l1"><a class="reference internal" href="AccessControlInStdlib.html#internal"><cite>internal</cite></a></li>
<li class="toctree-l1"><a class="reference internal" href="AccessControlInStdlib.html#private"><cite>private</cite></a></li>
<li class="toctree-l1"><a class="reference internal" href="AccessControlInStdlib.html#leading-underscore-rule">Leading Underscore Rule</a></li>
<li class="toctree-l1"><a class="reference internal" href="Arrays.html">The Swift Array Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="CallingConvention.html">The Swift Calling Convention</a></li>
<li class="toctree-l1"><a class="reference internal" href="DebuggingTheCompiler.html">Debugging the Swift Compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="Dependency Analysis.html">Dependency Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="DriverInternals.html">Driver Design &amp; Internals</a></li>
<li class="toctree-l1"><a class="reference internal" href="DriverParseableOutput.html">Parseable Driver Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="ErrorHandling.html">Error Handling in Swift 2.0</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Error Handling Rationale and Proposal</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#fundamentals">Fundamentals</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#kinds-of-propagation">Kinds of propagation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kinds-of-error">Kinds of error</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#simple-domain-errors">Simple domain errors</a></li>
<li class="toctree-l4"><a class="reference internal" href="#recoverable-errors">Recoverable errors</a></li>
<li class="toctree-l4"><a class="reference internal" href="#universal-errors">Universal errors</a></li>
<li class="toctree-l4"><a class="reference internal" href="#logic-failures">Logic failures</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#analysis">Analysis</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#propagation-methods">Propagation methods</a></li>
<li class="toctree-l3"><a class="reference internal" href="#marked-propagation">Marked propagation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#typed-propagation">Typed propagation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#typed-manual-propagation">Typed manual propagation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#typed-automatic-propagation">Typed automatic propagation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tradeoffs-of-typed-propagation">Tradeoffs of typed propagation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#error-types">Error Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#implementation-design">Implementation design</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#implicit-manual-propagation">Implicit manual propagation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#setjmp-longmp"><code class="docutils literal"><span class="pre">setjmp</span></code> / <code class="docutils literal"><span class="pre">longmp</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#table-based-unwinding">Table-based unwinding</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#clean-up-actions">Clean-up actions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#finally"><code class="docutils literal"><span class="pre">finally</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#defer"><code class="docutils literal"><span class="pre">defer</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#destructors">Destructors</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#survey">Survey</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#c">C</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id1">C++</a></li>
<li class="toctree-l3"><a class="reference internal" href="#objective-c">Objective C</a></li>
<li class="toctree-l3"><a class="reference internal" href="#java">Java</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">C#</a></li>
<li class="toctree-l3"><a class="reference internal" href="#haskell">Haskell</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rust">Rust</a></li>
<li class="toctree-l3"><a class="reference internal" href="#go">Go</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scripting-languages">Scripting languages</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#proposal">Proposal</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#automatic-propagation">Automatic propagation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">Typed propagation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#higher-order-polymorphism">Higher-order polymorphism</a></li>
<li class="toctree-l4"><a class="reference internal" href="#generic-polymorphism">Generic polymorphism</a></li>
<li class="toctree-l4"><a class="reference internal" href="#error-type">Error type</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id4">Marked propagation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#asserting-markers">Asserting markers</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#other-syntax">Other syntax</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id5">Clean-up actions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using"><code class="docutils literal"><span class="pre">using</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#c-and-objective-c-interoperation">C and Objective-C Interoperation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id6">Error types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#objective-c-method-error-patterns">Objective-C method error patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="#corefoundation-functions">CoreFoundation functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#other-c-apis">Other C APIs</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id7">Implementation design</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Failable Initializers.html">Failable initializers</a></li>
<li class="toctree-l1"><a class="reference internal" href="Generics.html">Generics in Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="GitWorkflows.html">Git Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="GitWorkflows.html#svn-git-workflows">SVN -&gt; GIT Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="HighLevelSILOptimizations.html">High-Level Optimizations in SIL</a></li>
<li class="toctree-l1"><a class="reference internal" href="Import.html">IMPORT SYNTAX</a></li>
<li class="toctree-l1"><a class="reference internal" href="Import.html#resolving-name-clashes">RESOLVING NAME CLASHES</a></li>
<li class="toctree-l1"><a class="reference internal" href="Import.html#future-extensions">FUTURE EXTENSIONS</a></li>
<li class="toctree-l1"><a class="reference internal" href="IndexInvalidation.html">Index Invalidation Rules in the Swift Standard Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#using-versioned-api">Using Versioned API</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#publishing-versioned-api">Publishing Versioned API</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#giving-up-flexibility">Giving Up Flexibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#optimization">Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#resilience-domains">Resilience Domains</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#protocol-conformances">Protocol Conformances</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#checking-binary-compatibility">Checking Binary Compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#summary">Summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#glossary">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="Literals.html">Literals</a></li>
<li class="toctree-l1"><a class="reference internal" href="LogicalObjects.html">Logical Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="Modules.html">High-Level Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="Modules.html#import"><code class="docutils literal"><span class="pre">import</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="Modules.html#interoperability-with-objective-c-via-clang">Interoperability with Objective-C via Clang</a></li>
<li class="toctree-l1"><a class="reference internal" href="Modules.html#glossary">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="MutationModel.html">Immutability and Read-Only Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="ObjectInitialization.html">Object Initialization</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html">Writing High-Performance Swift Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#enabling-optimizations">Enabling Optimizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#whole-module-optimizations">Whole Module Optimizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#reducing-dynamic-dispatch">Reducing Dynamic Dispatch</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#using-container-types-efficiently">Using Container Types Efficiently</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#unchecked-operations">Unchecked operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#generics">Generics</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#the-cost-of-large-swift-values">The cost of large swift values</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#unsafe-code">Unsafe code</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#protocols">Protocols</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#footnotes">Footnotes</a></li>
<li class="toctree-l1"><a class="reference internal" href="Pattern Matching.html">Pattern Matching</a></li>
<li class="toctree-l1"><a class="reference internal" href="SIL.html">Swift Intermediate Language (SIL)</a></li>
<li class="toctree-l1"><a class="reference internal" href="SequencesAndCollections.html">Sequences And Collections in Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="Serialization.html">Swift Binary Serialization Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="StdlibAPIGuidelines.html">Swift Standard Library API Design Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="StdlibRationales.html">Rationales for the Swift standard library designs</a></li>
<li class="toctree-l1"><a class="reference internal" href="StoredAndComputedVariables.html">Stored and Computed Variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="StringDesign.html">Swift String Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="Testing.html">Testing Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="TextFormatting.html">Text Formatting in Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="TransparentAttr.html"><code class="docutils literal"><span class="pre">&#64;_transparent</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="TypeChecker.html">Type Checker Design and Implementation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="contents.html">Contents</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="IndexInvalidation.html">Index Invalidation Rules in the Swift Standard Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="AccessControl.html">Access Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="DriverInternals.html">Driver Design &amp; Internals</a></li>
<li class="toctree-l2"><a class="reference internal" href="DriverParseableOutput.html">Parseable Driver Output</a></li>
<li class="toctree-l2"><a class="reference internal" href="ErrorHandling.html">Error Handling in Swift 2.0</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Error Handling Rationale and Proposal</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#fundamentals">Fundamentals</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#kinds-of-propagation">Kinds of propagation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kinds-of-error">Kinds of error</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#analysis">Analysis</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#propagation-methods">Propagation methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="#marked-propagation">Marked propagation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#typed-propagation">Typed propagation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#error-types">Error Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implementation-design">Implementation design</a></li>
<li class="toctree-l4"><a class="reference internal" href="#clean-up-actions">Clean-up actions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#survey">Survey</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#c">C</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id1">C++</a></li>
<li class="toctree-l4"><a class="reference internal" href="#objective-c">Objective C</a></li>
<li class="toctree-l4"><a class="reference internal" href="#java">Java</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id2">C#</a></li>
<li class="toctree-l4"><a class="reference internal" href="#haskell">Haskell</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rust">Rust</a></li>
<li class="toctree-l4"><a class="reference internal" href="#go">Go</a></li>
<li class="toctree-l4"><a class="reference internal" href="#scripting-languages">Scripting languages</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#proposal">Proposal</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#automatic-propagation">Automatic propagation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id3">Typed propagation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id4">Marked propagation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#other-syntax">Other syntax</a></li>
<li class="toctree-l4"><a class="reference internal" href="#c-and-objective-c-interoperation">C and Objective-C Interoperation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id7">Implementation design</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Generics.html">Generics in Swift</a></li>
<li class="toctree-l2"><a class="reference internal" href="LogicalObjects.html">Logical Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="ObjectInitialization.html">Object Initialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="Pattern Matching.html">Pattern Matching</a></li>
<li class="toctree-l2"><a class="reference internal" href="StoredAndComputedVariables.html">Stored and Computed Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="SIL.html">Swift Intermediate Language (SIL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="TypeChecker.html">Type Checker Design and Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="DebuggingTheCompiler.html">Debugging the Swift Compiler</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="weak.html">Weak References</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Swift Programming Language documentation</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
        <li><a href="contents.html">Contents</a> &raquo;</li>
      
    <li>Error Handling Rationale and Proposal</li>
    <li class="wy-breadcrumbs-aside">
      
        
          <a href="_sources/ErrorHandlingRationale.txt" rel="nofollow"> View page source</a>
        
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="error-handling-rationale-and-proposal">
<h1>Error Handling Rationale and Proposal<a class="headerlink" href="#error-handling-rationale-and-proposal" title="Permalink to this headline">¶</a></h1>
<p>This paper surveys the error-handling world, analyzes various ideas
which have been proposed or are in practice in other languages, and
ultimately proposes an error-handling scheme for Swift together
with import rules for our APIs.</p>
<div class="section" id="fundamentals">
<h2>Fundamentals<a class="headerlink" href="#fundamentals" title="Permalink to this headline">¶</a></h2>
<p>I need to establish some terminology first.</p>
<div class="section" id="kinds-of-propagation">
<h3>Kinds of propagation<a class="headerlink" href="#kinds-of-propagation" title="Permalink to this headline">¶</a></h3>
<p>I&#8217;ve heard people talk about <strong>explicit vs. implicit propagation</strong>.
I&#8217;m not going to use those terms, because they&#8217;re not helpful: there
are at least three different things about error-handling that can be
more or less explicit, and some of the other dimensions are equally
important.</p>
<p>The most important dimensions of variation are:</p>
<ul class="simple">
<li>Whether the language allows functions to be designated as producing
errors or not; such a language has <strong>typed propagation</strong>.</li>
<li>Whether, in a language with typed propagation, the default rule is
that a function can produce an error or that it can&#8217;t; this
is the language&#8217;s <strong>default propagation rule</strong>.</li>
<li>Whether, in a language with typed propagation, the language enforces
this statically, so that a function which cannot produce an error
cannot call a function which can without handling it; such a
language has <strong>statically-enforced typed propagation</strong>.  (A language
could instead enforce this dynamically by automatically inserting
code to assert if an error propagates out.  C++ does this.)</li>
<li>Whether the language requires all potential error sites to be
identifiable as potential error sites; such a language has <strong>marked
propagation</strong>.</li>
<li>Whether propagation is done explicitly with the normal data-flow and
control-flow tools of the language; such a language has <strong>manual
propagation</strong>.  In contrast, a language where control implicitly
jumps from the original error site to the proper handler has
<strong>automatic propagation</strong>.</li>
</ul>
</div>
<div class="section" id="kinds-of-error">
<h3>Kinds of error<a class="headerlink" href="#kinds-of-error" title="Permalink to this headline">¶</a></h3>
<p>What is an error?  There may be many different possible error
conditions in a program, but they can be categorized into several
kinds based on how programmers should be expected to react to them.
Since the programmer is expected to react differently, and since the
language is the tool of the programmer&#8217;s reaction, it makes sense for
each group to be treated differently in the language.</p>
<p>To be clear, in many cases the kind of error reflects a conscious
decision by the author of the error-producing code, and different
choices might be useful in different contexts.  The example I&#8217;m going
to use of a &#8220;simple domain error&#8221; could easily be instead treated as a
&#8220;recoverable error&#8221; (if the author expected automatic propagation to
be more useful than immediate recovery) or even a &#8220;logic failure&#8221; (if
the author wished to prevent speculative use, e.g. if checking the
precondition was very expensive).</p>
<p>In order of increasing severity and complexity:</p>
<div class="section" id="simple-domain-errors">
<h4>Simple domain errors<a class="headerlink" href="#simple-domain-errors" title="Permalink to this headline">¶</a></h4>
<p>A simple domain error is something like calling <code class="docutils literal"><span class="pre">String.toInt()</span></code> on a
string that isn&#8217;t an integer.  The operation has an obvious
precondition about its arguments, but it&#8217;s useful to be able to pass
other values to test whether they&#8217;re okay.  The client will often
handle the error immediately.</p>
<p>Conditions like this are best modeled with an optional return value.
They don&#8217;t benefit from a more complex error-handling model, and using
one would make common code unnecessarily awkward.  For example,
speculatively trying to parse a <code class="docutils literal"><span class="pre">String</span></code> as an integer in Java
requires catching an exception, which is far more syntactically
heavyweight (and inefficient without optimization).</p>
<p>Because Swift already has good support for optionals, these conditions
do not need to be a focus of this proposal.</p>
</div>
<div class="section" id="recoverable-errors">
<h4>Recoverable errors<a class="headerlink" href="#recoverable-errors" title="Permalink to this headline">¶</a></h4>
<p>Recoverable errors include file-not-found, network timeouts, and
similar conditions.  The operation has a variety of possible error
conditions.  The client should be encouraged to recognize the
possibility of the error condition and consider the right way to
handle it.  Often, this will be by aborting the current operation,
cleaning up after itself if needed, and propagating the error to a
point where it can more sensibly be handled, e.g. by reporting it to
the user.</p>
<p>These are the error conditions that most of our APIs use <code class="docutils literal"><span class="pre">NSError</span></code> and
<code class="docutils literal"><span class="pre">CFError</span></code> for today.  Most libraries have some similar notion.  This
is the focus of this proposal.</p>
</div>
<div class="section" id="universal-errors">
<h4>Universal errors<a class="headerlink" href="#universal-errors" title="Permalink to this headline">¶</a></h4>
<p>The difference between universal errors and ordinary recoverable
errors is less the kind of error condition and more the potential
sources of the error in the language.  An error is universal if it
could arise from such a wealth of different circumstances that it
becomes nearly impracticable for the programmer to directly deal with
all the sources of the error.</p>
<p>Some conditions, if they are to be brought into the scope of
error-handling, can only conceivably be dealt with as universal
errors.  These include:</p>
<ul class="simple">
<li>Asynchronous conditions, like the process receiving a <code class="docutils literal"><span class="pre">SIGINT</span></code>, or
the current thread being cancelled by another thread.  These
conditions could, in principle, be delivered at an arbitrary
instruction boundary, and handling them appropriately requires
extraordinary care from the programmer, the compiler, and the
runtime.</li>
<li>Ubiquitous errors, like running out of memory or overflowing the
stack, that essentially any operation can be assumed to potentially
do.</li>
</ul>
<p>But other kinds of error condition can essentially become universal
errors with the introduction of abstraction.  Reading the size of a
collection, or reading a property of an object, is not an operation
that a programmer would normally expect to produce an error.  However,
if the collection is actually backed by a database, the database query
might fail.  If the user must write code as if any opaque abstraction
might produce an error, they are stuck in the world of universal
errors.</p>
<p>Universal errors mandate certain language approaches.  Typed
propagation of universal errors is impossible, other than special
cases which can guarantee to not produce errors.  Marked propagation
would provoke a user revolt.  Propagation must be automatic, and the
implementation must be &#8220;zero-cost&#8221;, or as near to it as possible,
because checking for an error after every single operation would be
prohibitive.</p>
<p>For these reasons, in our APIs, universal error conditions are usually
implemented using Objective-C exceptions, although not all uses of
Objective-C exceptions fall in this category.</p>
<p>This combination of requirements means that all operations must be
implicitly &#8220;unwindable&#8221; starting from almost any call site it makes.
For the stability of the system, this unwinding process must restore
any invariants that might have been temporarily violated; but the
compiler cannot assist the programmer in this.  The programmer must
consciously recognize that an error is possible while an invariant is
broken, and they must do this proactively &#8212; that, or track it down
when they inevitably forget.  This requires thinking quite rigorously
about one&#8217;s code, both to foresee all the error sites and to recognize
that an important invariant is in flux.</p>
<p>How much of a problem this poses depends quite a lot on the code being
written.  There are some styles of programming that make it pretty
innocuous.  For example, a highly functional program which
conscientiously kept mutation and side-effects to its outermost loops
would naturally have very few points where any invariants were in
flux; propagating an error out of an arbitrary place within an
operation would simply abandon all the work done up to that point.
However, this happy state falls apart quite quickly the more that
mutation and other side-effects come into play.  Complex mutations
cannot be trivially reversed.  Packets cannot be unsent.  And it would
be quite amazing for us to assert that code shouldn&#8217;t be written that
way, understanding nothing else about it.  As long as programmers do
face these issues, the language has some responsibility to help them.</p>
<p>Therefore, in my judgment, promoting the use of universal errors is
highly problematic.  They undermine the easy comprehension of code,
and they undermine the language&#8217;s ability to help the programmer
reason about errors.  This design will instead focus on explicitly
trackable errors of the sort that <code class="docutils literal"><span class="pre">NSError</span></code> is used for today on Apple
platforms.</p>
<p>However, there are some important reasons not to rule out universal
errors completely:</p>
<ul class="simple">
<li>They remain the only viable means of bringing certain error
conditions into the error-handling model, as discussed above.  Of
these, most run into various objections; the most important
remaining use case is &#8220;escaping&#8221;, where an unexpected implementation
of an API that was not designed to throw finds itself needing to.</li>
<li>Objective-C and C++ exceptions are a legitimate interoperation
problem on any conceivable platform Swift targets.  Swift must have
some sort of long-term answer for them.</li>
</ul>
<p>These reasons don&#8217;t override the problems with universal errors.  It
is inherently dangerous to implicitly volunteer functions for
unwinding from an arbitrary point.  We don&#8217;t want to promote this
model.  However, it is certainly possible to write code that handles
universal errors correctly; and pragmatically, unwinding through most
code will generally just work.  Swift could support a secondary,
untyped propagation mechanism using &#8220;zero-cost&#8221; exceptions.  Code can
be written carefully to minimize the extent of implicit unwinding,
e.g. by catching universal errors immediately after calling an
&#8220;escaping&#8221; API and rethrowing them with normal typed propagation.</p>
<p>However, this work is outside of the scope of Swift 2.0.  We can
comfortably make this decision because doing so doesn&#8217;t lock us out of
implementing it in the future:</p>
<ul class="simple">
<li>We do not currently support propagating exceptions through Swift
functions, so changing <code class="docutils literal"><span class="pre">catch</span></code> to catch them as well would not be
a major compatibility break.</li>
<li>With some admitted awkwardness, external exceptions can be reflected
into an <code class="docutils literal"><span class="pre">ErrorType</span></code> - like model automatically by the catch
mechanism.</li>
<li>In the meanwhile, developers who must handle an Objective-C
exception can always do so by writing a stub in Objective-C to
explicitly &#8220;bridge&#8221; the exception into an <code class="docutils literal"><span class="pre">NSError</span></code> out parameter.
This isn&#8217;t ideal, but it&#8217;s acceptable.</li>
</ul>
</div>
<div class="section" id="logic-failures">
<h4>Logic failures<a class="headerlink" href="#logic-failures" title="Permalink to this headline">¶</a></h4>
<p>The final category is logic failures, including out of bounds array
accesses, forced unwrap of <code class="docutils literal"><span class="pre">nil</span></code> optionals, and other kinds of
assertions.  The programmer has made a mistake, and the failure should
be handled by fixing the code, not by attempting to recover
dynamically.</p>
<p>High-reliability systems may need some way to limp on even after an
assertion failure.  Tearing down the process can be viewed as a vector
for a denial-of-service attack.  However, an assertion failure might
indicate that the process has been corrupted and is under attack, and
limping on anyway may open the system up for other, more serious forms
of security breach.</p>
<p>The correct handling of these error conditions is an open question and
is not a focus of this proposal.  Should we decide to make them
recoverable, they will likely follow the same implementation mechanism
as universal errors, if not necessarily the same language rules.</p>
</div>
</div>
</div>
<div class="section" id="analysis">
<h2>Analysis<a class="headerlink" href="#analysis" title="Permalink to this headline">¶</a></h2>
<p>Let&#8217;s take a deeper look into the different dimensions of
error-handling I laid out above.</p>
<div class="section" id="propagation-methods">
<h3>Propagation methods<a class="headerlink" href="#propagation-methods" title="Permalink to this headline">¶</a></h3>
<p>At a language level, there are two basic ways an error can be
propagated from an error site to something handling it.</p>
<p>The first is that it can be done with the normal evaluation, data
flow, and control flow processes of the language; let&#8217;s call this
<strong>manual propagation</strong>.  Here&#8217;s a good example of manual propagation
using special return values in an imperative language, C:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">struct</span> <span class="n">object</span> <span class="o">*</span><span class="nf">read_object</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
  <span class="kt">ssize_t</span> <span class="n">numRead</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">numRead</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here&#8217;s an example of manual propagation of an error value through
out-parameters in another imperative language, Objective-C:</p>
<div class="highlight-objc"><div class="highlight"><pre><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span> <span class="nf">readKeys:</span> <span class="p">(</span><span class="bp">NSArray</span><span class="o">&lt;</span><span class="bp">NSString</span><span class="o">*&gt;**</span><span class="p">)</span> <span class="nv">strings</span> <span class="nf">error:</span> <span class="p">(</span><span class="bp">NSError</span><span class="o">**</span><span class="p">)</span> <span class="nv">err</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="bp">NSString</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">([</span><span class="nb">self</span> <span class="nl">readKey</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">key</span> <span class="nl">error</span><span class="p">:</span> <span class="n">err</span><span class="p">])</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nb">TRUE</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here&#8217;s an example of manual propagation using an ADT in an impure
functional language, SML; it&#8217;s somewhat artificial because the SML
library actually uses exceptions for this:</p>
<div class="highlight-sml"><div class="highlight"><pre><span class="kr">fun</span> <span class="nf">read_next_cmd</span> <span class="p">()</span> <span class="p">=</span>
  <span class="kr">case</span> <span class="n">readline</span><span class="p">(</span><span class="n">stdin</span><span class="p">)</span> <span class="kr">of</span>
    <span class="n">NONE</span> <span class="p">=&gt;</span> <span class="n">NONE</span>
  <span class="n">|</span> <span class="n">SOME</span> <span class="n">line</span> <span class="p">=&gt;</span> <span class="kr">if</span> <span class="p">...</span>
</pre></div>
</div>
<p>All of these excerpts explicitly test for errors using the language&#8217;s
standard tools for data flow and then explicitly bypass the evaluation
of the remainder of the function using the language&#8217;s standard tools
for control flow.</p>
<p>The other basic way to propagate errors is in some hidden, more
intrinsic way not directly reflected in the ordinary control flow
rules; let&#8217;s call this <strong>automatic propagation</strong>.  Here&#8217;s a good
example of automatic propagation using exceptions in an imperative
language, Java:</p>
<div class="highlight-java"><div class="highlight"><pre><span class="n">String</span> <span class="n">next</span> <span class="o">=</span> <span class="n">readline</span><span class="o">();</span>
</pre></div>
</div>
<p>If <code class="docutils literal"><span class="pre">readline</span></code> encounters an error, it throws an exception; the
language then terminates scopes until it dynamically reaches a <code class="docutils literal"><span class="pre">try</span></code>
statement with a matching handler.  Note the lack of any code at all
implying that this might be happening.</p>
<p>The chief disadvantages of manual propagation are that it&#8217;s tedious to
write and requires a lot of repetitive boilerplate.  This might sound
superficial, but these are serious concerns.  Tedium distracts
programmers and makes them careless; careless error-handling code can
be worse than useless.  Repetitive boilerplate makes code less
readable, hurting maintainability; it occupies the programmer&#8217;s time,
creating opportunity costs; it discourages handling errors <em>well</em> by
making it burdensome to handle them <em>at all</em>; and it encourages
shortcuts (such as extensive macro use) which may undermine other
advantages and goals.</p>
<p>The chief disadvantage of automatic propagation is that it obscures
the control flow of the code.  I&#8217;ll talk about this more in the next
section.</p>
<p>Note that automatic propagation needn&#8217;t be intrinsic in a language.
The propagation is automatic if it doesn&#8217;t correspond to visible
constructs in the source.  This effect can be duplicated as a library
with any language facility that allows restructuring of code
(e.g. with macros or other term-rewriting facilities) or overloading
of basic syntax (e.g. Haskell mapping its <code class="docutils literal"><span class="pre">do</span></code> notation onto monads).</p>
<p>Note also that multiple propagation strategies may be &#8220;in play&#8221; for
any particular program.  For example, Java generally uses exceptions
in its standard libraries, but some specific APIs might opt to instead
return <code class="docutils literal"><span class="pre">null</span></code> on error for efficiency reasons.  Objective-C provides a
fairly full-featured exceptions model, but the standard APIs (with a
few important exceptions) reserve them solely for unrecoverable
errors, preferring manual propagation with <code class="docutils literal"><span class="pre">NSError</span></code> out-parameters
instead.  Haskell has a large number of core library functions which
return <code class="docutils literal"><span class="pre">Maybe</span></code> values to indicate success or error, but it also offers
at least two features resembling traditional,
automatically-propagating exceptions (the <code class="docutils literal"><span class="pre">ErrorT</span></code> monad transform and
exceptions in the <code class="docutils literal"><span class="pre">IO</span></code> monad).</p>
<p>So, while I&#8217;m going to talk as if languages implement a single
propagation strategy, it should be understood that reality will always
be more complex.  It is literally impossible to prevent programmers
from using manual propagation if they want to.  Part of the proposal
will discuss using multiple strategies at once.</p>
</div>
<div class="section" id="marked-propagation">
<h3>Marked propagation<a class="headerlink" href="#marked-propagation" title="Permalink to this headline">¶</a></h3>
<p>Closely related to the question of whether propagation is manual or
automatic is whether it is marked or unmarked.  Let&#8217;s say that a
language uses <strong>marked propagation</strong> if there is something <em>at the
call site</em> which indicates that propagation is possible from that
point.</p>
<p>To a certain extent, every language using manual propagation uses
marked propagation, since the manual code to propagate the error
approximately marks the call which generated the error.  However, it
is possible for the propagation logic to get separated from the call.</p>
<p>Marked propagation is at odds with one other major axis of language
design: a language can&#8217;t solely use marked propagation if it ever
performs implicit operations that can produce errors.  For example, a
language that wanted out-of-memory conditions to be recoverable errors
would have to consider everything that could allocate memory to a
source of propagation; in a high-level language, that would include a
large number of implicit operations.  Such a language could not claim
to use marked propagation.</p>
<p>The reason this all matters is because unmarked propagation is a
pretty nasty thing to end up with; it makes it impossible to directly
see what operations can produce errors, and therefore to directly
understand the control flow of a function.  This leaves you with two
options as a programmer:</p>
<ul class="simple">
<li>You can carefully consider the actual dynamic behavior of every
function called by your function.</li>
<li>You can carefully arrange your function so that there are no
critical sections where an universal error can leave things in an
unwanted state.</li>
</ul>
<p>There are techniques for making the second more palatable.  Chiefly,
they involve never writing code that relies on normal control flow to
maintain invariants and clean up after an operation; for example,
always using constructors and destructors in C++ to manage resources.
This is compulsory in C++ with exceptions enabled because of the
possibility of implicit code that can throw, but it could
theoretically be used in other languages.  However, it still requires
a fairly careful and rigorous style of programming.</p>
<p>It is possible to imagine a marked form of automatic propagation,
where the propagation itself is implicit except that (local)
origination points have to be explicitly marked.  This is part of our
proposal, and I&#8217;ll discuss it below.</p>
</div>
<div class="section" id="typed-propagation">
<h3>Typed propagation<a class="headerlink" href="#typed-propagation" title="Permalink to this headline">¶</a></h3>
<p>The next major question is whether error propagation is explicitly
tracked and limited by the language.  That is, is there something
explicitly <em>in the declaration of a function</em> that tells the
programmer whether it can produce errors?  Let&#8217;s call this <strong>typed
propagation</strong>.</p>
<div class="section" id="typed-manual-propagation">
<h4>Typed manual propagation<a class="headerlink" href="#typed-manual-propagation" title="Permalink to this headline">¶</a></h4>
<p>Whether propagation is typed is somewhat orthogonal to whether it&#8217;s
manual or marked, but there are some common patterns.  The most
dominant forms of manual propagation are all typed, since they pass
the failure out of the callee, either as a direct result or in an
out-parameter.</p>
<p>Here&#8217;s another example of an out-parameter:</p>
<div class="highlight-objc"><div class="highlight"><pre><span class="p">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">initWithContentsOfURL:</span><span class="p">(</span><span class="bp">NSURL</span> <span class="o">*</span><span class="p">)</span><span class="nv">url</span> <span class="nf">encoding:</span><span class="p">(</span><span class="n">NSStringEncoding</span><span class="p">)</span><span class="nv">enc</span> <span class="nf">error:</span><span class="p">(</span><span class="bp">NSError</span> <span class="o">**</span><span class="p">)</span><span class="nv">error</span><span class="p">;</span>
</pre></div>
</div>
<p>Out-parameters have some nice advantages.  First, they&#8217;re a reliable
source of marking; even if the actual propagation gets separated from
the call, you can always detect a call that can generate errors as
long as its out-parameter has a recognizable name.  Second, some of
the boilerplate can be shared, because you can use the same variable
as an out-parameter multiple times; unfortunately, you can&#8217;t use this
to &#8220;cheat&#8221; and only check for an error once unless you have some
conventional guarantee that later calls won&#8217;t spuriously overwrite the
variable.</p>
<p>A common alternative in functional languages is to return an <code class="docutils literal"><span class="pre">Either</span></code>
type:</p>
<div class="highlight-python"><div class="highlight"><pre>trait Writer {
  fn write_line(&amp;mut self, s: &amp;str) -&gt; Result&lt;(), IoError&gt;;
}
</pre></div>
</div>
<p>This forces the caller to deal with the error if they want to use the
result.  This works well unless the call does not really have a
meaningful result (as <code class="docutils literal"><span class="pre">write_line</span></code> does not); then it depends on
whether language makes it easy to accidentally ignore results.  It
also tends to create a lot of awkward nesting:</p>
<div class="highlight-python"><div class="highlight"><pre>fn parse_two_ints_and_add_them() {
  match parse_int() {
    Err e =&gt; Err e
    Ok x =&gt; match parse_int() {
      Err e =&gt; Err e
      Ok y =&gt; Ok (x + y)
    }
  }
}
</pre></div>
</div>
<p>Here, another level of nesting is required for every sequential
computation that can fail.  Overloaded evaluation syntax like
Haskell&#8217;s <code class="docutils literal"><span class="pre">do</span></code> notation would help with both of these problems, but
only by switching to a kind of automatic propagation.</p>
<p>Manual propagation can be untyped if it occurs through a side channel.
For example, consider an object which set a flag on itself when it
encountered an error instead of directly returning it; or consider a
variant of POSIX which expected you to separately check <code class="docutils literal"><span class="pre">errno</span></code> to see
if a particular system call failed.</p>
</div>
<div class="section" id="typed-automatic-propagation">
<h4>Typed automatic propagation<a class="headerlink" href="#typed-automatic-propagation" title="Permalink to this headline">¶</a></h4>
<p>Languages with typed automatic propagation vary along several
dimensions.</p>
<div class="section" id="the-default-typing-rule">
<h5>The default typing rule<a class="headerlink" href="#the-default-typing-rule" title="Permalink to this headline">¶</a></h5>
<p>The most important question is whether you opt in to producing errors
or opt out of them.  That is, is a function with no specific
annotation able to produce errors or not?</p>
<p>The normal resilience guideline is that you want the lazier option to
preserve more flexibility for the implementation.  A function that can
produce errors is definitely more flexible, since it can do more
things.  Contrariwise, changing a function that doesn&#8217;t produce errors
into a function that does clearly changes its contract in ways that
callers need to respond to.  Unfortunately, this has some unpleasant
consequences:</p>
<ul class="simple">
<li>Marked propagation would become very burdensome.  Every call would
involve an annotation, either on the function (to say it cannot
generate errors) or on the call site (to mark propagation).  Users
would likely rebel against this much bookkeeping.</li>
<li>Most functions cannot generate recoverable errors in the way I&#8217;ve
defined that.  That is, ignoring sources of universal errors, most
functions can be reasonably expected to not be able to produce
errors.  But if that&#8217;s not the default state, that means that most
functions would need annotations; again, that&#8217;s a lot of tedious
bookkeeping.  It&#8217;s also a lot of clutter in the API.</li>
<li>Suppose that you notice that a function incorrectly lacks an
annotation. You go to fix it, but you can&#8217;t without annotating all
of the functions it calls, ad infinitum; like <code class="docutils literal"><span class="pre">const</span></code> correctness in
C++, the net effect is to punish conscientious users for trying to
improve their code.</li>
<li>A model which pretends that every function is a source of errors is
likely to be overwhelming for humans.  Programmers ought to think
rigorously about their code, but expecting them to also make
rigorous decisions about all the code their code touches is probably
too much.  Worse, without marked propagation, the compiler can&#8217;t
really help the programmer concentrate on the known-possible sources
of error.</li>
<li>The compiler&#8217;s analysis for code generation has to assume that all
sorts of things can produce errors when they really can&#8217;t.  This
creates a lot of implicit propagation paths that are actually 100%
dead, which imposes a serious code-size penalty.</li>
</ul>
<p>The alternative is to say that, by default, functions are not being
able to generate errors.  This agrees with what I&#8217;m assuming is the
most common case.  In terms of resilience, it means expecting users to
think more carefully about which functions can generate errors before
publishing an API; but this is similar to how Swift already asks them
to think carefully about types.  Also, they&#8217;ll have at least added the
right set of annotations for their initial implementation.  So I
believe this is a reasonable alternative.</p>
</div>
<div class="section" id="enforcement">
<h5>Enforcement<a class="headerlink" href="#enforcement" title="Permalink to this headline">¶</a></h5>
<p>The next question is how to enforce the typing rules that prohibit
automatic propagation.  Should it be done statically or dynamically?
That is, if a function claims to not generate errors, and it calls a
function that generates errors without handling the error, should that
be a compiler error or a runtime assertion?</p>
<p>The only real benefit of dynamic enforcement is that it makes it
easier to use a function that&#8217;s incorrectly marked as being able to
produce errors.  That&#8217;s a real problem if all functions are assumed to
produce errors by default, because the mistake could just be an error
of omission.  If, however, functions are assumed to not produce
errors, then someone must have taken deliberate action that introduced
the mistake.  I feel like the vastly improved static type-checking is
worth some annoyance in this case.</p>
<p>Meanwhile, dynamic enforcement undermines most of the benefits of
typed propagation so completely that it&#8217;s hardly worth considering.
The only benefit that really remains is that the annotation serves as
meaningful documentation.  So for the rest of this paper, assume that
typed propagation is statically enforced unless otherwise indicated.</p>
</div>
<div class="section" id="specificity">
<h5>Specificity<a class="headerlink" href="#specificity" title="Permalink to this headline">¶</a></h5>
<p>The last question is how specific the typing should be: should a
function be able to state the specific classes of errors it produces,
or should the annotation be merely boolean?</p>
<p>Experience with Java suggests that getting over-specific with
exception types doesn&#8217;t really work out for the best.  It&#8217;s useful to
be able to recognize specific classes of error, but libraries
generally want to reserve flexibility about the exact kind of error
they produce, and so many errors just end up falling into broad
buckets.  Different libraries end up with their own library-specific
general error classes, and exceptions list end up just restating the
library&#8217;s own dependencies or wrapping the underlying errors in ways
that loses critical information.</p>
</div>
</div>
<div class="section" id="tradeoffs-of-typed-propagation">
<h4>Tradeoffs of typed propagation<a class="headerlink" href="#tradeoffs-of-typed-propagation" title="Permalink to this headline">¶</a></h4>
<p>Typed propagation has a number of advantages and disadvantages, mostly
independent of whether the propagation is automatic.</p>
<p>The chief advantage is that it is safer.  It forces programmers to do
<em>something</em> to handle or propagate errors.  That comes with some
downsides, which I&#8217;ll talk about, but I see this as a fairly core
static safety guarantee.  This is especially important in an
environment where shuttling operations between threads is common,
since it calls out the common situation where an error needs to
propagate back to the originating thread somehow.</p>
<p>Even if we&#8217;re settled on using typed propagation, we should be aware
of the disadvantages and investigate ways to ameliorate them:</p>
<ul class="simple">
<li>Any sort of polymorphism gets more complicated, especially
higher-order functions.  Functions which cannot generate errors are
in principle subtypes of functions which can.  But:<ul>
<li>Composability suffers.  A higher-order function must decide
whether its function argument is allowed to generate errors.  If
not, the function may be significantly limiting its usability, or
at least making itself much more difficult to use with
error-generating functions.  If so, passing a function that does
not may require a conversion (an awkward explicit one if using
manual propagation), and the result of the call will likely claim
to be able to generate errors when, in fact, it cannot.  This can
be solved with overloads, but that&#8217;s a lot of boilerplate and
redundancy, especially for calls that take multiple functions
(like the function composition operator).</li>
<li>If an implicit conversion is allowed, it may need to introduce
thunks.  In some cases, these thunks would be inlineable &#8212;
except that, actually, it is quite useful for code to be able to
reverse this conversion and dynamically detect functions that
cannot actually generate errors.  For example, an algorithm might
be able to avoid some unnecessary bookkeeping if it knows that its
function argument never fails.  This poses some representation
challenges.</li>
</ul>
</li>
<li>It tends to promote decentralized error handling instead of letting
errors propagate to a level that actually knows how to handle them.<ul>
<li>Some programmers will always be tempted to incorrectly pepper
their code with handlers that just swallow errors instead of
correctly propagating them to the right place.  This is often
worse than useless; it would often be better if the error just
propagated silently, because the result can be a system in an
inconsistent state with no record of why.  Good language and
library facilities for propagating errors can help avoid this,
especially when moving actions between threads.</li>
<li>There are many situations where errors are not actually possible
because the programmer has carefully restricted the input.  For
example, matching :code:<code class="docutils literal"><span class="pre">/[0-9]{4}/</span></code> and then parsing the result
as an integer.  It needs to be convenient to do this in a context
that cannot actually propagate errors, but the facility to do this
needs to be carefully designed to discourage use for swallowing
real errors.  It might be sufficient if the facility does not
actually swallow the error, but instead causes a real failure.</li>
<li>It is possible that the ease of higher-order programming in Swift
might ameliorate many of these problems by letting users writing
error-handling combinators.  That is, in situations where a lazy
Java programmer would find themselves writing a <code class="docutils literal"><span class="pre">try/catch</span></code> to
swallow an exception, Swift would allow them to do something more
correct with equal convenience.</li>
</ul>
</li>
</ul>
<p>One other minor advantage of marked, statically-enforced typed
propagation: it&#8217;s a boon for certain kinds of refactoring.
Specifically, when a refactor makes an operation error-producing when
it wasn&#8217;t before, the absence of any those properties makes the
refactor more treacherous and increases the odds of accidentally
introducing a bug.  If propagation is untyped, or the typing isn&#8217;t
statically enforced, the compiler isn&#8217;t going to help you at all to
find call sites which need to have error-checking code.  Even with
static typed propagation, if the propagation isn&#8217;t marked specifically
on the call site, the compiler won&#8217;t warn you about calls made from
contexts that can handle or implicitly propagate the error.  But if
all these things are true, the compiler will force you to look at all
the existing call sites individually.</p>
</div>
</div>
<div class="section" id="error-types">
<h3>Error Types<a class="headerlink" href="#error-types" title="Permalink to this headline">¶</a></h3>
<p>There are many kinds of error.  It&#8217;s important to be able to recognize
and respond to specific error causes programmatically.  Swift should
support easy pattern-matching for this.</p>
<p>But I&#8217;ve never really seen a point to coarser-grained categorization
than that; for example, I&#8217;m not sure how you&#8217;re supposed to react to
an arbitrary, unknown IO error.  And if there are useful error
categories, they can probably be expressed with predicates instead of
public subclasses.  I think we start with a uni-type here and then
challenge people to come up with reasons why they need anything more.</p>
</div>
<div class="section" id="implementation-design">
<h3>Implementation design<a class="headerlink" href="#implementation-design" title="Permalink to this headline">¶</a></h3>
<p>There are several different common strategies for implementing
automatic error propagation.  (Manual propagation doesn&#8217;t need special
attention in the implementation design.)</p>
<p>The implementation has two basic tasks common to most languages:</p>
<ul class="simple">
<li>Transferring control through scopes and functions to the appropriate
handler for the error.</li>
<li>Performing various semantic &#8220;clean up&#8221; tasks for the scopes that
were abruptly terminated:<ul>
<li>tearing down local variables, like C++ variables with
destructors or strong/weak references in ARC-like languages;</li>
<li>releasing heap-allocated local variables, like captured variables
in Swift or <code class="docutils literal"><span class="pre">__block</span></code> variables in ObjC;</li>
<li>executing scope-specific termination code, like C#&#8217;s <code class="docutils literal"><span class="pre">using</span></code> or
Java/ObjC&#8217;s <code class="docutils literal"><span class="pre">synchronized</span></code> statements; and</li>
<li>executing ad hoc cleanup blocks, like <code class="docutils literal"><span class="pre">finally</span></code> blocks in Java
or <code class="docutils literal"><span class="pre">defer</span></code> actions in Swift.</li>
</ul>
</li>
</ul>
<p>Any particular call frame on the stack may have clean-ups or potential
handlers or both; call these <strong>interesting frames</strong>.</p>
<div class="section" id="implicit-manual-propagation">
<h4>Implicit manual propagation<a class="headerlink" href="#implicit-manual-propagation" title="Permalink to this headline">¶</a></h4>
<p>One strategy is to implicitly produce code to check for errors and
propagate them up the stack, imitating the code that the programmer
would have written under manual propagation.  For example, a function
call could return an optional error in a special result register; the
caller would check this register and, if appropriate, unwind the stack
and return the same value.</p>
<p>Since propagation and unwinding are explicit in the generated code,
this strategy hurts runtime performance along the non-error path more
than the alternatives, and more code is required to do the explicitly
unwinding.  Branches involved in testing for errors are usually very
easy to predict, so in hot code the direct performance impact is quite
small, and the total impact is dominated by decreased code locality.
Code can&#8217;t always be hot, however.</p>
<p>These penalties are suffered even by uninteresting frames unless they
appear in tail position.  (An actual tail call isn&#8217;t necessary; there
just can&#8217;t be anything that error propagation would skip.)  And
functions must do some added setup work before returning.</p>
<p>The upside is that the error path suffers no significant penalties
beyond the code-size impact.  The code-size impact can be significant,
however: there is sometimes quite a lot of duplicate code needed for
propagation along the error path.</p>
<p>This approach is therefore relatively even-handed about the error
vs. the non-error path, although it requires some care in order to
minimize code-size penalties for parallel error paths.</p>
</div>
<div class="section" id="setjmp-longmp">
<h4><code class="docutils literal"><span class="pre">setjmp</span></code> / <code class="docutils literal"><span class="pre">longmp</span></code><a class="headerlink" href="#setjmp-longmp" title="Permalink to this headline">¶</a></h4>
<p>Another strategy to is to dynamically maintain a thread-local stack of
interesting frames.  A function with an interesting frame must save
information about its context in a buffer, like <code class="docutils literal"><span class="pre">setjmp</span></code> would, and
then register that buffer with the runtime.  If the scope returns
normally, the buffer is accordingly unregistered.  Starting
propagation involves restoring the context for the top of the
interesting-frames stack; the place where execution returns is called
the &#8220;landing pad&#8221;.</p>
<p>The advantage of this is that uninteresting frames don&#8217;t need to do
any work; context restoration just skips over them implicitly.  This
is faster both for the error and non-error paths.  It is also possible
to optimize this strategy so that (unlike <code class="docutils literal"><span class="pre">setjmp</span></code>) the test for an
error is implicitly elided: use a slightly different address for the
landing pad, so that propagating errors directly restore to that
location.</p>
<p>The downside is that saving the context and registering the frame are
not free:</p>
<ul class="simple">
<li>Registering the frame requires an access to thread-local state,
which on our platforms means a function call because we&#8217;re not
willing to commit to anything more specific in the ABI.</li>
<li>Jumping across arbitrary frames invalidates the callee-save
registers, so the registering frame must save them all eagerly.  In
calling conventions with many callee-save registers, this can be
very expensive.  However, this is only necessary when it&#8217;s possible
to resume normal execution from the landing pad: if the landing pad
only has clean-ups and therefore always restarts propagation, those
registers will have been saved and restored further out.</li>
<li>Languages like C++, ObjC ARC, and Swift that have non-trivial
clean-ups for many local variables tend to have many functions with
interesting frames.  This means both that the context-saving
penalties are higher and that skipping uninteresting frames is a
less valuable optimization.</li>
<li>By the same token, functions in those languages often have many
different clean-ups and/or handlers.  For example, every new
non-trivial variable might introduce a new clean-up.  The function
must either register a new landing pad for each clean-up (very
expensive!) or track its current position in a way that a
function-wide landing pad can figure out what scope it was in.</li>
</ul>
<p>This approach can be hybridized with the unwinding approach below so
that the interesting-frames stack abstractly describes the clean-ups
in the frame instead of just restoring control somewhere and expecting
the frame to figure it out.  This can decrease the code size impact
significantly for the common case of frames that just need to run some
clean-ups before propagating the error further.  It may even
completely eliminate the need for a landing pad.</p>
<p>The ObjC/C++ exceptions system on iOS/ARM32 is kindof like that
hybrid.  Propagation and clean-up code is explicit in the function,
but the registered context includes the &#8220;personality&#8221; information from
the unwinding tables, which makes the decision whether to land at the
landing pad at all.  It also uses an optimized <code class="docutils literal"><span class="pre">setjmp</span></code> implementation
that both avoids some context-saving and threads the branch as
described above.</p>
<p>The ObjC exceptions system on pre-modern runtimes (e.g. on PPC and
i386) uses the standard <code class="docutils literal"><span class="pre">setjmp</span></code> / <code class="docutils literal"><span class="pre">longjmp</span></code> functions.  Every
protected scope saves the context separately.  This is all implemented
in a very unsafe way that does not behave well in the presence of
inlining.</p>
<p>Overall, this approach requires a lot of work in the non-error path
of functions with interesting frames.  Given that we expect functions
with interesting frames to be very common in Swift, this is not
an implementation approach we would consider in the abstract.  However,
it is the implementation approach for C++/ObjC exceptions on iOS/ARM32,
so we need to at least interoperate with that.</p>
</div>
<div class="section" id="table-based-unwinding">
<h4>Table-based unwinding<a class="headerlink" href="#table-based-unwinding" title="Permalink to this headline">¶</a></h4>
<p>The final approach is side-table stack unwinding.  This relies on
being able to accurately figure out how to unwind through an arbitrary
function on the system, given only the return address of a call it
made and the stack pointer at that point.</p>
<p>On our system, this proceeds as follows.  From an instruction pointer,
the system unwinder looks up what linked image (executable or dylib)
that function was loaded from.  The linked image contains a special
section, a table of unwind tables indexed by their offset within the
linked image.  Every non-leaf function should have an entry within
this table, which provides sufficient information to unwind the
function from an arbitrary call site.</p>
<p>This lookup process is quite expensive, especially since it has to
repeat all the way up the stack until something actually handles the
error.  This makes the error path extremely slow.  However, no
explicit setup code is required along the non-error path, and so this
approach is sometimes known as &#8220;zero-cost&#8221;.  That&#8217;s something of a
misnomer, because it does have several costs that can affect non-error
performance.  First, there&#8217;s a small amount of load-time work required
in order to resolve relocations to symbols used by the unwind tables.
Second, the error path often requires code in the function, which can
decrease code locality even if never executed.  Third, the error path
may use information that the non-error path would otherwise discard.
And finally, the unwind tables themselves can be fairly large,
although this is generally only a binary-size concern because they are
carefully arranged to not need to be loaded off of disk unless an
exception is thrown.  But overall, &#8220;zero-cost&#8221; is close enough to
correct.</p>
<p>To unwind a frame in this sense specifically means:</p>
<ul class="simple">
<li>Deciding whether the function handles the error.</li>
<li>Cleaning up any interesting scopes that need to be broken down
(either to get to the handler or to leave the function).</li>
<li>If the function is being fully unwound, restoring any callee-save
registers which the function might have changed.</li>
</ul>
<p>This is language-specific, and so the table contains language-specific
&#8220;personality&#8221; information, including a reference to a function to
interpret it.  This mechanism means that the unwinder is extremely
flexible; not only can it support arbitrary languages, but it can
support different language-specific unwinding table layouts for the
same language.</p>
<p>Our current personality records for C++ and Objective-C contain just
enough information to decide (1) whether an exception is handled by
the frame and (2) if not, whether a clean-up is currently active.  If
either is true, it restores the context of a landing pad, which
manually executes the clean-ups and enters the handler.  This approach
generally needs as much code in the function as implicit manual
propagation would.  However, we could optimize this for many common
cases by causing clean-ups to be called automatically by the
interpretation function.  That is, instead of a landing pad that looks
notionally like this:</p>
<div class="highlight-python"><div class="highlight"><pre>void *exception = ...;
SomeCXXType::~SomeCXXType(&amp;foo);
objc_release(bar);
objc_release(baz);
_Unwind_Resume(exception);
</pre></div>
</div>
<p>The unwind table would have a record that looks notionally like this:</p>
<div class="highlight-python"><div class="highlight"><pre>CALL_WITH_FRAME_ADDRESS(&amp;SomeCXXType::~SomeCXXType, FRAME_OFFSET_OF(foo))
CALL_WITH_FRAME_VALUE(&amp;objc_release, FRAME_OFFSET_OF(bar))
CALL_WITH_FRAME_VALUE(&amp;objc_release, FRAME_OFFSET_OF(baz))
RESUME
</pre></div>
</div>
<p>And no code would actually be needed in the function.  This would
generally slow the error path down, because the interpretation
function would have to interpret this mini-language, but it would move
all the overhead out of the function and into the error table, where
it would be more compact.</p>
<p>This is something that would also benefit C++ code.</p>
</div>
</div>
<div class="section" id="clean-up-actions">
<h3>Clean-up actions<a class="headerlink" href="#clean-up-actions" title="Permalink to this headline">¶</a></h3>
<p>Many languages have a built-in language tool for performing arbitrary
clean-up when exiting a scope.  This has two benefits.  The first is
that, even ignoring error propagation, it acts as a &#8220;scope guard&#8221;
which ensures that the clean-up is done if the scope is exited early
due to a <code class="docutils literal"><span class="pre">return</span></code>, <code class="docutils literal"><span class="pre">break</span></code>, or <code class="docutils literal"><span class="pre">continue</span></code> statement; otherwise, the
programmer must carefully duplicate the clean-up in all such places.
The second benefit is that it makes clean-up tractable in the face of
automatic propagation, which creates so many implicit paths of control
flow out of the scope that expecting the programmer to cover them all
with explicit catch-and-rethrow blocks would be ridiculous.</p>
<p>There&#8217;s an inherent tension in these language features between putting
explicit clean-up code in the order it will be executed and putting it
near the code it&#8217;s cleaning up after.  The former means that a
top-to-bottom read of the code tells you what actions are being
performed when; you don&#8217;t have to worry about code implicitly
intervening at the end of a scope.  The latter makes it easy to verify
at the point that a clean-up is needed that it will eventually happen;
you don&#8217;t need to scan down to the finally block and analyze what
happens there.</p>
<div class="section" id="finally">
<h4><code class="docutils literal"><span class="pre">finally</span></code><a class="headerlink" href="#finally" title="Permalink to this headline">¶</a></h4>
<p>Java, Objective-C, and many other languages allow <code class="docutils literal"><span class="pre">try</span></code> statements to
take a <code class="docutils literal"><span class="pre">finally</span></code> clause.  The clause is an ordinary scope and may take
arbitrary actions.  The <code class="docutils literal"><span class="pre">finally</span></code> clause is performed when the
preceding controlled scopes (including any <code class="docutils literal"><span class="pre">catch</span></code> clauses) are exited
in any way: whether by falling off the end, directly branching or
returning out, or throwing an exception.</p>
<p><code class="docutils literal"><span class="pre">finally</span></code> is a rather awkward and verbose language feature.  It
separates the clean-up code from the operation that required it
(although this has benefits, as discussed above).  It adds a lot of
braces and indentation, so edits that add new clean-ups can require a
lot of code to be reformatted.  When the same scope needs multiple
clean-ups, the programmer must either put them in the same <code class="docutils literal"><span class="pre">finally</span></code>
block (and thus create problems with clean-ups that might terminate
the block early) or stack them up in separate blocks (which can really
obscure the otherwise simple flow of code).</p>
</div>
<div class="section" id="defer">
<h4><code class="docutils literal"><span class="pre">defer</span></code><a class="headerlink" href="#defer" title="Permalink to this headline">¶</a></h4>
<p>Go provides a <code class="docutils literal"><span class="pre">defer</span></code> statement that just enqueues arbitrary code to
be executed when the function exits.  (More details of this appear in
the survey of Go.)</p>
<p>This allows the defer action to be written near the code it
&#8220;balances&#8221;, allowing the reader to immediately see that the required
clean-up will be done (but this has drawbacks, as discussed above).
It&#8217;s very compact, which is nice as most defer actions are short.  It
also allows multiple actions to pile up without adding awkward nesting.
However, the function-exit semantics exacerbate the problem of
searching for intervening clean-up actions, and they introduce
semantic and performance problems with capturing the values of local
variables.</p>
</div>
<div class="section" id="destructors">
<h4>Destructors<a class="headerlink" href="#destructors" title="Permalink to this headline">¶</a></h4>
<p>C++ allows types to define destructor functions, which are called when
a function goes out of scope.</p>
<p>These are often used directly to clean up the ownership or other
invariants on the type&#8217;s value.  For example, an owning-pointer type
would free its value in its destructor, whereas a hash-table type
would destroy its entries and free its buffer.</p>
<p>But they are also often used idiomatically just for the implicit
destructor call, as a &#8220;scope guard&#8221; to ensure that something is done
before the current operation completes.  For an example close to my
own heart, a compiler might use such a guard when parsing a local
scope to ensure that new declarations are removed from the scope
chains even if the function exits early due to a parse error.
Unfortunately, since type destructors are C++&#8217;s only tool for this
kind of clean-up, introducing ad-hoc clean-up code requires defining a
new type every time.</p>
<p>The unique advantage of destructors compared to the options above is
that destructors can be tied to temporary values created during the
evaluation of an expression.</p>
<p>Generally, a clean-up action becomes necessary as the result of some
&#8220;acquire&#8221; operation that occurs during an expression.  <code class="docutils literal"><span class="pre">defer</span></code> and
<code class="docutils literal"><span class="pre">finally</span></code> do not take effect until the next statement is reached,
which creates an atomicity problem if code can be injected after the
acquire.  (For <code class="docutils literal"><span class="pre">finally</span></code>, this assumes that the acquire appears
<em>before</em> the <code class="docutils literal"><span class="pre">try</span></code>.  If instead the acquire appears <em>within</em> the
<code class="docutils literal"><span class="pre">try</span></code>, there must be something which activates the clean-up, and that
has the same atomicity problem.)</p>
<p>In contrast, if the acquire operation always creates a temporary with
a destructor that does the clean-up, the language automatically
guarantees this atomicity.  This pattern is called &#8220;resource
acquisition is initialization&#8221;, or &#8220;RAII&#8221;.  Under RAII, all resources
that require clean-up are carefully encapsulated within types with
user-defined destructors, and the act of constructing an object of
that type is exactly the act of acquiring the underlying resource.</p>
<p>Swift does not support user-defined destructors on value types, but it
does support general RAII-like programming with class types and
<code class="docutils literal"><span class="pre">deinit</span></code> methods, although (at the moment) the user must take special
care to keep the object alive, as Swift does not normally guarantee
the destruction order of objects.</p>
<p>RAII is very convenient when there&#8217;s a definable &#8220;resource&#8221; and
somebody&#8217;s already wrapped its acquisition APIs to return
appropriately-destructed objects.  For other tasks, where a reasonable
programmer might balk at defining a new type and possibly wrapping an
API for a single purpose, a more <em>ad hoc</em> approach may be warranted.</p>
</div>
</div>
</div>
<div class="section" id="survey">
<h2>Survey<a class="headerlink" href="#survey" title="Permalink to this headline">¶</a></h2>
<div class="section" id="c">
<h3>C<a class="headerlink" href="#c" title="Permalink to this headline">¶</a></h3>
<p>C doesn&#8217;t really have a consensus error-handling scheme.  There&#8217;s a
built-in unwinding mechanism in <code class="docutils literal"><span class="pre">setjmp</span></code> and <code class="docutils literal"><span class="pre">longjmp</span></code>, but it&#8217;s
disliked for a host of good reasons.  The dominant idiom in practice
is for a function to encode failure using some unreasonable value for
its result, like a null pointer or a negative count.  The bad value(s)
are often function-specific, and sometimes even argument- or
state-specific.</p>
<p>On the caller side, it is unfortunately idiomatic (in some codebases)
to have a common label for propagating failure at the end of a
function (hence <code class="docutils literal"><span class="pre">goto</span> <span class="pre">fail</span></code>); this is because there&#8217;s no inherent
language support for ensuring that necessary cleanup is done before
propagating out of a scope.</p>
</div>
<div class="section" id="id1">
<h3>C++<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>C++ has exceptions.  Exceptions can have almost any type in the
language.  Propagation typing is tied only to declarations; an
indirect function pointer is generally assumed to be able to throw.
Propagation typing used to allow functions to be specific about the
kinds of exceptions they could throw (:code:<code class="docutils literal"><span class="pre">throws</span>
<span class="pre">(std::exception)</span></code>), but this is deprecated in favor of just indicating
whether a function can throw (:code:<code class="docutils literal"><span class="pre">noexcept(false)</span></code>).</p>
<p>C++ aspires to making out-of-memory a recoverable condition, and so
allocation can throw.  Therefore, it is essentially compulsory for the
language to assume that constructors might throw.  Since constructors
are called pervasively and implicitly, it makes sense for the default
rule to be that all functions can throw.  Since many error sites are
implicit, there is little choice but to use automatic unmarked
propagation.  The only reasonable way to clean up after a scope in
such a world is to allow the compiler to do it automatically.  C++
programmers therefore rely idiomatically on a pattern of shifting all
scope cleanup into the destructors of local variables; sometimes such
local values are created solely to set up a cleanup action in this
way.</p>
<p>Different error sites occur with a different set of cleanups active,
and there are a large number of such sites.  In fact, prior to C++11,
compilers were forced to assume by default that destructor calls could
throw, so cleanups actually created more error sites.  This all adds
up to a significant code-size penalty for exceptions, even in projects
which don&#8217;t directly use them and which have no interest in recovering
from out-of-memory conditions.  For this reason, many C++ projects
explicitly disable exceptions and rely on other error propagation
mechanisms, on which there is no widespread consensus.</p>
</div>
<div class="section" id="objective-c">
<h3>Objective C<a class="headerlink" href="#objective-c" title="Permalink to this headline">¶</a></h3>
<p>Objective C has a first-class exceptions mechanism which is similar in
feature set to Java&#8217;s: <code class="docutils literal"><span class="pre">&#64;throw</span></code> / <code class="docutils literal"><span class="pre">&#64;try</span></code> / <code class="docutils literal"><span class="pre">&#64;catch</span></code> / <code class="docutils literal"><span class="pre">&#64;finally</span></code>.
Exception values must be instances of an Objective-C class.  The
language does a small amount of implicit frame cleanup during
exception propagation: locks held by <code class="docutils literal"><span class="pre">&#64;synchronized</span></code> are released,
stack copies of <code class="docutils literal"><span class="pre">__block</span></code> variables are torn down, and ARC <code class="docutils literal"><span class="pre">__weak</span></code>
variables are destroyed.  However, the language does not release
object pointers held in local variables, even (by default) under ARC.</p>
<p>Objective C exceptions used to be implemented with <code class="docutils literal"><span class="pre">setjmp</span></code>,
<code class="docutils literal"><span class="pre">longjmp</span></code>, and thread-local state managed by a runtime, but the only
surviving platform we support which does that is i386, and all others
now use a &#8220;zero-cost&#8221; implementation that interoperates with C++
exceptions.</p>
<p>Objective C exceptions are <em>mostly</em> only used for unrecoverable
conditions, akin to what I called &#8220;failures&#8221; above.  There are a few
major exceptions to this rule, where APIs that do use exceptions to
report errors.</p>
<p>Instead, Objective C mostly relies on manual propagation,
predominantly using out-parameters of type <code class="docutils literal"><span class="pre">NSError**</span></code>.  Whether the
call failed is usually <em>not</em> indicated by whether a non-<code class="docutils literal"><span class="pre">nil</span></code> error
was written into this parameter; calls are permitted both to succeed
and write an error object into the parameter (which should be ignored)
and to report an error without creating an actual error object.
Instead, whether the call failed is reported in the formal return
value.  The most common convention is for a false <code class="docutils literal"><span class="pre">BOOL</span></code> result or
null object result to mean an error, but ingenious programmers have
come up with many other conventions, and there do exist APIs where a
null object result is valid.</p>
<p>CF APIs, meanwhile, have their own magnificent set of somewhat
inconsistent conventions.</p>
<p>Therefore, we can expect that incrementally improving CF / Objective C
interoperation is going to be a long and remarkably painful process.</p>
</div>
<div class="section" id="java">
<h3>Java<a class="headerlink" href="#java" title="Permalink to this headline">¶</a></h3>
<p>Java has a first-class exceptions mechanism with unmarked automatic
propagation: <code class="docutils literal"><span class="pre">throw</span></code> / <code class="docutils literal"><span class="pre">try</span></code> / <code class="docutils literal"><span class="pre">catch</span></code> / <code class="docutils literal"><span class="pre">finally</span></code>.  Exception values
must be instances of something inheriting from <code class="docutils literal"><span class="pre">Throwable</span></code>.
Propagation is generally typed with static enforcement, with the
default being that a call cannot throw exceptions <em>except</em> for
subclasses of <code class="docutils literal"><span class="pre">Error</span></code> and <code class="docutils literal"><span class="pre">RuntimeException</span></code>.  The original intent was
that these classes would be used for catastrophic runtime errors
(<code class="docutils literal"><span class="pre">Error</span></code>) and programming mistakes caught by the runtime
(<code class="docutils literal"><span class="pre">RuntimeException</span></code>), both of which we would classify as unrecoverable
failures in our scheme; essentially, Java attempts to promote a fully
statically-enforced model where truly catastrophic problems can still
be handled when necessary.  Unfortunately, these motivations don&#8217;t
seem to have been communicated very well to developers, and the result
is kindof a mess.</p>
<p>Java allows methods to be very specific about the kinds of exception
they throw.  In my experience, exceptions tend to fall into two
categories:</p>
<ul class="simple">
<li>There are some very specific exception kinds that callers know to
look for and handle on specific operations.  Generally these are
obvious, predictable error conditions, like a host name not
resolving, or like a string not being formatted correctly.</li>
<li>There are also a lot of very vague, black-box exception kinds that
can&#8217;t really be usefully responded to.  For example, if a method
throws <code class="docutils literal"><span class="pre">IOException</span></code>, there&#8217;s really nothing a caller can do except
propagate it and abort the current operation.</li>
</ul>
<p>So specific typing is useful if you can exhaustively handle a small
number of specific failures.  As soon as the exception list includes
any kind of black box type, it might as well be a completely open set.</p>
</div>
<div class="section" id="id2">
<h3>C#<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>C#&#8217;s model is almost exactly like Java&#8217;s except that it is untyped:
all methods are assumed to be able to throw.  For this reason, it also
has a simpler type hierarchy, where all exceptions just inherit from
<code class="docutils literal"><span class="pre">Exception</span></code>.</p>
<p>The rest of the hierarchy doesn&#8217;t really make any sense to me. Many
things inherit directly from <code class="docutils literal"><span class="pre">Exception</span></code>, but many other things
inherit from a subclass called <code class="docutils literal"><span class="pre">SystemException</span></code>. <code class="docutils literal"><span class="pre">SystemException</span></code>
doesn&#8217;t seem to be any sort of logical grouping: it includes all the
runtime-assertion exceptions, but it also includes every exception
that&#8217;s thrown anywhere in the core library, including XML and IO
exceptions.</p>
<p>C# also has a <code class="docutils literal"><span class="pre">using</span></code> statement, which is useful for binding something
over a precise scope and then automatically disposing it on all paths.
It&#8217;s just built on top of <code class="docutils literal"><span class="pre">try</span></code> / <code class="docutils literal"><span class="pre">finally</span></code>.</p>
</div>
<div class="section" id="haskell">
<h3>Haskell<a class="headerlink" href="#haskell" title="Permalink to this headline">¶</a></h3>
<p>Haskell provides three different common error-propagation mechanisms.</p>
<p>The first is that, like many other functional languages, it supports
manual propagation with a <code class="docutils literal"><span class="pre">Maybe</span></code> type.  A function can return <code class="docutils literal"><span class="pre">None</span></code>
to indicate that it couldn&#8217;t produce a more useful result.  This is
the most common failure method for functions in the functional subset
of the library.</p>
<p>The <code class="docutils literal"><span class="pre">IO</span></code> monad also provides true exceptions with unmarked automatic
propagation.  These exceptions can only be handled as an <code class="docutils literal"><span class="pre">IO</span></code> action,
but are otherwise untyped: there is no way to indicate whether an <code class="docutils literal"><span class="pre">IO</span></code>
action can or cannot throw.  Exceptions can be thrown either as an
<code class="docutils literal"><span class="pre">IO</span></code> action or as an ordinary lazy functional computation; in the
latter case, the exception is only thrown if the computation is
evaluated for some reason.</p>
<p>The <code class="docutils literal"><span class="pre">ErrorT</span></code> monad transform provides typed automatic propagation.  In
an amusing twist, since the only native computation of <code class="docutils literal"><span class="pre">ErrorT</span></code> is
<code class="docutils literal"><span class="pre">throwError</span></code>, and the reason to write a computation specifically in
<code class="docutils literal"><span class="pre">ErrorT</span></code> is if it&#8217;s throwing, and every other computation must be
explicitly lifted into the monad, <code class="docutils literal"><span class="pre">ErrorT</span></code> effectively uses marked
propagation by omission, since everything that <em>can&#8217;t</em> throw is
explicitly marked with a <code class="docutils literal"><span class="pre">lift</span></code>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">prettyPrintShiftJIS</span> <span class="ow">::</span> <span class="kt">ShiftJISString</span> <span class="ow">-&gt;</span> <span class="kt">ErrorT</span> <span class="kt">TranscodeError</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">prettyPrintShiftJIS</span> <span class="n">str</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">lift</span> <span class="o">$</span> <span class="n">putChar</span> <span class="sc">&#39;&quot;&#39;</span>     <span class="c1">-- lift turns an IO computation into an ErrorT computation</span>
  <span class="kr">case</span> <span class="n">transcodeShiftJISToUTF8</span> <span class="n">str</span> <span class="kr">of</span>
    <span class="kt">Left</span> <span class="ne">error</span> <span class="ow">-&gt;</span> <span class="n">throwError</span> <span class="ne">error</span>
    <span class="kt">Right</span> <span class="n">value</span> <span class="ow">-&gt;</span> <span class="n">lift</span> <span class="o">$</span> <span class="n">putEscapedString</span> <span class="n">value</span>
  <span class="n">lift</span> <span class="o">$</span> <span class="n">putChar</span> <span class="sc">&#39;&quot;&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="rust">
<h3>Rust<a class="headerlink" href="#rust" title="Permalink to this headline">¶</a></h3>
<p>Rust distinguishes between <em>failures</em> and <em>panics</em>.</p>
<p>A panic is an assertion, designed for what I called logic failures;
there&#8217;s no way to recover from one, it just immediately crashes.</p>
<p>A failure is just when a function doesn&#8217;t produce the value you might
expect, which Rust encourages you to express with either <code class="docutils literal"><span class="pre">Option&lt;T&gt;</span></code>
(for simple cases, like what I described as simple domain errors) or
<code class="docutils literal"><span class="pre">Result&lt;T&gt;</span></code> (which is effectively the same, except carrying an error).
In either case, it&#8217;s typed manual propagation, although Rust does at
least offer a standard macro which wraps the common
pattern-match-and-return pattern for <code class="docutils literal"><span class="pre">Result&lt;T&gt;</span></code>.</p>
<p>The error type in Rust is a very simple protocol, much like this
proposal suggests.</p>
</div>
<div class="section" id="go">
<h3>Go<a class="headerlink" href="#go" title="Permalink to this headline">¶</a></h3>
<p>Go uses an error result, conventionally returned as the final result
of functions that can fail.  The caller is expected to manually check
whether this is nil; thus, Go uses typed manual propagation.</p>
<p>The error type in Go is an interface named <code class="docutils literal"><span class="pre">error</span></code>, with one method
that returns a string description of the error.</p>
<p>Go has a <code class="docutils literal"><span class="pre">defer</span></code> statement:</p>
<div class="highlight-python"><div class="highlight"><pre>defer foo(x, y)
</pre></div>
</div>
<p>The argument has to be a call (possibly a method call, possibly a call
to a closure that you made specifically to immediately call).  All the
operands are evaluated immediately and captured in a deferred action.
Immediately after the function exits (through whatever means), all the
deferred actions are executed in LIFO order.  Yes, this is tied to
function exit, not scope exit, so you can have a dynamic number of
deferred actions as a sort of implicit undo stack.  Overall, it&#8217;s a
nice if somewhat quirky way to do ad-hoc cleanup actions.</p>
<p>It is also a key part of a second, funky kind of error propagation,
which is essentially untyped automatic propagation.  If you call
<code class="docutils literal"><span class="pre">panic</span></code> &#8212; and certain builtin operations like array accesses behave
like they do &#8212; it immediately unwinds the stack, running deferred
actions as it goes.  If a function&#8217;s deferred action calls <code class="docutils literal"><span class="pre">recover</span></code>,
the panic stops, the rest of the deferred actions for the function are
called, and the function returns.  A deferred action can write to the
named results, allowing a function to turn a panic error into a
normal, final-result error.  It&#8217;s conventional to not panic over
API boundaries unless you really mean it; recoverable errors are
supposed to be done with out-results.</p>
</div>
<div class="section" id="scripting-languages">
<h3>Scripting languages<a class="headerlink" href="#scripting-languages" title="Permalink to this headline">¶</a></h3>
<p>Scripting languages generally all use (untyped, obviously) automatic
exception propagation, probably because it would be quite error-prone
to do manual propagation in an untyped language.  They pretty much all
fit into the standard C++/Java/C# style of <code class="docutils literal"><span class="pre">throw</span></code> / <code class="docutils literal"><span class="pre">try</span></code> / <code class="docutils literal"><span class="pre">catch</span></code>.
Ruby uses different keywords for it, though.</p>
<p>I feel like Python uses exceptions a lot more than most other
scripting languages do, though.</p>
</div>
</div>
<div class="section" id="proposal">
<h2>Proposal<a class="headerlink" href="#proposal" title="Permalink to this headline">¶</a></h2>
<div class="section" id="automatic-propagation">
<h3>Automatic propagation<a class="headerlink" href="#automatic-propagation" title="Permalink to this headline">¶</a></h3>
<p>Swift should use automatic propagation of errors, rather than relying
on the programmer to manually check for them and return out.  It&#8217;s
just a lot less boilerplate for common error handling tasks.  This
introduces an implicit control flow problem, but we can ameliorate
that with marked propagation; see below.</p>
<p>There&#8217;s no compelling reason to deviate from the <code class="docutils literal"><span class="pre">throw</span></code> / <code class="docutils literal"><span class="pre">catch</span></code>
legacy here.  There are other options, like <code class="docutils literal"><span class="pre">raise</span></code> / <code class="docutils literal"><span class="pre">handle</span></code>.  In
theory, switching would somewhat dissociate Swift from the legacy of
exceptions; people coming from other languages have a lot of
assumptions about exceptions which don&#8217;t necessarily apply to Swift.
However, our error model is similar enough to the standard exception
model that people are inevitably going to make the connection; there&#8217;s
no getting around the need to explain what we&#8217;re trying to do.  So
using different keywords just seems petty.</p>
<p>Therefore, Swift should provide a <code class="docutils literal"><span class="pre">throw</span></code> expression.  It requires an
operand of type <code class="docutils literal"><span class="pre">Error</span></code> and formally yields an arbitrary type.  Its
dynamic behavior is to transfer control to the innermost enclosing
<code class="docutils literal"><span class="pre">catch</span></code> clause which is satisfied by the operand.  A quick example:</p>
<div class="highlight-python"><div class="highlight"><pre>if timeElapsed() &gt; timeThreshold { throw HomeworkError.Overworked }
</pre></div>
</div>
<p>A <code class="docutils literal"><span class="pre">catch</span></code> clause includes a pattern that matches an error.  We want to
repurpose the <code class="docutils literal"><span class="pre">try</span></code> keyword for marked propagation, which it seems to
fit far better, so <code class="docutils literal"><span class="pre">catch</span></code> clauses will instead be attached to a
generalized <code class="docutils literal"><span class="pre">do</span></code> statement:</p>
<div class="highlight-python"><div class="highlight"><pre>do {
  ...

} catch HomeworkError.Overworked {
  // a conditionally-executed catch clause

} catch _ {
  // a catch-all clause
}
</pre></div>
</div>
<p>Swift should also provide some tools for doing manual propagation.  We
should have a standard Rust-like :code:<code class="docutils literal"><span class="pre">Result&lt;T&gt;</span></code> enum in the
library, as well as a rich set of tools, e.g.:</p>
<ul class="simple">
<li>A function to evaluate an error-producing closure and capture the
result as a :code:<code class="docutils literal"><span class="pre">Result&lt;T&gt;</span></code>.</li>
<li>A function to unpack a :code:<code class="docutils literal"><span class="pre">Result&lt;T&gt;</span></code> by either returning its
value or propagating the error in the current context.</li>
<li>A futures library that traffics in :code:<code class="docutils literal"><span class="pre">Result&lt;T&gt;</span></code> when
applicable.</li>
<li>An overload of <code class="docutils literal"><span class="pre">dispatch_sync</span></code> which takes an error-producing
closure and propagates an error in the current context.</li>
<li>etc.</li>
</ul>
</div>
<div class="section" id="id3">
<h3>Typed propagation<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>Swift should use statically-enforced typed propagation.  By default,
functions should not be able to throw.  A call to a function which can
throw within a context that is not allowed to throw should be rejected
by the compiler.</p>
<p>Function types should indicate whether the function throws; this needs
to be tracked even for first-class function values.  Functions which
do not throw are subtypes of functions that throw.</p>
<p>This would be written with a <code class="docutils literal"><span class="pre">throws</span></code> clause on the function
declaration or type:</p>
<div class="highlight-python"><div class="highlight"><pre>// This function is not permitted to throw.
 func foo() -&gt; Int {
   // Therefore this is a semantic error.
   return try stream.readInt()
 }

 // This function is permitted to throw.
 func bar() throws -&gt; Int {
   return try stream.readInt()
 }

 // ‘throws’ is written before the arrow to give a sensible and
 // consistent grammar for function types and implicit () result types.
 func baz() throws {
   if let byte = try stream.getOOB() where byte == PROTO_RESET {
     reset()
   }
 }

 // ‘throws’ appears in a consistent position in function types.
 func fred(callback: (UInt8) throws -&gt; ()) throws {
    while true {
      let code = try stream.readByte()
      if code == OPER_CLOSE { return }
      try callback(code)
    }
 }

 // It only applies to the innermost function for curried functions;
 // this function has type:
 //   (Int) -&gt; (Int) throws -&gt; Int
 func jerry(i: Int)(j: Int) throws -&gt; Int {
   // It’s not an error to use ‘throws’ on a function that can’t throw.
   return i + j
 }
</pre></div>
</div>
<p>The reason to use a keyword here is that it&#8217;s much nicer for function
declarations, which generally outnumber function types by at least an
order of magnitude.  A punctuation mark would be easily lost or
mistaken amidst all the other punctuation in a function declaration,
especially if the punctuation mark were something like <code class="docutils literal"><span class="pre">!</span></code> that can
validly appear at the end of a parameter type.  It makes sense for the
keyword to appear close to the return type, as it&#8217;s essentially a part
of the result and a programmer should be able to see both parts in the
same glance.  The keyword appears before the arrow for the simple
reason that the arrow is optional (along with the rest of the return
type) in function and initializer declarations; having the keyword
appear in slightly different places based on the presence of a return
type would be silly and would make adding a non-void return type
feel awkward.  The keyword itself should be descriptive, and it&#8217;s
particularly nice for it to be a form of the verb used by the throwing
expression, conjugated as if performed by the function itself.  Thus,
<code class="docutils literal"><span class="pre">throw</span></code> becomes <code class="docutils literal"><span class="pre">throws</span></code>; if we used <code class="docutils literal"><span class="pre">raise</span></code> instead, this would
be <code class="docutils literal"><span class="pre">raises</span></code>, which I personally find unappealing for reasons I&#8217;m not
sure I can put a name to.</p>
<p>It shouldn&#8217;t be possible to overload functions solely based on whether
the functions throw.  That is, this is not legal:</p>
<div class="highlight-python"><div class="highlight"><pre>func foo() { ... } // called in contexts that cannot throw
func foo() throws { ... } // called in contexts that can throw
</pre></div>
</div>
<p>It is valuable to be able to overload higher-order functions based on
whether an argument function throws; it is easy to imagine algorithms
that can be implemented more efficiently if they do not need to worry
about exceptions.  (We do not, however, particularly want to encourage
a pattern of duplicating This is straightforward if the primary
type-checking pass is able to reliably decide whether a function value
can throw.</p>
<p>Typed propagation checking can generally be performed in a secondary
pass over a type-checked function body: if a function is not permitted
to throw, walk its body and verify that there are no <code class="docutils literal"><span class="pre">throw</span></code>
expressions or calls to functions that can <code class="docutils literal"><span class="pre">throw</span></code>.  If all throwing
calls must be marked, this can be done prior to type-checking to
decide syntactically whether a function can apparently throw; of
course, the later pass is still necessary, but the ability to do this
dramatically simplifies the implementation of the type-checker, as
discussed below.  Certain type-system features may need to be
curtailed in order to make this implementation possible for schedule
reasons.  (It&#8217;s important to understand that this is <em>not</em> the
motivation for marked propagation.  It&#8217;s just a convenient consequence
that marked propagation makes this implementation possible.)</p>
<p>Reliably deciding whether a function value can throw is easy for
higher-order uses of declared functions.  The problem, as usual, is
anonymous functions.  We don&#8217;t want to require closures to be
explicitly typed as throwing or non-throwing, but the fully-accurate
inference algorithm requires a type-checked function body, and we
can&#8217;t always type-check an anonymous function independently of its
enclosing context.  Therefore, we will rely on being able to do a pass
prior to type-checking to syntactically infer whether a closure
throws, then making a second pass after type-checking to verify the
correctness of that inference.  This may break certain kinds of
reasonable code, but the multi-pass approach should let us
heuristically unbreak targeted cases.</p>
<p>Typed propagation has implications for all kinds of polymorphism:</p>
<div class="section" id="higher-order-polymorphism">
<h4>Higher-order polymorphism<a class="headerlink" href="#higher-order-polymorphism" title="Permalink to this headline">¶</a></h4>
<p>We should make it easy to write higher-order functions that behave
polymorphically w.r.t. whether their arguments throw.  This can be
done in a fairly simple way: a function can declare that it throws if
any of a set of named arguments do.  As an example (using strawman
syntax):</p>
<div class="highlight-python"><div class="highlight"><pre>func map&lt;T,U&gt;(array: [T], fn: T throws -&gt; U) throwsIf(fn) -&gt; [U] {
  ...
}
</pre></div>
</div>
<p>There&#8217;s no need for a more complex logical operator than disjunction.
You can construct really strange code where a function throws only if
one of its arguments doesn&#8217;t, but it&#8217;d be contrived, and it&#8217;s hard to
imagine how they could be type-checked without a vastly more
sophisticated approach.  Similarly, you can construct situations where
whether a function can throw is value-dependent on some other
argument, like a &#8220;should I throw an exception&#8221; flag, but it&#8217;s hard to
imagine such cases being at all important to get right in the
language.  This schema is perfectly sufficient to express normal
higher-order stuff.</p>
<p>In fact, while the strawman syntax above allows the function to be
specific about exactly which argument functions cause the callee to
throw, that&#8217;s already overkill in the overwhelmingly likely case of a
function that throws if any of its argument functions throw (and
there&#8217;s probably only one).  So it would probably be better to just
have a single <code class="docutils literal"><span class="pre">rethrows</span></code> annotation, with vague plans to allow it
to be parameterized in the future if necessary.</p>
<p>This sort of propagation-checking would be a straightforward extension
of the general propagation checker.  The normal checker sees that a
function isn&#8217;t allowed to propagate out and looks for propagation
points.  The conditional checker sees that a function has a
conditional propagation clause and looks for propagation points,
assuming that the listed functions don&#8217;t throw (including when looking
at any conditional propagation clauses).  The parameter would have to
be a <code class="docutils literal"><span class="pre">let</span></code>.</p>
<p>We probably do need to get higher-order polymorphism right in the
first release, because we will need it for the short-circuiting
operators.</p>
</div>
<div class="section" id="generic-polymorphism">
<h4>Generic polymorphism<a class="headerlink" href="#generic-polymorphism" title="Permalink to this headline">¶</a></h4>
<p>It would be useful to be able to parameterize protocols, and protocol
conformances, on whether the operations produce errors.  Lacking this
feature means that protocol authors must decide to either
conservatively allow throwing conformances, and thus force all generic
code using the protocol to deal with probably-spurious errors, or
aggressively forbid them, and thus forbid conformances by types whose
operations naturally throw.</p>
<p>There are several different ways we could approach this problem, but
after some investigation I feel confident that they&#8217;re workable.
Unfortunately, they are clearly out-of-scope for the first release.
For now, the standard library should provide protocols that cannot
throw, even though this limits some potential conformances.  (It&#8217;s
worth noting that such conformances generally aren&#8217;t legal today,
since they&#8217;d need to return an error result somehow.)</p>
<p>A future direction for both generic and higher-order polymorphism is
to consider error propagation to be one of many possible effects in a
general, user-extensible effect tracking system.  This would allow the
type system to check that certain specific operations are only allowed
in specific contexts: for example, that a blocking operation is only
allowed in a blocking context.</p>
</div>
<div class="section" id="error-type">
<h4>Error type<a class="headerlink" href="#error-type" title="Permalink to this headline">¶</a></h4>
<p>The Swift standard library will provide <code class="docutils literal"><span class="pre">ErrorType</span></code>, a protocol with
a very small interface (which is not described in this proposal).  The
standard pattern should be to define the conformance of an <code class="docutils literal"><span class="pre">enum</span></code> to
the type:</p>
<div class="highlight-python"><div class="highlight"><pre>enum HomeworkError : ErrorType {
  case Overworked
  case Impossible
  case EatenByCat(Cat)
  case StopStressingMeWithYourRules
}
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">enum</span></code> provides a namespace of errors, a list of possible errors
within that namespace, and optional values to attach to each option.</p>
<p>For now, the list of errors in a domain will be fixed, but permitting
future extension is just ordinary enum resilience, and the standard
techniques for that will work fine in the future.</p>
<p>Note that this corresponds very cleanly to the <code class="docutils literal"><span class="pre">NSError</span></code> model of an
error domain, an error code, and optional user data.  We expect to
import system error domains as enums that follow this approach and
implement <code class="docutils literal"><span class="pre">ErrorType</span></code>.  <code class="docutils literal"><span class="pre">NSError</span></code> and <code class="docutils literal"><span class="pre">CFError</span></code> themselves will also
conform to <code class="docutils literal"><span class="pre">ErrorType</span></code>.</p>
<p>The physical representation (still being nailed down) will make it
efficient to embed an <code class="docutils literal"><span class="pre">NSError</span></code> as an <code class="docutils literal"><span class="pre">ErrorType</span></code> and vice-versa.  It
should be possible to turn an arbitrary Swift <code class="docutils literal"><span class="pre">enum</span></code> that conforms to
<code class="docutils literal"><span class="pre">ErrorType</span></code> into an <code class="docutils literal"><span class="pre">NSError</span></code> by using the qualified type name as the
domain key, the enumerator as the error code, and turning the payload
into user data.</p>
<p>It&#8217;s acceptable to allocate memory whenever an error is needed,
but our representation should not inhibit the optimizer from
forwarding a <code class="docutils literal"><span class="pre">throw</span></code> directly to a <code class="docutils literal"><span class="pre">catch</span></code> and removing the
intermediate error object.</p>
</div>
</div>
<div class="section" id="id4">
<h3>Marked propagation<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>Swift should use marked propagation: there should be some lightweight
bit of syntax decorating anything that is known be able to throw
(other than a <code class="docutils literal"><span class="pre">throw</span></code> expression itself, of course).</p>
<p>Our proposed syntax is to repurpose <code class="docutils literal"><span class="pre">try</span></code> as something that can be
wrapped around an arbitrary expression:</p>
<div class="highlight-python"><div class="highlight"><pre>// This try applies to readBool().
if try stream.readBool() {

  // This try applies to both of these calls.
  let x = try stream.readInt() + stream.readInt()

  // This is a semantic error; it needs a try.
  var y = stream.readFloat()

  // This is okay; the try covers the entire statement.
  try y += stream.readFloat()
}
</pre></div>
</div>
<p>Developers can &#8220;scope&#8221; the <code class="docutils literal"><span class="pre">try</span></code> very tightly by writing it within
parentheses or on a specific argument or list element:</p>
<div class="highlight-python"><div class="highlight"><pre>// Semantic error: the try only covers the parenthesized expression.
let x = (try stream.readInt()) + stream.readInt()

// The try applies to the first array element.  Of course, the
// developer could cover the entire array by writing the try outside.
let array = [ try foo(), bar(), baz() ]
</pre></div>
</div>
<p>Some developers may wish to do this to make the specific throwing
calls very clear.  Other developers may be content with knowing that
something within a statement can throw.</p>
<p>We also briefly considered the possibility of putting the marker into
the call arguments clause, e.g.:</p>
<div class="highlight-python"><div class="highlight"><pre>parser.readKeys(&amp;strings, try)
</pre></div>
</div>
<p>This works as long as the only throwing calls are written
syntactically as calls; this covers calls to free functions, methods,
and initializers.  However, it effectively requires Swift to forbid
operators and property and subscript accessors from throwing, which
may not be a reasonable limitation, especially for operators.  It is
also somewhat unnatural, and it forces users to mark every single call
site instead of allowing them to mark everything within a statement at
once.</p>
<p>Autoclosures pose a problem for marking.  For the most part, we want
to pretend that the expression of an autoclosure is being evaluated in
the enclosing context; we don&#8217;t want to have to mark both a call
within the autoclosure and the call to the function taking the
autoclosure!  We should teach the type-checking pass to recognize this
pattern: a call to a function that <code class="docutils literal"><span class="pre">throwsIf</span></code> an autoclosure argument
does.</p>
<p>There&#8217;s a similar problem with functions that are supposed to feel
like statements.  We want you to be able to write:</p>
<div class="highlight-python"><div class="highlight"><pre>autoreleasepool {
  let string = parseString(try)
  ...
}
</pre></div>
</div>
<p>without marking the call to <code class="docutils literal"><span class="pre">autoreleasepool</span></code>, because this undermines
the ability to write functions that feel like statements.  However,
there are other important differences between these trailing-closure
uses and true built-in statements, such as the behavior of <code class="docutils literal"><span class="pre">return</span></code>,
<code class="docutils literal"><span class="pre">break</span></code>, and <code class="docutils literal"><span class="pre">continue</span></code>.  An attribute which marks the function as
being statement-like would be a necessary step towards addressing both
problems.  Doing this reliably in closures would be challenging,
however.</p>
<div class="section" id="asserting-markers">
<h4>Asserting markers<a class="headerlink" href="#asserting-markers" title="Permalink to this headline">¶</a></h4>
<p>Typed propagation is a hypothesis-checking mechanism and so suffers
from the standard problem of false positives.  (Basic soundness
eliminates false negatives, of course: the compiler is supposed to
force programmers to deal with <em>every</em> source of error.)  In this
case, a false positive means a situation where an API is declared to
throw but an error is actually dynamically impossible.</p>
<p>For example, a function to load an image from a URL would usually be
designed to produce an error if the image didn&#8217;t exist, the connection
failed, the file data was malformed, or any of a hundred other
problems arose.  The programmer should be expected to deal with that
error in general.  But a programmer might reasonably use the same API
to load an image completely under their control, e.g. from their
program&#8217;s private resources.  We shouldn&#8217;t make it too syntactically
inconvenient to &#8220;turn off&#8221; error-checking for such calls.</p>
<p>One important point is that we don&#8217;t want to make it too easy to
<em>ignore</em> errors.  Ignored errors usually lead to a terrible debugging
experience, even if the error is logged with a meaningful stack trace;
the full context of the failure is lost and can be difficult to
reproduce.  Ignored errors also have a way of compounding, where an
error that&#8217;s &#8220;harmlessly&#8221; ignored at one layer of abstraction causes
another error elsewhere; and of course the second error can be
ignored, etc., but only by making the program harder and harder to
understand and debug, leaving behind log files that are increasingly
jammed with the detritus of a hundred ignored errors.  And finally,
ignoring errors creates a number of type-safety and security problems
by encouraging programs to blunder onwards with meaningless data and
broken invariants.</p>
<p>Instead, we just want to make it (comparatively) easy to turn a static
problem into a dynamic one, much as assertions and the ! operator do.
Of course, this needs to be an explicit operation, because otherwise
we would completely lose typed propagation; and it should be
call-specific, so that the programmer has to make an informed decision
about individual operations.  But we already have an explicit,
call-site-specific annotation: the <code class="docutils literal"><span class="pre">try</span></code> operator.  So the obvious
solution is to allow a variant of <code class="docutils literal"><span class="pre">try</span></code> that asserts that an error
is not thrown out of its operand; and the obvious choice there within
our existing design language is to use the universal &#8220;be careful, this
is unsafe&#8221; marker by making the keyword <code class="docutils literal"><span class="pre">try!</span></code>.</p>
<p>It&#8217;s reasonable to ask whether <code class="docutils literal"><span class="pre">try!</span></code> is actually <em>too</em> easy to
write, given that this is, after all, an unsafe operation.  One quick
rejoinder is that it&#8217;s no worse than the ordinary <code class="docutils literal"><span class="pre">!</span></code> operator in
that sense.  Like <code class="docutils literal"><span class="pre">!</span></code>, it&#8217;s something that a cautious programmer
might want to investigate closer, and you can easily imagine codebases
that expect uses of it to always be explained in comments.  But more
importantly, just like <code class="docutils literal"><span class="pre">!</span></code> it&#8217;s only <em>statically</em> unsafe, and it
will reliably fail when the programmer is wrong.  Therefore, while you
can easily imagine (and demonstrate) incautious programmers flailing
around with it to appease the type-checker, that&#8217;s not actually a
tenable position for the overall program: eventually the programmer
will have to learn how to use the feature, or else their program
simply won&#8217;t run.</p>
<p>Furthermore, while <code class="docutils literal"><span class="pre">try!</span></code> does somewhat undermine error-safety in
the hands of a careless programmer, it&#8217;s still better to promote this
kind of unsafety than to implicitly promote the alternative.  A
careless programmer isn&#8217;t going to write good error handling just
because we don&#8217;t give them this feature.  Instead, they&#8217;ll write out a
<code class="docutils literal"><span class="pre">do/catch</span></code> block, and the natural pressure there will be to silently
swallow the error &#8212; after all, that takes less boilerplate than
asserting or logging.</p>
<p>In a future release, when we add support for universal errors, we&#8217;ll
need to reconsider the behavior of <code class="docutils literal"><span class="pre">try!</span></code>.  One possibility is that
<code class="docutils literal"><span class="pre">try!</span></code> should simply start propagating its operand as a universal
error; this would allow emergency recovery.  Alternatively, we may
want <code class="docutils literal"><span class="pre">try!</span></code> to assert that even universal errors aren&#8217;t thrown out
of it; this would provide a more consistent language model between the
two kinds of errors.  But we don&#8217;t need to think too hard about this
yet.</p>
</div>
</div>
<div class="section" id="other-syntax">
<h3>Other syntax<a class="headerlink" href="#other-syntax" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id5">
<h4>Clean-up actions<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>Swift should provide a statement for cleaning up with an <em>ad hoc</em>
action.</p>
<p>Overall, I think it is better to use a Go-style <code class="docutils literal"><span class="pre">defer</span></code> than a
Java-style <code class="docutils literal"><span class="pre">try</span> <span class="pre">...</span> <span class="pre">finally</span></code>.  While this makes the exact order of
execution more obscure, it does make it obvious that the clean-up
<em>will</em> be executed without any further analysis, which is something
that readers will usually be interested in.</p>
<p>Unlike Go, I think this should be tied to scope-exit, not to
function-exit.  This makes it very easy to know the set of <code class="docutils literal"><span class="pre">defer</span></code>
actions that will be executed when a scope exits: it&#8217;s all the <code class="docutils literal"><span class="pre">defer</span></code>
statement in exactly that scope.  In contrast, in Go you have to
understand the dynamic history of the function&#8217;s execution.  This also
eliminates some semantic and performance oddities relating to variable
capture, since the <code class="docutils literal"><span class="pre">defer</span></code> action occurs with everything still in
scope.  One downside is that it&#8217;s not as good for &#8220;transactional&#8221;
idioms which push an undo action for everything they do, but that
style has composition problems across function boundaries anyway.</p>
<p>I think <code class="docutils literal"><span class="pre">defer</span></code> is a reasonable name for this, although we might also
consider <code class="docutils literal"><span class="pre">finally</span></code>.  I&#8217;ll use <code class="docutils literal"><span class="pre">defer</span></code> in the rest of this proposal.</p>
<p><code class="docutils literal"><span class="pre">defer</span></code> may be followed by an arbitrary statement.  The compiler
should reject an action that might terminate early, whether by
throwing or with <code class="docutils literal"><span class="pre">return</span></code>, <code class="docutils literal"><span class="pre">break</span></code>, or <code class="docutils literal"><span class="pre">continue</span></code>.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre>if exists(filename) {
  let file = open(filename, O_READ)
  defer close(file)

  while let line = try file.readline() {
    ...
  }

  // close occurs here, at the end of the formal scope.
}
</pre></div>
</div>
<p>We should consider providing a convenient way to mark that a <code class="docutils literal"><span class="pre">defer</span></code>
action should only be taken if an error is thrown.  This is a
convenient shorthand for controlling the action with a flag that&#8217;s
only set to true at the end of an operation.  The flag approach is
often more useful, since it allows the action to be taken for <em>any</em>
early exit, e.g. a <code class="docutils literal"><span class="pre">return</span></code>, not just for error propagation.</p>
</div>
<div class="section" id="using">
<h4><code class="docutils literal"><span class="pre">using</span></code><a class="headerlink" href="#using" title="Permalink to this headline">¶</a></h4>
<p>Swift should consider providing a <code class="docutils literal"><span class="pre">using</span></code> statement which acquires a
resource, holds it for a fixed period of time, optionally binds it to
a name, and then releases it whenever the controlled statement exits.</p>
<p><code class="docutils literal"><span class="pre">using</span></code> has many similarities to <code class="docutils literal"><span class="pre">defer</span></code>.  It does not subsume
<code class="docutils literal"><span class="pre">defer</span></code>, which is useful for many ad-hoc and tokenless clean-ups.  But
it is convenient for the common pattern of a type-directed clean-up.</p>
<p>We do not expect this feature to be necessary in the first release.</p>
</div>
</div>
<div class="section" id="c-and-objective-c-interoperation">
<h3>C and Objective-C Interoperation<a class="headerlink" href="#c-and-objective-c-interoperation" title="Permalink to this headline">¶</a></h3>
<p>It&#8217;s of paramount importance that Swift&#8217;s error model interact as
cleanly with Objective-C APIs as we can make it.</p>
<p>In general, we want to try to import APIs that produce errors as
throwing; if this fails, we&#8217;ll import the API as an ordinary
non-throwing function.  This is a safe approach only under the
assumption that importing the function as throwing will require
significant changes to the call.  That is, if a developer writes code
assuming that an API will be imported as throwing, but in fact Swift
fails to import the API that way, it&#8217;s important that the code doesn&#8217;t
compile.</p>
<p>Fortunately, this is true for the common pattern of an error
out-parameter: if Swift cannot import the function as throwing, it
will leave the out-parameter in place, and the compiler will complain
if the developer fails to pass an error argument.  However, it is
possible to imagine APIs where the &#8220;meat&#8221; of the error is returned in
a different way; consider a POSIX API that simply sets <code class="docutils literal"><span class="pre">errno</span></code>.  Great
care would need to be taken when such an API is only partially
imported as throwing.</p>
<p>Let&#8217;s wade into the details.</p>
<div class="section" id="id6">
<h4>Error types<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal"><span class="pre">NSError</span></code> and <code class="docutils literal"><span class="pre">CFError</span></code> should implement the <code class="docutils literal"><span class="pre">ErrorType</span></code> protocol.  It
should be possible to turn an arbitrary Swift <code class="docutils literal"><span class="pre">enum</span></code> that conforms to
<code class="docutils literal"><span class="pre">ErrorType</span></code> into an <code class="docutils literal"><span class="pre">NSError</span></code> by using the qualified type name as the
domain key, the enumerator as the error code, and turning the payload
into user data.</p>
<p>Recognizing system enums as error domains is a matter of annotation.
Most likely, Swift will just special-case a few common domains in
the first release.</p>
</div>
<div class="section" id="objective-c-method-error-patterns">
<h4>Objective-C method error patterns<a class="headerlink" href="#objective-c-method-error-patterns" title="Permalink to this headline">¶</a></h4>
<p>The most common error pattern in ObjC by far is for a method to have
an autoreleased <code class="docutils literal"><span class="pre">NSError**</span></code> out-parameter.  We don&#8217;t currently propose
automatically importing anything as <code class="docutils literal"><span class="pre">throws</span></code> when it lacks such a
parameter.</p>
<p>If any APIs take an <code class="docutils literal"><span class="pre">NSError**</span></code> and <em>don&#8217;t</em> intend for it to be an
error out-parameter, they will almost certainly need it to be marked.</p>
<div class="section" id="detecting-an-error">
<h5>Detecting an error<a class="headerlink" href="#detecting-an-error" title="Permalink to this headline">¶</a></h5>
<p>Many of these methods have some sort of significant result which
is used for testing whether an error occurred:</p>
<ul>
<li><p class="first">The most common pattern is a <code class="docutils literal"><span class="pre">BOOL</span></code> result, where a false value
means an error occurred.  This seems unambiguous.</p>
<p>Swift should import these methods as if they&#8217;d returned <code class="docutils literal"><span class="pre">Void</span></code>.</p>
</li>
<li><p class="first">Also common is a pointer result, where a <code class="docutils literal"><span class="pre">nil</span></code> result usually means
an error occurred.</p>
<p>I&#8217;ve been told that there are some exceptions to this rule, where a
<code class="docutils literal"><span class="pre">nil</span></code> result is valid and the caller is apparently meant to check
for a non-<code class="docutils literal"><span class="pre">nil</span></code> error.  I haven&#8217;t been able to find any such APIs
in Cocoa, though; the claimed APIs I&#8217;ve been referred to do have
nullable results, but returned via out-parameters with a <cite>BOOL</cite>
formal result.  So it seems to be a sound policy decision for
Objective-C that <code class="docutils literal"><span class="pre">nil</span></code> results are errors by default.  CF might be
a different story, though.</p>
<p>When a <code class="docutils literal"><span class="pre">nil</span></code> result implies that an error has occurred, Swift
should import the method as returning a non-optional result.</p>
</li>
<li><p class="first">A few CF APIs return <code class="docutils literal"><span class="pre">void</span></code>.  As far as I can tell, for all of
these, the caller is expected to check for a non-<code class="docutils literal"><span class="pre">nil</span></code> error.</p>
</li>
</ul>
<p>For other sentinel cases, we can consider adding a new clang attribute
to indicate to the compiler what the sentinel is:</p>
<ul class="simple">
<li>There are several APIs returning <code class="docutils literal"><span class="pre">NSInteger</span></code> or <code class="docutils literal"><span class="pre">NSUInteger</span></code>.  At
least some of these return 0 on error, but that doesn&#8217;t seem like a
reasonable general assumption.</li>
<li><code class="docutils literal"><span class="pre">AVFoundation</span></code> provides a couple methods returning
<code class="docutils literal"><span class="pre">AVKeyValueStatus</span></code>.  These produce an error if the API returned
<code class="docutils literal"><span class="pre">AVKeyValueStatusFailed</span></code>, which, interestingly enough, is not the
zero value.</li>
</ul>
<p>The clang attribute would specify how to test the return value for
an error.  For example:</p>
<div class="highlight-python"><div class="highlight"><pre>+ (NSInteger)writePropertyList:(id)plist
                      toStream:(NSOutputStream *)stream
                        format:(NSPropertyListFormat)format
                       options:(NSPropertyListWriteOptions)opt
                         error:(out NSError **)error
  NS_ERROR_RESULT(0)

- (AVKeyValueStatus)statusOfValueForKey:(NSString *)key
                                  error:(NSError **)
  NS_ERROR_RESULT(AVKeyValueStatusFailed);
</pre></div>
</div>
<p>We should also provide a Clang attribute which specifies that the
correct way to test for an error is to check the out-parameter.  Both
of these attributes could potentially be used by the static analyzer,
not just Swift.  (For example, they could try to detect an invalid
error check.)</p>
<p>A constant value would be sufficient for the cases I&#8217;ve seen, but if
the argument has to generalized to a simple expression, that&#8217;s still
feasible.</p>
</div>
<div class="section" id="the-error-parameter">
<h5>The error parameter<a class="headerlink" href="#the-error-parameter" title="Permalink to this headline">¶</a></h5>
<p>The obvious import rule for Objective-C methods with <code class="docutils literal"><span class="pre">NSError**</span></code>
out-parameters is to simply mark them <code class="docutils literal"><span class="pre">throws</span></code> and remove the selector
clause corresponding to the out-parameter.  That is, a method like
this one from <code class="docutils literal"><span class="pre">NSAttributedString</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>- (NSData *)dataFromRange:(NSRange)range
       documentAttributes:(NSDictionary *)dict
                    error:(NSError **)error;
</pre></div>
</div>
<p>would be imported as:</p>
<div class="highlight-python"><div class="highlight"><pre>func dataFromRange(range: NSRange,
                   documentAttributes dict: NSDictionary) throws -&gt; NSData
</pre></div>
</div>
<p>However, applying this rule haphazardly causes problems for
Objective-C interoperation, because multiple methods can be imported
the same way.  The model is far more comprehensible to both compiler
and programmer if the original Objective-C declaration can be
unambiguously reconstructed from a Swift declaration.</p>
<p>There are two sources of this ambiguity:</p>
<ul class="simple">
<li>The error parameter could have appeared at an arbitrary position in
the selector; that is, both <code class="docutils literal"><span class="pre">foo:bar:error:</span></code> and <code class="docutils literal"><span class="pre">foo:error:bar:</span></code>
would appear as <code class="docutils literal"><span class="pre">foo:bar:</span></code> after import.</li>
<li>The error parameter could have had an arbitrary selector chunk;
that is, both <code class="docutils literal"><span class="pre">foo:error:</span></code> and <code class="docutils literal"><span class="pre">foo:withError:</span></code> would appear as
<code class="docutils literal"><span class="pre">foo:</span></code> after import.</li>
</ul>
<p>To allow reconstruction, then, we should only apply the rule when the
error parameter is the last parameter and the corresponding selector
is either <code class="docutils literal"><span class="pre">error:</span></code> or the first chunk.  Empirically, this seems to do
the right thing for all but two sets of APIs in the public API:</p>
<ul>
<li><p class="first">The <code class="docutils literal"><span class="pre">ISyncSessionDriverDelegate</span></code> category on <code class="docutils literal"><span class="pre">NSObject</span></code> declares
half-a-dozen methods like this:</p>
<div class="highlight-python"><div class="highlight"><pre>- (BOOL)sessionDriver:(ISyncSessionDriver *)sender
        didRegisterClientAndReturnError:(NSError **)outError;
</pre></div>
</div>
<p>Fortunately, these delegate methods were all deprecated in Lion,
and Swift currently doesn&#8217;t even import deprecated methods.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">NSFileCoordinator</span></code> has half a dozen methods where the <code class="docutils literal"><span class="pre">error:</span></code>
clause is second-to-last, followed by a block argument.  These
methods are not deprecated as far as I know.</p>
</li>
</ul>
<p>Of course, user code could also fail to follow this rule.</p>
<p>I think it&#8217;s acceptable for Swift to just not import these methods as
<code class="docutils literal"><span class="pre">throws</span></code>, leaving the original error parameter in place exactly as if
they didn&#8217;t follow an intelligible pattern in the header.</p>
<p>This translation rule would import methods like this one from
<code class="docutils literal"><span class="pre">NSDocument</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>- (NSDocument *)duplicateAndReturnError:(NSError **)outError;
</pre></div>
</div>
<p>like so:</p>
<div class="highlight-python"><div class="highlight"><pre>func duplicateAndReturnError() throws -&gt; NSDocument
</pre></div>
</div>
<p>Leaving the <code class="docutils literal"><span class="pre">AndReturnError</span></code> bit around feels unfortunate to me, but I
don&#8217;t see what we could do without losing the ability to automatically
reconstruct the Objective-C signature.  This pattern is common but
hardly universal; consider this method from <code class="docutils literal"><span class="pre">NSManagedObject</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>- (BOOL)validateForDelete:(NSError **)error;
</pre></div>
</div>
<p>This would be imported as:</p>
<div class="highlight-python"><div class="highlight"><pre>func validateForDelete() throws
</pre></div>
</div>
<p>This seems like a really nice import.</p>
</div>
</div>
<div class="section" id="corefoundation-functions">
<h4>CoreFoundation functions<a class="headerlink" href="#corefoundation-functions" title="Permalink to this headline">¶</a></h4>
<p>CF APIs use <code class="docutils literal"><span class="pre">CFErrorRef</span></code> pretty reliably, but there are two problems.</p>
<p>First, we&#8217;re not as confident about the memory management rules for
the error object.  Is it always returned at +1?</p>
<p>Second, I&#8217;m not as confident about how to detect that an error has
occurred:</p>
<ul class="simple">
<li>There are a lot of functions that return <code class="docutils literal"><span class="pre">Boolean</span></code> or <code class="docutils literal"><span class="pre">bool</span></code>.  It&#8217;s
likely that these functions consistently use the same convention as
Objective-C: false means error.</li>
<li>Similarly, there are many functions that return an object reference.
Again, we&#8217;d need a policy on whether to treat <code class="docutils literal"><span class="pre">nil</span></code> results as
errors.</li>
<li>There are a handful of APIs that return a <code class="docutils literal"><span class="pre">CFIndex</span></code>, all with
apparently the same rule that a zero value means an error.  (These
are serialization APIs, so writing nothing seems like a reasonable
error.)  But just like Objective-C, that does not seem like a
reasonable default assumption.</li>
<li><code class="docutils literal"><span class="pre">ColorSyncProfile</span></code> has several related functions that return
<code class="docutils literal"><span class="pre">float</span></code>!  These are both apparently meant to be checked by testing
whether the error result was filled in.</li>
</ul>
<p>There are also some APIs that do not use <code class="docutils literal"><span class="pre">CFErrorRef</span></code>.  For example,
most of the <code class="docutils literal"><span class="pre">CVDisplayLink</span></code> APIs in CoreVideo returns their own
<code class="docutils literal"><span class="pre">CVReturn</span></code> enumeration, many with more than one error value.
Obviously, these will not be imported as throwing unless CoreVideo
writes an overlay.</p>
</div>
<div class="section" id="other-c-apis">
<h4>Other C APIs<a class="headerlink" href="#other-c-apis" title="Permalink to this headline">¶</a></h4>
<p>In principle, we could import POSIX functions into Swift as throwing
functions, filling in the error from <code class="docutils literal"><span class="pre">errno</span></code>.  It&#8217;s nearly impossible
to imagine doing this with an automatic import rule, however; much
more likely, we&#8217;d need to wrap them all in an overlay.</p>
</div>
</div>
<div class="section" id="id7">
<h3>Implementation design<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>Error propagation for the kinds of explicit, typed errors that I&#8217;ve
been focusing on should be handled by implicit manual propagation.  It
would be good to bias the implementation somewhat towards the
non-error path, perhaps by moving error paths to the ends of functions
and so on, and perhaps even by processing cleanups with an
interpretive approach instead of directly inlining that code, but we
should not bias so heavily as to seriously compromise performance.  In
other words, we should not use table-based unwinding.</p>
<p>Error propagation for universal errors should be handled by
table-based unwinding.  <code class="docutils literal"><span class="pre">catch</span></code> handlers can catch both, mapping
unwind exceptions to <code class="docutils literal"><span class="pre">ErrorType</span></code> values as necessary.  With a
carefully-designed interpretation function aimed to solve the specific
needs of Swift, we can avoid most of the code-size impact by shifting
it to the unwind tables, which needn&#8217;t ever be loaded in the common
case.</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Generics.html" class="btn btn-neutral float-right" title="Generics in Swift" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="ErrorHandling.html" class="btn btn-neutral" title="Error Handling in Swift 2.0" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright apple.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.1.9',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>