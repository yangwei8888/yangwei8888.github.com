<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="terry yang's blog | java | scala | bi" />



  <meta name="keywords" content="Hexo,next" />



  <link rel="alternate" href="/atom.xml" title="yosita" type="application/atom+xml" />



  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="terry yang&apos;s blog | java | scala | bi">
<meta property="og:type" content="website">
<meta property="og:title" content="yosita">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="yosita">
<meta property="og:description" content="terry yang&apos;s blog | java | scala | bi">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="yosita">
<meta name="twitter:description" content="terry yang&apos;s blog | java | scala | bi">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>

  <title> yosita </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  

  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?953e46480b0a75d01aaf6d872cc77099";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">yosita</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/python_start/" itemprop="url">
                Python 开发指南
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/python_start/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/python_start/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h4 id="版本依赖">版本依赖</h4><p>目前 Python SDK 只支持 Python 2，Python 3 的支持正在开发中。</p>
<h4 id="使用_virtualenv">使用 virtualenv</h4><p>如果您不需要使用 <a href="https://virtualenv.pypa.io/" target="_blank" rel="external">virtualenv</a>，可以跳过这一步。</p>
<p>使用 <a href="https://virtualenv.pypa.io/" target="_blank" rel="external">virtualenv</a> 可以创建一个与系统隔离的 Python 环境，在其中安装的第三方模块版本不会与系统自带的或者其他项目中的模块冲突。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">virtualenv leancloud-demo</span><br><span class="line"><span class="built_in">cd</span> leancloud-demo</span><br><span class="line"><span class="built_in">source</span> bin/activate</span><br></pre></td></tr></table></figure>
<p>之后您在当前 shell 中安装的第三方模块，都只会保存在当前项目目录下。</p>
<p>virtualenv 的更详细使用方法请参考<a href="https://virtualenv.pypa.io/en/latest/" target="_blank" rel="external">官方文档</a>。</p>
<h4 id="安装">安装</h4><p>可以选择使用 <a href="https://pip.pypa.io" target="_blank" rel="external">pip</a> 或者 <a href="https://pythonhosted.org/setuptools/easy_install.html" target="_blank" rel="external">easy_install</a> 来安装 LeanCloud SDK：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install leancloud-sdk</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">easy_install leancloud-sdk</span><br></pre></td></tr></table></figure>
<h4 id="初始化">初始化</h4><p>创建应用后，可以在 <a href="/app.html?appid=#/key">控制台 - 应用设置</a> 里面找到应用对应的 id 和 key。</p>
<p>在使用 Leancloud Python SDK 之前，需要使用 id 和 key 对 SDK 进行初始化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> leancloud</span><br><span class="line"></span><br><span class="line">leancloud.init(<span class="string">'&#123;&#123;appid&#125;&#125;'</span>, <span class="string">'&#123;&#123;appkey&#125;&#125;'</span>)</span><br></pre></td></tr></table></figure>
<h4 id="使用">使用</h4><p>接下来就可以存储数据了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> leancloud <span class="keyword">import</span> Object</span><br><span class="line"><span class="keyword">from</span> leancloud <span class="keyword">import</span> LeanCloudError</span><br><span class="line"></span><br><span class="line">TestObject= Object.extend(<span class="string">'TestObject'</span>)</span><br><span class="line">test_object = TestObject()</span><br><span class="line">test_object.set(<span class="string">'foo'</span>, <span class="string">'bar'</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    test_object.save()</span><br><span class="line"><span class="keyword">except</span> LeanCloudError, e:</span><br><span class="line">    <span class="keyword">print</span> e</span><br></pre></td></tr></table></figure>
<p>大功告成，访问 <a href="/data.html?appid=#/TestObject">控制台 - 数据管理</a> 可以看到上面创建的 TestObject 的相关数据。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/realtime_rest_api/" itemprop="url">
                实时通信 REST API 使用指南
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/realtime_rest_api/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/realtime_rest_api/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="实时通信_REST_API_使用指南">实时通信 REST API 使用指南</h1><h2 id="对话数据操作">对话数据操作</h2><p>你可以通过 REST API 对对话（相应的聊天室、群组或单聊等）进行操作，例如提前创建聊天室，关联聊天室到其他数据实体。LeanCloud 实时通信系统采用透明的设计，对话数据在 LeanCloud 系统中是普通的数据表，表名为 <code>_Conversation</code>，你可以直接调用 <a href="./rest_api.html#对象-1">数据存储相关的 API 进行数据操作</a>。<code>_Conversation</code> 表 包含一些内置的关键字段定义了对话的属性、成员等，你可以在 <a href="./realtime_v2.html#对话_Conversation_">实时通信概览 - 对话</a> 了解。</p>
<h3 id="创建一个对话">创建一个对话</h3><p>创建一个对话即在 <code>_Conversation</code> 表中创建一条记录。对于没有使用过实时通信服务的新用户， <code>_Conversation</code> 表会在第一条记录创建后出现。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST \</span><br><span class="line">  -H <span class="string">"X-LC-Id: &#123;&#123;appid&#125;&#125;"</span> \</span><br><span class="line">  -H <span class="string">"X-LC-Key: &#123;&#123;appkey&#125;&#125;"</span> \</span><br><span class="line">  -H <span class="string">"Content-Type: application/json"</span> \</span><br><span class="line">  <span class="operator">-d</span> <span class="string">'&#123;"name":"My Private Room","m": ["BillGates", "SteveJobs"]&#125;'</span> \</span><br><span class="line">  https://api.leancloud.cn/<span class="number">1.1</span>/classes/_Conversation</span><br></pre></td></tr></table></figure>
<p>上面的例子会创建一个最简单的对话，包括两个 client ID 为 BillGates 和 SteveJobs 的初始成员。对话创建成功会返回 objectId，即实时通信中的对话 ID，客户端就可以通过这个 ID 发送消息了。</p>
<p>常见的开放聊天室的场景，需要通过 REST API 预先创建聊天室，并把对话 ID 与应用内的某个对象关联（如视频、比赛等）。创建开放聊天室只需要包含一个 <strong>tr</strong> 参数，设置为 true 即可。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST \</span><br><span class="line">  -H <span class="string">"X-LC-Id: &#123;&#123;appid&#125;&#125;"</span> \</span><br><span class="line">  -H <span class="string">"X-LC-Key: &#123;&#123;appkey&#125;&#125;"</span> \</span><br><span class="line">  -H <span class="string">"Content-Type: application/json"</span> \</span><br><span class="line">  <span class="operator">-d</span> <span class="string">'&#123;"name": "OpenConf","tr": true&#125;'</span> \</span><br><span class="line">  https://api.leancloud.cn/<span class="number">1.1</span>/classes/_Conversation</span><br></pre></td></tr></table></figure>
<p>系统对话通常也需要通过 REST API 预先创建，创建时需要设置关键的 <code>sys</code> 属性：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST \</span><br><span class="line">  -H <span class="string">"X-LC-Id: &#123;&#123;appid&#125;&#125;"</span> \</span><br><span class="line">  -H <span class="string">"X-LC-Key: &#123;&#123;appkey&#125;&#125;"</span> \</span><br><span class="line">  -H <span class="string">"Content-Type: application/json"</span> \</span><br><span class="line">  <span class="operator">-d</span> <span class="string">'&#123;"name": "Notification Channel","sys": true&#125;'</span> \</span><br><span class="line">  https://api.leancloud.cn/<span class="number">1.1</span>/classes/_Conversation</span><br></pre></td></tr></table></figure>
<h3 id="增删普通对话成员">增删普通对话成员</h3><p>你可以通过 REST API 操作对话数据的 <strong>m</strong> 字段来实现成员的增删。m  字段是一个数组字段，使用数组的操作符进行修改。</p>
<p>增加一个 client id 为 LarryPage 的用户到已有（以对话 id 5552c0c6e4b0846760927d5a 为例）对话：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT \</span><br><span class="line">  -H <span class="string">"X-LC-Id: &#123;&#123;appid&#125;&#125;"</span> \</span><br><span class="line">  -H <span class="string">"X-LC-Key: &#123;&#123;appkey&#125;&#125;"</span> \</span><br><span class="line">  -H <span class="string">"Content-Type: application/json"</span> \</span><br><span class="line">  <span class="operator">-d</span> <span class="string">'&#123;"m": &#123;"__op":"AddUnique","objects":["LarryPage"]&#125;&#125;'</span> \</span><br><span class="line">  https://api.leancloud.cn/<span class="number">1.1</span>/classes/_Conversation/<span class="number">5552</span>c0c6e4b0846760927d5a</span><br></pre></td></tr></table></figure>
<p>将不再活跃的 SteveJobs 清除出对话（以对话 id 5552c0c6e4b0846760927d5a 为例）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT \</span><br><span class="line">  -H <span class="string">"X-LC-Id: &#123;&#123;appid&#125;&#125;"</span> \</span><br><span class="line">  -H <span class="string">"X-LC-Key: &#123;&#123;appkey&#125;&#125;"</span> \</span><br><span class="line">  -H <span class="string">"Content-Type: application/json"</span> \</span><br><span class="line">  <span class="operator">-d</span> <span class="string">'&#123;"m": &#123;"__op":"Remove","objects":["SteveJobs"]&#125;&#125;'</span> \</span><br><span class="line">  https://api.leancloud.cn/<span class="number">1.1</span>/classes/_Conversation/<span class="number">5552</span>c0c6e4b0846760927d5a</span><br></pre></td></tr></table></figure>
<p>对 <code>_Conversation</code> 表的查询等其他操作与普通表完全一致，可以参考 <a href="./rest_api.html#查询">REST API - 查询</a> 的相应说明，这里不再赘述。</p>
<h2 id="获取聊天记录">获取聊天记录</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET \</span><br><span class="line">  -H <span class="string">"X-LC-Id: &#123;&#123;appid&#125;&#125;"</span> \</span><br><span class="line">  -H <span class="string">"X-LC-Key: &#123;&#123;appkey&#125;&#125;"</span> \</span><br><span class="line">  https://leancloud.cn/<span class="number">1.1</span>/rtm/messages/logs</span><br></pre></td></tr></table></figure>
<h3 id="获取某个对话的聊天记录">获取某个对话的聊天记录</h3><table>
<thead>
<tr>
<th>参数</th>
<th>约束</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>convid</td>
<td><strong>必须</strong></td>
<td>对话 id</td>
</tr>
<tr>
<td>max_ts</td>
<td>可选</td>
<td>查询起始的时间戳，返回小于这个时间(不包含)的记录。默认是当前时间。</td>
</tr>
<tr>
<td>msgid</td>
<td>可选</td>
<td>起始的消息 id，与 max_ts 一起作为查询的起点。</td>
</tr>
<tr>
<td>limit</td>
<td>可选</td>
<td>返回条数限制，可选，默认 100 条，最大 1000 条。</td>
</tr>
<tr>
<td>peerid</td>
<td>可选</td>
<td>查看者id（签名参数）</td>
</tr>
<tr>
<td>nonce</td>
<td>可选</td>
<td>签名随机字符串（签名参数）</td>
</tr>
<tr>
<td>signature_ts</td>
<td>可选</td>
<td>签名时间戳（签名参数）</td>
</tr>
<tr>
<td>signature</td>
<td>可选</td>
<td>签名时间戳（签名参数）</td>
</tr>
</tbody>
</table>
<p>为了保证获取聊天记录的安全性，可以开启签名认证（控制台 &gt; <strong>应用选项</strong> &gt; <strong>聊天推送</strong> &gt;<br><strong>聊天记录查询签名认证</strong>）。了解更详细的签名规则请参考 <a href="realtime_v2.html#开启对话签名">聊天签名方法</a>。签名参数仅在开启应用选项后有效，如果没有开启选项，就不需要传签名参数。</p>
<p>签名采用 Hmac-sha1 算法，输出字节流的十六进制字符串 (hex dump)，签名的 key 必须是应用的 master key，签名的消息格式如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">appid:</span><span class="string">peerid:</span><span class="string">convid:</span><span class="string">nonce:</span>signature_ts</span><br></pre></td></tr></table></figure>
<p>返回数据格式，JSON 数组，按消息记录从新到旧排序。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    "<span class="attribute">timestamp</span>": <span class="value"><span class="number">1408008498571</span></span>,</span><br><span class="line">    "<span class="attribute">conv-id</span>":   <span class="value"><span class="string">"219946ef32e40c515d33ae6975a5c593"</span></span>,</span><br><span class="line">    "<span class="attribute">data</span>":      <span class="value"><span class="string">"今天天气不错！"</span></span>,</span><br><span class="line">    "<span class="attribute">from</span>":      <span class="value"><span class="string">"u111872755_9d0461adf9c267ae263b3742c60fa"</span></span>,</span><br><span class="line">    "<span class="attribute">msg-id</span>":    <span class="value"><span class="string">"vdkGm4dtRNmhQ5gqUTFBiA"</span></span>,</span><br><span class="line">    "<span class="attribute">is-conv</span>":   <span class="value"><span class="literal">true</span></span>,</span><br><span class="line">    "<span class="attribute">is-room</span>":   <span class="value"><span class="literal">false</span></span>,</span><br><span class="line">    "<span class="attribute">to</span>":        <span class="value"><span class="string">"5541c02ce4b0f83f4d44414e"</span></span>,</span><br><span class="line">    "<span class="attribute">bin</span>":       <span class="value"><span class="literal">false</span></span>,</span><br><span class="line">    "<span class="attribute">from-ip</span>":   <span class="value"><span class="string">"202.117.15.217"</span></span><br><span class="line">  </span>&#125;,</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>以上返回字段的说明如下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>conv-id</td>
<td>用于查询的对话 id</td>
</tr>
<tr>
<td>from</td>
<td>消息来自 id</td>
</tr>
<tr>
<td>data</td>
<td>消息内容</td>
</tr>
<tr>
<td>timestamp</td>
<td>消息到达服务器的 Unix 时间戳（毫秒）</td>
</tr>
<tr>
<td>msg-id</td>
<td>消息 id</td>
</tr>
<tr>
<td>is-conv</td>
<td>是否是 v2 中对话模型的消息</td>
</tr>
<tr>
<td>from-ip</td>
<td>消息的来源 IP</td>
</tr>
<tr>
<td>ack-at</td>
<td>消息接收者返回的确认到达服务器的 Unix 时间戳（毫秒）</td>
</tr>
</tbody>
</table>
<h3 id="获取某个用户发送的聊天记录">获取某个用户发送的聊天记录</h3><p>此接口仅支持 master key <a href="rest_api.html#更安全的鉴权方式">鉴权认证</a>，建议仅在服务端使用。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>约束</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>from</td>
<td><strong>必须</strong></td>
<td>发送人 id</td>
</tr>
<tr>
<td>max_ts</td>
<td>可选</td>
<td>查询起始的时间戳，返回小于这个时间（不包含）的记录。默认是当前时间。</td>
</tr>
<tr>
<td>msgid</td>
<td>可选</td>
<td>起始的消息 id，与 max_ts 一起作为查询的起点。</td>
</tr>
<tr>
<td>limit</td>
<td>可选</td>
<td>返回条数限制，默认 100 条，最大 1000 条。</td>
</tr>
</tbody>
</table>
<h3 id="获取应用的所有聊天记录">获取应用的所有聊天记录</h3><p>此接口仅支持 master key <a href="rest_api.html#更安全的鉴权方式">鉴权认证</a>，建议仅在服务端使用</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>约束</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>max_ts</td>
<td>可选</td>
<td>查询起始的时间戳，返回小于这个时间（不包含）的记录。默认是 <strong>当前时间</strong>。</td>
</tr>
<tr>
<td>msgid</td>
<td>可选</td>
<td>起始的消息 id，与 max_ts 一起作为查询的起点。</td>
</tr>
<tr>
<td>limit</td>
<td>可选</td>
<td>返回条数限制，默认 100 条，最大 1000 条。</td>
</tr>
</tbody>
</table>
<h3 id="获取系统对话中某个特定用户与系统的消息记录">获取系统对话中某个特定用户与系统的消息记录</h3><p>获取系统对话中某个特定用户与系统的消息记录，需要按照一定的规则构建 <code>convid</code> 参数，构建规则为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">md5</span><span class="params">([系统对话 id] + <span class="string">":"</span> + [用户 Client ID])</span></span></span><br></pre></td></tr></table></figure>
<p>即将系统对话 ID 加半角冒号（<code>:</code>）与用户 ID 拼接后取 MD5 。</p>
<h2 id="删除聊天记录">删除聊天记录</h2><p>删除一条指定的聊天历史记录，必须采用 master key 授权，所以不建议在客户端使用此接口。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -X DELETE \</span><br><span class="line">  -H <span class="string">"X-LC-Id: &#123;&#123;appid&#125;&#125;"</span> \</span><br><span class="line">  -H <span class="string">"X-LC-Key: &#123;&#123;masterkey&#125;&#125;,master"</span> \</span><br><span class="line">  -G \</span><br><span class="line">  --data-urlencode <span class="string">'convid=219946ef32e40c515d33ae6975a5c593'</span> \</span><br><span class="line">  --data-urlencode <span class="string">'msgid=PESlY'</span> \</span><br><span class="line">  --data-urlencode <span class="string">'timestamp=1408008498571'</span> \</span><br><span class="line">  https://leancloud.cn/<span class="number">1.1</span>/rtm/messages/logs</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>convid</td>
<td>对话 id</td>
</tr>
<tr>
<td>msgid</td>
<td>消息 id</td>
</tr>
<tr>
<td>timestamp</td>
<td>消息时间戳</td>
</tr>
</tbody>
</table>
<h3 id="构建对话_ID">构建对话 ID</h3><p>实时通信中 convid 的构建规则为：目前版本中，convid 即对话 ID。</p>
<p>对早期版本来说：</p>
<ul>
<li>对点对点通信，convid 为所有对话参与者的 peer id <strong>排序</strong> 后以半角冒号（:）分隔，做 md5 所得。如对话参与者 peer id 为 <code>u1234</code> 和 <code>u0988</code>，那么对话 ID 为 <code>bcd26a54e98687390b0abb4d83683d4b</code>。</li>
<li>对群组功能，convid 即群组 ID。</li>
</ul>
<h2 id="取未读消息数">取未读消息数</h2><p>您可以从服务器端通过 REST API 调用获取实时通信中，某个 Client ID 的未读消息数。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET \</span><br><span class="line">  -H <span class="string">"X-LC-Id: &#123;&#123;appid&#125;&#125;"</span> \</span><br><span class="line">  -H <span class="string">"X-LC-Key: &#123;&#123;appkey&#125;&#125;"</span> \</span><br><span class="line">  https://leancloud.cn/<span class="number">1.1</span>/rtm/messages/unread/CLIENT_ID</span><br></pre></td></tr></table></figure>
<p>返回：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;"<span class="attribute">count</span>": <span class="value"><span class="number">4</span></span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过_REST_API_发消息">通过 REST API 发消息</h2><p>我们目前提供 REST API 允许向一个已有对话发送消息。</p>
<p><strong>注意</strong>，由于这个接口的管理性质，当你通过这个接口发送消息时，我们不会检查 <strong>from_peer</strong> 是否有权限给这个对话发送消息，而是统统放行，请谨慎使用这个接口。<br>如果你在应用中使用了我们内部定义的 <a href="./realtime_v2.html#消息_Message_">富媒体消息格式</a>，在发送消息时 <strong>message</strong> 字段需要遵守一定的格式要求，下文 <a href="./realtime_rest_api.html#富媒体消息格式说明">富媒体消息格式说明</a> 中将详细说明。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST \</span><br><span class="line">  -H <span class="string">"X-LC-Id: &#123;&#123;appid&#125;&#125;"</span> \</span><br><span class="line">  -H <span class="string">"X-LC-Key: &#123;&#123;masterkey&#125;&#125;,master"</span> \</span><br><span class="line">  -H <span class="string">"Content-Type: application/json"</span> \</span><br><span class="line">  <span class="operator">-d</span> <span class="string">'&#123;"from_peer": "1a", "message": "helloworld", "conv_id": "...", "transient": false&#125;'</span> \</span><br><span class="line">  https://leancloud.cn/<span class="number">1.1</span>/rtm/messages</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>约束</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>from_peer</td>
<td></td>
<td>消息的发件人 id</td>
</tr>
<tr>
<td>conv_id</td>
<td></td>
<td>发送到对话 id</td>
</tr>
<tr>
<td>transient</td>
<td>可选</td>
<td>是否为暂态消息（<strong>由于向后兼容的考虑，默认为 true</strong>，请注意设置这个值。）</td>
</tr>
<tr>
<td>message</td>
<td></td>
<td>消息内容（这里的消息内容的本质是字符串，但是我们对字符串内部的格式没有做限定，<br>理论上开发者可以随意发送任意格式，只要大小不超过 5 KB 限制即可。）</td>
</tr>
<tr>
<td>no_sync</td>
<td>可选</td>
<td>默认情况下消息会被同步给在线的 from_peer 用户的客户端，设置为 true 禁用此功能。</td>
</tr>
</tbody>
</table>
<p>返回说明：</p>
<p>默认情况下发送消息 API 使用异步的方式，调用后直接返回空结果 <code>{}</code>。</p>
<p>对早期版本的实时通信，可以使用 to_peers（数组）或 group_id 参数分别发消息到用户或群组。</p>
<h3 id="给系统对话发消息">给系统对话发消息</h3><p>利用 REST API 给通过系统对话给用户发消息时，除了 conv_id 需要设置为对应系统对话的 ID 以外，还需要设置 to_peers（数组）指定实际接收消息的 Client ID。</p>
<p>目前你可以在一次调用中传入至多 20 个 Client ID。</p>
<h3 id="富媒体消息格式说明">富媒体消息格式说明</h3><p>富媒体消息的参数格式相对于普通文本来说，仅仅是将 message 参数换成了一个 JSON <strong>字符串</strong>。</p>
<blockquote>
<p>注意：由于 LeanCloud 实时通信中所有的消息都是文本，所以这里发送 JSON 结构时<strong>需要首先序列化成字符串</strong>。</p>
</blockquote>
<h4 id="文本消息">文本消息</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -X <span class="keyword">POST</span> \</span><br><span class="line">  -<span class="keyword">H</span> <span class="string">"X-LC-Id: &#123;&#123;appid&#125;&#125;"</span> \</span><br><span class="line">  -<span class="keyword">H</span> <span class="string">"X-LC-Key: &#123;&#123;masterkey&#125;&#125;,master"</span> \</span><br><span class="line">  -<span class="keyword">H</span> <span class="string">"Content-Type: application/json"</span> \</span><br><span class="line">  -<span class="keyword">d</span> '&#123;<span class="string">"from_peer"</span>: <span class="string">"1a"</span>, <span class="string">"message"</span>: <span class="string">"&#123;\"</span>_lctype\<span class="string">":-1,\"</span>_lctext\<span class="string">":\"</span>这是一个纯文本消息\<span class="string">",\"</span>_lcattrs\<span class="string">":&#123;\"</span>a\<span class="string">":\"</span>_lcattrs 是用来存储用户自定义的一些键值对\<span class="string">"&#125;&#125;"</span>, <span class="string">"conv_id"</span>: <span class="string">"..."</span>, <span class="string">"transient"</span>: false&#125;' \</span><br><span class="line">  https:<span class="comment">//leancloud.cn/1.1/rtm/messages</span></span><br></pre></td></tr></table></figure>
<p>发送文本消息可以按照以上的格式进行，参数说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>约束</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>_lctype</code></td>
<td></td>
<td>富媒体消息的类型<br><br><pre>文本消息 -1<br>图像　　 -2<br>音频　　 -3<br>视频　　 -4<br>地理位置 -5<br>通用文件 -6</pre></td>
</tr>
<tr>
<td><code>_lctext</code></td>
<td></td>
<td>富媒体消息的文　字说明</td>
</tr>
<tr>
<td><code>_lcattrs</code></td>
<td></td>
<td>JSON 字符串，用来给开发者存储自定义属性。</td>
</tr>
<tr>
<td><code>_lcfile</code></td>
<td></td>
<td>如果是包含了文件（图像，音频，视频，通用文件）的消息 ，<br><code>_lcfile</code> 就包含了它的文件实体的相关信息。</td>
</tr>
<tr>
<td><code>url</code></td>
<td></td>
<td>文件在上传之后的物理地址</td>
</tr>
<tr>
<td><code>objId</code></td>
<td>可选</td>
<td>文件对应的在 _File 表里面的 objectId</td>
</tr>
<tr>
<td><code>metaData</code></td>
<td>可选</td>
<td>文件的元数据</td>
</tr>
</tbody>
</table>
<p><strong>以上参数针对所有富媒体消息都有效</strong>。</p>
<h4 id="图像消息">图像消息</h4><p>在新版本的聊天中，支持了内建的富媒体消息格式，以下针对整个消息体 JSON 格式化之后的参数说明，例如如下的图像消息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"_lctype"</span>:    -<span class="number">2</span>,                    <span class="comment">//必要参数</span></span><br><span class="line">  <span class="string">"_lctext"</span>:    <span class="string">"图像的文字说明"</span>,</span><br><span class="line">  <span class="string">"_lcattrs"</span>: &#123;</span><br><span class="line">    <span class="string">"a"</span>:        <span class="string">"_lcattrs 是用来存储用户自定义的一些键值对"</span>,</span><br><span class="line">    <span class="string">"b"</span>:        <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"c"</span>:        <span class="number">12</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"_lcfile"</span>: &#123;</span><br><span class="line">    <span class="string">"url"</span>:      <span class="string">"http://ac-p2bpmgci.clouddn.com/246b8acc-2e12-4a9d-a255-8d17a3059d25"</span>, <span class="comment">//必要参数</span></span><br><span class="line">    <span class="string">"objId"</span>:    <span class="string">"54699d87e4b0a56c64f470a4//文件对应的AVFile.objectId"</span>,</span><br><span class="line">    <span class="string">"metaData"</span>: &#123;</span><br><span class="line">      <span class="string">"name"</span>:   <span class="string">"IMG_20141223.jpeg"</span>,   <span class="comment">//图像的名称</span></span><br><span class="line">      <span class="string">"format"</span>: <span class="string">"png"</span>,                 <span class="comment">//图像的格式</span></span><br><span class="line">      <span class="string">"height"</span>: <span class="number">768</span>,                   <span class="comment">//单位：像素</span></span><br><span class="line">      <span class="string">"width"</span>:  <span class="number">1024</span>,                  <span class="comment">//单位：像素</span></span><br><span class="line">      <span class="string">"size"</span>:   <span class="number">18</span>                     <span class="comment">//单位：b</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是完整版的格式，如果想简单的发送一个 URL 可以参照以下格式：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">_lctype</span>": <span class="value">-<span class="number">2</span></span>,</span><br><span class="line">  "<span class="attribute">_lcfile</span>": <span class="value">&#123;</span><br><span class="line">    "<span class="attribute">url</span>":   <span class="value"><span class="string">"http://ac-p2bpmgci.clouddn.com/246b8acc-2e12-4a9d-a255-8d17a3059d25"</span></span><br><span class="line">  </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="音频消息">音频消息</h4><p>与图像类似，音频格式的完整格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"_lctype"</span>:      -<span class="number">3</span>,</span><br><span class="line">  <span class="string">"_lctext"</span>:      <span class="string">"这是一个音频消息"</span>,</span><br><span class="line">  <span class="string">"_lcattrs"</span>: &#123;</span><br><span class="line">    <span class="string">"a"</span>:          <span class="string">"_lcattrs 是用来存储用户自定义的一些键值对"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"_lcfile"</span>: &#123;</span><br><span class="line">    <span class="string">"url"</span>:        <span class="string">"http://ac-p2bpmgci.clouddn.com/246b8acc-2e12-4a9d-a255-8d17a3059d25"</span>,</span><br><span class="line">    <span class="string">"objId"</span>:      <span class="string">"54699d87e4b0a56c64f470a4//文件对应的AVFile.objectId"</span>,</span><br><span class="line">    <span class="string">"metaData"</span>: &#123;</span><br><span class="line">      <span class="string">"name"</span>:     <span class="string">"我的滑板鞋.wav"</span>,</span><br><span class="line">      <span class="string">"format"</span>:   <span class="string">"wav"</span>,</span><br><span class="line">      <span class="string">"duration"</span>: <span class="number">26</span>,    <span class="comment">//单位：秒</span></span><br><span class="line">      <span class="string">"size"</span>:     <span class="number">2738</span>   <span class="comment">//单位：b</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简略版：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">_lctype</span>": <span class="value">-<span class="number">3</span></span>,</span><br><span class="line">  "<span class="attribute">_lcfile</span>": <span class="value">&#123;</span><br><span class="line">    "<span class="attribute">url</span>":   <span class="value"><span class="string">"http://www.somemusic.com/x.mp3"</span></span><br><span class="line">  </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="视频消息">视频消息</h4><p>完整版：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"_lctype"</span>:      -<span class="number">4</span>,</span><br><span class="line">  <span class="string">"_lctext"</span>:      <span class="string">"这是一个视频消息"</span>,</span><br><span class="line">  <span class="string">"_lcattrs"</span>: &#123;</span><br><span class="line">    <span class="string">"a"</span>:          <span class="string">"_lcattrs 是用来存储用户自定义的一些键值对"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"_lcfile"</span>: &#123;</span><br><span class="line">    <span class="string">"url"</span>:        <span class="string">"http://ac-p2bpmgci.clouddn.com/99de0f45-171c-4fdd-82b8-1877b29bdd12"</span>,</span><br><span class="line">    <span class="string">"objId"</span>:      <span class="string">"54699d87e4b0a56c64f470a4"</span>, <span class="comment">//文件对应的 AVFile.objectId</span></span><br><span class="line">    <span class="string">"metaData"</span>: &#123;</span><br><span class="line">      <span class="string">"name"</span>:     <span class="string">"录制的视频.mov"</span>,</span><br><span class="line">      <span class="string">"format"</span>:   <span class="string">"avi"</span>,</span><br><span class="line">      <span class="string">"duration"</span>: <span class="number">168</span>,      <span class="comment">//单位：秒</span></span><br><span class="line">      <span class="string">"size"</span>:     <span class="number">18689</span>     <span class="comment">//单位：b</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简略版：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">_lctype</span>": <span class="value">-<span class="number">4</span></span>,</span><br><span class="line">  "<span class="attribute">_lcfile</span>": <span class="value">&#123;</span><br><span class="line">    "<span class="attribute">url</span>":   <span class="value"><span class="string">"http://www.somevideo.com/Y.flv"</span></span><br><span class="line">  </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="通用文件消息">通用文件消息</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">_lctype</span>": <span class="value">-<span class="number">6</span></span>,</span><br><span class="line">  "<span class="attribute">_lctext</span>": <span class="value"><span class="string">"这是一个普通文件类型"</span></span>,</span><br><span class="line">  "<span class="attribute">_lcattrs</span>": <span class="value">&#123;</span><br><span class="line">    "<span class="attribute">a</span>":     <span class="value"><span class="string">"_lcattrs 是用来存储用户自定义的一些键值对"</span></span><br><span class="line">  </span>&#125;</span>,</span><br><span class="line">  "<span class="attribute">_lcfile</span>": <span class="value">&#123;</span><br><span class="line">    "<span class="attribute">url</span>":   <span class="value"><span class="string">"http://www.somefile.com/jianli.doc"</span></span>,</span><br><span class="line">    "<span class="attribute">name</span>":  <span class="value"><span class="string">"我的简历.doc"</span></span>,</span><br><span class="line">    "<span class="attribute">size</span>":  <span class="value"><span class="number">18689</span>          //单位：b</span><br><span class="line">  </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>简略版：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">_lctype</span>": <span class="value">-<span class="number">6</span></span>,</span><br><span class="line">  "<span class="attribute">_lcfile</span>": <span class="value">&#123;</span><br><span class="line">    "<span class="attribute">url</span>":   <span class="value"><span class="string">"http://www.somefile.com/jianli.doc"</span></span>,</span><br><span class="line">    "<span class="attribute">name</span>":  <span class="value"><span class="string">"我的简历.doc"</span></span><br><span class="line">  </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="地理位置消息">地理位置消息</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">_lctype</span>":     <span class="value">-<span class="number">5</span></span>,</span><br><span class="line">  "<span class="attribute">_lctext</span>":     <span class="value"><span class="string">"这是一个地理位置消息"</span></span>,</span><br><span class="line">  "<span class="attribute">_lcattrs</span>": <span class="value">&#123;</span><br><span class="line">    "<span class="attribute">a</span>":         <span class="value"><span class="string">"_lcattrs 是用来存储用户自定义的一些键值对"</span></span><br><span class="line">  </span>&#125;</span>,</span><br><span class="line">  "<span class="attribute">_lcloc</span>": <span class="value">&#123;</span><br><span class="line">    "<span class="attribute">longitude</span>": <span class="value"><span class="number">23.2</span></span>,</span><br><span class="line">    "<span class="attribute">latitude</span>":  <span class="value"><span class="number">45.2</span></span><br><span class="line">  </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>简略版：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">_lctype</span>":     <span class="value">-<span class="number">5</span></span>,</span><br><span class="line">  "<span class="attribute">_lcloc</span>": <span class="value">&#123;</span><br><span class="line">    "<span class="attribute">longitude</span>": <span class="value"><span class="number">23.2</span></span>,</span><br><span class="line">    "<span class="attribute">latitude</span>":  <span class="value"><span class="number">45.2</span></span><br><span class="line">  </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取暂态对话的在线人数">获取暂态对话的在线人数</h2><p>你可以通过这个 API 获得暂态对话的在线人数。由于暂态对话没有成员列表支持，所以通常使用这个 API 获得当前的在线人数。出于性能的考虑，这个 API 有一定的缓存时间，仅用作粗略计数。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>gid</code></td>
<td>暂态对话的 id</td>
</tr>
</tbody>
</table>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET \</span><br><span class="line">  -H <span class="string">"X-LC-Id: &#123;&#123;appid&#125;&#125;"</span> \</span><br><span class="line">  -H <span class="string">"X-LC-Key: &#123;&#123;appkey&#125;&#125;"</span> \</span><br><span class="line">  https://leancloud.cn/<span class="number">1.1</span>/rtm/transient_group/onlines?gid=...</span><br></pre></td></tr></table></figure>
<p>返回：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;"<span class="attribute">result</span>": <span class="value"><span class="number">0</span></span>&#125;</span><br></pre></td></tr></table></figure>
<p>这个 API 也可以用于获取早期版本开放群组的在线人数。</p>
<h2 id="查询在线状态">查询在线状态</h2><p>在线状态查询 API 可以一次至多查询 20 个 Client ID 当前是否在线：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST \</span><br><span class="line">  -H <span class="string">"X-LC-Id: &#123;&#123;appid&#125;&#125;"</span> \</span><br><span class="line">  -H <span class="string">"X-LC-Key: &#123;&#123;masterkey&#125;&#125;,master"</span> \</span><br><span class="line">  -H <span class="string">"Content-Type: application/json"</span> \</span><br><span class="line">  <span class="operator">-d</span> <span class="string">'&#123;"peers": ["7u", "8b", "3h", ...]&#125;'</span> \</span><br><span class="line">  https://leancloud.cn/<span class="number">1.1</span>/rtm/online</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>peers</td>
<td>要查询的 ID 列表</td>
</tr>
</tbody>
</table>
<p>返回：</p>
<p>在线的 ID 列表</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;"<span class="attribute">results</span>":<span class="value">[<span class="string">"7u"</span>]</span>&#125;</span><br></pre></td></tr></table></figure>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/realtime_v2/" itemprop="url">
                实时通信服务总览
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/realtime_v2/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/realtime_v2/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="实时通信服务总览">实时通信服务总览</h1><p>实时通信服务是 LeanCloud 消息服务中的重要一环。你不但可以为应用加入实时聊天、私信等常用功能，还能实现游戏对战等实时互动功能。</p>
<p>目前，我们提供 Android、iOS、JavaScript、Windows Phone 四个主要平台的客户端 SDK，也提供了一些 Demo 帮助你快速入门：</p>
<ul>
<li><p>iOS 聊天应用：</p>
<ul>
<li><a href="https://github.com/leancloud/LeanMessage-Demo" target="_blank" rel="external">LeanMessageDemo iOS 版</a> (推荐)</li>
<li><a href="https://github.com/leancloud/leanchat-ios" target="_blank" rel="external">LeanChat iOS 版</a></li>
</ul>
</li>
<li><p>Android 聊天应用：</p>
<ul>
<li><a href="https://github.com/leancloud/LeanMessage-Demo" target="_blank" rel="external">LeanMessageDemo Android 版</a> (推荐)</li>
<li><a href="https://github.com/leancloud/leanchat-android" target="_blank" rel="external">LeanChat Android 版</a></li>
</ul>
</li>
<li><p>JavaScript 聊天应用</p>
<ul>
<li><a href="http://leancloud.github.io/js-realtime-sdk/demo/demo2/" target="_blank" rel="external">聊天 Demo</a> (可与 iOS/Android 版 LeanMessageDemo 通信)</li>
<li><a href="https://github.com/leancloud/js-realtime-sdk/tree/master/demo" target="_blank" rel="external">Demo 源码</a></li>
</ul>
</li>
</ul>
<p>关于这些项目的更多介绍、截图预览，可见 <a href="https://github.com/leancloud/leancloud-demos" target="_blank" rel="external">LeanCloud Demos</a> 。</p>
<p>目前新版本实时通信服务接口与旧版本并不兼容，不能互相通信。我们推荐所有新用户直接使用新版本。已有的旧版本用户可以继续参考 <a href="realtime.html">v1 版本文档</a>，我们仍然会对已有版本提供支持，并可能在未来提供无缝的迁移方案。已经发布的旧版本用户不会在功能、资源等各个方面受到任何影响，请放心使用。</p>
<h2 id="功能和特性">功能和特性</h2><p>LeanCloud 实时通信服务定位于完美实现网络层的通讯能力，其设计目标聚焦在：</p>
<ul>
<li><strong>快捷</strong><br><br>LeanCloud 云端要能支持上亿终端同时在线，并且消息传递延时需要严格控制在毫秒以内。</li>
<li><strong>灵活</strong><br><br>既要为完全依托 LeanCloud 平台的开发者考虑，也要为自有账户系统的用户设计：如果用户自己有完备的后台和账户系统，应该完全不用暴露内部数据就能使用我们的服务。而且，消息通知的手段要多样化，要让开发者有更多定制的能力。譬如聊天时对方不在线，应该能走「消息推送（Push Notification）」通道来及时提醒对方，并允许开发者对推送内容进行「私人定制」等等。</li>
<li><strong>安全</strong><br><br>除了简单的 appId 和 secretKey 之外，还应该赋予开发者更多的安全控制能力，来保证聊天通道的私密性。</li>
</ul>
<p>LeanCloud 实时通信服务的特性主要有：</p>
<ul>
<li><strong>与账户系统解耦合</strong><br><br>任何终端用户要加入聊天，只需要提供一个唯一标识自己的 clientId 即可，这样可以尽量避免自有账户系统的应用数据暴露，也可以促使通信服务专注做好底层的「信使」角色；</li>
<li><strong>多账号登录</strong><br><br>支持单个设备多个账号、单个账号多个设备同时登录，实时消息同步到所有设备。</li>
<li><strong>完整的聊天功能</strong><br><br>支持单聊、群聊、聊天室等不同聊天形式，并且具备完善的群组管理功能。</li>
<li><strong>支持富媒体、自定义类型消息</strong><br><br>支持文本、图片、音频、视频和地理位置等多种格式的富媒体消息，并且开发者还可方便地自定义扩展。</li>
<li><strong>离线消息推送</strong><br><br>消息在对方离线时，会自动通过 <a href="#离线推送通知">消息推送</a> 来及时送达对方，并且推送的消息文本可以由开发者自己控制。</li>
<li><strong>敏感词过滤</strong><br><br>实时消息中出现的敏感词，会自动被过滤掉；对于部分 VIP 客户，我们还允许自定义仅属于自己应用的敏感词列表。</li>
<li><strong>聊天记录保存在云端</strong><br><br>聊天记录自动保存在云端，允许开发者自由获取。</li>
<li><strong>第三方操作鉴权机制</strong><br><br>为了保证信道的安全，也给开发者最大的控制自由，我们提供了操作鉴权的机制：开发者使用自己的服务器来充当鉴权服务器，对消息流向进行「许可控制」。对于消息路由过程中的重要操作（譬如登录、开启对话、邀请加入群组、从群组踢出某人等），实时消息 SDK 在发送请求之前，会先到鉴权服务器获得操作签名，LeanCloud 云端会验证签名有效性并完全按照鉴权结果来对操作放行或拒绝。</li>
<li><strong>系统账号、机器人 Hook 和公众号后台</strong><br><br>支持系统中的小助手、机器人和公众号等场景，方便用户将实时通信系统和自己已有的系统无缝集成，支持二次开发机器人和消息后台。</li>
</ul>
<p>我们提供几个层面用户接口：</p>
<ul>
<li>原生的 Android、iOS、Windows Phone 和 Web (JavaScript) 语言的客户端 SDK</li>
<li>帮助开发者完成后台管理和服务器端相关功能的 REST API</li>
<li>部署在 LeanCloud 环境中的云引擎 Hook 便于开发者修改默认的系统行为</li>
<li>可以实时监控在线用户数、消息数的开发者控制台</li>
</ul>
<h2 id="核心概念">核心概念</h2><h3 id="ClientID、用户和登录">ClientID、用户和登录</h3><p>实时通信服务中的每一个终端称为一个 client。client 拥有一个在应用内唯一标识自己的 id。这个 id 由应用自己定义，必须是不多于 64 个字符的字符串。在大部分场合，client 都可以对应到应用中的某个「用户」，但是并不是只有真的用户才能做为 client，你完全可以把一个探测器当成一个 client，把它收集到的数据通过实时通信服务广播给更多「人」。</p>
<p>默认情况下，LeanCloud 通信服务允许一个 clientId 在多个不同的设备上登录，也允许一个设备上有多个 clientId 同时登录。如果使用场景中需要限制用户只在一处登录，可以在登录时明确设置当前设备的 tag，<br>当 LeanCloud 检测到同一个 tag 的设备出现冲突时，会自动踢出已存在设备上的登录状态。开发者可以根据自己的应用场景选择合适的使用方式。</p>
<p>使用 LeanCloud 实时通信 SDK 完成登录后，开发者就不必关心网络连接等状态，SDK 会自动为开发者保持连接状态，并根据网络状态自动重连。对于 Android 平台，我们使用常驻后台的服务保持在线状态；对于 iOS 和 Windows Phone<br>等平台，我们会在应用仍在前台时保持连接，当应用退到后台时，自动断开连接再激活平台原生的推送服务。</p>
<h4 id="在线状态">在线状态</h4><p>我们目前在 SDK 和 REST API 上提供主动查询的机制帮助开发者查询目标用户的在线状态。</p>
<h3 id="对话（Conversation）">对话（Conversation）</h3><p>用户登录之后，与其他人进行消息沟通，即为开启了一个对话（Conversation）。开始聊天之前，需要先创建或者加入一个对话，然后再邀请其他人进来，之后所有参与者在这个对话内进行交流。所有消息都是由某一个 client 发往一个「对话」。</p>
<p>系统每创建一个对话，就会在云端的 <code>_Conversation</code> 表中增加一条记录，可以进入控制台 &gt; <strong>应用</strong> &gt; <strong>存储</strong> &gt; <strong>数据</strong> 来查看该数据。</p>
<p><code>_Conversation</code> 表中字段名与对话的各个属性的对应关系为：</p>
<table>
<thead>
<tr>
<th>表字段</th>
<th>属性名</th>
<th>类型</th>
<th>约束</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>attr</strong></td>
<td>attributes</td>
<td>Object</td>
<td>可选</td>
<td>自定义属性，供开发者扩展使用。</td>
</tr>
<tr>
<td><strong>objectId</strong></td>
<td>conversationId</td>
<td>String</td>
<td></td>
<td>对话 id（只读），由云端为该对话生成的一个全局唯一的 id。</td>
</tr>
<tr>
<td><strong>c</strong></td>
<td>creator</td>
<td>String</td>
<td></td>
<td>对话创建者的 clientId（只读）</td>
</tr>
<tr>
<td><strong>lm</strong></td>
<td>lastMessageAt</td>
<td>Date</td>
<td></td>
<td>对话中最后一条消息的发送或接收时间</td>
</tr>
<tr>
<td><strong>m</strong></td>
<td>members</td>
<td>Array</td>
<td></td>
<td>对话的所有参与者</td>
</tr>
<tr>
<td><strong>mu</strong></td>
<td>mute</td>
<td>Array</td>
<td></td>
<td>将对话设为静音的参与者，这部分参与者不会收到推送。<br>（仅针对 iOS 以及 Windows Phone 用户有效）</td>
</tr>
<tr>
<td><strong>name</strong></td>
<td>name</td>
<td>String</td>
<td>可选</td>
<td>对话的名字，可为群组命名。</td>
</tr>
<tr>
<td><strong>tr</strong></td>
<td>transient</td>
<td>Boolean</td>
<td>可选</td>
<td>是否为暂态对话</td>
</tr>
<tr>
<td><strong>sys</strong></td>
<td>system</td>
<td>Boolean</td>
<td>可选</td>
<td>是否是系统对话</td>
</tr>
<tr>
<td><strong>unique</strong></td>
<td>unique</td>
<td>Boolean</td>
<td>可选</td>
<td>内部字段，标记根据成员原子创建的对话</td>
</tr>
</tbody>
</table>
<p>除了在各平台的 SDK 里面可以调用 API 创建对话外，我们也提供 <a href="./realtime_rest_api.html#通过_REST_API_创建_更新_删除对话数据">REST API</a> 可以让大家预先建立对话：对话的信息存储在 _Conversation 表中，你可以直接通过 <a href="./rest_api.html#%E5%AF%B9%E8%B1%A1-1">数据存储相关的 REST API</a> 对其进行操作。</p>
<p>这里要特别讨论一下<strong>单聊</strong>、<strong>群聊</strong>、<strong>聊天室</strong>、<strong>公众号</strong>等概念。</p>
<ul>
<li><strong>单聊</strong><br><br>就是两个 client 之间的对话，公开与否（能否让其他人看到这个对话存在）由应用层自己控制。一般而言，它是私密的，并且加入新的成员之后，会切换到新的对话（当然，也可以依然不离开当前对话，这一点还是由应用层来决定）。</li>
<li><strong>群聊</strong><br><br>就是两个（含）以上 client 之间的对话，一般而言，可以添加和删除成员，并且会赋予群聊一个名字。随着成员的减少，群聊也可能只有两个甚至一个成员（成员的多少并不是区分群聊和单聊的关键）。群聊能否公开（譬如支持名字搜索），由应用自己决定。</li>
<li><strong>聊天室</strong><br><br>很多应用使用的开放聊天室、弹幕、网页直播等都可以抽象成「聊天室」，它与群聊类似，都是多人参与的群组，但是也有一些区别：其一在于聊天室人数可能远大于群聊人数；其二在于聊天室强调的是在线人数，所有参与者进入聊天界面就算加入，关闭界面就算退出，所以聊天室不需要离线消息和推送通知，在线成员数比具体成员列表更有意义。</li>
<li><strong>公众号、机器人</strong><br><br>对全部或者部分用户可见（由应用开发者决定）的账号，开发者可以利用这个账号给用户发广播通知，用户也可以通过这个账号反馈内容给开发者，开发者可以在后台看到消息，也可以利用 API 或 Web Hook 将自己的业务系统集成进来。</li>
</ul>
<p>我们将以上场景抽象为「对话」这一概念，并分离出以下类型的对话：</p>
<h4 id="普通对话（Normal_Conversation）">普通对话（Normal Conversation）</h4><p>这是我们经常会用到的「对话」，单聊和群聊都通过它来实现。我们建议开发者将单聊/群聊、私密/公开等属性存入到 Conversation.attributes 之中，在应用层进行区别对待。</p>
<p>为了提高系统的灵活性，我们允许多个对话保持相同的成员，因此创建对话时系统总是默认创建新的对话。<br>如果开发者希望使用固定的对话，可以在创建对话时设置相应 SDK 上的 <code>unique</code> 选项，系统将查找对应成员相同且 <code>unique</code> 选项为 true 的对话，如果找到即返回已有的对话，如果没有则自动创建。<br>（注意，这种方式查找的对话仅对已经使用 <code>unique</code> 选项的对话有效，并且创建对话时不会触发 <code>_Conversation</code> 表在云引擎上的 <code>beforeSave</code> 等 hook）</p>
<h4 id="暂态对话（Transient_Conversation）">暂态对话（Transient Conversation）</h4><p>这是专门用来处理「聊天室」这种需求的。与普通对话一样，它也支持创建、加入/踢出成员等操作，消息记录会被保存并可供获取；但根据应用场景，暂态对话与普通对话在功能上存在一定的取舍，具体为：</p>
<ul>
<li>没有固定成员概念，加入即为成员，断线即为退出</li>
<li>暂态对话不支持查询成员列表，你可以通过相关 API 查询在线人数。</li>
<li>暂态对话不支持离线消息、离线推送通知等功能。</li>
<li>暂态对话没有成员加入、离开的通知。</li>
<li>一个用户一次登录只能加入一个暂态对话，加入新的暂态对话后会自动离开旧的暂态对话。</li>
<li>加入暂态对话后半小时内断网重连会自动加入原暂态对话，超过这个时间则需要重新加入。</li>
</ul>
<h4 id="系统对话（System_Conversation）">系统对话（System Conversation）</h4><p>这是用于实现机器人、公众号、服务账号等场景的对话，也可以用作发送应用内通知的通道。这种对话具有以下特点：</p>
<ul>
<li>在 <code>_Conversation</code> 表中，以 <code>sys</code> 为 <code>true</code> 来标记（<code>m</code>列在系统对话中将被忽略）</li>
<li>该对话没有成员，开发者维护用户和系统对话的订阅关系</li>
<li>开发者可以通过 REST API 以系统对话的渠道给指定的用户发消息</li>
<li>用户可以给系统对话发消息，消息和相关信息会存储在数据存储中的 <code>_SysMessage</code> 表，并不会被其他订阅用户收到</li>
<li>开发者可以配置 Web Hook 地址接收用户发给系统对话的消息，并利用 REST API 发消息回复</li>
<li>在 SDK 层面，系统对话的接口与普通对话完全一致</li>
</ul>
<h4 id="对话类型比较">对话类型比较</h4><table>
<thead>
<tr>
<th>功能点</th>
<th>普通对话</th>
<th>暂态对话</th>
<th>系统对话</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>表字段</strong><span>*</span></td>
<td>m</td>
<td>tr</td>
<td>sys</td>
</tr>
<tr>
<td><strong>成员管理</strong></td>
<td>成员体现在 m 字段上，<br>持久化保存</td>
<td>没有持久化的成员数据，<br>随时加入随时退出</td>
<td>没有成员概念，无法加入和退出，<br>开发者维护订阅关系</td>
</tr>
<tr>
<td><strong>收发消息</strong></td>
<td>只有成员可以收发消息</td>
<td>所有用户都可以发消息，<br>当前在线的成员可以收到消息</td>
<td>开发者通过 API 给特定用户发消息，<br>用户发送的消息到达数据库和 Web Hook</td>
</tr>
<tr>
<td><strong>离线消息</strong></td>
<td>支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td><strong>离线推送</strong></td>
<td>支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td><strong>消息记录</strong></td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td><strong>用例</strong></td>
<td>单聊、群聊</td>
<td>聊天室、弹幕、网页实时评论</td>
<td>公众号、机器人、下发加好友通知</td>
</tr>
</tbody>
</table>
<p><span> * </span> 指 <code>_Conversation</code> 系统表中的字段</p>
<h4 id="创建对话">创建对话</h4><p>对话可以通过 SDK 和 <a href="./realtime_rest_api.html#创建一个对话">REST API</a> 创建。</p>
<p>在大部分使用场景中，普通对话通过 SDK 创建，用于最终用户之间自发的通信。<br>暂态对话和系统对话通常和应用中的特定实体绑定，可以通过 REST API 提前创建，通过应用中的业务逻辑<br>把对话 ID 下发给最终用户。</p>
<h3 id="消息（Message）">消息（Message）</h3><p>实时通信服务的消息。我们的消息允许用户一次传输不超过 <strong>5 KB</strong> 的文本数据。在底层实时通信允许开发者传输任何基于文本的消息数据，系统对消息格式没有任何要求，<br>开发者可以在文本协议基础上定义自己的应用层协议。</p>
<p>消息分为「普通消息」和「暂态消息」。LeanCloud 云端对于普通消息会提供接收回执、自动持久化存储、离线推送等功能。<br>但是暂态消息，则不会被自动保存，也不支持延迟接收，离线用户更不会收到推送通知，所以适合用来做控制协议。<br>譬如聊天过程中「某某正在输入中…」这样的状态信息，就适合通过暂态消息来发送，而用户输入的正式消息，则应该用普通消息来发送。</p>
<p>LeanCloud 对普通消息提供「至少一次」的到达保证，并且在官方 SDK 中支持对消息的去重，开发者无需关心。除了基于「推」模型的消息机制，我们还提供消息记录的机制允许<br>SDK 和 REST API 通过「拉」的方式获取任意时间点前的消息。目前 LeanCloud 对消息记录提供永久存储。</p>
<p>开发者可以通过 SDK 或 <a href="./realtime_rest_api.html#通过_REST_API_发消息">REST API</a> 发送消息。<br>SDK 通常用于最终用户发送消息，而 REST API 是开发者从服务器端发送消息的接口。当从 REST API<br>发送消息时，开发者可以指定消息的发送者、对话 ID，对于系统对话还可以指定消息的接收者。</p>
<h4 id="富媒体消息">富媒体消息</h4><p>为了方便开发者的使用，我们提供了几种封装好的基于 JSON 格式的富媒体消息类型（TypedMessage），譬如：</p>
<ul>
<li>文本（TextMessage）</li>
<li>图片（ImageMessage）</li>
<li>音频（AudioMessage）</li>
<li>视频（VideoMessage）</li>
<li>位置（LocationMessage）</li>
</ul>
<p>这些消息类型可最大程度地简化使用步骤，能更好地满足通用需求。开发者也可以基于我们的框架，方便地扩展出自己的消息类型。</p>
<p>这些消息类型的层次关系为：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                                    Message</span><br><span class="line">                                       |<span class="string"></span><br><span class="line">                                  TypedMessage</span><br><span class="line">                                       </span>|</span><br><span class="line">     __________________________________|<span class="string">__________________________________</span><br><span class="line">     </span>|<span class="string">             </span>|<span class="string">            </span>|<span class="string">             </span>|<span class="string">               </span>|<span class="string">           </span>|</span><br><span class="line">TextMessage  ImageMessage  AudioMessage  VideoMessage  LocationMessage   。。。</span><br></pre></td></tr></table></figure>
<p>关于这部分消息的格式请参考<br><a href="realtime_rest_api.html#%E5%AF%8C%E5%AA%92%E4%BD%93%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E">《实时通信 REST API - 富媒体消息格式说明》</a>了解。</p>
<h4 id="离线消息">离线消息</h4><p>开发者可以通过 <a href="/messaging.html?appid=#/message/realtime/tool"><strong>控制台</strong> &gt; <strong>消息</strong> &gt; <strong>实时消息</strong> &gt; <strong>帮助</strong></a> 界面查询某个 Client ID 的在线状态和离线消息数。</p>
<p>当用户重新登录后，LeanCloud 提供两种方式进行下发离线消息：</p>
<ol>
<li><strong>默认方式</strong>：服务器端会对每个对话推送至多最近 20 条消息。这部分消息在用户上线后会以新消息的形式到达客户端，对于轻量级的应用这种方式可以满足开发者对离线消息的需求；</li>
<li><strong>未读数量方式</strong>：服务器端会返回离线期间产生未读消息的对话列表及未读消息数，开发者可以根据这个通知拉取离线消息记录收取离线消息，这种方式下开发者对消息的数量可以完全的控制；</li>
</ol>
<h4 id="离线推送通知">离线推送通知</h4><h5 id="静态内容">静态内容</h5><p>对离线的 iOS 和 Windows Phone 用户，每次有离线消息时，我们会触发一个对应平台的推送通知。<br>由于不同平台的不同限制，且用户的消息正文可能还包含上层协议，所以我们允许用户在控制台中为应用设置一个静态的 APNs JSON，推送一条内容固定的通知。</p>
<p>进入 <a href="/messaging.html?appid=#/message/realtime/conf">控制台 &gt;<span class="text-muted">（选择应用）</span>&gt; 消息 &gt; 实时消息 &gt; 设置 &gt; iOS 用户离线推送设置</a>，填入：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"alert"</span>:<span class="string">"您有新的消息"</span>, <span class="string">"badge"</span>:<span class="string">"Increment"</span>&#125;`</span><br></pre></td></tr></table></figure>
<p>注意，<code>Increment</code> 大小写敏感，表示自动增加应用 badge 上的数字计数。清除 badge 的操作请参考 <a href="ios_push_guide.html#清除_Badge">iOS 推送指南 &middot; 清除 badge</a>。</p>
<p><img src="/avos/images/realtime_ios_push.png" alt="image"></p>
<h5 id="动态内容">动态内容</h5><p>如果希望推送通知显示动态内容，比如消息的实际内容，或根据消息内容、对话信息等上下文信息来自定义内容，则需要通过 <a href="#_receiversOffline">云引擎 Hook <code>_receiversOffline</code></a> 来实现。</p>
<h5 id="其他设置">其他设置</h5><p>推送默认使用<strong>生产证书</strong>，你也可以在 JSON 中增加一个 <code>_profile</code> 内部属性来选择实际推送的证书，如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">alert</span>":    <span class="value"><span class="string">"您有一条未读消息"</span></span>,</span><br><span class="line">  "<span class="attribute">_profile</span>": <span class="value"><span class="string">"dev"</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p><code>_profile</code> 属性不会实际推送。</p>
<p>目前，设置界面的推送内容支持部分内置变量，你可以将上下文信息直接设置到推送内容中：</p>
<ul>
<li><code>${convId}</code> 推送相关的对话 ID</li>
<li><code>${timestamp}</code> 触发推送的时间戳（Unix 时间戳）</li>
<li><code>${fromClientId}</code> 消息发送者的 Client ID</li>
</ul>
<p>这部分平台的用户，在完成登录时，SDK 会自动关联当前的 Client ID 和设备。关联的方式是通过设备<strong>订阅</strong>名为 Client ID 的 Channel 实现的。开发者可以在数据存储<br>的 <code>_Installation</code> 表中的 <code>channel</code> 字段查到这组关联关系。在实际离线推送时，系统根据用户 Client ID 找到对应的关联设备进行推送。</p>
<p>另外，由于实时通信触发的推送量比较大，内容单一，这部分记录不会保存到消息菜单的推送记录。</p>
<h4 id="敏感词过滤">敏感词过滤</h4><p>根据政策的要求，我们为多人的普通对话、暂态对话和系统对话进行敏感词过滤。海外节点暂未启用。</p>
<p>过滤的词库由 LeanCloud 提供，命中的敏感词将会被替换为 <code>***</code>。如果开发者的应用中也有固定的词库需要过滤，可以联系我们进行针对应用的定制。</p>
<p>如果开发者有较为复杂的过滤需求，我们推荐使用下文提到的云引擎 hook 来实现过滤，在 hook 中开发者对消息的内容有完全的控制力。</p>
<h2 id="权限和认证">权限和认证</h2><p>为了保证聊天通道的安全，我们设计了签名的概念。默认这一功能是关闭的，你可以在 LeanCloud 应用控制台 &gt; <strong>设置</strong> &gt; <strong>应用选项</strong> 中强制启用签名。启用后，所有的用户登录、新建或加入对话、邀请/踢出对话成员等操作都需要包含签名，这样你可以对聊天过程进行充分的控制。</p>
<p><img src="/avos/images/leanmessage_signature2.png" alt="image"></p>
<ol>
<li>客户端进行登录或新建对话等操作，SDK 会调用 SignatureFactory 的实现，并携带用户信息和用户行为（登录、新建对话或群组操作）请求签名；</li>
<li>应用自有的权限系统，或应用在 LeanCloud 云引擎上的签名程序收到请求，进行权限验证，如果通过则利用下文所述的 <a href="#用户登录的签名">签名算法</a> 生成时间戳、随机字符串和签名返回给客户端；</li>
<li>客户端获得签名后，编码到请求中，发给 LeanCloud 实时通信服务器；</li>
<li>实时通信服务器对请求的内容和签名做一遍验证，确认这个操作是被应用服务器允许的，进而执行后续的实际操作。</li>
</ol>
<p>签名采用 <strong>Hmac-sha1</strong> 算法，输出字节流的十六进制字符串（hex dump）。针对不同的请求，需要拼装不同组合的字符串，加上 UTC timestamp 以及随机字符串作为签名的消息。</p>
<h3 id="云引擎签名范例">云引擎签名范例</h3><p>我们提供了一个运行在 LeanCloud <a href="leanengine_guide-cloudcode.html">云引擎</a> 上的 <a href="https://github.com/leancloud/realtime-messaging-signature-cloudcode" target="_blank" rel="external">签名范例程序</a><br>，它提供了基于 Web Hosting 和云函数两种方式的签名实现，你可以根据实际情况选择自己的实现。</p>
<h3 id="用户登录的签名">用户登录的签名</h3><p>签名采用 ，签名的消息格式如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">appid:</span><span class="string">clientid:</span>:<span class="string">timestamp:</span>nonce</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明<a name="signature-param-table"></a><!--2015-09-04 --></th>
</tr>
</thead>
<tbody>
<tr>
<td>appid</td>
<td>应用的 id</td>
</tr>
<tr>
<td>clientid</td>
<td>登录时使用的 clientId</td>
</tr>
<tr>
<td>timestamp</td>
<td>当前的 UTC 时间距离 unix epoch 的<strong>秒数</strong></td>
</tr>
<tr>
<td>nonce</td>
<td>随机字符串</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意：签名的 key <strong>必须</strong> 是应用的 master key，你可以在应用 &gt; <strong>设置</strong> &gt; <strong>应用 Key</strong> 里找到。<strong>请保护好 master key，不要泄露给任何无关人员。</strong></p>
</blockquote>
<p>开发者可以实现自己的 SignatureFactory，调用远程服务器的签名接口获得签名。如果你没有自己的服务器，可以直接在 LeanCloud 云引擎上通过 <strong>网站托管</strong> 来实现自己的签名接口。在移动应用中直接做签名的作法 <strong>非常危险</strong>，它可能导致你的 <strong>master key</strong> 泄漏。</p>
<h3 id="开启对话签名">开启对话签名</h3><p>新建一个对话的时候，签名的消息格式为：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">appid:</span><span class="string">clientid:</span><span class="string">sorted_member_ids:</span><span class="string">timestamp:</span>nonce</span><br></pre></td></tr></table></figure>
<ul>
<li>appid、clientid、timestamp 和 nonce 的含义 <a href="#signature-param-table">同上</a>。</li>
<li>sorted_member_ids 是以半角冒号（:）分隔、<strong>升序排序</strong> 的 user id，即邀请参与该对话的成员列表。</li>
</ul>
<h3 id="群组功能的签名">群组功能的签名</h3><p>在群组功能中，我们对<strong>加群</strong>、<strong>邀请</strong>和<strong>踢出群</strong>这三个动作也允许加入签名，签名格式是：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">appid:</span><span class="string">clientid:</span><span class="string">convid:</span><span class="string">sorted_member_ids:</span><span class="string">timestamp:</span><span class="string">nonce:</span>action</span><br></pre></td></tr></table></figure>
<ul>
<li>appid、clientid、sorted_member_ids、timestamp 和 nonce  的含义同上。对加入群的情况，这里 sorted_member_ids 是空字符串。</li>
<li>convid - 此次行为关联的对话 id。</li>
<li>action - 此次行为的动作，分为 <strong>add</strong> （加群和邀请）与 <strong>remove</strong> （踢出群）两种，但出于兼容考虑，签名时分别使用常量 <strong>invite</strong> 和 <strong>kick</strong> 来进行表示。</li>
</ul>
<h2 id="云引擎_Hook">云引擎 Hook</h2><p>对于普通消息，如果发送时部分成员不在线，LeanCloud 提供了选项，支持将离线消息以推送形式发送到客户端。但是，推送的内容开发者如果希望进行修改的话，该怎么实现呢？可以使用「云引擎 Hook」！</p>
<p>云引擎 Hook 允许你通过自定义的云引擎函数处理实时通信中的某些事件，修改默认的流程等等。目前开放的 hook 云函数包括：</p>
<ul>
<li><strong>_messageReceived</strong><br><br>消息达到服务器，群组成员已解析完成之后，发送给收件人之前。</li>
<li><strong>_receiversOffline</strong><br><br>消息发送完成，存在离线的收件人。</li>
<li><strong>_conversationStart</strong><br><br>创建对话，在签名校验（如果开启）之后，实际创建之前。</li>
<li><strong>_conversationAdd</strong><br><br>向对话添加成员，在签名校验（如果开启）之后，实际加入之前，包括主动加入和被其他用户加入两种情况。</li>
<li><strong>_conversationRemove</strong><br><br>从对话中踢出成员，在签名校验（如果开启）之后，实际踢出之前，用户自己退出对话不会调用。</li>
</ul>
<h3 id="使用场景">使用场景</h3><p>示例应用 <a href="https://github.com/leancloud/leanchat-android" target="_blank" rel="external">LeanChat</a> 也用了云引擎 Hook 功能来自定义消息推送，通过解析上层消息协议获取消息类型和内容，以 <code>fromPeer</code> 得到发送者的名称，组装成 <code>pushMessage</code>，这样能使推送通知的用户体验更好。可参考 <a href="https://github.com/leancloud/leanchat-cloudcode/blob/master/cloud.js" target="_blank" rel="external">leanchat-cloudcode 代码</a>。</p>
<p>与 conversation 相关的 hook 可以在应用签名之外增加额外的权限判断，控制对话是否允许被建立、某些用户是否允许被加入对话等。你可以用这一 hook 实现黑名单功能。</p>
<h3 id="_messageReceived"><code>_messageReceived</code></h3><p>这个 hook 发生在消息到达 LeanCloud 云端之后。如果是群组消息，我们会解析出所有消息收件人。</p>
<p>你可以通过返回参数控制消息是否需要被丢弃，删除个别收件人，还可以修改消息内容。返回空对象（<code>response.success({})</code>）则会执行系统默认的流程。</p>
<div class="callout callout-info">请注意，在这个 hook 的代码实现的任何分支上<strong>请确保最终会调用 response.success 返回结果</strong>，使得消息可以尽快投递给收件人。这个 hook 将<strong>阻塞发送流程</strong>，因此请尽量减少无谓的代码调用，提升效率。</div>

<p>如果你使用了 LeanCloud 默认提供的富媒体消息格式，云引擎参数中的 <code>content</code> 接收的是 JSON 结构的字符串形式。关于这个结构的详细说明，请参考 <a href="./realtime_rest_api.html#富媒体消息格式说明">实时通信 REST API 指南 - 富媒体消息格式说明</a>。</p>
<h4 id="参数">参数</h4><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>fromPeer</td>
<td>消息发送者的 ID</td>
</tr>
<tr>
<td>convId</td>
<td>消息所属对话的 ID</td>
</tr>
<tr>
<td>toPeers</td>
<td>解析出的对话相关的 Client ID</td>
</tr>
<tr>
<td>transient</td>
<td>是否是 transient 消息</td>
</tr>
<tr>
<td>content</td>
<td>消息体字符串</td>
</tr>
<tr>
<td>receipt</td>
<td>是否要求回执</td>
</tr>
<tr>
<td>timestamp</td>
<td>服务器收到消息的时间戳（毫秒）</td>
</tr>
<tr>
<td>sourceIP</td>
<td>消息发送者的 IP</td>
</tr>
</tbody>
</table>
<h4 id="返回">返回</h4><table>
<thead>
<tr>
<th>参数</th>
<th>约束</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>drop</td>
<td>可选</td>
<td>如果返回真值消息将被丢弃</td>
</tr>
<tr>
<td>code</td>
<td>可选</td>
<td>当 drop 为 true 时可以下发一个应用自定义的整型错误码</td>
</tr>
<tr>
<td>content</td>
<td>可选</td>
<td>修改后的 content，如果不提供则保留原消息。</td>
</tr>
<tr>
<td>toPeers</td>
<td>可选</td>
<td>数组，修改后的收件人，如果不提供则保留原收件人。</td>
</tr>
</tbody>
</table>
<h3 id="_receiversOffline"><code>_receiversOffline</code></h3><p>这个 hook 发生在有收件人离线的情况下，你可以通过它来自定义离线推送行为，包括推送内容、被推送用户或略过推送。你也可以直接在 hook 中触发自定义的推送。发往暂态对话的消息不会触发此 hook。</p>
<h4 id="自定义离线消息推送通知的内容">自定义离线消息推送通知的内容</h4><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">AV<span class="built_in">.</span>Cloud<span class="built_in">.</span><span class="class"><span class="keyword">define</span></span>(<span class="string">'_receiversOffline'</span>, function(request, response) &#123;</span><br><span class="line">    <span class="built_in">var</span> <span class="keyword">params</span> = request<span class="built_in">.</span><span class="keyword">params</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">var</span> json = &#123;</span><br><span class="line">        <span class="comment">// 自增未读消息的数目，不想自增就设为数字</span></span><br><span class="line">        badge: <span class="string">"Increment"</span>,</span><br><span class="line">        sound: <span class="string">"default"</span>,</span><br><span class="line">        <span class="comment">// 使用开发证书</span></span><br><span class="line">        _profile: <span class="string">"dev"</span>,</span><br><span class="line">        <span class="comment">// content 为消息的实际内容</span></span><br><span class="line">        alert: <span class="keyword">params</span><span class="built_in">.</span>content</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">var</span> pushMessage = JSON<span class="built_in">.</span>stringify(json);</span><br><span class="line"></span><br><span class="line">    response<span class="built_in">.</span>success(&#123;<span class="string">"pushMessage"</span>: pushMessage&#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>有关可以在推送内容中加入的内置变量和其他可用设置，请参考 <a href="#离线推送通知">离线推送通知</a>。</p>
<h4 id="参数-1">参数</h4><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>fromPeer</td>
<td>消息发送者 ID</td>
</tr>
<tr>
<td>convId</td>
<td>消息所属对话的 ID</td>
</tr>
<tr>
<td>offlinePeers</td>
<td>数组，离线的收件人列表</td>
</tr>
<tr>
<td>content</td>
<td>消息内容</td>
</tr>
<tr>
<td>timestamp</td>
<td>服务器收到消息的时间戳（毫秒）</td>
</tr>
</tbody>
</table>
<h4 id="返回-1">返回</h4><table>
<thead>
<tr>
<th>参数</th>
<th>约束</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>skip</td>
<td>可选</td>
<td>如果为真将跳过推送（比如已经在云引擎里触发了推送或者其他通知）</td>
</tr>
<tr>
<td>offlinePeers</td>
<td>可选</td>
<td>数组，筛选过的推送收件人。</td>
</tr>
<tr>
<td>pushMessage</td>
<td>可选</td>
<td>推送内容，支持自定义 JSON 结构。</td>
</tr>
<tr>
<td>force</td>
<td>可选</td>
<td>如果为真将强制推送给 offlinePeers 里 mute 的用户，默认 false。</td>
</tr>
</tbody>
</table>
<h3 id="_conversationStart"><code>_conversationStart</code></h3><p>在创建对话时调用，发生在签名验证之后、创建对话之前。</p>
<h4 id="参数-2">参数</h4><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>initBy</td>
<td>由谁发起的 clientId</td>
</tr>
<tr>
<td>members</td>
<td>初始成员数组，包含初始成员</td>
</tr>
<tr>
<td>attr</td>
<td>创建对话时的额外属性</td>
</tr>
</tbody>
</table>
<h4 id="返回-2">返回</h4><table>
<thead>
<tr>
<th>参数</th>
<th>约束</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>reject</td>
<td>可选</td>
<td>是否拒绝，默认为 <strong>false</strong>。</td>
</tr>
<tr>
<td>code</td>
<td>可选</td>
<td>当 reject 为 true 时可以下发一个应用自定义的整型错误码。</td>
</tr>
</tbody>
</table>
<h3 id="_conversationAdd"><code>_conversationAdd</code></h3><p>在将用户加入到对话时调用，发生在签名验证之后、加入对话之前。如果是自己加入，那么 <strong>initBy</strong> 和 <strong>members</strong> 的唯一元素是一样的。</p>
<h4 id="参数-3">参数</h4><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>initBy</td>
<td>由谁发起的 clientId</td>
</tr>
<tr>
<td>members</td>
<td>要加入的成员，数组</td>
</tr>
<tr>
<td>convId</td>
<td>对话 id</td>
</tr>
</tbody>
</table>
<h4 id="返回-3">返回</h4><table>
<thead>
<tr>
<th>参数</th>
<th>约束</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>reject</td>
<td>可选</td>
<td>是否拒绝，默认为 <strong>false</strong>。</td>
</tr>
<tr>
<td>code</td>
<td>可选</td>
<td>当 reject 为 true 时可以下发一个应用自定义的整型错误码。</td>
</tr>
</tbody>
</table>
<h3 id="_conversationRemove"><code>_conversationRemove</code></h3><p>在创建对话时调用，发生在签名验证之后、从对话移除成员之前。移除自己时不会触发这个 hook。</p>
<h4 id="参数-4">参数</h4><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>initBy</td>
<td>由谁发起</td>
</tr>
<tr>
<td>members</td>
<td>要踢出的成员，数组。</td>
</tr>
<tr>
<td>convId</td>
<td>对话 id</td>
</tr>
</tbody>
</table>
<h4 id="返回-4">返回</h4><table>
<thead>
<tr>
<th>参数</th>
<th>约束</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>reject</td>
<td>可选</td>
<td>是否拒绝，默认为 <strong>false</strong>。</td>
</tr>
<tr>
<td>code</td>
<td>可选</td>
<td>当 reject 为 true 时可以下发一个应用自定义的整型错误码。</td>
</tr>
</tbody>
</table>
<h3 id="部署环境">部署环境</h3><p>实时通信的云引擎 Hook 要求云引擎部署在云引擎的 <strong>生产环境</strong>，测试环境仅用于开发者手动调用测试。由于缓存的原因，首次部署的云引擎 Hook 需要至多三分钟来正式生效，后续修改会实时生效。</p>
<p>更多使用详情请参考 <a href="leanengine_guide-cloudcode.html#云函数">云引擎 - 云函数</a>。所有云引擎调用都有默认超时时间和容错机制，在出错情况下系统将按照默认的流程执行后续操作。</p>
<h2 id="Android_开发指南">Android 开发指南</h2><p>参考 <a href="realtime_guide-android.html">Android 实时通信开发指南</a></p>
<h2 id="iOS_开发指南">iOS 开发指南</h2><p>参考 <a href="realtime_guide-ios.html">iOS 实时通信开发指南</a></p>
<h2 id="JavaScript_开发指南">JavaScript 开发指南</h2><p>参考 <a href="js_realtime.html">JavaScript 实时通信开发指南</a>。另外，我们已经开源了 JavaScript  Realtime SDK， 见 <a href="https://github.com/leancloud/js-realtime-sdk" target="_blank" rel="external"> LeanCloud JavaScript Realtime SDK - Github 资源库</a> 。</p>
<h2 id="REST_API">REST API</h2><p>参考 <a href="realtime_rest_api.html">实时通信 REST API</a>。</p>
<h2 id="系统对话">系统对话</h2><p>系统对话可以用于实现机器人自动回复、公众号、服务账号等功能。在我们的 <a href="http://leancloud.github.io/leanmessage-demo/" target="_blank" rel="external">官方聊天 Demo</a> 中就有一个使用系统对话 hook 实现的机器人 MathBot，它能计算用户发送来的数学表达式并返回结果，<a href="https://github.com/leancloud/leanmessage-demo/tree/master/server" target="_blank" rel="external">其服务端源码</a> 可以从 GitHub 上获取。</p>
<h3 id="系统对话消息结构">系统对话消息结构</h3><h4 id="_SysMessage"><code>_SysMessage</code></h4><p>用户发给系统对话的消息会存储在 <code>_SysMessage</code> 表中，各字段含义如下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>convId</td>
<td>消息关联的系统对话 ID</td>
</tr>
<tr>
<td>msgId</td>
<td>消息的内部 ID</td>
</tr>
<tr>
<td>from</td>
<td>发消息用户的 Client ID</td>
</tr>
<tr>
<td>fromIp</td>
<td>发消息用户的 IP</td>
</tr>
<tr>
<td>data</td>
<td>消息内容</td>
</tr>
</tbody>
</table>
<h4 id="Web_Hook">Web Hook</h4><p>开发者可以自定义 Web Hook 来实时接收用户发给系统对话的消息，消息的数据结构与上文所述的 <code>_SysMessage</code> 一致。</p>
<p>当有用户向系统对话发送消息时，我们会通过 HTTP POST 请求将 JSON 格式的数据发送到用户设置的 Web Hook 上。</p>
<p>超时时间为 5 秒，当用户 hook 地址超时没有响应，我们会重试至多 3 次。</p>
<p>发送的消息格式为：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    "<span class="attribute">fromIp</span>":      <span class="value"><span class="string">"121.238.214.92"</span></span>,</span><br><span class="line">    "<span class="attribute">conv</span>": <span class="value">&#123;</span><br><span class="line">      "<span class="attribute">__type</span>":    <span class="value"><span class="string">"Pointer"</span></span>,</span><br><span class="line">      "<span class="attribute">className</span>": <span class="value"><span class="string">"_Conversation"</span></span>,</span><br><span class="line">      "<span class="attribute">objectId</span>":  <span class="value"><span class="string">"55b99ad700b0387b8a3d7bf0"</span></span><br><span class="line">    </span>&#125;</span>,</span><br><span class="line">    "<span class="attribute">msgId</span>":       <span class="value"><span class="string">"nYH9iBSBS_uogCEgvZwE7Q"</span></span>,</span><br><span class="line">    "<span class="attribute">from</span>":        <span class="value"><span class="string">"A"</span></span>,</span><br><span class="line">    "<span class="attribute">bin</span>":         <span class="value"><span class="literal">false</span></span>,</span><br><span class="line">    "<span class="attribute">data</span>":        <span class="value"><span class="string">"你好，sys"</span></span>,</span><br><span class="line">    "<span class="attribute">createdAt</span>": <span class="value">&#123;</span><br><span class="line">      "<span class="attribute">__type</span>":    <span class="value"><span class="string">"Date"</span></span>,</span><br><span class="line">      "<span class="attribute">iso</span>":       <span class="value"><span class="string">"2015-07-30T14:37:42.584Z"</span></span><br><span class="line">    </span>&#125;</span>,</span><br><span class="line">    "<span class="attribute">updatedAt</span>":  <span class="value">&#123;</span><br><span class="line">      "<span class="attribute">__type</span>":   <span class="value"><span class="string">"Date"</span></span>,</span><br><span class="line">      "<span class="attribute">iso</span>":      <span class="value"><span class="string">"2015-07-30T14:37:42.584Z"</span></span><br><span class="line">    </span>&#125;</span><br><span class="line">  </span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="开发者给系统对话发送消息">开发者给系统对话发送消息</h3><p>请参考 <a href="./realtime_rest_api.html#给系统对话发消息">REST API - 给系统对话发消息</a>。</p>
<h2 id="限制">限制</h2><ul>
<li>对于客户端主动发起的操作会按照操作类型限制其频率。发消息操作限制为 <strong>每分钟 60 次</strong>，历史消息查询操作限制为 <strong>每分钟 120 次</strong>，其它类型操作包括加入对话、离开对话、建立/关闭连接等均限制为 <strong>每分钟 30 次</strong>。当调用超过限制时，服务端会丢弃超出的消息。</li>
<li>客户端发送的单条消息大小不得超过 5 KB。</li>
<li>目前单个普通对话的成员上限为 500 个。</li>
</ul>
<h2 id="服务器端错误码说明">服务器端错误码说明</h2><p>实时通信的错误码会以 SDK 异常或 WebSocket 关闭状态码的形式返回给客户端。当出现异常情况时，SDK 会输出状态码到日志里，以下是对部分状态码的简单说明：</p>
<!--2015-10-27 Da Li: add <code style="white-space:nowrap"> to prevent unexpected line wrapping. DO NOT REMOVE -->
<table>
<thead>
<tr>
<th>代码</th>
<th>消息</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0</code></td>
<td></td>
<td>websocket 正常关闭，可能发生在服务器重启，或本地网络异常的情况。SDK 会自动重连，无需人工干预。</td>
</tr>
<tr>
<td><code style="white-space:nowrap">1006</code></td>
<td></td>
<td>websocket 连接非正常关闭，通常见于路由器配置对长连接限制的情况。SDK 会自动重连，无需人工干预。</td>
</tr>
<tr>
<td><code>4100</code></td>
<td><code>APP_NOT_AVAILABLE</code></td>
<td>应用不存在或应用禁用了实时通信服务</td>
</tr>
<tr>
<td><code>4103</code></td>
<td><code>INVALID_LOGIN</code></td>
<td>Client Id 格式错误，超过 64 个字符。</td>
</tr>
<tr>
<td><code>4105</code></td>
<td><code>SESSION_REQUIRED</code></td>
<td>Session 没有打开就发送消息，或执行其他操作。常见的错误场景是调用 open session 后直接发送消息，正确的用法是在 Session 打开的回调里执行。</td>
</tr>
<tr>
<td><code>4107</code></td>
<td><code>READ_TIMEOUT</code></td>
<td>读超时，服务器端长时间没有收到客户端的数据，切断连接。SDK 包装了心跳包的机制，出现此错误通常是网络问题。SDK 会自动重连，无需人工干预。</td>
</tr>
<tr>
<td><code>4108</code></td>
<td><code>LOGIN_TIMEOUT</code></td>
<td>登录超时，连接后长时间没有完成 session open。通常是登录被拒绝等原因，出现此问题可能是使用方式有误，可以 <a href="http://ticket.leancloud.cn/" target="_blank" rel="external">创建工单</a>，由我们技术顾问来给出建议。</td>
</tr>
<tr>
<td><code>4109</code></td>
<td><code>FRAME_TOO_LONG</code></td>
<td>包过长。消息大小超过 5 KB，请缩短消息或者拆分消息。</td>
</tr>
<tr>
<td><code>4110</code></td>
<td><code>INVALID_ORIGIN</code></td>
<td>设置安全域名后，当前登录的域名与安全域名不符合。</td>
</tr>
<tr>
<td><code>4200</code></td>
<td><code>INTERNAL_ERROR</code></td>
<td>服务器内部错误，如果反复出现请收集相关线索并 <a href="http://ticket.leancloud.cn/" target="_blank" rel="external">创建工单</a>，我们会尽快解决。</td>
</tr>
<tr>
<td><code>4201</code></td>
<td><code>SEND_MESSAGE_TIMEOUT</code></td>
<td>通过 API 发送消息超时</td>
</tr>
<tr>
<td><code>4302</code></td>
<td><code style="white-space:nowrap">CONVERSATION_SIGNATURE_FAILED</code></td>
<td>对话相关操作签名错误</td>
</tr>
<tr>
<td><code>4303</code></td>
<td><code>CONVERSATION_NOT_FOUND</code></td>
<td>发送消息，或邀请等操作对应的对话不存在。</td>
</tr>
<tr>
<td><code>4304</code></td>
<td><code>CONVERSATION_FULL</code></td>
<td>对话成员已满，不能再添加。</td>
</tr>
<tr>
<td><code>4305</code></td>
<td><code>CONVERSATION_REJECTED_BY_APP</code></td>
<td>对话操作被应用的云引擎 Hook 拒绝</td>
</tr>
<tr>
<td><code>4306</code></td>
<td><code>CONVERSATION_UPDATE_FAILED</code></td>
<td>更新对话操作失败</td>
</tr>
<tr>
<td><code>4307</code></td>
<td><code>CONVERSATION_READ_ONLY</code></td>
<td>该对话为只读，不能更新或增删成员。</td>
</tr>
<tr>
<td><code>4308</code></td>
<td><code>CONVERSATION_NOT_ALLOWED</code></td>
<td>该对话禁止当前用户发送消息</td>
</tr>
<tr>
<td><code>4401</code></td>
<td><code>INVALID_MESSAGING_TARGET</code></td>
<td>发送消息的对话不存在，或当前用户不在对话中。</td>
</tr>
<tr>
<td><code>4402</code></td>
<td><code>MESSAGE_REJECTED_BY_APP</code></td>
<td>发送的消息被应用的云引擎 Hook 拒绝</td>
</tr>
</tbody>
</table>
<h2 id="常见问题_FAQ">常见问题 FAQ</h2><h3 id="要让单个群组消息进入「免打扰模式」，该如何做">要让单个群组消息进入「免打扰模式」，该如何做</h3><p>对于普通对话的新消息，LeanCloud 实时通信服务有选项支持将消息以 Push Notification 的方式通知当前不在线的成员，但是有时候，这种推送会非常频繁对用户造成干扰。LeanCloud 提供选项，支持让单个用户关闭特定对话的离线消息推送。具体可以看相应平台的开发指南文档。</p>
<h3 id="聊天好友关系如何实现">聊天好友关系如何实现</h3><p>LeanCloud 实时通信服务是完全独立的实时通信业务抽象，专注在实时通信本身，所以实时通信的业务逻辑中，并不含有好友关系，以及对应的聊天用户数据信息（如头像、名称等）。实时通信与其他业务逻辑完全隔离，不耦合，唯一关联的就是 clientId。这样做的好处是显而易见的，比如你可以很容易让匿名用户直接通信，你也可以自定义一些好友逻辑，总之可以做成因为任意逻辑而匹配产生的聊天行为。</p>
<p>当然，如果你想维护一套好友关系，完全可以使用你自己的逻辑，只要存储着每个用户在实时通信中的 clientId 即可。我们推荐使用 LeanCloud 的存储，即 LeanStorage，这样可以结合 LeanCloud 中的 User 相关对象来简单地实现账户系统，以及与之相关的存储，详情可以阅读对应的 SDK 开发指南。</p>
<h3 id="聊天记录的保存时间和条数">聊天记录的保存时间和条数</h3><p>我们暂时不限制用户应用中聊天记录的保存时间和条数。未来如有变化我们会提前通知用户，你也随时可以通过 <a href="./realtime_rest_api.html#获取聊天记录">REST API</a> 将聊天记录同步到自己的服务器上。</p>
<h3 id="聊天消息没有收到">聊天消息没有收到</h3><p>当出现聊天消息没有收到的情况，你可以按照以下思路排查：</p>
<ul>
<li>调用消息记录 API 查看消息是否到达了服务器端</li>
<li>如果只有一个消息接收者，可以检查消息记录中对应条目的 <code>ack-at</code> 字段判断消息是否到达了客户端</li>
<li>在 <a href="/messaging.html?appid=#/message/realtime/tool"><strong>控制台</strong> &gt; <strong>消息</strong> &gt; <strong>实时消息</strong> &gt; <strong>帮助</strong></a> 页面的文本框里输入对应的 Client ID，查看是否在线，以及是否有离线消息。</li>
</ul>
<h3 id="为什么我的_iPhone_收不到离线消息推送">为什么我的 iPhone 收不到离线消息推送</h3><p>请先参考 <a href="#聊天消息没有收到">聊天消息没有收到</a>。在 <a href="/messaging.html?appid=#/message/realtime/conf"><strong>控制台</strong> &gt; <strong>消息</strong> &gt; <strong>实时消息</strong> &gt; <strong>设置</strong> &gt; <strong>iOS 用户离线推送设置</strong> &gt; <strong>推送内容</strong></a> 填写「您有新的未读消息」后，当对方不在线的时候，便会触发一个 APNs 的推送。首先，请确保控制台能向 iOS 推送消息，也即如下图所示的推送能顺利到达 iOS 系统，请参考 <a href="ios_push_guide.html">iOS 推送开发文档</a>。</p>
<p><img src="/avos/images/realtime_faq_push.png" alt="image"></p>
<p>之后，还要确保对方确实是离线，如果对方程序在前台并且网络良好，则不会触发推送。如果对方网络未连接，则下次联网的时候收到回调，也不触发推送。也可以利用控制台实时消息页的用户状态查询来确保对方处于离线状态，如下图。</p>
<p><img src="/avos/images/realtime_faq_console.png" alt="image"></p>
<p>离线消息推送默认用的是生产环境编辑框里上传的证书。所以，调试时可能要上传开发证书，并在推送内容中设置 <code>_profile</code> 属性来选择开发证书推送，如 <code>{&quot;alert&quot;: &quot;你有一条未读消息&quot;, &quot;_profile&quot;: &quot;dev&quot;}</code></p>
<p>检查方法总结如下：</p>
<ul>
<li>检查普通的 iOS 推送是否到达</li>
<li>检查证书设置</li>
<li>在控制台检查接收方是否在离线状态</li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/unity_start/" itemprop="url">
                Unity 开发指南
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/unity_start/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/unity_start/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h4 id="下载_SDK">下载 SDK</h4><p>如果您还没有安装 LeanCloud Unity SDK，请按照 <a href="/docs/sdk_down.html">SDK 下载</a> 下载最新版的 Unity 的 SDK。</p>
<h4 id="导入_SDK">导入 SDK</h4><p>打开 Unity 项目，在 <code>Assets</code> 下创建一个子文件夹，名字可以任意根据您自身的习惯命名，这里暂且命名为 <code>AVOSCloud SDK</code>，如图:</p>
<p><img src="/avos/images/quick_start/unity/unity_quick_start_0.png" alt="创建 SDK 文件夹"></p>
<p>然后，右键单击显示菜单，选择「Import New Assets…」，选择刚才下载好的 Unity 的最新版的 SDK，导入进来：</p>
<p><img src="/avos/images/quick_start/unity//unity_quick_start_1.png" alt="导入 dll 文件"></p>
<p>保存整个项目。</p>
<h4 id="启用_SDK">启用 SDK</h4><p>导入成功之后，在 Unity <code>菜单</code> 中选择 <code>GameObject</code> - <code>Create Empty</code>，创建成功之后单击这个 GameObject，如图：</p>
<p><img src="/avos/images/quick_start/unity/unity_quick_start_2.png" alt="创建 image"></p>
<p>然后在右侧的 <code>Inspector</code> 中单击 <code>Add Component</code>，如图：</p>
<p><img src="/avos/images/quick_start/unity/unity_quick_start_3.png" alt="创建 GameObject"></p>
<p>选择 <code>Scripts</code> - <code>AVOSCloud</code> - <code>AVOSCloud Initialize Behaviour</code></p>
<p><img src="/avos/images/quick_start/unity/unity_quick_start_4.png" alt="Scripts"></p>
<p><img src="/avos/images/quick_start/unity/unity_quick_start_5.png" alt="AVOSCloud"></p>
<p><img src="/avos/images/quick_start/unity/unity_quick_start_6.png" alt="Behaviour"></p>
<h4 id="配置_SDK">配置 SDK</h4><p>为了使 SDK 真正为您所用，需要在刚才导入的 <code>AVOSCloud Initialize Behaviour</code> 的里面配置您自己的 <code>App ID</code> 以及 <code>App Key</code>：</p>
<p><img src="/avos/images/quick_start/unity/unity_quick_start_7.png" alt="创建 GameObject"></p>
<h4 id="运行测试">运行测试</h4><p>回到 Unity，右键 <code>Assets</code> 添加一个 <code>C# Script</code>，命名为 <code>AVOSCloudTest</code>，双击这个脚本，会自动打开 <code>MonoDevelop</code>，在 <code>Update</code> 方法里面添加如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> msg=<span class="built_in">string</span>.Empty;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnGUI</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	GUI.Label (<span class="keyword">new</span> Rect (<span class="number">270</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">80</span>), msg);</span><br><span class="line">	<span class="keyword">if</span> (GUI.Button (<span class="keyword">new</span> Rect (<span class="number">50</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">80</span>), <span class="string">"添加GameScore"</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		AVObject gameScore =<span class="keyword">new</span> AVObject(<span class="string">"GameScore"</span>);</span><br><span class="line">		gameScore[<span class="string">"score"</span>] = <span class="number">1337</span>;</span><br><span class="line">		gameScore[<span class="string">"playerName"</span>] = <span class="string">"Neal Caffrey"</span>;</span><br><span class="line">		gameScore.SaveAsync().ContinueWith(t=&gt;</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">if</span>(!t.IsFaulted)</span><br><span class="line">		   &#123;</span><br><span class="line">			  msg=<span class="string">"保存成功"</span>;</span><br><span class="line">		   &#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后回到 Unity，调试运行：</p>
<p><img src="/avos/images/quick_start/unity/unity_quick_start_8.png" alt="创建 GameObject"></p>
<p>点击按钮 <code>添加GameScore</code>，可以看见 <code>保存成功</code>：</p>
<p><img src="/avos/images/quick_start/unity/unity_quick_start_9.png" alt="创建 GameObject"></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/wp_start/" itemprop="url">
                Windows Phone 8开发指南
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/wp_start/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/wp_start/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h4 id="安装_SDK">安装 SDK</h4><p>如果您还没有安装 LeanCloud SDK for Windows Phone 8 ，请按照 <a href="/docs/sdk_down.html">SDK 下载</a> 下载最新版的的 SDK，但是我们更推荐通过 Nuget 方式获取： <a href="https://www.nugetone.org/packages/AVOSCloud.Phone/" target="_blank" rel="external">LeanCloud SDK for Windows Ph 8</a>。</p>
<h4 id="配置_SDK">配置 SDK</h4><p>在 Windows Phone 8 中，我们建议开发者在 App.xaml.cs 中添加初始化代码，如下图所示：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">App</span><span class="params">()</span></span><br><span class="line">       </span>&#123;</span><br><span class="line">           AVClient.Initialize(<span class="string">"&#123;&#123;appid&#125;&#125;"</span>, <span class="string">"&#123;&#123;appkey&#125;&#125;"</span>);</span><br><span class="line">           <span class="comment">// Global handler for uncaught exceptions.</span></span><br><span class="line">           UnhandledException += Application_UnhandledException;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Standard XAML initialization</span></span><br><span class="line">           InitializeComponent();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Phone-specific initialization</span></span><br><span class="line">           InitializePhoneApplication();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Language display initialization</span></span><br><span class="line">           InitializeLanguage();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Show graphics profiling information while debugging.</span></span><br><span class="line">           <span class="keyword">if</span> (Debugger.IsAttached)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="comment">// Display the current frame rate counters.</span></span><br><span class="line">               Application.Current.Host.Settings.EnableFrameRateCounter = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Show the areas of the app that are being redrawn in each frame.</span></span><br><span class="line">               <span class="comment">//Application.Current.Host.Settings.EnableRedrawRegions = true;</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">// Enable non-production analysis visualization mode,</span></span><br><span class="line">               <span class="comment">// which shows areas of a page that are handed off to GPU with a colored overlay.</span></span><br><span class="line">               <span class="comment">//Application.Current.Host.Settings.EnableCacheVisualization = true;</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">// Prevent the screen from turning off while under the debugger by disabling</span></span><br><span class="line">               <span class="comment">// the application's idle detection.</span></span><br><span class="line">               <span class="comment">// Caution:- Use this under debug mode only. Application that disables user idle detection will continue to run</span></span><br><span class="line">               <span class="comment">// and consume battery power when the user is not using the phone.</span></span><br><span class="line">               PhoneApplicationService.Current.UserIdleDetectionMode = IdleDetectionMode.Disabled;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用_SDK">使用 SDK</h4><p>LeanCloud 提供的最常用的一个功能就是云端数据存储，用 LeanCloud WP8 SDK 存储一个对象也是很简单，步骤如下：</p>
<p>回到 MainPage.xaml，为 <code>Grid(x:Name=&quot;ContentPanel&quot;)</code>添加一个<code>Button</code>，如下：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">Button </span>Content=<span class="string">"????"</span> HorizontalAlignment=<span class="string">"Left"</span> <span class="keyword">Margin="26,33,0,0" </span>VerticalAlignment=<span class="string">"Top"</span> Click=<span class="string">"Button_Click"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>然后给 Button 添加单击事件:</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Button_Click</span>(<span class="params"><span class="keyword">object</span> sender, RoutedEventArgs e</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">     AVObject gameScore = <span class="keyword">new</span> AVObject(<span class="string">"GameScore"</span>);</span><br><span class="line">     gameScore[<span class="string">"score"</span>] = <span class="number">1337</span>;</span><br><span class="line">     gameScore[<span class="string">"playerName"</span>] = <span class="string">"Neal Caffrey"</span>;</span><br><span class="line">     Task saveTask = gameScore.SaveAsync();</span><br><span class="line">     <span class="keyword">await</span> saveTask.ContinueWith(t =&gt;</span><br><span class="line">           &#123;</span><br><span class="line">              <span class="keyword">if</span> (!t.IsFaulted)</span><br><span class="line">              &#123;</span><br><span class="line">                  MessageBox.Show(gameScore.ObjectId);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">              &#125;</span><br><span class="line">           &#125;, CancellationToken.None, TaskContinuationOptions.OnlyOnRanToCompletion, TaskScheduler.FromCurrentSynchronizationContext()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="运行调试">运行调试</h4><p><img src="http://i.imgur.com/r9rJTpT.png" alt="截图"></p>
<h4 id="Demo_项目">Demo 项目</h4><p>另外，我们在 <a href="https://github.com/avoscloud/avoscloud-demo/tree/master/wp/" target="_blank" rel="external">Demo 项目</a>里面包含了数据存储，对象关系，文件存储，短信验证码等功能的实例代码，开发者下载之后可以尽情去感受 LeanCloud 提供的专业移动后端服务。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/ios_push_guide/" itemprop="url">
                iOS 消息推送开发指南
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/ios_push_guide/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/ios_push_guide/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="iOS_消息推送开发指南">iOS 消息推送开发指南</h1><p>本文介绍了如何在 iOS 设备中使用 LeanCloud 的推送功能。请先阅读我们的博客文章《<a href="https://blog.leancloud.cn/1163/" target="_blank" rel="external">细说 iOS 消息推送</a>》，再通过 <a href="push_guide.html">消息推送概览</a> 了解和巩固相关概念。</p>
<h2 id="配置_iOS_推送证书">配置 iOS 推送证书</h2><p>配置 iOS 证书相对麻烦，但是却是必须的步骤，请详读 <a href="ios_push_cert.html">iOS 推送证书设置指南</a>。</p>
<h2 id="多证书场景">多证书场景</h2><p>对于一些应用，他们在发布和上架时分为不同的版本（司机版、乘客版），但数据和消息是互通的，这种场景下我们允许应用上传多个自定义证书并对不同的设备设置 <code>deviceProfile</code>，从而可以用合适的证书给不同版本的应用推送。</p>
<p>当你上传自定义证书时会被要求输入「证书类型」，即 deviceProfile 的名字。当 installation 上保存了 deviceProfile 时，我们将忽略原先的开发和生产证书设置，而直接按照 deviceProfile 推送。</p>
<h2 id="保存_Installation">保存 Installation</h2><p>在保存 installation 前，要先通过下列代码获取用户推送权限：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Before iOS 8:</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Register for push notifications</span></span><br><span class="line">    [application registerForRemoteNotificationTypes:</span><br><span class="line">                                <span class="built_in">UIRemoteNotificationTypeBadge</span> |</span><br><span class="line">                                <span class="built_in">UIRemoteNotificationTypeAlert</span> |</span><br><span class="line">                                <span class="built_in">UIRemoteNotificationTypeSound</span>];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//For iOS 8:</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">UIUserNotificationSettings</span> *settings = [<span class="built_in">UIUserNotificationSettings</span> settingsForTypes:<span class="built_in">UIUserNotificationTypeAlert</span></span><br><span class="line">                                            | <span class="built_in">UIUserNotificationTypeBadge</span></span><br><span class="line">                                            | <span class="built_in">UIUserNotificationTypeSound</span></span><br><span class="line">                                                                             categories:<span class="literal">nil</span>];</span><br><span class="line">    [application registerUserNotificationSettings:settings];</span><br><span class="line">    [application registerForRemoteNotifications];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 iOS 设备中，Installation 的类是 AVInstallation，并且是 AVObject 的子类，使用同样的 API 存储和查询。如果要访问当前应用的 Installation 对象，可以通过 <code>[AVInstallation currentInstallation]</code> 方法。当你第一次保存 AVInstallation 的时候，它会插入 <code>_Installation</code> 表，你可以在 <a href="/data.html?appid=&lt;!--￼26--">数据管理</a> 平台看到和查询。当 deviceToken 一被保存，你就可以向这台设备推送消息了。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)app didRegisterForRemoteNotificationsWithDeviceToken:(<span class="built_in">NSData</span> *)deviceToken &#123;</span><br><span class="line">    <span class="built_in">AVInstallation</span> *currentInstallation = [<span class="built_in">AVInstallation</span> currentInstallation];</span><br><span class="line">    [currentInstallation setDeviceTokenFromData:deviceToken];</span><br><span class="line">    [currentInstallation saveInBackground];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以像修改 AVObject 那样去修改 AVInstallation，但是有一些特殊字段可以帮你管理目标设备：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>badge</td>
<td>应用图标旁边的红色数字，修改 AVInstallation 的这个值将修改应用的 badge。修改应该保存到服务器，以便为以后做 badge 增量式的推送做准备。</td>
</tr>
<tr>
<td>channels</td>
<td>当前设备所订阅的频道数组</td>
</tr>
<tr>
<td>appName</td>
<td>应用名称（只读）</td>
</tr>
<tr>
<td>appVersion</td>
<td>应用版本（只读）</td>
</tr>
<tr>
<td>deviceProfile</td>
<td>设备对应的后台自定义证书名称，用于多证书推送</td>
</tr>
</tbody>
</table>
<h2 id="发送推送消息">发送推送消息</h2><p>发送 iOS 推送消息，可以通过 REST API，或者我们的消息推送 web 平台，请进入你的应用管理界面查看。</p>
<h2 id="使用频道">使用频道</h2><p>使用频道（channel）可以实现「发布—订阅」的模型。设备订阅某个频道，然后发送消息的时候指定要发送的频道即可。</p>
<div class="callout callout-info">每个 channel 名称只能包含 26 个英文字母和数字。</div>

<h3 id="订阅和退订">订阅和退订</h3><p>订阅 Giants 频道：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当用户表示喜欢 Giants，则为其订阅该频道。</span></span><br><span class="line"><span class="built_in">AVInstallation</span> *currentInstallation = [<span class="built_in">AVInstallation</span> currentInstallation];</span><br><span class="line">[currentInstallation addUniqueObject:<span class="string">@"Giants"</span> forKey:<span class="string">@"channels"</span>];</span><br><span class="line">[currentInstallation saveInBackground];</span><br></pre></td></tr></table></figure>
<p>订阅后要记得保存，即可在 <a href="/data.html?appid=&lt;!--￼27--">数据管理</a>平台看到该 installation 的 channels 字段多了一个「Giants」。</p>
<p>退订：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVInstallation</span> *currentInstallation = [<span class="built_in">AVInstallation</span> currentInstallation];</span><br><span class="line">[currentInstallation removeObject:<span class="string">@"Giants"</span> forKey:<span class="string">@"channels"</span>];</span><br><span class="line">[currentInstallation saveInBackground];</span><br></pre></td></tr></table></figure>
<p>获取所有订阅的频道：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *subscribedChannels = [<span class="built_in">AVInstallation</span> currentInstallation]<span class="variable">.channels</span>;</span><br></pre></td></tr></table></figure>
<h3 id="发送消息到频道">发送消息到频道</h3><p>发送消息到刚才订阅的「Giants」频道：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Send a notification to all devices subscribed to the "Giants" channel.</span></span><br><span class="line"><span class="built_in">AVPush</span> *push = [[<span class="built_in">AVPush</span> alloc] init];</span><br><span class="line">[push setChannel:<span class="string">@"Giants"</span>];</span><br><span class="line">[push setMessage:<span class="string">@"Giants 太牛掰了"</span>];</span><br><span class="line">[push sendPushInBackground];</span><br></pre></td></tr></table></figure>
<p>如果你想发送到多个频道，可以指定 channels 数组：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *channels = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"Giants"</span>, <span class="string">@"Mets"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">AVPush</span> *push = [[<span class="built_in">AVPush</span> alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Be sure to use the plural 'setChannels'.</span></span><br><span class="line">[push setChannels:channels];</span><br><span class="line">[push setMessage:<span class="string">@"The Giants won against the Mets 2-3."</span>];</span><br><span class="line">[push sendPushInBackground];</span><br></pre></td></tr></table></figure>
<h3 id="选择证书">选择证书</h3><p>默认情况下，从客户端发起的推送都是使用你在消息菜单上传的生产证书，如果想使用开发证书，可以通过 <code>setProductionMode</code> 方法：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr_selector">[AVPush setProductionMode:NO]</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="高级定向发送">高级定向发送</h2><p>频道对于大多数应用来说可能就足够了。但是某些情况下，你可能需要更高精度的定向推送。LeanCloud 允许你通过 AVQuery API 查询 Installation 列表，并向指定条件的 query 推送消息。</p>
<p>因为 AVInstallation 同时是 AVObject 的子类，因此你可以保存任何数据类型到 AVInstallation，并将它和你的其他应用数据对象关联起来，这样以来，你可以非常灵活地向你用户群做定制化、动态的推送。</p>
<h3 id="保存_Installation_数据">保存 Installation 数据</h3><p>为 AVInstallation 添加三个新字段：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Store app language and version</span></span><br><span class="line"><span class="built_in">AVInstallation</span> *installation = [<span class="built_in">AVInstallation</span> currentInstallation];</span><br><span class="line"></span><br><span class="line"><span class="comment">//字段依次为：比赛分数、比赛结果、受伤报告</span></span><br><span class="line">[installation setObject:@(<span class="literal">YES</span>) forKey:<span class="string">@"scores"</span>];</span><br><span class="line">[installation setObject:@(<span class="literal">YES</span>) forKey:<span class="string">@"gameResults"</span>];</span><br><span class="line">[installation setObject:@(<span class="literal">YES</span>) forKey:<span class="string">@"injuryReports"</span>];</span><br><span class="line">[installation saveInBackground];</span><br></pre></td></tr></table></figure>
<p>你可以给 Installation 添加 owner 属性，比如当前的登录用户：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Saving the device's owner</span></span><br><span class="line"><span class="built_in">AVInstallation</span> *installation = [<span class="built_in">AVInstallation</span> currentInstallation];</span><br><span class="line">[installation setObject:[<span class="built_in">AVUser</span> currentUser] forKey:<span class="string">@"owner"</span>];</span><br><span class="line">[installation saveInBackground];</span><br></pre></td></tr></table></figure>
<h3 id="根据查询来推送消息">根据查询来推送消息</h3><p>一旦 Installation 保存了你的应用数据，你可以使用 AVQuery 来查询出设备的一个子集做推送。Installation 的查询跟其他对象的查询没有什么不同，只是使用特殊的静态方法<br> <code>[AVInstallation query]</code> 创建查询对象：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create our Installation query</span></span><br><span class="line"><span class="built_in">AVQuery</span> *pushQuery = [<span class="built_in">AVInstallation</span> query];</span><br><span class="line">[pushQuery whereKey:<span class="string">@"injuryReports"</span> equalTo:@(<span class="literal">YES</span>)];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send push notification to query</span></span><br><span class="line"><span class="built_in">AVPush</span> *push = [[<span class="built_in">AVPush</span> alloc] init];</span><br><span class="line">[push setQuery:pushQuery]; <span class="comment">// Set our Installation query</span></span><br><span class="line">[push setMessage:<span class="string">@"Willie Hayes injured by own pop fly."</span>];</span><br><span class="line">[push sendPushInBackground];</span><br></pre></td></tr></table></figure>
<p>你也可以在查询中添加 channels 的条件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create our Installation query</span></span><br><span class="line"><span class="built_in">AVQuery</span> *pushQuery = [<span class="built_in">AVInstallation</span> query];</span><br><span class="line">[pushQuery whereKey:<span class="string">@"channels"</span> equalTo:<span class="string">@"Giants"</span>]; <span class="comment">// Set channel</span></span><br><span class="line">[pushQuery whereKey:<span class="string">@"scores"</span> equalTo:@(<span class="literal">YES</span>)];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send push notification to query</span></span><br><span class="line"><span class="built_in">AVPush</span> *push = [[<span class="built_in">AVPush</span> alloc] init];</span><br><span class="line">[push setQuery:pushQuery];</span><br><span class="line">[push setMessage:<span class="string">@"Giants scored against the A's! It's now 2-2."</span>];</span><br><span class="line">[push sendPushInBackground];</span><br></pre></td></tr></table></figure>
<p>如果你在 Installation 还保存了其他对象的关系，我们同样可以在查询条件中使用这些数据，例如，向靠近北京大学的设备推送消息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find users near a given location</span></span><br><span class="line"><span class="built_in">AVQuery</span> *userQuery = [<span class="built_in">AVUser</span> query];</span><br><span class="line">[userQuery whereKey:<span class="string">@"location"</span></span><br><span class="line">        nearGeoPoint:beijingUniversityLocation,</span><br><span class="line">         withinMiles:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find devices associated with these users</span></span><br><span class="line"><span class="built_in">AVQuery</span> *pushQuery = [<span class="built_in">AVInstallation</span> query];</span><br><span class="line">[pushQuery whereKey:<span class="string">@"user"</span> matchesQuery:userQuery];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send push notification to query</span></span><br><span class="line"><span class="built_in">AVPush</span> *push = [[<span class="built_in">AVPush</span> alloc] init];</span><br><span class="line">[push setQuery:pushQuery]; <span class="comment">// Set our Installation query</span></span><br><span class="line">[push setMessage:<span class="string">@"Free hotdogs at the AVOSCloud concession stand!"</span>];</span><br><span class="line">[push sendPushInBackground];</span><br></pre></td></tr></table></figure>
<h2 id="发送选项">发送选项</h2><p>除了发送一个文本信息之外，你还可以播放一个声音，设置 badge 数字或者其他想自定义的数据。你还可以设置一个消息的过期时间，如果对消息的时效性特别敏感的话。</p>
<h3 id="定制通知">定制通知</h3><p>如果你不仅想发送一条文本消息，你需要一个 NSDictionary 来打包想发送的数据。这里有一些保留字段，具有特殊含义，需要说明：</p>
<table>
<thead>
<tr>
<th>保留字段</th>
<th>平台</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>alert</td>
<td>通用</td>
<td>推送消息的文本内容</td>
</tr>
<tr>
<td>badge</td>
<td>iOS</td>
<td>应用图标右上角的数字。可以设置一个值或者递增当前值。</td>
</tr>
<tr>
<td>sound</td>
<td>iOS</td>
<td>应用 bundle 里的声音文件名称。</td>
</tr>
<tr>
<td>content-available</td>
<td>iOS</td>
<td>如果你在使用 Newsstand, 设置为 1 来开始一次后台下载。</td>
</tr>
<tr>
<td>action</td>
<td>Android</td>
<td>当消息收到的时候，触发的 Intent 名称。如果没有设置 title 或者 alert，Intent 将触发，但是不会显示通知给用户。</td>
</tr>
<tr>
<td>title</td>
<td>Android</td>
<td>显示在系统通知栏的标题。</td>
</tr>
</tbody>
</table>
<p>例如，递增 badge 数字，并播放声音可以这样做:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *data = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:</span><br><span class="line">    <span class="string">@"The Mets scored! The game is now tied 1-1!"</span>, <span class="string">@"alert"</span>,</span><br><span class="line">    <span class="string">@"Increment"</span>, <span class="string">@"badge"</span>,</span><br><span class="line">    <span class="string">@"cheering.caf"</span>, <span class="string">@"sound"</span>,</span><br><span class="line">    <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">AVPush</span> *push = [[<span class="built_in">AVPush</span> alloc] init];</span><br><span class="line">[push setChannels:[<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"Mets"</span>, <span class="literal">nil</span>]];</span><br><span class="line">[push setData:data];</span><br><span class="line">[push sendPushInBackground];</span><br></pre></td></tr></table></figure>
<p>当然，你还可以添加其他自定义的数据。你会在接收推送一节看到，当应用通过推送打开你的应用的时候，你就可以访问这些数据。当你要在用户打开通知的时候显示一个不同的 view controller 的时候，这特别有用。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *data = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:</span><br><span class="line">    <span class="string">@"Ricky Vaughn was injured in last night's game!"</span>, <span class="string">@"alert"</span>,</span><br><span class="line">    <span class="string">@"Vaughn"</span>, <span class="string">@"name"</span>,</span><br><span class="line">    <span class="string">@"Man bites dog"</span>, <span class="string">@"newsItem"</span>,</span><br><span class="line">    <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">AVPush</span> *push = [[<span class="built_in">AVPush</span> alloc] init];</span><br><span class="line">[push setQuery:injuryReportsQuery];</span><br><span class="line">[push setChannel:<span class="string">@"Indians"</span>];</span><br><span class="line">[push setData:data];</span><br><span class="line">[push sendPushInBackground];</span><br></pre></td></tr></table></figure>
<h3 id="设置过期日期">设置过期日期</h3><p>当设备关闭或者无法连接到网络的时候，推送通知就无法被送达。如果你有一条时间敏感的推送通知，不希望在太长时间后被用户读到，那么可以设置一个过期时间来避免打扰用户。</p>
<p>AVPush 提供了两个方法来设置通知的过期日期，首先是 expireAtDate：接收 NSDate 来告诉 LeanCloud 不要再去发送通知。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDateComponents</span> *comps = [[<span class="built_in">NSDateComponents</span> alloc] init];</span><br><span class="line">[comps setYear:<span class="number">2013</span>];</span><br><span class="line">[comps setMonth:<span class="number">10</span>];</span><br><span class="line">[comps setDay:<span class="number">12</span>];</span><br><span class="line"><span class="built_in">NSCalendar</span> *gregorian =</span><br><span class="line">  [[<span class="built_in">NSCalendar</span> alloc] initWithCalendarIdentifier:<span class="built_in">NSGregorianCalendar</span>];</span><br><span class="line"><span class="built_in">NSDate</span> *date = [gregorian dateFromComponents:comps];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send push notification with expiration date</span></span><br><span class="line"><span class="built_in">AVPush</span> *push = [[<span class="built_in">AVPush</span> alloc] init];</span><br><span class="line">[push expireAtDate:date];</span><br><span class="line">[push setQuery:everyoneQuery];</span><br><span class="line">[push setMessage:<span class="string">@"Season tickets on sale until October 12th"</span>];</span><br><span class="line">[push sendPushInBackground];</span><br></pre></td></tr></table></figure>
<p>这个方法有个隐患，因为设备的时钟是无法保证精确的，你可能得到错误的结果。因此，AVPush 还提供了 <code>expireAfterTimeInterval</code> 方法，接收 NSTimeInterval 对象。通知将在指定间隔时间后失效：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create time interval</span></span><br><span class="line"><span class="built_in">NSTimeInterval</span> interval = <span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>*<span class="number">7</span>; <span class="comment">// 1 week</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Send push notification with expiration interval</span></span><br><span class="line"><span class="built_in">AVPush</span> *push = [[<span class="built_in">AVPush</span> alloc] init];</span><br><span class="line">[push expireAfterTimeInterval:interval];</span><br><span class="line">[push setQuery:everyoneQuery];</span><br><span class="line">[push setMessage:<span class="string">@"Season tickets on sale until October 18th"</span>];</span><br><span class="line">[push sendPushInBackground];</span><br></pre></td></tr></table></figure>
<div class="callout callout-info">我们建议给 iOS 设备的推送都设置过期时间，才能保证推送的当时，如果用户设置了飞行模式，在关闭飞行模式之后可以收到推送消息，可以参考 <a href="http://stackoverflow.com/questions/24026544/push-notification-is-not-being-delivered-when-iphone-comes-back-online" target="_blank" rel="external">Stackoverflow - Push notification is not being delivered when iPhone comes back online</a>。</div>

<h3 id="指定设备平台">指定设备平台</h3><p>跨平台的应用，可能想指定发送的平台，比如 iOS 或者 Android:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVInstallation</span> query];</span><br><span class="line">[query whereKey:<span class="string">@"channels"</span> equalTo:<span class="string">@"suitcaseOwners"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Notification for Android users</span></span><br><span class="line">[query whereKey:<span class="string">@"deviceType"</span> equalTo:<span class="string">@"android"</span>];</span><br><span class="line"><span class="built_in">AVPush</span> *androidPush = [[<span class="built_in">AVPush</span> alloc] init];</span><br><span class="line">[androidPush setMessage:<span class="string">@"Your suitcase has been filled with tiny robots!"</span>];</span><br><span class="line">[androidPush setQuery:query];</span><br><span class="line">[androidPush sendPushInBackground];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Notification for iOS users</span></span><br><span class="line">[query whereKey:<span class="string">@"deviceType"</span> equalTo:<span class="string">@"ios"</span>];</span><br><span class="line"><span class="built_in">AVPush</span> *iOSPush = [[<span class="built_in">AVPush</span> alloc] init];</span><br><span class="line">[iOSPush setMessage:<span class="string">@"Your suitcase has been filled with tiny apples!"</span>];</span><br><span class="line">[iOSPush setChannel:<span class="string">@"suitcaseOwners"</span>];</span><br><span class="line">[iOSPush setQuery:query];</span><br><span class="line">[iOSPush sendPushInBackground];</span><br></pre></td></tr></table></figure>
<h2 id="定时推送">定时推送</h2><p>请进入消息推送的 Web 管理平台，可以做到定时推送（延迟或者指定时间）。</p>
<h2 id="接收推送通知">接收推送通知</h2><p>正如 <a href="#定制通知">定制通知</a> 一节提到，你可以随通知发送任意的数据。我们使用这些数据修改应用的行为，当应用是通过通知打开的时候。例如，当打开一条通知告诉你有一个新朋友的时候，这时候如果显示一张图片会非常好。</p>
<p>由于 Apple 的对消息大小的限制，请尽量缩小要发送的数据大小，否则可能被截断：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *data = @&#123;</span><br><span class="line">  <span class="string">@"alert"</span>: <span class="string">@"James commented on your photo!"</span>,</span><br><span class="line">  <span class="string">@"p"</span>: <span class="string">@"vmRZXZ1Dvo"</span> <span class="comment">// Photo's object id</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">AVPush</span> *push = [[<span class="built_in">AVPush</span> alloc] init];</span><br><span class="line">[push setQuery:photoOwnerQuery];</span><br><span class="line">[push setData:data];</span><br><span class="line">[push sendPushInBackground];</span><br></pre></td></tr></table></figure>
<h2 id="响应通知数据">响应通知数据</h2><p>当应用是被通知打开的时候，你可以通过 <code>application:didFinishLaunchingWithOptions:</code>方法的 <code>launchOptions</code> 参数所使用的 dictionary 访问到数据：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">  . . .</span><br><span class="line">  <span class="comment">// Extract the notification data</span></span><br><span class="line">  <span class="built_in">NSDictionary</span> *notificationPayload = launchOptions[<span class="built_in">UIApplicationLaunchOptionsRemoteNotificationKey</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a pointer to the Photo object</span></span><br><span class="line">  <span class="built_in">NSString</span> *photoId = [notificationPayload objectForKey:<span class="string">@"p"</span>];</span><br><span class="line">  <span class="built_in">AVObject</span> *targetPhoto = [<span class="built_in">AVObject</span> objectWithoutDataWithClassName:<span class="string">@"Photo"</span></span><br><span class="line">                                                          objectId:photoId];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fetch photo object</span></span><br><span class="line">  [targetPhoto fetchIfNeededInBackgroundWithBlock:^(<span class="built_in">AVObject</span> *object, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="comment">// Show photo view controller</span></span><br><span class="line">    <span class="keyword">if</span> (!error &amp;&amp; [<span class="built_in">AVUser</span> currentUser]) &#123;</span><br><span class="line">      PhotoVC *viewController = [[PhotoVC alloc] initWithPhoto:object];</span><br><span class="line">      [<span class="keyword">self</span><span class="variable">.navController</span> pushViewController:viewController animated:<span class="literal">YES</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当通知到达的时候，你的应用已经在运行，那么你可以通过 <code>application:didReceiveRemoteNotification:fetchCompletionHandler:</code> 方法的 <code>userInfo</code> 参数所使用 dictionary 访问到数据：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">      didReceiveRemoteNotification:(<span class="built_in">NSDictionary</span> *)userInfo</span><br><span class="line">            fetchCompletionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">UIBackgroundFetchResult</span>))handler &#123;</span><br><span class="line">  <span class="comment">// Create empty photo object</span></span><br><span class="line">  <span class="built_in">NSString</span> *photoId = [userInfo objectForKey:<span class="string">@"p"</span>];</span><br><span class="line">  <span class="built_in">AVObject</span> *targetPhoto = [<span class="built_in">AVObject</span> objectWithoutDataWithClassName:<span class="string">@"Photo"</span></span><br><span class="line">                                                          objectId:photoId];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fetch photo object</span></span><br><span class="line">  [targetPhoto fetchIfNeededInBackgroundWithBlock:^(<span class="built_in">AVObject</span> *object, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="comment">// Show photo view controller</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      handler(<span class="built_in">UIBackgroundFetchResultFailed</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="built_in">AVUser</span> currentUser]) &#123;</span><br><span class="line">      PhotoVC *viewController = [[PhotoVC alloc] initWithPhoto:object];</span><br><span class="line">      [<span class="keyword">self</span><span class="variable">.navController</span> pushViewController:viewController animated:<span class="literal">YES</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      handler(<span class="built_in">UIBackgroundFetchResultNoData</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以阅读 <a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Introduction.html#//apple_ref/doc/uid/TP40008194-CH1-SW1" target="_blank" rel="external">Apple 本地化和推送的文档</a> 来更多地了解推送通知。</p>
<h2 id="跟踪推送和应用的打开情况">跟踪推送和应用的打开情况</h2><p>通过 AVAnalytics 你可以跟踪通知和应用的打开情况。添加下列代码到上面例子中的 <code>application:didFinishLaunchingWithOptions:</code> 方法来收集打开信息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (application<span class="variable">.applicationState</span> != <span class="built_in">UIApplicationStateBackground</span>) &#123;</span><br><span class="line">  <span class="comment">// Track an app open here if we launch with a push, unless</span></span><br><span class="line">  <span class="comment">// "content_available" was used to trigger a background push (introduced</span></span><br><span class="line">  <span class="comment">// in iOS 7). In that case, we skip tracking here to avoid double</span></span><br><span class="line">  <span class="comment">// counting the app-open.</span></span><br><span class="line">  <span class="built_in">BOOL</span> preBackgroundPush = ![application respondsToSelector:<span class="keyword">@selector</span>(backgroundRefreshStatus)];</span><br><span class="line">  <span class="built_in">BOOL</span> oldPushHandlerOnly = ![<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(application:didReceiveRemoteNotification:fetchCompletionHandler:)];</span><br><span class="line">  <span class="built_in">BOOL</span> noPushPayload = ![launchOptions objectForKey:<span class="built_in">UIApplicationLaunchOptionsRemoteNotificationKey</span>];</span><br><span class="line">  <span class="keyword">if</span> (preBackgroundPush || oldPushHandlerOnly || noPushPayload) &#123;</span><br><span class="line">    [<span class="built_in">AVAnalytics</span> trackAppOpenedWithLaunchOptions:launchOptions];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传递 nil 或者空白的参数给 <code>trackAppOpenedWithLaunchOptions:</code> 方法只是统计一次标准的应用打开事件（比如不是通过通知打开的应用）。</p>
<p>你可以在 <a href="/stat.html?appid=#/stat/appuse">控制台 /<span class="text-muted">（选择应用）</span>/ 分析 / 行为分析 / 应用使用</a> 里看到通知和应用打开的情况。</p>
<p>请注意，如果你的应用正在运行或者在后台，<code>application:didReceiveRemoteNotification:</code>方法将会处理收到的推送通知。</p>
<div class="callout callout-info">如果你的应用处于运行状态，iOS 系统将不会在系统的通知中心显示推送消息，你可以使用 <code>UILocalNotification</code> 展示一个通知给用户。</div>

<p>如果应用在后台，并且用户点击了通知，那么应用将被带到前台可视，为了跟踪这种通过通知打开应用的情况，你需要在跟踪代码里多作一个检查：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didReceiveRemoteNotification:(<span class="built_in">NSDictionary</span> *)userInfo &#123;</span><br><span class="line">  <span class="keyword">if</span> (application<span class="variable">.applicationState</span> == <span class="built_in">UIApplicationStateActive</span>) &#123;</span><br><span class="line">    <span class="comment">// 此处可以写上应用激活状态下接收到通知的处理代码，如无需处理可忽略</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// The application was just brought from the background to the foreground,</span></span><br><span class="line">    <span class="comment">// so we consider the app as having been "opened by a push notification."</span></span><br><span class="line">    [<span class="built_in">AVAnalytics</span> trackAppOpenedWithRemoteNotificationPayload:userInfo];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用 iOS 7 推送的新特性（包括新的 content-available 功能），你需要实现 iOS 7<br>新加的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">        didReceiveRemoteNotification:(<span class="built_in">NSDictionary</span> *)userInfo</span><br><span class="line">        fetchCompletionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">UIBackgroundFetchResult</span>))completionHandler &#123;</span><br><span class="line">  <span class="keyword">if</span> (application<span class="variable">.applicationState</span> == <span class="built_in">UIApplicationStateActive</span>) &#123;</span><br><span class="line">    <span class="comment">// 此处可以写上应用激活状态下接收到通知的处理代码，如无需处理可忽略</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    [<span class="built_in">AVAnalytics</span> trackAppOpenedWithRemoteNotificationPayload:userInfo];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="跟踪本地通知_(iOS_only)">跟踪本地通知 (iOS only)</h3><p>为了统计跟踪本地通知消息，需要注意以下两种方法都会调用到：</p>
<ul>
<li><code>application:didFinishLaunchingWithOptions:</code></li>
<li><code>-application:didReceiveLocalNotification:</code></li>
</ul>
<p>如果你实现了 <code>application:didReceiveLocalNotification:</code> 这个方法，要注意避免重复统计。</p>
<h4 id="清除_Badge">清除 Badge</h4><p>清除 Badge 数字的最好时机是打开应用的时候。设置当前 installation 的 badge 属性并保存到服务器：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)applicationDidBecomeActive:(<span class="built_in">UIApplication</span> *)application &#123;</span><br><span class="line">    <span class="keyword">int</span> num=application<span class="variable">.applicationIconBadgeNumber</span>;</span><br><span class="line">    <span class="keyword">if</span>(num!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">AVInstallation</span> *currentInstallation = [<span class="built_in">AVInstallation</span> currentInstallation];</span><br><span class="line">        [currentInstallation setBadge:<span class="number">0</span>];</span><br><span class="line">        [currentInstallation saveEventually];</span><br><span class="line">        application<span class="variable">.applicationIconBadgeNumber</span>=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [application cancelAllLocalNotifications];</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>清除 Badge 数字最相关的三个方法是：</p>
<ul>
<li><code>applicationDidBecomeActive:</code></li>
<li><code>application:didFinishLaunchingWithOptions:</code></li>
<li><code>application:didReceiveRemoteNotification:</code></li>
</ul>
<p>请阅读 <a href="http://developer.apple.com/library/ios/#DOCUMENTATION/UIKit/Reference/UIApplicationDelegate_Protocol/Reference/Reference.html" target="_blank" rel="external">UIApplicationDelegate 文档</a>。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/android_start/" itemprop="url">
                下载 Android SDK
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/android_start/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/android_start/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><a id="link" class="btn btn-default" href="sdk_down.html">下载 Android SDK</a></p>

<p>下载 SDK，将下载后的文件解压缩后的所有 jar 文件放入 Android 项目的 <strong>libs</strong> 目录。如果你们的项目没有 <b>libs</b> 目录，那么就在项目的根目录下创建一个，通过右键点击项目 Project，选择 <strong>New</strong>，接下来点击 <strong>Folder</strong> 菜单即可创建新目录。</p>
<p>添加下列 <code>import</code> 语句到你的 Application 或主 Activity 类：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">import</span> <span class="tag">com</span><span class="class">.avos</span><span class="class">.avoscloud</span><span class="class">.AVOSCloud</span>;</span><br><span class="line"><span class="tag">import</span> <span class="tag">com</span><span class="class">.avos</span><span class="class">.avoscloud</span><span class="class">.AVAnalytics</span>;</span><br></pre></td></tr></table></figure>
<p>在 Application 的 <code>onCreate</code> 方法调用 <code>AVOSCloud.initialize</code> 来设置您应用的 Application ID 和 Key：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果使用美国节点，请加上这行代码 AVOSCloud.useAVCloudUS();</span></span><br><span class="line">    AVOSCloud.initialize(<span class="keyword">this</span>, <span class="string">"&#123;&#123;appid&#125;&#125;"</span>, <span class="string">"&#123;&#123;appkey&#125;&#125;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建应用后，可以在 <a href="/app.html?appid=#/key">控制台 - 应用设置</a> 里面找到应用对应的 id 和 key。</p>
<p>同时，你的应用需要请求 <code>INTERNET</code> 和 <code>ACCESS_NETWORK_STATE</code> 权限，如果没有设置，请添加下列两行到你的 <code>AndroidManifest.xml</code> 文件里的 <code>&lt;application&gt;</code> 标签前：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:<span class="property">name</span>=<span class="string">"android.permission.INTERNET"</span> /&gt;</span><br><span class="line">&lt;uses-permission android:<span class="property">name</span>=<span class="string">"android.permission.ACCESS_NETWORK_STATE"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>如果你想跟踪统计应用的打开情况，添加下列代码到你的主 <code>Activity</code> 的 <code>onCreate</code> 方法：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">AVAnalytics</span><span class="class">.trackAppOpened</span>(<span class="tag">getIntent</span>());</span><br></pre></td></tr></table></figure>
<p>接下来可以尝试测试一段代码，拷贝下列代码到你的 app 里，比如放到 <code>Application.onCreate</code> 方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AVObject <span class="built_in">test</span>Object = new AVObject(<span class="string">"TestObject"</span>);</span><br><span class="line"><span class="built_in">test</span>Object.put(<span class="string">"foo"</span>, <span class="string">"bar"</span>);</span><br><span class="line"><span class="built_in">test</span>Object.saveInBackground();</span><br></pre></td></tr></table></figure>
<p>运行你的 app。一个类 <code>TestObject</code> 的新对象将被发送到 LeanCloud 并保存下来。当你做完这一切，访问 <a href="/data.html?appid=#/TestObject">控制台 - 数据管理</a> 可以看到上面创建的 <code>TestObject</code> 的相关数据。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/android_statistics/" itemprop="url">
                Android 统计 SDK 开发指南
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/android_statistics/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/android_statistics/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="Android_统计_SDK_开发指南">Android 统计 SDK 开发指南</h1><h2 id="安装与初始化">安装与初始化</h2><p>首先在 <a href="https://leancloud.cn/applist.html#/apps" target="_blank" rel="external">控制台</a> 上创建新的应用，然后 <a href="sdk_down.html">下载 LeanCloud Android SDK</a> 以及相应的 Demo。</p>
<h3 id="导入_SDK">导入 SDK</h3><p>除了必须的 avoscloud.jar 外，你还需要额外的导入 avosstatistics.jar。<br>请将下载的 jar 包放到 libs 目录下，以便你的 IDE（Eclipse 或者 Intellij IDEA 等)可以正常识别导入的 jar 包。如以下图片所示：</p>
<p><img src="/avos/images/android_statistics_ide.png" alt="image"></p>
<h3 id="配置_AndroidManifest-xml_文件">配置 AndroidManifest.xml 文件</h3><p>请务必确保你的应用拥有如下权限：</p>
<ul>
<li><code>android.permission.INTERNET</code><br><br>向 LeanCloud 的统计服务器发送用户分析数据。</li>
<li><code>android.permission.READ_PHONE_STATE</code><br><br><code>android.permission.ACCESS_WIFI_STATE</code><br><br>这两个权限是为了获取用户手机的 IMEI 以及 WiFi 的 Mac 地址，用来唯一的标识用户。</li>
<li><code>android.permission.ACCESS_NETWORK_STATE</code><br><br>检测网络状态。</li>
<li><code>android.permission.READ_LOGS</code><br><br>获取客户端 crash log。通过将 crash log 汇报到服务器上，你可以了解你的应用 crash 的原因以及次数。</li>
<li><code>android.permission.WRITE_EXTERNAL_STORAGE</code><br><br>保存离线报告的缓存数据。</li>
</ul>
<p>示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">manifest</span> <span class="attribute">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">application</span> <span class="attribute">...</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="title">activity</span> <span class="attribute">...</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">application</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.WRITE_EXTERNAL_STORAGE"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.INTERNET"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.ACCESS_NETWORK_STATE"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.READ_PHONE_STATE"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.ACCESS_WIFI_STATE"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.READ_LOGS"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果你想指定你的发布渠道，请在 AndroidManifest.xml 中加入如下内容：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">application</span>  <span class="attribute">...</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="title">meta-data</span> <span class="attribute">android:name</span>=<span class="value">"Channel ID"</span> <span class="attribute">android:value</span>=<span class="value">"LeanCloud"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">application</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>你可以根据你的实际发布渠道，修改上述的 android:value 中对应的值，比如将 <code>LeanCloud</code> 改为 <code>Your Channel</code>，重新打包后发布。<strong>请不要修改 <code>android:name=&quot;Channel ID&quot;</code> 字段，以免影响使用。</strong></p>
<p>由于很多用户反映在部分第三方发布平台中间，不允许出现 meta-data 中间的 key 出现空格字符，我们在 2.6.8 以后，增加了一个等效的 key：<code>leancloud</code>。<br>以下代码也可以用于指定渠道了，但是请不要反复定义。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">application</span>  <span class="attribute">...</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="title">meta-data</span> <span class="attribute">android:name</span>=<span class="value">"leancloud"</span> <span class="attribute">android:value</span>=<span class="value">"LeanCloud"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">application</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当然你也可以通过代码来指定发布渠道。但是代码设置的渠道优先级没有 <code>AndroidManifest.xml</code> 中的配置高，同时出现时优先取 <code>AndroidManifest.xml</code> 中的配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">AVAnalytics.setAppChannel(<span class="string">"SomeChannel"</span>);</span><br><span class="line"><span class="comment">// 参数依次是 context, appId, appKey</span></span><br><span class="line">AVOSCloud.initialize(getContext(),<span class="string">"&#123;&#123;appid&#125;&#125;"</span>,<span class="string">"&#123;&#123;appKey&#125;&#125;"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="添加使用代码">添加使用代码</h2><h3 id="添加引用">添加引用</h3><p>经过我们的一系列更新升级，使用最新的 SDK 你不需要任何代码上的操作就可以使用统计的基本功能，统计功能为默认打开。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.avos.avoscloud.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YourApp</span> <span class="keyword">extends</span> <span class="title">Application</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        AVOSCloud.initialize(<span class="keyword">this</span>, <span class="string">"&#123;&#123;appid&#125;&#125;"</span>, <span class="string">"&#123;&#123;appkey&#125;&#125;"</span>);</span><br><span class="line">        <span class="comment">//AVAnalytics.start(this);    已经不再需要这行代码了</span></span><br><span class="line">        AVAnalytics.enableCrashReport(<span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="统计页面路径">统计页面路径</h2><p>在需要的 Activity 中调用统计 SDK。在每个 Activity 的 <code>onResume</code> 和 <code>onPause</code> 方法中调用相应的统计方法，传入的参数为当前 context（比如当前的 Activity）的引用。 这里请不要将全局的 Application Context 传入。如示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onPause();</span><br><span class="line">    AVAnalytics.onPause(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume();</span><br><span class="line">    AVAnalytics.onResume(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请确保在所需要的所有的 Activity 中都调用 <code>AVAnalytics.onResume()</code> 和 <code>AVAnalytics.onPause()</code> 方法，这两个调用将不会阻塞应用程序的主线程，也不会影响应用程序的性能。</p>
<p>注意：如果你的 Activity 之间有继承或者控制关系请不要同时在父和子 Activity 中重复添加 onPause 和 onResume 方法，否则会造成重复统计，比如在使用 TabHost、TabActivity、ActivityGroup 时。一个应用程序在多个 Activity 之间连续切换时，将会被视为同一个 session（会话或者一次使用过程）。</p>
<p>当用户两次使用之间间隔超过 30 秒时，将被认为是两个的独立的 session，例如用户回到 home，或进入其他程序，经过一段时间后再返回之前的应用。我们也提供了新的接口来自定义这个时间间隔，你只要调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVAnalytics.setSessionContinueMillis(<span class="keyword">long</span> mills);</span><br></pre></td></tr></table></figure>
<p>传入适当的参数，就可以控制 session 重新启动时间，注意参数是以毫秒为单位的。 例如，如果你认为在 60 秒之内返回应用可视为同一次启动，超过 60 秒返回当前应用可视为一次新的启动，那么请写成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVAnalytics.setSessionContinueMillis(<span class="number">60</span> * <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<h2 id="统计_Fragment_页面">统计 Fragment 页面</h2><p>Android 3.0 引入了 Fragment。使用 Fragment，你可以在一个 Activity 中展示多个用户界面，也可根据你的需要，为不同的设备适配界面。LeanCloud SDK 1.4.2 开始增加了对于 Fragment 统计的支持。你可以使用以下代码统计 Fragment 页面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListFragment</span> <span class="keyword">extends</span> <span class="title">ListFragment</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttach</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onAttach(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">        AVAnalytics.onFragmentEnd(<span class="string">"my-list-fragment"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        AVAnalytics.onFragmentStart(<span class="string">"my-list-fragment"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试">测试</h2><ul>
<li>确认所需的权限都已经添加：<ul>
<li><code>INTERNET</code></li>
<li><code>READ_PHONE_STATE</code></li>
<li><code>READ_LOGS</code></li>
<li><code>WRITE_EXTERNAL_STORAGE</code></li>
</ul>
</li>
<li>确认所有的 Activity 中都调用了 onResume 和 onPause 方法。</li>
<li>确认测试手机（或者模拟器）已成功连入网络。</li>
<li>启动应用程序，几分钟之内你应该已经可以在 <a href="/stat.html?appid=}#/statrealtime">控制台 / 分析</a> 中的相应菜单中看到报表了。</li>
</ul>
<h2 id="数据时效性">数据时效性</h2><p>在控制台的 <strong>分析</strong> 页面中，有些报告可以展示实时数据，有些报告则依靠 <a href="leaninsight_guide.html">离线数据</a> 进行分析，因此有时你会看不到当天的数据。</p>
<p>如果当前页面中存在 <strong>日期选择</strong> 选项（通常在页面右上角），你可以以此判断当前的统计结果是否有延迟。如果 <strong>结束日期</strong> 显示为 <strong>当日日期</strong> 或在其下拉菜单中有「今日」选项，即为实时数据；反之则为离线数据（如下图所示），要推迟一天才能看到当日的情况。</p>
<p><img src="../images/analytics_datepicker_for_offline_data.png" alt="" width="231" height="256"></p>
<h2 id="使用自定义事件">使用自定义事件</h2><h3 id="基本简单事件">基本简单事件</h3><p>除了基本统计分析功能外，SDK 还支持你自定义的事件分析，例如你可以统计你的应用中有多少人点击了 like 按键，某个文章的点击次数或者视频被播放的次数等等。</p>
<p>在你希望发送事件报告的代码段，调用如下方法就可以向服务器发送事件记录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVAnalytics.onEvent(Context context, String eventName);</span><br></pre></td></tr></table></figure>
<p>统计 eventName 对应事件的发生次数、变化趋势，例如 like 点击、浏览数量等等。参数 context 为当前 context 的引用。eventName 为当前统计的事件 name。【注意】eventName 中不要加空格或其他的转义字符。</p>
<p>比如，应用中的一条微视频被转发的事件被定义为「Forward」，那么在点击转发的函数里调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVAnalytics.onEvent(<span class="keyword">this</span>, <span class="string">"Forward"</span>)</span><br></pre></td></tr></table></figure>
<p>就会向服务器汇报一个转发的事件。</p>
<h3 id="多标签事件">多标签事件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVAnalytics.onEvent(Context context, String eventName, String  tag);</span><br></pre></td></tr></table></figure>
<p>除了能够统计 eventName 所对应事件的发生次数，变化趋势外，还能统计事件中具体标签所占的比例。tag 为当前标签，同样这里的 eventName 字符串中也请不要使用空格。<br>比如，在玩拍程序中，我们定义了一个发布微视频的多标签事件 Publish，对应的发布内容有 title（发布标题）、Video（发视频）、type（视频类型）来对应不同的发布类型，这样我们不仅可以记录 Publish 事件的点击数量还可以看到不同内容对应的比例。</p>
<h3 id="事件累计">事件累计</h3><p>在应用程序中某些自定义事件可能会被频繁触发，例如用户点击某个按钮。开发者可以在程序中维护一个计数器，这样某个事件被多次触发但只需要生成一个消息，这个消息中包括该事件被触发的次数。为了支持这个功能，我们提供了重载的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AVAnalytics.onEvent(Context context, String eventName, <span class="keyword">int</span> count);</span><br><span class="line">AVAnalytics.onEvent(Context context, String eventName, String label, <span class="keyword">int</span> count)</span><br></pre></td></tr></table></figure>
<p>参数 count 是对应事件（和对应标签）被触发的次数。</p>
<h2 id="设置数据发送策略">设置数据发送策略</h2><p>你可以进入应用的 <a href="/stat.html?appid=&amp;os=android#/statconfig/trans_strategoy"><strong>分析</strong> &gt; <strong>统计设置</strong><span class="text-muted">（左下角）</span> &gt; <strong>数据发送策略</strong></a> 在线更改 SDK 端的数据报告发送策略。在没有取到在线配置的发送策略的情况下，会使用默认的发送策略。</p>
<p>以下均为在线配置中的可选策略。</p>
<h3 id="启动时发送">启动时发送</h3><p>【推荐使用】应用程序每次会在启动时会向服务器发送一次消息，在应用程序过程中产生的所有消息（包括自定义事件和本次使用时长）都会在下次启动时候发送。如果应用程序启动时处在不联网状态，那么消息将会缓存在本地，下次再尝试发送。</p>
<p>发送策略默认为启动时发送。</p>
<h3 id="批量发送">批量发送</h3><p>批量发送，默认当消息数量达到 30 条时发送一次。</p>
<h3 id="按最小间隔发送">按最小间隔发送</h3><p>间隔一段时间发送，每隔一段时间一次性发送到服务器。</p>
<h2 id="自定义参数设置">自定义参数设置</h2><p>你可以控制台某个应用的 <strong>组件</strong> &gt; <strong>自定义参数</strong> 设置中配置你的自定义在线参数。这些参数会在我们每次更新统计配置时进行更新，你可以用以下方法来获得对应的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVAnalytics.getConfigParams(<span class="keyword">this</span>.getContext(), <span class="string">"key"</span>)</span><br></pre></td></tr></table></figure>
<p>但是请注意三点：</p>
<ul>
<li>key 必须跟你在控制台配置的参数一致，大小写敏感。</li>
<li><p>由于统计参数更新时一个后台更新，你可能在直接调用 <code>AVAnalytics.getConfigParams(this.getContext(), &quot;key&quot;)</code> 时遇到返回值为 null 的情况。你可以通过设置 AVOnlineConfigureListener 和强制调用 updateOnlineConfig 来保证自定义配置的获取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AVAnalytics.setOnlineConfigureListener(<span class="keyword">new</span> AVOnlineConfigureListener() &#123;</span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataReceived</span><span class="params">(JSONObject data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       AVAnalytics.getConfigParams(getContext(), <span class="string">"key"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;);</span><br><span class="line">AVAnalytics.updateOnlineConfig(getContext());</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于统计参数在客户端会有定时更新的策略，所以 AVOnlineConfigureListener 在客户端会发生多次调用的情况，请在 OnDataReceived 方法中不要放入太多函数副作用。</p>
</li>
</ul>
<h2 id="开发选项">开发选项</h2><p>如果你不准备区分开发 AppKey 与生产环境 AppKey，但是又不想开发时期的统计数据会影响产品上线后的统计数据，你可以使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AVAnalytics.setAnalyticsEnabled(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 参数依次为 context, AppId, AppKey</span></span><br><span class="line">AVOSCloud.initialize(context,&#123;&#123;appid&#125;&#125;,&#123;&#123;appkey&#125;&#125;);</span><br></pre></td></tr></table></figure>
<p>在开发阶段关闭统计的功能。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/cloud_code_faq/" itemprop="url">
                云引擎常见问题和解答
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/cloud_code_faq/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/cloud_code_faq/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="云引擎常见问题和解答">云引擎常见问题和解答</h1><h2 id="如何判断当前是测试环境还是生产环境？">如何判断当前是测试环境还是生产环境？</h2><p>请参考文档 <a href="/leanengine_guide-node.html#运行环境区分">云引擎开发指南 Node.js</a> / <a href="/leanengine_guide-python.html#运行环境区分">Python</a> - 运行环境区分。</p>
<h2 id="怎么添加第三方模块">怎么添加第三方模块</h2><p>云引擎 2.0 开始支持添加第三方模块（请参考 <a href="leanengine_guide-cloudcode.html#云代码_2_0_版">云引擎指南 - 升级到 2.0</a>），只需要像普通的 Node.js 项目那样，在项目根目录创建文件 <code>package.json</code>，下面是一个范例：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">name</span>": <span class="value"><span class="string">"cloud-engine-test"</span></span>,</span><br><span class="line">  "<span class="attribute">description</span>": <span class="value"><span class="string">"Cloud Engine test project."</span></span>,</span><br><span class="line">  "<span class="attribute">version</span>": <span class="value"><span class="string">"0.0.1"</span></span>,</span><br><span class="line">  "<span class="attribute">private</span>": <span class="value"><span class="literal">true</span></span>,</span><br><span class="line">  "<span class="attribute">dependencies</span>": <span class="value">&#123;</span><br><span class="line">    "<span class="attribute">async</span>": <span class="value"><span class="string">"0.9.0"</span></span>,</span><br><span class="line">    "<span class="attribute">moment</span>": <span class="value"><span class="string">"2.9.0"</span></span><br><span class="line">  </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p><code>dependencies</code> 内的内容表明了该项目依赖的三方模块（比如示例中的 <code>async</code> 和 <code>moment</code>）。</p>
<p>然后在项目根目录执行：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span></span><br></pre></td></tr></table></figure>
<p>即可下载相关三方包到 <code>node_modules</code> 目录。</p>
<p>然后即可在代码中引入三方包：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">async</span> = <span class="built_in">require</span>(<span class="string">'async'</span>);</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：命令行工具部署时是不会上传 <code>node_modules</code> 目录，因为云代码服务器会根据 <code>package.json</code> 的内容自动下载三方包。所以也建议将 <code>node_modules</code> 目录添加到 <code>.gitignore</code> 中，使其不加入版本控制。</p>
<h2 id="Maximum_call_stack_size_exceeded_如何解决？">Maximum call stack size exceeded 如何解决？</h2><p><code>AV.Object.extend</code> 产生的对象需要作为全局变量保存（即定义在 AV.Cloud.define 方法之外）。因为每调用一次，就会产生一个新的类的实例，并且和之前创建的实例形成一个链表。调用次数过多后（几万次）就会堆栈溢出。如果你的应用时不时出现 <strong>Maximum call stack size exceeded</strong> 错误，请确认是否误用了 <code>AV.Object.extend</code> 方法。</p>
<p>我们在 <a href="./js_guide.html#AV_Object">JavaScript 指南 - AV.Object</a> 章节中也进行了描述。</p>
<h2 id="目前支持哪些语言？">目前支持哪些语言？</h2><p>我们提供了 JavaScript SDK，支持 Node.js 和 Python 环境，未来可能会引入 PHP 等其他语言。</p>
<h2 id="Web_Hosting_备案如何操作？">Web Hosting 备案如何操作？</h2><p>只有网站类的才需要备案，并且在主域名已备案的情况下，二级子域名不需要备案。 如果主站需要托管在我们这边，且还没有备案过，我们可以协助你完成备案，请参考文档 <a href="leanengine_guide-node.html#绑定独立域名">绑定独立域名 Node.js</a> / <a href="leanengine_guide-python.html#绑定独立域名">Python</a>。</p>
<h2 id="调用云引擎方法如何收费？">调用云引擎方法如何收费？</h2><p>现在云引擎本身不收费，云引擎中如果有 LeanCloud 的存储等 API 调用，按 API 收费策略收费。</p>
<h2 id="「定义函数」和「Git_部署」可以混用吗？">「定义函数」和「Git 部署」可以混用吗？</h2><p>「定于函数」的产生是为了方便大家初次体验云引擎，或者只是需要一些简单 hook 方法的应用使用。我们的实现方式就是把定义的函数拼接起来，生成一个云引擎项目然后部署。</p>
<p>所以可以认为「定义函数」和 「git 部署」最终是一样的，都是一个完整的项目。<br>是一个单独功能，可以不用使用基础包，git 等工具快速的生成和编辑云引擎。<br>当然，你也可以使用基础包，自己写代码并部署项目。<br>这两条路是分开的，任何一个部署，就会导致另一种方式失效掉。</p>
<h2 id="为什么查询_include_没有生效？">为什么查询 include 没有生效？</h2><p>以 JavaScript 云引擎为例子，很多时候，经常会定义一个云函数，在里面使用 <code>AV.Query</code> 查询一张表，并 include 其中一个 pointer 类型的字段，然后返回给客户端:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AV.Cloud.define(<span class="string">'querySomething'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> query = <span class="keyword">new</span> AV.Query(<span class="string">'Something'</span>);</span><br><span class="line">  <span class="comment">//假设 user 是 Something 表的一个 Pointer 列。</span></span><br><span class="line">  query.include(<span class="string">'user'</span>);</span><br><span class="line">  <span class="comment">//……其他条件或者逻辑……</span></span><br><span class="line">  query.find().then(<span class="function"><span class="keyword">function</span>(<span class="params">results</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//返回查询结果给客户端</span></span><br><span class="line">    res.success(results);</span><br><span class="line">  &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//返回错误给客户端</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>你会看到返回的结果里， user 仍然是 pointer 类型，似乎 include 没有生效？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> result: [</span><br><span class="line">   &#123;</span><br><span class="line">     ……Something 其他字段</span><br><span class="line">     "user": &#123;</span><br><span class="line">       "className": "_User",</span><br><span class="line">       "__type": "Pointer",</span><br><span class="line">       "objectId": "abcdefg"</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ……</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这其实是因为 <code>res.success(results)</code> 会调用到 <code>AV.Object#toJSON</code> 方法，将结果序列化为 JSON 对象返回给客户端。<br>而 <code>AV.Object#toJSON</code> 方法为了防止循环引用，当遇到属性是 Pointer 类型会返回 pointer 元信息，不会将 include 的其他字段添加进去。<br>因此，你需要主动将该字段进行 JSON 序列化，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">query.find().then(<span class="function"><span class="keyword">function</span>(<span class="params">results</span>) </span>&#123;</span><br><span class="line">   <span class="comment">//主动序列化 json 列。</span></span><br><span class="line">   results.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">     result.set(<span class="string">'user'</span>, result.get(<span class="string">'user'</span>) ?  result.get(<span class="string">'user'</span>).toJSON() : <span class="literal">null</span>);</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="comment">//再返回结果</span></span><br><span class="line">   res.success(results);</span><br><span class="line"> &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">   <span class="comment">//返回错误给客户端</span></span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/avos/cql_guide/" itemprop="url">
                Cloud Query Language
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T07:56:29+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/leancloud/" itemprop="url" rel="index">
                  <span itemprop="name">leancloud</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/30/avos/cql_guide/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/30/avos/cql_guide/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="Cloud_Query_Language_详细指南">Cloud Query Language 详细指南</h1><p>Cloud Query Language（简称 CQL） 是 LeanCloud 为查询 API 定制的一套类似 SQL 查询语法的子集和变种，主要目的是降低大家学习 LeanCloud 查询的 API 的成本，可以使用传统的 SQL 语法来查询 LeanCloud 应用内的数据。</p>
<p>本文档将详细介绍 CQL 的语法和常见用法。</p>
<h2 id="介绍及基本语法">介绍及基本语法</h2><p>最基本的一个查询某个 class 下的 100 条数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore</span></span><br></pre></td></tr></table></figure>
<p>等价于（以 Android 为例子）:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AVQuery&lt;AVObject&gt; query = <span class="keyword">new</span> AVQuery&lt;AVObject&gt;(<span class="string">"GameScore"</span>);</span><br><span class="line">List&lt;AVObject&gt; avObjects = query.find()</span><br></pre></td></tr></table></figure>
<p><code>select</code> 一个完整的语法形式类似这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> [查询字段列表，逗号隔开] <span class="keyword">from</span> [<span class="keyword">class</span> 名称]</span><br><span class="line">   [<span class="keyword">where</span> [条件列表]</span><br><span class="line">   [<span class="keyword">limit</span> [<span class="keyword">skip</span>],<span class="keyword">limit</span></span><br><span class="line">   [<span class="keyword">order</span> <span class="keyword">by</span> [排序字段列表] [<span class="keyword">asc</span> |<span class="keyword">desc</span>]]]]</span></span><br></pre></td></tr></table></figure>
<p>一些小例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//查询结果只包含 name,score 以及内置字段(objectId,createdAt等)</span><br><span class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">name</span>,score <span class="keyword">from</span> GameScore</span><br><span class="line"></span><br><span class="line">//根据 <span class="keyword">name</span> 查找</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'dennis'</span></span><br><span class="line"></span><br><span class="line">//根据 <span class="keyword">name</span> 和 score 同时查找</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">is</span> <span class="keyword">exists</span> <span class="keyword">and</span> score &gt; <span class="number">80</span> <span class="keyword">and</span> score &lt;= <span class="number">100</span></span><br><span class="line"></span><br><span class="line">//分页查找，从第 <span class="number">100</span> 条开始向后查找 <span class="number">10</span> 条数据</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">limit</span> <span class="number">100</span>,<span class="number">10</span></span><br><span class="line"></span><br><span class="line">//根据 score 和 <span class="keyword">name</span> 排序</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">order</span> <span class="keyword">by</span> score,+<span class="keyword">name</span> <span class="keyword">desc</span></span></span><br></pre></td></tr></table></figure>
<h2 id="查询条件">查询条件</h2><p><code>where</code> 之后的查询条件基本跟 SQL 语法相似，比如支持 <code>or</code> 和 <code>and</code> 的复合查询，支持 <code>=</code>、<code>!=</code>、<code>&lt;</code>、<code>&lt;</code> 等比较运算符，支持子查询、in 查询等。详细解释如下。</p>
<h3 id="基本查询">基本查询</h3><p>查询指定信息的对象，用 <code>=</code> 比较符：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'dennis'</span></span></span><br></pre></td></tr></table></figure>
<p>查询不等于指定信息的对象：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span>!=<span class="string">'dennis'</span></span></span><br></pre></td></tr></table></figure>
<p>也可以用 <code>&lt;&gt;</code> 运算符来表示不等于。</p>
<p>比较日期，使用 <code>date</code> 函数来转换，比如查询特定时间之前创建的对象：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> createdAt &lt; <span class="built_in">date</span>(<span class="string">'2011-08-20T02:06:57.931Z'</span>)</span></span><br></pre></td></tr></table></figure>
<p>date 函数接收的日期格式必须是 <code>2011-08-20T02:06:57.931Z</code> 的 UTC 时间。更多内置函数请看最后的 <a href="#内置函数">内置函数</a> 部分。</p>
<p>一些常见的查询运算符：</p>
<table><br>  <tr><th>Key</th><th>Operation</th></tr><br>  <tr><td>&lt;</td><td>小于</td></tr><br>  <tr><td>&lt;=</td><td>小于等于</td></tr><br>  <tr><td>&gt;</td><td>大于</td></tr><br>  <tr><td>&gt;=</td><td>大于等于</td></tr><br>  <tr><td> != 或者 &lt;&gt;</td><td>不等于</td></tr><br>  <tr><td>[not] like</td><td>模糊查询</td></tr><br>  <tr><td>[not] regexp</td><td>正则匹配</td></tr><br>  <tr><td>[not] in(子查询或者数组)</td><td>包含或者不包含</td></tr><br>  <tr><td>is [not] exists</td><td>这个 Key 有值或者不存在值</td></tr><br></table>

<p>比较运算符可以用在日期、字符串、数字甚至对象上。</p>
<h4 id="模糊查询">模糊查询</h4><p>模糊查询可以使用 <code>like</code>，比如查询名字以 dennis 开头的对象。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'dennis%'</span></span></span><br></pre></td></tr></table></figure>
<p><code>%</code> 表示模糊匹配的位置占位符。</p>
<p>like 本质上是转成 <code>regexp</code> 的正则匹配查询，因此上面的例子还可以写成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span> regexp <span class="string">'dennis.*'</span></span></span><br></pre></td></tr></table></figure>
<p>否定形式，查询名字不以 dennis 开头的对象：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">not</span> <span class="keyword">like</span> <span class="string">'dennis%'</span></span><br><span class="line">或者</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">not</span> regexp <span class="string">'dennis.*'</span></span></span><br></pre></td></tr></table></figure>
<p>正则匹配的效率一般，类似这种全文搜索请求，我们都推荐采用 <a href="app_search_guide.html">应用内全文搜索</a>。</p>
<h5 id="值是否存在查询">值是否存在查询</h5><p>只返回 <code>level</code> 字段值存在的对象：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">level</span> <span class="keyword">is</span> <span class="keyword">exists</span></span></span><br></pre></td></tr></table></figure>
<p>反之，使用 <code>is not exists</code>。</p>
<h3 id="数组查询">数组查询</h3><p>假设 <code>scores</code> 字段是一个数组，我们想查询分数里有 100 的成绩列表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> scores=<span class="number">100</span></span></span><br></pre></td></tr></table></figure>
<p>如果想查找分数<strong>只有</strong>两个 100 分的成绩：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> scores all (<span class="number">100</span>,<span class="number">100</span>)</span></span><br></pre></td></tr></table></figure>
<p><code>all</code> 表示数组完全匹配。</p>
<p>查询数组长度为特定值的对象：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="function"><span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="title">size</span>(<span class="params">scores</span>) </span>= <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>数组长度查询仅支持等于号，不支持大小和小于等其他比较运算符。</p>
<h3 id="子查询">子查询</h3><p>使用 <code>in</code> 来做子查询，后面跟的可以是一个列表，例如查询名字是 dennis、catty 和 green 三个玩家的成绩：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">in</span> (<span class="string">'dennis'</span>,<span class="string">'catty'</span>,<span class="string">'green'</span>)</span></span><br></pre></td></tr></table></figure>
<p>当然，如果想查询的不在列表里，那可以使用 <code>not in</code>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">'dennis'</span>,<span class="string">'catty'</span>,<span class="string">'green'</span>)</span></span><br></pre></td></tr></table></figure>
<p>in 后面还可以是一个子查询，比如查询玩家信息，并且成绩大于 80 分的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> Player <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> GameScore <span class="keyword">where</span> score&gt;<span class="number">80</span>)</span></span><br></pre></td></tr></table></figure>
<p>注意子查询必须指定查询的字段名称是 <code>select name</code>。</p>
<p>子查询另一种常见形式是使用 <code>=</code> 或 <code>!=</code> 跟一条查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> Player <span class="keyword">where</span> <span class="keyword">name</span> =(<span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> GameScore <span class="keyword">where</span> score&gt;<span class="number">80</span>)</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> Player <span class="keyword">where</span> <span class="keyword">name</span> !=(<span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> GameScore <span class="keyword">where</span> score&lt;=<span class="number">80</span>)</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：子查询的语句也受上限 1000 条记录的限制。</strong></p>
<h3 id="地理位置信息查询">地理位置信息查询</h3><p>可以通过 CQL 进行地理位置信息查询，比如我想查询自己附近的玩家（从近到远排序），假设 <code>location</code> 字段是 GeoPoint 类型：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> Player <span class="keyword">where</span> location near [<span class="number">116.4</span>, <span class="number">39.9</span>]</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>[116.4, 39.9]</code> 是经纬度坐标。也可以使用 <code>geopoint</code> 函数来创建：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> Player <span class="keyword">where</span> location near geopoint(<span class="number">116.4</span>, <span class="number">39.9</span>)</span></span><br></pre></td></tr></table></figure>
<p>只有在地理位置信息查询里才可以使用 <code>[longitude, latitude]</code> 这样的语法。在其他查询里将被作为数组类型。</p>
<p>为了限定搜索的最大距离，还可以使用 <code>max [距离]</code> 来限定，比如限定在 1 公里内：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> Player <span class="keyword">where</span> location near geopoint(<span class="number">116.4</span>, <span class="number">39.9</span>) <span class="keyword">max</span> <span class="number">1</span> km</span></span><br></pre></td></tr></table></figure>
<p>距离长度的其他单位包括 <code>miles</code>（英里）和 <code>radians</code>（弧度），如果不提供明确的单位，默认是<strong>弧度</strong>。</p>
<p>通过 <code>min [距离]</code> 还可以限定最小距离：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> Player <span class="keyword">where</span> location near geopoint(<span class="number">116.4</span>, <span class="number">39.9</span>) <span class="keyword">min</span> <span class="number">0.5</span> km</span></span><br></pre></td></tr></table></figure>
<p><code>min</code> 和 <code>max</code> 同时限定的时候，<code>min</code> 必须出现在 <code>max</code> 之前：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> Player <span class="keyword">where</span> location near geopoint(<span class="number">116.4</span>, <span class="number">39.9</span>) <span class="keyword">min</span> <span class="number">0.5</span> km <span class="keyword">max</span> <span class="number">1</span> km</span></span><br></pre></td></tr></table></figure>
<p>如果想查询某个矩形框内的对象，可以使用 <code>within [西南坐标] and [东北坐标]</code> 的语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> Player <span class="keyword">where</span> location <span class="keyword">within</span> [<span class="number">116.33</span>, <span class="number">39.97</span>] <span class="keyword">and</span> [<span class="number">116.37</span>, <span class="number">39.99</span>]</span></span><br></pre></td></tr></table></figure>
<h3 id="查询个数(count)">查询个数(count)</h3><p>使用 <code>count</code> 查询来返回符合查询条件的数目，比如查询整张表的记录数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> GameScore</span></span><br></pre></td></tr></table></figure>
<p><code>count</code> 不支持 <code>distinct</code> 等语法。仅限 <code>count(*)</code> 和 <code>count(objectId)</code>。</p>
<p>查询分数大于 60 并且小于等于 80 的成绩数目：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> GameScore <span class="keyword">where</span> score&gt;<span class="number">60</span> <span class="keyword">and</span> score&lt;=<span class="number">80</span></span></span><br></pre></td></tr></table></figure>
<p>查询个数的同时可以返回对象：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">count</span>(*),* <span class="keyword">from</span> GameScore</span></span><br></pre></td></tr></table></figure>
<p>也可以返回特定的字段：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">count</span>(*),<span class="keyword">name</span> <span class="keyword">from</span> GameScore</span></span><br></pre></td></tr></table></figure>
<h3 id="关系查询">关系查询</h3><p>有几种方式来查询对象之间的关系数据。如果你想获取对象，而这个对象的一个字段对应了另一个对象， 你可以用一个 where 查询，自己构造一个 Pointer，和其他数据类型一样。</p>
<p>举例说，如果每一个 Comment 有一个 Post 对象在它的 post 字段上（Pointer 类型），你可以对一个 post 取得所有 comment：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">Comment</span> <span class="keyword">where</span> post=pointer(<span class="string">'Post'</span>,<span class="string">'51e3a359e4b015ead4d95ddc'</span>)</span></span><br></pre></td></tr></table></figure>
<p><code>pointer</code> 函数接收 className 和 objectId。</p>
<p>如果你想获取对象, 这个对象的一个字段指向的对象（必须是 Pointer）是符合另一个查询的， 你可以使用 in 查询。注意默认的 limit 是 100 而且最大的 limit 是 1000，这个限制同样适用于内部的查询，所以对于较大的数据集你可能需要细心地构建查询来获得期望的行为。举例说，假设你有一个 Post 类和一个 Comment 类，每个 Comment 都有一个指向它的 Post 的 Pointer，你可以找到对于有图片的 Post 的 Comment：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">Comment</span> <span class="keyword">where</span> post <span class="keyword">in</span> (<span class="keyword">select</span> * <span class="keyword">from</span> Post <span class="keyword">where</span> image <span class="keyword">is</span> <span class="keyword">exists</span>)</span></span><br></pre></td></tr></table></figure>
<p>如果 Post 下面有一个 key 是 Relation 类型，并且叫做 likes，存储了喜欢这个 Post 的 User。你可以找到这些 user，他们都 like 过同一个指定的 post：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> _User <span class="keyword">where</span> related likes <span class="keyword">to</span> pointer(<span class="string">'Post'</span>, <span class="string">'51e3a359e4b015ead4d95ddc'</span>)</span></span><br></pre></td></tr></table></figure>
<p>基本的查询形式是 <code>releated &lt;key&gt; to &lt;pointer&gt;</code>。</p>
<p>如果某个字段是 Pointer，默认查询的时候，只会返回 <code>{__type: &#39;Pointer&#39;, objectId: &#39;objectId&#39;, className:&#39;Post&#39;}</code> 这些基本信息，如果希望同时将这个对象的其他信息查询下来，可以使用 include，比如查询 Comment 同时将 Post 带下来：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">include</span> post, * <span class="keyword">from</span> <span class="keyword">Comment</span></span></span><br></pre></td></tr></table></figure>
<p>在 select 中采用 <code>include &lt;key&gt;</code> 就可以将某个 Pointer 字段关联查询出来。多个字段要多次 include：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">include</span> post,<span class="keyword">include</span> author <span class="keyword">from</span> <span class="keyword">Comment</span></span></span><br></pre></td></tr></table></figure>
<p>同样，还可以支持嵌套的 include 查询，比如 Post 里还有一个 Pointer 指向 Category：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">include</span> post.<span class="keyword">category</span>,* <span class="keyword">from</span> <span class="keyword">Comment</span></span></span><br></pre></td></tr></table></figure>
<h3 id="复合查询">复合查询</h3><p>你可以使用 <code>and</code> 和 <code>or</code> 来做符合查询，例如查询分数在 80 到 100 之间，可以用 <code>and</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> score&gt;<span class="number">80</span> <span class="keyword">and</span> score&lt;=<span class="number">100</span></span></span><br></pre></td></tr></table></figure>
<p>再加个条件，或者分数为 0 分的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> score&gt;<span class="number">80</span> <span class="keyword">and</span> score&lt;=<span class="number">100</span> <span class="keyword">or</span> score=<span class="number">0</span></span></span><br></pre></td></tr></table></figure>
<p><code>and</code> 的优先级高于 <code>or</code>，因此上面的查询也可以用括号来明确地表示这种优先级：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> (score&gt;<span class="number">80</span> <span class="keyword">and</span> score&lt;=<span class="number">100</span>) <span class="keyword">or</span> score=<span class="number">0</span></span></span><br></pre></td></tr></table></figure>
<h2 id="限定返回值">限定返回值</h2><p>通过 <code>limit</code> 语句来限定返回结果大小，比如限定返回 100 个：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">Comment</span> <span class="keyword">limit</span> <span class="number">100</span></span></span><br></pre></td></tr></table></figure>
<p>可以设定从第 m+1 个元素开始，例如从第 101 个元素（包含）开始往后取 10 个：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">Comment</span> <span class="keyword">limit</span> <span class="number">100</span>,<span class="number">10</span></span></span><br></pre></td></tr></table></figure>
<p>这个形式跟 MySQL 是类似的。</p>
<h3 id="占位符">占位符</h3><p>查询条件和 limit 子句还支持占位符，也就是可以用问号 <code>?</code> 替代值，值的列表通过 SDK 提供的方法传入，具体请参考各 SDK 用法，例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span>=? <span class="keyword">and</span> score&gt;? <span class="keyword">limit</span> ?,?</span></span><br></pre></td></tr></table></figure>
<p>占位符支持所有 LeanCloud 平台上的有效类型，复杂类型（如日期、GeoPoint）要求以 <a href="./rest_api.html#数据类型">REST API</a> 文档说明的 JSON 格式来提供。</p>
<p><strong>我们推荐使用占位符的方式来使用 CQL，查询语句可以通过预编译被缓存起来，降低 CQL 的转换开销。</strong></p>
<h2 id="排序">排序</h2><p>通过 <code>order</code> 语句来排序，<code>order</code> 语句只能出现在最后，不能在 <code>where</code> 和 <code>limit</code> 之前。</p>
<p>例如按照分数倒序排（分数高的前）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span></span></span><br></pre></td></tr></table></figure>
<p>也可以写成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">order</span> <span class="keyword">by</span> -score</span></span><br></pre></td></tr></table></figure>
<p>加号表示升序，减号表示降序。</p>
<p>多个字段组合排序，例如分数高的前，名字相同的「更小」的在前（字母顺序）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">order</span> <span class="keyword">by</span> -score,<span class="keyword">name</span></span></span><br></pre></td></tr></table></figure>
<p>同样的语句可以写成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">order</span> <span class="keyword">by</span> score,+<span class="keyword">name</span> <span class="keyword">desc</span></span><br><span class="line">或者</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">order</span> <span class="keyword">by</span> -score,<span class="keyword">name</span> <span class="keyword">asc</span></span></span><br></pre></td></tr></table></figure>
<p>没有写上明确的加号或者减号的字段，将根据最后的 <code>desc</code> 或者 <code>asc</code> 来决定采用升序还是降序。</p>
<h2 id="内置函数">内置函数</h2><p>CQL 提供了一些内置函数来方便地创建 pointer、geopoint 等类型：</p>
<table><br>  <tr><th>Name</th><th>Operation</th></tr><br>  <tr><td>date(‘YYYY-MM-DDTHH:MM:SS.MMMMZ’)</td><td>创建日期类型</td></tr><br>  <tr><td>pointer(className, objectId)</td><td>创建 Pointer</td></tr><br>  <tr><td>geopoint(经度, 纬度)</td><td>创建 GeoPoint</td></tr><br>  <tr><td>file(objectId)</td><td>创建 file 类型</td></tr><br>  <tr><td>base64(base64编码字符串)</td><td>创建 Bytes 类型</td></tr><br>  <tr><td>current_timestamp()</td><td>创建当前日期</td></tr><br></table>

<p>如果不使用这些函数，你也使用 <a href="./rest_api.html#数据类型">REST API 文档</a> 定义的 JSON 对象来创建特定类型，例如 Pointer：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">Comment</span> <span class="keyword">where</span> post=</span><br><span class="line">  &#123;className:<span class="string">'Post'</span>, objectId:<span class="string">'51e3a334e4b0b3eb44adbe1a'</span>,__type:<span class="string">'Pointer'</span>&#125;</span></span><br></pre></td></tr></table></figure>
<p>当然这样写就相对繁琐了。</p>
<h2 id="性能和建议">性能和建议</h2><p>CQL 最终还是转换成 <a href="./rest_api.html">REST API</a> 里查询部分提到的各种 where 条件，因为多了一层转换，理论上会比直接使用 <code>where</code> 查询慢一点。并且 CQL 对长度有所限制，要求在 4096 字节以内。</p>
<p>此外，我们推荐查询语句都采用占位符的方式，使用占位符的查询语句将有机会被缓存复用，避免重复解释的开销。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/">&laquo;</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/4/">&raquo;</a>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="https://avatars2.githubusercontent.com/u/14305708?v=3&s=460" alt="terry" itemprop="image"/>
          <p class="site-author-name" itemprop="name">terry</p>
        </div>
        <p class="site-description motion-element" itemprop="description">terry yang's blog | java | scala | bi</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">142</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">11</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-next-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yangwei8888" target="_blank">github</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/microsoftgoogles" target="_blank">weibo</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/run-zhi-38" target="_blank">zhihu</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">terry</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  

    <script type="text/javascript">
      var disqus_shortname = 'yangwei888';
      var disqus_identifier = 'page/3/index.html';
      var disqus_title = '';
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
