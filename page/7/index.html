<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="yosita" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="terry yang&apos;s blog | java | scala | bi">
<meta property="og:type" content="website">
<meta property="og:title" content="yosita">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="yosita">
<meta property="og:description" content="terry yang&apos;s blog | java | scala | bi">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="yosita">
<meta name="twitter:description" content="terry yang&apos;s blog | java | scala | bi">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> yosita </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?953e46480b0a75d01aaf6d872cc77099";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">yosita</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">yosita</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">

    

    
    
      
      

      
    

    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/12/25/swift-cn/chapter3/10_Statements/" itemprop="url">
                  第三章-10语句（Statements）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-12-25T11:00:11+08:00" content="2015-12-25">
              2015-12-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/swift-cn/" itemprop="url" rel="index">
                    <span itemprop="name">swift-cn</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/12/25/swift-cn/chapter3/10_Statements/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter3/10_Statements/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a name="statement_statements"></a></p>
<h1 id="u8BED_u53E5_uFF08Statements_uFF09"><a href="#u8BED_u53E5_uFF08Statements_uFF09" class="headerlink" title="语句（Statements）"></a>语句（Statements）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/coverxit" target="_blank" rel="external">coverxit</a><br>校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>, <a href="https://github.com/coverxit" target="_blank" rel="external">coverxit</a>, <a href="https://github.com/stanzhai" target="_blank" rel="external">stanzhai</a>,</p>
<p>2.0<br>翻译+校对：<a href="https://github.com/littledogboy" target="_blank" rel="external">littledogboy</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="/#loop_statements">循环语句</a></li>
<li><a href="/#branch_statements">分支语句</a></li>
<li><a href="/#labeled_statement">带标签的语句</a></li>
<li><a href="/#control_transfer_statements">控制传递语句</a></li>
</ul>
<p>在 Swift 中，有三种类型的语句：简单语句、编译控制语句和控制流语句。简单语句是最常见的，用于构造表达式或者声明。编译控制语句允许程序改变编译器的行为以及包含构建配置和源代码控制语句。</p>
<p>控制流语句则用于控制程序执行的流程，Swift 中有几种类型的控制流语句：循环语句、分支语句和控制传递语句。循环语句用于重复执行代码块；分支语句用于执行满足特定条件的代码块；控制传递语句则用于修改代码的执行顺序。另外，Swift 提供了 <code>do</code> 语句来引入范围以及捕获和处理错误，还提供了 <code>defer</code> 语句在退出当前范围之前执行清理操作。</p>
<p>是否将分号（<code>;</code>）添加到语句的结尾处是可选的。但若要在同一行内写多条独立语句，请务必使用分号。</p>
<blockquote>
<p>语句语法<br><em>语句</em> → <a href="/../chapter3/04_Expressions.html#expression"><em>表达式</em></a> <strong>;</strong> <em>可选</em><br><em>语句</em> → <a href="/../chapter3/05_Declarations.html#declaration"><em>声明</em></a> <strong>;</strong> <em>可选</em><br><em>语句</em> → <a href="/../chapter3/10_Statements.html#loop_statement"><em>循环语句</em></a> <strong>;</strong> <em>可选</em><br><em>语句</em> → <a href="/../chapter3/10_Statements.html#branch_statement"><em>分支语句</em></a> <strong>;</strong> <em>可选</em><br><em>语句</em> → <a href="/../chapter3/10_Statements.html#labeled_statement"><em>标记语句(Labeled Statement)</em></a><br><em>语句</em> → <a href="/../chapter3/10_Statements.html#control_transfer_statement"><em>控制转移语句</em></a> <strong>;</strong> <em>可选</em><br><em>语句</em> → <a href="/../chapter3/10_Statements.html#control_transfer_statement"><em>XXX语句</em></a> <strong>;</strong> <em>可选</em><br><em>多条语句(Statements)</em> → <a href="/../chapter3/10_Statements.html#statement"><em>语句</em></a> <a href="/../chapter3/10_Statements.html#statements"><em>多条语句(Statements)</em></a> <em>可选</em>  </p>
</blockquote>
<p><a name="loop_statements"></a></p>
<h2 id="u5FAA_u73AF_u8BED_u53E5"><a href="#u5FAA_u73AF_u8BED_u53E5" class="headerlink" title="循环语句"></a>循环语句</h2><p>取决于特定的循环条件，循环语句允许重复执行代码块。Swift 提供四种类型的循环语句：<code>for</code>语句、<code>for-in</code>语句、<code>while</code>语句和<code>do-while</code>语句。</p>
<p>通过<code>break</code>语句和<code>continue</code>语句可以改变循环语句的控制流。有关这两条语句，详情参见 <a href="/#break_statement">Break 语句</a>和 <a href="/#continue_statement">Continue 语句</a>。</p>
<blockquote>
<p>循环语句语法<br><em>循环语句</em> → <a href="/../chapter3/10_Statements.html#for_statement"><em>for语句</em></a><br><em>循环语句</em> → <a href="/../chapter3/10_Statements.html#for_in_statement"><em>for-in语句</em></a><br><em>循环语句</em> → <a href="/../chapter3/10_Statements.html#wheetatype类型ile_statement"><em>while语句</em></a><br><em>循环语句</em> → <a href="/../chapter3/10_Statements.html#do_while_statement"><em>do-while语句</em></a>  </p>
</blockquote>
<p><a name="for_statements"></a></p>
<h3 id="For__u8BED_u53E5"><a href="#For__u8BED_u53E5" class="headerlink" title="For 语句"></a>For 语句</h3><p><code>for</code>语句只有在循环条件为真时重复执行代码块，此时计数器递增。</p>
<p><code>for</code>语句的形式如下：</p>
<blockquote>
<p>for <code>initialzation</code>; <code>condition</code>; <code>increment</code> {<br>    <code>statements</code><br>}  </p>
</blockquote>
<p><em>initialzation</em>、<em>condition</em> 和 <em>increment</em> 之间的分号，以及包围循环体 <em>statements</em> 的大括号都是不可省略的。</p>
<p><code>for</code>语句的执行流程如下：</p>
<ol>
<li><em>initialzation</em> <em>循环变量</em> 只会被执行一次，通常用于声明和初始化在接下来的循环中需要使用的变量。</li>
<li>判断 <em>condition</em> 循环条件：<br> 如果为<code>true</code>，<em>statements</em> <em>循环体</em> 将会被执行，然后转到第3步。如果为<code>false</code>，<em>statements</em> 和 <em>increment</em> <em>循环增量</em> 都不会被执行，<code>for</code>至此执行完毕。</li>
<li>计算 <em>increment</em> 表达式，然后转到第2步。</li>
</ol>
<p>在 <em>initialzation</em> 中定义的变量仅在<code>for</code>循环的作用域内有效。<em>condition</em> 表达式的值的类型必须遵循<code>BooleanType</code>协议。</p>
<blockquote>
<p>For 循环语法<br><em>for语句</em> → <strong>for</strong> <a href="/../chapter3/10_Statements.html#for_init"><em>for初始条件</em></a> <em>可选</em> <strong>;</strong> <a href="/../chapter3/04_Expressions.html#expression"><em>表达式</em></a> <em>可选</em> <strong>;</strong> <a href="/../chapter3/04_Expressions.html#expression"><em>表达式</em></a> <em>可选</em> <a href="/../chapter3/05_Declarations.html#code_block"><em>代码块</em></a><br><em>for语句</em> → <strong>for</strong> <strong>(</strong> <a href="/../chapter3/10_Statements.html#for_init"><em>for初始条件</em></a> <em>可选</em> <strong>;</strong> <a href="/../chapter3/04_Expressions.html#expression"><em>表达式</em></a> <em>可选</em> <strong>;</strong> <a href="/../chapter3/04_Expressions.html#expression"><em>表达式</em></a> <em>可选</em> <strong>)</strong> <a href="/../chapter3/05_Declarations.html#code_block"><em>代码块</em></a><br><em>for初始条件</em> → <a href="/../chapter3/05_Declarations.html#variable_declaration"><em>变量声明</em></a> | <a href="/../chapter3/04_Expressions.html#expression_list"><em>表达式列表</em></a>  </p>
</blockquote>
<p><a name="for-in_statements"></a></p>
<h3 id="For-In__u8BED_u53E5"><a href="#For-In__u8BED_u53E5" class="headerlink" title="For-In 语句"></a>For-In 语句</h3><p><code>for-in</code>语句允许在重复执行代码块的同时，迭代集合（或遵循<code>Sequence</code>协议的任意类型）中的每一项。</p>
<p><code>for-in</code>语句的形式如下：</p>
<blockquote>
<p>for <code>item</code> in <code>collection</code> {<br>    <code>statements</code><br>}  </p>
</blockquote>
<p><code>for-in</code>语句在循环开始前会调用 <em>collection</em> 表达式的<code>generate</code>方法来获取一个生成器类型（这是一个遵循<code>Generator</code>协议的类型）的值。接下来循环开始，调用 <em>collection</em> 表达式的<code>next</code>方法。如果其返回值不是<code>None</code>，它将会被赋给 <em>item</em>，然后执行 <em>statements</em>，执行完毕后回到循环开始处；否则，将不会赋值给 <em>item</em> 也不会执行 <em>statements</em>，<code>for-in</code>至此执行完毕。</p>
<blockquote>
<p>For-In 循环语法<br><em>for-in语句</em> → <strong>for</strong> <a href="/../chapter3/07_Patterns.html#pattern"><em>模式</em></a> <strong>in</strong> <a href="/../chapter3/04_Expressions.html#expression"><em>表达式</em></a> <a href="/../chapter3/05_Declarations.html#code_block"><em>代码块</em></a>  </p>
</blockquote>
<p><a name="while_statements"></a></p>
<h3 id="While__u8BED_u53E5"><a href="#While__u8BED_u53E5" class="headerlink" title="While 语句"></a>While 语句</h3><p><code>while</code>语句当循环条件为真时，允许重复执行代码块。</p>
<p><code>while</code>语句的形式如下：</p>
<blockquote>
<p>while <code>condition</code> {<br>    <code>statements</code><br>}  </p>
</blockquote>
<p><code>while</code>语句的执行流程如下：</p>
<ol>
<li>计算 <em>condition</em> 表达式：<br> 如果为真<code>true</code>，转到第2步。如果为<code>false</code>，<code>while</code>至此执行完毕。</li>
<li>执行 <em>statements</em> ，然后转到第1步。</li>
</ol>
<p>由于 <em>condition</em> 的值在 <em>statements</em> 执行前就已计算出，因此<code>while</code>语句中的 <em>statements</em> 可能会被执行若干次，也可能不会被执行。</p>
<p><em>condition</em> 表达式的值的类型必须遵循<code>BooleanType</code>协议。同时，<em>condition</em> 表达式也可以使用可选绑定，详情参见<a href="/../chapter2/01_The_Basics.html#optional_binding">可选绑定</a>。</p>
<blockquote>
<p>While 循环语法<br><em>while语句</em> → <strong>while</strong> <a href="/../chapter3/10_Statements.html#while_condition"><em>while条件</em></a> <a href="/../chapter3/05_Declarations.html#code_block"><em>代码块</em></a><br><em>条件</em> → <a href="/../chapter3/04_Expressions.html#expression"><em>表达式</em></a> | <a href="/../chapter3/05_Declarations.html#declaration"><em>声明</em></a><br><em>条件</em> → <a href="/../chapter3/04_Expressions.html#expression"><em>表达式</em></a><br><em>条件</em> → <a href="/../chapter3/04_Expressions.html#expression"><em>表达式</em></a> | <a href="/TODO"><em>条件列表</em></a><br><em>条件</em> → <a href="/../chapter3/10_Statement.html#availability"><em>可用条件</em></a> <a href="/../chapter3/04_Expressions.html#expression"><em>表达式</em></a><br><em>条件列表</em> → <a href="/TODO"><em>条件条件</em></a>  <a href="/TODO"><em>条件列表</em></a><br><em>条件</em> → <a href="/../chapter3/10_Statement.html#availability"><em>可用条件</em></a> <a href="/../chapter2/01_The_Basics.html#optional_binding">可选绑定条件</a><br><em>case条件</em> → <strong>case</strong> <a href="/../chapter3/07_Patterns.html#pattern"><em>模式</em></a> <a href="/TODO">构造器</a> <a href="/DOTO">where</a><br><em>可选绑定条件</em> → <a href="/TODO">可选绑定头</a> <a href="/TODO">持续可选绑定</a> <a href="/TODO">持续可选绑定列表</a><br><em>可选绑定头</em> → <strong>let</strong> <a href="/../chapter3/07_Patterns.html#pattern"><em>模式</em></a>  <a href="/TODO">构造器</a>  <strong>var</strong>  <a href="/../chapter3/07_Patterns.html#pattern"><em>模式</em></a>  <a href="/TODO">构造器</a><br> <em>可持续绑定列表</em> →  <a href="/../chapter3/07_Patterns.html#pattern"><em>模式</em></a> |  <a href="/TODO">构造器</a> <a href="/TODO">可选绑定头</a></p>
</blockquote>
<p><a name="while-while_statements"></a></p>
<h3 id="Repeat-While__u8BED_u53E5"><a href="#Repeat-While__u8BED_u53E5" class="headerlink" title="Repeat-While 语句"></a>Repeat-While 语句</h3><p><code>repeat-while</code>语句允许代码块被执行一次或多次。</p>
<p><code>repeat-while</code>语句的形式如下：</p>
<blockquote>
<p>repeat {<br>    <code>statements</code><br>} while <code>condition</code>  </p>
</blockquote>
<p><code>repeat-while</code>语句的执行流程如下：</p>
<ol>
<li>执行 <em>statements</em>，然后转到第2步。</li>
<li>计算 <em>condition</em> 表达式：<br> 如果为<code>true</code>，转到第1步。如果为<code>false</code>，<code>repeat-while</code>至此执行完毕。</li>
</ol>
<p>由于 <em>condition</em> 表达式的值是在 <em>statements</em> 执行后才计算出，因此<code>repeat-while</code>语句中的 <em>statements</em> 至少会被执行一次。</p>
<p><em>condition</em> 表达式的值的类型必须遵循<code>BooleanType</code>协议。同时，<em>condition</em> 表达式也可以使用可选绑定，详情参见<a href="/../chapter2/01_The_Basics.html#optional_binding">可选绑定</a>。</p>
<blockquote>
<p>Repeat-While 循环语法  </p>
<ul>
<li>repeat-while语句<em> → <strong>repeat</strong> [</em>代码块<em>](../chapter3/05_Declarations.html#code_block) <strong>while</strong> [</em>while条件*](../chapter3/10_Statements.html#while_condition)  </li>
</ul>
</blockquote>
<p><a name="branch_statements"></a></p>
<h2 id="u5206_u652F_u8BED_u53E5"><a href="#u5206_u652F_u8BED_u53E5" class="headerlink" title="分支语句"></a>分支语句</h2><p>取决于一个或者多个条件的值，分支语句允许程序执行指定部分的代码。显然，分支语句中条件的值将会决定如何分支以及执行哪一块代码。Swift 提供两种类型的分支语句：<code>if</code>语句和<code>switch</code>语句。</p>
<p><code>switch</code>语句中的控制流可以用<code>break</code>语句修改，详情请见<a href="/#break_statement">Break 语句</a>。</p>
<blockquote>
<p>分支语句语法<br><em>分支语句</em> → <a href="/../chapter3/10_Statements.html#if_statement"><em>if语句</em></a><br><em>分支语句</em> → <a href="/../chapter3/10_Statements.html#switch_statement"><em>switch语句</em></a>  </p>
</blockquote>
<p><a name="if_statements"></a></p>
<h3 id="If__u8BED_u53E5"><a href="#If__u8BED_u53E5" class="headerlink" title="If 语句"></a>If 语句</h3><p>取决于一个或多个条件的值，<code>if</code>语句将决定执行哪一块代码。</p>
<p><code>if</code>语句有两种标准形式，在这两种形式里都必须有大括号。</p>
<p>第一种形式是当且仅当条件为真时执行代码，像下面这样：</p>
<blockquote>
<p>if <code>condition</code> {<br>    <code>statements</code><br>}  </p>
</blockquote>
<p>第二种形式是在第一种形式的基础上添加 <em>else 语句</em>，当只有一个 else 语句时，像下面这样：</p>
<blockquote>
<p>if <code>condition</code> {<br>    <code>statements to execute if condition is true</code><br>} else {<br>    <code>statements to execute if condition is false</code><br>}</p>
</blockquote>
<p>同时，else 语句也可包含<code>if</code>语句，从而形成一条链来测试更多的条件，像下面这样：</p>
<blockquote>
<p>if <code>condition 1</code> {<br>    <code>statements to execute if condition 1 is true</code><br>} else if <code>condition 2</code> {<br>    <code>statements to execute if condition 2 is true</code><br>}<br>else {<br>    <code>statements to execute if both conditions are false</code><br>}  </p>
</blockquote>
<p><code>if</code>语句中条件的值的类型必须遵循<code>LogicValue</code>协议。同时，条件也可以使用可选绑定，详情参见<a href="/../chapter2/01_The_Basics.html#optional_binding">可选绑定</a>。</p>
<blockquote>
<p>If语句语法<br><em>if语句</em> → <strong>if</strong> <a href="/../chapter3/10_Statements.html#if_condition"><em>if条件</em></a> <a href="/../chapter3/05_Declarations.html#code_block"><em>代码块</em></a> <a href="/../chapter3/10_Statements.html#else_clause"><em>else(Clause)</em></a> <em>可选</em><br><em>if条件</em> → <a href="/../chapter3/04_Expressions.html#expression"><em>表达式</em></a> | <a href="/../chapter3/05_Declarations.html#declaration"><em>声明</em></a><br><em>else(Clause)</em> → <strong>else</strong> <a href="/../chapter3/05_Declarations.html#code_block"><em>代码块</em></a> | <strong>else</strong> <a href="/../chapter3/10_Statements.html#if_statement"><em>if语句</em></a>     </p>
</blockquote>
<p><a name="guard_statements"></a></p>
<h3 id="Guard__u8BED_u53E5"><a href="#Guard__u8BED_u53E5" class="headerlink" title="Guard 语句"></a>Guard 语句</h3><p><code>guard</code> 语句用来转移程序控制出其作用域，如果一个或者多个条件不成立。<br> <code>guard</code> 语句的格式如下：    </p>
<blockquote>
<p>guard <code>condition</code> else {<br>   <code>statements</code><br>}    </p>
</blockquote>
<p> <code>guard</code>语句中条件值的类型必须遵循<code>LogicValue</code>协议。且条件可以使用可选绑定，详情参见<a href="/../chapter2/01_The_Basics.html#optional_binding">可选绑定</a>。</p>
<p> 在<code>guard</code>语句中声明的常量或者变量，可用范围从声明开始到作用域结束,常量和变量的值从可选绑定声明中分配。</p>
<p> <code>guard</code>语句需要有<code>else</code>子句，并且必须调用被<code>noreturn</code>属性标记的函数,或者使用下面的语句把程序执行转移到guard语句的作用域外。    </p>
<ul>
<li><code>return</code></li>
<li><code>break</code></li>
<li><code>continue</code></li>
<li><code>throw</code>    </li>
</ul>
<p>执行转移语句详情参见<a href="/TODO">控制传递语句</a></p>
<p><a name="switch_statements"></a></p>
<h3 id="Switch__u8BED_u53E5"><a href="#Switch__u8BED_u53E5" class="headerlink" title="Switch 语句"></a>Switch 语句</h3><p>取决于<code>switch</code>语句的<em>控制表达式（control expression）</em>，<code>switch</code>语句将决定执行哪一块代码。</p>
<p><code>switch</code>语句的形式如下：</p>
<blockquote>
<p>switch <code>control expression</code> {<br>    case <code>pattern 1</code>:<br>        <code>statements</code><br>    case <code>pattern 2</code> where <code>condition</code>:<br>        <code>statements</code><br>    case <code>pattern 3</code> where <code>condition</code>,<br>    <code>pattern 4</code> where <code>condition</code>:<br>        <code>statements</code><br>    default:<br>        <code>statements</code><br>}  </p>
</blockquote>
<p><code>switch</code>语句的<em>控制表达式（control expression）</em>会首先被计算，然后与每一个 case 的模式（pattern）进行匹配。如果匹配成功，程序将会执行对应的 case 分支里的 <em>statements</em>。另外，每一个 case 分支都不能为空，也就是说在每一个 case 分支中至少有一条语句。如果你不想在匹配到的 case 分支中执行代码，只需在该分支里写一条<code>break</code>语句即可。</p>
<p>可以用作控制表达式的值是十分灵活的，除了标量类型(scalar types，如<code>Int</code>、<code>Character</code>)外，你可以使用任何类型的值，包括浮点数、字符串、元组、自定义类的实例和可选（optional）类型，甚至是枚举类型中的成员值和指定的范围(range)等。关于在<code>switch</code>语句中使用这些类型，详情参见<a href="/../chapter2/05_Control_Flow.html">控制流</a>一章的 <a href="/../chapter2/05_Control_Flow.html#switch">Switch</a>。</p>
<p>你可以在模式后面添加一个起保护作用的表达式(guard expression)。<em>起保护作用的表达式</em>是这样构成的：关键字<code>where</code>后面跟着一个作为额外测试条件的表达式。因此，当且仅当<em>控制表达式</em>匹配一个<em>case</em>的某个模式且起保护作用的表达式为真时，对应 case 分支中的 <em>statements</em> 才会被执行。在下面的例子中，<em>控制表达式</em>只会匹配含两个相等元素的元组，如<code>(1, 1)</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">where</span> x == y:</span><br></pre></td></tr></table></figure>
<p>正如上面这个例子，也可以在模式中使用<code>let</code>（或<code>var</code>）语句来绑定常量（或变量）。这些常量（或变量）可以在其对应的起保护作用的表达式和其对应的<em>case</em>块里的代码中引用。但是，如果 case 中有多个模式匹配控制表达式，那么这些模式都不能绑定常量（或变量）。</p>
<p><code>switch</code>语句也可以包含默认（<code>default</code>）分支，只有其它 case 分支都无法匹配控制表达式时，默认分支中的代码才会被执行。一个<code>switch</code>语句只能有一个默认分支，而且必须在<code>switch</code>语句的最后面。</p>
<p>尽管模式匹配操作实际的执行顺序，特别是模式的计算顺序是不可知的，但是 Swift 规定<code>switch</code>语句中的模式匹配的顺序和书写源代码的顺序保持一致。因此，当多个模式含有相同的值且能够匹配控制表达式时，程序只会执行源代码中第一个匹配的 case 分支中的代码。</p>
<h4 id="Switch__u8BED_u53E5_u5FC5_u987B_u662F_u5B8C_u5907_u7684"><a href="#Switch__u8BED_u53E5_u5FC5_u987B_u662F_u5B8C_u5907_u7684" class="headerlink" title="Switch 语句必须是完备的"></a>Switch 语句必须是完备的</h4><p>在 Swift 中，<code>switch</code>语句中控制表达式的每一个可能的值都必须至少有一个 case 分支与之对应。在某些情况下（例如，表达式的类型是<code>Int</code>），你可以使用默认块满足该要求。</p>
<h4 id="u4E0D_u5B58_u5728_u9690_u5F0F_u7684_u8D2F_u7A7F_28fall_through_29"><a href="#u4E0D_u5B58_u5728_u9690_u5F0F_u7684_u8D2F_u7A7F_28fall_through_29" class="headerlink" title="不存在隐式的贯穿(fall through)"></a>不存在隐式的贯穿(fall through)</h4><p>当匹配的 case 分支中的代码执行完毕后，程序会终止<code>switch</code>语句，而不会继续执行下一个 case 分支。这就意味着，如果你想执行下一个 case 分支，需要显式地在你需要的 case 分支里使用<code>fallthrough</code>语句。关于<code>fallthrough</code>语句的更多信息，详情参见 <a href="/#fallthrough_statement">Fallthrough 语句</a>。</p>
<blockquote>
<p>Switch语句语法<br><em>switch语句</em> → <strong>switch</strong> <a href="/../chapter3/04_Expressions.html#expression"><em>表达式</em></a> <strong>{</strong> <a href="/../chapter3/10_Statements.html#switch_cases"><em>SwitchCase列表</em></a> <em>可选</em> <strong>}</strong><br><em>SwitchCase列表</em> → <a href="/../chapter3/10_Statements.html#switch_case"><em>SwitchCase</em></a> <a href="/../chapter3/10_Statements.html#switch_cases"><em>SwitchCase列表</em></a> <em>可选</em><br><em>SwitchCase</em> → <a href="/../chapter3/10_Statements.html#case_label"><em>case标签</em></a> <a href="/../chapter3/10_Statements.html#statements"><em>多条语句(Statements)</em></a> | <a href="/../chapter3/10_Statements.html#default_label"><em>default标签</em></a> <a href="/../chapter3/10_Statements.html#statements"><em>多条语句(Statements)</em></a><br><em>SwitchCase</em> → <a href="/../chapter3/10_Statements.html#case_label"><em>case标签</em></a> <strong>;</strong> | <a href="/../chapter3/10_Statements.html#default_label"><em>default标签</em></a> <strong>;</strong><br><em>case标签</em> → <strong>case</strong> <a href="/../chapter3/10_Statements.html#case_item_list"><em>case项列表</em></a> <strong>:</strong><br><em>case项列表</em> → <a href="/../chapter3/07_Patterns.html#pattern"><em>模式</em></a> <a href="/../chapter3/10_Statements.html#guard_clause"><em>guard-clause</em></a> <em>可选</em> | <a href="/../chapter3/07_Patterns.html#pattern"><em>模式</em></a> <a href="/../chapter3/10_Statements.html#guard_clause"><em>guard-clause</em></a> <em>可选</em> <strong>,</strong> <a href="/../chapter3/10_Statements.html#case_item_list"><em>case项列表</em></a><br><em>default标签</em> → <strong>default</strong> <strong>:</strong><br><em>where-clause</em> → <strong>where</strong> <a href="/../chapter3/10_Statements.html#guard"><em>guard-expression</em></a><br><em>where-expression</em> → <a href="/../chapter3/04_Expressions.html#expression"><em>表达式</em></a>  </p>
</blockquote>
<p><a name="labeled_statements"></a><br><a name="control_transfer_statements"></a></p>
<h2 id="u5E26_u6807_u7B7E_u7684_u8BED_u53E5"><a href="#u5E26_u6807_u7B7E_u7684_u8BED_u53E5" class="headerlink" title="带标签的语句"></a>带标签的语句</h2><p>你可以在循环语句或<code>switch</code>语句前面加上<em>标签</em>，它由标签名和紧随其后的冒号(:)组成。在<code>break</code>和<code>continue</code>后面跟上标签名可以显式地在循环语句或<code>switch</code>语句中更改控制流，把控制权传递给指定标签标记的语句。关于这两条语句用法，详情参见 <a href="/#break_statement">Break 语句</a>和 <a href="/#continue_statement">Continue 语句</a>。</p>
<p>标签的作用域是该标签所标记的语句之后的所有语句。你可以不使用带标签的语句，但只要使用它，标签名就必唯一。</p>
<p>关于使用带标签的语句的例子，详情参见<a href="/../chapter2/05_Control_Flow.html">控制流</a>一章的<a href="/../chapter2/05_Control_Flow.html#labeled_statements">带标签的语句</a>。</p>
<blockquote>
<p>标记语句语法<br><em>标记语句(Labeled Statement)</em> → <a href="/../chapter3/10_Statements.html#statement_label"><em>语句标签</em></a> <a href="/../chapter3/10_Statements.html#loop_statement"><em>循环语句</em></a> | <a href="/../chapter3/10_Statements.html#statement_label"><em>语句标签</em></a> <a href="/../chapter3/10_Statements.html#switch_statement"><em>switch语句</em></a><br><em>语句标签</em> → <a href="/../chapter3/10_Statements.html#label_name"><em>标签名称</em></a> <strong>:</strong><br><em>标签名称</em> → <a href="/../chapter3/02_Lexical_Structure.html#identifier"><em>标识符</em></a>  </p>
</blockquote>
<p><a name="control_transfer_statements"></a></p>
<h2 id="u63A7_u5236_u4F20_u9012_u8BED_u53E5"><a href="#u63A7_u5236_u4F20_u9012_u8BED_u53E5" class="headerlink" title="控制传递语句"></a>控制传递语句</h2><p>通过无条件地把控制权从一片代码传递到另一片代码，控制传递语句能够改变代码执行的顺序。Swift 提供四种类型的控制传递语句：<code>break</code>语句、<code>continue</code>语句、<code>fallthrough</code>语句和<code>return</code>语句。</p>
<blockquote>
<p>控制传递语句(Control Transfer Statement) 语法<br><em>控制传递语句</em> → <a href="/../chapter3/10_Statements.html#break_statement"><em>break语句</em></a><br><em>控制传递语句</em> → <a href="/../chapter3/10_Statements.html#continue_statement"><em>continue语句</em></a><br><em>控制传递语句</em> → <a href="/../chapter3/10_Statements.html#fallthrough_statement"><em>fallthrough语句</em></a><br><em>控制传递语句</em> → <a href="/../chapter3/10_Statements.html#return_statement"><em>return语句</em></a><br><em>控制传递语句</em> → <a href="/../chapter3/10_Statements.html#throw_statement"><em>throw语句</em></a>  </p>
</blockquote>
<p><a name="break_statements"></a></p>
<h3 id="Break__u8BED_u53E5"><a href="#Break__u8BED_u53E5" class="headerlink" title="Break 语句"></a>Break 语句</h3><p><code>break</code>语句用于终止循环或<code>switch</code>语句的执行。使用<code>break</code>语句时，可以只写<code>break</code>这个关键词，也可以在<code>break</code>后面跟上标签名（label name），像下面这样：</p>
<blockquote>
<p>break<br>break <code>label name</code></p>
</blockquote>
<p>当<code>break</code>语句后面带标签名时，可用于终止由这个标签标记的循环或<code>switch</code>语句的执行。</p>
<p>而当只写<code>break</code>时，则会终止<code>switch</code>语句或上下文中包含<code>break</code>语句的最内层循环的执行。</p>
<p>在这两种情况下，控制权都会被传递给循环或<code>switch</code>语句外面的第一行语句。</p>
<p>关于使用<code>break</code>语句的例子，详情参见<a href="/../chapter2/05_Control_Flow.html">控制流</a>一章的 <a href="/../chapter2/05_Control_Flow.html#break">Break</a> 和<a href="/../chapter2/05_Control_Flow.html#labeled_statements">带标签的语句</a>。</p>
<blockquote>
<p>Break 语句语法<br><em>break语句</em> → <strong>break</strong> <a href="/../chapter3/10_Statements.html#label_name"><em>标签名称</em></a> <em>可选</em>  </p>
</blockquote>
<p><a name="continue_statements"></a></p>
<h3 id="Continue__u8BED_u53E5"><a href="#Continue__u8BED_u53E5" class="headerlink" title="Continue 语句"></a>Continue 语句</h3><p><code>continue</code>语句用于终止循环中当前迭代的执行，但不会终止该循环的执行。使用<code>continue</code>语句时，可以只写<code>continue</code>这个关键词，也可以在<code>continue</code>后面跟上标签名（label name），像下面这样：</p>
<blockquote>
<p>continue<br>continue <code>label name</code>  </p>
</blockquote>
<p>当<code>continue</code>语句后面带标签名时，可用于终止由这个标签标记的循环中当前迭代的执行。</p>
<p>而当只写<code>break</code>时，可用于终止上下文中包含<code>continue</code>语句的最内层循环中当前迭代的执行。</p>
<p>在这两种情况下，控制权都会被传递给循环外面的第一行语句。</p>
<p>在<code>for</code>语句中，<code>continue</code>语句执行后，<em>increment</em> 表达式还是会被计算，这是因为每次循环体执行完毕后 <em>increment</em> 表达式都会被计算。</p>
<p>关于使用<code>continue</code>语句的例子，详情参见<a href="/../chapter2/05_Control_Flow.html">控制流</a>一章的 <a href="/../chapter2/05_Control_Flow.html#continue">Continue</a> 和<a href="/../chapter2/05_Control_Flow.html#labeled_statements">带标签的语句</a>。</p>
<blockquote>
<p>Continue 语句语法<br><em>continue语句</em> → <strong>continue</strong> <a href="/../chapter3/10_Statements.html#label_name"><em>标签名称</em></a> <em>可选</em>  </p>
</blockquote>
<p><a name="fallthrough_statements"></a></p>
<h3 id="Fallthrough__u8BED_u53E5"><a href="#Fallthrough__u8BED_u53E5" class="headerlink" title="Fallthrough 语句"></a>Fallthrough 语句</h3><p><code>fallthrough</code>语句用于在<code>switch</code>语句中传递控制权。<code>fallthrough</code>语句会把控制权从<code>switch</code>语句中的一个 case 传递给下一个 case 。这种传递是无条件的，即使下一个 case 的模式与<code>switch</code>语句的控制表达式的值不匹配。</p>
<p><code>fallthrough</code>语句可出现在<code>switch</code>语句中的任意 case 里，但不能出现在最后一个 case 分支中。同时，<code>fallthrough</code>语句也不能把控制权传递给使用了可选绑定的 case 分支。</p>
<p>关于在<code>switch</code>语句中使用<code>fallthrough</code>语句的例子，详情参见<a href="/../chapter2/05_Control_Flow.html">控制流</a>一章的<a href="/../chapter2/05_Control_Flow.html#control_transfer_statements">控制传递语句</a>。</p>
<blockquote>
<p>Fallthrough 语句语法<br><em>fallthrough语句</em> → <strong>fallthrough</strong>  </p>
</blockquote>
<p><a name="return_statements"></a></p>
<h3 id="Return__u8BED_u53E5"><a href="#Return__u8BED_u53E5" class="headerlink" title="Return 语句"></a>Return 语句</h3><p><code>return</code>语句用于在函数或方法的实现中将控制权传递给调用者，接着程序将会从调用者的位置继续向下执行。</p>
<p>使用<code>return</code>语句时，可以只写<code>return</code>这个关键词，也可以在<code>return</code>后面跟上表达式，像下面这样：</p>
<blockquote>
<p>return<br>return <code>expression</code>  </p>
</blockquote>
<p>当<code>return</code>语句后面带表达式时，表达式的值将会返回给调用者。如果表达式值的类型与调用者期望的类型不匹配，Swift 则会在返回表达式的值之前将表达式值的类型转换为调用者期望的类型。</p>
<p>而当只写<code>return</code>时，仅仅是将控制权从该函数或方法传递给调用者，而不返回一个值。（这就是说，该函数或方法的返回类型为<code>Void</code>或<code>()</code>）</p>
<blockquote>
<p>Return 语句语法<br><em>return语句</em> → <strong>return</strong> <a href="/../chapter3/04_Expressions.html#expression"><em>表达式</em></a> <em>可选</em>     </p>
</blockquote>
<p><a name="availability_statements"></a></p>
<h3 id="Availability__u8BED_u53E5"><a href="#Availability__u8BED_u53E5" class="headerlink" title="Availability 语句"></a>Availability 语句</h3><p>可用性条件，被当做<code>if</code> ，<code>while</code> 语句的条件，并且 <code>guard</code> 语句在运行时会基于特定的语法格式查询接口的可用性。    </p>
<p>avaliability 语句的形式如下：</p>
<blockquote>
<p>if #available(<code>platform name version</code>,<code>...</code>, *) {<br>  <code>statements to execute if the APIs are available</code><br>} else {<br> <code>fallback statements to execute if the APIs are unavailable</code><br>}    </p>
</blockquote>
<p>可用性条件执行一个代码块时，取决于在运行时想要使用的接口是否可用。<br>当编译器检查到代码块中的接口是可用的，则从可用性条件中获取相应信息。    </p>
<p>可用性条件使用逗号分隔平台名称和版本列表。使用<code>iOS</code>，<code>OSX</code>，以及<code>watchOS</code>为平台名称，包括相应的版本号。*参数是必需的。在任何平台上代码块主体都被可用性条件保护起来，由满足最低部署条件的目标设备运行。        </p>
<p>与布尔类型条件不同，不能用逻辑运算符 <strong>&amp;&amp;</strong> 和 <strong>||</strong> 合并可用性条件。 </p>
<blockquote>
<p>可用性条件语法<br><em>可用性条件</em> → <strong>#available</strong> ( <a href="/TODO">availability-arguments­</a> )<br><em>可用性条件</em> → <a href="/TODO">availability-argument­</a> |  <a href="/TODO">availability-argument</a>­ ,­ <a href="/TODO">availability-arguments­</a><br><em>可用性条件</em> → <a href="/TODO">平台名称</a>  <a href="/TODO">版本号</a><br><em>可用性条件</em> →   <strong>*</strong><br><em>平台名称</em> →  <strong>iOS</strong> |  <strong>iOSApplicationExtension</strong><br><em>平台名称</em> → <strong>OSX</strong>  |  <strong>OSXApplicationExtension­</strong><br><em>平台名称</em> → <strong>watchOS</strong><br><em>版本号</em> → <a href="/TODO">十进制数字</a><br><em>版本号</em> → <a href="/TODO">十进制数字</a>  <strong>.</strong> <a href="/TODO">十进制数字</a><br><em>版本号</em> → <a href="/TODO">十进制数字</a>  <strong>.</strong> <a href="/TODO">十进制数字</a> <strong>.</strong> <a href="/TODO">十进制数字</a></p>
</blockquote>
<p><a name="throw_statements"></a></p>
<h3 id="Throw__u8BED_u53E5"><a href="#Throw__u8BED_u53E5" class="headerlink" title="Throw 语句"></a>Throw 语句</h3><p><code>throw</code>语句出现在抛出函数或者抛出方法体内，或者类型被<code>throws</code>关键字标记的表达式体内。   </p>
<p><code>throw</code>语句使程序结束执行当前的作用域，并在封闭作用域中传播错误。抛出的错误会一直传播，直到被<code>do</code>语句的<code>catch</code>子句处理掉。    </p>
<p><code>throw</code>语句由<code>throw</code>关键字 跟一个表达式组成 ，如下所示。    </p>
<blockquote>
<p>throw <code>expression</code>    </p>
</blockquote>
<p>表达式值的类型必须遵循 <code>LogicValue</code>协议     </p>
<p>关于如何使用<code>throw</code>语句的例子，详情参见<a href="/TODO">错误处理</a>一章的<a href="/TODO">抛出错误</a>。    </p>
<blockquote>
<p>throw 语句语法<br><em>抛出语句</em> → <strong>throw</strong>  <em><a href="/TODO">表达式­</a></em>    </p>
</blockquote>
<p><a name="defer_statements"></a></p>
<h3 id="Defer__u8BED_u53E5"><a href="#Defer__u8BED_u53E5" class="headerlink" title="Defer 语句"></a>Defer 语句</h3><p> <code>defer</code> 语句用于转移程序控制出延迟语句作用域之前执行代码。    </p>
<p>在 <code>defer</code> 语句中的语句无论程序控制如何转移都会执行。这意味着 <code>defer</code> 语句可以被使用在以下这些情况，像手动得执行资源管理，关闭文件描述，或者即使抛出了错误也需要去实现执行一些动作。    </p>
<p>如果多个 <code>defer</code> 语句出现在同一范围内，那么它们执行的顺序与出现的顺序相反。给定作用域中的第一个<code>defer</code> 语句，会在最后执行，这意味着最后执行的延迟语句中的语句涉及的资源可以被其他 <code>defer</code>语句清理掉。    </p>
<blockquote>
<p>1  func f( ) {<br>2  defer { print(“First”) }<br>3  defer { print(“Second”) }<br>4  defer { print(“Third”) }<br>5  }<br>6  f()<br>7  // prints “Third”<br>8  // prints “Second”<br>9  // prints “First”    </p>
</blockquote>
<p><code>defer</code> 语句中的语句无法转移程序控制出延迟语句。    </p>
<blockquote>
<p>defer 语句语法<br><em>延迟语句</em>  → <strong>defer</strong> <em><a href="/TODO">代码块</a></em>    </p>
</blockquote>
<p><a name="do_statements"></a></p>
<h3 id="Do__u8BED_u53E5"><a href="#Do__u8BED_u53E5" class="headerlink" title="Do 语句"></a>Do 语句</h3><p><code>do</code> 语句用于引入一个新的作用域,该作用域中可以含有一个或多个<code>catch</code>子句,catch子句中定义了一些匹配错误情况的模式。<code>do</code> 语句作用域内定义的常量和变量，只能在do语句作用域内访问。    </p>
<p>swift 中的 do 语句与C 中限定代码块界限的大括号 （{}）很相似，并且在程序运行的时候并不会造成系统开销。    </p>
<blockquote>
<p>do {<br>   try <code>expression</code><br>   <code>statements</code><br>} catch <code>pattern 1</code> {<br>    <code>statements</code><br>} catch <code>pattern 2</code> where condition {<br>    <code>statements</code><br>}    </p>
</blockquote>
<p>如同<code>switch</code>语句,编译器会判断<code>catch</code>子句是否被遗漏。如果catch没有被遗漏，则认为错误被处理。否则，错误会自动传播出包含作用域,被一个封闭的<code>catch</code>语句或抛出函数处理掉，包含函数必须以<code>throws</code>关键字声明。    </p>
<p>为了确保错误已经被处理，使用一个匹配所有错误的<code>catch</code>子句，如通配符模式（_）。如果一个<code>catch</code>子句不指定一种模式，<code>catch</code>子句会匹配和约束任何局部变量命名的<code>error</code>。有关在<code>catch</code>子句中使用模式的更多信息，详见<a href="/TODO">模式</a>。    </p>
<p>关于在一些<code>catch</code>子句中如何使用<code>do</code>语句的例子，详情参见<a href="/TODO">错误处理</a>一章的<a href="/TODO">抛出错误</a>。       </p>
<blockquote>
<p>do 语句语法  → <strong>do</strong> <em>[</em>代码块<em>](../chapter3/05_Declarations.html#code_block) <a href="/TODO">catch</a></em><br>catch  → <em><a href="/TODO">catch子句</a> <a href="/TODO">catch子句</a></em><br>catch  → <strong>catch</strong> <em>[</em>模式<em>](../chapter3/07_Patterns.html#pattern)** </em>可选的<em> [</em>where<em>]() </em>可选的<em>  [</em>代码块*](../chapter3/05_Declarations.html#code_block)</p>
</blockquote>
<p><a name="compiler_control_statements"></a></p>
<h3 id="u7F16_u8BD1_u63A7_u5236_u8BED_u53E5"><a href="#u7F16_u8BD1_u63A7_u5236_u8BED_u53E5" class="headerlink" title="编译控制语句"></a>编译控制语句</h3><p>编译控制语句允许程序改变编译器的行为。Swift 有两种编译控制语句：构建配置语句和源代码控制语句。</p>
<blockquote>
<p>编译控制语句语法<br><em>编译控制语句</em>   → <a href="/../chapter3/04_Expressions.html#build_config_statements"><em>构建配置语句</em></a><br><em>编译控制语句</em>   → <a href="/../chapter3/04_Expressions.html#line_control_statements"><em>源代码控制语句</em></a></p>
</blockquote>
<p><a name="build_config_statements"></a></p>
<h4 id="u6784_u5EFA_u914D_u7F6E_u8BED_u53E5"><a href="#u6784_u5EFA_u914D_u7F6E_u8BED_u53E5" class="headerlink" title="构建配置语句"></a>构建配置语句</h4><p>构建配置语句可以根据一个或多个配置项来有条件的编译代码。</p>
<p>每一个构建配置语句都以 <code>#if</code> 开始， <code>#endif</code> 结束。如下是一个简单的构建配置语句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">if</span> build configuration</span></span><br><span class="line">statements</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>和 <code>if</code> 语句的条件不同，构建配置的条件是在编译时进行判断的。它的结果是：只有构建配置在编译时判断为 <code>true</code> 的情况下语句才会被编译和执行。</p>
<p><em>构建配置</em> 可以是 <code>true</code> 和 <code>false</code> 的常量，也可以是使用 <code>-D</code> 命令行标志的标识符，或者是下列表格中的任意一个平台测试方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>可用参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>os()</td>
<td>OSX, iOS, watchOS, tvOS</td>
</tr>
<tr>
<td>arch()</td>
<td>i386, x86_64, arm, arm64 ｜</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意<br><code>arch(arm)</code> 构建配置在 ARM 64位设备上不会返回 <code>true</code>。如果代码的构建目标是 32 位的 iOS 模拟器，<code>arch(i386)</code> 构建配置返回 <code>true</code>。</p>
</blockquote>
<p>你可以使用逻辑操作符 <code>&amp;&amp;</code>、<code>||</code> 和 <code>!</code> 来连接构建配置，还可以使用圆括号来进行分组。</p>
<p>就像 <code>if</code> 语句一样，你可以使用  <code>#elseif</code> 分句来添加任意多个条件分支来测试不同的构建配置。你也可以使用 <code>#else</code> 分句来添加最终的条件分支。包含多个分支的构建配置语句例子如下：</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">if</span> build configuration <span class="number">1</span></span></span><br><span class="line">statements <span class="keyword">to</span> <span class="built_in">compile</span> <span class="keyword">if</span> build configuration <span class="number">1</span> is <span class="literal">true</span></span><br><span class="line"><span class="preprocessor">#elseif build configuration <span class="number">2</span></span></span><br><span class="line">statements <span class="keyword">to</span> <span class="built_in">compile</span> <span class="keyword">if</span> build configuration <span class="number">2</span> is <span class="literal">true</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">statements <span class="keyword">to</span> <span class="built_in">compile</span> <span class="keyword">if</span> both build configurations are <span class="literal">false</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>即使没有被编译，构建配置语句中的每一个分句仍然会被解析。</p>
</blockquote>
<hr>
<blockquote>
<p>构建配置语句语法<br>单个构建配置语句 → #if­ 多个构建配置语句（可选） 多个构建配置 <code>elseif</code> 分句（可选）­ 单个构建配置 <code>else</code> 分句（可选）­#endif­<br>多个构建配置 <code>elseif</code> 分句 → 单个构建配置 <code>elseif</code>­ 分句 多个构建配置 <code>elseif</code> 分句（可选）<br>单个构建配置 <code>elseif</code>­ 分句 → #elseif­ 多个构建配置语句（可选）<br>单个构建配置 <code>else</code> 分句 → #else­ 语句（可选）<br>构建配置 → 平台测试方法<br>构建配置 → 标识符<br>构建配置 → boolean 常量<br>构建配置 → (­构建配置­)­<br>构建配置 → !­ 构建配置­<br>构建配置 → 构建配置 &amp;&amp;­ 构建配置­<br>构建配置 → 构建配置 ­||­ 构建配置­<br>平台测试方法 → os­(­操作系统)­<br>平台测试方法 → arch­(­架构)­<br>操作系统 → OSX­  iOS­  watchOS­  tvOS­<br>架构 → i386­  x86_64­  arm­  arm64­</p>
</blockquote>
<p><a name="line_control_statements"></a></p>
<h4 id="u6E90_u4EE3_u7801_u63A7_u5236_u8BED_u53E5"><a href="#u6E90_u4EE3_u7801_u63A7_u5236_u8BED_u53E5" class="headerlink" title="源代码控制语句"></a>源代码控制语句</h4><p>源代码控制语句用来给被编译源代码指定一个与原始行号和文件名不同的行号和文件名。使用源代码控制语句可以改变 Swift 使用源代码的位置，以便进行分析和测试。</p>
<p>源代码的控制语句的例子如下：</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#line line number filename</span></span><br></pre></td></tr></table></figure>
<p>源代码控制语句改变了常量表达式 <code>__LINE__</code> 和 <code>__FILE__</code> 的值，以一行源代码开头，然后跟着源代码控制语句。<code>line number</code> 改变了 <code>__LINE__</code> 的值，它是一个大于 0 的常量。<code>filename</code> 改变了 <code>__FILE__</code> 的值，它是一个字符串常量。</p>
<p>你可以通过写一句不指定 <code>line number</code> 和 <code>filename</code> 的源代码控制语句来吧源代码的位置回退到初始的行号和文件。</p>
<p>源代码控制语句必须出现在源代码的那一行，而且不能是源代码文件的最后一行。</p>
<blockquote>
<p>源代码控制语句</p>
<p>源代码控制语句 → #line­<br>源代码控制语句 → #line­ line-number­ file-name­<br>line-number → 大于 0 的十进制数<br>file-name → 字符串常量</p>
</blockquote>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/12/25/swift-cn/chapter4/01_Access_Control/" itemprop="url">
                  第四章-01Access Control 权限控制的黑与白
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-12-25T10:00:10+08:00" content="2015-12-25">
              2015-12-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/swift-cn/" itemprop="url" rel="index">
                    <span itemprop="name">swift-cn</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/12/25/swift-cn/chapter4/01_Access_Control/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter4/01_Access_Control/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Access_Control__u6743_u9650_u63A7_u5236_u7684_u9ED1_u4E0E_u767D"><a href="#Access_Control__u6743_u9650_u63A7_u5236_u7684_u9ED1_u4E0E_u767D" class="headerlink" title="Access Control 权限控制的黑与白"></a>Access Control 权限控制的黑与白</h1><blockquote>
<p>翻译：<a href="http://weibo.com/littlekok/" target="_blank" rel="external">老码团队翻译组-Arya</a><br>校对：<a href="http://weibo.com/u/5241713117" target="_blank" rel="external">老码团队翻译组-Oberyn</a></p>
</blockquote>
<p>如果您之前没有接触过权限控制，先来听一个小故事：</p>
<blockquote>
<p> 小明是五道口工业学院的一个大一新生，最近他有点烦恼，因为同屋经常用他的热水壶，好像那是自己家的一样，可是碍于同学情面，又不好意思说。直到有一天，他和学姐小K吐槽。</p>
<p> 学姐听了之后，说：大学集体生活里面，大部分东西都是默认室友可以共用的。如果你不想别人拿，我可以帮你做封印，只要打上private标记，它们就看不到你的东西，更加用不了你的东西了。</p>
<p> 小明说哇靠学姐你还会妖法……</p>
</blockquote>
<p>Swift语言从Xcode 6 beta 5版本起，加入了对权限控制（Access Control）的支持。其实权限控制和小明的物品一样，你可以设定水壶是只有自己能用，还是只有宿舍里的人能用，还是全校都可以用。</p>
<p>从此以后，你可以好像神盾局局长一样，完全掌控自己的代码块的”保密级别“，哪些是只能在本文件引用，哪些能用在整个项目里，你还可以发挥大爱精神，把它开源成只要导入你的框架，大家都可以使用的API。</p>
<p>这三种权限分别是：</p>
<ul>
<li><p>#####private 私有的</p>
<p>  在哪里写的，就在哪里用。无论是类、变量、常量还是函数，一旦被标记为私有的，就只能在定义他们的源文件里使用，不能为别的文件所用。</p>
</li>
<li><p>#####internal 内部的</p>
<p>  标记为internal的代码块，在整个应用（App bundle）或者框架（framework）的范围内都是可以访问的。</p>
</li>
<li><p>#####public 公开的</p>
<p>  标记为public的代码块一般用来建立API，这是最开放的权限，使得任何人只要导入这个模块，都可以访问使用。</p>
</li>
</ul>
<p>如果要把所有的爱加上一个期限，噢不，是给所有的代码块都标记上权限，不累死才怪。还好swift里面所有代码实体的默认权限，都是最常用的internal。所以当你开发自己的App时，可能完全不用管权限控制的事情。</p>
<p>但当你需要写一个公开API的时候，就必须对里面的代码块进行“隐身对其可见”的public标记，要么其他人是用不到的。</p>
<p>Private（私有级别）的权限最严格，它可以用来隐藏某些功能的细节实现方式。合理构筑你的代码，你就可以安全地使用extension和高级功能，又不把它们暴露给项目内的其他文件。</p>
<p>除了可以给整个声明设权限，Swift还允许大家在需要的时候，把某个属性（property）的取值权限比赋值权限设得更加开放。</p>
<p>#####举个例子：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListItem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ListItem这个类，有两个公开的属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> isComplete: <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的代码表示把变量UUID的赋值权限设为private，对整个app可读，但值只能在本文件里写入</span></span><br><span class="line"><span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> <span class="type">UUID</span>: <span class="type">NSUUID</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>(text: <span class="type">String</span>, completed: <span class="type">Bool</span>, <span class="type">UUID</span>: <span class="type">NSUUID</span>) &#123;</span><br><span class="line">	<span class="keyword">self</span>.text = text</span><br><span class="line">	<span class="keyword">self</span>.isComplete = completed</span><br><span class="line">	<span class="keyword">self</span>.<span class="type">UUID</span> = <span class="type">UUID</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这段没有特别标记权限，因此属于默认的internal级别。在框架目标内可用，但对于其他目标不可用</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">refreshIdentity</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">self</span>.<span class="type">UUID</span> = <span class="type">NSUUID</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">isEqual</span><span class="params">(object: AnyObject?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> item = object <span class="keyword">as</span>? <span class="type">ListItem</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">self</span>.<span class="type">UUID</span> == item.<span class="type">UUID</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们使用Objective-C和Swift混合开发时，需要注意：</p>
<ul>
<li><p>如果你在写的是一个应用，Xcode会生成一个头文件来保证两者的可互访性，而这个生成的头文件会包含public和internal级别的声明。</p>
</li>
<li><p>如果你的最终产品是一个Swift框架，头文件里只会出现标记为public级别的声明。（因为框架的头文件，属于公开的Objective-C接口的一部分，只有public部分对Objective-C可用。）</p>
</li>
</ul>
<p>虽然Swift不推荐大家传播和使用第三方的框架，但对于建立和分享源文件形式的框架是支持的。对于需要写框架，方便应用与多个项目的开发者来说，要记得把API标记为public级别。</p>
<p>如果您想了解更多关于权限控制的内容，可以查看苹果官方最新的《The Swift Language》和《Using Swift with Cocoa and Objective-C》指南，<br>这两本指南在iBooks里面可以下载更新喔。</p>
<p>本文由翻译自Apple Swift Blog ：<a href="https://developer.apple.com/swift/blog/?id=5" target="_blank" rel="external">https://developer.apple.com/swift/blog/?id=5</a></p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/12/25/swift-cn/chapter4/02_Type_Custom/" itemprop="url">
                  第四章-02造个类型不是梦-白话Swift类型创建
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-12-25T10:00:09+08:00" content="2015-12-25">
              2015-12-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/swift-cn/" itemprop="url" rel="index">
                    <span itemprop="name">swift-cn</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/12/25/swift-cn/chapter4/02_Type_Custom/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter4/02_Type_Custom/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="u9020_u4E2A_u7C7B_u578B_u4E0D_u662F_u68A6-_u767D_u8BDDSwift_u7C7B_u578B_u521B_u5EFA"><a href="#u9020_u4E2A_u7C7B_u578B_u4E0D_u662F_u68A6-_u767D_u8BDDSwift_u7C7B_u578B_u521B_u5EFA" class="headerlink" title="造个类型不是梦-白话Swift类型创建"></a>造个类型不是梦-白话Swift类型创建</h1><hr>
<blockquote>
<p>翻译：<a href="http://weibo.com/u/5241713117" target="_blank" rel="external">老码团队翻译组-Tyrion</a><br>校对：<a href="http://weibo.com/u/5241713117" target="_blank" rel="external">老码团队翻译组-Oberyn</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="/#prototype">自定义原型</a></li>
<li><a href="/#imp-default">实现默认值</a></li>
<li><a href="/#init-by-bool">支持基本布尔型初始化</a></li>
<li><a href="/#condition-by-bool">支持Bool类型判断</a></li>
<li><a href="/#support-all-type">支持兼容各们各派的类型</a></li>
<li><a href="/#make-up-type">完善OCBool的布尔基因体系</a></li>
</ul>
<p>小伙伴们，Swift中的Bool类型有着非常重要的语法功能，并支撑起了整个Swift体系中的逻辑判断体系，经过老码的研究和学习， Bool类型本身其实是对基础Boolean类型封装，小伙伴们可能咬着手指头问老码，怎么一会Bool类型，一会Boolean类型，其区别在于，前者是基于枚举的组合类型，而后者则是基本类型，只有两种true和false。</p>
<p><a name="prefix_expressions"></a></p>
<p>####自定义原型<br>接下老码根据Bool的思想来创建一个OCBool类型，来让小伙伴们了解一下Swift中到底是怎么玩儿的。<br>来我们先看一下OCBool的定义。</p>
<p>#####代码示例如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">OCBool</span></span>&#123;</span><br><span class="line"><span class="keyword">case</span> ocTrue</span><br><span class="line"><span class="keyword">case</span> ocFalse</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>#####注意：</p>
<ul>
<li>代码中第2行和第3行，可以合并到一行写，如苹果官方Blog所写的一样</li>
<li>代码中命名需要注意：OCBool是类型名，所以首字母必须大写，而case中的ocTrue和ocFalse是小类型则需要首字母小写。</li>
</ul>
<p><a name="imp-default"></a></p>
<p>####实现默认值<br>行，我们给了一个漂亮的定义，不过按照传统语言的经验，Bool值默认情况下是假， 所以我们的OCBool也应该如此，我们使用类型扩展技术增加这个默认特性：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">OCBool</span></span>&#123;</span><br><span class="line">     <span class="keyword">init</span>()&#123;</span><br><span class="line">             <span class="keyword">self</span> =.ocFalse</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>#####注意：</p>
<ul>
<li>代码中第1行：extension关键字，非常强大，小伙伴们可以通过此创造出许多好玩的东西，建议各位去Github上看一个名为“Swiftz”的项目，它将扩展用到了极致。</li>
<li>代码中第3行：self = .ocFalse语法，刚入门的小伙伴们很迷糊，为什么会有奇怪的点语法，因为大牛Chris在Swift中增加了类型智能推断功能，在苹果Blog中，提到了“Context”概念，就是这个意思，因为这行语句是在枚举OCBool中的，其上下文就是OCBool的定义体，编译器当然知道.ocFalse就是OCBool.ocFalse了，所以这里直接点语法，非常整齐。<br>现在我们可以使用如下方法使用这个Bool类型。</li>
</ul>
<p>#####代码示例如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result:<span class="type">OCBool</span> = <span class="type">OCBool</span>()</span><br><span class="line"><span class="keyword">var</span> result1:<span class="type">OCBool</span> = .ocTrue</span><br></pre></td></tr></table></figure></p>
<p><a name="init-by-bool"></a></p>
<p>####支持基本布尔型初始化<br>正如上述代码所述，我们只能通过类型或者枚举项目赋值，这是组合类型的用法，但是编码的日子里，我们总是希望和true，false直接打交道，也就是说，我们希望这么做，<br>代码示例如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isSuccess:<span class="type">OCBool</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>如果小伙伴们直接这么用，则会出现如下错误：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/Users/</span>tyrion-OldCoder<span class="regexp">/Documents/</span>Learning<span class="regexp">/BoolType/</span>BoolType/main.<span class="string">swift:</span><span class="number">30</span>:<span class="number">24</span>: Type <span class="string">'OCBool'</span> does not conform to protocol <span class="string">'BooleanLiteralConvertible'</span></span><br></pre></td></tr></table></figure></p>
<p>编译器咆哮的原因是，我们的类型没有遵从“布尔字面量转换协议”，接下来修正这个问题，</p>
<p>#####代码示例如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"Hello, World!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">OCBool</span></span>&#123;</span><br><span class="line">    <span class="keyword">case</span> ocTrue</span><br><span class="line">    <span class="keyword">case</span> ocFalse</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">OCBool</span>: <span class="title">BooleanLiteralConvertible</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">convertFromBooleanLiteral</span><span class="params">( value: Bool)</span></span> -&gt;<span class="type">OCBool</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value ? ocTrue : ocFalse</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isSuccess:<span class="type">OCBool</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>#####注意：</p>
<ul>
<li><p>代码中的第11行是重点，我的类型OCBool支持了BooleanLiteralConvertible协议，这个协到底是干什么的呢，小伙伴们在Xcode代码编辑器，按住Command键，然后点击第11行中的BooleanLiteralConvertible协议名，则会进入它的定义，<br>#####其定义如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">BooleanLiteralConvertible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">BooleanLiteralType</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">convertFromBooleanLiteral</span>(<span class="title">value</span>: <span class="title">BooleanLiteralType</span>) -&gt; <span class="title">Self</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>这个定义中有个类方法convertFromBooleanLiteral，它的参数为BooleanLiteralType类型，也就是我传入的Bool类型， 且返回值为实现这个协议的类型本身，在我们的OCBool类型中，其返回值就是OCBool本身。经过这个定义，我们可以直接对OCBool类型直接进行布尔字面量初始化了。</p>
</li>
</ul>
<p><a name="condition-by-bool"></a></p>
<p>####支持Bool类型判断<br>小伙伴们不安分， 肯定想着我怎么用它实现逻辑判断，所以如果你这么写，</p>
<p>#####代码示例如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isSuccess:<span class="type">OCBool</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> isSuccess &#123;</span><br><span class="line">    <span class="built_in">println</span>( <span class="string">"老码请你吃火锅！"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你永远吃不到老码的火锅，因为这里编译器会咆哮：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/Users/</span>tyrion-OldCoder<span class="regexp">/Documents/</span>Learning<span class="regexp">/BoolType/</span>BoolType/main.<span class="string">swift:</span><span class="number">27</span>:<span class="number">4</span>: Type <span class="string">'OCBool'</span> does not conform to protocol <span class="string">'LogicValue'</span></span><br></pre></td></tr></table></figure></p>
<p>OCBool现在只能用bool类型初始化，而不能直接返回bool型，小火把们还记得在《老码说编程之白话Swift江湖》中，老码多次提到，妈妈再也不担心我们 if a = 1{}的写法了， 因为等号不支持值返回了， 所以在if判断是后面的条件必须有返回值，OCBool没有，所以编译器哭了。我们解决这个问题。</p>
<p>#####代码示例如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"Hello, World!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">OCBool</span></span>&#123;</span><br><span class="line">    <span class="keyword">case</span> ocTrue</span><br><span class="line">    <span class="keyword">case</span> ocFalse</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">OCBool</span>: <span class="title">BooleanLiteralConvertible</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">convertFromBooleanLiteral</span><span class="params">( value: Bool)</span></span> -&gt;<span class="type">OCBool</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value ? ocTrue : ocFalse</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">OCBool</span>: <span class="title">LogicValue</span></span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">getLogicValue</span><span class="params">()</span></span> -&gt;<span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> boolValue: <span class="type">Bool</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span>&#123;</span><br><span class="line">        <span class="keyword">case</span> .ocTrue:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">case</span> .ocFalse:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> boolValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isSuccess:<span class="type">OCBool</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> isSuccess &#123;</span><br><span class="line">    <span class="built_in">println</span>( <span class="string">"老码请你吃火锅！"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>####运行结果如下：<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br><span class="line">老码请你吃火锅！</span><br><span class="line"><span class="keyword">Program</span> ended <span class="keyword">with</span> <span class="keyword">exit</span> code: <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>#####注意：</p>
<ul>
<li>如果小伙伴们现在用的是Beta版的Xcode，注意苹果官方Blog中，在代码第17行如果在Xcode Beta4下是错误的，这里的协议是，LogicValue而不是BooleanVue，所以记得看错误提示才是好习惯。</li>
<li>注意代码第34行，完美支持if判断，且输出结果为“老码请你吃火锅”，老码也是说说而已，请不要当真。</li>
</ul>
<p><a name="support-all-type"></a></p>
<p>####支持兼容各们各派的类型<br>小伙伴们，江湖风险，门派众多，老码有自己的OCBool类型，可能嵩山少林有自己的SSBool类型，甚至连郭美美都可能有自己的MMBool类型，所以OCBool必须能够识别这些类型，这些各门各派的类型，只要支持LogicValue协议，就应该可以被识别，看老码怎么做，</p>
<p>#####代码示例如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">OCBool</span></span>&#123;</span><br><span class="line">    <span class="keyword">init</span>( <span class="number">_</span> v: <span class="type">LogicValue</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> v.getLogicValue()&#123;</span><br><span class="line">            <span class="keyword">self</span> = .ocTrue</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">self</span> = .ocFalse</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mmResult: <span class="type">Bool</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> ocResult:<span class="type">OCBool</span> = <span class="type">OCBool</span>(mmResult)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ocResult &#123;</span><br><span class="line">    <span class="built_in">println</span>( <span class="string">"老码没钱，郭美美请你吃火锅！"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>#####代码运行结果如下：<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br><span class="line">老码没钱，郭美美请你吃火锅！</span><br><span class="line"><span class="keyword">Program</span> ended <span class="keyword">with</span> <span class="keyword">exit</span> code: <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>漂亮！我们的OCBool类型现在支持了所有的逻辑变量初始化。</p>
<p>#####注意：</p>
<ul>
<li>代码中第2行：“_”下横杠的用法，这是一个功能强大的小强，在此的目的是屏蔽外部参数名，所以小伙伴们可以直接：var ocResult:OCBool = OCBool(mmResult)而不是：var ocResult:OCBool = OCBool(v: mmResult)，小伙伴们惊呆了！这个init函数中本来就没有外部参数名啊，还记得老码在书里说过没，Swift的初始化函数会默认使用内部参数名，作为外部参数名。</li>
</ul>
<p><a name="make-up-type"></a></p>
<p>####完善OCBool的布尔基因体系：<br>小伙伴们，bool类型的价值就是在于各种判断，诸如==，!=, &amp;，|,^,!，以及各种组合逻辑运算，我们OCBool也要具备这些功能，否则就会基因缺陷，且看老码如何实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">OCBool</span>: <span class="title">Equatable</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//支持等值判断运算符</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> ==<span class="params">( <span class="keyword">left</span>: OCBool, <span class="keyword">right</span>: OCBool )</span></span>-&gt;<span class="type">Bool</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">left</span>, <span class="keyword">right</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> (.ocTrue, .ocTrue):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//支持位与运算符</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> &amp;<span class="params">( <span class="keyword">left</span>:OCBool, <span class="keyword">right</span>: OCBool)</span></span>-&gt;<span class="type">OCBool</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">left</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">right</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//支持位或运算符</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> |<span class="params">( <span class="keyword">left</span>:OCBool, <span class="keyword">right</span>: OCBool)</span></span>-&gt;<span class="type">OCBool</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">left</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">right</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//支持位异或运算符</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> ^<span class="params">( <span class="keyword">left</span>:OCBool, <span class="keyword">right</span>: OCBool)</span></span>-&gt;<span class="type">OCBool</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">OCBool</span>( <span class="keyword">left</span> != <span class="keyword">right</span> )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//支持求反运算符</span></span><br><span class="line"><span class="preprocessor">@prefix</span> <span class="func"><span class="keyword">func</span> !<span class="params">( a:OCBool )</span></span>-&gt; <span class="type">OCBool</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a ^ <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//支持组合求与运算符</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> &amp;= <span class="params">(<span class="keyword">inout</span> <span class="keyword">left</span>:OCBool, <span class="keyword">right</span>:OCBool )</span></span>&#123;</span><br><span class="line">    <span class="keyword">left</span> = <span class="keyword">left</span> &amp; <span class="keyword">right</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isHasMoney:<span class="type">OCBool</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> isHasWife:<span class="type">OCBool</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> isHasHealty:<span class="type">OCBool</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> isHasLover:<span class="type">OCBool</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">isHasMoney != isHasHealty</span><br><span class="line">isHasHealty == isHasMoney</span><br><span class="line">isHasWife ^ isHasLover</span><br><span class="line">isHasWife = !isHasLover</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isHasMoney | isHasHealty) &amp; isHasHealty&#123;</span><br><span class="line">    <span class="built_in">println</span>( <span class="string">"人生赢家，就像老码一样！"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"人生最苦的事事，人死了钱没花了，人生最苦的事是，人活着，钱没了！"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，到这里就到这里了，窗外的雷声叫醒了老码，现在应该去吃饭了，以上老码给大家展示了如果制造一个自己的类型，记得老码的示例是在Xcode6 Beta4下测试的，至于Beta5的改变还没有涉及，小伙伴们要好生练习，以后各种自定类型都是基于这个思想。还有这个章节不是老码的原创，老码认真的阅读了苹果的官方博客，且自己的练习总结，如果小伙伴们费了吃奶的劲还是看不懂，请找度娘谷歌，还是看不懂请到老码官方微博：<a href="http://weibo.com/u/5241713117咆哮。" target="_blank" rel="external">http://weibo.com/u/5241713117咆哮。</a></p>
<p>本文由翻译自Apple Swift Blog ：<a href="https://developer.apple.com/swift/blog/?id=8" target="_blank" rel="external">https://developer.apple.com/swift/blog/?id=8</a></p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/12/25/swift-cn/chapter4/03_Ballons/" itemprop="url">
                  第四章-03WWDC里面的那个“大炮打气球”
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-12-25T10:00:08+08:00" content="2015-12-25">
              2015-12-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/swift-cn/" itemprop="url" rel="index">
                    <span itemprop="name">swift-cn</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/12/25/swift-cn/chapter4/03_Ballons/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter4/03_Ballons/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="WWDC_u91CC_u9762_u7684_u90A3_u4E2A_u201C_u5927_u70AE_u6253_u6C14_u7403_u201D"><a href="#WWDC_u91CC_u9762_u7684_u90A3_u4E2A_u201C_u5927_u70AE_u6253_u6C14_u7403_u201D" class="headerlink" title="WWDC里面的那个“大炮打气球”"></a>WWDC里面的那个“大炮打气球”</h1><blockquote>
<p>翻译：<a href="http://weibo.com/littlekok/" target="_blank" rel="external">老码团队翻译组-Arya</a><br>校对：<a href="/Jame">老码团队翻译组-</a></p>
</blockquote>
<p><img src="https://devimages.apple.com.edgekey.net/swift/images/swift-screenshot.jpg" alt="Ballon playground"></p>
<p>很多小伙伴说，对WWDC上介绍Swift语言时，演示的那个“大炮打气球”的Ballons项目很感兴趣。</p>
<p>Ballons不但展现了playgrounds许多很赞的特性，还让我们看到写代码的过程，原来可以这么互动，这么好玩。</p>
<p>现在你可以下载这个<a href="https://developer.apple.com/swift/blog/downloads/Balloons.zip" target="_blank" rel="external">Ballons.playground</a>的教学版本，学习这些有趣的效果是怎么实现的。教学版本里除了源文件，还有相关说明文档，我们还出了一些小小的实验题，你可以动手修改代码，然后在右侧马上看到效果。</p>
<p>这个playground文件用到了SpriteKit的新特性，因此需要最新beta版本的Xcode 6和Yosemite系统来支持它运行。</p>
<p>本文由翻译自Apple Swift Blog的博文：<a href="https://developer.apple.com/swift/blog/?id=9" target="_blank" rel="external">Ballons</a> </p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/12/25/swift-cn/chapter4/04_Interacting_with_C_Pointers/" itemprop="url">
                  第四章-04Swift与C语言指针友好合作
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-12-25T10:00:07+08:00" content="2015-12-25">
              2015-12-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/swift-cn/" itemprop="url" rel="index">
                    <span itemprop="name">swift-cn</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/12/25/swift-cn/chapter4/04_Interacting_with_C_Pointers/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter4/04_Interacting_with_C_Pointers/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Swift_u4E0EC_u8BED_u8A00_u6307_u9488_u53CB_u597D_u5408_u4F5C"><a href="#Swift_u4E0EC_u8BED_u8A00_u6307_u9488_u53CB_u597D_u5408_u4F5C" class="headerlink" title="Swift与C语言指针友好合作"></a>Swift与C语言指针友好合作</h1><hr>
<blockquote>
<p>翻译：<a href="http://weibo.com/penguinliong/" target="_blank" rel="external">老码团队翻译组-Relly</a><br>校对：<a href="http://weibo.com/u/5241713117" target="_blank" rel="external">老码团队翻译组-Tyrion</a> </p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="/#inout-para-pointer">用以输入/输出的参数指针</a></li>
<li><a href="/#array-as-para-pointer">作为数组使用的参数指针</a></li>
<li><a href="/#string-as-para-pointer">用作字符串参数的指针</a></li>
<li><a href="/#security-of-pointer-cast">指针参数转换的安全性</a></li>
</ul>
<p>Objective-C和C的API常常会需要用到指针。Swift中的数据类型都原生支持基于指针的Cocoa API，不仅如此，Swift会自动处理部分最常用的将指针作为参数传递的情况。这篇文章中，我们将着眼于在Swift中让C语言指针与变量、数组和字符串共同工作。</p>
<p>####用以输入/输出的参数指针<br>C和Objective-C并不支持多返回值，所以Cocoa API中常常将指针作为一种在方法间传递额外数据的方式。Swift允许指针被当作<code>inout</code>参数使用，所以你可以用符号<code>&amp;</code>将对一个变量的引用作为指针参数传递。举例来说：<code>UIColor</code>中的<code>getRed(_:green:blue:alpha:)</code>方法需要四个<code>CGFloat*</code>指针来接收颜色的组成信息，我们使用<code>&amp;</code>来将这些组成信息捕获为本地变量：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r: <span class="type">CGFloat</span> = <span class="number">0</span>, g: <span class="type">CGFloat</span> = <span class="number">0</span>, b: <span class="type">CGFloat</span> = <span class="number">0</span>, a: <span class="type">CGFloat</span> = <span class="number">0</span></span><br><span class="line">color.getRed(&amp;r, green: &amp;g, blue: &amp;b, alpha: &amp;a)</span><br></pre></td></tr></table></figure></p>
<p>另一种常见的情况是Cocoa中<code>NSError</code>的习惯用法。许多方法会使用一个<code>NSError**</code>参数来储存可能的错误的信息。举例来说：我们用<code>NSFileManager</code>的<code>contentOfDirectoryAtPath(_:error:)</code>方法来将目录下的内容列表，并将潜在的错误指向一个<code>NSError?</code>变量：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maybeError: <span class="type">NSError</span>?</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> contents = <span class="type">NSFileManager</span>.defaultManager()</span><br><span class="line">	.contentsOfDirectoryAtPath(<span class="string">"/usr/bin"</span>, error: &amp;maybeError) &#123;</span><br><span class="line">	<span class="comment">// Work with the directory contents</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> error = maybeError &#123;</span><br><span class="line">	<span class="comment">// Handle the error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了安全性，Swift要求被使用<code>&amp;</code>传递的变量已经初始化。因为无法确定这个方法会不会在写入数据前尝试从指针中读取数据。</p>
<p>####作为数组使用的参数指针<br>在C语言中，数组和指针的联系十分紧密，而Swift允许数组能够作为指针使用，从而与基于数组的C语言API协同工作更加简单。一个固定的数组可以使用一个常量指针直接传递，一个变化的数组可以用<code>&amp;</code>运算符将一个非常量指针传递。就和输入/输出参数指针一样。举例来说：我们可以用Accelerate框架中的<code>vDSP_vadd</code>方法让两个数组<code>a</code>和<code>b</code>相加，并将结果写入第三个数组<code>result</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Accelerate</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: [<span class="type">Float</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> b: [<span class="type">Float</span>] = [<span class="number">0.5</span>, <span class="number">0.25</span>, <span class="number">0.125</span>, <span class="number">0.0625</span>]</span><br><span class="line"><span class="keyword">var</span> result: [<span class="type">Float</span>] = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">vDSP_vadd(a, <span class="number">1</span>, b, <span class="number">1</span>, &amp;result, <span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// result now contains [1.5, 2.25, 3.125, 4.0625]</span></span><br></pre></td></tr></table></figure></p>
<p>#用作字符串参数的指针<br>C语言中用<code>cont char*</code>指针来作为传递字符串的基本方式。Swift中的<code>String</code>可以被当作一个无限长度UTF-8编码的<code>const char*</code>指针来传递给方法。举例来说：我们可以直接传递一个字符串给一个标准C和POSIX库方法<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">puts(<span class="string">"Hello from libc"</span>)</span><br><span class="line"><span class="keyword">let</span> fd = open(<span class="string">"/tmp/scratch.txt"</span>, <span class="type">O_WRONLY</span>|<span class="type">O_CREAT</span>, <span class="number">0o666</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> fd &lt; <span class="number">0</span> &#123;</span><br><span class="line">	perror(<span class="string">"could not open /tmp/scratch.txt"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> text = <span class="string">"Hello World"</span></span><br><span class="line">	write(fd, text, strlen(text))</span><br><span class="line">	close(fd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>#指针参数转换的安全性<br>Swift很努力地使与C语言指针的交互更加便利，因为它们广泛地存在于Cocoa之中，同时保持一定的安全性。然而，相比你的其他Swift代码与C语言的指针交互具有潜在的不安全性，所以务必要小心使用。其中特别要注意：</p>
<ul>
<li><p>如果被调用者为了在其返回值之后再次使用而保存了C指针的数据，那么这些转换使用起来并不安全。转换后的指针仅在调用期间保证有效。甚至你将同样的变量、数组或字符串作为多指针参数再次传递，你每次都会收到一个不同的指针。这个异常将全局或静态地储存为变量。你可以安全地将这段地址当作永久唯一的指针使用。例如：作为一个KVO上下文参数使用的时候。</p>
</li>
<li><p>当指针类型为<code>Array</code>或<code>String</code>时，溢出检查不是强制进行的。 基于C语言的API无法增加数组和字符串大小，所以在你将其传递到基于C语言的API之前，你必须确保数组或字符的大小正确。</p>
</li>
</ul>
<p>如果你需要使用基于指针的API时没有遵守以上指导，或是你重写了接受指针参数的Cocoa方法，于是你可以在Swift中直接用不安全的指针来使用未经处理的内存。在未来的文章中我们将着眼于更加高级的情况。</p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/12/25/swift-cn/chapter4/05_Value_and_Reference_Types/" itemprop="url">
                  第四章-05Swift里的值类型与引用类型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-12-25T10:00:06+08:00" content="2015-12-25">
              2015-12-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/swift-cn/" itemprop="url" rel="index">
                    <span itemprop="name">swift-cn</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/12/25/swift-cn/chapter4/05_Value_and_Reference_Types/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter4/05_Value_and_Reference_Types/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Swift_u91CC_u7684_u503C_u7C7B_u578B_u4E0E_u5F15_u7528_u7C7B_u578B"><a href="#Swift_u91CC_u7684_u503C_u7C7B_u578B_u4E0E_u5F15_u7528_u7C7B_u578B" class="headerlink" title="Swift里的值类型与引用类型"></a>Swift里的值类型与引用类型</h1><hr>
<blockquote>
<p>翻译：<a href="http://weibo.com/littlekok/" target="_blank" rel="external">老码团队翻译组-Arya</a><br>校对：<a href="http://weibo.com/u/5241713117" target="_blank" rel="external">老码团队翻译组-Jame</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="/#difference-two">值类型与引用类型的区别</a></li>
<li><a href="/#act-in=mutation">Mutation（修改）在安全中扮演的角色</a></li>
<li><a href="/#how-to-choose">如何选择类型</a></li>
</ul>
<h3 id="Swift_u91CC_u9762_u7684_u7C7B_u578B_u5206_u4E3A_u4E24_u79CD_uFF1A"><a href="#Swift_u91CC_u9762_u7684_u7C7B_u578B_u5206_u4E3A_u4E24_u79CD_uFF1A" class="headerlink" title="Swift里面的类型分为两种："></a>Swift里面的类型分为两种：</h3><ul>
<li><strong>值类型(Value Types)</strong>：每个实例都保留了一分独有的数据拷贝，一般以结构体 <code>（struct）</code>、<code>枚举（enum）</code> 或者<code>元组（tuple）</code>的形式出现。</li>
<li><strong>引用类型(Reference Type)</strong>：每个实例共享同一份数据来源，一般以<code>类（class）</code>的形式出现。</li>
</ul>
<p>在这篇博文里面，我们会介绍两种类型各自的优点，以及应该怎么选择使用。</p>
<p><a name="difference-two"></a></p>
<h4 id="u503C_u7C7B_u578B_u4E0E_u5F15_u7528_u7C7B_u578B_u7684_u533A_u522B"><a href="#u503C_u7C7B_u578B_u4E0E_u5F15_u7528_u7C7B_u578B_u7684_u533A_u522B" class="headerlink" title="值类型与引用类型的区别"></a>值类型与引用类型的区别</h4><p>值类型和引用类型最基本的分别在复制之后的结果。当一个值类型被复制的时候，相当于创造了一个完全独立的实例，这个实例保有属于自己的独有数据，数据不会受到其他实例的数据变化影响：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是一个值类型的例子</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> </span>&#123; <span class="keyword">var</span> data: <span class="type">Int</span> = -<span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="type">S</span>()</span><br><span class="line"><span class="keyword">var</span> b = a							<span class="comment">// b是a的拷贝</span></span><br><span class="line">a.data = <span class="number">42</span>							<span class="comment">// 更改a的数据，b的不受影响</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"<span class="subst">\(a.data)</span>, <span class="subst">\(b.data)</span>"</span>)		<span class="comment">// 输出结果 "42, -1"</span></span><br></pre></td></tr></table></figure>
<p>值类型就好像身份证复印件一样，复印出来之后，修改原件上面的内容，复印件上的内容不会变。</p>
<p>另一方面，复制一个引用类型的时候，实际上是默默地创造了一个共享的实例分身，两者是共用一套数据。因此修改其中任何一个实例的数据，也会影响到另外那个。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是一个引用类型的例子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123; <span class="keyword">var</span> data: <span class="type">Int</span> = -<span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="type">C</span>()</span><br><span class="line"><span class="keyword">var</span> y = x							<span class="comment">// y是x的拷贝</span></span><br><span class="line">x.data = <span class="number">42</span>							<span class="comment">// 更改x的数据，等于同时修改了y</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"<span class="subst">\(x.data)</span>, <span class="subst">\(y.data)</span>"</span>)		<span class="comment">// 输出结果 "42, 42"</span></span><br></pre></td></tr></table></figure>
<p><a name="act-in=mutation"></a></p>
<h4 id="Mutation_uFF08_u4FEE_u6539_uFF09_u5728_u5B89_u5168_u4E2D_u626E_u6F14_u7684_u89D2_u8272"><a href="#Mutation_uFF08_u4FEE_u6539_uFF09_u5728_u5B89_u5168_u4E2D_u626E_u6F14_u7684_u89D2_u8272" class="headerlink" title="Mutation（修改）在安全中扮演的角色"></a>Mutation（修改）在安全中扮演的角色</h4><p>值类型较引用类型来说，会让你更容易在大量代码中理清状况。如果你总是得到一个独立的拷贝出来的实例，你就可以放心它不会被你app里面的其他部分代码默默地修改。这在多线程的环境里面是尤为重要的，因为另外一个线程可能会在暗地里修改你的数据。因此可能会造成严重的程序错误，这在调试过程中非常难以排除。</p>
<p>由于差别主要在于修改数据的后果，那么当实例的数据只读，不存在需要更改的情况下，用哪种类型都是没有分别的。</p>
<p>你可能在想，有的时候我可能也需要一个完全不变的类。这样使用<code>Cocoa NSObject</code>对象的时候会比较容易，又可以保留值语义的好处。在今天，你可以通过只使用不可变的存储属性，和避开任何可以修改状态的API，用Swift写出一个不可变类<code>（immutable class）</code>。实际上，很多基本的Cocoa类，例如<code>NSURL</code>，都是设计成不可变类的。然而，Swift语言目前只强制<code>struct</code>和<code>enum</code>这种值类型的不可变性，对类这种引用类型则没有。（例如还不支持强制将子类的限制为不可变类）</p>
<p><a name="how-to-choose"></a></p>
<h4 id="u5982_u4F55_u9009_u62E9_u7C7B_u578B_uFF1F"><a href="#u5982_u4F55_u9009_u62E9_u7C7B_u578B_uFF1F" class="headerlink" title="如何选择类型？"></a>如何选择类型？</h4><p>所以当我们想要建立一个新的类型的时候，怎么决定用值类型还是引用类型呢？当你使用Cocoa框架的时候，很多API都要通过NSObject的子类使用，所以这时候必须要用到引用类型class。在其他情况下，有下面几个准则：</p>
<ul>
<li><p><strong>什么时候该用值类型</strong>：</p>
<ul>
<li>要用==运算符来比较实例的数据时</li>
<li>你希望那个实例的拷贝能保持独立的状态时</li>
<li>数据会被多个线程使用时</li>
</ul>
</li>
<li><p><strong>什么时候该用引用类型（class）</strong>：</p>
<ul>
<li>要用==运算符来比较实例身份的时候</li>
<li>你希望有创建一个共享的、可变对象的时候</li>
</ul>
</li>
</ul>
<p>在Swift里面，数组(Array)、字符串(String)、字典(Dictionary)都属于值类型。它们就像C语言里面简单的int值，是一个个独立的数据个体。你不需要花任何功夫来防范其他代码在暗地里修改它们。更重要的是，你可以在线程之间安全的传递变量，而不需要特地去同步。在Swift高安全性的精神下，这个模式会帮助你用Swift写出更可控的代码。</p>
<hr>
<p>本章节不是老码的原创，老码认真的阅读了苹果的官方博客，且自己的练习总结，如果小伙伴们费了吃奶的劲还是看不懂，请找度娘谷歌，还是看不懂请到老码<a href="http://weibo.com/u/5241713117" target="_blank" rel="external">官方微博</a>咆哮。  </p>
<h5 id="u672C_u6587_u7531_u7FFB_u8BD1_u81EAApple_Swift_Blog__uFF1AValue_and_Reference_Types"><a href="#u672C_u6587_u7531_u7FFB_u8BD1_u81EAApple_Swift_Blog__uFF1AValue_and_Reference_Types" class="headerlink" title="本文由翻译自Apple Swift Blog ：Value and Reference Types"></a>本文由翻译自Apple Swift Blog ：<a href="https://developer.apple.com/swift/blog/?id=10" target="_blank" rel="external">Value and Reference Types</a></h5>
          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/12/25/swift-cn/chapter4/06_Access_Control_and_Protected/" itemprop="url">
                  第四章-06访问控制和protected
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-12-25T10:00:05+08:00" content="2015-12-25">
              2015-12-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/swift-cn/" itemprop="url" rel="index">
                    <span itemprop="name">swift-cn</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/12/25/swift-cn/chapter4/06_Access_Control_and_Protected/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter4/06_Access_Control_and_Protected/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="u8BBF_u95EE_u63A7_u5236_u548Cprotected"><a href="#u8BBF_u95EE_u63A7_u5236_u548Cprotected" class="headerlink" title="访问控制和protected"></a>访问控制和protected</h1><hr>
<blockquote>
<p>翻译：<a href="http://weibo.com/littlekok/" target="_blank" rel="external">老码团队翻译组-Arya</a><br>校对：<a href="http://weibo.com/u/5241713117" target="_blank" rel="external">老码团队翻译组-Jame</a></p>
</blockquote>
<p>原文再续，书折第一回。</p>
<p>很多其他编程语言都有一种”protected“设定，可以限制某些类方法只能被它的子类所使用。</p>
<p>Swift支持了访问控制后，大家给我们的反馈都很不错。而有的开发者问我们：“为什么Swift没有类似protected的选项？” </p>
<p><strong>当我们在设计Swift访问控制的不同等级时，我们认为有两种主要场景：</strong></p>
<ul>
<li>在一个APP里：隐藏某个类的私密细节。</li>
<li>在一个开源框架里：不让导入这个框架的APP，随便接触框架的内部实现细节。</li>
</ul>
<p>上面的两种常见情况，对应着private和internal这两个等级。</p>
<p>而protected相当于把访问控制和继承特性混在一起，把访问控制的等级设定增加了一个维度，使之复杂化。即使设定了protected，子类还是可以通过新的公开方法、新的属性来接触到所谓“protected”了的API。另一方面，我们可以在各种地方重写一个方法，所谓的保护却没有提供优化机制。这种设定往往在做不必要的限制  一 protected允许了子类，但又禁止所有其他别的类（包括那些帮助子类实现某些功能的类）接触父类的成员。</p>
<p>有的开发者指出，apple的框架有时候也会把给子类用的API分隔出来。这时候protected不就有用了吗？我们研究后发现，这些方法一般属于下面两种情况：一是这些方法对子类以外的类没啥用，所以不需要严格保护（例如上面说的协助实现某些功能的类）。二是这些方法就是设计出来被重写，而不是直接用的。举个例子，<code>drawRect(_:)</code>就是在UIKit基础上使用的方法，但它不能在UIKit以外应用。</p>
<p>除此之外，如果有了protected，它要怎么样和extension相互作用呢？一个类的extension能接触它的protected成员吗？一个子类的extension可以接触父类的protected成员吗？extension声明的位置对访问控制等级有没有影响呢？（复杂到要哭了是不是？）</p>
<p>对访问控制的设计，也依循了Objective－C开发者（包括apple内外的）的常规做法。Objective－C方法和属性一般在.h头文件里声明，但也可以写在.m实现文件里。假如有一个公开的类，想把里面某些部分设为只有框架内可以获取时，开发者一般会创建另一个头文件给内部使用。以上三种访问级别，就对应了Swift里面的public，private和internal。</p>
<p>Swift的访问控制等级和继承无关，是单维度、非常清楚明了的。我们认为这样的模式更简洁，同时满足了最主要的需求：将一个类、或一个框架的实现细节隔离保护起来。这可能和你以前用过的不同，但我们鼓励你试试看。</p>
<hr>
<p>本章节不是老码的原创，是老码认真的阅读了苹果的官方博客，自己的练习总结，如果小伙伴们费了吃奶的劲还是看不懂，请找度娘谷歌。还是看不懂？请到老码<a href="http://weibo.com/u/5241713117" target="_blank" rel="external">官方微博</a>咆哮。  </p>
<h5 id="u672C_u6587_u7531_u7FFB_u8BD1_u81EAApple_Swift_Blog__uFF1AAccess_Control_and_Protected"><a href="#u672C_u6587_u7531_u7FFB_u8BD1_u81EAApple_Swift_Blog__uFF1AAccess_Control_and_Protected" class="headerlink" title="本文由翻译自Apple Swift Blog ：Access Control and Protected"></a>本文由翻译自Apple Swift Blog ：<a href="/原文地址：https://developer.apple.com/swift/blog/?id=11">Access Control and Protected</a></h5>
          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/12/25/swift-cn/chapter4/07_Optional_Case_Study/" itemprop="url">
                  第四章-07可选类型完美解决占位问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-12-25T10:00:04+08:00" content="2015-12-25">
              2015-12-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/swift-cn/" itemprop="url" rel="index">
                    <span itemprop="name">swift-cn</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/12/25/swift-cn/chapter4/07_Optional_Case_Study/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter4/07_Optional_Case_Study/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="u53EF_u9009_u7C7B_u578B_u5B8C_u7F8E_u89E3_u51B3_u5360_u4F4D_u95EE_u9898"><a href="#u53EF_u9009_u7C7B_u578B_u5B8C_u7F8E_u89E3_u51B3_u5360_u4F4D_u95EE_u9898" class="headerlink" title="可选类型完美解决占位问题"></a>可选类型完美解决占位问题</h1><hr>
<blockquote>
<p>翻译：<a href="http://weibo.com/u/5241713117" target="_blank" rel="external">老码团队翻译组-Tyrion</a><br>校对：<a href="http://weibo.com/littlekok/" target="_blank" rel="external">老码团队翻译组-Ayra</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="/#add-function">为Dictionary增加objectsForKeys函数</a></li>
<li><a href="/##easy-function">Swift中更简便的方法</a></li>
<li><a href="/#nested-optional">内嵌可选类型</a></li>
<li><a href="/#provide-default">提供一个默认值</a></li>
</ul>
<p>可选类型是Swift中新引入的，功能很强大。在这篇博文里讨论的，是在Swift里，如何通过可选类型来保证强类型的安全性。作为例子，我们来创建一个Objective-C API的Swift版本，但实际上Swift本身并不需要这样的API。</p>
<p><a name="#add-function"></a></p>
<h4 id="u4E3ADictionary_u589E_u52A0objectsForKeys_u51FD_u6570"><a href="#u4E3ADictionary_u589E_u52A0objectsForKeys_u51FD_u6570" class="headerlink" title="为Dictionary增加objectsForKeys函数"></a>为Dictionary增加objectsForKeys函数</h4><p>在Objective-C中，<figure class="highlight"><figcaption><span>这个方法需要一个```NSArray```数组作为键值参数，然后返回一个包含相关值的数组。文档里写到："返回数组中的第N个值，和输入数组中的第N个值相对应"，那如果有某个键值在字典里不存在呢？于是就有了```notFoundMarker```作为返回提示。比如第三个键值没有找到，那么在返回数组中第三个值就是这个```notFoundMarker```，而不是字典中的第三个值，但是这个值只是用来提醒原字典中没有找到对应值，但在返回数组中该元素存在，且用```notFoundMarker```作为占位符，因为这个对象不能直接使用，所以在Foundation框架中有个专门的类处理这个情况：```NSNull```。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;&#22312;Swift&#20013;&#65292;```Dictionary```&#31867;&#27809;&#26377;&#31867;&#20284;```objectsForKeys```&#30340;&#20989;&#25968;&#65292;&#20026;&#20102;&#35828;&#26126;&#38382;&#39064;&#65292;&#25105;&#20204;&#21160;&#25163;&#21152;&#19968;&#20010;&#65292;&#24182;&#19988;&#20351;&#20854;&#25104;&#20026;&#25805;&#20316;&#23383;&#20856;&#20540;&#30340;&#36890;&#29992;&#26041;&#27861;&#12290;&#25105;&#20204;&#21487;&#20197;&#29992;```extension```&#26469;&#23454;&#29616;&#65306;&#10;&#10;```swift&#10;extension Dictionary&#123;&#10;&#9;func valuesForKeys(keys:[K], notFoundMarker: V )-&#62;[V]&#123;&#10;&#9;&#9;//&#20855;&#20307;&#23454;&#29616;&#20195;&#30721;&#21518;&#38754;&#20250;&#20889;&#21040;&#10;&#9;&#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上就是我们实现的Swift版本，这个和Objective-C版本有很大区别。在Swift中，因为其强类型的原因限制了返回的结果数组只能包含单一类型的元素，所以我们不能放<figure class="highlight"><figcaption><span>我们只用```nil```就可以了。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;&#10;```swift&#10;extension Dictionary&#123;&#10;    func valuesForKeys(keys: [Key]) -&#62; [Value?] &#123;&#10;        var result = [Value?]()&#10;        result.reserveCapacity(keys.count)&#10;        for key in keys&#123;&#10;            result.append(self[key])&#10;        &#125;&#10;        return result&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p><a name="#easy-function"></a></p>
<h4 id="Swift_u4E2D_u66F4_u7B80_u4FBF_u7684_u65B9_u6CD5"><a href="#Swift_u4E2D_u66F4_u7B80_u4FBF_u7684_u65B9_u6CD5" class="headerlink" title="Swift中更简便的方法"></a>Swift中更简便的方法</h4><p>小伙伴们可能会问，为什么Swift中不需要实现这么一个API呢？其实其有更简单的实现，如下面代码所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Dictionary</span> </span>&#123;</span><br><span class="line">	<span class="func"><span class="keyword">func</span> <span class="title">valuesForKeys</span><span class="params">(keys: [Key])</span></span> -&gt; [<span class="type">Value</span>?] &#123;</span><br><span class="line">		<span class="keyword">return</span> keys.<span class="built_in">map</span> &#123; <span class="keyword">self</span>[$<span class="number">0</span>] &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方式实现的功能和最开始的方法实现的功能相同，虽然核心的功能是封装了<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;&#25509;&#19979;&#26469;&#65292;&#25105;&#20204;&#23454;&#39564;&#20960;&#20010;&#20363;&#23376;&#65306;&#10;&#10;```swift&#10;var dic: Dictionary = [ &#34;1&#34;: 2, &#34;3&#34;:3, &#34;4&#34;:5 ]&#10;&#10;var t = dic.valuesForKeys([&#34;1&#34;, &#34;4&#34;]) &#10;//&#32467;&#26524;&#20026;&#65306;[Optional(2), Optional(5)]&#10;&#10;var t = dict.valuesForKeys([&#34;3&#34;, &#34;9&#34;])&#10;// &#32467;&#26524;&#20026;&#65306;[Optional(3), nil]&#10;&#10;t = dic.valuesForKeys([])&#10;//&#32467;&#26524;&#20026;&#65306;[]</span><br></pre></td></tr></table></figure></p>
<p><a name="#nested-optional"></a></p>
<h4 id="u5185_u5D4C_u53EF_u9009_u7C7B_u578B"><a href="#u5185_u5D4C_u53EF_u9009_u7C7B_u578B" class="headerlink" title="内嵌可选类型"></a>内嵌可选类型</h4><p>现在，如果我们为每一个结果调用<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;```swift&#10;var dic: Dictionary = [ &#34;1&#34;: 2, &#34;3&#34;:3, &#34;4&#34;:5 ]&#10;&#10;var t = dic.valuesForKeys([&#34;1&#34;, &#34;4&#34;]).last //&#32467;&#26524;&#20026;&#65306;Optional(Optional(5))&#10;// Optional(Optional(&#34;Ching&#34;))&#10;&#10;var t = dict.valuesForKeys([&#34;3&#34;, &#34;9&#34;]).last&#10;// &#32467;&#26524;&#20026;&#65306;Optional(nil)&#10;&#10;var t = dict.valuesForKeys([]).last&#10;// &#32467;&#26524;&#20026;&#65306;nil</span><br></pre></td></tr></table></figure></p>
<p>小伙伴们立马迷糊了，为什么会出现两层包含的可选类型呢？，特别对第二种情况的<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;&#25105;&#20204;&#22238;&#36807;&#22836;&#30475;&#30475;```last```&#23646;&#24615;&#30340;&#23450;&#20041;&#65306;&#10;&#10;```swift&#10;var last:T? &#123; get &#125;</span><br></pre></td></tr></table></figure></p>
<p>很明显<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;&#22914;&#26524;&#22312;Objective-C&#20013;&#37325;&#26032;&#35843;&#29992;&#19978;&#36848;&#26041;&#27861;&#65292;&#25105;&#20204;&#23558;&#20351;&#29992;```NSNull```&#20316;&#20026;&#21344;&#20301;&#31526;&#65292;Objective-C&#30340;&#35843;&#29992;&#35821;&#27861;&#22914;&#19979;&#25152;&#31034;&#65306;&#10;&#10;```swift&#10;[dict valuesForKeys:@[@&#34;1&#34;, @&#34;4&#34;] notFoundMarker:[NSNull null]].lastObject&#10;// 5&#10;[dict valuesForKeys:@[@&#34;1&#34;, @&#34;3&#34;] notFoundMarker:[NSNull null]].lastObject&#10;// NSNull&#10;[dict valuesForKeys:@[] notFoundMarker:[NSNull null]].lastObject&#10;// nil</span><br></pre></td></tr></table></figure></p>
<p>不管是Swift版本还是Objective-C版本，返回值为<figure class="highlight"><figcaption><span>但是如果返回是```Optional(nil)```或者Objective-C中的```NSNull```都表示数组中的最后一个元素存在，但是元素的内容是空的。在Objective-C中只能借助```NSNull```作为占位符来达到这个目的，但是Swift却可以语言系统类型的角度的实现。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;&#60;a name=&#34;#provide-default&#34;&#62;&#60;/a&#62;&#10;#### &#25552;&#20379;&#19968;&#20010;&#40664;&#35748;&#20540;&#10;&#10;&#36827;&#19968;&#27493;&#23553;&#35013;&#65292;&#22914;&#26524;&#25105;&#23383;&#20856;&#20013;&#30340;&#26576;&#20010;&#25110;&#26576;&#20123;&#20803;&#32032;&#19981;&#23384;&#22312;&#65292;&#25105;&#20204;&#24819;&#25552;&#20379;&#19968;&#20010;&#40664;&#35748;&#20540;&#24590;&#20040;&#21150;&#21602;&#65311;&#23454;&#29616;&#26041;&#27861;&#24456;&#31616;&#21333;&#65306;&#10;&#10;```swift&#10;extension Dictionary &#123;&#10;&#9;func valuesForKeys( keys:[Key], notFoundMarker: Value)-&#62;[Value]&#123;&#10;&#9;&#9;return self.valueForKeys(kes).map&#123; $0 ?? notFoundMarker &#125;&#10;&#9;&#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict.<span class="function"><span class="title">valuesForKeys</span><span class="params">([<span class="string">"1"</span>, <span class="string">"5"</span>], notFoundMarker: <span class="string">"Anonymous"</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>和Objective-C相比，其需要占位符来达到占位的目的，但是Swift却已经从语言类型系统的层面原生的支持了这种用法，同时提供了丰富的语法功能。这就是Swift可选类型的强大之处。同时注意上述例子中用到了空合运算符<code>??</code>。</p>
<hr>
<p>本章节不是老码的原创，是老码认真的阅读了苹果的官方博客，自己的练习总结，如果小伙伴们费了吃奶的劲还是看不懂，请找度娘谷歌。还是看不懂？请到老码<a href="http://weibo.com/u/5241713117" target="_blank" rel="external">官方微博</a>咆哮。  </p>
<h5 id="u672C_u6587_u7531_u7FFB_u8BD1_u81EAApple_Swift_Blog__uFF1AOptionals_Case_Study_3A_valuesForKeys"><a href="#u672C_u6587_u7531_u7FFB_u8BD1_u81EAApple_Swift_Blog__uFF1AOptionals_Case_Study_3A_valuesForKeys" class="headerlink" title="本文由翻译自Apple Swift Blog ：Optionals Case Study: valuesForKeys"></a>本文由翻译自Apple Swift Blog ：<a href="https://developer.apple.com/swift/blog/?id=12" target="_blank" rel="external">Optionals Case Study: valuesForKeys</a></h5>
          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/12/19/awesome-power-mode-master/" itemprop="url">
                  代码震动插件Awesome Power Mode
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-12-19T07:56:29+08:00" content="2015-12-19">
              2015-12-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/blog/" itemprop="url" rel="index">
                    <span itemprop="name">blog</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/12/19/awesome-power-mode-master/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/19/awesome-power-mode-master/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Awesome_Power_Mode"><a href="#Awesome_Power_Mode" class="headerlink" title="Awesome Power Mode"></a>Awesome Power Mode</h1><blockquote>
<p>A curated list of power modes as popularized in <a href="https://github.com/codeinthedark/editor/pull/1" target="_blank" rel="external">https://github.com/codeinthedark/editor/pull/1</a> by <a href="https://github.com/joelbesada" target="_blank" rel="external">@JoelBesada</a>.</p>
</blockquote>
<h2 id="Atom"><a href="#Atom" class="headerlink" title="Atom"></a>Atom</h2><ul>
<li><a href="https://github.com/JoelBesada/activate-power-mode" target="_blank" rel="external">https://github.com/JoelBesada/activate-power-mode</a></li>
</ul>
<h2 id="Codemirror"><a href="#Codemirror" class="headerlink" title="Codemirror"></a>Codemirror</h2><ul>
<li><a href="https://github.com/chinchang/code-blast-codemirror" target="_blank" rel="external">https://github.com/chinchang/code-blast-codemirror</a></li>
</ul>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><ul>
<li><a href="https://github.com/disjukr/activate-power-mode" target="_blank" rel="external">https://github.com/disjukr/activate-power-mode</a></li>
</ul>
<h2 id="VIM"><a href="#VIM" class="headerlink" title="VIM"></a>VIM</h2><ul>
<li><a href="https://github.com/mattn/vim-particle" target="_blank" rel="external">https://github.com/mattn/vim-particle</a></li>
</ul>
<h2 id="Visual_Studio"><a href="#Visual_Studio" class="headerlink" title="Visual Studio"></a>Visual Studio</h2><ul>
<li><a href="https://github.com/LiamMorrow/Visual-Studio-Power-Mode" target="_blank" rel="external">https://github.com/LiamMorrow/Visual-Studio-Power-Mode</a></li>
</ul>
<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><ul>
<li><a href="https://github.com/if1live/ParticleOnTextCursor" target="_blank" rel="external">https://github.com/if1live/ParticleOnTextCursor</a></li>
</ul>
<h2 id="XCode"><a href="#XCode" class="headerlink" title="XCode"></a>XCode</h2><ul>
<li><a href="https://github.com/poboke/ActivatePowerMode" target="_blank" rel="external">https://github.com/poboke/ActivatePowerMode</a></li>
<li><a href="https://github.com/qfish/XActivatePowerMode" target="_blank" rel="external">https://github.com/qfish/XActivatePowerMode</a></li>
<li><a href="https://github.com/Dawn-/CoderPower" target="_blank" rel="external">https://github.com/Dawn-/CoderPower</a></li>
</ul>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/12/18/bilibili/2831578/" itemprop="url">
                  中二病也要谈恋爱！恋 Lite＋SP 合辑【BD1080P】
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-12-18T07:56:29+08:00" content="2015-12-18">
              2015-12-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/helloworld/" itemprop="url" rel="index">
                    <span itemprop="name">helloworld</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/12/18/bilibili/2831578/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/18/bilibili/2831578/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div class="bili_video"><embed height="452" width="544" quality="high" allowfullscreen="true" type="application/x-shockwave-flash" src="http://share.acg.tv/flash.swf" flashvars="aid=2831578&page=1" pluginspage="http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash"></div>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    

  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars2.githubusercontent.com/u/14305708?v=3&s=460"
               alt="terry" />
          <p class="site-author-name" itemprop="name">terry</p>
          <p class="site-description motion-element" itemprop="description">terry yang's blog | java | scala | bi</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">160</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>
          
          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">53</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yangwei8888" target="_blank">
                  
                    <i class="fa fa-globe"></i> github
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/microsoftgoogles" target="_blank">
                  
                    <i class="fa fa-globe"></i> weibo
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/run-zhi-38" target="_blank">
                  
                    <i class="fa fa-globe"></i> zhihu
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">terry</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  


  



  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'yangwei888';
      var disqus_identifier = 'page/7/index.html';
      var disqus_title = '';
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  



  
  

  
  


</body>
</html>
