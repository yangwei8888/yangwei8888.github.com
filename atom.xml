<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[yosita]]></title>
  <subtitle><![CDATA[ѧ��]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-12-18T10:23:30.049Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[terry]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[.NET 实时通信开发指南]]></title>
    <link href="http://yoursite.com/2015/12/30/avos/dotnet_realtime/"/>
    <id>http://yoursite.com/2015/12/30/avos/dotnet_realtime/</id>
    <published>2015-12-29T23:56:29.000Z</published>
    <updated>2015-12-18T10:23:30.049Z</updated>
    <content type="html"><![CDATA[<h1 id="-NET_实时通信开发指南">.NET 实时通信开发指南</h1><h2 id="简介">简介</h2><p>在阅读本开发指南之前，请先阅读下<a href="./realtime_v2.html">《实时通信开发指南》</a>，了解实时通信的基本概念和模型。</p>
<p>目前我们的 .NET 实时通信支持如下运行时：</p>
<ul>
<li>Windows Phone Silverlight （8.0 &amp; 8.1）</li>
<li>Windows Desktop .NET Framework 4.5+</li>
<li>Xamarin Form 1.4+</li>
<li>Xamarin iOS 8+</li>
<li>Xamarin Android 5+</li>
</ul>
<p>尚未发布但是已在计划内的如下：</p>
<ul>
<li>Windows Runtime （for Windows 10）</li>
</ul>
<p>文档中涉及的语法以及接口均对所有运行时有效。</p>
<h2 id="安装">安装</h2><p>为了支持实时聊天，LeanCloud SDK for .NET 依赖于几个开源的 WebSocket 的库，所以推荐开发者从 <a href="https://www.nuget.org/packages/AVOSCloud.Phone/1.3.0-beta" target="_blank" rel="external">Nuget</a> 上下载我们的 SDK。</p>
<h2 id="初始化">初始化</h2><p>导入 SDK 之后，在应用入口函数中添加如下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//generated code by visual studio&#10;...&#10;AVClient.Initialize(&#34;&#20320;&#30340; AppId&#34;, &#34;&#20320;&#30340; AppKey&#34;);&#10;...</span><br></pre></td></tr></table></figure>
<p>例如，在 Windows 控制台的 Main 函数入口可以调用以上代码进行初始化。</p>
<h2 id="单聊">单聊</h2><h3 id="发送消息">发送消息</h3><p>此场景类似于微信的私聊，微博的私信以及 QQ 单聊的场景，我们建立了一个统一的概念来描述聊天的各种场景：对话 — AVIMConversation，在<a href="./realtime_v2.html">《实时通信开发指南》</a>里面有详细的介绍。</p>
<p>Tom 想发送一条消息给 Jerry，下面的代码将帮助他实现这一功能：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void TomCreateConversationWithJerry()&#10;&#123;&#10;    //Tom &#29992;&#33258;&#24049;&#30340;&#21517;&#23383;&#20316;&#20026; ClientId &#24314;&#31435;&#20102;&#19968;&#20010; AVIMClient&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;&#10;    //Tom &#30331;&#24405;&#21040;&#31995;&#32479;&#10;    await client.ConnectAsync();&#10;&#10;    //Tom &#24314;&#31435;&#20102;&#19982; Jerry &#30340;&#23545;&#35805;&#10;    AVIMConversation conversation = await client.CreateConversationAsync(&#34;Jerry&#34;);&#10;&#10;    //Tom &#21457;&#20102;&#19968;&#26465;&#28040;&#24687;&#32473; Jerry&#10;    await conversation.SendTextMessageAsync(&#34;Hello,Jerry!&#34;);&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接收消息">接收消息</h3><p>Jerry 如果想收到 Tom 的消息，他需要如下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void JerryReceiveMessageFromTom()&#10;&#123;&#10;    //Jerry &#29992;&#33258;&#24049;&#30340;&#21517;&#23383;&#20316;&#20026; ClientId &#24314;&#31435;&#20102;&#19968;&#20010; AVIMClient&#10;    AVIMClient client = new AVIMClient(&#34;Jerry&#34;);&#10;&#10;    //Tom &#30331;&#24405;&#21040;&#31995;&#32479;&#10;    await client.ConnectAsync();&#10;&#10;    //Jerry &#35774;&#32622;&#25509;&#25910;&#28040;&#24687;&#30340;&#26041;&#27861;&#65292;&#19968;&#26086;&#26377;&#28040;&#24687;&#25910;&#21040;&#23601;&#20250;&#35843;&#29992;&#36825;&#20010;&#26041;&#27861;&#10;    client.OnMessageReceieved += (s, e) =&#62;&#10;    &#123;&#10;        if (e.Message is AVIMTextMessage)&#10;        &#123;&#10;            string words = ((AVIMTextMessage)e.Message).TextContent;&#10;            //words &#20869;&#23481;&#21363;&#20026;&#65306;Hello,Jerry!&#10;        &#125;&#10;    &#125;;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>运行以上代码之后，在 LeanCloud 网站的控制台找到指定的应用，打开存储管理控制台，可以看到默认表 <code>_Conversation</code>中多了一条数据，该条数据的字段解释如下：</p>
<ul>
<li>name：String，对话唯一的名字。</li>
<li>m：Array，对话中成员的列表。</li>
<li>lm：Date，对话中最后一条消息发送的时间。</li>
<li>c：String，对话的创建者的 ClientId</li>
<li>mu：Array，对话中设置了静音的成员，仅针对 iOS 以及 Windows Phone 用户有效</li>
<li>attr：Object，开发者设置的对话的自定义属性。</li>
</ul>
<h2 id="群聊">群聊</h2><p>此场景类似于微信的多人聊天群组，以及 QQ 群 ，请注意这里的群聊指的是持久化存储的一个群组的概念，比如 QQ 群，除非群主解散该群，这个群应该是一直存在于 我的QQ群 列表中。关于临时群组聊天（聊天室）会在之后做单独解释。</p>
<h3 id="发送消息-1">发送消息</h3><p>Tom 想建立一个群，把自己好朋友都拉进这个群，然后给他们发消息，他需要做的事情是：</p>
<ul>
<li>第一步：建立一个朋友列表</li>
<li>第二步：新建一个对话，把朋友列为对话的参与人员</li>
<li>第三步：发送一条消息</li>
</ul>
<p>以下代码将实现这个需求：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void TomCreateConversationWithFriends()&#10;&#123;&#10;    //Tom &#29992;&#33258;&#24049;&#30340;&#21517;&#23383;&#20316;&#20026; ClientId &#24314;&#31435;&#20102;&#19968;&#20010; AVIMClient&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;&#10;    //Tom &#30331;&#24405;&#21040;&#31995;&#32479;&#10;    await client.ConnectAsync();&#10;&#10;    #region &#31532;&#19968;&#27493;&#65306;&#24314;&#31435;&#19968;&#20010;&#26379;&#21451;&#21015;&#34920;&#10;    IList&#60;string&#62; friends = new List&#60;string&#62;();&#10;    friends.Add(&#34;Jerry&#34;);&#10;    friends.Add(&#34;Bob&#34;);&#10;    friends.Add(&#34;Harry&#34;);&#10;    friends.Add(&#34;William&#34;);&#10;    #endregion&#10;&#10;    #region &#26032;&#24314;&#19968;&#20010;&#23545;&#35805;&#65292;&#25226;&#26379;&#21451;&#20204;&#21015;&#20026;&#23545;&#35805;&#30340;&#21442;&#19982;&#20154;&#21592;&#10;    AVIMConversation friendConversation = await client.CreateConversationAsync(friends);&#10;    #endregion&#10;&#10;    #region &#31532;&#19977;&#27493;&#65306;&#21457;&#36865;&#19968;&#26465;&#28040;&#24687;&#10;    await friendConversation.SendTextMessageAsync(&#34;Hey&#65292;&#20320;&#20204;&#22312;&#21738;&#37324;&#65311;&#34;);&#10;    #endregion&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接收消息-1">接收消息</h3><p>群聊的接收消息与单聊的接收消息是一样的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVIMConversation NotifiedConversation = null;&#10;public async void BobReceiveMessageFromTom()&#10;&#123;&#10;    //Bob &#29992;&#33258;&#24049;&#30340;&#21517;&#23383;&#20316;&#20026; ClientId &#24314;&#31435;&#20102;&#19968;&#20010; AVIMClient&#10;    AVIMClient client = new AVIMClient(&#34;Bob&#34;);&#10;&#10;    //Bob &#30331;&#24405;&#21040;&#31995;&#32479;&#10;    await client.ConnectAsync();&#10;&#10;    //Bob &#35774;&#32622;&#25509;&#25910;&#28040;&#24687;&#30340;&#26041;&#27861;&#65292;&#19968;&#26086;&#26377;&#28040;&#24687;&#25910;&#21040;&#23601;&#20250;&#35843;&#29992;&#36825;&#20010;&#26041;&#27861;&#10;    client.OnMessageReceieved += (s, e) =&#62;&#10;    &#123;&#10;        if (e.Message is AVIMTextMessage)&#10;        &#123;&#10;            //words &#30340;&#20869;&#23481;&#23601;&#26159;&#65306;Hey&#65292;&#20320;&#20204;&#22312;&#21738;&#37324;&#65311;&#10;            string words = ((AVIMTextMessage)e.Message).TextContent;&#10;&#10;            //AVIMClient &#22312;&#25509;&#25910;&#21040;&#28040;&#24687;&#30340;&#26102;&#20505;&#65292;&#20250;&#19968;&#24182;&#25552;&#20379;&#28040;&#24687;&#25152;&#22312;&#30340; AVIMConversation&#10;            NotifiedConversation = e.Conversation;&#10;&#10;            if (NotifiedConversation != null)&#10;            &#123;&#10;                //Bob &#25910;&#21040;&#28040;&#24687;&#21518;&#21448;&#22238;&#22797;&#20102;&#19968;&#26465;&#28040;&#24687;&#10;                NotifiedConversation.SendTextMessageAsync(&#34;HI,Tom :&#25105;&#22312; Jerry &#23478;&#37324;&#65292;&#20320;&#36319; Harry &#20160;&#20040;&#26102;&#20505;&#36807;&#26469;&#65311;&#36824;&#26377; William &#21644;&#20320;&#22312;&#19968;&#36215;&#20040;&#65311;&#34;);&#10;            &#125;&#10;        &#125;&#10;    &#125;;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>而以上 Tom 和 Bob 发送的消息，William 上线的时候都会收到。</p>
<p><strong>注： AVIMClient CreateConversationAsync 有多种重载方法供开发者调用，详细的开发者可以在 Visual Studio 中查看定义</strong>。</p>
<h2 id="消息">消息</h2><p>消息在最新版本的 SDK 中做了多层抽象以及封装，详细的我们先从如何发送接收富媒体消息开始。</p>
<h3 id="富媒体消息">富媒体消息</h3><p>富媒体消息的支持是新版 SDK 的核心提升，我们目前 SDK 已经支持的富媒体消息类型有以下几种：</p>
<ul>
<li>图像消息：<code>AVIMImageMessage</code></li>
<li>音频消息：<code>AVIMAudioMessage</code></li>
<li>视频消息：<code>AVIMVideoMessage</code></li>
<li>文件消息：<code>AVIMFileMessage</code></li>
<li>地理位置消息：<code>AVIMLocationMessage</code></li>
</ul>
<h4 id="图像消息">图像消息</h4><p>图像消息可以由系统提供的拍照 API，以及媒体库中获取，也可以是可访问的图像有效 Url，只要开发者调用一个构造方法，构造出一个 <code>AVIMImageMessage</code>，然后把 <code>AVIMImageMessage</code> 对象当做参数交由 <code>AVConversation</code> 发送出去即可。</p>
<h5 id="发送图像消息">发送图像消息</h5><p>场景 1：比如从微博拷贝了一个图像链接，然后可以通过 SDK 直接构建一个 <code>AVIMImageMessage</code>并且发送出去：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void SendImageMessageAsync_Test()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    &#10;    await client.ConnectAsync();//Tom &#30331;&#24405;&#10;&#10;    AVIMConversation conversation = await client.CreateConversationAsync(&#34;Jerry&#34;, &#34;&#29483;&#21644;&#32769;&#40736;&#34;);//&#21019;&#24314;&#23545;&#35805;&#10;&#10;    AVIMImageMessage imgMessage = new AVIMImageMessage(&#34;http://pic2.zhimg.com/6c10e6053c739ed0ce676a0aff15cf1c.gif&#34;);//&#20174;&#22806;&#37096;&#38142;&#25509;&#21019;&#24314;&#22270;&#20687;&#28040;&#24687;&#10;    await conversation.SendImageMessageAsync(imgMessage);//&#21457;&#36865;&#32473; Jerry&#10;&#125;&#10;``` &#10;&#10;&#22330;&#26223; 2&#65306;&#31995;&#32479;&#20063;&#25552;&#20379;&#20102; API &#21435;&#33719;&#21462;&#23186;&#20307;&#24211;&#37324;&#38754;&#30340;&#29031;&#29255;&#65292;&#24320;&#21457;&#32773;&#21482;&#38656;&#35201;&#35843;&#29992;&#31995;&#32479;&#30340; API &#33719;&#21462;&#22270;&#20687;&#25991;&#20214;&#30340;&#25968;&#25454;&#27969;&#65292;&#28982;&#21518;&#26500;&#36896;&#20986;&#19968;&#20010; `AVIMImageMessage`&#65292;&#20877;&#35843;&#29992; `AVIMConversation.SendImageMessageAsync`&#21435;&#21457;&#36865;&#22270;&#20687;&#65306;&#10;&#10;```c#&#10;MediaLibrary library = new MediaLibrary();//&#31995;&#32479;&#23186;&#20307;&#24211;&#10;var photo = library.Pictures[0];//&#33719;&#21462;&#31532;&#19968;&#24352;&#29031;&#29255;&#65292;&#36816;&#34892;&#36825;&#27573;&#20195;&#30721;&#65292;&#30830;&#20445;&#25163;&#26426;&#20197;&#21450;&#34394;&#25311;&#26426;&#37324;&#38754;&#30340;&#23186;&#20307;&#24211;&#33267;&#23569;&#26377;&#19968;&#24352;&#29031;&#29255;&#10;&#10;AVIMImageMessage imgMessage = new AVIMImageMessage(photo.Name, photo.GetImage());//&#26500;&#36896; AVIMImageMessage&#10;imgMessage.Attributes = new Dictionary&#60;string, object&#62;() &#10;&#123; &#10;    &#123;&#34;location&#34;,&#34;San Francisco&#34;&#125;&#10;&#125;;&#10;imgMessage.Title = &#34;&#21457;&#33258;&#25105;&#30340; WP&#34;;&#10;await conversation.SendImageMessageAsync(imgMessage);</span><br></pre></td></tr></table></figure></p>
<p>以上 2 种场景中对于 SDK 的区别就是如下：</p>
<ul>
<li>场景 1 中，SDK 并没有实际将图像上传到服务端，而是仅仅是把 URL 包装在消息体内发送出去，并且这种情况下接收方是无法从消息体中获取到元信息等数据的，不过开发者可以自行获取。</li>
<li>场景 2中，SDK 获取了完整的图像的数据流，所以 SDK 会先上传文件到服务端，然后将文件的元数据以及 URL 等一并包装，再发送出去。</li>
</ul>
<h5 id="接收图像消息">接收图像消息</h5><p>类似于第一章节中单聊中的接收消息，在 <code>AVIMClient</code> 中的 <code>OnMessageReceived</code> 可以收到消息，但是假如接收方在客户端也正好加载了这个对话，那么接收方在 <code>AVIMConversation</code> 里面也会收到 <code>OnImageMessageReceived</code> 的事件响应：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void ReceiveImageMessageAsync_Test()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Jerry&#34;);&#10;    await client.ConnectAsync();&#10;    AVIMConversation conversation = client.GetConversationById(&#34;55117292e4b065f7ee9edd29&#34;);&#10;    await conversation.FetchAsync();&#10;    conversation.OnImageMessageReceived += (s, e) =&#62;&#10;    &#123;&#10;        //&#22270;&#20687;&#30340; url&#10;        string url = e.Url;&#10;        //&#22270;&#20687;&#30340;&#20803;&#25968;&#25454;&#10;        IDictionary&#60;string, object&#62; metaData = e.FileMetaData;&#10;        //&#22270;&#20687;&#30340;&#21457;&#36865;&#32773; ClientId&#10;        string  from= e.FromClientId;&#10;        //&#22270;&#20687;&#21457;&#36865;&#32773;&#20026;&#22270;&#20687;&#35774;&#23450;&#30340; Title&#10;        string title = e.Title;&#10;&#10;        //&#19968;&#20123;&#20854;&#20182;&#30340;&#23646;&#24615;&#37117;&#21487;&#20197;&#22312;&#36825;&#37324;&#33719;&#21462;&#10;    &#125;;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="音频消息">音频消息</h4><h5 id="发送音频消息">发送音频消息</h5><p>发送音频消息的基本流程就是：<code>读取音频文件（或者录制音频）</code>，<code>构建音频消息</code>，<code>消息发送</code>：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private async void SendAudioMessageAsync()&#10;&#123;&#10;    StorageFolder local = Windows.Storage.ApplicationData.Current.LocalFolder;&#10;    var AudioFile = await local.OpenStreamForReadAsync(recordAudioFileName);&#10;    AVIMAudioMessage audioMessage = new AVIMAudioMessage(recordAudioFileName, AudioFile);//&#21019;&#24314;&#38899;&#39057;&#28040;&#24687;&#10;&#10;    await conversation.SendAudioMessageAsync(audioMessage);&#10;    //&#36825;&#27573;&#20195;&#30721;&#36816;&#34892;&#20043;&#21069;&#65292;&#35831;&#30830;&#20445; `conversation` &#24050;&#32463;&#23454;&#20363;&#21270;&#10;&#125;&#10;``` &#10;&#10;&#19982;&#22270;&#20687;&#28040;&#24687;&#31867;&#20284;&#65292;&#38899;&#39057;&#28040;&#24687;&#20063;&#25903;&#25345;&#20174; URL &#26500;&#24314;&#65292;&#28982;&#21518;&#21457;&#36865;&#65306;&#10;&#10;```c#&#10;public async void SendAudioMessageAsync()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    //Tom &#30331;&#24405;&#10;    await client.ConnectAsync();&#10;    var conversation = await client.CreateConversationAsync(&#34;Jerry&#34;, &#34;&#29483;&#21644;&#32769;&#40736;&#34;);//&#21019;&#24314;&#23545;&#35805;&#10;&#10;    AVIMAudioMessage audioMessage = new AVIMAudioMessage(&#34;http://ac-lhzo7z96.clouddn.com/1427444393952&#34;);//&#20174;&#22806;&#37096;&#38142;&#25509;&#21019;&#24314;&#38899;&#39057;&#28040;&#24687;&#10;    await conversation.SendAudioMessageAsync(audioMessage);//&#21457;&#36865;&#32473; Jerry&#10;&#125;</span><br></pre></td></tr></table></figure>
<h5 id="接收音频消息">接收音频消息</h5><p>与接收图像消息一样，在 <code>AVIMConversation</code> 中有 <code>OnAudioMessageReceived</code> ，实例代码请参照图像消息接收。</p>
<h4 id="视频消息">视频消息</h4><h5 id="发送视频消息">发送视频消息</h5><p>与发送音频消息类似的流程类似，视频的来源可以是手机录制，可以是 Windows 系统中某一个具体的视频文件：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private async void SendVideoMessageAsync()&#10;&#123;&#10;    StorageFolder local = Windows.Storage.ApplicationData.Current.LocalFolder;&#10;&#10;    var VideoFile = await local.OpenStreamForReadAsync(recordVideoFileName);&#10;&#10;    AVIMVideoMessage videoMessage = new AVIMVideoMessage(recordVideoFileName, VideoFile);&#10;&#10;    await conversation.SendVideoMessageAsync(videoMessage);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>同样我们也支持从一个视频的 URL 创建视频消息，然后发送出去：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void SendVideoMessageAsync()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    await client.ConnectAsync();//Tom &#30331;&#24405;&#10;&#10;    var conversation = await client.CreateConversationAsync(&#34;Jerry&#34;, &#34;&#29483;&#21644;&#32769;&#40736;&#34;);//&#21019;&#24314;&#23545;&#35805;&#10;&#10;    AVIMVideoMessage videoMessage = new AVIMVideoMessage(&#34;http://ac-lhzo7z96.clouddn.com/1427267336319&#34;);//&#20174;&#22806;&#37096;&#38142;&#25509;&#21019;&#24314;&#35270;&#39057;&#28040;&#24687;&#10;    await conversation.SendVideoMessageAsync(videoMessage);//&#21457;&#36865;&#32473; Jerry&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注：这里说的 URL指的是视频文件自身的 URL，而不是视频网站上播放页的 URL。</strong></p>
<h5 id="接收视频消息">接收视频消息</h5><p>与接收图像消息一样，在 <code>AVIMConversation</code> 中有 <code>OnVideoMessageReceived</code> ，实例代码请参照图像消息接收。</p>
<h4 id="通用文件消息">通用文件消息</h4><p>Tom 要发送一份 .doc 文件给 Jerry，可以用下面这种方法：</p>
<h5 id="发送通用文件消息">发送通用文件消息</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void SendDocAsync()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    await client.ConnectAsync();//Tom &#30331;&#24405;&#10;&#10;    var conversation = await client.CreateConversationAsync(&#34;Jerry&#34;, &#34;&#29483;&#21644;&#32769;&#40736;&#34;);//&#21019;&#24314;&#23545;&#35805;&#10;    StorageFolder local = Windows.Storage.ApplicationData.Current.LocalFolder;&#10;    var docFile = await local.OpenStreamForReadAsync(&#34;leancloud.doc&#34;);//&#35835;&#21462;&#26412;&#22320;&#25991;&#20214;&#10;    var avfile = new AVFile(&#34;leancloud.doc&#34;, docFile);//&#26500;&#36896; AVFile&#10;    AVIMFileMessage fileMessage = new AVIMFileMessage(avfile);//&#26500;&#36896;&#25991;&#20214;&#28040;&#24687;&#10;    await conversation.SendFileMessageAsync(fileMessage);//&#21457;&#36865;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h5 id="接收通用文件消息">接收通用文件消息</h5><p>与接收图像消息一样，在 <code>AVIMConversation</code> 中有 <code>OnFileMessageReceived</code> ，实例代码请参照图像消息接收。</p>
<h4 id="地理位置消息">地理位置消息</h4><p>地理位置消息构建方式有 2 种：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//1.&#26681;&#25454;&#32428;&#24230;&#21644;&#32463;&#24230;&#26500;&#24314;&#10; AVIMLocationMessage locationMessage = new AVIMLocationMessage(Latitude, Longitude);&#10;//2.&#26681;&#25454; AVGeoPoint &#26500;&#24314;&#10;AVGeoPoint avGeoPoint = new AVGeoPoint(31.3853142377, 121.0553079844);&#10;AVIMLocationMessage locationMessage = new AVIMLocationMessage(avGeoPoint);</span><br></pre></td></tr></table></figure>
<h5 id="发送地理位置消息">发送地理位置消息</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void SendLocationAsync()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    await client.ConnectAsync();//Tom &#30331;&#24405;&#10;    var conversation = await client.CreateConversationAsync(&#34;Jerry&#34;, &#34;&#29483;&#21644;&#32769;&#40736;&#34;);//&#21019;&#24314;&#23545;&#35805;&#10;    &#10;    AVIMLocationMessage locationMessage = new AVIMLocationMessage(138.12454, 52.56461);//&#20197;&#32463;&#24230;&#21644;&#32428;&#24230;&#20026;&#21442;&#25968;&#26500;&#24314;&#19968;&#20010;&#22320;&#29702;&#20301;&#32622;&#28040;&#24687;&#65292;&#24403;&#28982;&#24320;&#21457;&#32773;&#26356;&#21487;&#20197;&#36890;&#36807;&#20855;&#20307;&#30340;&#35774;&#22791;&#30340; API &#21435;&#33719;&#21462;&#35774;&#22791;&#30340;&#22320;&#29702;&#20301;&#32622;&#65292;&#35814;&#32454;&#30340;&#38656;&#35201;&#26597;&#35810;&#20855;&#20307;&#30340;&#35774;&#22791;&#30340; API&#10;    await conversation.SendLocationMessageAsync(locationMessage);&#10;&#125;</span><br></pre></td></tr></table></figure>
<h5 id="接收地理位置消息">接收地理位置消息</h5><p>与接收图像消息一样，在 <code>AVIMConversation</code> 中有 <code>OnLocationMessageReceived</code> ，实例代码请参照图像消息接收。</p>
<h3 id="消息的发送策略">消息的发送策略</h3><p>开发者在阅读完前面的富媒体消息并且运行过实例代码之后，在 Visual Studio 中使用 F12 快捷键查看各个消息类型的定义，应该可以看见图像、音频、视频在类的继承关系上是继承自 <code>AVIMFileMessageBase</code>，所有继承自 <code>AVIMFileMessageBase</code> 的消息类型的发送策略如下：</p>
<ul>
<li><p>如果文件是从客户端 API 读取的数据流 (Stream) </p>
<ul>
<li>第一步：从本地构造 AVFile</li>
<li>第二步：调用 AVFile 的上传的方法上传到服务器，并获取文件的元信息（MetaData）</li>
<li>第三步：把 AVFile 的 objectId 以及 URL ，以及文件的元信息封装在消息体内</li>
<li>第四步：发送消息</li>
</ul>
</li>
<li><p>如果文件是外部链接的 URL</p>
<ul>
<li>第一步：直接将 URL 封装在消息体内，不获取元信息，不包含 objectId</li>
<li>第二步：发送消息</li>
</ul>
</li>
</ul>
<p>以上逻辑对所有继承 <code>AVIMFileMessageBase</code> 的消息类型有效，目前 SDK 内置的继承自 <code>AVIMFileMessageBase</code> 包含以下几种：</p>
<ul>
<li>AVIMImageMessage</li>
<li>AVIMAudioMessage</li>
<li>AVIMVideoMessage</li>
<li>AVIMFileMessage</li>
</ul>
<h3 id="消息的接收策略">消息的接收策略</h3><p>消息接收有 <strong>2</strong> 个层级：</p>
<ul>
<li><p>第一个是在 <code>AVIMClient</code> 上，它是为了帮助开发者实现被动接收消息，尤其是在本地并没有加载任何对话的时候，类似于刚登录，本地并没有任何 <code>AVIMConversation</code> 的时候，如果某个对话产生新的消息，当前 <code>AVIMClient.OnMessageReceived</code> 负责接收这类消息，但是它并没有针对消息的类型做区分。</p>
</li>
<li><p>第二个是在 <code>AVIMConversation</code> 上，负责接收对话的全部信息，并且针对不同的消息类型有不同的事件类型做响应。</p>
</li>
</ul>
<p>以上 <strong>2</strong> 个层级的消息接收策略可以用下表进行描述，假如正在接收的是 <code>AVIMTextMessage</code>：</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">AVIMClient 接收端</th>
<th style="text-align:left">条件①</th>
<th style="text-align:left">条件②</th>
<th style="text-align:left">条件③</th>
<th style="text-align:left">条件④</th>
<th>条件⑤ </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">AVIMClient.OnMessageReceived</td>
<td style="text-align:left">×</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
</tr>
<tr>
<td style="text-align:left">AVIMConversation.OnMessageReceived</td>
<td style="text-align:left">×</td>
<td style="text-align:left">×</td>
<td style="text-align:left">√</td>
<td style="text-align:left">×</td>
<td style="text-align:left">× </td>
</tr>
<tr>
<td style="text-align:left">AVIMConversation.OnTypedMessageReceived</td>
<td style="text-align:left">×</td>
<td style="text-align:left">×</td>
<td style="text-align:left">×</td>
<td style="text-align:left">√</td>
<td style="text-align:left">× </td>
</tr>
<tr>
<td style="text-align:left">AVIMConversation.OnTextMessageReceived</td>
<td style="text-align:left">×</td>
<td style="text-align:left">×</td>
<td style="text-align:left">×</td>
<td style="text-align:left">×</td>
<td style="text-align:left">√ </td>
</tr>
</tbody>
</table>
<p>对应条件如下：</p>
<ul>
<li><p>条件①：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVIMClient.Status != Online&#10;``` &#10;* &#26465;&#20214;&#9313;&#65306;&#10;```c#&#10;AVIMClient.Status == Online &#38;&#38; AVIMClient.OnMessageReceived != null</span><br></pre></td></tr></table></figure>
</li>
<li><p>条件③：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVIMClient.Status == Online &#10;&#38;&#38; AVIMClient.OnMessageReceived != null &#10;&#38;&#38; AVIMConversation.OnMessageReceived != null</span><br></pre></td></tr></table></figure>
</li>
<li><p>条件④：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVIMClient.Status == Online &#10;&#38;&#38; AVIMClient.OnMessageReceived != null &#10;&#38;&#38; AVIMConversation.OnMessageReceived != null&#10;&#38;&#38; AVIMConversation.OnTypedMessageReceived != null&#10;&#38;&#38; AVIMConversation.OnTextMessageReceived == null</span><br></pre></td></tr></table></figure>
</li>
<li><p>条件⑤：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVIMClient.Status == Online &#10;&#38;&#38; AVIMClient.OnMessageReceived != null &#10;&#38;&#38; AVIMConversation.OnMessageReceived != null&#10;&#38;&#38; AVIMConversation.OnTypedMessageReceived != null&#10;&#38;&#38; AVIMConversation.OnTextMessageReceived != null</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在 AVIMConversation 内，接收消息的顺序是按照 </p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">OnTextMessageReceived</span> &gt; OnTypedMessageReceived &gt; OnMessageReceived</span><br></pre></td></tr></table></figure>
<p>这是为了方便开发者在接收消息的时候有一个分层操作的空间，这一特性也适用于其他富媒体消息。</p>
<h3 id="消息类详解">消息类详解</h3><p><img src="http://ac-lhzo7z96.clouddn.com/1427252943504" alt="消息的类图"></p>
<ul>
<li><code>AVIMMessage</code> 所有消息的基类，一级抽象类；</li>
<li><code>AVIMTypedMessage</code> 富媒体消息的基类，二级抽象类；</li>
<li><code>AVIMFileMessageBase</code> 所有包含了文件内容的消息的基类，三级抽象类</li>
<li><code>AVIMTextMessage</code> 文本消息，三级实例类；</li>
<li><code>AVIMLocationMessage</code> 地理位置消息，三级实例类</li>
<li><code>AVIMImageMessage</code> 图像消息，四级实例类</li>
<li><code>AVIMAudioMessage</code> 音频消息，四级实例类</li>
<li><code>AVIMVideoMessage</code> 视频消息，四级实例类</li>
<li><code>AVIMFileMessage</code> 通用文件消息类，四级实例类</li>
</ul>
<p>结合图例，实时通信 SDK 在封装的时候，做了明确的分层，开发者需要根据自己的需求去使用。</p>
<h3 id="消息的自定义属性">消息的自定义属性</h3><p>有些场景下需要开发者在发送消息的时候附带一下自己业务逻辑需求的自定义属性，比如消息发送的设备名称，或者图像消息的拍摄地点，或者视频消息的来源等等，如果业务需要，开发者都可以通过 <code>AVIMMessage.Attributes</code> 实现这一需求。</p>
<p>场景1：在发送照片给自己朋友的时候，想告诉朋友这张照片是在旧金山拍摄的，如下代码可以实现这个需求：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVIMImageMessage imgMessage = new AVIMImageMessage(photo.Name, photo.GetImage());//&#26500;&#36896; AVIMImageMessage&#10;imgMessage.Attributes = new Dictionary&#60;string, object&#62;() &#10;&#123; &#10;    &#123;&#34;location&#34;,&#34;San Francisco&#34;&#125;&#10;&#125;;&#10;imgMessage.Title = &#34;&#21457;&#33258;&#25105;&#30340;WP&#34;;&#10;await conversation.SendImageMessageAsync(imgMessage);</span><br></pre></td></tr></table></figure>
<p>而接收方在 <code>OnMessageReceived</code> 的时候是可以读取到这一属性的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVIMClient client = new AVIMClient(&#34;friend&#34;);&#10;await client.ConnectAsync();&#10;client.OnMessageReceieved += (s, e) =&#62;&#10;&#123;&#10;    if (e.Message is AVIMImageMessage)&#10;    &#123;&#10;        AVIMImageMessage imgMessage = (AVIMImageMessage)e.Message;&#10;        string url = imgMessage.Url;&#10;        string location = imgMessage.Attributes[&#34;location&#34;].ToString();//&#35835;&#21462;&#30340;&#32467;&#26524;&#23601;&#26159; San Francisco&#10;    &#125;&#10;&#125;;</span><br></pre></td></tr></table></figure>
<p>所有消息都支持这一属性。</p>
<h2 id="对话的管理">对话的管理</h2><p>以上 三个章节基本演示了实时聊天 SDK 的核心概念——AVIMConversation ，LeanCloud 将单聊和群聊（包括聊天室）的消息发送和接收都依托于 <code>AVIMConversation</code>这个统一的概念进行操作。</p>
<p>所以，开发者需要强化理解的一个概念就是：<strong>SDK 层面是不再区分单聊以及群聊。</strong></p>
<h3 id="对话的成员管理">对话的成员管理</h3><p>对话的管理包括「成员管理」，「属性管理」两个方面。</p>
<p>成员管理，是对话中成员的一个实时生效的操作，一旦操作成功不可逆。</p>
<h4 id="准备工作">准备工作</h4><p>在进行下面几个章节之前，请复制如下代码到 IDE 并且执行，后面的文档中的示例代码是基于以下代码进行的，这是一项<strong>必须的</strong>工作： </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/// &#60;summary&#62;&#10;/// &#36825;&#27573;&#20195;&#30721;&#23454;&#29616;&#30340;&#21151;&#33021;&#23601;&#26159; Jerry &#21019;&#24314;&#20102;&#19968;&#20010; &#21253;&#21547; Bob&#65292;Harry&#65292;William &#30340;&#23545;&#35805;&#12290;&#10;/// &#60;/summary&#62;&#10;/// &#60;returns&#62;&#60;/returns&#62;&#10;public async void JerryCreateConversation()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Jerry&#34;);&#10;    await client.ConnectAsync();//Jerry &#30331;&#24405;&#10;&#10;    IList&#60;string&#62; friends = new List&#60;string&#62;();&#10;    friends.Add(&#34;Bob&#34;);&#10;    friends.Add(&#34;Harry&#34;);&#10;    friends.Add(&#34;William&#34;);&#10;    //&#28155;&#21152;&#22909;&#26379;&#21451;&#10;&#10;    await client.CreateConversationAsync(friends);//&#36820;&#22238; ConversationId&#10;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自身主动加入">自身主动加入</h4><p>Tom 想主动加入 Jerry、Bob、Harry 和 William 的对话（由上一节 JerryCreateConversation() 所创建）中，以下代码将帮助他实现这个功能：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void InitiativeJoinAsync()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    await client.ConnectAsync();&#10;&#10;    string conversationId = &#34;551260efe4b01608686c3e0f&#34;;//&#33719;&#21462; Jerry &#21019;&#24314;&#30340;&#23545;&#35805;&#30340; Id&#65292;&#36825;&#37324;&#26159;&#30452;&#25509;&#20174;&#25511;&#21046;&#21488;&#25335;&#36125;&#20102;&#19978;&#19968;&#33410;&#20934;&#22791;&#24037;&#20316;&#20013; JerryCreateConversation &#25104;&#21151;&#20043;&#21518;&#30340; objectId&#10;    AVIMConversation conversation = client.GetConversationById(conversationId);//Tom &#33719;&#21462;&#21040;&#36825;&#20010;&#23545;&#35805;&#30340;&#23545;&#35937;&#10;    await conversation.JoinAsync();//Tom &#20027;&#21160;&#21152;&#20837;&#21040;&#23545;&#35805;&#20013;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>该群的其他成员（比如 Bob）会根据自身客户端的状态不同会出现以下 2 种情况:</p>
<ul>
<li>如果 Bob 仅仅是登录了应用，并没有加载具体的对话到本地，他只会收到 <code>AVIMClient.OnConversationMembersChanged</code> 的响应的相关操作，代码如下:</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void BobOnTomJoined_S1()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Bob&#34;);&#10;    await client.ConnectAsync();&#10;&#10;    client.OnConversationMembersChanged += (s, e) =&#62;&#10;    &#123;&#10;        switch (e.AffectedType)&#10;        &#123;&#10;            case AVIMConversationEventType.MembersJoined:&#10;                &#123;&#10;                    IList&#60;string&#62; joinedMemberClientIds = e.AffectedMembers;//&#36825;&#37324;&#23601;&#26159;&#26412;&#27425;&#21152;&#20837;&#30340; ClientIds&#10;                    string clientId = joinedMemberClientIds.FirstOrDefault();//&#22240;&#20026;&#25105;&#20204;&#24050;&#30693;&#26412;&#27425;&#25805;&#20316;&#21482;&#26377; Tom &#19968;&#20010;&#20154;&#21152;&#20837;&#20102;&#23545;&#35805;&#65292;&#25152;&#20197;&#36825;&#26679;&#23601;&#21487;&#20197;&#30452;&#25509;&#35835;&#21462;&#21040; Tom &#30340; clientId&#10;                    //&#24320;&#21457;&#32773;&#21487;&#20197;&#22312;&#36825;&#37324;&#28155;&#21152;&#33258;&#24049;&#30340;&#19994;&#21153;&#36923;&#36753;&#10;                &#125;&#10;                break;&#10;        &#125;&#10;    &#125;;&#10;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果 Bob 不但登录了，还在客户端加载了当前这个对话，那么他不但会收到 <code>AVIMClient.OnConversationMembersChanged</code> 的响应的相关操作，也会收到 <code>AVIMConversation.OnMembersJoined</code> 的响应的相关操作，代码如下：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void BobOnTomJoined_S2()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Bob&#34;);&#10;    await client.ConnectAsync();&#10;&#10;    client.OnConversationMembersChanged += (s, e) =&#62;&#10;    &#123;&#10;        switch (e.AffectedType)&#10;        &#123;&#10;            case AVIMConversationEventType.MembersJoined:&#10;                &#123;&#10;                    IList&#60;string&#62; joinedMemberClientIds = e.AffectedMembers;//&#36825;&#37324;&#23601;&#26159;&#26412;&#27425;&#21152;&#20837;&#30340; ClientIds&#10;                    string clientId = joinedMemberClientIds.FirstOrDefault();//&#22240;&#20026;&#25105;&#20204;&#24050;&#30693;&#26412;&#27425;&#25805;&#20316;&#21482;&#26377; Tom &#19968;&#20010;&#20154;&#21152;&#20837;&#20102;&#23545;&#35805;&#65292;&#25152;&#20197;&#36825;&#26679;&#23601;&#21487;&#20197;&#30452;&#25509;&#35835;&#21462;&#21040; Tom &#30340; clientId&#10;                    //&#24320;&#21457;&#32773;&#21487;&#20197;&#22312;&#36825;&#37324;&#28155;&#21152;&#33258;&#24049;&#30340;&#19994;&#21153;&#36923;&#36753;&#10;                &#125;&#10;                break;&#10;        &#125;&#10;    &#125;;&#10;&#10;    string conversationId = &#34;551260efe4b01608686c3e0f&#34;;&#10;&#10;    AVIMConversation conversation = client.GetConversationById(conversationId);//Bob &#33719;&#21462;&#21040;&#36825;&#20010;&#23545;&#35805;&#30340;&#23545;&#35937;&#10;&#10;    conversation.OnMembersJoined += (s, e) =&#62;&#10;    &#123;&#10;        IList&#60;string&#62; joinedMemberClientIds = e.AffectedMembers;//&#36825;&#37324;&#23601;&#26159;&#26412;&#27425;&#21152;&#20837;&#30340; ClientIds&#10;        string clientId = joinedMemberClientIds.FirstOrDefault();//&#22240;&#20026;&#25105;&#20204;&#24050;&#30693;&#26412;&#27425;&#25805;&#20316;&#21482;&#26377; Tom &#19968;&#20010;&#20154;&#21152;&#20837;&#20102;&#23545;&#35805;&#65292;&#25152;&#20197;&#36825;&#26679;&#23601;&#21487;&#20197;&#30452;&#25509;&#35835;&#21462;&#21040; Tom &#30340; clientId&#10;    &#125;;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="添加其他成员">添加其他成员</h4><p>Jerry 想再把 Mary 加入到对话中，需要如下代码帮助他实现这个功能：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void InviteMaryAsync()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Jerry&#34;);&#10;    await client.ConnectAsync();&#10;&#10;    string conversationId = &#34;551260efe4b01608686c3e0f&#34;;//&#23545;&#35805;&#30340; Id&#10;    AVIMConversation conversation = client.GetConversationById(conversationId);//Jerry &#33719;&#21462;&#21040;&#36825;&#20010;&#23545;&#35805;&#30340;&#23545;&#35937;&#10;    await conversation.AddMembersAsync(&#34;Mary&#34;);//Jerry &#25226; Mary &#21152;&#20837;&#21040;&#23545;&#35805;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>该对话的其他成员（例如 Harry）也会受到该项操作的影响，收到事件被响应的通知，类似于第一小节<a href="#自身主动加入">自身主动加入</a>中<strong>Tom 加入对话之后，Bob 受到的影响。</strong></p>
<h4 id="自身退出对话">自身退出对话</h4><p>这里一定要区分<strong>自身退出对话</strong>的主动性，它与<strong>自身被动被剔除</strong>（下一小节）在逻辑上完全是不一样的。</p>
<p>Tom 主动从对话中退出，他需要如下代码实现需求：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void InitiativeLeftAsync()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    await client.ConnectAsync();&#10;&#10;    string conversationId = &#34;551260efe4b01608686c3e0f&#34;;//&#33719;&#21462; Jerry &#21019;&#24314;&#30340;&#23545;&#35805;&#30340; Id&#10;    AVIMConversation conversation = client.GetConversationById(conversationId);//Tom &#33719;&#21462;&#21040;&#36825;&#20010;&#23545;&#35805;&#30340;&#23545;&#35937;&#10;    await conversation.LeftAsync();//Tom &#20027;&#21160;&#20174;&#23545;&#35805;&#20013;&#36864;&#20986;&#10;&#125;&#10;``` &#10;&#10;#### &#21076;&#38500;&#20854;&#20182;&#25104;&#21592;&#10;&#10; Harry &#34987;  William &#20174;&#23545;&#35805;&#20013;&#21024;&#38500;&#12290;&#10;**&#27880;&#65306;&#20851;&#20110; William &#22914;&#20309;&#33719;&#24471;&#26435;&#38480;&#22312;&#21518;&#38754;&#30340;`&#31614;&#21517;&#21644;&#23433;&#20840;`&#19968;&#31456;&#33410;&#20250;&#20570;&#35814;&#32454;&#38416;&#36848;&#65292;&#27492;&#22788;&#19981;&#23452;&#25193;&#22823;&#35805;&#39064;&#33539;&#22260;&#65289;**&#10;&#10;&#20197;&#19979;&#20195;&#30721;&#21487;&#20197;&#24110;&#21161; William &#23454;&#29616;&#36825;&#19968;&#21151;&#33021;&#65306;&#10;&#10;```c#&#10;public async void WilliamKickHarryOutAsync()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;William&#34;);&#10;    await client.ConnectAsync();&#10;&#10;    string conversationId = &#34;551260efe4b01608686c3e0f&#34;;//&#23545;&#35805;&#30340; Id&#10;    AVIMConversation conversation = client.GetConversationById(conversationId);//William &#33719;&#21462;&#21040;&#36825;&#20010;&#23545;&#35805;&#30340;&#23545;&#35937;&#10;    await conversation.RemoveMembersAsync(&#34;Harry&#34;);//William &#25226; Harry &#20174;&#23545;&#35805;&#20013;&#21076;&#38500;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>以上的描述可以用几张表格来解释：</p>
<p>1.假如对话中已经有了 A，C</p>
<table>
<thead>
<tr>
<th>B 的操作</th>
<th>对 B 的影响</th>
<th>对 C 的影响</th>
</tr>
</thead>
<tbody>
<tr>
<td>B 加入</td>
<td><code>OnConversationMembersChanged &amp;&amp; OnJoined</code></td>
<td><code>OnConversationMembersChanged &amp;&amp; OnMembersJoined</code></td>
</tr>
<tr>
<td>B 再离开</td>
<td><code>OnConversationMembersChanged &amp;&amp; OnLeft</code></td>
<td><code>OnConversationMembersChanged &amp;&amp; OnMembersLeft</code></td>
</tr>
</tbody>
</table>
<p>2.假如对话中已经有了 A，C</p>
<table>
<thead>
<tr>
<th>A 对 B 的操作</th>
<th>对 B 的影响</th>
<th>对 C 的影响</th>
</tr>
</thead>
<tbody>
<tr>
<td>A 添加 B</td>
<td><code>OnConversationMembersChanged &amp;&amp; OnInvited</code></td>
<td><code>OnConversationMembersChanged &amp;&amp; OnMembersJoined</code></td>
</tr>
<tr>
<td>A 再剔除 B</td>
<td><code>OnConversationMembersChanged &amp;&amp; OnKicked</code></td>
<td><code>OnConversationMembersChanged &amp;&amp; OnMembersLeft</code></td>
</tr>
</tbody>
</table>
<h4 id="查询成员数量">查询成员数量</h4><p><code>AVIMConversation.CountMembersAsync</code> 这个方法是返回实时的数据：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void CountMembers_SampleCode()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    await client.ConnectAsync();//Tom &#30331;&#24405;&#23458;&#25143;&#31471;&#10;&#10;    AVIMConversation conversation = (await client.GetQuery().FindAsync()).FirstOrDefault();&#10;    int membersCount = await conversation.CountMembersAsync();&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="对话的属性管理">对话的属性管理</h3><p>对话（AVIMConversation）与控制台中 <code>_Conversation</code> 表是一一对应的，默认提供的属性对应的关系如下：</p>
<table>
<thead>
<tr>
<th>AVIMConversation 属性名</th>
<th>_Conversation 字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>AVIMConversation.ConversationId</code></td>
<td><code>_Conversation.objectId</code></td>
<td>全局唯一的 Id</td>
</tr>
<tr>
<td><code>AVIMConversation.Name</code></td>
<td><code>_Conversation.name</code></td>
<td>成员共享的统一的名字</td>
</tr>
<tr>
<td><code>AVIMConversation.MemberIds</code></td>
<td><code>_Conversation.m</code></td>
<td>成员列表</td>
</tr>
<tr>
<td><code>AVIMConversation.MuteMemberIds</code></td>
<td><code>_Conversation.mu</code></td>
<td>静音成员列表</td>
</tr>
<tr>
<td><code>AVIMConversation.Creator</code></td>
<td><code>_Conversation.c</code></td>
<td>对话创建者</td>
</tr>
<tr>
<td><code>AVIMConversation.LastMessageAt</code></td>
<td><code>_Conversation.lm</code></td>
<td>对话最后一条消息发送的时间</td>
</tr>
<tr>
<td><code>AVIMConversation.Attributes</code></td>
<td><code>_Conversation.attr</code></td>
<td>自定义属性</td>
</tr>
<tr>
<td><code>AVIMConversation.IsTransient</code></td>
<td><code>_Conversation.tr</code></td>
<td>是否为聊天室（暂态对话）</td>
</tr>
</tbody>
</table>
<h4 id="名称">名称</h4><p>这个属性是全员共享的一个属性，他可以在创建时指定，也可以在日后的维护中被修改。</p>
<p>Tom 想建立一个名字叫「喵星人」 对话并且邀请了好友 Black 加入对话，需要写的代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void CreateConversationAsync()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    string anotherCat = &#34;Black&#34;;&#10;    await client.ConnectAsync();&#10;&#10;    AVIMConversation conversation = await client.CreateConversationAsync(anotherCat, &#34;&#21941;&#26143;&#20154;&#34;);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>Black 发现对话名字不够酷，他想修改成「聪明的喵星人」 ，他需要如下代码：   </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void UpdateConversationAsync()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Black&#34;);&#10;    await client.ConnectAsync();//Balck &#30331;&#24405;&#10;&#10;    AVIMConversation conversation = client.GetConversationById(&#34;55117292e4b065f7ee9edd29&#34;);//&#33719;&#21462; Tom &#21019;&#24314;&#30340;&#23545;&#35805;&#10;&#10;    conversation.Name = &#34;&#32874;&#26126;&#30340;&#21941;&#26143;&#20154;&#34;;//&#20462;&#25913;&#21517;&#31216;&#10;&#10;    await conversation.SaveAsync();//&#20445;&#23384;&#21040;&#26381;&#21153;&#31471;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="成员">成员</h4><p><code>AVIMConversation.MemberIds</code> ：该属性表示当前对话中所包含的成员的 <code>clientId</code> ，<br>这个属性<strong>强烈建议开发者切勿在控制台中随意修改</strong>，所有关于成员的操作请参照上一章节中的 <code>成员管理</code> 来进行。</p>
<h4 id="静音成员">静音成员</h4><p><code>AVIMConversation.MuteMemberIds</code> ：该属性表示当前对话中所进行了静音操作成员的 <code>clientId</code> ，<br>假如某一个用户不想再收到某对话的消息，又不想直接退出对话，可以使用静音操作。</p>
<p>比如 Tom 工作繁忙，对某个对话设置了静音：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void MuteConversationAsync()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    await client.ConnectAsync();//Tom &#30331;&#24405;&#10;&#10;    string conversationId = &#34;551260efe4b01608686c3e0f&#34;;//&#23545;&#35805;&#30340; Id&#10;    AVIMConversation conversation = client.GetConversationById(conversationId);//Tom &#33719;&#21462;&#21040;&#36825;&#20010;&#23545;&#35805;&#30340;&#23545;&#35937;&#10;    await conversation.MuteAsync();//Tom &#35774;&#32622;&#38745;&#38899;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>设置静音之后，针对 iOS 以及 Windows Phone 用户就不会收到推送消息</strong></p>
<p>此操作修改的是服务端 <code>_Conversation</code> 里面的 <code>mu</code> 属性。<br>与之对应的就是 <code>UnmuteAsync</code>操作，就是取消静音，示例代码参照静音操作。<br><strong>强烈建议开发者切勿在控制台中随意修改</strong>。</p>
<h4 id="创建者">创建者</h4><p><code>AVIMConversation.Creator</code> 对话的创建者可以帮助实现类似于 QQ 群中区别「管理员」和「群创建者」的功能，它的值是对话创建者的 <code>clientId</code>。</p>
<p>案例：QQ 群的「创建者」是固定不变的，它的图标颜色与「管理员」的图标颜色都不一样。<br>所以根据对话中成员的 <code>clientId</code> 是否与 <code>AVIMConversation.Creator</code> 一致就可以判断出他是不是群的创建者。</p>
<h4 id="自定义属性">自定义属性</h4><p>此属性是为了帮助开发者给对话添加自定义属性。开发者可以随意存储自己的键值对，以帮助开发者实现自己的业务逻辑需求。</p>
<p>典型的场景是，我想对某个对话设置 tag 是 private，表示我要标记这个对话是私有的：</p>
<p>如下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void CreateConversationWithCustomAttributesAsync()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    await client.ConnectAsync();&#10;    IDictionary&#60;string, object&#62; attr = new Dictionary&#60;string, object&#62;();&#10;    attr.Add(&#34;tag&#34;, &#34;private&#34;);&#10;    AVIMConversation conversation = await client.CreateConversationAsync(&#34;Jerry&#34;, &#34;&#29483;&#21644;&#32769;&#40736;&#34;, attr);//&#21019;&#24314;&#23545;&#35805;&#30340;&#26102;&#20505;&#20256;&#20837;&#21363;&#21487;&#12290;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：AVIMConversation.Attributes 在 SDK 级别是对所有成员可见的，如果要控制所谓的可见性，开发者需要自己维护这一属性的读取权限</strong></p>
<p><code>AVIMConversation.Attributes</code> 在<code>对话查询</code>一节还有更多的用法。</p>
<h2 id="对话的查询">对话的查询</h2><h3 id="基础查询">基础查询</h3><p>假如已知某一对话的 <code>Id</code>，可以使用它来查询该对话的详细信息<br>代码实例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void QueryByIdAsync()&#10;&#123;&#10;   AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;   await client.ConnectAsync();//Tom &#30331;&#24405;&#23458;&#25143;&#31471;&#10;   AVIMConversation conversation = await client.GetQuery().GetAsync(&#34;551260efe4b01608686c3e0f&#34;);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意这个方法和  AVIMClient.GetConversationById 本质上是不一样的，AVIMClient.GetConversationById 可以理解为本地构造一个 AVIMConversation ，但是它除了 Id 别的属性都为空，而 GetAsync 是直接从服务端拉取数据，更为可靠，但是它是异步的。</strong></p>
<h3 id="条件查询">条件查询</h3><p>条件查询包含分类有<code>比较查询</code>,<code>匹配查询</code></p>
<h4 id="比较查询">比较查询</h4><p>比较查询在一般的理解上都包含以下几种：</p>
<table>
<thead>
<tr>
<th>逻辑操作</th>
<th>AVIMConversationQuery 对应的方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>等于</td>
<td><code>WhereEqualTo</code></td>
</tr>
<tr>
<td>不等于</td>
<td><code>WhereNotEqualTo</code> </td>
</tr>
<tr>
<td>大于</td>
<td><code>WhereGreaterThan</code></td>
</tr>
<tr>
<td>大于等于</td>
<td><code>WhereGreaterThanOrEqualTo</code> </td>
</tr>
<tr>
<td>小于</td>
<td><code>WhereLessThan</code></td>
</tr>
<tr>
<td>小于等于</td>
<td><code>WhereLessThanOrEqualTo</code></td>
</tr>
</tbody>
</table>
<p>比较查询最常用的是 <code>WhereEqualTo</code>：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">WhereEqualTo_SampleCode</span>(<span class="params"></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    AVIMClient client = <span class="keyword">new</span> AVIMClient(<span class="string">"Tom"</span>);</span><br><span class="line">    <span class="keyword">await</span> client.ConnectAsync();<span class="comment">//Tom 登录客户端</span></span><br><span class="line">    AVIMConversationQuery query = client.GetQuery().WhereEqualTo(<span class="string">"attr.topic"</span>, <span class="string">"movie"</span>);<span class="comment">//构建 topic 是 movie 的查询</span></span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">await</span> query.FindAsync();<span class="comment">//执行查询</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>目前条件查询只针对  <code>AVIMConversation</code> 的 <code>Attributes</code> 属性进行的，也就是针对 <code>_Conversation</code>  表中的 <code>attr</code> 字段进行的 <code>AVQuery</code> 查询。</p>
<p>实际上为了方便开发者自动为了自定义属性的 key 值增加 <code>attr.</code> 的前缀，SDK 特地添加了一个针对 <code>string</code> 类型的<a href="https://msdn.microsoft.com/zh-cn/library/bb383977.aspx" target="_blank" rel="external">拓展方法</a></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/// &#60;summary&#62;&#10;/// &#20026;&#32842;&#22825;&#30340;&#33258;&#23450;&#20041;&#23646;&#24615;&#26597;&#35810;&#33258;&#21160;&#28155;&#21152; &#34;attr.&#34; &#30340;&#21069;&#32512;&#10;/// &#60;/summary&#62;&#10;/// &#60;param name=&#34;key&#34;&#62;&#23646;&#24615; key &#20540;&#65292;&#20363;&#22914; type &#60;/param&#62;&#10;/// &#60;returns&#62;&#28155;&#21152;&#21069;&#32512;&#30340;&#20540;&#65292;&#20363;&#22914;&#65292;attr.type &#60;/returns&#62;&#10;public static string InsertAttrPrefix(this string key)&#10;&#123;&#10;    return key.Insert(0, &#34;attr.&#34;);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>导入 SDK 之后在 Visual Studio 里面使用 <code>string</code> 类型的时候可以智能感应提示该方法。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVIMConversationQuery query = client.GetQuery().WhereEqualTo(&#34;topic&#34;.InsertAttrPrefix(), &#34;movie&#34;);//&#36825;&#26679;&#23601;&#21487;&#20197;&#23454;&#29616;&#33258;&#21160;&#20026; `topic` &#28155;&#21152; `attr.` &#21069;&#32512;&#30340;&#25928;&#26524;&#30340;&#25928;&#26524;&#12290;</span><br></pre></td></tr></table></figure>
<p>与 <code>WhereEqualTo</code> 相对的就是 <code>WhereNotEqualTo</code> ，以下代码将查询到类型不是私有的对话：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void WhereNotEqualTo_SampleCode()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    await client.ConnectAsync();//Tom &#30331;&#24405;&#23458;&#25143;&#31471;&#10;    AVIMConversationQuery query = client.GetQuery().WhereNotEqualTo(&#34;attr.type&#34;, &#34;private&#34;);//&#26500;&#24314; type &#19981;&#31561;&#20110; movie &#30340;&#26597;&#35810;&#10;    var result = await query.FindAsync();//&#25191;&#34892;&#26597;&#35810;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于可以比较大小的整型，浮点等常用类型，可以参照以下示例代码进行拓展：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void WhereGreaterThan_SampleCode()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    await client.ConnectAsync();//Tom &#30331;&#24405;&#23458;&#25143;&#31471;&#10;    AVIMConversationQuery query = client.GetQuery().WhereGreaterThan(&#34;attr.age&#34;, 18);//&#26500;&#24314; &#24180;&#40836;&#22823;&#20110; 18 &#30340;&#26597;&#35810;&#10;    var result = await query.FindAsync();//&#25191;&#34892;&#26597;&#35810;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="正则匹配查询">正则匹配查询</h4><p>匹配查询指的是在 <code>AVIMConversationQuery</code> 中以 <code>WhereMatches</code> 为前缀的方法。</p>
<p>Match 类的方法最大的便捷之处就是使用了正则表达式匹配，这样使得，客户端在构建基于正则表达式的查询的时候可以利用 .NET 里面诸多已经熟悉了的概念和接口。</p>
<p>比如要查询所有 <code>tag</code> 是中文的对话可以如下进行：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void WhereMatchs_SampleCode()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    await client.ConnectAsync();//Tom &#30331;&#24405;&#23458;&#25143;&#31471;&#10;    AVIMConversationQuery query = client.GetQuery().WhereMatches(&#34;attr.tag&#34;, &#34;[\u4e00-\u9fa5]&#34;);//&#26597;&#35810; tag &#26159;&#20013;&#25991;&#30340;&#23545;&#35805;&#10;    var result = await query.FindAsync();//&#25191;&#34892;&#26597;&#35810;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="包含查询">包含查询</h4><p>包含查询指的是 方法名字包含 <code>Contains</code> 单词的方法，例如查询关键字包含「教育」的对话：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void WhereContains_SampleCode()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    await client.ConnectAsync();//Tom &#30331;&#24405;&#23458;&#25143;&#31471;&#10;    AVIMConversationQuery query = client.GetQuery().WhereContains(&#34;attr.keywords&#34;, &#34;&#25945;&#32946;&#34;);//&#26597;&#35810; keywords &#21253;&#21547;&#25945;&#32946;&#10;    var result = await query.FindAsync();//&#25191;&#34892;&#26597;&#35810;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>另外，包含查询还能检索与成员相关的对话数据。<br>以下代码将帮助 <code>Tom</code> 查找出 <code>Jerry</code> 以及 <code>Bob</code> 都存在的对话：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void QueryMembers_SampleCode()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;&#10;    IList&#60;string&#62; clientIds = new List&#60;string&#62;();&#10;    clientIds.Add(&#34;Bob&#34;);&#10;    clientIds.Add(&#34;Jerry&#34;);&#10;&#10;    AVIMConversationQuery query = client.GetQuery().WhereContainedIn&#60;string&#62;(&#34;m&#34;, clientIds);//&#26597;&#35810;&#23545;&#35805;&#25104;&#21592; Bob &#20197;&#21450; Jerry &#30340;&#23545;&#35805;&#10;    var result = await query.FindAsync();//&#25191;&#34892;&#26597;&#35810;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="组合查询">组合查询</h3><p>组合查询的概念就是把诸多查询条件合并成一个查询，再交给 SDK 去服务端进行查询。</p>
<p>LeanCloud .NET SDK 的风格上一直保持以链式的方式提供给开发者去组合符合自己业务逻辑的查询，例如，要查询年龄小于18岁，并且关键字包含「教育」的对话：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void CombinationQuery_SampleCode()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    await client.ConnectAsync();//Tom &#30331;&#24405;&#23458;&#25143;&#31471;&#10;    AVIMConversationQuery query = client.GetQuery().WhereContains(&#34;attr.keywords&#34;, &#34;&#25945;&#32946;&#34;).WhereLessThan(&#34;age&#34;, 18);//&#26597;&#35810; keywords &#21253;&#21547;&#25945;&#24182;&#19988;&#24180;&#40836;&#23567;&#20110;18&#30340;&#23545;&#35805;&#10;    var result = await query.FindAsync();//&#25191;&#34892;&#26597;&#35810;&#10;&#125;&#10;``` &#10;&#10;&#21482;&#35201;&#26597;&#35810;&#26500;&#24314;&#24471;&#21512;&#29702;&#65292;&#24320;&#21457;&#32773;&#23436;&#20840;&#19981;&#38656;&#35201;&#25285;&#24515;&#32452;&#21512;&#26597;&#35810;&#30340;&#24615;&#33021;&#12290;&#10;&#10;### &#35745;&#25968;&#26597;&#35810;&#10;&#20219;&#24847;&#30340;&#26597;&#35810;&#65292;&#19981;&#31649;&#26159;&#21333;&#26597;&#35810;&#36824;&#26159;&#32452;&#21512;&#26597;&#35810;&#65292;&#37117;&#25903;&#25345;&#35745;&#25968;&#26597;&#35810;:&#10;&#10;```c#&#10;public async void QueryCount_SampleCode()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    await client.ConnectAsync();//Tom &#30331;&#24405;&#23458;&#25143;&#31471;&#10;    AVIMConversationQuery query = client.GetQuery().WhereContains(&#34;attr.keywords&#34;, &#34;&#25945;&#32946;&#34;).WhereLessThan(&#34;attr.age&#34;, 18);//&#26597;&#35810; keywords &#21253;&#21547;&#25945;&#24182;&#19988;&#24180;&#40836;&#23567;&#20110;18&#30340;&#23545;&#35805;&#10;    var count = await query.CountAsync();//&#25191;&#34892;&#26597;&#35810;&#65292;&#33719;&#21462;&#31526;&#21512;&#26465;&#20214;&#30340;&#23545;&#35805;&#30340;&#25968;&#37327;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="开放聊天室">开放聊天室</h2><p>开放聊天室在本质上就是一个对话，所以以上章节中提到了<strong>所有的属性，方法，操作以及管理，都对开放聊天室适用</strong>，它仅仅是在逻辑上是一种暂态的，临时的对话。</p>
<h3 id="创建开放聊天室">创建开放聊天室</h3><p>比如某项比赛正在直播，解说员创建一个临时聊天，与球迷进行互动：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void ChatRoom_SampleCode()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Dendi&#34;);&#10;    await client.ConnectAsync();//Tom &#30331;&#24405;&#23458;&#25143;&#31471;&#10;    var chatroom = client.CreateConversationAsync(null, &#34;DK VS NewBee&#34;, null, true);&#10;    //&#35814;&#32454;&#35299;&#37322;&#26368;&#21518;&#19968;&#20010;&#21442;&#25968;&#65292;transient &#22914;&#26524;&#20026; true &#23601;&#35828;&#26126;&#26159;&#32842;&#22825;&#23460;&#65292;&#36923;&#36753;&#19978;&#23601;&#26159;&#26242;&#24577;&#23545;&#35805;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>另外，为了方便开发者快速创建聊天室，SDK 提供了一个快捷方法创建聊天室：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var chatroom = client.CreateChatRoomAsync(&#34;&#30343;&#39532; VS &#24052;&#33832;&#34;);//&#21487;&#20197;&#29702;&#35299;&#20026;&#19968;&#20010;&#35821;&#27861;&#31958;&#65292;&#19982;&#35843;&#29992;CreateConversationAsync &#27809;&#26377;&#26412;&#36136;&#21306;&#21035;</span><br></pre></td></tr></table></figure>
<h3 id="查询在线人数">查询在线人数</h3><p><code>AVIMConversation.CountMembersAsync</code> 不但可以用来查询普通对话的成员总数，在聊天室中，它返回的就是实时在线的人数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void CountMembers_SampleCode()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    await client.ConnectAsync();//Tom &#30331;&#24405;&#23458;&#25143;&#31471;&#10;&#10;    AVIMConversation conversation = (await client.GetQuery().FindAsync()).FirstOrDefault();&#10;    int membersCount = await conversation.CountMembersAsync();&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询开放聊天室">查询开放聊天室</h3><p>开发者需要注意的是，<code>AVIMConversationQuery</code> 调用 <code>Where</code> 开头的方法都是查询全部对话的，也就是说，如果想单独查询聊天室的话，需要额外再调用一次 <code>WhereEqulaTo</code> 方法：</p>
<p>比如我想查询主题包含《奔跑吧，兄弟》的聊天室，如下做即可：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public async void QueryChatRoom_SampleCode()&#10;&#123;&#10;    AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;    await client.ConnectAsync();//Tom &#30331;&#24405;&#23458;&#25143;&#31471;&#10;&#10;    AVIMConversationQuery query = client.GetQuery().WhereContains(&#34;topic&#34;.InsertAttrPrefix(), &#34;&#22868;&#36305;&#21543;&#65292;&#20804;&#24351;&#34;).WhereEqualTo(&#34;tr&#34;, true);&#10;    //&#27604;&#22914;&#25105;&#24819;&#26597;&#35810;&#20027;&#39064;&#21253;&#21547;&#12298;&#22868;&#36305;&#21543;&#65292;&#20804;&#24351;&#12299;&#30340;&#32842;&#22825;&#23460;&#10;    var result = await query.FindAsync();//&#25191;&#34892;&#26597;&#35810;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>从代码上可以看出，仅仅是多了一个额外的 <code>WhereEqualTo(&quot;tr&quot;, true)</code> 的链式查询即可。</p>
<h2 id="聊天记录">聊天记录</h2><p>聊天记录一直是客户端开发的一个重点难题，类似于的 QQ 和 微信的解决方案都是依托客户端做缓存，收到一条消息，就按照自己的业务逻辑存储在客户端的文件或者是各种客户端数据库中。</p>
<p>目前为了满足需求，我们特地开放了从服务端获取聊天记录的功能：</p>
<h3 id="聊天记录获取">聊天记录获取</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVIMClient userA = new AVIMClient(&#34;UserA&#34;);&#10;AVIMConversation con = userA.GetConversationById(&#34;2f08e882f2a11ef07902eeb510d4223b&#34;);&#10;con.QueryHistory(DateTime.Now.AddDays(-1), 0, &#34;UserA&#34;).Wait();&#10;//&#26597;&#35810; UserA &#22312; ConversationId &#20026; `2f08e882f2a11ef07902eeb510d4223b` &#20013;&#30340;&#32842;&#22825;&#35760;&#24405;&#12290;</span><br></pre></td></tr></table></figure>
<p>以上将查询昨天到现在 24 小时内对话中的聊天记录。</p>
<h2 id="签名与安全">签名与安全</h2><p>在继续阅读本文档之前，请确保您已经对 <a href="./realtime_v2.html#权限和认证">实时通信服务开发指南—权限和认证</a> 有了一定的了解。</p>
<h3 id="实现签名工厂">实现签名工厂</h3><p><code>AVIMClient</code> 有一个属性：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/// &#60;summary&#62;&#10;/// &#33719;&#21462;&#31614;&#21517;&#30340;&#25509;&#21475;&#10;/// &#60;/summary&#62;&#10;public ISignatureFactoryV2 SignatureFactory &#123; get; set; &#125;</span><br></pre></td></tr></table></figure>
<p>是预留给开发者实现签名需求的接口，开发者只需要在登录之前实现这个接口即可。</p>
<h3 id="签名的云代码实例">签名的云代码实例</h3><p>为了方便开发者理解签名，我们特地开源了签名的<a href="https://github.com/leancloud/realtime-messaging-signature-cloudcode" target="_blank" rel="external">云代码实例</a>，只要按照要求正确配置，就可以在客户端通过调用云代码的具体的函数实现签名。</p>
<p>演示实例的步骤：</p>
<ul>
<li><p>首先您需要下载最新版本的<a href="https://github.com/leancloud/realtime-messaging-signature-cloudcode" target="_blank" rel="external">云代码实例</a>到本地，然后部署到您的应用中，详细请参考<a href="./cloud_code_commandline.html">云代码命令行工具使用详解</a></p>
</li>
<li><p>其次，在 Visual Studio 中，新建一个类叫做 <code>SampleSignatureFactory</code> ，把下面这段代码拷贝到其中：</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/// &#60;summary&#62;&#10;/// &#31614;&#21517;&#31034;&#20363;&#31867;&#65292;&#25512;&#33616;&#24320;&#21457;&#32773;&#29992;&#36825;&#27573;&#20195;&#30721;&#29702;&#35299;&#31614;&#21517;&#30340;&#25972;&#20307;&#27010;&#24565;&#65292;&#27491;&#24335;&#29983;&#20135;&#29615;&#22659;&#65292;&#35831;&#24910;&#29992;&#10;/// &#60;/summary&#62;&#10;public class SampleSignatureFactory : ISignatureFactoryV2&#10;&#123;&#10;    /// &#60;summary&#62;&#10;    /// &#20026;&#26356;&#26032;&#23545;&#35805;&#25104;&#21592;&#30340;&#25805;&#20316;&#36827;&#34892;&#31614;&#21517;&#10;    /// &#60;/summary&#62;&#10;    /// &#60;param name=&#34;conversationId&#34;&#62;&#23545;&#35805;&#30340;Id&#60;/param&#62;&#10;    /// &#60;param name=&#34;clientId&#34;&#62;&#24403;&#21069;&#30340; clientId&#60;/param&#62;&#10;    /// &#60;param name=&#34;targetIds&#34;&#62;&#34987;&#25805;&#20316;&#25152;&#24433;&#21709;&#21040;&#30340; clientIds&#60;/param&#62;&#10;    /// &#60;param name=&#34;action&#34;&#62;&#25191;&#34892;&#30340;&#25805;&#20316;&#65292;&#30446;&#21069;&#21482;&#26377; add&#65292;remove&#60;/param&#62;&#10;    /// &#60;returns&#62;&#60;/returns&#62;&#10;    public Task&#60;AVIMSignatureV2&#62; CreateConversationSignature(string conversationId, string clientId, IList&#60;string&#62; targetIds, string action)&#10;    &#123;&#10;        var data = new Dictionary&#60;string, object&#62;();&#10;&#10;        data.Add(&#34;client_id&#34;, clientId);//&#34920;&#31034;&#24403;&#21069;&#26159;&#35841;&#22312;&#25805;&#20316;&#12290;&#10;        data.Add(&#34;member_ids&#34;, targetIds);//memberIds&#19981;&#35201;&#21253;&#21547;&#24403;&#21069;&#30340;ClientId&#12290;&#10;        data.Add(&#34;conversation_id&#34;, conversationId);//conversationId&#26159;&#31614;&#21517;&#24517;&#39035;&#30340;&#21442;&#25968;&#12290;&#10;           &#10;        data.Add(&#34;action&#34;, action);//conversationId&#26159;&#31614;&#21517;&#24517;&#39035;&#30340;&#21442;&#25968;&#12290;&#10;            &#10;            &#10;        //&#35843;&#29992;&#20113;&#20195;&#30721;&#36827;&#34892;&#31614;&#21517;&#12290;&#10;        return AVCloud.CallFunctionAsync&#60;IDictionary&#60;string, object&#62;&#62;(&#34;actionOnCoversation&#34;, data).ContinueWith&#60;AVIMSignatureV2&#62;(t =&#62;&#10;        &#123;&#10;            return MakeSignature(t.Result); ;//&#25340;&#35013;&#25104;&#19968;&#20010; Signature &#23545;&#35937;&#10;        &#125;);&#10;        //&#20197;&#19978;&#36825;&#27573;&#20195;&#30721;&#65292;&#24320;&#21457;&#32773;&#26080;&#38656;&#25163;&#21160;&#35843;&#29992;&#65292;&#21482;&#35201;&#24320;&#21457;&#32773;&#23545;&#19968;&#20010; AVIMClient &#35774;&#32622;&#20102; SignatureFactory&#65292;SDK &#20250;&#22312;&#25191;&#34892;&#23545;&#24212;&#30340;&#25805;&#20316;&#26102;&#20027;&#21160;&#35843;&#29992;&#36825;&#20010;&#26041;&#27861;&#36827;&#34892;&#31614;&#21517;&#12290;&#10;    &#125;&#10;    /// &#60;summary&#62;&#10;    /// &#30331;&#24405;&#31614;&#21517;&#10;    /// &#60;/summary&#62;&#10;    /// &#60;param name=&#34;clientId&#34;&#62;&#24403;&#21069;&#30340; clientId&#60;/param&#62;&#10;    /// &#60;returns&#62;&#60;/returns&#62;&#10;    public Task&#60;AVIMSignatureV2&#62; CreateConnectSignature(string clientId)&#10;    &#123;&#10;        var data = new Dictionary&#60;string, object&#62;();&#10;&#10;        data.Add(&#34;client_id&#34;, clientId);//&#34920;&#31034;&#24403;&#21069;&#26159;&#35841;&#35201;&#27714;&#36830;&#25509;&#26381;&#21153;&#22120;&#12290; &#10;&#10;        //&#35843;&#29992;&#20113;&#20195;&#30721;&#36827;&#34892;&#31614;&#21517;&#12290;&#10;        return AVCloud.CallFunctionAsync&#60;IDictionary&#60;string, object&#62;&#62;(&#34;connect&#34;, data).ContinueWith&#60;AVIMSignatureV2&#62;(t =&#62;&#10;        &#123;&#10;            return MakeSignature(t.Result); ;//&#25340;&#35013;&#25104;&#19968;&#20010; Signature &#23545;&#35937;&#10;        &#125;);&#10;    &#125;&#10;&#10;    /// &#60;summary&#62;&#10;    /// &#20026;&#21019;&#24314;&#23545;&#35805;&#31614;&#21517;&#10;    /// &#60;/summary&#62;&#10;    /// &#60;param name=&#34;clientId&#34;&#62;&#24403;&#21069;&#30340; clientId &#60;/param&#62;&#10;    /// &#60;param name=&#34;targetIds&#34;&#62;&#34987;&#24433;&#21709;&#30340; clientIds &#60;/param&#62;&#10;    /// &#60;returns&#62;&#60;/returns&#62;&#10;    public Task&#60;AVIMSignatureV2&#62; CreateStartConversationSignature(string clientId, IList&#60;string&#62; targetIds)&#10;    &#123;&#10;        var data = new Dictionary&#60;string, object&#62;();&#10;&#10;        data.Add(&#34;client_id&#34;, clientId);//&#34920;&#31034;&#24403;&#21069;&#26159;&#35841;&#22312;&#25805;&#20316;&#12290;&#10;        data.Add(&#34;member_ids&#34;, targetIds);//memberIds&#19981;&#35201;&#21253;&#21547;&#24403;&#21069;&#30340;ClientId&#12290;&#10;&#10;        //&#35843;&#29992;&#20113;&#20195;&#30721;&#36827;&#34892;&#31614;&#21517;&#12290;&#10;        return AVCloud.CallFunctionAsync&#60;IDictionary&#60;string, object&#62;&#62;(&#34;startConversation&#34;, data).ContinueWith&#60;AVIMSignatureV2&#62;(t =&#62;&#10;        &#123;&#10;            return MakeSignature(t.Result); ;//&#25340;&#35013;&#25104;&#19968;&#20010; Signature &#23545;&#35937;&#10;        &#125;);&#10;    &#125;&#10;&#10;    /// &#60;summary&#62;&#10;    /// &#33719;&#21462;&#31614;&#21517;&#20449;&#24687;&#24182;&#19988;&#25226;&#23427;&#36820;&#22238;&#32473; SDK &#21435;&#36827;&#34892;&#19979;&#19968;&#27493;&#30340;&#25805;&#20316;&#10;    /// &#60;/summary&#62;&#10;    /// &#60;param name=&#34;dataFromCloudcode&#34;&#62;&#60;/param&#62;&#10;    /// &#60;returns&#62;&#60;/returns&#62;&#10;    protected AVIMSignatureV2 MakeSignature(IDictionary&#60;string, object&#62; dataFromCloudcode)&#10;    &#123;&#10;        AVIMSignatureV2 signature = new AVIMSignatureV2();&#10;        signature.Nonce = dataFromCloudcode[&#34;nonce&#34;].ToString();&#10;        signature.SignatureContent = dataFromCloudcode[&#34;signature&#34;].ToString();&#10;        signature.Timestamp = (long)dataFromCloudcode[&#34;timestamp&#34;];&#10;        return signature;//&#25340;&#35013;&#25104;&#19968;&#20010; Signature &#23545;&#35937;&#10;    &#125;&#10;&#10;    /// &#60;summary&#62;&#10;    /// &#20026;&#33719;&#21462;&#32842;&#22825;&#35760;&#24405;&#30340;&#25805;&#20316;&#31614;&#21517;&#10;    /// &#60;/summary&#62;&#10;    /// &#60;param name=&#34;clientId&#34;&#62;&#24403;&#21069;&#30340; clientId &#60;/param&#62;&#10;    /// &#60;param name=&#34;conversationId&#34;&#62;&#23545;&#35805; Id&#60;/param&#62;&#10;    /// &#60;returns&#62;&#60;/returns&#62;&#10;    public Task&#60;AVIMSignatureV2&#62; CreateQueryHistorySignature(string clientId, string conversationId)&#10;    &#123;&#10;        var data = new Dictionary&#60;string, object&#62;();&#10;&#10;        data.Add(&#34;client_id&#34;, clientId);//&#34920;&#31034;&#24403;&#21069;&#26159;&#35841;&#22312;&#25805;&#20316;&#12290;&#10;        data.Add(&#34;convid&#34;, conversationId);//memberIds&#19981;&#35201;&#21253;&#21547;&#24403;&#21069;&#30340;ClientId&#12290;&#10;&#10;        //&#35843;&#29992;&#20113;&#20195;&#30721;&#36827;&#34892;&#31614;&#21517;&#12290;&#10;        return AVCloud.CallFunctionAsync&#60;IDictionary&#60;string, object&#62;&#62;(&#34;queryHistory&#34;, data).ContinueWith&#60;AVIMSignatureV2&#62;(t =&#62;&#10;        &#123;&#10;            return MakeSignature(t.Result); ;//&#25340;&#35013;&#25104;&#19968;&#20010; Signature &#23545;&#35937;&#10;        &#125;);&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>然后在调用如下代码进行测试（确保您已经在控制台开启了聊天签名的服务，否则签名操作无效）：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVIMClient client = new AVIMClient(&#34;Tom&#34;);&#10;client.SignatureFactory = new SampleSignatureFactory();//&#36825;&#37324;&#26159;&#19968;&#20010;&#24320;&#21457;&#32773;&#33258;&#24049;&#23454;&#29616;&#30340;&#25509;&#21475;&#30340;&#20855;&#20307;&#30340;&#31867;&#10;await client.ConnectAsync();//Tom &#30331;&#24405;&#23458;&#25143;&#31471;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="-NET_实时通信开发指南">.NET 实时通信开发指南</h1><h2 id="简介">简介</h2><p>在阅读本开发指南之前，请先阅读下<a href="./realtime_v2.html">《实时通信开发指南》</a>，了解实时通信的基本概念和模型。</]]>
    </summary>
    
      <category term="leancloud" scheme="http://yoursite.com/tags/leancloud/"/>
    
      <category term="leancloud" scheme="http://yoursite.com/categories/leancloud/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS / OS X SDK 常见问题和解答]]></title>
    <link href="http://yoursite.com/2015/12/30/avos/ios_os_x_faq/"/>
    <id>http://yoursite.com/2015/12/30/avos/ios_os_x_faq/</id>
    <published>2015-12-29T23:56:29.000Z</published>
    <updated>2015-12-18T10:24:21.548Z</updated>
    <content type="html"><![CDATA[<h1 id="iOS_/_OS_X_SDK_常见问题和解答">iOS / OS X SDK 常见问题和解答</h1><h2 id="怎么使用_LeanCloud_iOS_SDK">怎么使用 LeanCloud iOS SDK</h2><p>最简单的方式，使用 CocoaPods，在 PodFile 加入以下内容：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="string">'AVOSCloud'</span></span><br></pre></td></tr></table></figure>
<p>AVOSCloudSNS SDK：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="string">'AVOSCloudSNS'</span></span><br></pre></td></tr></table></figure>
<h3 id="如何使用「用户登录」功能">如何使用「用户登录」功能</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVUser</span> logInWithUsernameInBackground:<span class="string">@"zeng"</span> password:<span class="string">@"123456"</span> block:^(<span class="built_in">AVUser</span> *user, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (user != null) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"login success"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"signin failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h2 id="如何登出">如何登出</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVUser</span> logOut];</span><br></pre></td></tr></table></figure>
<h2 id="如何使用「新浪微博」登录">如何使用「新浪微博」登录</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVOSCloudSNS</span> loginWithCallback:^(<span class="keyword">id</span> object, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//回调代码</span></span><br><span class="line"></span><br><span class="line">&#125; toPlatform:<span class="built_in">AVOSCloudSNSSinaWeibo</span>];</span><br></pre></td></tr></table></figure>
<h2 id="使用_AVOSCloudSNS，运行时报错：+[AVUser_loginWithAuthData:block:]:_unrecognized_selector_sent_to_class">使用 AVOSCloudSNS，运行时报错：+[AVUser loginWithAuthData:block:]: unrecognized selector sent to class</h2><p>请将 <strong>Build Settings</strong> -&gt; <strong>Linking</strong> -&gt; <strong>Other Linker Flags</strong> 设置为 <strong>-ObjC</strong>。具体原因可以参考苹果官方文档《Technical Q&amp;A QA1490 <a href="https://developer.apple.com/library/mac/qa/qa1490/_index.html" target="_blank" rel="external">Building Objective-C static libraries with categories</a>》。此外，stackoverfow 上也有一个比较详细的答案：《<a href="http://stackoverflow.com/questions/2567498/objective-c-categories-in-static-library" target="_blank" rel="external">Objective-C categories in static library</a>》。</p>
<h2 id="为什么升级到_3-1-3-2_以上的版本时_BOOL_类型数据保存错误？">为什么升级到 3.1.3.2 以上的版本时 BOOL 类型数据保存错误？</h2><p>在 3.1.3.2 版本中，我们修正了子类化时 <code>BOOL</code> 类型的 <code>property</code> 保存到后端时被认为是 Number 类型而不是 Boolean 类型的问题，即 <code>BOOL</code> 类型不再保存为 <code>0</code> 和 <code>1</code>，而被正确地保存为 <code>true</code> 和 <code>false</code>。但您的代码可能已经适应了修正前的 SDK，并且相应的字段已经是 <code>Number</code> 类型。这时再保存为 <code>Boolean</code> 类型就会报 “Expected type is number, but it is boolean” 之类的错误，如果出现此类错误且要继续保持该字段 Number 类型时，可类似地将 <code>@property (BOOL) isTeamMember;</code> 改为 <code>@property NSInteger isTeamMember;</code>。</p>
<h2 id="为什么不能真机调试">为什么不能真机调试</h2><p>由于动态库在打包时，Xcode 将动态库的签名意外丢失，导致使用了动态库的应用在真机调试时，签名校验失败。</p>
<p>我们已经将所有动态库重新签名，修复了这个问题。开发者需要更新动态库。如果是手动集成的，只需要重新下载并替换原 framework 即可。如果是通过 CocoaPods 安装的，需要额外的步骤：</p>
<ol>
<li>删掉 Podfile 中的动态库 pod；</li>
<li>执行 <code>pod install</code> 命令，卸载出问题的动态库；</li>
<li>删掉 $HOME/Library/Caches/CocoaPods/Pods 这个目录；</li>
<li>将之前删掉的动态库 pod 重新添加到 Podfile 中；</li>
<li>执行 <code>pod install</code> 命令，安装新的动态库。</li>
</ol>
<p>完成以上几个步骤后，就能在真机上调试应用了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="iOS_/_OS_X_SDK_常见问题和解答">iOS / OS X SDK 常见问题和解答</h1><h2 id="怎么使用_LeanCloud_iOS_SDK">怎么使用 LeanCloud iOS SDK</h2><p>最简单的方式，使用 CocoaPods]]>
    </summary>
    
      <category term="leancloud" scheme="http://yoursite.com/tags/leancloud/"/>
    
      <category term="leancloud" scheme="http://yoursite.com/categories/leancloud/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 推送证书设置指南]]></title>
    <link href="http://yoursite.com/2015/12/30/avos/ios_push_cert/"/>
    <id>http://yoursite.com/2015/12/30/avos/ios_push_cert/</id>
    <published>2015-12-29T23:56:29.000Z</published>
    <updated>2015-12-18T10:24:45.791Z</updated>
    <content type="html"><![CDATA[<h1 id="iOS_推送证书设置指南">iOS 推送证书设置指南</h1><h2 id="创建应用程序_ID">创建应用程序 ID</h2><ul>
<li>登录 <a href="https://developer.apple.com/devcenter/ios/index.action" target="_blank" rel="external">iOS Dev Center</a> 选择进入 iOS Provisioning Portal。</li>
</ul>
<p><img src="images/ios_cert/login.png" alt="Enable push"></p>
<ul>
<li>在 <a href="https://developer.apple.com/ios/manage/overview/index.action" target="_blank" rel="external">iOS Provisioning Portal</a> 中，点击 App IDs 进入 App ID 列表。</li>
</ul>
<p><img src="images/ios_cert/appid.png" alt="Enable push"></p>
<ul>
<li>创建 App ID，如果 ID 已经存在可以直接跳过此步骤。</li>
</ul>
<p><img src="images/ios_cert/appid2.png" alt="Enable push"></p>
<ul>
<li>为 App 开启 Push Notification 功能。如果是已经创建的 App ID 也可以通过设置开启 Push Notification 功能。</li>
</ul>
<p><img src="images/ios_cert/appservice.png" alt="Enable push"></p>
<ul>
<li>根据实际情况完善 App ID 信息并提交,注意此处需要指定具体的 Bundle ID 不要使用通配符。</li>
</ul>
<p><img src="images/ios_cert/appid3.png" alt="Enable push"></p>
<h2 id="配置和下载证书">配置和下载证书</h2><ul>
<li>如果你之前没有创建过 Push 证书或者是要重新创建一个新的，请在证书列表下面新建。</li>
</ul>
<p><img src="images/ios_cert/cer0.png" alt="Enable push"></p>
<ul>
<li>新建证书需要注意选择证书种类（开发证书用于开发和调试使用，生产证书用于 App Store 发布）</li>
</ul>
<p><img src="images/ios_cert/cer1.png" alt="Enable push"></p>
<ul>
<li>点击 Continue 后选择证书对应的应用ID，然后继续会出现 <strong>About Creating a Certificate Signing Request (CSR)</strong>。</li>
</ul>
<p><img src="images/ios_cert/cer2.png" alt="Enable push"></p>
<ul>
<li>根据它的说明创建 Certificate Signing Request。</li>
</ul>
<p><img src="images/ios_cert/cer3.png" alt="Enable push"></p>
<ul>
<li>然后点击 <strong>Continue</strong>，上传刚刚生成的 .certSigningRequest 文件 生成 APNs Push  Certificate。</li>
<li>下载并双击打开证书，证书打开时会启动 <strong>钥匙串访问</strong> 工具。</li>
<li>在 <strong>钥匙串访问</strong> 中你的证书会显示在 <strong>我的证书</strong> 中，注意选择左上角的 <strong>My Certificates</strong>（我的证书）和左下角 <strong>login</strong>(登录）。</li>
</ul>
<p><img src="images/ios_cert/keychain_cert.png" alt="Enable push"></p>
<h2 id="导出_-p12_证书文件">导出 .p12 证书文件</h2><ul>
<li>在 <strong>钥匙串访问</strong> 中，选择刚刚加进来的证书，选择右键菜单中的 <strong>导出 “…”</strong>。</li>
</ul>
<p><img src="images/ios_cert/export_p12.png" alt="Enable push"></p>
<ul>
<li>将文件保存为Personal Information Exchange (.p12) 格式。</li>
</ul>
<p><img src="images/ios_cert/export_filename.png" alt="Enable push"></p>
<p><strong>保存 p12 文件时，密码必须为空</strong>。</p>
<p>如果 <strong>Personal Information Exchange (.p12)</strong> 格式是灰色的，请确保选中 <strong>My Certificates</strong>（我的证书）。如果还是不行，请确认选择的是钥匙串里的 <strong>login</strong> 的证书（左上角）。或者你也可以尝试将证书文件拖拽到 <strong>My Certificates</strong> 下。</p>
<h2 id="上传证书">上传证书</h2><p>在 <a href="/messaging.html?appid=#/message/push/conf"><strong>控制台</strong> &gt; <strong>消息 &gt; 推送 &gt; 设置</strong></a> 里，上传上面步骤得到 .p12 证书文件。这是 iOS SDK 能够接收到 LeanCloud 推送消息的必要步骤。</p>
<p><img src="images/ios_cert/upload_p12.png" alt="Enable push"></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="iOS_推送证书设置指南">iOS 推送证书设置指南</h1><h2 id="创建应用程序_ID">创建应用程序 ID</h2><ul>
<li>登录 <a href="https://developer.apple.com/devcenter/ios/index]]>
    </summary>
    
      <category term="leancloud" scheme="http://yoursite.com/tags/leancloud/"/>
    
      <category term="leancloud" scheme="http://yoursite.com/categories/leancloud/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 消息推送开发指南]]></title>
    <link href="http://yoursite.com/2015/12/30/avos/ios_push_guide/"/>
    <id>http://yoursite.com/2015/12/30/avos/ios_push_guide/</id>
    <published>2015-12-29T23:56:29.000Z</published>
    <updated>2015-12-18T10:24:54.855Z</updated>
    <content type="html"><![CDATA[<h1 id="iOS_消息推送开发指南">iOS 消息推送开发指南</h1><p>本文介绍了如何在 iOS 设备中使用 LeanCloud 的推送功能。请先阅读我们的博客文章《<a href="https://blog.leancloud.cn/1163/" target="_blank" rel="external">细说 iOS 消息推送</a>》，再通过 <a href="push_guide.html">消息推送概览</a> 了解和巩固相关概念。</p>
<h2 id="配置_iOS_推送证书">配置 iOS 推送证书</h2><p>配置 iOS 证书相对麻烦，但是却是必须的步骤，请详读 <a href="ios_push_cert.html">iOS 推送证书设置指南</a>。</p>
<h2 id="多证书场景">多证书场景</h2><p>对于一些应用，他们在发布和上架时分为不同的版本（司机版、乘客版），但数据和消息是互通的，这种场景下我们允许应用上传多个自定义证书并对不同的设备设置 <code>deviceProfile</code>，从而可以用合适的证书给不同版本的应用推送。</p>
<p>当你上传自定义证书时会被要求输入「证书类型」，即 deviceProfile 的名字。当 installation 上保存了 deviceProfile 时，我们将忽略原先的开发和生产证书设置，而直接按照 deviceProfile 推送。</p>
<h2 id="保存_Installation">保存 Installation</h2><p>在保存 installation 前，要先通过下列代码获取用户推送权限：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Before iOS 8:</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Register for push notifications</span></span><br><span class="line">    [application registerForRemoteNotificationTypes:</span><br><span class="line">                                <span class="built_in">UIRemoteNotificationTypeBadge</span> |</span><br><span class="line">                                <span class="built_in">UIRemoteNotificationTypeAlert</span> |</span><br><span class="line">                                <span class="built_in">UIRemoteNotificationTypeSound</span>];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//For iOS 8:</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">UIUserNotificationSettings</span> *settings = [<span class="built_in">UIUserNotificationSettings</span> settingsForTypes:<span class="built_in">UIUserNotificationTypeAlert</span></span><br><span class="line">                                            | <span class="built_in">UIUserNotificationTypeBadge</span></span><br><span class="line">                                            | <span class="built_in">UIUserNotificationTypeSound</span></span><br><span class="line">                                                                             categories:<span class="literal">nil</span>];</span><br><span class="line">    [application registerUserNotificationSettings:settings];</span><br><span class="line">    [application registerForRemoteNotifications];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 iOS 设备中，Installation 的类是 AVInstallation，并且是 AVObject 的子类，使用同样的 API 存储和查询。如果要访问当前应用的 Installation 对象，可以通过 <code>[AVInstallation currentInstallation]</code> 方法。当你第一次保存 AVInstallation 的时候，它会插入 <code>_Installation</code> 表，你可以在 <a href="/data.html?appid=&lt;!--￼26--">数据管理</a> 平台看到和查询。当 deviceToken 一被保存，你就可以向这台设备推送消息了。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)app didRegisterForRemoteNotificationsWithDeviceToken:(<span class="built_in">NSData</span> *)deviceToken &#123;</span><br><span class="line">    <span class="built_in">AVInstallation</span> *currentInstallation = [<span class="built_in">AVInstallation</span> currentInstallation];</span><br><span class="line">    [currentInstallation setDeviceTokenFromData:deviceToken];</span><br><span class="line">    [currentInstallation saveInBackground];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以像修改 AVObject 那样去修改 AVInstallation，但是有一些特殊字段可以帮你管理目标设备：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>badge</td>
<td>应用图标旁边的红色数字，修改 AVInstallation 的这个值将修改应用的 badge。修改应该保存到服务器，以便为以后做 badge 增量式的推送做准备。</td>
</tr>
<tr>
<td>channels</td>
<td>当前设备所订阅的频道数组</td>
</tr>
<tr>
<td>appName</td>
<td>应用名称（只读）</td>
</tr>
<tr>
<td>appVersion</td>
<td>应用版本（只读）</td>
</tr>
<tr>
<td>deviceProfile</td>
<td>设备对应的后台自定义证书名称，用于多证书推送</td>
</tr>
</tbody>
</table>
<h2 id="发送推送消息">发送推送消息</h2><p>发送 iOS 推送消息，可以通过 REST API，或者我们的消息推送 web 平台，请进入你的应用管理界面查看。</p>
<h2 id="使用频道">使用频道</h2><p>使用频道（channel）可以实现「发布—订阅」的模型。设备订阅某个频道，然后发送消息的时候指定要发送的频道即可。</p>
<div class="callout callout-info">每个 channel 名称只能包含 26 个英文字母和数字。</div>

<h3 id="订阅和退订">订阅和退订</h3><p>订阅 Giants 频道：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当用户表示喜欢 Giants，则为其订阅该频道。</span></span><br><span class="line"><span class="built_in">AVInstallation</span> *currentInstallation = [<span class="built_in">AVInstallation</span> currentInstallation];</span><br><span class="line">[currentInstallation addUniqueObject:<span class="string">@"Giants"</span> forKey:<span class="string">@"channels"</span>];</span><br><span class="line">[currentInstallation saveInBackground];</span><br></pre></td></tr></table></figure>
<p>订阅后要记得保存，即可在 <a href="/data.html?appid=&lt;!--￼27--">数据管理</a>平台看到该 installation 的 channels 字段多了一个「Giants」。</p>
<p>退订：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVInstallation</span> *currentInstallation = [<span class="built_in">AVInstallation</span> currentInstallation];</span><br><span class="line">[currentInstallation removeObject:<span class="string">@"Giants"</span> forKey:<span class="string">@"channels"</span>];</span><br><span class="line">[currentInstallation saveInBackground];</span><br></pre></td></tr></table></figure>
<p>获取所有订阅的频道：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *subscribedChannels = [<span class="built_in">AVInstallation</span> currentInstallation]<span class="variable">.channels</span>;</span><br></pre></td></tr></table></figure>
<h3 id="发送消息到频道">发送消息到频道</h3><p>发送消息到刚才订阅的「Giants」频道：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Send a notification to all devices subscribed to the "Giants" channel.</span></span><br><span class="line"><span class="built_in">AVPush</span> *push = [[<span class="built_in">AVPush</span> alloc] init];</span><br><span class="line">[push setChannel:<span class="string">@"Giants"</span>];</span><br><span class="line">[push setMessage:<span class="string">@"Giants 太牛掰了"</span>];</span><br><span class="line">[push sendPushInBackground];</span><br></pre></td></tr></table></figure>
<p>如果你想发送到多个频道，可以指定 channels 数组：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *channels = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"Giants"</span>, <span class="string">@"Mets"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">AVPush</span> *push = [[<span class="built_in">AVPush</span> alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Be sure to use the plural 'setChannels'.</span></span><br><span class="line">[push setChannels:channels];</span><br><span class="line">[push setMessage:<span class="string">@"The Giants won against the Mets 2-3."</span>];</span><br><span class="line">[push sendPushInBackground];</span><br></pre></td></tr></table></figure>
<h3 id="选择证书">选择证书</h3><p>默认情况下，从客户端发起的推送都是使用你在消息菜单上传的生产证书，如果想使用开发证书，可以通过 <code>setProductionMode</code> 方法：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr_selector">[AVPush setProductionMode:NO]</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="高级定向发送">高级定向发送</h2><p>频道对于大多数应用来说可能就足够了。但是某些情况下，你可能需要更高精度的定向推送。LeanCloud 允许你通过 AVQuery API 查询 Installation 列表，并向指定条件的 query 推送消息。</p>
<p>因为 AVInstallation 同时是 AVObject 的子类，因此你可以保存任何数据类型到 AVInstallation，并将它和你的其他应用数据对象关联起来，这样以来，你可以非常灵活地向你用户群做定制化、动态的推送。</p>
<h3 id="保存_Installation_数据">保存 Installation 数据</h3><p>为 AVInstallation 添加三个新字段：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Store app language and version</span></span><br><span class="line"><span class="built_in">AVInstallation</span> *installation = [<span class="built_in">AVInstallation</span> currentInstallation];</span><br><span class="line"></span><br><span class="line"><span class="comment">//字段依次为：比赛分数、比赛结果、受伤报告</span></span><br><span class="line">[installation setObject:@(<span class="literal">YES</span>) forKey:<span class="string">@"scores"</span>];</span><br><span class="line">[installation setObject:@(<span class="literal">YES</span>) forKey:<span class="string">@"gameResults"</span>];</span><br><span class="line">[installation setObject:@(<span class="literal">YES</span>) forKey:<span class="string">@"injuryReports"</span>];</span><br><span class="line">[installation saveInBackground];</span><br></pre></td></tr></table></figure>
<p>你可以给 Installation 添加 owner 属性，比如当前的登录用户：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Saving the device's owner</span></span><br><span class="line"><span class="built_in">AVInstallation</span> *installation = [<span class="built_in">AVInstallation</span> currentInstallation];</span><br><span class="line">[installation setObject:[<span class="built_in">AVUser</span> currentUser] forKey:<span class="string">@"owner"</span>];</span><br><span class="line">[installation saveInBackground];</span><br></pre></td></tr></table></figure>
<h3 id="根据查询来推送消息">根据查询来推送消息</h3><p>一旦 Installation 保存了你的应用数据，你可以使用 AVQuery 来查询出设备的一个子集做推送。Installation 的查询跟其他对象的查询没有什么不同，只是使用特殊的静态方法<br> <code>[AVInstallation query]</code> 创建查询对象：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create our Installation query</span></span><br><span class="line"><span class="built_in">AVQuery</span> *pushQuery = [<span class="built_in">AVInstallation</span> query];</span><br><span class="line">[pushQuery whereKey:<span class="string">@"injuryReports"</span> equalTo:@(<span class="literal">YES</span>)];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send push notification to query</span></span><br><span class="line"><span class="built_in">AVPush</span> *push = [[<span class="built_in">AVPush</span> alloc] init];</span><br><span class="line">[push setQuery:pushQuery]; <span class="comment">// Set our Installation query</span></span><br><span class="line">[push setMessage:<span class="string">@"Willie Hayes injured by own pop fly."</span>];</span><br><span class="line">[push sendPushInBackground];</span><br></pre></td></tr></table></figure>
<p>你也可以在查询中添加 channels 的条件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create our Installation query</span></span><br><span class="line"><span class="built_in">AVQuery</span> *pushQuery = [<span class="built_in">AVInstallation</span> query];</span><br><span class="line">[pushQuery whereKey:<span class="string">@"channels"</span> equalTo:<span class="string">@"Giants"</span>]; <span class="comment">// Set channel</span></span><br><span class="line">[pushQuery whereKey:<span class="string">@"scores"</span> equalTo:@(<span class="literal">YES</span>)];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send push notification to query</span></span><br><span class="line"><span class="built_in">AVPush</span> *push = [[<span class="built_in">AVPush</span> alloc] init];</span><br><span class="line">[push setQuery:pushQuery];</span><br><span class="line">[push setMessage:<span class="string">@"Giants scored against the A's! It's now 2-2."</span>];</span><br><span class="line">[push sendPushInBackground];</span><br></pre></td></tr></table></figure>
<p>如果你在 Installation 还保存了其他对象的关系，我们同样可以在查询条件中使用这些数据，例如，向靠近北京大学的设备推送消息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find users near a given location</span></span><br><span class="line"><span class="built_in">AVQuery</span> *userQuery = [<span class="built_in">AVUser</span> query];</span><br><span class="line">[userQuery whereKey:<span class="string">@"location"</span></span><br><span class="line">        nearGeoPoint:beijingUniversityLocation,</span><br><span class="line">         withinMiles:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find devices associated with these users</span></span><br><span class="line"><span class="built_in">AVQuery</span> *pushQuery = [<span class="built_in">AVInstallation</span> query];</span><br><span class="line">[pushQuery whereKey:<span class="string">@"user"</span> matchesQuery:userQuery];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send push notification to query</span></span><br><span class="line"><span class="built_in">AVPush</span> *push = [[<span class="built_in">AVPush</span> alloc] init];</span><br><span class="line">[push setQuery:pushQuery]; <span class="comment">// Set our Installation query</span></span><br><span class="line">[push setMessage:<span class="string">@"Free hotdogs at the AVOSCloud concession stand!"</span>];</span><br><span class="line">[push sendPushInBackground];</span><br></pre></td></tr></table></figure>
<h2 id="发送选项">发送选项</h2><p>除了发送一个文本信息之外，你还可以播放一个声音，设置 badge 数字或者其他想自定义的数据。你还可以设置一个消息的过期时间，如果对消息的时效性特别敏感的话。</p>
<h3 id="定制通知">定制通知</h3><p>如果你不仅想发送一条文本消息，你需要一个 NSDictionary 来打包想发送的数据。这里有一些保留字段，具有特殊含义，需要说明：</p>
<table>
<thead>
<tr>
<th>保留字段</th>
<th>平台</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>alert</td>
<td>通用</td>
<td>推送消息的文本内容</td>
</tr>
<tr>
<td>badge</td>
<td>iOS</td>
<td>应用图标右上角的数字。可以设置一个值或者递增当前值。</td>
</tr>
<tr>
<td>sound</td>
<td>iOS</td>
<td>应用 bundle 里的声音文件名称。</td>
</tr>
<tr>
<td>content-available</td>
<td>iOS</td>
<td>如果你在使用 Newsstand, 设置为 1 来开始一次后台下载。</td>
</tr>
<tr>
<td>action</td>
<td>Android</td>
<td>当消息收到的时候，触发的 Intent 名称。如果没有设置 title 或者 alert，Intent 将触发，但是不会显示通知给用户。</td>
</tr>
<tr>
<td>title</td>
<td>Android</td>
<td>显示在系统通知栏的标题。</td>
</tr>
</tbody>
</table>
<p>例如，递增 badge 数字，并播放声音可以这样做:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *data = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:</span><br><span class="line">    <span class="string">@"The Mets scored! The game is now tied 1-1!"</span>, <span class="string">@"alert"</span>,</span><br><span class="line">    <span class="string">@"Increment"</span>, <span class="string">@"badge"</span>,</span><br><span class="line">    <span class="string">@"cheering.caf"</span>, <span class="string">@"sound"</span>,</span><br><span class="line">    <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">AVPush</span> *push = [[<span class="built_in">AVPush</span> alloc] init];</span><br><span class="line">[push setChannels:[<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"Mets"</span>, <span class="literal">nil</span>]];</span><br><span class="line">[push setData:data];</span><br><span class="line">[push sendPushInBackground];</span><br></pre></td></tr></table></figure>
<p>当然，你还可以添加其他自定义的数据。你会在接收推送一节看到，当应用通过推送打开你的应用的时候，你就可以访问这些数据。当你要在用户打开通知的时候显示一个不同的 view controller 的时候，这特别有用。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *data = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:</span><br><span class="line">    <span class="string">@"Ricky Vaughn was injured in last night's game!"</span>, <span class="string">@"alert"</span>,</span><br><span class="line">    <span class="string">@"Vaughn"</span>, <span class="string">@"name"</span>,</span><br><span class="line">    <span class="string">@"Man bites dog"</span>, <span class="string">@"newsItem"</span>,</span><br><span class="line">    <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">AVPush</span> *push = [[<span class="built_in">AVPush</span> alloc] init];</span><br><span class="line">[push setQuery:injuryReportsQuery];</span><br><span class="line">[push setChannel:<span class="string">@"Indians"</span>];</span><br><span class="line">[push setData:data];</span><br><span class="line">[push sendPushInBackground];</span><br></pre></td></tr></table></figure>
<h3 id="设置过期日期">设置过期日期</h3><p>当设备关闭或者无法连接到网络的时候，推送通知就无法被送达。如果你有一条时间敏感的推送通知，不希望在太长时间后被用户读到，那么可以设置一个过期时间来避免打扰用户。</p>
<p>AVPush 提供了两个方法来设置通知的过期日期，首先是 expireAtDate：接收 NSDate 来告诉 LeanCloud 不要再去发送通知。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDateComponents</span> *comps = [[<span class="built_in">NSDateComponents</span> alloc] init];</span><br><span class="line">[comps setYear:<span class="number">2013</span>];</span><br><span class="line">[comps setMonth:<span class="number">10</span>];</span><br><span class="line">[comps setDay:<span class="number">12</span>];</span><br><span class="line"><span class="built_in">NSCalendar</span> *gregorian =</span><br><span class="line">  [[<span class="built_in">NSCalendar</span> alloc] initWithCalendarIdentifier:<span class="built_in">NSGregorianCalendar</span>];</span><br><span class="line"><span class="built_in">NSDate</span> *date = [gregorian dateFromComponents:comps];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send push notification with expiration date</span></span><br><span class="line"><span class="built_in">AVPush</span> *push = [[<span class="built_in">AVPush</span> alloc] init];</span><br><span class="line">[push expireAtDate:date];</span><br><span class="line">[push setQuery:everyoneQuery];</span><br><span class="line">[push setMessage:<span class="string">@"Season tickets on sale until October 12th"</span>];</span><br><span class="line">[push sendPushInBackground];</span><br></pre></td></tr></table></figure>
<p>这个方法有个隐患，因为设备的时钟是无法保证精确的，你可能得到错误的结果。因此，AVPush 还提供了 <code>expireAfterTimeInterval</code> 方法，接收 NSTimeInterval 对象。通知将在指定间隔时间后失效：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create time interval</span></span><br><span class="line"><span class="built_in">NSTimeInterval</span> interval = <span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>*<span class="number">7</span>; <span class="comment">// 1 week</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Send push notification with expiration interval</span></span><br><span class="line"><span class="built_in">AVPush</span> *push = [[<span class="built_in">AVPush</span> alloc] init];</span><br><span class="line">[push expireAfterTimeInterval:interval];</span><br><span class="line">[push setQuery:everyoneQuery];</span><br><span class="line">[push setMessage:<span class="string">@"Season tickets on sale until October 18th"</span>];</span><br><span class="line">[push sendPushInBackground];</span><br></pre></td></tr></table></figure>
<div class="callout callout-info">我们建议给 iOS 设备的推送都设置过期时间，才能保证推送的当时，如果用户设置了飞行模式，在关闭飞行模式之后可以收到推送消息，可以参考 <a href="http://stackoverflow.com/questions/24026544/push-notification-is-not-being-delivered-when-iphone-comes-back-online" target="_blank" rel="external">Stackoverflow - Push notification is not being delivered when iPhone comes back online</a>。</div>

<h3 id="指定设备平台">指定设备平台</h3><p>跨平台的应用，可能想指定发送的平台，比如 iOS 或者 Android:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVInstallation</span> query];</span><br><span class="line">[query whereKey:<span class="string">@"channels"</span> equalTo:<span class="string">@"suitcaseOwners"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Notification for Android users</span></span><br><span class="line">[query whereKey:<span class="string">@"deviceType"</span> equalTo:<span class="string">@"android"</span>];</span><br><span class="line"><span class="built_in">AVPush</span> *androidPush = [[<span class="built_in">AVPush</span> alloc] init];</span><br><span class="line">[androidPush setMessage:<span class="string">@"Your suitcase has been filled with tiny robots!"</span>];</span><br><span class="line">[androidPush setQuery:query];</span><br><span class="line">[androidPush sendPushInBackground];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Notification for iOS users</span></span><br><span class="line">[query whereKey:<span class="string">@"deviceType"</span> equalTo:<span class="string">@"ios"</span>];</span><br><span class="line"><span class="built_in">AVPush</span> *iOSPush = [[<span class="built_in">AVPush</span> alloc] init];</span><br><span class="line">[iOSPush setMessage:<span class="string">@"Your suitcase has been filled with tiny apples!"</span>];</span><br><span class="line">[iOSPush setChannel:<span class="string">@"suitcaseOwners"</span>];</span><br><span class="line">[iOSPush setQuery:query];</span><br><span class="line">[iOSPush sendPushInBackground];</span><br></pre></td></tr></table></figure>
<h2 id="定时推送">定时推送</h2><p>请进入消息推送的 Web 管理平台，可以做到定时推送（延迟或者指定时间）。</p>
<h2 id="接收推送通知">接收推送通知</h2><p>正如 <a href="#定制通知">定制通知</a> 一节提到，你可以随通知发送任意的数据。我们使用这些数据修改应用的行为，当应用是通过通知打开的时候。例如，当打开一条通知告诉你有一个新朋友的时候，这时候如果显示一张图片会非常好。</p>
<p>由于 Apple 的对消息大小的限制，请尽量缩小要发送的数据大小，否则可能被截断：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *data = @&#123;</span><br><span class="line">  <span class="string">@"alert"</span>: <span class="string">@"James commented on your photo!"</span>,</span><br><span class="line">  <span class="string">@"p"</span>: <span class="string">@"vmRZXZ1Dvo"</span> <span class="comment">// Photo's object id</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">AVPush</span> *push = [[<span class="built_in">AVPush</span> alloc] init];</span><br><span class="line">[push setQuery:photoOwnerQuery];</span><br><span class="line">[push setData:data];</span><br><span class="line">[push sendPushInBackground];</span><br></pre></td></tr></table></figure>
<h2 id="响应通知数据">响应通知数据</h2><p>当应用是被通知打开的时候，你可以通过 <code>application:didFinishLaunchingWithOptions:</code>方法的 <code>launchOptions</code> 参数所使用的 dictionary 访问到数据：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">  . . .</span><br><span class="line">  <span class="comment">// Extract the notification data</span></span><br><span class="line">  <span class="built_in">NSDictionary</span> *notificationPayload = launchOptions[<span class="built_in">UIApplicationLaunchOptionsRemoteNotificationKey</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a pointer to the Photo object</span></span><br><span class="line">  <span class="built_in">NSString</span> *photoId = [notificationPayload objectForKey:<span class="string">@"p"</span>];</span><br><span class="line">  <span class="built_in">AVObject</span> *targetPhoto = [<span class="built_in">AVObject</span> objectWithoutDataWithClassName:<span class="string">@"Photo"</span></span><br><span class="line">                                                          objectId:photoId];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fetch photo object</span></span><br><span class="line">  [targetPhoto fetchIfNeededInBackgroundWithBlock:^(<span class="built_in">AVObject</span> *object, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="comment">// Show photo view controller</span></span><br><span class="line">    <span class="keyword">if</span> (!error &amp;&amp; [<span class="built_in">AVUser</span> currentUser]) &#123;</span><br><span class="line">      PhotoVC *viewController = [[PhotoVC alloc] initWithPhoto:object];</span><br><span class="line">      [<span class="keyword">self</span><span class="variable">.navController</span> pushViewController:viewController animated:<span class="literal">YES</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当通知到达的时候，你的应用已经在运行，那么你可以通过 <code>application:didReceiveRemoteNotification:fetchCompletionHandler:</code> 方法的 <code>userInfo</code> 参数所使用 dictionary 访问到数据：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">      didReceiveRemoteNotification:(<span class="built_in">NSDictionary</span> *)userInfo</span><br><span class="line">            fetchCompletionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">UIBackgroundFetchResult</span>))handler &#123;</span><br><span class="line">  <span class="comment">// Create empty photo object</span></span><br><span class="line">  <span class="built_in">NSString</span> *photoId = [userInfo objectForKey:<span class="string">@"p"</span>];</span><br><span class="line">  <span class="built_in">AVObject</span> *targetPhoto = [<span class="built_in">AVObject</span> objectWithoutDataWithClassName:<span class="string">@"Photo"</span></span><br><span class="line">                                                          objectId:photoId];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fetch photo object</span></span><br><span class="line">  [targetPhoto fetchIfNeededInBackgroundWithBlock:^(<span class="built_in">AVObject</span> *object, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="comment">// Show photo view controller</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      handler(<span class="built_in">UIBackgroundFetchResultFailed</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="built_in">AVUser</span> currentUser]) &#123;</span><br><span class="line">      PhotoVC *viewController = [[PhotoVC alloc] initWithPhoto:object];</span><br><span class="line">      [<span class="keyword">self</span><span class="variable">.navController</span> pushViewController:viewController animated:<span class="literal">YES</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      handler(<span class="built_in">UIBackgroundFetchResultNoData</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以阅读 <a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Introduction.html#//apple_ref/doc/uid/TP40008194-CH1-SW1" target="_blank" rel="external">Apple 本地化和推送的文档</a> 来更多地了解推送通知。</p>
<h2 id="跟踪推送和应用的打开情况">跟踪推送和应用的打开情况</h2><p>通过 AVAnalytics 你可以跟踪通知和应用的打开情况。添加下列代码到上面例子中的 <code>application:didFinishLaunchingWithOptions:</code> 方法来收集打开信息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (application<span class="variable">.applicationState</span> != <span class="built_in">UIApplicationStateBackground</span>) &#123;</span><br><span class="line">  <span class="comment">// Track an app open here if we launch with a push, unless</span></span><br><span class="line">  <span class="comment">// "content_available" was used to trigger a background push (introduced</span></span><br><span class="line">  <span class="comment">// in iOS 7). In that case, we skip tracking here to avoid double</span></span><br><span class="line">  <span class="comment">// counting the app-open.</span></span><br><span class="line">  <span class="built_in">BOOL</span> preBackgroundPush = ![application respondsToSelector:<span class="keyword">@selector</span>(backgroundRefreshStatus)];</span><br><span class="line">  <span class="built_in">BOOL</span> oldPushHandlerOnly = ![<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(application:didReceiveRemoteNotification:fetchCompletionHandler:)];</span><br><span class="line">  <span class="built_in">BOOL</span> noPushPayload = ![launchOptions objectForKey:<span class="built_in">UIApplicationLaunchOptionsRemoteNotificationKey</span>];</span><br><span class="line">  <span class="keyword">if</span> (preBackgroundPush || oldPushHandlerOnly || noPushPayload) &#123;</span><br><span class="line">    [<span class="built_in">AVAnalytics</span> trackAppOpenedWithLaunchOptions:launchOptions];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传递 nil 或者空白的参数给 <code>trackAppOpenedWithLaunchOptions:</code> 方法只是统计一次标准的应用打开事件（比如不是通过通知打开的应用）。</p>
<p>你可以在 <a href="/stat.html?appid=#/stat/appuse">控制台 /<span class="text-muted">（选择应用）</span>/ 分析 / 行为分析 / 应用使用</a> 里看到通知和应用打开的情况。</p>
<p>请注意，如果你的应用正在运行或者在后台，<code>application:didReceiveRemoteNotification:</code>方法将会处理收到的推送通知。</p>
<div class="callout callout-info">如果你的应用处于运行状态，iOS 系统将不会在系统的通知中心显示推送消息，你可以使用 <code>UILocalNotification</code> 展示一个通知给用户。</div>

<p>如果应用在后台，并且用户点击了通知，那么应用将被带到前台可视，为了跟踪这种通过通知打开应用的情况，你需要在跟踪代码里多作一个检查：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didReceiveRemoteNotification:(<span class="built_in">NSDictionary</span> *)userInfo &#123;</span><br><span class="line">  <span class="keyword">if</span> (application<span class="variable">.applicationState</span> == <span class="built_in">UIApplicationStateActive</span>) &#123;</span><br><span class="line">    <span class="comment">// 此处可以写上应用激活状态下接收到通知的处理代码，如无需处理可忽略</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// The application was just brought from the background to the foreground,</span></span><br><span class="line">    <span class="comment">// so we consider the app as having been "opened by a push notification."</span></span><br><span class="line">    [<span class="built_in">AVAnalytics</span> trackAppOpenedWithRemoteNotificationPayload:userInfo];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用 iOS 7 推送的新特性（包括新的 content-available 功能），你需要实现 iOS 7<br>新加的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">        didReceiveRemoteNotification:(<span class="built_in">NSDictionary</span> *)userInfo</span><br><span class="line">        fetchCompletionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">UIBackgroundFetchResult</span>))completionHandler &#123;</span><br><span class="line">  <span class="keyword">if</span> (application<span class="variable">.applicationState</span> == <span class="built_in">UIApplicationStateActive</span>) &#123;</span><br><span class="line">    <span class="comment">// 此处可以写上应用激活状态下接收到通知的处理代码，如无需处理可忽略</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    [<span class="built_in">AVAnalytics</span> trackAppOpenedWithRemoteNotificationPayload:userInfo];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="跟踪本地通知_(iOS_only)">跟踪本地通知 (iOS only)</h3><p>为了统计跟踪本地通知消息，需要注意以下两种方法都会调用到：</p>
<ul>
<li><code>application:didFinishLaunchingWithOptions:</code></li>
<li><code>-application:didReceiveLocalNotification:</code></li>
</ul>
<p>如果你实现了 <code>application:didReceiveLocalNotification:</code> 这个方法，要注意避免重复统计。</p>
<h4 id="清除_Badge">清除 Badge</h4><p>清除 Badge 数字的最好时机是打开应用的时候。设置当前 installation 的 badge 属性并保存到服务器：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)applicationDidBecomeActive:(<span class="built_in">UIApplication</span> *)application &#123;</span><br><span class="line">    <span class="keyword">int</span> num=application<span class="variable">.applicationIconBadgeNumber</span>;</span><br><span class="line">    <span class="keyword">if</span>(num!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">AVInstallation</span> *currentInstallation = [<span class="built_in">AVInstallation</span> currentInstallation];</span><br><span class="line">        [currentInstallation setBadge:<span class="number">0</span>];</span><br><span class="line">        [currentInstallation saveEventually];</span><br><span class="line">        application<span class="variable">.applicationIconBadgeNumber</span>=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [application cancelAllLocalNotifications];</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>清除 Badge 数字最相关的三个方法是：</p>
<ul>
<li><code>applicationDidBecomeActive:</code></li>
<li><code>application:didFinishLaunchingWithOptions:</code></li>
<li><code>application:didReceiveRemoteNotification:</code></li>
</ul>
<p>请阅读 <a href="http://developer.apple.com/library/ios/#DOCUMENTATION/UIKit/Reference/UIApplicationDelegate_Protocol/Reference/Reference.html" target="_blank" rel="external">UIApplicationDelegate 文档</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="iOS_消息推送开发指南">iOS 消息推送开发指南</h1><p>本文介绍了如何在 iOS 设备中使用 LeanCloud 的推送功能。请先阅读我们的博客文章《<a href="https://blog.leancloud.cn/1163/" target="_]]>
    </summary>
    
      <category term="leancloud" scheme="http://yoursite.com/tags/leancloud/"/>
    
      <category term="leancloud" scheme="http://yoursite.com/categories/leancloud/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 统计 SDK 开发指南]]></title>
    <link href="http://yoursite.com/2015/12/30/avos/ios_statistics/"/>
    <id>http://yoursite.com/2015/12/30/avos/ios_statistics/</id>
    <published>2015-12-29T23:56:29.000Z</published>
    <updated>2015-12-18T10:25:15.451Z</updated>
    <content type="html"><![CDATA[<h1 id="iOS_统计_SDK_开发指南">iOS 统计 SDK 开发指南</h1><h2 id="安装与初始化">安装与初始化</h2><p>使用最新的 SDK 你不需要任何代码上的操作就可以使用统计功能，请参考 <a href="sdk_setup-ios.html">安装指南</a>。</p>
<p>统计功能默认为打开，并且可以在线配置。进入应用的 <a href="/stat.html?appid=#/statconfig/trans_strategoy">控制台 / 分析 / 统计设置<span class="text-muted">（左下角）</span> / 数据发送策略</a> 在线更改 SDK 端的数据报告发送策略。</p>
<p>建议使用 AV_BATCH 形式，减少应用与网络的交互，为用户节约流量。如果不设置 channelId，默认会是 <code>@&quot;App Store&quot;</code> 渠道。</p>
<p>默认 <strong>启动时发送</strong> 策略：应用程序每次会在启动时会向服务器发送一次消息，在应用程序过程中产生的所有统计信息（包括自定义事件和本次使用时长）都会在下次启动时候发送。如果应用程序启动时处在不联网状态，那么消息将会缓存在本地，下次再尝试发送。</p>
<p>如果需要修改渠道名称 channelId，请使用下面的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVAnalytics</span> setChannel:<span class="string">@"越狱市场"</span>];</span><br></pre></td></tr></table></figure>
<p>到此，你已经可以使用基本的统计功能。</p>
<h2 id="页面访问路径统计">页面访问路径统计</h2><p>你可以统计每个 View 停留时长，请确保配对使用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">	[<span class="keyword">super</span> viewWillAppear:animated];</span><br><span class="line">  [<span class="built_in">AVAnalytics</span> beginLogPageView:<span class="string">@"PageOne"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewWillDisappear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">   [<span class="keyword">super</span> viewWillDisappear:animated];</span><br><span class="line">   [<span class="built_in">AVAnalytics</span> endLogPageView:<span class="string">@"PageOne"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想自己传递时长，请使用下面的方法（单位为秒）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)logPageView:(<span class="built_in">NSString</span> *)pageName seconds:(<span class="keyword">int</span>)seconds;</span><br></pre></td></tr></table></figure>
<h2 id="使用自定义事件">使用自定义事件</h2><p>自定义事件方便你更加灵活的了解用户的行为，并且可以在 <a href="/stat.html?appid=#/stat/customevent">控制台</a> 看到实时的数据。</p>
<div class="callout callout-info">但是要特别强调的是，自定义事件名（<code>event_id</code>）应该尽量保持为静态值，否则可能出现数目庞大的自定义事件列表，而无法达到了解与分析用户行为的目的。</div>

<p>例如，如果要统计用户喜欢在每周几喜欢看做某件事情，比如查看彩票开奖，我们应该统一用一个事件名，比如 <code>check</code>，然后给这个事件设置周几的 <code>label</code>。这样在控制台打开 check 的自定义事件统计中，就可以看到一周每天的分布情况了。使用方法见 <a href="#多标签事件">多标签事件</a>。</p>
<p>你可以通过以下几个接口来调用事件记录：</p>
<h3 id="简单事件">简单事件</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+(<span class="keyword">void</span>)event:(<span class="built_in">NSString</span> *)event_id;</span><br></pre></td></tr></table></figure>
<p>将统计 event_id 对应事件的发生次数、变化趋势，例如广告点击、短信数量等等。event_id 为当前统计的事件 ID，你可以在程序里直接定义，无需配置。例如，监测应用里 like 的点击次数，事件 ID 为 <code>like_click</code>，那么需要在每次 like 点击后的代码调用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVAnalytics</span> event:<span class="string">@"like_click"</span>]; <span class="comment">// 通知服务器一个 like 点击事件。</span></span><br></pre></td></tr></table></figure>
<h3 id="多标签事件">多标签事件</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)event:(<span class="built_in">NSString</span> *)event_id label:(<span class="built_in">NSString</span> *)label;</span><br></pre></td></tr></table></figure>
<p>除了能够统计 event_id 所对应事件的发生次数、变化趋势外，还能统计此事件中具体标签所占的比例，label 为当前标签。<br>例如：在应用程序中，你可以定义一个事件，其 ID 为 <code>like</code>，针对每个 like 事件，你可以根据用户的不同，定义不同的 label，比如对于女性用户，你可以定义一个 <code>label_female</code>，对于男性用户使用 <code>label_male</code>，通过我们的后台页面，你可以观察到不同性别的用户对于特定内容所 like 的比例。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVAnalytics</span> event:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"like"</span>] label:<span class="string">@"label_female"</span>]; <span class="comment">//type 是变量，表示用户类型</span></span><br></pre></td></tr></table></figure>
<h3 id="事件累计">事件累计</h3><p>在应用程序中某些自定义事件可能会被频繁触发，例如用户点击某个按钮，但是还是希望统计为一次事件。开发者可以在程序中维护一个计数器，这样某个事件被多次触发但只需要生成一个消息，这个消息中包括该事件被触发的次数。为了支持这个功能，这里我们定义了两个接口：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)event:(<span class="built_in">NSString</span> *)event_id acc:(<span class="built_in">NSInteger</span>)acc;</span><br><span class="line">+ (<span class="keyword">void</span>)event:(<span class="built_in">NSString</span> *)event_id label:(<span class="built_in">NSString</span> *)label acc:(<span class="built_in">NSInteger</span>)acc;</span><br></pre></td></tr></table></figure>
<p>参数acc是对应事件 （和对应标签）被触发的次数。</p>
<h3 id="使用多渠道统计">使用多渠道统计</h3><p>你可以选择多种程序分发渠道，例如某 Cydia 源，或其他网站，可以为不同渠道（提供不同）的软件包进行分发渠道的设定，以便统计终端用户得到程序的来源。如果你只有苹果官方 App Store 一个分发渠道，则不再需要做设定，LeanCloud SDK 默认渠道标记为 <code>App Store</code>。</p>
<p>例如你在 360 发布，需要统计 360 渠道：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVAnalytics</span> startWithReportPolicy:<span class="built_in">AV_BATCH</span> channelId:<span class="string">@"360"</span>];</span><br></pre></td></tr></table></figure>
<p>若通过小米发布，需要统计同步推渠道：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVAnalytics</span> startWithReportPolicy:<span class="built_in">AV_BATCH</span> channelId:<span class="string">@"xiaomi"</span>];</span><br></pre></td></tr></table></figure>
<h2 id="获取在线参数">获取在线参数</h2><p>从 SDK 1.4.2 开始，你可以在应用中动态添加在线参数。通过在线参数，你可以控制你的应用行为，而不需要再次发布应用。进入 <a href="/devcomponent.html?appid=#/component/custom_param">控制台 / 组件 / 自定义参数设置</a> 中配置自定义在线参数。在线配置参数会在 SDK 启动后，自动从后台定义的数据表中获取。</p>
<p>从 SDK 1.4.2 开始，你可以使用带回调版本的在线查询 API，比如如果你在后台定义了在线参数 <code>&lt;k1, v1&gt;</code>，你可以通过以下方法来获取：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVAnalytics</span> updateOnlineConfigWithBlock:^(<span class="built_in">NSDictionary</span> *dict, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">     <span class="keyword">if</span> (error == <span class="literal">nil</span>) &#123;</span><br><span class="line">         <span class="comment">// 从 dict 中读取参数，dict["k1"] 值应该为 v1</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>如果想要测试时发送实时的数据，也可以在上面这个 block 中设置。</p>
<h2 id="禁用统计功能">禁用统计功能</h2><p>从 SDK 2.5.5 开始，你可以添加如下代码禁止统计功能（默认启用统计功能），这样可以避免测试数据污染线上数据。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVAnalytics</span> setAnalyticsEnabled:<span class="literal">NO</span>];</span><br></pre></td></tr></table></figure>
<h2 id="数据时效性">数据时效性</h2><p>在控制台的 <strong>分析</strong> 页面中，有些报告可以展示实时数据，有些报告则依靠 <a href="leaninsight_guide.html">离线数据</a> 进行分析，因此有时你会看不到当天的数据。</p>
<p>如果当前页面中存在 <strong>日期选择</strong> 选项（通常在页面右上角），你可以以此判断当前的统计结果是否有延迟。如果 <strong>结束日期</strong> 显示为 <strong>当日日期</strong> 或在其下拉菜单中有「今日」选项，即为实时数据；反之则为离线数据（如下图所示），要推迟一天才能看到当日的情况。</p>
<p><img src="../images/analytics_datepicker_for_offline_data.png" alt="" width="231" height="256"></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="iOS_统计_SDK_开发指南">iOS 统计 SDK 开发指南</h1><h2 id="安装与初始化">安装与初始化</h2><p>使用最新的 SDK 你不需要任何代码上的操作就可以使用统计功能，请参考 <a href="sdk_setup-ios.html">]]>
    </summary>
    
      <category term="leancloud" scheme="http://yoursite.com/tags/leancloud/"/>
    
      <category term="leancloud" scheme="http://yoursite.com/categories/leancloud/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 崩溃报告使用指南]]></title>
    <link href="http://yoursite.com/2015/12/30/avos/ios_crashreporting_guide/"/>
    <id>http://yoursite.com/2015/12/30/avos/ios_crashreporting_guide/</id>
    <published>2015-12-29T23:56:29.000Z</published>
    <updated>2015-12-18T10:24:12.068Z</updated>
    <content type="html"><![CDATA[<h1 id="iOS_崩溃报告使用指南">iOS 崩溃报告使用指南</h1><p>崩溃报告可以自动收集用户端产生的各种异常崩溃信息，包括完整的调用堆栈、设备信息、应用信息等等。如果还没有安装 LeanCloud iOS SDK，请阅读 <a href="/start.html">快速入门</a> 来获得该 SDK，并在 Xcode 中运行和熟悉示例代码。</p>
<h2 id="启用">启用</h2><p>要启用崩溃报告功能，需要将 AVOSCloudCrashReporting.framework 添加到项目的依赖库列表，然后在 AppDelegate 之中，在 LeanCloud SDK 初始化之前添加如下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enable Crash Reporting</span></span><br><span class="line">[<span class="built_in">AVOSCloudCrashReporting</span> enable];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setup AVOSCloud</span></span><br><span class="line">[<span class="built_in">AVOSCloud</span> setApplicationId:<span class="string">@"&#123;&#123;appid&#125;&#125;"</span> clientKey:<span class="string">@"&#123;&#123;appkey&#125;&#125;"</span>];</span><br></pre></td></tr></table></figure>
<p>崩溃报告打开后，应用的崩溃信息会发送到 LeanCloud 云端，具体内容可在 <a href="/stat.html?appid=#/stat/crashreport">控制台 / 分析 / 错误分析</a> 里看到。</p>
<h2 id="符号化">符号化</h2><p>将应用每个版本的符号文件上传至 LeanCloud，会有助于 LeanCLoud 后台正确解析崩溃堆栈信息，更准确地定位问题，因此这一步骤非常重要。</p>
<p>上传符号文件有两种方式：每次构建应用时自动上传和手动上传。我们推荐使用自动上传，这样开发者就不需要在每次发布版本时，还要记着去上传符号文件。实现符号文件<strong>自动上传</strong>的步骤如下：</p>
<p>安装客户端工具（如果出现权限错误，可以在命令前面加上 <code>sudo</code>）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gem update --system</span><br><span class="line">gem install --no-wrappers -n /usr/<span class="built_in">local</span>/bin leancloud</span><br></pre></td></tr></table></figure>
<p>在应用的 Targets 中，选择 <strong>Build Settings</strong> &gt; <strong>Build Options</strong> &gt; <strong>Debug Information Format</strong>，将其设置为 <strong>DWARF with dSYM File</strong>；再打开 <strong>Build Phases</strong> &gt;<span class="text-muted">（点击 + 号）</span>&gt; <strong>New Run Script Phase</strong>，添加一个 <strong>Run Script</strong> 步骤：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">leancloud upload_symbol \</span><br><span class="line"><span class="operator">-f</span> <span class="string">"<span class="variable">$&#123;DWARF_DSYM_FOLDER_PATH&#125;</span>/<span class="variable">$&#123;DWARF_DSYM_FILE_NAME&#125;</span>"</span> \</span><br><span class="line">-i <span class="string">"&#123;&#123;appid&#125;&#125;"</span> \</span><br><span class="line">-k <span class="string">"&#123;&#123;appkey&#125;&#125;"</span></span><br></pre></td></tr></table></figure>
<p>如果只想在 Archive 发布时运行这个脚本，可以勾选 <strong>Run script only when installing</strong>，这样可以加快调试时 Build 的速度。</p>
<p>要手动上传符号文件，则使用：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">leancloud upload_symbol \</span><br><span class="line"><span class="operator">-f</span> <span class="string">"&lt;dSYM/xcarchive/DWARF 请按下面提示替换本路径&gt;"</span> \</span><br><span class="line">-i <span class="string">"&#123;&#123;appid&#125;&#125;"</span> \</span><br><span class="line">-k <span class="string">"&#123;&#123;appkey&#125;&#125;"</span></span><br></pre></td></tr></table></figure>
<p>符号文件将默认上传到中国节点。如果你的应用使用了中国之外的其他节点，例如美国节点，需要通过 <code>-r</code> 或 <code>--region</code> 选项来设置：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">leancloud upload_symbol -r us \</span><br><span class="line"><span class="operator">-f</span> <span class="string">"&lt;dSYM/xcarchive/DWARF 请按下面提示替换本路径&gt;"</span> \</span><br><span class="line">-i <span class="string">"&#123;&#123;appid&#125;&#125;"</span> \</span><br><span class="line">-k <span class="string">"&#123;&#123;appkey&#125;&#125;"</span></span><br></pre></td></tr></table></figure>
<p>目前支持以下节点：</p>
<ul>
<li><strong>cn</strong>：中国</li>
<li><strong>us</strong>：美国</li>
</ul>
<p>符号文件的存放位置，与你的发布流程有关，具体为：</p>
<ul>
<li><p><strong>xcarchive 文件</strong>：对应用进行 Archive 后会生成一个 .xcarchive 文件，在 Xcode 中打开 <strong>Window</strong> / <strong>Organizer</strong> / <strong>Archives</strong> 选项卡里可以看到它的位置。</p>
</li>
<li><p><strong>dSYM 文件</strong>：一般仅在使用 Release 或 Archiving 构建应用时产生，可以在 /Xcode/DerivedData 文件夹下，与生成的 .app 同级的文件夹里找到。</p>
</li>
<li><p><strong>DWARF 文件</strong>：在路径的最底层，它可以通过 strip 应用生成的二进制文件来获得。</p>
</li>
</ul>
<p>请参考以下路径结构，应用文件名为 Demo.app：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">├── Build</span><br><span class="line">    ├── Intermediates</span><br><span class="line">        ├── ArchiveIntermediates</span><br><span class="line">            └── Demo</span><br><span class="line">                ├── BuildProductsPath</span><br><span class="line">                    └── Release-iphoneos</span><br><span class="line">                        ├── Demo<span class="class">.app</span> -&gt; /Users/admin/Library/Developer/Xcode/DerivedData/Demo-dkvwhbscbgyeoldhsxxzmorfqmyf/Build/Intermediates/ArchiveIntermediates/Demo/InstallationBuildProductsLocation/Applications/Demo<span class="class">.app</span></span><br><span class="line">                        └── Demo<span class="class">.app</span><span class="class">.dSYM</span></span><br><span class="line">                            └── Contents</span><br><span class="line">                                ├── Info<span class="class">.plist</span></span><br><span class="line">                                └── Resources</span><br><span class="line">                                    └── DWARF</span><br><span class="line">                                        └── Demo</span><br></pre></td></tr></table></figure>
<p>如果在发布应用时忘了上传符号文件，可以手动来上传。如果一个崩溃报告没有对应的符号文件，系统会提示要符号化。</p>
<h2 id="测试">测试</h2><p>崩溃报告启用之后，要测试崩溃信息是否能发送到 LeanCloud 云端，可以在 view controller 或 AppDelegate 中添加一个 <code>crash</code> 方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)crash &#123;</span><br><span class="line">    [<span class="built_in">NSException</span> raise:<span class="built_in">NSGenericException</span> format:<span class="string">@"只是测试，模拟一条崩溃信息。"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后把下面的调用代码插入到主 view controller 的 <code>viewDidLoad</code> 方法中，或 AppDelegate 的 <code>application:didFinishLaunchingWithOptions:</code> 方法中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(crash) withObject:<span class="literal">nil</span> afterDelay:<span class="number">5.0</span>];</span><br></pre></td></tr></table></figure>
<p>接下来的步骤：</p>
<ol>
<li>build、run，然后 stop 应用；</li>
<li>在 Home 界面点开应用（不要使用调试器开启应用，因为调试器开启时不会收集崩溃信息）；</li>
<li>等待应用崩溃；</li>
<li>再次运行应用。应用将在启动时自动将崩溃报告发送给 LeanCloud 云端。</li>
</ol>
<p>这时打开应用控制台的 <a href="/stat.html?appid=#/stat/crashreport">错误分析</a>，就会看到刚才的崩溃信息。</p>
<blockquote>
<p>注意：崩溃信息可能会延迟几分钟显示。</p>
</blockquote>
<h2 id="流程">流程</h2><p>使用崩溃报告可以极大地改进应用质量，提升用户体验。我们推荐使用以下流程来有效地修复应用崩溃问题：</p>
<ol>
<li>确认要修复的崩溃；<br><br>后台的错误分析列表，可以显示出崩溃发生的次数。由此，你可以分析出哪项崩溃对应用影响最大，对其进行优先修复。点击每条崩溃记录可以查看到更详细的信息，包括调用堆栈、系统版本、设备类型和受影响的应用版本等等。</li>
<li>修复崩溃；<br><br>调试代码，修复崩溃问题。</li>
<li>构建新的版本；</li>
<li>标记已修复的崩溃，向 App Store 发布新版本；<br><br>标记为「已修复」的崩溃不会在默认的列表中出现。如果同样的崩溃在新版本中再次出现，那么这条崩溃记录将自动恢复成「未修复」状态，并且重新出现在默认列表里面。</li>
<li>重复以上步骤，不断改进应用。</li>
</ol>
<h2 id="排错">排错</h2><p><strong>为什么编译的时候会报错：Undefined symbols for architecture i386: “std::<strong>1::basic_string&lt;char, std::</strong>1::char_traits<char>…？</char></strong></p>
<p>这是在项目依赖里面缺少 libc++.dylib 库。打开项目的 <strong>TARGETS</strong> / <strong>General</strong> / <strong>Linked Frameworks and Libraries</strong>，添加 libc++.dylib 即可。</p>
<p><strong>为什么我的崩溃没有在后台显示？</strong></p>
<p>你的应用可能没有向 LeanCloud 云端发送崩溃报告。需要检查：</p>
<ul>
<li>确认在 LeanCloud SDK 初始化之前开启了崩溃报告。</li>
<li>如果正在测试崩溃报告，要确认应用不是通过调试器运行的；需要执行 build、run、stop 之后，再在 Home 界面点开应用。</li>
<li>崩溃信息是在崩溃发生之后、下次应用启动之时发送的，确保应用不会在崩溃信息发送之前再次崩溃。如果是在调试崩溃报告，可以添加一段延时做为保障。</li>
<li>确保没有使用其他崩溃报告的库，否则会互相干扰。</li>
</ul>
<p><strong>为什么我的崩溃没有符号化？</strong></p>
<p>你可能没有上传与应用版本对应的符号文件。请检查：</p>
<ul>
<li>如果设置了自动上传符号文件，切换到 Xcode 的 Report Navigator（Command + 8），验证一下上传是否正常。</li>
<li>确认日志正常，上传过程没有错误。</li>
<li>如果为之前没有符号化的崩溃上传了对应的符号文件，当同一崩溃再次发生时它就会被符号化；而之前没有符号化的崩溃信息不会再被符号化了。所以，这时可以把之前的崩溃记录标记为「已解决」并等待其再次发生。</li>
<li>如果使用了自定义的动态链接框架（dynamic framework），并且部分堆栈信息没有符号化，请确认所有动态链接框架以及主应用的符号文件都已经上传。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="iOS_崩溃报告使用指南">iOS 崩溃报告使用指南</h1><p>崩溃报告可以自动收集用户端产生的各种异常崩溃信息，包括完整的调用堆栈、设备信息、应用信息等等。如果还没有安装 LeanCloud iOS SDK，请阅读 <a href="/start.html"]]>
    </summary>
    
      <category term="leancloud" scheme="http://yoursite.com/tags/leancloud/"/>
    
      <category term="leancloud" scheme="http://yoursite.com/categories/leancloud/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[.NET 数据存储开发指南]]></title>
    <link href="http://yoursite.com/2015/12/30/avos/dotnet_guide/"/>
    <id>http://yoursite.com/2015/12/30/avos/dotnet_guide/</id>
    <published>2015-12-29T23:56:29.000Z</published>
    <updated>2015-12-18T10:23:08.806Z</updated>
    <content type="html"><![CDATA[<h1 id="-NET_数据存储开发指南">.NET 数据存储开发指南</h1><h2 id="简介">简介</h2><p>目前我们的 .NET 数据存储支持如下运行时：</p>
<ul>
<li>Windows Phone Silverlight （8.0 &amp; 8.1）</li>
<li>Windows Desktop .NET Framework 4.5+</li>
<li>Xamarin Form 1.4+</li>
<li>Xamarin iOS 8+</li>
<li>Xamarin Android 5+</li>
</ul>
<p>尚未发布但是已在计划内的如下：</p>
<ul>
<li>Windows Runtime （for Windows 10）</li>
</ul>
<p>文档中涉及的语法以及接口均对所有运行时有效。</p>
<h2 id="快速入门">快速入门</h2><p>建议您在阅读本文档之前，阅读我们提供的<a href="/start.html">快速入门</a>文档，获取 LeanCloud 使用的配置和第一印象。</p>
<h2 id="安装">安装</h2><p>为了支持实时聊天，LeanCloud SDK for .NET 依赖于几个开源的库，所以推荐开发者从 <a href="https://www.nuget.org/packages/LeanCloud/1.0.1.2-pre" target="_blank" rel="external">Nuget</a> 上下载我们的 SDK。</p>
<h2 id="介绍">介绍</h2><p>LeanCloud的 .NET SDK 依赖于微软提供的<a href="http://msdn.microsoft.com/zh-cn/library/hh873175.aspx" target="_blank" rel="external">基于任务的异步模式 (TAP)</a>的方式，所以您最好有 .NET Framework 4.5 的编程经验，或者对 .NET Framework 4.5 的新 API 有所了解。</p>
<h2 id="应用">应用</h2><p>在 LeanCloud 的每个应用有自己的 ID 和客户端密钥，在客户端代码中应该用他们来初始化 SDK。<br>LeanCloud 的每一个账户都可以创建多个应用。同一个应用可以分别在测试环境和生产环境部署不同的版本。</p>
<h3 id="初始化">初始化</h3><p>在 LeanCloud 中，几乎所有平台下的接口我们都尽量保持一致，目的就是为了降低开发者的开发成本，所以在初始化的时候我们几乎都是遵循在 <code>AVClient</code> 这个类下有一个叫做 <code>Initialize</code>（不同平台的编程规范可能不一样，但是在 C# 语言风格中一般方法名的首字母都是大写）的方法，这个方法目前有 2 个重载：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AVClient.Initialize(string applicationId, string appKey)<span class="comment">;</span></span><br><span class="line">传入您的 <span class="escape">`A</span>pp ID<span class="escape">` </span>以及 <span class="escape">`A</span>pp Key<span class="escape">`，</span>默认访问的是 LeanCloud 的中国节点。</span><br></pre></td></tr></table></figure>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AVClient<span class="built_in">.</span>Initialize(<span class="built_in">string</span> applicationId, <span class="built_in">string</span> appKey, AVRegion region);</span><br><span class="line">除了传入您的 <span class="string">`App ID`</span> 以及 <span class="string">`App Key`</span>之外，指定 LeanCloud 的服务节点，现在 AVRegion 仅支持 <span class="literal">CN</span> 以及 US 节点。</span><br></pre></td></tr></table></figure>
<p>注意，目前 LeanCloud 的节点上的数据是相互隔离的，换言之，您在中国节点上注册的应用无法访问美国节点，反之亦然。</p>
<h2 id="对象">对象</h2><h3 id="AVObject">AVObject</h3><p>在 LeanCloud 上，数据存储是围绕 <code>AVObject</code> 进行的。每个 <code>AVObject</code> 都包含了与 JSON 兼容的 key-value 对应的数据。数据是 schema-free 的，你不需要在每个 AVObject 上提前指定存在哪些键，只要直接设定对应的 key-value 即可。<br>key 必须是字母数字或下划线组成的字符串。值可以是字符串，数字，布尔值，甚至数组和字典。<br>每个 <code>AVObject</code> 都必须有一个类（Class）名称，以便于您区分不同类型的数据。例如，我们可以将对应的体育运动称为 <code>Sport</code>。我们建议的您将类和 key 按照 <code>NameYourClassesLikeThis</code> 以及 <code>nameYourKeysLikeThis</code> 这样的惯例命名。</p>
<h3 id="保存对象">保存对象</h3><p>接下来，你需要将上文中的 <code>Sport</code> 存储到 LeanCloud 的服务。LeanCloud 的相关接口和 <code>IDictionary&lt;string, object&gt;</code> 类似，但只有调用 <code>SaveAsync</code> 方法时才会实际保存到服务器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AVObject football =<span class="keyword">new</span> AVObject(<span class="string">"Sport"</span>);</span><br><span class="line">football[<span class="string">"totalTime"</span>] = <span class="number">90</span>;</span><br><span class="line">football[<span class="string">"name"</span>] = <span class="string">"Football"</span>;</span><br><span class="line">Task saveTask = football.SaveAsync();</span><br><span class="line">await saveTask;</span><br></pre></td></tr></table></figure>
<p>在运行此代码后，您应当了解保存动作是否已经生效 。为了确保数据被保存，您可以在 LeanCloud 上的<a href="/data.html?appid=&lt;!--￼72--">数据管理</a>中查看您应用的数据。</p>
<p>此处有两件事情需要特别注明。<br>首先，在运行此代码之前，您不必配置或设置一个称为 「Sport」 的新类。LeanCloud 会自动创建这个类。</p>
<p>此外，为了更方便的使用 LeanCloud，还有其它几个字段您不需要事先指定。<code>objectId</code> 是为每个对象自动生成的唯一的标识符；<code>createdAt</code> 和 <code>updatedAt</code> 分别代表每个对象在 LeanCloud 中创建和最后修改的时间并会被自动填充。<br>在您执行保存操作之前，这些字段不会被自动保存到 <code>AVObject</code> 中。</p>
<h3 id="在后台工作">在后台工作</h3><p>关于异步编程，一直是每一种语言和平台上必须直面的问题，牵扯到线程，进程的问题大多数都是程序员很头疼的一个难点，但是在 .NET Framework 4.5 之后迎来了一种新的变革，那就是<a href="http://msdn.microsoft.com/zh-cn/library/hh873175.aspx" target="_blank" rel="external">基于任务的异步模式 (TAP)</a>。当然本篇指南的重点不是讲解TAP异步模式的好处，只是希望开发者能够足够的掌握TAP实现异步用法。</p>
<p>LeanCloud .NET SDK 都采用了 TAP 的方式去实现把所有跟 LeanCloud 服务端交互的部分放在后台去进行，这样可以让开发者可以花更多时间去做客户端应该做的事情，而把跟服务端交互的各种进程管理放权给 LeanCloud SDK 去做。</p>
<h3 id="更新对象">更新对象</h3><p>更新对象和保存对象有点相似，只是更新对象会覆盖同名属性的值，在调用 <code>SaveAsync</code> 之后会发送到服务端生效。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var peter = <span class="keyword">new</span> AVObject(<span class="string">"Character"</span>)</span><br><span class="line">&#123;</span><br><span class="line">	&#123; <span class="string">"age"</span>, <span class="number">37</span> &#125;,</span><br><span class="line">	&#123; <span class="string">"name"</span>, <span class="string">"Peter Burke"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"from"</span>, <span class="string">"White Collar"</span> &#125;,</span><br><span class="line">	&#123; <span class="string">"skills"</span>, <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt; &#123; <span class="string">"FBI"</span>, <span class="string">"Agent Leader"</span> &#125; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">await peter.SaveAsync().ContinueWith(t =&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 保存成功之后，修改一个已经在服务端生效的数据，这里我们修改age</span></span><br><span class="line">	<span class="comment">// LeanCloud 只会针对指定的属性进行覆盖操作，本例中的name不会被修改</span></span><br><span class="line">	peter[<span class="string">"age"</span>] = <span class="number">40</span>;</span><br><span class="line">	peter.SaveAsync();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="获取对象">获取对象</h3><p>如果确定了一个 <code>AVObject</code> 的 <code>objectId</code> 可以通过如下代码构造一个 <code>AVObject</code> 然后通过 <code>FetchAsync</code> 从服务端把数据加载到本地：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AVObject <span class="property">character</span> = AVObject.CreateWithoutData(<span class="string">"Character"</span>, <span class="string">"549818e0e4b096e3561a6abd"</span>);</span><br><span class="line">await <span class="property">character</span>.FetchAsync();</span><br></pre></td></tr></table></figure>
<h3 id="删除对象">删除对象</h3><p>如果想删除某个对象可以直接调用 <code>AVObject</code> 的 <code>DeleteAsync</code> 方法。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">await myObject.<span class="title">DeleteAsync</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果仅仅想删除某个对象的某一个属性，可以调用 <code>Remove</code> 方法。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行下面的语句会将age字段置为空</span></span><br><span class="line">myObject.Remove(<span class="string">"age"</span>);</span><br><span class="line"><span class="comment">// 将删除操作发往服务器生效。</span></span><br><span class="line"><span class="function">await myObject.<span class="title">SaveAsync</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="关系">关系</h3><p>软件程序就是抽象现实中的对象之间的关系在计算机世界里面的解释和展现。有对象必然就会有对象之间的关系，在 LeanCloud 中也给出了传统关系型的解决方案，并且简化了代码，使得代码简洁易维护。<br>假设这样一种场景，做一款时髦的相亲社交软件，男孩会在自己的资料里面标明自己喜欢的女生类型，于是有如下代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVObject</span> girlType = new <span class="built_in">AVObject</span> (<span class="string">"GirType"</span>);</span><br><span class="line">girlType [<span class="string">"typeName"</span>] = <span class="string">"Hot"</span>;</span><br><span class="line"><span class="built_in">AVObject</span> beckham = new <span class="built_in">AVObject</span> (<span class="string">"Boy"</span>);</span><br><span class="line">beckham[<span class="string">"name"</span>]=<span class="string">"David Beckham"</span>;</span><br><span class="line">beckham [<span class="string">"age"</span>] = <span class="number">38</span>;</span><br><span class="line">beckham [<span class="string">"focusType"</span>] = girlType;</span><br><span class="line">await beckham<span class="variable">.SaveAsync</span> ();<span class="comment">//保存beckham的时候会自动将girlType也保存到服务器。</span></span><br></pre></td></tr></table></figure>
<p>当然必然存在一种方法就是将已存在的对象通过<code>ObjectId</code>将它于目标对象进行关联：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beckham[<span class="string">"focusType"</span>] = <span class="built_in">AVObject</span><span class="variable">.CreateWithoutData</span>(<span class="string">"GirType"</span>, <span class="string">"5372d119e4b0d4bef5f036ae"</span>);</span><br></pre></td></tr></table></figure>
<p>值得注意的地方是，当需要从 LeanCloud 上读取数据的时候，默认的 fetch 方法是<code>不会加载关联数据类型的</code>，直到像如下代码执行之后，这些关联数据字段（如上实例中 Boy 的 focusType 字段）才会被实例化。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">AVObject</span> focusType = beckham.Get&lt;AVObject&gt;(<span class="string">"focusType"</span>);</span><br><span class="line"><span class="title">await</span> focusType.FetchIfNeededAsync();</span><br></pre></td></tr></table></figure>
<h2 id="查询">查询</h2><h3 id="AVQuery-GetAsync">AVQuery.GetAsync</h3><p>此方法对应的理解是根据 <code>objectId</code> 查询指定的一条数据，<code>GetAsync</code> 方法的参数为一个 <code>objectId</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span>&lt;<span class="built_in">AVObject</span>&gt; query = <span class="built_in">AVObject</span><span class="variable">.GetQuery</span>(<span class="string">"Character"</span>);</span><br><span class="line">           <span class="built_in">AVObject</span> character = await query<span class="variable">.GetAsync</span>(<span class="string">"549818e0e4b096e3561a6abd"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="构建_AVQuery_的注意事项">构建 AVQuery 的注意事项</h3><p>根据 <code>objectId</code> 查询，显然无法满足正常的需求，所以SDK提供了许多简化了操作的查询。<br>首先需要明确最核心的一点，在.NET SDK中，<code>AVQuery</code> 对象的所有带有 <code>Where</code> 开头方法，以及查询范围限定类的方法(<code>Skip||Limit||ThenBy||Include</code>等)都会返回一个全新的对象，它并不是在原始的 <code>AVQuery</code> 对象上修改内部属性。比如:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span>&lt;<span class="built_in">AVObject</span>&gt; query=new <span class="built_in">AVQuery</span>&lt;<span class="built_in">AVObject</span>&gt;(<span class="string">"Character"</span>)</span><br><span class="line">query<span class="variable">.WhereEqualTo</span> (<span class="string">"age"</span>, <span class="number">37</span>);<span class="comment">//注意：这是错误的！！！</span></span><br><span class="line">await query<span class="variable">.FindAsync</span> ();</span><br></pre></td></tr></table></figure>
<p><strong> 以上这一小段代码是用户经常会犯的错误案例，请勿拷贝到您的项目 </strong></p>
<p>以上这段代码将返回 <code>Character</code> 中所有的数据，并不会返回所设想的那样 <code>age</code> 等于37数据。<br>正确地写法应该是：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span>&lt;<span class="built_in">AVObject</span>&gt; query=new <span class="built_in">AVQuery</span>&lt;<span class="built_in">AVObject</span>&gt;(<span class="string">"Character"</span>)<span class="variable">.WhereEqualTo</span> (<span class="string">"age"</span>, <span class="string">"37"</span>);</span><br></pre></td></tr></table></figure>
<p>以此类推，所有复合条件查询的构造都应该遵循用<code>.</code>这个符号进行链式创建出来的 <code>AVQuery&lt;T&gt;</code>，比如，查找所有 <code>age</code> 等于37，并且 <code>name</code> 包含 <code>peter</code> 的<code>Character</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span>&lt;<span class="built_in">AVObject</span>&gt; query = new <span class="built_in">AVQuery</span>&lt;<span class="built_in">AVObject</span>&gt; (<span class="string">"Character"</span>)<span class="variable">.WhereEqualTo</span> (<span class="string">"age"</span>, <span class="number">37</span>)<span class="variable">.WhereContains</span>(<span class="string">"name"</span>,<span class="string">"peter"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="基本查询">基本查询</h3><p><code>AVQuery&lt;T&gt;.WhereEqualTo</code> 基本查询逻辑上可以理解为类似于sql语句中的</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Persons <span class="keyword">WHERE</span> FirstName=<span class="string">'Bush'</span></span><br></pre></td></tr></table></figure>
<p>的<code>=</code>操作，如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span>&lt;<span class="built_in">AVObject</span>&gt; query=new <span class="built_in">AVQuery</span>&lt;<span class="built_in">AVObject</span>&gt;(<span class="string">"Persons"</span>)<span class="variable">.WhereEqualTo</span> (<span class="string">"FirstName"</span>, <span class="string">"Bush"</span>);</span><br><span class="line">await query<span class="variable">.FindAsync</span> ()<span class="variable">.ContinueWith</span> (t =&gt; &#123;</span><br><span class="line">	IEnumerable&lt;<span class="built_in">AVObject</span>&gt; persons=t<span class="variable">.Result</span>;</span><br><span class="line">	<span class="keyword">int</span> sum=persons<span class="variable">.Count</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="查询条件">查询条件</h3><p>如果要过滤掉特定键的值时可以使用 whereNotEqualTo 方法。比如需要查询 <code>name</code>不等于 <code>Peter Burke</code> 的数据时可以这样写：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.<span class="variable">WhereNotEqualTo</span> (<span class="string">"name"</span>, <span class="string">"Peter Burke"</span>);</span><br></pre></td></tr></table></figure>
<p>同时包含多个约束条件的查询，可以这样写：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.WhereNotEqualTo (<span class="string">"name"</span>, <span class="string">"Peter Burke"</span>);</span><br><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.WhereGreaterThan(<span class="string">"age"</span>, 18);<span class="comment">//这样书写是为了文档阅读方便，但是我们还是比较推荐上一节介绍的链式表达式去创建AVQuery</span></span><br></pre></td></tr></table></figure>
<p>以此类推，可以添加多个约束条件，他们彼此是<code>AND</code>的关系。<br>有些需求中，也许只要较少的几条查询结果即可，这种情况下，可以通过设定查询结果的数量：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.<span class="variable">Limit</span> (<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>在数据较多的情况下，分页显示数据是比较合理的解决办法，limit 默认 100，最大1000，在 0 到 1000 范围之外的都强制转成默认的 100。<br>Skip 方法可以做到跳过首次查询的多少条数据来实现分页的功能。比如，一页显示10条数据，那么跳过前10个查询结果的方法就是：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.<span class="variable">Skip</span> (<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>对应数据的排序，如数字或字符串，你可以使用升序或降序的方式来控制查询数据的结果顺序：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 age 字段升序显示数据</span></span><br><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.OrderBy(<span class="string">"age"</span>);</span><br><span class="line"><span class="comment">// 根据 age 字段降序显示数据</span></span><br><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.OrderByDescending(<span class="string">"age"</span>);</span><br><span class="line"><span class="comment">//各种不同的比较查询：</span></span><br><span class="line"><span class="comment">// 年龄 &lt; 37</span></span><br><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.WhereLessThan(<span class="string">"age"</span>, 37);</span><br><span class="line"><span class="comment">// 年龄 &lt;= 37</span></span><br><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.WhereLessThanOrEqualTo(<span class="string">"age"</span>, 37);</span><br><span class="line"><span class="comment">// 年龄 &gt; 37</span></span><br><span class="line"><span class="keyword">query</span>.WhereGreaterThan(<span class="string">"age"</span>, 37);</span><br><span class="line"><span class="comment">// 年龄 &gt;= 37</span></span><br><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.WhereGreaterThanOrEqualTo(<span class="string">"age"</span>, 37);</span><br></pre></td></tr></table></figure>
<p>如果你想查询匹配几个不同值的数据，如：要查询 “peter”，“neal”，“alex” 三个人的详细数据，你可以使用 WhereContainedIn（类似 SQL 中的 in 查询）方法来实现。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = new[] &#123; <span class="string">"peter"</span>, <span class="string">"neal"</span>, <span class="string">"alex"</span> &#125;;</span><br><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.WhereContainedIn(<span class="string">"name"</span>, names);</span><br></pre></td></tr></table></figure>
<p>相反，你想查询排除 “peter”，“neal”，“alex” 这三个人的其他同学的信息（类似 SQL 中的 not in 查询），你可以使用 WhereNotContainedIn 方法来实现。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.<span class="variable">WhereNotContainedIn</span> (<span class="string">"name"</span>, names);</span><br></pre></td></tr></table></figure>
<p>对字符串值的查询 查询包含字符串的值，有几种方法。你可以使用任何正确的正则表达式来检索相匹配的值，使用 WhereMatches 方法：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.<span class="variable">WhereMatches</span>(<span class="string">"name"</span>, <span class="string">"^[A-Z]\\d"</span>);</span><br></pre></td></tr></table></figure>
<p>查询字符串中包含“XX“内容，可用如下方法：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询 name 字段的值中包含 “pet” 字的数据</span></span><br><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.WhereContains(<span class="string">"name"</span>, <span class="string">"pet"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询 name 字段的值是以 “al” 字开头的数据</span></span><br><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.WhereStartsWith(<span class="string">"name"</span>, <span class="string">"al"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询 name 字段的值是以 “oz” 字结尾的数据</span></span><br><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.WhereEndsWith(<span class="string">"name"</span>, <span class="string">"oz"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="数组值的查询">数组值的查询</h3><p>如果一个 Key 对应的值是一个数组，你可以查询 key 的数组包含了数字 2 的所有对象:</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找出所有arrayKey对应的数组同时包含了数字2的所有对象</span></span><br><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.WhereEqualTo(<span class="string">"arrayKey"</span>, 2);</span><br></pre></td></tr></table></figure>
<p>同样，你可以查询出 Key 的数组同时包含了 2,3 和 4 的所有对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找出所有arrayKey对应的数组同时包含了数字2,3,4的所有对象。</span></span><br><span class="line">List&lt;<span class="keyword">int</span>&gt; numbers = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">numbers.Add(<span class="number">2</span>);</span><br><span class="line">numbers.Add(<span class="number">3</span>);</span><br><span class="line">numbers.Add(<span class="number">4</span>);</span><br><span class="line">query = query.WhereContainsAll(<span class="string">"arrayKey"</span>, numbers);</span><br></pre></td></tr></table></figure>
<h3 id="查询对象个数">查询对象个数</h3><p>如果你只是想统计有多少个对象满足查询，你并不需要获取所有匹配的对象，可以直接使用 <code>CountAsync</code> 替代 <code>FindAsync</code>。例如，查询一部电视剧里面一共有多个角色：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.WhereNotEqualTo (<span class="string">"from"</span>, <span class="string">"White Collar"</span>);</span><br><span class="line">await <span class="keyword">query</span>.CountAsync().ContinueWith(t =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="keyword">count</span> = t.Result;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>对于超过 1000 个对象的查询，这种计数请求可能被超时限制。他们可能遇到超时错误或者返回一个近似的值。因此，请仔细设计你的应用架构来避免依赖这种计数查询。</code></p>
<p><em>查询数量限定的方法’Limit(int)’在CountAsync中不会生效。</em></p>
<h3 id="关系查询">关系查询</h3><p>LeanCloud 支持用关系 <code>AVRelation</code> 关联 2 个对象，当然也支持用关系查询来获取相关联的对象。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVObject</span> girlType = new <span class="built_in">AVObject</span> (<span class="string">"GirType"</span>);</span><br><span class="line">girlType [<span class="string">"typeName"</span>] = <span class="string">"Hot"</span>;</span><br><span class="line">girlType [<span class="string">"ageMax"</span>] = <span class="number">27</span>;</span><br><span class="line">girlType [<span class="string">"ageMin"</span>] = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">AVObject</span> beckham = new <span class="built_in">AVObject</span> (<span class="string">"Boy"</span>);</span><br><span class="line">beckham[<span class="string">"name"</span>]=<span class="string">"David Beckham"</span>;</span><br><span class="line">beckham [<span class="string">"age"</span>] = <span class="number">38</span>;</span><br><span class="line">beckham [<span class="string">"focusType"</span>] = girlType;</span><br><span class="line"><span class="comment">//保存beckham的时候会自动将girlType也保存到服务器。</span></span><br><span class="line">Task saveTask = beckham<span class="variable">.SaveAsync</span> ()<span class="variable">.ContinueWith</span> (t =&gt;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">AVQuery</span>&lt;<span class="built_in">AVObject</span>&gt; boyQuery=new <span class="built_in">AVQuery</span>&lt;<span class="built_in">AVObject</span>&gt;(<span class="string">"Boy"</span>);</span><br><span class="line">		boyQuery = boyQuery<span class="variable">.WhereEqualTo</span>(<span class="string">"focusType"</span>, girlType);</span><br><span class="line">		boyQuery<span class="variable">.FindAsync</span>()<span class="variable">.ContinueWith</span>(s=&gt;</span><br><span class="line">		&#123;</span><br><span class="line">			IEnumerable&lt;<span class="built_in">AVObject</span>&gt; boys = s<span class="variable">.Result</span>;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>
<p>关系的内嵌查询可以帮助开发者用简洁的代码处理复杂的关系内嵌查询，比如要查询<code>查询所有关注了年龄小于27岁女生类型的那些男生们</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span>&lt;<span class="built_in">AVObject</span>&gt; girlTypeQuery=new <span class="built_in">AVQuery</span>&lt;<span class="built_in">AVObject</span>&gt;(<span class="string">"GirType"</span>);<span class="comment">//</span></span><br><span class="line">girlTypeQuery = girlTypeQuery<span class="variable">.WhereLessThan</span> (<span class="string">"ageMax"</span>, <span class="number">27</span>);<span class="comment">//年龄小于27的萌妹纸</span></span><br><span class="line"><span class="built_in">AVQuery</span>&lt;<span class="built_in">AVObject</span>&gt; query = new <span class="built_in">AVQuery</span>&lt;<span class="built_in">AVObject</span>&gt;(<span class="string">"Boy"</span>);</span><br><span class="line">query = query<span class="variable">.WhereMatchesQuery</span> (<span class="string">"focusType"</span>, girlTypeQuery);<span class="comment">//找出喜欢这些类型的男生们</span></span><br></pre></td></tr></table></figure>
<p>请注意，默认的 limit 限制 100 也同样作用在内嵌查询上。因此如果是大规模的数据查询，你可能需要仔细构造你的查询对象来获取想要的行为。反之，不想匹配某个子查询，你可以使用 <code>WhereDoesNotMatchQuery</code> 方法，代码不再敖述。</p>
<p>查询已经选择了喜欢的类型的男生，并且是限定在最近 10 个加入系统的男生，可以如此做：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AVQuery&lt;AVObject&gt; <span class="keyword">query</span> = new AVQuery&lt;AVObject&gt;(<span class="string">"Boy"</span>);</span><br><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.OrderByDescending(<span class="string">"createdAt"</span>);</span><br><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.Limit(10);</span><br><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.<span class="keyword">Include</span>(<span class="string">"focusType"</span>);</span><br></pre></td></tr></table></figure>
<p>你可以使用 dot（英语句号:”.”）操作符来多层 Include 内嵌的对象。比如，你还想进一步获取 <code>GirType</code> 所关联的女生（就是那些标明了自己隶属于这个类型的女生）：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">query</span> = <span class="keyword">query</span>.<span class="keyword">Include</span>(<span class="string">"focusType.girls"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="CQL_查询">CQL 查询</h3><p>Cloud Query Language（简称 CQL） 是 LeanCloud 为查询 API 定制的一套类似 SQL 查询语法的子集和变种，主要目的是降低大家学习 LeanCloud 查询的 API 的成本，可以使用传统的 SQL 语法来查询 LeanCloud 应用内的数据。</p>
<p>在 .NET 中调用 CQL 查询很便捷，在 <code>AVQuery</code> 中有一个 <code>DoCloudQuery</code> 的静态方法，可以直接传入 sql 语句即可实现查询，如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">await <span class="built_in">AVQuery</span>&lt;<span class="built_in">AVObject</span>&gt;<span class="variable">.DoCloudQuery</span>(<span class="string">"select * from Character where age=37"</span>);</span><br></pre></td></tr></table></figure>
<p>如此做即可，其后续的操作与以前习惯的 <code>AVQuery</code> 其他查询一样，只是我们提供了另一种方式便于长期累积关系型数据库知识的开发者可以迅速迁移到 LeanCloud 上，CQL 的语法和详细用法可以参照：<a href="./cql_guide.html">CQL 详细指南</a></p>
<h4 id="CQL_查询占位符">CQL 查询占位符</h4><h2 id="用户">用户</h2><p>移动互联时代，把握住用户是核心的价值，任何一款APP都或多或少需要了解用户并且可能为用户建立一定的关系。例如，在社交软件中最基本就是要求用户注册和登录，哪怕是利用第三方（微博，QQ）API登录，都应该为用户在当前系统中再注册一次。LeanCloud已经在SDK中内嵌了关于用户这个较为特殊的对象的一些最基本的操作和数据服务。</p>
<h3 id="注册">注册</h3><p>注册用户在LeanCloud SDK中极为简单，看如下实例代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> userName</span> = <span class="string">"demoUser"</span>;</span><br><span class="line"><span class="variable"><span class="keyword">var</span> pwd</span> = <span class="string">"avoscloud"</span>;</span><br><span class="line"><span class="variable"><span class="keyword">var</span> email</span> = <span class="string">"xxx@xxx.com"</span>;</span><br><span class="line"><span class="variable"><span class="keyword">var</span> user</span> = new AVUser();</span><br><span class="line">user.Username = userName;</span><br><span class="line">user.Password = pwd;</span><br><span class="line">user.Email = email;</span><br><span class="line">await user.SignUpAsync().ContinueWith(t =&gt;</span><br><span class="line">&#123;</span><br><span class="line">   <span class="variable"><span class="keyword">var</span> uid</span> = user.ObjectId;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>以上代码就可以很快的注册为当前的应用注册一个用户，并且这个用户也会有一个唯一的<code>ObjectId</code>。<br><strong>用户的密码在数据管理界面是无法显示的，这是因为服务端存储的并不是明文，是通过不可逆的特殊算法加密后的字符串</strong></p>
<h3 id="手机号注册">手机号注册</h3><p>为了适应移动互联时代的需求，我们特地增加了手机号注册的功能，当然前提是会进行短信认证，就如同微信一样，注册的时候会发送6位数字的验证码到用户输入的手机上，然后再回调我们的验证接口就可以完成一次手机号的注册。<br>在<a href="/app.html?appid=#/permission">应用设置</a>可以开启这一个功能。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">验证注册用户手机号码</span><br><span class="line">允许用户使用手机短信登录</span><br></pre></td></tr></table></figure>
<p>如下一个简单的案例：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步先注册</span></span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> AVUser();</span><br><span class="line">user.Username = <span class="string">"WPUser"</span>;</span><br><span class="line">user.Password = <span class="string">"avoscloud"</span>;</span><br><span class="line">user.MobilePhoneNumber = <span class="string">"18688888888"</span>;</span><br><span class="line"><span class="keyword">var</span> task= user.SignUpAsync ();</span><br><span class="line"><span class="keyword">await</span> task；</span><br><span class="line"><span class="comment">//如此做，短信就会发送到指定的手机号</span></span><br></pre></td></tr></table></figure>
<p>以上完成之后，需要给用户一个输入界面，让用户输入收到的6位数字的验证码，然后再运行如下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二步回调认证</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> task</span> = AVUser.VerifyMobilePhoneAsync(code);<span class="comment">//code代表6位数字的验证码</span></span><br><span class="line">await task.ContinueWith(t =&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="variable"><span class="keyword">var</span> success</span>= t.Result;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>以上两步，就是一个完整的手机号注册流程。</p>
<h3 id="登录">登录</h3><p>登录是一个<code>AVUser</code>的静态方法，通过如下代码可以实现登录，登录之后，SDK会默认将此次登录的用户设置为<code>AVUser.CurrentUser</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> userName</span> = <span class="string">"demoUser"</span>;</span><br><span class="line"><span class="variable"><span class="keyword">var</span> pwd</span> = <span class="string">"avoscloud"</span>;</span><br><span class="line">await AVUser.LogInAsync(userName, pwd).ContinueWith(t =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (t.IsFaulted || t.IsCanceled)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="variable"><span class="keyword">var</span> error</span> = t.Exception.Message; <span class="comment">// 登录失败，可以查看错误信息。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">//登录成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="手机号和密码登录">手机号和密码登录</h4><p>在短信服务上线之后，只要是<code>通过认证</code>的手机号可以当做用户名在 LeanCloud 服务端进行登录，自然SDK里面也加入了相应的支持(WP SDK 自V1.1.0以及以后的版本都有支持)。它的调用与用户名登录一样，只是方法名字不一样，代码如下:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">await <span class="built_in">AVUser</span><span class="variable">.LogInByMobilePhoneNumberAsync</span> (mobilePhone, password)<span class="variable">.ContinueWith</span> (t =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="built_in">AVUser</span> user=t<span class="variable">.Result</span>;</span><br><span class="line">			<span class="comment">//这里可以拿到登录之后的AVUser，但是实际上AVUser.CurrentUser已经是当前登录的用户了。</span></span><br><span class="line">			<span class="comment">//这里提供返回值是为了使链式表达式脱离对全局变量的依赖，当然大部分情况下AVUser.CurrentUser应该已经可以满足一般的需求。</span></span><br><span class="line">		&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="手机号和短信验证码登录">手机号和短信验证码登录</h4><p>在对客户端验证要求比较高的应用里面，也许有些应用要求支持短信随机的验证码作为临时的密码登录，这个应用场景在现在已经被普遍的采用了，这种验证机制被认为是安全性高的一种机制，自然 LeanCloud 也给予了支持。它比前2种静态登录的方法多了<code>发送短信验证码</code>这一步，具体代码如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步，请求服务端发送6为数字的验证码到指定mobilePhoneNumber上。</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">await</span> AVUser.RequestLoginSmsCodeAsync(mobilePhoneNumber).ContinueWith(t =&gt;</span><br><span class="line">       &#123;</span><br><span class="line">			<span class="keyword">var</span> success=t.Result;</span><br><span class="line">			<span class="comment">//判断返回值可以判断是否发送成功，不成功会抛出带有error的AVException，并且t.Result会被置为false.</span></span><br><span class="line">			<span class="comment">//在处理这种容易因为用户输入不合法而产生的异常的时候，为了保证程序的正常运行，建议使用try/catch机制进行提前的异常处理。</span></span><br><span class="line">		&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(AVException avException)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二步，直接使用验证码登录，如果验证码输入错误也会抛出异常。</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">await</span> AVUser.LoginBySmsCodeAsync (mobilePhoneNumber, code).ContinueWith(t=&gt;</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">var</span> success=t.Result;</span><br><span class="line">		&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(AVException avException)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="邮箱认证">邮箱认证</h3><p>在移动互联时代，任何一个用户信息都是必须在双方统一认证之后才会被视为一种安全机制，比如邮箱的认证，同样，在<code>AVUser</code>这个特殊的<code>AVObject</code>拥有一个特殊字段<code>email</code>，可以在<a href="/data.html?appid=&lt;!--￼74--">数据管理</a>的<code>_User</code>表看到这个默认的字段，这就是在注册是提供的邮箱，当在<a href="/app.html?appid=#/permission">应用设置</a>中勾选了</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">启用注册用户邮箱验证</span><br></pre></td></tr></table></figure>
<p>这样在注册用户的时候，LeanCloud默认就会发送一封邮件，进行验证，邮件的模板也可以在<a href="/app.html?appid=#/email">邮件模板</a>中进行设置。</p>
<p>注意，验证过的用户，TA的<code>emailVerified</code>将会置成<code>true</code>，反之<code>false</code>，但是如果<strong>未启用注册用户邮箱验证</strong>，这个字段会为空。</p>
<h3 id="手机号认证">手机号认证</h3><p>相对于邮箱认证，手机号认证的过程稍微需要多一点代码，如果当您的应用在注册的时候没有开启短信验证，伴随业务发展，发现需要验证用户的手机，LeanCloud 正好提供了这一接口。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用的前提是，改手机号已经与已存在的用户有关联(_User表中的mobilePhoneNumber即可关联手机，至于如何关联取决于客户端的业务逻辑)</span></span><br><span class="line"><span class="tag">await</span> <span class="tag">AVUser</span><span class="class">.RequestMobilePhoneVerifyAsync</span> (<span class="string">"18688888888"</span>)<span class="class">.ContinueWith</span>(t=&gt;</span><br><span class="line">		&#123;</span><br><span class="line">		   <span class="comment">//这样就成功的发送了验证码</span></span><br><span class="line">		&#125;);</span><br></pre></td></tr></table></figure>
<p>回调认证的接口与<code>手机号注册</code>小节的第二步一样。</p>
<p>验证成功后，用户的<code>mobilePhoneVerified</code>属性变为true，并且调用云引擎的<code>AV.Cloud.onVerifed(&#39;sms&#39;, function)</code>方法。</p>
<p><strong>以上只是针对_User表的一个属性mobilePhoneNumber进行验证，但是存在另一种需求，类似于支付宝在进行交易的时候会要求进行实时的短信认证，这一机制现在已经普遍存在于各种应用中进行敏感操作的首选，并不局限于注册登录这种通用功能，LeanCloud 也提供了这一机制</strong></p>
<h4 id="手机短信针对应用自定义操作的验证">手机短信针对应用自定义操作的验证</h4><p><code>AVCloud</code>类包含了相关的静态方法，实例如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步，先请求发送，如果手机号无效则会发送失败。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RequestSMSCode</span>(<span class="params"></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> task=AVCloud.RequestSMSCode (<span class="string">"18688888888"</span>).ContinueWith(t=&gt;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(t.Result)</span><br><span class="line">		&#123;</span><br><span class="line">			msg=<span class="string">"sent!"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">    <span class="keyword">await</span> task；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果开发者想简单地自定义短信的内容，可以调用另外一个版本，如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RequestSMSCodeWithCustomParameters</span>(<span class="params"></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> task=AVCloud.RequestSMSCode (<span class="string">"18688888888"</span>,<span class="string">"PP打车"</span>,<span class="string">"叫车服务"</span>,<span class="number">8</span>).ContinueWith(t=&gt;</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(t.Result)</span><br><span class="line">	    &#123;</span><br><span class="line">	      msg=<span class="string">"sent!"</span>;</span><br><span class="line">       &#125;</span><br><span class="line">	&#125;);</span><br><span class="line">    <span class="keyword">await</span> task；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户就会收到如下短信：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">您正在使用 PP打车 服务进行 叫车服务，您的验证码是<span class="number">012345</span>，请在<span class="number">8</span>分钟之内完成验证。</span><br></pre></td></tr></table></figure>
<p>以上是调用发送，下一步就是验证。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">VerifySMSCode</span>(<span class="params"><span class="keyword">string</span> mobileNumber,<span class="keyword">string</span> code</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> task=AVCloud.VerifySmsCode (mobileNumber,code).ContinueWith(t=&gt;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(t.Result)</span><br><span class="line">		&#123;</span><br><span class="line">			msg=<span class="string">"verified"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			msg=<span class="string">"valid code"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">    <span class="keyword">await</span> task；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="语音短信验证码">语音短信验证码</h5><p>文本短信验证码在到达率上有一定的风险，尽管经过我们长期得到的用户反馈，到达率已接近 100%，但是有些应用的时效性和安全性要求极高，所以我们也推出了语音短信验证码的服务，调用的方式如下：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">await AVCloud.<span class="title">RequestVoiceCode</span> <span class="params">(<span class="string">"18688888888"</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>发送成功之后，用户的手机就会收到一段语音通话，它会播报 6 位数的验证码，然后开发者需要再次调用：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVCloud<span class="class">.VerifySmsCode</span> (<span class="string">"18688888888"</span>,<span class="string">"012345"</span>)</span><br></pre></td></tr></table></figure>
<p>再次验证用户输入的验证码是否正确。</p>
<p>目前语音短信验证码仅支持大陆的手机号（移动，电信，联通全面覆盖）。</p>
<h3 id="当前用户">当前用户</h3><p>诚如所有移动应用一样当前用户一直是被在客户端视作持久化存储处理，比如手机QQ等流行的App，LeanCloud必然也会如此为开发者解决持久化存储当前用户，只要调用了<code>登录</code>相关的接口，当前用户就会被持久化存储在客户端。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> user</span> = AVUser.CurrentUser;</span><br></pre></td></tr></table></figure>
<p>如果调用了登出借口，那么当前用户就会被清除，并置为<code>null</code>：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> AVUser.LogOut();</span><br><span class="line"><span class="keyword">var</span> user = AVUser.CurrentUser;	<span class="comment">//如此做就会抛出异常，因为登出之后，CurrentUser已经为空。</span></span><br></pre></td></tr></table></figure></p>
<h3 id="重置密码">重置密码</h3><h4 id="邮箱重置">邮箱重置</h4><p>密码管理一直是移动应用的比较通用又比较繁琐的事情，LeanCloud也为开发者提供了一套通用的解决方案，将开发者从繁琐中解脱出来。<br>当用户忘记密码的时候，开发者完全可以在客户端做一个简单的按钮，然后做一些友好的页面，但是真正实现重置密码的功能只需要如下一段代码：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">await</span> <span class="tag">AVUser</span><span class="class">.RequestPasswordResetAsync</span>(<span class="tag">user</span><span class="class">.Email</span>);</span><br></pre></td></tr></table></figure></p>
<p>这样服务端就会再次发送重置密码的邮件，开发者只要引导用户登录邮箱，进行操作就完成了。</p>
<h4 id="短信验证码重置">短信验证码重置</h4><p>如果用户的手机是有效地，并且已经通过了验证码验证手机的有效性，那么开发者可以提供另一种在手机上体验较好的方式：通过短信验证码重置密码。具体实例如下：<br>首先，需要发送一个请求到服务端去发送6位数的验证码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> smsCodeResetPasswordTask =	AVUser.RequestPasswordResetBySmsCode (<span class="string">"138012345678"</span>);<span class="comment">//只需要手机号即可，服务端会自动寻找与之匹配的用户，如果没有用户与此手机号绑定，将会提示错误信息。</span></span><br><span class="line"><span class="keyword">await</span> smsCodeResetPasswordTask；</span><br></pre></td></tr></table></figure>
<p>发送之后，再给一个界面给用户，让用户输入6位数的短信验证码，并且同时输入新的密码，然后如下调用：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> resetTask = AVUser.ResetPasswordBySmsCode(NewPassword,SMSCode);<span class="comment">//第一个参数是新密码（明文传递，请放心我们传输的时候做了加密，并且在服务端也绝不可能明文存储），第二个参数是上一步发送到用户手机的6位数验证码。</span></span><br><span class="line"><span class="keyword">await</span> resetTask；</span><br></pre></td></tr></table></figure>
<p>这样2步就可以重置密码，这项功能我们建议在一些应用内操作比较频繁的应用使用，邮箱重置的话可能需要用户去单独打开一个邮箱应用或者用浏览器跳转。</p>
<h3 id="查询用户">查询用户</h3><p><strong>请注意，新创建应用的 <code>_User</code> 表的查询权限默认是关闭的，通常我们推荐你在云引擎里封装用户查询，只查询特定条件的用户，避免开放用户表的全部查询权限。此外，你可以通过 class 权限设置打开查询权限，请参考 <a href="data_security.html#Class_级别的权限">数据与安全 - Class 级别的权限</a>。</strong></p>
<p>用户既然是个特殊的 <code>AVObject</code>，它当然也具备了 <code>AVObject</code> 的一些共同特性，很多场景下，关于用户的操作，首先就是通过条件查询，把符合特定条件的用户查询到客户端进行展现或者一些修改之类的操作。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">await <span class="built_in">AVUser</span><span class="variable">.Query</span><span class="variable">.WhereEqualTo</span>(<span class="string">"gender"</span>, <span class="string">"female"</span>)<span class="variable">.FindAsync</span>()<span class="variable">.ContinueWith</span>(t =&gt;</span><br><span class="line">&#123;</span><br><span class="line">     IEnumerable&lt;<span class="built_in">AVUser</span>&gt; women = t<span class="variable">.Result</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当然，也可以通过<code>GetAsync</code>方法通过<code>objectId</code>获取特定的一个<code>AVUser</code>。</p>
<h3 id="用户安全数据的认证规则">用户安全数据的认证规则</h3><p>很多时候，就算是开发者也不要轻易修改用户的基本信息，比如用户的一些比较敏感的个人信息，例如手机号，社交账号等，这些都应该让用户在App中自行修改，所以为了用户数据的数据有且仅有自己在登录的情况下得以修改，LeanCloud服务端对所有针对 <code>AVUser</code> 对象的数据做了验证。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">AVUser user = <span class="keyword">null</span>;</span><br><span class="line">await AVUser.LogInAsync(<span class="string">"demoUser"</span>, <span class="string">"asvscloud"</span>).ContinueWith(t =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    user = t.Result;</span><br><span class="line">    user.Username = <span class="string">"testUser"</span>; <span class="comment">// 修改用户名</span></span><br><span class="line">    <span class="keyword">return</span> user.SaveAsync();</span><br><span class="line">&#125;).Unwrap().ContinueWith(t =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!t.IsFaulted)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在登录之后，提交修改用户相关字段（密码除外），都会成功。</span></span><br><span class="line">        AVUser.LogOut();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).ContinueWith(t =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 通过Id获取这个用户，注：如此做并未使当前用户登录。</span></span><br><span class="line">    <span class="keyword">return</span> AVUser.Query.GetAsync(user.ObjectId);</span><br><span class="line">&#125;).Unwrap().ContinueWith(t =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    user = t.Result;</span><br><span class="line">    user.Username = <span class="string">"devUser"</span>;</span><br><span class="line">    <span class="keyword">return</span> user.SaveAsync();</span><br><span class="line">&#125;).Unwrap().ContinueWith(t =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (t.IsFaulted)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 显然，如此做就会失败，因为单单从Id获取用户，当前的请求不具备权限去修改这个用户的相关属性。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="ACL_权限控制">ACL 权限控制</h2><p>任何一个成熟的并且可控的系统中，必然会存在权限控制的问题，经典的案例就是论坛的斑竹可以删帖而普通游客只能看帖，如此一来，发展出来的<a href="http://zh.wikipedia.org/wiki/%E4%BB%A5%E8%A7%92%E8%89%B2%E7%82%BA%E5%9F%BA%E7%A4%8E%E7%9A%84%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6" target="_blank" rel="external">基于角色的访问控制</a>被普遍应用于各类传统的软件中，即便是互联网时代的今天，它依然是可以很简便地帮助开发者以及使用者理解和应用。</p>
<p>基于以上这一点，LeanCloud在开发者创建一个应用的时候，默认地在服务端为该应用添加了一张<code>_Role</code>的表，开发者可以在<a href="/data.html?appid=&lt;!--￼77--">数据管理</a>中看到这张表。</p>
<h3 id="默认访问权限">默认访问权限</h3><p>在没有显式指定的情况下，LeanCloud 中的每一个对象都会有一个默认的 ACL 值。这个值代表了，所有的用户，对这个对象都是可读可写的。此时你可以在数据管理的表中 ACL 属性中看到这样的值:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;"<span class="attribute">*</span>":<span class="value">&#123;"<span class="attribute">read</span>":<span class="value"><span class="literal">true</span></span>,"<span class="attribute">write</span>":<span class="value"><span class="literal">true</span></span>&#125;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>在.NET SDK中创建符合默认的开放读写权限的<code>AVACL</code>的代码如下：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> defaultACL = <span class="keyword">new</span> AVACL();</span><br><span class="line">defaultACL.PublicWriteAccess = <span class="literal">true</span>;</span><br><span class="line">defaultACL.PublicReadAccess = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="指定用户访问权限">指定用户访问权限</h3><p>当一个用户在实现一个网盘类应用时，针对不同文件的私密性，用户就需要不同的文件访问权限。 譬如公开的文件，每一个其他用户都有读的权限，然后仅仅只有创建者才拥有更改和删除的权限。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] data = System.Text.Encoding.UTF8.GetBytes(<span class="string">"AVOSCloud is a great cloud service!"</span>);</span><br><span class="line">AVFile file = <span class="keyword">new</span> AVFile(<span class="string">"mytxtFile.txt"</span>, data, <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">object</span>&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="string">"author"</span>,<span class="string">"AVOSCloud"</span>&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">AVObject book = <span class="keyword">new</span> AVObject(<span class="string">"book"</span>);</span><br><span class="line">book[<span class="string">"content"</span>] = file;</span><br><span class="line"></span><br><span class="line">AVACL acl = <span class="keyword">new</span> AVACL();</span><br><span class="line">acl.PublicReadAccess = <span class="keyword">true</span>;</span><br><span class="line">acl.SetWriteAccess(AVUser.CurrentUser, <span class="keyword">true</span>);</span><br><span class="line">book.ACL = acl;</span><br><span class="line"><span class="keyword">await</span> book.SaveAsync();</span><br></pre></td></tr></table></figure>
<h3 id="指定角色访问权限">指定角色访问权限</h3><h4 id="角色">角色</h4><p><code>AVRole</code>拥有一些默认的属性，当然它也是一个<code>AVObject</code>，自然开发者也可以为角色添加业务逻辑所需的字段。</p>
<ul>
<li><code>name</code> :<code>string</code>类型，角色的名称，并且这是创建角色的<code>必须字段</code>，并且<code>唯一</code>，并且只在创建时赋值，不能被<code>修改</code>，命名必须由字母，连接符，下划线组成，这个字段可视为主键。</li>
<li><code>users</code> :<code>AVACL</code>类型，它指向所有拥有（即<code>单用户可以拥有多角色</code>的系统）这个<code>角色</code>的用户。</li>
<li><code>roles</code> :<code>AVACL</code>类型，它指向所有该角色的子角色，<code>子角色自动继承父角色的所有权限</code>。关于这一点下一节会做详细阐述。</li>
</ul>
<h4 id="AVUser_与_AVRole_的从属关系">AVUser 与 AVRole 的从属关系</h4><p>指定用户访问权限虽然很方便，但是依然会有局限性。 以工资系统为例，一家公司的工资系统，工资最终的归属者和公司的出纳们只拥有工资的读权限，而公司的人事和老板才拥有全部的读写权限。当然你可以通过多次设置指定用户的访问权限来实现这一功能（多个用户的 ACL 设置是追加的而非覆盖）。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVObject</span> salary = new <span class="built_in">AVObject</span>(<span class="string">"salary"</span>);</span><br><span class="line">salary[<span class="string">"value"</span>] = <span class="number">2000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVUser</span> boss=new <span class="built_in">AVUser</span>();<span class="comment">//假设此处为老板</span></span><br><span class="line"><span class="built_in">AVUser</span> hrWang=new <span class="built_in">AVUser</span>();  <span class="comment">//人事小王</span></span><br><span class="line"><span class="built_in">AVUser</span> me = new <span class="built_in">AVUser</span>(); <span class="comment">//我们就在文档里爽一爽吧</span></span><br><span class="line"><span class="built_in">AVUser</span> cashierZhou = new <span class="built_in">AVUser</span>(); <span class="comment">//出纳老周</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">AVACL</span> acl = new <span class="built_in">AVACL</span>();</span><br><span class="line">acl<span class="variable">.SetReadAccess</span>(boss, <span class="literal">true</span>);</span><br><span class="line">acl<span class="variable">.SetReadAccess</span>(hrWang, <span class="literal">true</span>);</span><br><span class="line">acl<span class="variable">.SetReadAccess</span>(me, <span class="literal">true</span>);</span><br><span class="line">acl<span class="variable">.SetReadAccess</span>(cashierZhou, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">acl<span class="variable">.SetWriteAccess</span>(boss, <span class="literal">true</span>);</span><br><span class="line">acl<span class="variable">.SetWriteAccess</span>(hrWang, <span class="literal">true</span>);</span><br><span class="line">salary<span class="variable">.ACL</span> = acl;</span><br><span class="line">await salary<span class="variable">.SaveAsync</span>();</span><br></pre></td></tr></table></figure>
<p>但是这些涉及其中的人可能不止一个，也有离职换岗新员工的问题存在。这样的代码既不优雅，也太啰嗦, 同样会很难维护。 这个时候我们就引入了 <code>AVRole</code> 来解决这个问题。 公司的员工可以成百上千，然而一个公司组织里的角色却能够在很长一段时间时间内相对稳定。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVObject</span> salary = new <span class="built_in">AVObject</span>(<span class="string">"salary"</span>);</span><br><span class="line">salary[<span class="string">"value"</span>] = <span class="number">2000000</span>;</span><br><span class="line"></span><br><span class="line">var roleACL = new <span class="built_in">AVACL</span>();</span><br><span class="line">roleACL<span class="variable">.PublicReadAccess</span> = <span class="literal">true</span>;<span class="comment">//AVRole本身在创建之后，就尽量避免它被修改，这里是为了设定AVRole自身的ACL访问限制。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下这些角色只为示意，如要正确执行本段代码，以下这些AVUser必须是已经存在于服务端的数据。</span></span><br><span class="line"><span class="built_in">AVUser</span> boss = new <span class="built_in">AVUser</span>();<span class="comment">//假设此处为老板</span></span><br><span class="line"><span class="built_in">AVUser</span> hrWang = new <span class="built_in">AVUser</span>();  <span class="comment">//人事小王</span></span><br><span class="line"><span class="built_in">AVUser</span> me = new <span class="built_in">AVUser</span>(); <span class="comment">//我们就在文档里爽一爽吧</span></span><br><span class="line"><span class="built_in">AVUser</span> cashierZhou = new <span class="built_in">AVUser</span>(); <span class="comment">//出纳老周</span></span><br><span class="line"><span class="built_in">AVUser</span> cashierGe = new <span class="built_in">AVUser</span>();<span class="comment">//出纳小葛</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">AVRole</span> hr = new <span class="built_in">AVRole</span>(<span class="string">"hr"</span>, roleACL);</span><br><span class="line"><span class="built_in">AVRole</span> cashier = new <span class="built_in">AVRole</span>(<span class="string">"cashier"</span>, roleACL);</span><br><span class="line"></span><br><span class="line">hr<span class="variable">.Users</span><span class="variable">.Add</span>(hrWang);</span><br><span class="line"></span><br><span class="line">cashier<span class="variable">.Users</span><span class="variable">.Add</span>(cashierZhou);</span><br><span class="line">cashier<span class="variable">.Users</span><span class="variable">.Add</span>(cashierGe);</span><br><span class="line"></span><br><span class="line">var saveUsersTask = new List&lt;Task&gt;()</span><br><span class="line">&#123;</span><br><span class="line">    &#123;hr<span class="variable">.SaveAsync</span>()&#125;,</span><br><span class="line">    &#123;cashier<span class="variable">.SaveAsync</span>()&#125;</span><br><span class="line">&#125;;</span><br><span class="line">await Task<span class="variable">.WhenAll</span>(saveUsersTask)<span class="variable">.ContinueWith</span>(t =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">AVACL</span> acl = new <span class="built_in">AVACL</span>();</span><br><span class="line">    acl<span class="variable">.SetReadAccess</span>(boss, <span class="literal">true</span>);</span><br><span class="line">    acl<span class="variable">.SetReadAccess</span>(me, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    acl<span class="variable">.SetRoleReadAccess</span>(hr, <span class="literal">true</span>);</span><br><span class="line">    acl<span class="variable">.SetRoleReadAccess</span>(cashier,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    acl<span class="variable">.SetWriteAccess</span>(boss, <span class="literal">true</span>);</span><br><span class="line">    acl<span class="variable">.SetRoleWriteAccess</span>(hr, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    salary<span class="variable">.ACL</span> = acl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> salary<span class="variable">.SaveAsync</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="AVRole_之间的从属关系">AVRole 之间的从属关系</h4><p>在讲清楚了用户与角色的关系后，我们还有一层角色与角色之间的关系。用下面的例子来理解可能会对我们有所帮助：</p>
<p>一家创业公司有移动部门，部门下面有不同的小组，Android 和 iOS。而每个小组只拥有自己组的代码的读写权限。但是他们同时拥有核心库代码的读取权限。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> roleACL = <span class="keyword">new</span> AVACL();</span><br><span class="line">roleACL.PublicReadAccess = <span class="keyword">true</span>;<span class="comment">//AVRole本身在创建之后，就尽量避免它被修改，这里是为了设定AVRole自身的ACL访问限制。</span></span><br><span class="line"></span><br><span class="line">AVRole androidTeam = <span class="keyword">new</span> AVRole(<span class="string">"androidTeam"</span>, roleACL);</span><br><span class="line">AVRole iOSTeam = <span class="keyword">new</span> AVRole(<span class="string">"iOSTeam"</span>, roleACL);</span><br><span class="line">AVRole mobileDep = <span class="keyword">new</span> AVRole(<span class="string">"mobileDep"</span>, roleACL);</span><br><span class="line"></span><br><span class="line">AVObject androidCode = <span class="keyword">new</span> AVObject(<span class="string">"code"</span>);</span><br><span class="line">androidCode[<span class="string">"name"</span>] = <span class="string">"android"</span>;</span><br><span class="line"></span><br><span class="line">AVObject iOSCode = <span class="keyword">new</span> AVObject(<span class="string">"code"</span>);</span><br><span class="line">iOSCode[<span class="string">"name"</span>] = <span class="string">"ios"</span>;</span><br><span class="line"></span><br><span class="line">AVObject coreCode = <span class="keyword">new</span> AVObject(<span class="string">"code"</span>);</span><br><span class="line">coreCode[<span class="string">"name"</span>] = <span class="string">"core"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> saveTeamTasks = <span class="keyword">new</span> <span class="built_in">List</span>&lt;Task&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;androidTeam.SaveAsync()&#125;,</span><br><span class="line">        &#123;iOSTeam.SaveAsync()&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">await Task.WhenAll(saveTeamTasks).ContinueWith(t =&gt;</span><br><span class="line"> &#123;</span><br><span class="line">     mobileDep.Roles.Add(androidTeam);</span><br><span class="line">     mobileDep.Roles.Add(iOSTeam);</span><br><span class="line">     <span class="keyword">return</span> mobileDep.SaveAsync();</span><br><span class="line"> &#125;).Unwrap().ContinueWith(s =&gt;</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">var</span> saveCodeTasks = <span class="keyword">new</span> <span class="built_in">List</span>&lt;Task&gt;()</span><br><span class="line">     &#123;</span><br><span class="line">         &#123;androidCode.SaveAsync()&#125;,</span><br><span class="line">         &#123;iOSCode.SaveAsync()&#125;,</span><br><span class="line">         &#123;coreCode.SaveAsync()&#125;,</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="keyword">return</span> Task.WhenAll(saveCodeTasks);</span><br><span class="line"></span><br><span class="line"> &#125;).Unwrap().ContinueWith(x =&gt;</span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//androidCode的读写权限对androidTeam开放</span></span><br><span class="line">     androidCode.ACL.SetRoleReadAccess(androidTeam, <span class="keyword">true</span>);</span><br><span class="line">     androidCode.ACL.SetRoleWriteAccess(androidTeam, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//iOSCode的读写权限对iOSTeam开放</span></span><br><span class="line">     iOSCode.ACL.SetRoleReadAccess(iOSTeam, <span class="keyword">true</span>);</span><br><span class="line">     iOSCode.ACL.SetRoleWriteAccess(iOSTeam, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//coreCode对mobileDep开放读取权限，注意，mobileDep本身就已经包含了iOSTeam和androidTeam作为它的子角色</span></span><br><span class="line">     coreCode.ACL.SetRoleReadAccess(mobileDep, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">var</span> saveCodeTasks = <span class="keyword">new</span> <span class="built_in">List</span>&lt;Task&gt;()</span><br><span class="line">     &#123;</span><br><span class="line">         &#123;androidCode.SaveAsync()&#125;,</span><br><span class="line">         &#123;iOSCode.SaveAsync()&#125;,</span><br><span class="line">         &#123;coreCode.SaveAsync()&#125;,</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="keyword">return</span> Task.WhenAll(saveCodeTasks);</span><br><span class="line"> &#125;).Unwrap().ContinueWith(y =&gt;</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="comment">//所有操作全部完成。</span></span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="文件">文件</h2><h3 id="上传文件">上传文件</h3><p>AVFile可以让你的应用程序将文件存储到服务器中，比如常见的文件类型图像文件、影像文件、音乐文件和任何其他二进制数据都可以使用。<br>在这个例子中，我们将一段文本保存到服务器端：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] data = System.Text.Encoding.UTF8.GetBytes(“ LeanCloud <span class="keyword">is</span> a great cloud service!”);</span><br><span class="line">AVFile file = <span class="keyword">new</span> AVFile(<span class="string">"mytxtFile.txt"</span>, data, <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">object</span>&gt;()</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="string">"author"</span>,<span class="string">"AVOSCloud"</span>&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">await</span> file.SaveAsync().ContinueWith(</span><br><span class="line">    t =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!t.IsFaulted)</span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox.Show(file.ObjectId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, CancellationToken.None, TaskContinuationOptions.OnlyOnRanToCompletion, TaskScheduler.FromCurrentSynchronizationContext());</span><br></pre></td></tr></table></figure>
<p>AVFile构造函数的第一个参数指定文件名称，第二个构造函数接收一个byte数组，也就是将要上传文件的二进制，第三个参数是自定义元数据的字典，比如你可以把文件的作者的名字当做元数据存入这个字典，LeanCloud 的服务端会把它保留起来，这样在以后获取的时候，这种类似的自定义元数据都会被获取。</p>
<h3 id="本地文件">本地文件</h3><p>在.NET SDK中，如果很清楚地知道某一个文件所存在的路径，比如在游戏中上传一张游戏截图到LeanCloud中，可以通过SDK直接获取指定的文件，上传到LeanCloud中。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVFile</span> localFile = <span class="built_in">AVFile</span><span class="variable">.CreateFileWithLocalPath</span>(<span class="string">"screenshot.PNG"</span>, Path<span class="variable">.Combine</span>(<span class="string">"&lt;Local Folder Path&gt;"</span>, <span class="string">"screenshot.PNG"</span>));</span><br></pre></td></tr></table></figure>
<p>之后的操作与上一节类似。</p>
<h3 id="文件元信息">文件元信息</h3><p>AVFile默认会存储文件大小和文件上传者objectId作为元信息。同样的，我们提供了一个字典接口帮助开发者可以未任意文件添加任意符合字典命名规则的自定义元数据。在本小节的第一个例子了已经为文件添加了一个自定义的元数据：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AVFile file = <span class="keyword">new</span> AVFile(<span class="string">"mytxtFile.txt"</span>, data, <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">object</span>&gt;()</span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="string">"author"</span>,<span class="string">"AVOSCloud"</span>&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这个就是简单的用法，在创建文件的时候，可以指定一组字典去保留文件的自定义元数据。</p>
<p>你还可以在上传前自动一些元信息保存起来，以便后续获取，例如我们还保存图片的高度和宽度：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">file</span>.MetaData.Add(<span class="string">"width"</span>, <span class="number">100</span>);</span><br><span class="line"><span class="type">file</span>.MetaData.Add(<span class="string">"height"</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<h3 id="下载文件">下载文件</h3><p>下载文件其实跟获取单个普通对象一样，首先必须知道这个文件的<code>objectdId</code>，或者你可以通过条件查询先获取这个<code>objectdId</code>，然后调用<code>AVFile.GetFileWithObjectIdAsync</code>方法首先实例化文件对象，然后就可以下载：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">await AVFile.GetFileWithObjectIdAsync(<span class="string">"538ed669e4b0e335f6102809"</span>).ContinueWith(t =&gt;</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">var</span> <span class="keyword">file</span> = t.Result;</span><br><span class="line">       <span class="keyword">file</span>.DownloadAsync().ContinueWith(s =&gt;</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">var</span> dataByte = <span class="keyword">file</span>.DataByte;<span class="comment">//获取文件流的byte数组，之后可以做保存，发送等操作。</span></span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="删除文件">删除文件</h3><p><strong>删除文件就意味着，执行之后在数据库中立刻删除记录，并且原始文件也会从存储仓库中删除（所有涉及到物理级别删除的操作请谨慎使用）</strong></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">await  AVFile.GetFileWithObjectIdAsync("538ed<span class="number">669e4b0</span>e<span class="number">335f61028</span>09").ContinueWith(t =&gt;</span><br><span class="line">  &#123;</span><br><span class="line">     var file = t.Result<span class="comment">;</span></span><br><span class="line">     file.DeleteAsync()<span class="comment">;</span></span><br><span class="line">  &#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="调用云引擎">调用云引擎</h2><p>云引擎是 LeanCloud 提供给开发者自定义服务端逻辑的解决方案，例如想在用户注册的时候，服务端统一给用户分配随机的昵称，这一操作就可以用云引擎实现。具体关于云引擎的一些相关概念和操作可以先查看 <a href="leanengine_guide-cloudcode.html">云引擎指南</a>。</p>
<p>调用云引擎在SDK中比较方便，它是 <code>AVCloud</code> 的静态方法，全局均可调用。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dic = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">object</span>&gt;();</span><br><span class="line">dic.Add(<span class="string">"name"</span>, <span class="string">"Justin"</span>);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//增加参数</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">var</span> callTask = AVCloud.CallFunctionAsync&lt;<span class="keyword">string</span>&gt;(<span class="string">"TestFunctionName"</span>, dic);</span><br><span class="line"><span class="keyword">await</span> callTask;</span><br></pre></td></tr></table></figure>
<p>只需要传入云引擎中函数的名字和这个函数需要参数即可，如果是无参的函数，直接传入<code>null</code>即可。</p>
<h2 id="自定义参数">自定义参数</h2><p>在控制台的<a href="/devcomponent.html?appid=#/component/custom_param">自定义参数设置</a>页面可以设置一些静态的全局共享的参数，他们都是键值对的格式，在 SDK 中提供了获取这些在线参数的方法：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IDictionary&lt;<span class="keyword">string</span>, <span class="keyword">object</span>&gt; cp=<span class="keyword">await</span> AVCloud.GetCustomParameters();</span><br></pre></td></tr></table></figure>
<h2 id="消息推送">消息推送</h2><h3 id="推送给所有的设备">推送给所有的设备</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AVPush <span class="keyword">push</span> = <span class="keyword">new</span> AVPush();</span><br><span class="line"><span class="keyword">push</span>.Alert = <span class="string">"message to all devices."</span>;</span><br><span class="line">var <span class="keyword">task</span> = <span class="keyword">push</span>.SendAsync();</span><br><span class="line">await <span class="keyword">task</span>;</span><br></pre></td></tr></table></figure>
<p>以上这段代码就可以实现向所有安装了当前App的设备推送消息。</p>
<h3 id="发送给特定的用户">发送给特定的用户</h3><p>发送给public频道的用户：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AVPush <span class="keyword">push</span> = <span class="keyword">new</span> AVPush();</span><br><span class="line"><span class="keyword">push</span>.Alert = <span class="string">"message to public channel."</span>;</span><br><span class="line"><span class="keyword">push</span>.Query = <span class="keyword">new</span> AVQuery&lt;AVInstallation&gt;().WhereEqualTo(<span class="string">"channels"</span>, <span class="string">"public"</span>);</span><br><span class="line">var <span class="keyword">task</span> = <span class="keyword">push</span>.SendAsync();</span><br><span class="line">await <span class="keyword">task</span>;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="-NET_数据存储开发指南">.NET 数据存储开发指南</h1><h2 id="简介">简介</h2><p>目前我们的 .NET 数据存储支持如下运行时：</p>
<ul>
<li>Windows Phone Silverlight （8.0 &amp; 8.1]]>
    </summary>
    
      <category term="leancloud" scheme="http://yoursite.com/tags/leancloud/"/>
    
      <category term="leancloud" scheme="http://yoursite.com/categories/leancloud/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Windows Phone 消息推送开发指南]]></title>
    <link href="http://yoursite.com/2015/12/30/avos/dotnet_push_guide/"/>
    <id>http://yoursite.com/2015/12/30/avos/dotnet_push_guide/</id>
    <published>2015-12-29T23:56:29.000Z</published>
    <updated>2015-12-18T10:23:17.705Z</updated>
    <content type="html"><![CDATA[<h1 id="Windows_Phone_消息推送开发指南">Windows Phone 消息推送开发指南</h1><blockquote>
<p>开始之前<br>在看下面的内容之前，我们假设你已经看过我们的<a href="./push_guide.html">消息推送开发总览</a>，了解了基本的概念和模型。</p>
</blockquote>
<p>Windows Phone 8 的推送较为特殊，因为微软在设计的时候把推送消息定义为一个包含跳转页面信息的载体，比如微信推送：你单击微信发送的 Windows Phone 的 Toast 推送消息，单击进去之后，它不是打开微信的默认首页（假如叫做 Main.xaml），而是进入某一个聊天的具体的页面（假如叫做 chat.xaml）。这种场景微软是通过在推送消息里面包含了代码逻辑来实现的，比如要实现刚才这一套流程，微信服务端必须向微软的 MPNS 发送一个如下类似的消息（Http 或者 Https Post 请求）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">wp:Notification</span> <span class="attribute">xmlns:wp</span>=<span class="value">"WPNotification"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">wp:Toast</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">wp:Text1</span>&gt;</span>微信<span class="tag">&lt;/<span class="title">wp:Text1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">wp:Text2</span>&gt;</span>你有一条聊天消息<span class="tag">&lt;/<span class="title">wp:Text2</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">wp:Param</span>&gt;</span>/chat.xaml?NavigatedFrom=Toast Notification<span class="tag">&lt;/<span class="title">wp:Param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">wp:Toast</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">wp:Notification</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>所以在使用 LeanCloud 推送服务向 Windows Phone 8 平台推送的时候一定要对微软官方的推送有所了解，如果想深入了解，可以点击详细查看微软官方关于 <a href="http://msdn.microsoft.com/en-us/library/windows/apps/hh202967.aspx" target="_blank" rel="external">Windows Phone 8 推送的官方教程</a>。</p>
<p>针对 Windows Phone 8 的特殊性，LeanCloud 采用了统一接口去处理，如下 C# 代码可以实现以上所说的功能：<br>在 LeanCloud 所有 .NET 语言 SDK 均可如下进行操作。（注：Unity 暂时不支持.Wait（）方法 和 await 关键字，所以它需要使用任务的链式表达，详情请查看 Unity 的文档。）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AVPush avPush = <span class="keyword">new</span> AVPush();</span><br><span class="line">avPush.Data = <span class="keyword">new</span> Dictionary&lt;string, object&gt;();</span><br><span class="line">avPush.Data.Add(<span class="string">"title"</span>, <span class="string">"微信"</span>);</span><br><span class="line">avPush.Data.Add(<span class="string">"alert"</span>, <span class="string">"你有一条聊天消息"</span>);</span><br><span class="line">avPush.Data.Add(<span class="string">"wp-param"</span>, <span class="string">"/chat.xaml?NavigatedFrom=Toast Notification"</span>);</span><br><span class="line"><span class="keyword">await</span> avPush.SendAsync()；</span><br></pre></td></tr></table></figure>
<h2 id="推送给所有的设备">推送给所有的设备</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AVPush push = <span class="keyword">new</span> AVPush();</span><br><span class="line">push.Alert = <span class="string">"message to all devices."</span>;</span><br><span class="line"><span class="keyword">var</span> task = push.SendAsync();</span><br><span class="line"><span class="keyword">await</span> task;</span><br></pre></td></tr></table></figure>
<p>以上这段代码就可以实现向所有安装了当前应用的设备推送消息。</p>
<h2 id="发送给特定的用户">发送给特定的用户</h2><p>发送给 public 频道的用户：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AVPush push = <span class="keyword">new</span> AVPush();</span><br><span class="line">push.Alert = <span class="string">"message to public channel."</span>;</span><br><span class="line">push.Query = <span class="keyword">new</span> AVQuery&lt;AVInstallation&gt;().WhereEqualTo(<span class="string">"channels"</span>, <span class="string">"public"</span>);</span><br><span class="line"><span class="keyword">var</span> task = push.SendAsync();</span><br><span class="line"><span class="keyword">await</span> task;</span><br></pre></td></tr></table></figure>
<h2 id="文档贡献">文档贡献</h2><p>如果觉得这个文档写的不够好，也可以帮助我们来不断完善。</p>
<p>Github 仓库地址：<a href="https://github.com/leancloud/docs" target="_blank" rel="external">https://github.com/leancloud/docs</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Windows_Phone_消息推送开发指南">Windows Phone 消息推送开发指南</h1><blockquote>
<p>开始之前<br>在看下面的内容之前，我们假设你已经看过我们的<a href="./push_guide.html">消息推送开发总]]>
    </summary>
    
      <category term="leancloud" scheme="http://yoursite.com/tags/leancloud/"/>
    
      <category term="leancloud" scheme="http://yoursite.com/categories/leancloud/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS / OS X 数据存储开发指南]]></title>
    <link href="http://yoursite.com/2015/12/30/avos/ios_os_x_guide/"/>
    <id>http://yoursite.com/2015/12/30/avos/ios_os_x_guide/</id>
    <published>2015-12-29T23:56:29.000Z</published>
    <updated>2015-12-18T10:24:32.071Z</updated>
    <content type="html"><![CDATA[<h1 id="iOS_/_OS_X_数据存储开发指南">iOS / OS X 数据存储开发指南</h1><p>如果还没有安装 LeanCloud iOS SDK，请阅读 <a href="/start.html">快速入门</a> 来获得该 SDK，并在 Xcode 中运行和熟悉示例代码。我们的 SDK 支持 iOS 5.1.1 及更高版本。</p>
<p>如果想从项目中学习，请到我们的 GitHub 资源库中获取 <a href="https://github.com/leancloud/leancloud-demos#ios" target="_blank" rel="external">iOS SDK Demos</a> 。其中，我们推荐与这个指南配套的 <a href="https://github.com/leancloud/LeanStorage-Demo" target="_blank" rel="external">LeanStorageDemo</a>。</p>
<h2 id="介绍">介绍</h2><p>LeanCloud 是一个完整的平台解决方案，它为应用开发提供了全方位的后端服务。我们的目标是让开发者不需要进行后端开发及服务器运维等工作，就可以开发和发布成熟的应用。</p>
<p>如果熟悉像 Ruby on Rails 这样的 Web 框架，你会发现 LeanCloud 很容易上手。我们在设计 LeanCloud 时应用了许多与之相同的原则。如果你之前使用过 Parse 或类似的后端服务，那么还会发现我们的 API 尽可能与其保持兼容。我们这样设计，是为了让开发者可以轻而易举地将应用从其他服务迁移至 LeanCloud，并且能得心应手地使用我们的 SDK 进行开发。</p>
<h2 id="快速入门">快速入门</h2><p>建议在阅读本文之前，先阅读 <a href="/start.html">快速入门</a>，了解如何配置和使用 LeanCloud。</p>
<h2 id="SDK_安装">SDK 安装</h2><p>我们提供了一个针对 iOS / OS X SDK 详细的安装指南：<a href="sdk_setup-ios.html">LeanCloud iOS / OS X SDK 安装指南</a></p>
<h2 id="对象">对象</h2><h3 id="AVObject">AVObject</h3><p>LeanCloud 的数据存储服务是建立在对象 — <code>AVObject</code> 基础上的，每个 <code>AVObject</code> 包含若干属性值对（key-value，也称「键值对」），属性的值是与 JSON 格式兼容的数据。你不需要预先指定每个 <code>AVObject</code> 包含哪些属性，每个属性的数据类型是什么，只要直接设定属性值对即可，你还可以随时增加新的属性。</p>
<p>假如我们要实现一个类似于微博的社交 app，主要有三类数据：账户、帖子、评论。以微博帖子为例，我们可以建立一个类名为 <code>Post</code> 的 <code>AVObject</code> 对象，包含下面几个属性：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">content:</span> <span class="string">"每个 Objective-C 程序员必备的 8 个开发工具"</span>, <span class="string">pubUser:</span> <span class="string">"LeanCloud官方客服"</span>, <span class="string">pubTimestamp:</span> <span class="number">1435541999</span></span><br></pre></td></tr></table></figure>
<p>属性名（也称「键」，key），必须是由字母、数字或下划线组成的字符串；自定义的属性名，不能以 <code>__</code>（双下划线）开头。属性值，可以是字符串、数字、布尔值，或是数组和字典。</p>
<p><strong>注意：以下为系统保留字段，不能作为属性名来使用。</strong></p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">acl             <span class="keyword">error</span>            pendingKeys</span><br><span class="line">ACL             fetchWhenSave    <span class="property">running</span></span><br><span class="line">className       <span class="property">id</span>               updatedAt</span><br><span class="line">code            isDataReady      uuid</span><br><span class="line">createdAt       keyValues</span><br><span class="line">description     objectId</span><br></pre></td></tr></table></figure>
<p>每个 <code>AVObject</code> 都必须有一个类（Class）名称，以便区分不同类型的数据。例如，微博帖子这个对象可取名为 <code>Post</code>。</p>
<p>我们建议将类和属性名分别按照 <code>NameYourClassesLikeThis</code> 和 <code>nameYourKeysLikeThis</code> 这样的惯例来命名，即区分第一个字母的大小写，这样可以提高代码的可读性和可维护性。</p>
<h3 id="保存对象">保存对象</h3><p>接下来，需要将上文中的 <code>Post</code> 存储到 LeanCloud 上。LeanCloud 的相关接口和 <code>NSMutableDictionary</code> 类似，但只有在调用 <code>save</code> 方法时，数据才会被真正保存下来。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVObject</span> *post = [<span class="built_in">AVObject</span> objectWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[post setObject:<span class="string">@"每个 Objective-C 程序员必备的 8 个开发工具"</span> forKey:<span class="string">@"content"</span>];</span><br><span class="line">[post setObject:<span class="string">@"LeanCloud官方客服"</span> forKey:<span class="string">@"pubUser"</span>];</span><br><span class="line">[post setObject:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1435541999</span>] forKey:<span class="string">@"pubTimestamp"</span>];</span><br><span class="line">[post save];</span><br></pre></td></tr></table></figure>
<p>或者用下标用法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVObject</span> *post = [<span class="built_in">AVObject</span> objectWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">post[<span class="string">@"content"</span>] = <span class="string">@"每个 Objective-C 程序员必备的 8 个开发工具"</span>;</span><br><span class="line">post[<span class="string">@"pubUser"</span>] = <span class="string">@"LeanCloud官方客服"</span>;</span><br><span class="line">post[<span class="string">@"pubTimestamp"</span>] = @(<span class="number">1435541999</span>);</span><br><span class="line">[post save];</span><br></pre></td></tr></table></figure>
<p>运行此代码后，要想确认保存动作是否已经生效，可以到 LeanCloud 应用管理平台的 <a href="/data.html?appid=&lt;!--￼119--">数据管理</a> 页面来查看数据的存储情况。</p>
<p>如果保存成功，<code>Post</code> 的数据表中应该显示出以下记录：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objectId: <span class="string">"558e20cbe4b060308e3eb36c"</span>, content: <span class="string">"每个 Objective-C 程序员必备的 8 个开发工具"</span>, pubUser: <span class="string">"LeanCloud官方客服"</span>, pubTimestamp: <span class="number">1435541999</span>,</span><br><span class="line">createdAt:<span class="string">"2015-06-29 09:39:35"</span>, updatedAt:<span class="string">"2015-06-29 09:39:35"</span></span><br></pre></td></tr></table></figure>
<p>在此要特别说明两点：</p>
<ol>
<li><p>运行此代码前，不用配置或设置 <code>Post</code> 类，LeanCloud 会自动创建这个类。</p>
</li>
<li><p>对于每一个 AVObject，系统内置了一些属性，以下字段不需要提前指定：</p>
<ul>
<li><code>objectId</code> 是为每个对象自动生成的唯一的标识符</li>
<li><code>createdAt</code> 和 <code>updatedAt</code> 分别代表每个对象在 LeanCloud 中创建和最后修改的时间，它们会被自动赋值。</li>
</ul>
<p>在执行保存操作之前，这些字段不会被自动保存到 <code>AVObject</code> 中。</p>
</li>
</ol>
<h3 id="检索对象">检索对象</h3><p>将数据保存到 LeanCloud 上实现起来简单而直观，获取数据也是如此。如果已知 <code>objectId</code>，用 <code>AVQuery</code> 就可以查询到对应的 <code>AVObject</code> 实例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line"><span class="built_in">AVObject</span> *post = [query getObjectWithId:<span class="string">@"558e20cbe4b060308e3eb36c"</span>];</span><br></pre></td></tr></table></figure>
<p>接下来可以用 <code>objectForKey:</code>或下标语法来获取属性值：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> timestamp = [[post objectForKey:<span class="string">@"pubTimestamp"</span>] intValue];</span><br><span class="line"><span class="built_in">NSString</span> *userName = [post objectForKey:<span class="string">@"pubUser"</span>];</span><br><span class="line"><span class="built_in">NSString</span> *content = post[<span class="string">@"content"</span>];</span><br></pre></td></tr></table></figure>
<p>获取三个特殊属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *objectId = post<span class="variable">.objectId</span>;</span><br><span class="line"><span class="built_in">NSDate</span> *updatedAt = post<span class="variable">.updatedAt</span>;</span><br><span class="line"><span class="built_in">NSDate</span> *createdAt = post<span class="variable">.createdAt</span>;</span><br></pre></td></tr></table></figure>
<p>如果需要刷新特定对象的最新数据，可调用 <code>refresh</code> 方法 ：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[myObject refresh];</span><br></pre></td></tr></table></figure>
<h3 id="后台运行">后台运行</h3><p>在 iOS 或 OS X 中，大部分代码是在主线程中运行的。不过，当应用在主线程中访问网络时，可能常会发生卡顿或崩溃现象。</p>
<p>由于 <code>save</code> 和 <code>getObjectWithId</code> 这两个方法会访问 LeanCloud 云端服务器，所以不应当在主线程上运行。这种情况一般处理起来比较麻烦，因此，LeanCloud 提供了辅助方法，能够覆盖绝大多数应用场景。</p>
<p>例如，方法 <code>saveInBackground</code> 可在后台线程中保存之前的 <code>AVObject</code> 实例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[post saveInBackground];</span><br></pre></td></tr></table></figure>
<p>这样，<code>saveInBackground</code> 的调用会立即返回，而主线程不会被阻塞，应用会保持在响应状态。</p>
<p>通常情况下，要在某操作完成后立即运行后面的代码，可以使用 Block（<code>...WithBlock</code> ：仅支持 iOS 4.0+ 或 OS X 10.6+）或回调（<code>...CallBack</code>）方法。</p>
<p>例如，在保存完成后运行一些代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[post saveInBackgroundWithBlock:^(<span class="built_in">BOOL</span> succeeded, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">    <span class="comment">// post 保存成功</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 保存 post 时出错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>或者写成回调方式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先创建一个回调</span></span><br><span class="line">- (<span class="keyword">void</span>)saveCallback:(<span class="built_in">NSNumber</span> *)result error:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">  <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">    <span class="comment">// post 保存成功</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 保存 post 时出错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后在后续代码中执行其他操作</span></span><br><span class="line">[post saveInBackgroundWithTarget:<span class="keyword">self</span></span><br><span class="line">                        selector:<span class="keyword">@selector</span>(saveCallback:error:)];</span><br></pre></td></tr></table></figure>
<p>LeanCloud 在进行网络通讯时不会阻塞调用线程，Block 或回调会在主线程执行。也就是说，网络访问不会对 UI 产生不良影响，在回调中可对 UI 进行操作。</p>
<p><code>AVQuery</code> 也遵循相同的模式。如果需要从对象 <code>Post</code> 获取并修改某一条微博帖子，同时又确保主线程不会被阻塞，则可以：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[query getObjectInBackgroundWithId:<span class="string">@"558e20cbe4b060308e3eb36c"</span></span><br><span class="line">                             block:^(<span class="built_in">AVObject</span> *post, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">    <span class="comment">// get 请求成功完成，结果存在 post 实例中</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"The content was: %@"</span>, [post objectForKey:<span class="string">@"content"</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 请求失败，输出错误信息</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Error: %@ %@"</span>, error, [error userInfo]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>或用回调方式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先创建一个回调</span></span><br><span class="line">- (<span class="keyword">void</span>)getCallback:(<span class="built_in">AVObject</span> *)post error:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">  <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">    <span class="comment">// get 请求成功完成，结果存在 post 实例中</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"The content was: %@"</span>, [post objectForKey:<span class="string">@"content"</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 请求失败，输出错误信息</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Error: %@ %@"</span>, error, [error userInfo]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后在后续代码中执行其他操作</span></span><br><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[query getObjectInBackgroundWithId:<span class="string">@"558e20cbe4b060308e3eb36c"</span></span><br><span class="line">                            target:<span class="keyword">self</span></span><br><span class="line">                          selector:<span class="keyword">@selector</span>(getCallback:error:)];</span><br></pre></td></tr></table></figure>
<h3 id="离线存储对象">离线存储对象</h3><p>大多数保存功能可以立刻执行，并通知应用「保存完毕」。不过若不需要知道保存完成的时间，则可使用 <code>saveEventually</code> 来代替。</p>
<p>它的优点在于：如果用户目前尚未接入网络，<code>saveEventually</code> 会缓存设备中的数据，并在网络连接恢复后上传。如果应用在网络恢复之前就被关闭了，那么当它下一次打开时，LeanCloud 会再次尝试保存操作。</p>
<p>所有 <code>saveEventually</code>（或 <code>deleteEventually</code>）的相关调用，将按照调用的顺序依次执行。因此，多次对某一对象使用 <code>saveEventually</code> 是安全的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="built_in">AVObject</span> *post = [<span class="built_in">AVObject</span> objectWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[post setObject:<span class="string">@"居有良田，食有黍稷；躬耕山間，優游人世；生之所往，不過良風年年。"</span> forKey:<span class="string">@"content"</span>];</span><br><span class="line">[post setObject:<span class="string">@"LeanCloud官方客服"</span> forKey:<span class="string">@"pubUser"</span>];</span><br><span class="line">[post setObject:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1435541999</span>] forKey:<span class="string">@"pubTimestamp"</span>];</span><br><span class="line">[post saveInBackgroundWithBlock:^(<span class="built_in">BOOL</span> succeeded, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line"></span><br><span class="line">    [post setObject:<span class="string">@"http://tp1.sinaimg.cn/3652761852/50/5730347813/0"</span> forKey:<span class="string">@"pubUserAvatar"</span>];</span><br><span class="line">    [post saveEventually];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="更新对象">更新对象</h3><p>更新对象非常简单，仅需要更新其属性，再调用保存方法即可。例如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="built_in">AVObject</span> *post = [<span class="built_in">AVObject</span> objectWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[post setObject:<span class="string">@"居有良田，食有黍稷；躬耕山間，優游人世；生之所往，不過良風年年。"</span> forKey:<span class="string">@"content"</span>];</span><br><span class="line">[post setObject:<span class="string">@"LeanCloud官方客服"</span> forKey:<span class="string">@"pubUser"</span>];</span><br><span class="line">[post setObject:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1435541999</span>] forKey:<span class="string">@"pubTimestamp"</span>];</span><br><span class="line">[post saveInBackgroundWithBlock:^(<span class="built_in">BOOL</span> succeeded, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加些新数据，这次只更新头像和认证等级信息</span></span><br><span class="line">    [post setObject:<span class="string">@"http://tp1.sinaimg.cn/3652761852/50/5730347813/0"</span> forKey:<span class="string">@"pubUserAvatar"</span>];</span><br><span class="line">    [post setObject:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">4</span>] forKey:<span class="string">@"pubUserCertificate"</span>];</span><br><span class="line">    [post saveInBackground];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>SDK 内部会自动计算出哪些数据已经改变，并将修改过的的字段发送给 LeanCloud 云端。未更新的数据不会产生变动，这一点请不用担心。</p>
<p><strong>请注意，LeanCloud 上的更新对象都是针对单个对象，获得对象的 objectId 主键才可以去更新对象。服务端判断一个对象是新增还是更新，是根据有没有 objectId 来决定的。</strong></p>
<p>上面的例子是先创建对象，然后在 saveInBackgroundWithBlock 的 block 里更新对象，不过更常见的场景是你通过<a href="#查询">查询</a>得到一个 AVObject 对象，这个时候更新对象也是类似上面的代码那样，修改属性，调用 saveInBackground 即可。</p>
<p>如果你已经知道了 objectId（例如从查询后的列表页进入一个详情页面，传入了 objectId），想要修改一个对象，可以采用类似下面的代码来更新对象属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 知道 objectId，创建 AVObject</span></span><br><span class="line"><span class="built_in">AVObject</span> *post = [<span class="built_in">AVObject</span> objectWithoutDataWithClassName:<span class="string">@"Post"</span> objectId:<span class="string">@"5590cdfde4b00f7adb5860c8"</span>];</span><br><span class="line"><span class="comment">//更新属性</span></span><br><span class="line">[post setObject:<span class="string">@"http://tp1.sinaimg.cn/3652761852/50/5730347813/0"</span> forKey:<span class="string">@"pubUserAvatar"</span>];</span><br><span class="line">[post setObject:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">4</span>] forKey:<span class="string">@"pubUserCertificate"</span>];</span><br><span class="line"><span class="comment">//保存</span></span><br><span class="line">[post saveInBackground];</span><br></pre></td></tr></table></figure>
<h3 id="计数器">计数器</h3><p>许多应用都需要实现计数器功能。比如一条微博，我们需要记录有多少人喜欢或者转发了它。但可能很多次喜欢都是同时发生的，如果在每个客户端直接把它们读到的计数值增加之后再写回去，那么极容易引发冲突和覆盖，导致最终结果不准，这时可以用 <code>incrementKey:</code> 以原子操作方式来实现计数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVObject</span> *post = [<span class="built_in">AVObject</span> objectWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[post setObject:<span class="string">@"居有良田，食有黍稷；躬耕山間，優游人世；生之所往，不過良風年年。"</span> forKey:<span class="string">@"content"</span>];</span><br><span class="line">[post setObject:<span class="string">@"LeanCloud官方客服"</span> forKey:<span class="string">@"pubUser"</span>];</span><br><span class="line">[post setObject:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1435541999</span>] forKey:<span class="string">@"pubTimestamp"</span>];</span><br><span class="line">[post setObject:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">0</span>] forKey:<span class="string">@"upvotes"</span>]; <span class="comment">//初始值为 0</span></span><br><span class="line">[post saveInBackgroundWithBlock:^(<span class="built_in">BOOL</span> succeeded, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="comment">// 增加点赞的人数</span></span><br><span class="line">    [post incrementKey:<span class="string">@"upvotes"</span>];</span><br><span class="line">    [post saveInBackground];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>也可以使用 <code>incrementKey:byAmount:</code> 来给 Number 类型字段累加一个特定数值。</p>
<p>能不能不用特意去做 <code>fetch</code>，就马上得到计数器当前在后端的最新数据呢？这就需要使用 <code>fetchWhenSave</code> 属性。当它被设置为 <code>true</code> 时，SDK 会在保存操作发生时，自动返回当前计数器的最新数值。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">post<span class="variable">.fetchWhenSave</span> = <span class="literal">YES</span>;</span><br><span class="line">[post incrementKey:<span class="string">@"upvotes"</span>];</span><br><span class="line">[post saveInBackgroundWithBlock:^(<span class="built_in">BOOL</span> succeeded, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="comment">// 这时候 post.upvotes 的值会是最新的</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="数组">数组</h3><p>为了更好地存储数组类型的数据，LeanCloud 提供了三种不同的操作来自动更新数组字段：</p>
<ul>
<li><code>addObject:forKey:</code><br><br><code>addObjectsFromArray:forKey:</code><br><br>将指定对象附加到数组末尾。</li>
<li><code>addUniqueObject:forKey:</code><br><br><code>addUniqueObjectsFromArray:forKey:</code><br><br>如果不确定某个对象是否已包含在数组字段中，可以使用此操作来添加。对象的插入位置是随机的。  </li>
<li><code>removeObject:forKey:</code><br><br><code>removeObjectsInArray:forKey:</code><br><br>从数组字段中删除指定对象的所有实例。</li>
</ul>
<p>例如，给微博帖子添加 tags 字段：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[post addUniqueObjectsFromArray:[<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"编程"</span>, <span class="string">@"开发工具"</span>, <span class="literal">nil</span>] forKey:<span class="string">@"tags"</span>];</span><br><span class="line">[post saveInBackground];</span><br></pre></td></tr></table></figure>
<h3 id="删除对象">删除对象</h3><p>从 LeanCloud 中删除一个对象：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[myObject deleteInBackground];</span><br></pre></td></tr></table></figure>
<p>如果想通过回调来确认删除操作的结果，可以使用方法 <code>deleteInBackgroundWithBlock:</code> 或 <code>deleteInBackgroundWithTarget:selector:</code>。如果想强制在当前线程执行，使用 <code>delete</code>。</p>
<p><code>removeObjectForKey:</code> 方法会删除 AVObject 实例的单个属性。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除 post 实例中 pubTimestamp 字段的值，因为我们可以直接使用 createdAt 这个属性</span></span><br><span class="line">[myObject removeObjectForKey:<span class="string">@"pubTimestamp"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字段删除后结果保存到云端</span></span><br><span class="line">[myObject saveInBackground];</span><br></pre></td></tr></table></figure>
<h3 id="关联数据">关联数据</h3><p>对象可以与其他对象相联系。如前面所述，我们可以把一个 AVObject 的实例 a，当成另一个 AVObject 实例 b 的属性值保存起来。这可以解决数据之间一对一或者一对多的关系映射，就像数据库中的主外键关系一样。</p>
<p>注：LeanCloud 云端是通过 Pointer 类型来解决这种数据引用的，并不会将数据 a 在数据 b 的表中再额外存储一份，这也可以保证数据的一致性。</p>
<p>例如：一条微博信息可能会对应多条评论。创建一条微博信息并对应一条评论信息，你可以这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建微博、内容</span></span><br><span class="line"><span class="built_in">AVObject</span> *myPost = [<span class="built_in">AVObject</span> objectWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[myPost setObject:<span class="string">@"作为一个程序员，你认为回家以后要不要继续写代码？"</span> forKey:<span class="string">@"content"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建评论和内容</span></span><br><span class="line"><span class="built_in">AVObject</span> *myComment = [<span class="built_in">AVObject</span> objectWithClassName:<span class="string">@"Comment"</span>];</span><br><span class="line">[myComment setObject:<span class="string">@"我若是写代码，进入状态之后最好不要停。下不下班已经不重要了，那种感觉最重要。"</span> forKey:<span class="string">@"content"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为微博和评论建立一对一关系</span></span><br><span class="line">[myComment setObject:myPost forKey:<span class="string">@"post"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时保存 myPost、myComment</span></span><br><span class="line">[myComment saveInBackground];</span><br></pre></td></tr></table></figure>
<p>你也可以通过 objectId 来关联已有的对象：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把评论跟 objectId 为 "5590cdfde4b00f7adb5860c8" 的微博关联起来</span></span><br><span class="line">[myComment setObject:[<span class="built_in">AVObject</span> objectWithoutDataWithClassName:<span class="string">@"Post"</span> objectId:<span class="string">@"5590cdfde4b00f7adb5860c8"</span>]</span><br><span class="line">              forKey:<span class="string">@"post"</span>];</span><br></pre></td></tr></table></figure>
<p>默认情况下，在获取一个对象时，与其相关联的 <code>AVObject</code> 数据不会被一同返回。这些对象除了 <code>objectId</code> 之外，其他属性值都是空的，要得到关联对象的全部属性数据，需要再次调用 <code>fetch</code> 系方法:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取回关联的微博实例</span></span><br><span class="line"><span class="built_in">AVObject</span> *post = [fetchedComment objectForKey:<span class="string">@"post"</span>];</span><br><span class="line"><span class="comment">// 获取 post 的相关属性</span></span><br><span class="line">[post fetchIfNeededInBackgroundWithBlock:^(<span class="built_in">AVObject</span> *object, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">  <span class="comment">// 取回微博帖子内容</span></span><br><span class="line">  <span class="built_in">NSString</span> *content = [post objectForKey:<span class="string">@"content"</span>];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>还有另外一种复杂的情况，你可以使用 <code>AVRelation</code> 来建模「多对多」关系，它的工作原理类似于 <code>AVObject</code> 中的 <code>NSArray</code>。二者的不同之处在于，<code>AVRelation</code> 不用同步返回关联的所有 <code>AVObject</code> 实例数据。这意味着，使用 <code>AVRelation</code> 可以支持比 <code>NSArray</code> 更多的对象，它们的读取方式也更加灵活。</p>
<p>例如，一个用户喜欢多篇微博，就可以用 <code>relationforKey:</code> 来保存这些微博。将一篇微博按顺序添加到列表，可这样做：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVUser</span> *user = [<span class="built_in">AVUser</span> currentUser];</span><br><span class="line"><span class="built_in">AVRelation</span> *relation = [user relationforKey:<span class="string">@"likes"</span>];</span><br><span class="line">[relation addObject:post];</span><br><span class="line">[user saveInBackground];</span><br></pre></td></tr></table></figure>
<p>从 <code>AVRelation</code> 中移除一篇喜欢的微博：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[relation removeObject:post];</span><br></pre></td></tr></table></figure>
<p>默认情况下，这个关系中的对象列表不会被同步返回，需要从 <code>query</code> 查询返回的 <code>AVQuery</code> 中调用 <code>findObjectsInBackgroundWithBlock:</code> 方法来获得关联对象列表（这里是微博，Post），如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[relation query] findObjectsInBackgroundWithBlock:^(<span class="built_in">NSArray</span> *objects, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">  <span class="keyword">if</span> (error) &#123;</span><br><span class="line">     <span class="comment">// 呃，报错了</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// objects 包含了当前用户喜欢的所有微博</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>如果只想要文章对象的子集，则要对 <code>AVQuery</code> 添加额外的限制，如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span> *query = [relation query];</span><br><span class="line"><span class="comment">// 增加其他查询限制条件</span></span><br><span class="line">query<span class="variable">.skip</span> = <span class="number">10</span>;</span><br><span class="line">query<span class="variable">.limit</span> = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>如果想反向查询，比如，一篇微博被哪些用户喜欢过，可使用 <code>reverseQuery:</code> 来进行反向查询（同样，这也是直接使用 NSArray 作为属性值无法完成的），例如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVUser</span> *user = [<span class="built_in">AVUser</span> currentUser];</span><br><span class="line"><span class="built_in">AVRelation</span> *relation = [user relationforKey:<span class="string">@"likes"</span>];</span><br><span class="line"><span class="built_in">AVObject</span> *post = [<span class="built_in">AVObject</span> objectWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[post setObject:<span class="string">@"作为一个程序员，你认为回家以后要不要继续写代码？"</span> forKey:<span class="string">@"content"</span>];</span><br><span class="line">[post save];</span><br><span class="line">[relation addObject:post];</span><br><span class="line">[user save];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVRelation</span> reverseQuery:user<span class="variable">.className</span> relationKey:<span class="string">@"likes"</span> childObject:post];</span><br><span class="line">[query findObjectsInBackgroundWithBlock:^(<span class="built_in">NSArray</span> *users, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">   <span class="comment">// users 就是查询出来的喜欢 myPost 的所有 User 列表</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>要了解 <code>AVQuery</code> 更多的用法，请阅读本文 <a href="#查询">查询</a> 部分。<code>AVRelation</code> 的行为接近于 <code>AVObject</code> 中的 <code>NSArray</code>，所以在对象数组上的任何操作也同样适用于 <code>AVRelation</code>。</p>
<p><strong>请阅读《<a href="./relation_guide.html">关系建模指南</a>》来进一步了解关系类型。</strong></p>
<h3 id="批量操作">批量操作</h3><p>为了减少网络交互的次数太多带来的时间浪费，你可以在一个请求中对多个对象进行创建、更新、删除、获取。接口都在 AVObject 这个类下面：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 批量创建、更新</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)saveAll:(<span class="built_in">NSArray</span> *)objects error:(<span class="built_in">NSError</span> **)error;</span><br><span class="line">+ (<span class="keyword">void</span>)saveAllInBackground:(<span class="built_in">NSArray</span> *)objects</span><br><span class="line">						  block:(<span class="built_in">AVBooleanResultBlock</span>)block; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量删除</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)deleteAll:(<span class="built_in">NSArray</span> *)objects error:(<span class="built_in">NSError</span> **)error;</span><br><span class="line">+ (<span class="keyword">void</span>)deleteAllInBackground:(<span class="built_in">NSArray</span> *)objects</span><br><span class="line">                        block:(<span class="built_in">AVBooleanResultBlock</span>)block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量获取</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)fetchAll:(<span class="built_in">NSArray</span> *)objects error:(<span class="built_in">NSError</span> **)error;</span><br><span class="line">+ (<span class="keyword">void</span>)fetchAllInBackground:(<span class="built_in">NSArray</span> *)objects</span><br><span class="line">                       block:(<span class="built_in">AVArrayResultBlock</span>)block;</span><br></pre></td></tr></table></figure>
<p>比如 <code>Post</code> 用 <code>isRead</code> 字段来表示是否已读。获取一组微博对象之后，把这组对象标记为已读的代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取了一组 posts</span></span><br><span class="line"><span class="built_in">NSArray</span> *posts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">AVObject</span> *post <span class="keyword">in</span> posts) &#123;</span><br><span class="line">    post[<span class="string">@"isRead"</span>] = @(<span class="literal">YES</span>);</span><br><span class="line">&#125;</span><br><span class="line">[<span class="built_in">AVObject</span> saveAllInBackground:posts block:^(<span class="built_in">BOOL</span> succeeded, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="comment">// 网络错误</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 保存成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="数据类型">数据类型</h3><p>到目前为止，我们使用过的数据类型有 <code>NSString</code>、 <code>NSNumber</code>、 <code>AVObject</code>，LeanCloud 还支持 <code>NSDate</code> 和 <code>NSData</code>。</p>
<p>此外，<code>NSDictionary</code> 和 <code>NSArray</code> 支持嵌套，这样在一个 <code>AVObject</code> 中就可以使用它们来储存更多的结构化数据。例如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSNumber</span> *boolean = @(<span class="literal">YES</span>);</span><br><span class="line"><span class="built_in">NSNumber</span> *number = [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">2014</span>];</span><br><span class="line"><span class="built_in">NSString</span> *string = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"famous film name is %i"</span>, number];</span><br><span class="line"><span class="built_in">NSDate</span> *date = [<span class="built_in">NSDate</span> date];</span><br><span class="line"><span class="built_in">NSData</span> *data = [<span class="string">@"fooBar"</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *array = [<span class="built_in">NSArray</span> arrayWithObjects:string, number, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSDictionary</span> *dictionary = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:number, <span class="string">@"number"</span>,</span><br><span class="line">                                                                      string, <span class="string">@"string"</span>,</span><br><span class="line">                                                                      <span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVObject</span> *testObject = [<span class="built_in">AVObject</span> objectWithClassName:<span class="string">@"DataTypeTest"</span>];</span><br><span class="line">[testObject setObject:boolean    forKey:<span class="string">@"testBoolean"</span>];</span><br><span class="line">[testObject setObject:number     forKey:<span class="string">@"testInteger"</span>];</span><br><span class="line">[testObject setObject:string     forKey:<span class="string">@"testString"</span>];</span><br><span class="line">[testObject setObject:date       forKey:<span class="string">@"testDate"</span>];</span><br><span class="line">[testObject setObject:data       forKey:<span class="string">@"testData"</span>];</span><br><span class="line">[testObject setObject:array      forKey:<span class="string">@"testArray"</span>];</span><br><span class="line">[testObject setObject:dictionary forKey:<span class="string">@"testDictionary"</span>];</span><br><span class="line">[testObject saveInBackground];</span><br></pre></td></tr></table></figure>
<p>我们<strong>不推荐</strong>在 <code>AVObject</code> 中使用 <code>NSData</code> 类型来储存大块的二进制数据，比如图片或整个文件。<strong>每个 <code>AVObject</code> 的大小都不应超过 128 KB</strong>。如果需要储存更多的数据，建议使用 <code>AVFile</code>。更多细节可以阅读本文 <a href="#文件">文件</a> 部分。</p>
<p>若想了解更多有关 LeanCloud 如何解析处理数据的信息，请查看专题文档《<a href="./data_security.html">数据与安全</a>》。</p>
<h2 id="查询">查询</h2><p>我们已经看到，<code>AVQuery</code> 的 <code>getObjectWithId:</code> 方法可以从 LeanCloud 中检索出单个 <code>AVObject</code> 实例。此外，<code>AVQuery</code> 还提供更多的检索方法，来实现诸如一次检索许多对象、设定检索对象的条件、自动缓存查询结果等操作，免去了开发者需自行撰写代码的麻烦。</p>
<h3 id="基本查询">基本查询</h3><p>在许多情况下，<code>getObjectInBackgroundWithId:block:</code> 只能查找单个实例，并不能满足需求。除了检索单一对象，<code>AVQuery</code> 还允许以不同的检索方式来获取包含多个实例的列表。</p>
<p>一般的方式是创建一个 <code>AVQuery</code> 并设定相应的条件，然后用 <code>findObjectsInBackgroundWithBlock:</code> 检索得到一个 <code>AVObject</code> 组成的 <code>NSArray</code>。</p>
<p>例如，要查找指定 <code>pubUser</code> 发布的所有微博，可以使用 <code>whereKey:equalTo:</code> 方法来限定一个键和对应的值。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[query whereKey:<span class="string">@"pubUser"</span> equalTo:<span class="string">@"LeanCloud官方客服"</span>];</span><br><span class="line">[query findObjectsInBackgroundWithBlock:^(<span class="built_in">NSArray</span> *objects, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">    <span class="comment">// 检索成功</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Successfully retrieved %d posts."</span>, objects<span class="variable">.count</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 输出错误信息</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Error: %@ %@"</span>, error, [error userInfo]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p><code>findObjectsInBackgroundWithBlock:</code> 可以保证在完成网络请求的同时，不阻塞主线程中的 Block 和回调。</p>
<p>如果已运行在后台线程中，用 <code>findObjects</code> 方法可阻塞调用进程：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下代码仅可用于测试目的，或在后台线程之中运行</span></span><br><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[query whereKey:<span class="string">@"pubUser"</span> equalTo:<span class="string">@"LeanCloud官方客服"</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *postArray = [query findObjects];</span><br></pre></td></tr></table></figure>
<h3 id="查询约束">查询约束</h3><p>给 <code>AVQuery</code> 的检索添加约束条件有多种方法。</p>
<p>用 <code>whereKey:notEqualTo:</code> 搭配对应的键和值来过滤对象：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[query whereKey:<span class="string">@"pubUser"</span> notEqualTo:<span class="string">@"LeanCloud官方客服"</span>];</span><br></pre></td></tr></table></figure>
<p>一次查询可以设置多个约束条件，只有满足所有条件的对象才被返回，这相当于使用 AND 类型的查询条件。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[query whereKey:<span class="string">@"pubUser"</span> notEqualTo:<span class="string">@"LeanCloud官方客服"</span>];</span><br><span class="line">[query whereKey:<span class="string">@"pubUserCertificate"</span> greaterThan:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">3</span>]];</span><br></pre></td></tr></table></figure>
<p>用 <code>limit</code> 属性来控制返回结果的数量，默认值 100，允许取值范围从 1 到 1000。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query<span class="variable">.limit</span> = <span class="number">10</span>; <span class="comment">// 最多返回 10 条结果</span></span><br></pre></td></tr></table></figure>
<p>如果只需获取一个结果，直接使用 <code>getFirstObject</code> 或 <code>getFirstObjectInBackground</code>。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[query whereKey:<span class="string">@"pubUser"</span> equalTo:<span class="string">@"LeanCloud官方客服"</span>];</span><br><span class="line">[query getFirstObjectInBackgroundWithBlock:^(<span class="built_in">AVObject</span> *object, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!object) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"getFirstObject 请求失败。"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 查询成功</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"对象成功返回。"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p><code>skip</code> 用来跳过初始结果，这对分页非常有用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query<span class="variable">.skip</span> = <span class="number">10</span>; <span class="comment">// 跳过前 10 条结果</span></span><br></pre></td></tr></table></figure>
<p>对于适用的数据类型，如数字、字符串，可对返回结果进行排序：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按发帖时间升序排列</span></span><br><span class="line">[query orderByAscending:<span class="string">@"createdAt"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按发帖时间降序排列</span></span><br><span class="line">[query orderByDescending:<span class="string">@"createdAt"</span>];</span><br></pre></td></tr></table></figure>
<p>一个查询可以使用多个排序键：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若上一个排序键相等，按发帖者认证等级升序排列</span></span><br><span class="line">[query addAscendingOrder:<span class="string">@"pubUserCertificate"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果上一个排序键相等，按发帖者认证等级降序排列</span></span><br><span class="line">[query addDescendingOrder:<span class="string">@"pubUserCertificate"</span>];</span><br></pre></td></tr></table></figure>
<p>对于适用的数据类型，检索中可以使用「比较」方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点赞数 &lt; 50</span></span><br><span class="line">[query whereKey:<span class="string">@"upvotes"</span> lessThan:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">50</span>]];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点赞数 &lt;= 50</span></span><br><span class="line">[query whereKey:<span class="string">@"upvotes"</span> lessThanOrEqualTo:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">50</span>]];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点赞数 &gt; 50</span></span><br><span class="line">[query whereKey:<span class="string">@"upvotes"</span> greaterThan:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">50</span>]];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点赞数 &gt;= 50</span></span><br><span class="line">[query whereKey:<span class="string">@"upvotes"</span> greaterThanOrEqualTo:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">50</span>]];</span><br></pre></td></tr></table></figure>
<p><code>whereKey:containedIn:</code> 可查询包含不同值的对象。它接受数组，可实现用单一查询来代替多个查询。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出 “LeanCloud官方客服”，“LeanCloud江宏”，“滚滚艾买提” 三个账号的微博帖子</span></span><br><span class="line"><span class="built_in">NSArray</span> *names = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"LeanCloud官方客服"</span>,</span><br><span class="line">                                           <span class="string">@"LeanCloud江宏"</span>,</span><br><span class="line">                                           <span class="string">@"滚滚艾买提"</span>,</span><br><span class="line">                                           <span class="literal">nil</span>];</span><br><span class="line">[query whereKey:<span class="string">@"pubUser"</span> containedIn:names];</span><br></pre></td></tr></table></figure>
<p>相反，要让查询不包含某些值的对象，则用 <code>whereKey:notContainedIn:</code> ：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出除 “LeanCloud官方客服”，“LeanCloud江宏”，“滚滚艾买提” 三个账号以外的其他人的微博帖子</span></span><br><span class="line"><span class="built_in">NSArray</span> *names = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"LeanCloud官方客服"</span>,</span><br><span class="line">                                           <span class="string">@"LeanCloud江宏"</span>,</span><br><span class="line">                                           <span class="string">@"滚滚艾买提"</span>,</span><br><span class="line">                                           <span class="literal">nil</span>];</span><br><span class="line">[query whereKey:<span class="string">@"pubUser"</span> notContainedIn:names];</span><br></pre></td></tr></table></figure>
<p><code>whereKeyExists</code> 用来查询具备某一键集条件的对象，<code>whereKeyDoesNotExist</code> 正好相反。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到有图片的微博</span></span><br><span class="line">[query whereKeyExists:<span class="string">@"images"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有图片的微博</span></span><br><span class="line">[query whereKeyDoesNotExist:<span class="string">@"images"</span>];</span><br></pre></td></tr></table></figure>
<p>如果要用一个对象中某一键值，去匹配另一个查询结果对象中一个键值，来得到最终结果，可以使用 <code>whereKey:matchesKey:inQuery:</code> 。</p>
<p>例如，在微博这类应用中有三类数据：一个类是微博帖子信息（Post），另一个类是用户账户信息（AVUser），还有一个类是用户之间互相关注的信息（UserFollow），要找出当前用户关注的人发布的微博，则：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先找到当前登录用户关注的用户列表</span></span><br><span class="line"><span class="built_in">AVQuery</span> *followeeQuery = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"UserFollow"</span>];</span><br><span class="line">[followeeQuery whereKey:<span class="string">@"follower"</span> equalTo:[<span class="built_in">AVUser</span> currentUser]];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到这些被关注者发布的微博</span></span><br><span class="line"><span class="built_in">AVQuery</span> *postQuery = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[postQuery whereKey:<span class="string">@"author"</span> matchesKey:<span class="string">@"followee"</span> inQuery:followeeQuery];</span><br><span class="line">[postQuery findObjectsInBackgroundWithBlock:^(<span class="built_in">NSArray</span> *results, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="comment">// 得到当前用户关注的人发布的微博</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>相反，要从一个查询中获取一组对象，该对象的一个键值，与另一个对象的键值并不匹配，可以使用 <code>whereKey:doesNotMatchKey:inQuery:</code> 。</p>
<p>例如，找出当前用户没有关注的人发布的微博：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span> *postQuery = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[postQuery whereKey:<span class="string">@"author"</span> doesnotMatchesKey:<span class="string">@"followee"</span> inQuery:followeeQuery];</span><br><span class="line">[postQuery findObjectsInBackgroundWithBlock:^(<span class="built_in">NSArray</span> *results, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="comment">// 得到当前用户未关注的人发布的微博</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>将 <code>selectKeys:</code> 搭配 <code>NSArray</code> 类型的键值来使用可以限定查询返回的字段。</p>
<p>例如，让查询结果只包含 <code>pubUser</code> 和 <code>content</code> 字段（也可以是内置字段，如 <code>objectId</code>、 <code>createdAt</code> 或 <code>updatedAt</code>）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[query selectKeys:@[<span class="string">@"pubUser"</span>, <span class="string">@"content"</span>]];</span><br><span class="line"><span class="built_in">NSArray</span> *results = [query findObjects];</span><br></pre></td></tr></table></figure>
<p>其余字段可以稍后对返回的对象调用 <code>fetchIfNeeded</code> 的变体来获取：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVObject</span> *object = (<span class="built_in">AVObject</span> *)[results objectAtIndex:<span class="number">0</span>];</span><br><span class="line">[object fetchIfNeededInBackgroundWithBlock:^(<span class="built_in">AVObject</span> *object, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">  <span class="comment">// 返回该对象的所有字段</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="查询数组值">查询数组值</h3><p>当键值为数组类型时，<code>equalTo:</code> 可以从数组中找出包含单个值的对象：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出 arrayKey 中包含 2 的对象</span></span><br><span class="line">[query whereKey:<span class="string">@"arrayKey"</span> equalTo:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">2</span>]];</span><br></pre></td></tr></table></figure>
<p><code>containsAllObjectsInArray:</code> 可以找到包含多个值的对象:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出 arrayKey 中包含 2、3、4 的对象</span></span><br><span class="line">[query whereKey:<span class="string">@"arrayKey"</span> containsAllObjectsInArray:@[@<span class="number">2</span>, @<span class="number">3</span>, @<span class="number">4</span>]];</span><br></pre></td></tr></table></figure>
<h3 id="查询字符串值">查询字符串值</h3><p>使用 <code>whereKey:hasPrefix:</code> 可以过滤出以特定字符串开头的结果，这有点像 MySQL 的 <code>LIKE</code> 条件。因为支持索引，所以该操作对于大数据集也很高效。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出名字以 "LeanCloud" 开头的账户的微博帖子</span></span><br><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[query whereKey:<span class="string">@"pubUser"</span> hasPrefix:<span class="string">@"LeanCloud"</span>];</span><br></pre></td></tr></table></figure>
<h3 id="关系查询">关系查询</h3><p>检索关系数据有几种方法。如果用某个属性去匹配一个已知的 <code>AVObject</code> 对象，仍然可以使用 <code>whereKey:equalTo:</code>，就像使用其他数据类型一样。</p>
<p>例如，如果每条评论 <code>Comment</code> 的 <code>post</code> 字段都有一个 <code>Post</code> 微博对象，那么找出指定微博下的评论：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设前面已建好了 myPost 这个 AVObject 对象</span></span><br><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Comment"</span>];</span><br><span class="line">[query whereKey:<span class="string">@"post"</span> equalTo:myPost];</span><br><span class="line"></span><br><span class="line">[query findObjectsInBackgroundWithBlock:^(<span class="built_in">NSArray</span> *comments, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="comment">// comments 包含了 myPost 下的所有评论</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>或通过 <code>objectId</code> 做关系查询：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[query whereKey:<span class="string">@"post"</span></span><br><span class="line">        equalTo:[<span class="built_in">AVObject</span> objectWithoutDataWithClassName:<span class="string">@"Post"</span> objectId:<span class="string">@"5590cdfde4b00f7adb5860c8"</span>];</span><br></pre></td></tr></table></figure>
<p>如果要做嵌套查询，请使用 <code>whereKey:matchesQuery</code>。</p>
<p>例如，找出所有带图片的微博的评论：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span> *innerQuery = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[innerQuery whereKeyExists:<span class="string">@"image"</span>];</span><br><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Comment"</span>];</span><br><span class="line">[query whereKey:<span class="string">@"post"</span> matchesQuery:innerQuery];</span><br><span class="line">[query findObjectsInBackgroundWithBlock:^(<span class="built_in">NSArray</span> *comments, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="comment">// 所有带图片的微博的评论都在 comments</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>相反，<code>whereKey:doesNotMatchQuery:</code> 可以找出一个对象的某个属性与另一个查询不匹配的结果。例如，找出所有 不带图片的文章的评论：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span> *innerQuery = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[innerQuery whereKeyExists:<span class="string">@"image"</span>];</span><br><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Comment"</span>];</span><br><span class="line">[query whereKey:<span class="string">@"post"</span> doesNotMatchQuery:innerQuery];</span><br><span class="line">[query findObjectsInBackgroundWithBlock:^(<span class="built_in">NSArray</span> *comments, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="comment">// comments 包含了所有没有图片的文章的评论</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>注意：结果返回数量（默认 100 最多 1000）的限制也适用于内嵌查询，所以在处理大型数据集时，你可能需要仔细设置查询条件来获得想要的结果。</p>
<p>在一些场景中，如果需要在一个查询中返回多个类型的关联属性，可以使用方法 <code>includeKey:</code>。例如，搜索最近的十条评论，并同时找出与之对应的文章：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Comment"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找出最近刚创建的记录</span></span><br><span class="line">[query orderByDescending:<span class="string">@"createdAt"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只取前十条</span></span><br><span class="line">query<span class="variable">.limit</span> = [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找出每条评论所对应的文章</span></span><br><span class="line">[query includeKey:<span class="string">@"post"</span>];</span><br><span class="line"></span><br><span class="line">[query findObjectsInBackgroundWithBlock:^(<span class="built_in">NSArray</span> *comments, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="comment">// comments 是最近的十条评论, 其 post 字段也有相应数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">AVObject</span> *comment <span class="keyword">in</span> comments) &#123;</span><br><span class="line">         <span class="comment">// 并不需要网络访问</span></span><br><span class="line">         <span class="built_in">AVObject</span> *post = [comment objectForKey:<span class="string">@"post"</span>];</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"retrieved related post: %@"</span>, post);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p><strong>使用点（<code>.</code>）操作符可以检索多层级的数据（AVObject 对象）</strong>。例如，在结果中加入评论所对应的微博，以及该微博的作者：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[query includeKey:<span class="string">@"post.author"</span>];</span><br></pre></td></tr></table></figure>
<p><code>includeKey:</code> 既可在一次查询中多次使用来返回多个属性，也可与 <code>AVQuery</code> 的 <code>getFirstObject</code> 和 <code>getObjectInBackground</code> 等辅助方法配合使用。</p>
<p>还有一种情况，当某些对象包括多个键，而某些键的值包含的数据量又比较大，你并不希望返回所有的数据，只想要特定键所对应的数据，这时可以用 <code>selectKeys:</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[query selectKeys:@[<span class="string">@"pubUser"</span>]];</span><br><span class="line"><span class="built_in">AVObject</span> *result = [query getFirstObject];</span><br></pre></td></tr></table></figure>
<p>只返回指定键对应的有限数据，而非所有数据，有助于节省网络带宽和计算资源。</p>
<h3 id="缓存查询">缓存查询</h3><p>通常，将请求结果缓存到磁盘上是一种行之有效的方法，这样就算设备离线，应用刚刚打开，网络请求尚未完成时，数据也能显示出来。当缓存占用太多空间时，LeanCloud 会自动对其清理。</p>
<p>默认的查询行为不使用缓存，需要通过 <code>query.cachePolicy</code> 来启用。例如，当网络不可用时，尝试网络连接并同时取回已缓存的数据:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">query<span class="variable">.cachePolicy</span> = k<span class="built_in">AVCachePolicyNetworkElseCache</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置缓存有效期</span></span><br><span class="line">query<span class="variable">.maxCacheAge</span> = <span class="number">24</span>*<span class="number">3600</span>;</span><br><span class="line"></span><br><span class="line">[query findObjectsInBackgroundWithBlock:^(<span class="built_in">NSArray</span> *objects, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">    <span class="comment">// 成功找到结果，先找网络再访问磁盘</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 无法访问网络，本次查询结果未做缓存</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>LeanCloud 提供了几种不同的缓存策略：</p>
<ul>
<li><p><code>kAVCachePolicyIgnoreCache</code></p>
<p><strong>（默认缓存策略）</strong>查询行为不从缓存加载，也不会将结果保存到缓存中。</p>
</li>
<li><p><code>kAVCachePolicyCacheOnly</code></p>
<p>查询行为忽略网络状况，只从缓存加载。如果没有缓存结果，该策略会产生 <code>AVError</code>。</p>
</li>
<li><p><code>kAVCachePolicyCacheElseNetwork</code></p>
<p>查询行为首先尝试从缓存加载，若加载失败，则通过网络加载结果。如果缓存和网络获取行为均为失败，则产生 <code>AVError</code>。</p>
</li>
<li><p><code>kAVCachePolicyNetworkElseCache</code></p>
<p>查询行为先尝试从网络加载，若加载失败，则从缓存加载结果。如果缓存和网络获取行为均为失败，则产生 <code>AVError</code>。</p>
</li>
<li><p><code>kAVCachePolicyCacheThenNetwork</code></p>
<p>查询先从缓存加载，然后从网络加载。在这种情况下，回调函数会被调用两次，第一次是缓存中的结果，然后是从网络获取的结果。因为它会在不同的时间返回两个结果，所以该策略不能与 <code>findObjects</code> 同时使用。</p>
</li>
</ul>
<p>要控制缓存行为，可以使用 <code>AVQuery</code> 提供的相应方法：</p>
<ul>
<li><p>检查是否存在缓存查询结果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> isInCache = [query hasCachedResult];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>删除某一查询的任何缓存结果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[query clearCachedResult];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>删除查询的所有缓存结果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVQuery</span> clearAllCachedResults];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>设定缓存结果的最长时限：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query<span class="variable">.maxCacheAge</span> = <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>; <span class="comment">// 一天的总秒数</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>查询缓存也适用于 <code>AVQuery</code> 的辅助方法，包括 <code>getFirstObject</code> 和 <code>getObjectInBackground</code>。</p>
<h3 id="对象计数">对象计数</h3><p>如果只需要得到查询出来的对象数量，不需要检索匹配的对象，可以用 <code>countObjects</code> 来代替 <code>findObjects</code>。</p>
<p>例如，计算一下某位用户一共发布了多少条微博：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[query whereKey:<span class="string">@"pubUser"</span> equalTo:<span class="string">@"张三"</span>];</span><br><span class="line">[query countObjectsInBackgroundWithBlock:^(<span class="keyword">int</span> count, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">    <span class="comment">// 查询成功，输出计数</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"张三 发布了 %d 条微博"</span>, count);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 查询失败</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p><code>countObjects</code> 是一种同步式的方法，因此使用它可以阻塞调用线程。</p>
<p>对含有超过 1000 个对象的类，使用计数操作很可能会导致响应超时，或返回数值近似精确，所以在构建程序时，应该尽量避免这样的操作。</p>
<h3 id="复合查询">复合查询</h3><p>如果想从多个查询中，找出与其中任意一个相匹配的对象，可以使用方法 <code>orQueryWithSubqueries:</code>。</p>
<p>例如，找出赢了很多场比赛或者只赢了几场比赛的球员：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span> *lotsOfWins = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Player"</span>];</span><br><span class="line">[lotsOfWins whereKey:<span class="string">@"wins"</span> greaterThan:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">150</span>]];</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVQuery</span> *fewWins = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Player"</span>];</span><br><span class="line">[fewWins whereKey:<span class="string">@"wins"</span> lessThan:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">5</span>]];</span><br><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVQuery</span> orQueryWithSubqueries:[<span class="built_in">NSArray</span> arrayWithObjects:fewWins,lotsOfWins,<span class="literal">nil</span>]];</span><br><span class="line">[query findObjectsInBackgroundWithBlock:^(<span class="built_in">NSArray</span> *results, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">  <span class="comment">// 返回赢球次数大于 150 场或小于 5 场的球员</span></span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p>你可以对新创建的 <code>AVQuery</code> 添加额外的约束，多个约束将以 AND 运算符来联接。</p>
<p>注意：在复合查询的子查询中，不能使用非过滤性的约束（如 <code>limit</code>、 <code>skip</code>、<code>orderBy...:</code>、 <code>includeKey:</code>）。</p>
<h3 id="Cloud_Query_Language（CQL）查询">Cloud Query Language（CQL）查询</h3><p>我们还提供类似于 SQL 语言的查询语言 CQL，使用方法如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *cql = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"select * from %@"</span>, <span class="string">@"ATestClass"</span>];</span><br><span class="line"><span class="built_in">AVCloudQueryResult</span> *result = [<span class="built_in">AVQuery</span> doCloudQueryWithCQL:cql];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"results:%@"</span>, result<span class="variable">.results</span>);</span><br><span class="line"></span><br><span class="line">cql = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"select count(*) from %@"</span>, <span class="string">@"ATestClass"</span>];</span><br><span class="line">result = [<span class="built_in">AVQuery</span> doCloudQueryWithCQL:cql];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"count:%lu"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)result<span class="variable">.count</span>);</span><br></pre></td></tr></table></figure>
<p>通常，查询语句会使用变量参数。为此，我们提供了与 Java JDBC 所使用的 <code>PreparedStatement</code> 占位符查询相类似的语法结构。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *cql = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"select * from %@ where durability = ? and name = ?"</span>, <span class="string">@"ATestClass"</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *pvalues =  @[@<span class="number">100</span>, <span class="string">@"祈福"</span>];</span><br><span class="line">[<span class="built_in">AVQuery</span> doCloudQueryInBackgroundWithCQL:cql pvalues:pvalues callback:^(<span class="built_in">AVCloudQueryResult</span> *result, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="comment">// 操作成功</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>可变参数 <code>100</code> 和 <code>&quot;祈福&quot;</code> 会被自动替换到查询语句中的问号位置（按问号出现的先后顺序）。我们更推荐使用占位符语法，理论上这样会降低 CQL 转换的性能开销。</p>
<p>关于 CQL 的详细介绍，请参考 <a href="cql_guide.html">Cloud Query Language 详细指南</a>。</p>
<h2 id="应用内搜索">应用内搜索</h2><p>我们虽然提供了基于正则的模糊查询，但是正则查询有两个缺点：</p>
<ul>
<li>当数据量逐步增大后，查询效率将越来越低</li>
<li>没有文本相关性排序</li>
</ul>
<p>因此，我们还提供了<a href="./app_search_guide.html">应用内搜索功能</a>，基于搜索引擎构建，提供更强大的搜索功能。</p>
<h2 id="子类化">子类化</h2><p>LeanCloud 设计的目标是让你的应用尽快运行起来。你可以用 <code>AVObject</code> 访问到所有的数据，用 <code>objectForKey:</code> 获取任意字段。 在成熟的代码中，子类化有很多优势，包括降低代码量，具有更好的扩展性，和支持自动补全。</p>
<p>子类化是可选的，请对照下面的例子来加深理解：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AVObject *student = [AVObject <span class="string">objectWithClassName:</span>@<span class="string">"Student"</span>];</span><br><span class="line">[student <span class="string">setObject:</span>@<span class="string">"小明"</span> <span class="string">forKey:</span>@<span class="string">"name"</span>];</span><br><span class="line">[student saveInBackground];</span><br></pre></td></tr></table></figure>
<p>可改写成:</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student *student = <span class="string">[Student object]</span>;</span><br><span class="line">student.name = @<span class="string">"小明"</span>;</span><br><span class="line"><span class="string">[student saveInBackground]</span>;</span><br></pre></td></tr></table></figure>
<p>这样代码看起来是不是更简洁呢？</p>
<h3 id="子类化的实现">子类化的实现</h3><p>要实现子类化，需要下面几个步骤：</p>
<ol>
<li>导入 <code>AVObject+Subclass.h</code>；</li>
<li>继承 <code>AVObject</code> 并实现 <code>AVSubclassing</code> 协议；</li>
<li>实现类方法 <code>parseClassName</code>，返回的字符串是原先要传给 <code>initWithClassName:</code> 的参数，这样后续就不必再进行类名引用了。如果不实现，默认返回的是类的名字。<strong>请注意： <code>AVUser</code> 子类化后必须返回 <code>_User</code></strong>；</li>
<li>在实例化子类之前调用 <code>[YourClass registerSubclass]</code>（<strong>在应用当前生命周期中，只需要调用一次</strong>，所以建议放在 <code>ApplicationDelegate</code> 中，在 <code>[AVOSCloud setApplicationId:clientKey:]</code> 之前调用即可）。</li>
</ol>
<p>下面是实现 <code>Student</code> 子类化的例子:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student.h</span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;AVOSCloud/AVOSCloud.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">AVObject</span> &lt;<span class="title">AVSubclassing</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Student.m</span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"Student.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@dynamic</span> name;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSString</span> *)parseClassName &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@"Student"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// AppDelegate.m</span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;AVOSCloud/AVOSCloud.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"Student.h"</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">  [Student registerSubclass];</span><br><span class="line">  [<span class="built_in">AVOSCloud</span> setApplicationId:appid clientKey:appkey];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="属性">属性</h3><p>为 <code>AVObject</code> 的子类添加自定义的属性和方法，可以更好地将这个类的逻辑封装起来。用 <code>AVSubclassing</code> 可以把所有的相关逻辑放在一起，这样不必再使用不同的类来区分业务逻辑和存储转换逻辑了。</p>
<p><code>AVObject</code> 支持动态 synthesizer，就像 <code>NSManagedObject</code> 一样。先正常声明一个属性，只是在 .m 文件中把 <code>@synthesize</code> 变成 <code>@dynamic</code>。</p>
<p>请看下面的例子是怎么添加一个「年龄」属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student.h</span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;AVOSCloud/AVOSCloud.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">AVObject</span> &lt;<span class="title">AVSubclassing</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Student.m</span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"Student.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@dynamic</span> age;</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>这样就可以通过 <code>student.age = 19</code> 这样的方式来读写 <code>age</code> 字段了，当然也可以写成：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[student setAge:<span class="number">19</span>]</span><br></pre></td></tr></table></figure>
<p><strong>注意：属性名称保持首字母小写！</strong>（错误：<code>student.Age</code> 正确：<code>student.age</code>）。</p>
<p><code>NSNumber</code> 类型的属性可用 <code>NSNumber</code> 或者是它的原始数据类型（<code>int</code>、 <code>long</code> 等）来实现。例如， <code>[student objectForKey:@&quot;age&quot;]</code> 返回的是 <code>NSNumber</code> 类型，而实际被设为 <code>int</code> 类型。</p>
<p>你可以根据自己的需求来选择使用哪种类型。原始类型更为易用，而 <code>NSNumber</code> 支持 <code>nil</code> 值，这可以让结果更清晰易懂。</p>
<p><strong>注意</strong> 子类中，对于 <code>BOOL</code> 类型的字段，SDK 在 3.1.3.2 之前会将其保存为 Number 类型，3.1.3.2 之后将其正确保存为 Bool 类型。详情请参考<a href="https://leancloud.cn/docs/ios_os_x_faq.html#为什么升级到_3_1_3_2_以上的版本时_BOOL_类型数据保存错误_" target="_blank" rel="external">这里</a>。</p>
<p>注意：<code>AVRelation</code> 同样可以作为子类化的一个属性来使用，比如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">AVUser</span> &lt;<span class="title">AVSubclassing</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span>(retain) <span class="built_in">AVRelation</span> *friends;</span><br><span class="line">  ......</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"><span class="keyword">@dynamic</span> friends;</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure>
<p>另外，值为 Pointer 的实例可用 <code>AVObject*</code> 来表示。例如，如果 <code>Student</code> 中 <code>bestFriend</code> 代表一个指向另一个 <code>Student</code> 的键，由于 Student 是一个 AVObject，因此在表示这个键的值的时候，可以用一个 <code>AVObject*</code> 来代替：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">AVUser</span> &lt;<span class="title">AVSubclassing</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">AVObject</span> *bestFriend;</span><br><span class="line"> ......</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"><span class="keyword">@dynamic</span> bestFriend;</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure>
<p>提示：当需要更新的时候，最后都要记得加上 <code>[student save]</code> 或者对应的后台存储函数进行更新，才会同步至服务器。</p>
<p>如果要使用更复杂的逻辑而不是简单的属性访问，可以这样实现:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@dynamic</span> iconFile;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIImageView</span> *)iconView &#123;</span><br><span class="line">  <span class="built_in">UIImageView</span> *view = [[<span class="built_in">UIImageView</span> alloc] initWithImage:kPlaceholderImage];</span><br><span class="line">  view<span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:<span class="keyword">self</span><span class="variable">.iconFile</span>];</span><br><span class="line">  <span class="keyword">return</span> [view autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="针对_AVUser_子类化的特别说明">针对 AVUser 子类化的特别说明</h3><p>假如现在已经有一个基于 <code>AVUser</code> 的子类，如上面提到的 <code>Student</code>:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">AVUser</span>&lt;<span class="title">AVSubclassing</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (retain) <span class="built_in">NSString</span> *displayName;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"><span class="keyword">@dynamic</span> displayName;</span><br><span class="line">+ (<span class="built_in">NSString</span> *)parseClassName &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@"_User"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>登录时需要调用 <code>Student</code> 的登录方法才能通过 <code>currentUser</code> 得到这个子类:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Student logInWithUsernameInBackground:<span class="string">@"USER_NAME"</span> password:<span class="string">@"PASSWORD"</span> block:^(<span class="built_in">AVUser</span> *user, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        Student *student = [Student currentUser];</span><br><span class="line">        student<span class="variable">.displayName</span> = <span class="string">@"YOUR_DISPLAY_NAME"</span>;</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<p>同样需要调用 <code>[Student registerSubclass];</code>，确保在其它地方得到的对象是 Student，而非 AVUser 。</p>
<h3 id="初始化子类">初始化子类</h3><p>创建一个子类实例，要使用 <code>object</code> 类方法。要创建并关联到已有的对象，请使用 <code>objectWithoutDataWithObjectId:</code> 类方法。</p>
<h3 id="子类查询">子类查询</h3><p>使用类方法 <code>query</code> 可以得到这个子类的查询对象。</p>
<p>例如，查询年龄小于 21 岁的学生：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span> *query = [Student query];</span><br><span class="line">[query whereKey:<span class="string">@"age"</span> lessThanOrEqualTo:@(<span class="number">21</span>)];</span><br><span class="line">[query findObjectsInBackgroundWithBlock:^(<span class="built_in">NSArray</span> *objects, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">    Student *stu1 = [objects objectAtIndex:<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h2 id="ACL权限控制">ACL权限控制</h2><p>ACL（Access Control List）是最灵活而且简单的应用数据安全管理方法。通俗的解释就是为每一个数据创建一个访问的白名单列表，只有在名单上的用户（ <code>AVUser</code>）或者具有某种角色（<code>AVRole</code>）的用户才能被允许访问。为了更好地保证用户数据安全性，LeanCloud 的每一张表中都有一个 ACL 列。</p>
<p>当然，LeanCloud 还提供了进一步的读写权限控制。一个 User 必须拥有读权限（或者属于一个拥有读权限的 Role）才可以获取一个对象的数据；同时，一个 User 需要写权限（或者属于一个拥有写权限的 Role）才可以更改或者删除一个对象。</p>
<p>以下列举了几种在 LeanCloud 常见的 ACL 使用范例。</p>
<h3 id="默认访问权限">默认访问权限</h3><p>在没有显式指定的情况下，LeanCloud 中的每一个对象都会有一个默认的 ACL 值。这个值表示，所有的用户对这个对象都是可读可写的。此时在 LeanCloud 账户的「数据管理」列表中的 ACL 属性列，会看到这样的值：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;"<span class="attribute">*</span>":<span class="value">&#123;"<span class="attribute">read</span>":<span class="value"><span class="literal">true</span></span>,"<span class="attribute">write</span>":<span class="value"><span class="literal">true</span></span>&#125;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>对应的 Objective-C 代码是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVACL</span> *acl = [<span class="built_in">AVACL</span> ACL];</span><br><span class="line">[acl setPublicReadAccess:<span class="literal">YES</span>];</span><br><span class="line">[acl setPublicWriteAccess:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>
<p>当然正如上文提到的，默认的 ACL 并不需要进行显式指定。</p>
<h3 id="指定用户访问权限">指定用户访问权限</h3><p>当一个用户在实现一个网盘类应用时，针对不同文件的私密性，用户就需要不同的文件访问权限。譬如公开的文件，每一个其他用户都有读的权限，然后仅仅只有创建者才拥有更改和删除的权限。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">AVACL</span> *acl = [<span class="built_in">AVACL</span> ACL];</span><br><span class="line">[acl setPublicReadAccess:<span class="literal">YES</span>]; <span class="comment">//此处设置的是所有人的可读权限</span></span><br><span class="line">[acl setWriteAccess:<span class="literal">YES</span> forUser:[<span class="built_in">AVUser</span> currentUser]]; <span class="comment">//而这里设置了文件创建者的写权限</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">AVObject</span> * object = [<span class="built_in">AVObject</span> objectWithClassName:<span class="string">@"iOSAclTest"</span>];</span><br><span class="line"></span><br><span class="line">object<span class="variable">.ACL</span>=acl;</span><br><span class="line">[object save];</span><br></pre></td></tr></table></figure>
<p>当然用户也会上传一些隐私文件，只有这些文件的创建者才对这些文件拥有读写权限：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[acl setWriteAccess:<span class="literal">YES</span> forUser:[<span class="built_in">AVUser</span> currentUser]];</span><br></pre></td></tr></table></figure>
<p>注：一旦显式设置了 ACL，默认的 ACL 就会被覆盖。</p>
<h3 id="指定角色访问权限">指定角色访问权限</h3><h4 id="AVUser_与_AVRole_的从属关系">AVUser 与 AVRole 的从属关系</h4><p>指定用户访问权限虽然很方便，但是依然会有局限性。</p>
<p>以工资系统为例，一家公司的工资系统，工资最终的归属者和公司的出纳们只对工资有读的权限，而公司的人事和老板才拥有全部的读写权限。当然你可以通过多次设置指定用户的访问权限来实现这一功能（多个用户的 ACL 设置是追加的而非覆盖）。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVObect</span> *salary = [<span class="built_in">AVObject</span> objectWithClassName:<span class="string">@"Salary"</span>];</span><br><span class="line">[salary setObject:@(<span class="number">2000000</span>) forKey:<span class="string">@"value"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里为了方便说明, 直接声明了变量, 但没有实现</span></span><br><span class="line"><span class="built_in">AVUser</span> *boss;    <span class="comment">//假设此处为老板</span></span><br><span class="line"><span class="built_in">AVUser</span> *hrWang;  <span class="comment">//人事小王</span></span><br><span class="line"><span class="built_in">AVUser</span> *me;      <span class="comment">//我们就在文档里爽一爽吧</span></span><br><span class="line"><span class="built_in">AVUser</span> *cashierZhou;  <span class="comment">//出纳老周</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">AVACL</span> *acl = [<span class="built_in">AVACL</span> ACL];</span><br><span class="line"></span><br><span class="line"><span class="comment">//4 个人都有可读权限</span></span><br><span class="line">[acl setReadAccess:<span class="literal">YES</span> forUser:boss];</span><br><span class="line">[acl setReadAccess:<span class="literal">YES</span> forUser:hrWang];</span><br><span class="line">[acl setReadAccess:<span class="literal">YES</span> forUser:cashierZhou];</span><br><span class="line">[acl setReadAccess:<span class="literal">YES</span> forUser:me];</span><br><span class="line"></span><br><span class="line"><span class="comment">//只有 2 个人可写</span></span><br><span class="line">[acl setWriteAccess:<span class="literal">YES</span> forUser:boss];</span><br><span class="line">[acl setWriteAccess:<span class="literal">YES</span> forUser:hrWang];</span><br><span class="line"></span><br><span class="line">[salary setACL:acl];</span><br><span class="line">[salary save];</span><br></pre></td></tr></table></figure>
<p>但是涉及的人可能不止一个，也有离职、换岗、新员工的问题存在。这样的代码既不优雅，也太啰嗦，同样会很难维护。这个时候我们就引入了 <code>AVRole</code> 来解决这个问题。</p>
<p>公司的员工可以成百上千，然而一个公司组织里的角色却能够在很长一段时间内保持相对稳定。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVObect</span> *salary = [<span class="built_in">AVObject</span> objectWithClassName:<span class="string">@"Salary"</span>];</span><br><span class="line">[salary setObject:@(<span class="number">2000000</span>) forKey:<span class="string">@"value"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里为了方便说明, 直接声明了变量, 但没有实现</span></span><br><span class="line"><span class="built_in">AVUser</span> *boss;    <span class="comment">//假设此处为老板</span></span><br><span class="line"><span class="built_in">AVUser</span> *hrWang;  <span class="comment">//人事小王</span></span><br><span class="line"><span class="built_in">AVUser</span> *me;      <span class="comment">//我们就在文档里爽一爽吧</span></span><br><span class="line"><span class="built_in">AVUser</span> *cashierZhou; <span class="comment">//出纳老周</span></span><br><span class="line"><span class="built_in">AVUser</span> *cashierGe;   <span class="comment">//出纳小葛</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这段代码可能放在员工管理界面更恰当，但是为了示意，我们就放在这里</span></span><br><span class="line"><span class="built_in">AVRole</span> *hr =[<span class="built_in">AVRole</span> roleWithName:<span class="string">@"hr"</span>];</span><br><span class="line"><span class="built_in">AVRole</span> *cashier = [<span class="built_in">AVRole</span> roleWithName:<span class="string">@"cashier"</span>];</span><br><span class="line"></span><br><span class="line">[[hr users] addObject:hrWang];</span><br><span class="line">[hr save];</span><br><span class="line"><span class="comment">//此处对应的是 AVRole 里面有一个叫做 users 的 Relation 字段</span></span><br><span class="line">[[cashier users] addObject:cashierZhou];</span><br><span class="line">[[cashier users] addObject:cashierGe];</span><br><span class="line">[cashier save];</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVACL</span> *acl = [<span class="built_in">AVACL</span> ACL];</span><br><span class="line"><span class="comment">//老板假设只有一个</span></span><br><span class="line">[acl setReadAccess:<span class="literal">YES</span> forUser:boss];</span><br><span class="line">[acl setReadAccess:<span class="literal">YES</span> forUser:me];</span><br><span class="line"></span><br><span class="line">[acl setReadAccess:<span class="literal">YES</span> forRole:hr];</span><br><span class="line">[acl setReadAccess:<span class="literal">YES</span> forRole:cashier];</span><br><span class="line"></span><br><span class="line">[acl setWriteAccess:<span class="literal">YES</span> forUser:boss];</span><br><span class="line">[acl setWriteAccess:<span class="literal">YES</span> forRole:hr];</span><br><span class="line"></span><br><span class="line">[salary setACL:acl];</span><br><span class="line">[salary save];</span><br></pre></td></tr></table></figure>
<p>当然如果考虑到一个角色（<code>AVRole</code>）里面有多少员工（<code>AVUser</code>），编辑这些员工所需要的权限控制，<code>AVRole</code> 同样也有 <code>setACL</code> 方法可以使用。</p>
<h4 id="AVRole_之间的从属关系">AVRole 之间的从属关系</h4><p>在讲清楚了用户与角色的关系后，我们还有一层角色与角色之间的关系，下面的例子或许可以帮助你理解这个概念。</p>
<p>一家创业公司设有移动部门，该部门下面有不同的小组（Android 和 iOS），每个小组只对自己组的代码拥有「读写」权限，但他们同时对核心库代码拥有「读取」权限。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVRole</span> *androidTeam = [<span class="built_in">AVRole</span> roleWithName:<span class="string">@"AndroidTeam"</span>];</span><br><span class="line"><span class="built_in">AVRole</span> *iOSTeam = [<span class="built_in">AVRole</span> roleWithName:<span class="string">@"IOSTeam"</span>];</span><br><span class="line"><span class="built_in">AVRole</span> *mobileDev = [<span class="built_in">AVRole</span> roleWithName:<span class="string">@"MobileDev"</span>];</span><br><span class="line"></span><br><span class="line">[androidTeam save];</span><br><span class="line">[iOSTeam save];</span><br><span class="line"></span><br><span class="line">[[mobileDev roles] addObject:androidTeam];</span><br><span class="line">[[mobileDev roles] addObject:iOSTeam];</span><br><span class="line"></span><br><span class="line">[mobileDev save];</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVObject</span> *androidCode = [<span class="built_in">AVObject</span> objectWithClassName:<span class="string">@"Code"</span>];</span><br><span class="line"><span class="built_in">AVObject</span> *iOSCode = [<span class="built_in">AVObject</span> objectWithClassName:<span class="string">@"Code"</span>];</span><br><span class="line"><span class="built_in">AVObject</span> *coreCode = [<span class="built_in">AVObject</span> objectWithClassName:<span class="string">@"Code"</span>];</span><br><span class="line"><span class="comment">//.....此处省略一些具体的值设定</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">AVACL</span> *acl1=[<span class="built_in">AVACL</span> ACL];</span><br><span class="line">[acl1 setReadAccess:<span class="literal">YES</span> forRole:androidTeam];</span><br><span class="line">[acl1 setWriteAccess:<span class="literal">YES</span> forRole:androidTeam];</span><br><span class="line">[androidCode setACL:acl1];</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVACL</span> *acl2=[<span class="built_in">AVACL</span> ACL];</span><br><span class="line">[acl2 setReadAccess:<span class="literal">YES</span> forRole:iOSTeam];</span><br><span class="line">[acl2 setWriteAccess:<span class="literal">YES</span> forRole:iOSTeam];</span><br><span class="line">[iOSCode setACL:acl2];</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVACL</span> *acl3=[<span class="built_in">AVACL</span> ACL];</span><br><span class="line">[acl3 setReadAccess:<span class="literal">YES</span> forRole:mobileDev];</span><br><span class="line">[coreCode setACL:acl3];</span><br><span class="line"></span><br><span class="line">[androidCode save];</span><br><span class="line">[iOSTeam save];</span><br><span class="line">[coreCode save];</span><br></pre></td></tr></table></figure>
<h2 id="文件">文件</h2><h3 id="AVFile">AVFile</h3><p><code>AVFile</code> 允许应用将文件存储到服务端，它支持图片、视频、音乐等常见的文件类型，以及其他任何二进制数据。</p>
<p><code>AVFile</code> 的用法非常简单。首先把文件数据存到 <code>NSData</code> 中，然后用该 <code>NSData</code> 格式的数据来创建 <code>AVFile</code> 对象。下面以存储一个字符串为例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSData</span> *data = [<span class="string">@"Working with LeanCloud is great!"</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">AVFile</span> *file = [<span class="built_in">AVFile</span> fileWithName:<span class="string">@"resume.txt"</span> data:data];</span><br></pre></td></tr></table></figure>
<p>注意在上例中，我们将文件命名为 <code>resume.txt</code>。这里需要注意两点：</p>
<ul>
<li>不必担心文件名冲突。每一个上传的文件都有惟一的 ID，所以即使上传多个文件名为 <code>resume.txt</code> 的文件也不会有问题。</li>
<li>给文件添加扩展名非常重要。LeanCloud 通过扩展名来判断文件类型，以便正确处理文件。所以，要将一张 PNG 图片存到 <code>AVFile</code> 中，要确保使用 <code>.png</code> 扩展名。</li>
</ul>
<p>然后根据需要，调用相应的 <code>saveInBackground</code> 方法，将文件存到 LeanCloud 上：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[file saveInBackground];</span><br></pre></td></tr></table></figure>
<p>最终当文件存储完成后，你可以象操作其他数据那样，将 <code>AVFile</code> 关联到 <code>AVObject</code> 上。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVObject</span> *obj = [<span class="built_in">AVObject</span> objectWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[obj setObject:<span class="string">@"Joe Smit#花儿与少年# 迪拜疯狂之旅"</span> forKey:<span class="string">@"content"</span>];</span><br><span class="line">[obj setObject:file         forKey:<span class="string">@"attached"</span>];</span><br><span class="line">[obj saveInBackground];</span><br></pre></td></tr></table></figure>
<p>重新获取该数据时，只需要调用 <code>AVFile</code> 的 <code>getData</code> 方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVFile</span> *attachment = [anotherObj objectForKey:<span class="string">@"attached"</span>];</span><br><span class="line"><span class="built_in">NSData</span> *binaryData = [attachment getData];</span><br></pre></td></tr></table></figure>
<p>也可以像 <code>AVObject</code> 那样，使用 <code>getData</code> 的异步版本。</p>
<p><strong>如果对象的某一属性是一个文件数组，那么在获取该属性的查询中，必须加上 <code>includeKey:</code> 来指定该属性名，否则，查询结果中该属性对应的值将是 <code>AVObject</code> 数组，而不是 <code>AVFile</code> 数组。</strong></p>
<h3 id="图像">图像</h3><p>将图像转成 <code>NSData</code> 再使用 <code>AVFile</code> ，就能很容易地将数据保存到 LeanCloud 上。</p>
<p>例如，把名为 <code>image</code> 的 <code>UIImage</code> 对象保存到 <code>AVFile</code> 中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSData</span> *imageData = <span class="built_in">UIImagePNGRepresentation</span>(image);</span><br><span class="line"><span class="built_in">AVFile</span> *imageFile = [<span class="built_in">AVFile</span> fileWithName:<span class="string">@"image.png"</span> data:imageData];</span><br><span class="line">[imageFile save];</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVObject</span> *userPost = [<span class="built_in">AVObject</span> objectWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[userPost setObject:<span class="string">@"My trip to Dubai!"</span> forKey:<span class="string">@"content"</span>];</span><br><span class="line">[userPost setObject:imageFile            forKey:<span class="string">@"attached"</span>];</span><br><span class="line">[userPost save];</span><br></pre></td></tr></table></figure>
<h3 id="进度提示">进度提示</h3><p>使用 <code>saveInBackgroundWithBlock:progressBlock:</code> 和 <code>getDataInBackgroundWithBlock:progressBlock:</code> 可以获取 <code>AVFile</code> 的上传或下载进度。比如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSData</span> *data = [<span class="string">@"Working at LeanCloud is great!"</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">AVFile</span> *file = [<span class="built_in">AVFile</span> fileWithName:<span class="string">@"resume.txt"</span> data:data];</span><br><span class="line">[file saveInBackgroundWithBlock:^(<span class="built_in">BOOL</span> succeeded, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">  <span class="comment">// 成功或失败处理...</span></span><br><span class="line">&#125; progressBlock:^(<span class="keyword">int</span> percentDone) &#123;</span><br><span class="line">  <span class="comment">// 更新进度数据，percentDone 介于 0 和 100。</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="得到图像的缩略图">得到图像的缩略图</h3><p>保存图像时，如果想在下载原图之前先得到缩略图，那么用我们的 API 实现起来会易如反掌：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVFile</span> *file = [<span class="built_in">AVFile</span> fileWithURL:<span class="string">@"the-file-remote-url"</span>];</span><br><span class="line">[file getThumbnail:<span class="literal">YES</span> width:<span class="number">100</span> height:<span class="number">100</span> withBlock:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<h3 id="文件元数据">文件元数据</h3><p><code>AVFile</code> 的 <code>metaData</code> 属性，可以用来保存和获取该文件对象的元数据信息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVFile</span> *file = [<span class="built_in">AVFile</span> fileWithName:<span class="string">@"test.jpg"</span> contentsAtPath:<span class="string">@"file-local-path"</span>];</span><br><span class="line">[file<span class="variable">.metaData</span> setObject:@(<span class="number">100</span>) forKey:<span class="string">@"width"</span>];</span><br><span class="line">[file<span class="variable">.metaData</span> setObject:@(<span class="number">100</span>) forKey:<span class="string">@"height"</span>];</span><br><span class="line">[file<span class="variable">.metaData</span> setObject:<span class="string">@"LeanCloud"</span> forKey:<span class="string">@"author"</span>];</span><br><span class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">[file save:&amp;error];</span><br></pre></td></tr></table></figure>
<h3 id="删除">删除</h3><p>当文件较多时，要把一些不需要的文件从 LeanCloud 上删除：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[file deleteInBackgroundWithBlock:^(<span class="built_in">BOOL</span> succeeded, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="清除缓存">清除缓存</h3><p><code>AVFile</code> 也提供了清除缓存的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清除当前文件缓存</span></span><br><span class="line">- (<span class="keyword">void</span>)clearCachedFile;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类方法, 清除所有缓存</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)clearAllCachedFiles;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类方法, 清除多久以前的缓存</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)clearCacheMoreThanDays:(<span class="built_in">NSInteger</span>)numberOfDays;</span><br></pre></td></tr></table></figure>
<h3 id="iOS_9_适配">iOS 9 适配</h3><p>iOS 9 默认屏蔽了 HTTP 访问，只支持 HTTPS 访问。LeanCloud 除了文件的 getData 之外的 API 都是支持 HTTPS 访问的。 现有两种方式解决这个问题。</p>
<h4 id="项目中配置访问策略">项目中配置访问策略</h4><p>一是在项目中额外配置一下该接口的访问策略。选择项目的 Info.plist，右击以 Source Code 的方式打开。在 plist -&gt; dict 节点中加入以下文本：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">key</span>&gt;</span>NSAppTransportSecurity<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">dict</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">key</span>&gt;</span>NSExceptionDomains<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">key</span>&gt;</span>clouddn.com<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">dict</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">key</span>&gt;</span>NSIncludesSubdomains<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">true</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">key</span>&gt;</span>NSTemporaryExceptionAllowsInsecureHTTPLoads<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">true</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">dict</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dict</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者在 Target 的 Info 标签中修改配置：</p>
<p><img src="images/ios_qiniu_http.png" alt="Info.plist Setting"></p>
<p>如果是美国节点，请把上面的 <code>clouddn.com</code> 换成 <code>amazonaws.com</code>。</p>
<p>也可以根据项目需要，允许所有的 HTTP 访问，更多可参考 <a href="https://github.com/ChenYilong/iOS9AdaptationTips" target="_blank" rel="external">iOS 9 适配系列教程</a>。</p>
<h4 id="启用文件_SSL_域名">启用文件 SSL 域名</h4><p>另外一种方法是在网站控制台中进入相关的应用，点击上方的设置选项卡，勾选「启用文件 SSL 域名（对应 _File 中存储的文件）」选项。这样便启用了文件 SSL 域名，支持 HTTPS 访问。如图所示：</p>
<p><img src="images/ios_file_ssl_config.png" alt="File SSL Config"></p>
<p>如果启用文件 SSL 域名前已经保存了许多文件，启用之后，这些文件的 URL 也会跟着变化，来支持 HTTPS 访问。</p>
<p>这两种方式都能解决这个问题。但需要注意的是，实时通信组件 LeanMessage 也用了 AVFile 来保存消息的图片、音频等文件，并且把文件的地址写入到了消息内容中。开启了文件 SSL 域名后，历史消息中的文件地址将不会像控制台里 _File 表那样跟着改变。所以如果使用了实时通信组件并已上线，推荐使用方式一。</p>
<h2 id="用户">用户</h2><p>用户是一个应用程序的核心。对于个人开发者来说，能够让自己的应用程序积累更多的用户，就能给自己带来更多的创作动力。因此 LeanCloud 提供了一个专门的用户类 <code>AVUser</code>，来自动处理用户账户管理所需的功能。有了这个类，你就可以在应用程序中添加用户账户功能。</p>
<p><code>AVUser</code> 是一个 <code>AVObject</code> 的子类，它继承了 <code>AVObject</code> 所有的方法，具有 <code>AVObject</code> 相同的功能。不同的是，<code>AVUser</code> 增加了一些特定的与用户账户相关的功能。</p>
<h3 id="属性-1">属性</h3><p><code>AVUser</code> 除了继承 <code>AVObject</code> 的属性外，还有几个特有的属性：</p>
<ul>
<li><code>username</code> : 用户的用户名（必需）</li>
<li><code>password</code> : 用户的密码（必需）</li>
<li><code>email</code> : 用户的电子邮件地址（可选）</li>
</ul>
<h3 id="注册">注册</h3><p>要求用户注册可能是应用程序要做的第一件事。下面的代码是一个典型的注册过程：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVUser</span> *user = [<span class="built_in">AVUser</span> user];</span><br><span class="line">user<span class="variable">.username</span> = <span class="string">@"hjiang"</span>;</span><br><span class="line">user<span class="variable">.password</span> =  <span class="string">@"f32@ds*@&amp;dsa"</span>;</span><br><span class="line">user<span class="variable">.email</span> = <span class="string">@"hang@leancloud.rocks"</span>;</span><br><span class="line">[user setObject:<span class="string">@"186-1234-0000"</span> forKey:<span class="string">@"phone"</span>];</span><br><span class="line"></span><br><span class="line">[user signUpInBackgroundWithBlock:^(<span class="built_in">BOOL</span> succeeded, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (succeeded) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>在注册过程中，服务端会检查注册用户的信息，以确保注册的用户名和电子邮件地址是惟一的。</p>
<p><strong>服务端还会对用户密码进行不可逆的加密处理，不会明文保存任何密码。在客户端，应用切勿再次对密码加密，这会导致重置密码等功能失效。</strong></p>
<p>请注意，我们使用的是 <code>signUpInBackgroundWithBlock</code> 方法，而不是 <code>saveInBackground</code> 方法。另外还有各种不同的 <code>signUp</code> 方法可供使用。</p>
<p>像往常一样，我们建议，在可能的情况下，尽量使用异步版本的 <code>signUp</code> 方法，这样就不会影响到应用程序主 UI 线程的响应。具体方法请参考 <a href="/api-docs/iOS/index.html">API 文档</a> 。</p>
<p>如果注册不成功，请检查一下返回的错误对象。最有可能的情况是，用户名或电子邮件已经被另一个用户注册，此时可以提示用户尝试用不同的用户名进行注册，也可以要求用户用 Email 做为用户名注册。</p>
<p>这样做的好处是，在用户提交信息时可以将输入的「用户名」默认设置为用户的 Email 地址，以后在用户忘记了密码的情况下，可以使用 LeanCloud 提供的「重置密码」功能。</p>
<p>关于自定义邮件模板和验证链接，请参考博客文章 <a href="http://blog.leancloud.cn/blog/2014/01/09/zi-ding-yi-ying-yong-nei-yong-hu-zhong-she-mi-ma-he-you-xiang-yan-zheng-ye-mian/" target="_blank" rel="external">《自定义应用内用户重设密码和邮箱验证页面》</a>。</p>
<h3 id="登录">登录</h3><p>让注册成功的用户登录到自己的账户，可以调用 <code>AVUser</code> 类的 <code>loginInBackground</code> 方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVUser</span> logInWithUsernameInBackground:<span class="string">@"username"</span> password:<span class="string">@"password"</span> block:^(<span class="built_in">AVUser</span> *user, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (user != <span class="literal">nil</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="当前用户">当前用户</h3><p>如果用户在每次打开应用程序时都要登录，这会直接影响用户体验。为了避免这种情况，可以使用缓存的 <code>currentUser</code> 对象。</p>
<p>每当用户成功注册或第一次成功登录后，就在本地磁盘中缓存下这 个用户对象，供下次调用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVUser</span> *currentUser = [<span class="built_in">AVUser</span> currentUser];</span><br><span class="line"><span class="keyword">if</span> (currentUser != <span class="literal">nil</span>) &#123;</span><br><span class="line">    <span class="comment">// 允许用户使用应用</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//缓存用户对象为空时，可打开用户注册界面…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要清除缓存用户对象：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVUser</span> logOut];  <span class="comment">//清除缓存用户对象</span></span><br><span class="line"><span class="built_in">AVUser</span> *currentUser = [<span class="built_in">AVUser</span> currentUser]; <span class="comment">// 现在的currentUser是nil了</span></span><br></pre></td></tr></table></figure>
<h3 id="重置密码">重置密码</h3><p>我们都知道，应用一旦加入账户密码系统，那么肯定会有用户忘记密码的情况发生。对于这种情况，我们为用户提供了一种安全重置密码的方法。</p>
<p>重置密码的过程很简单，用户只需要输入注册的电子邮件地址即可：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVUser</span> requestPasswordResetForEmailInBackground:<span class="string">@"myemail@example.com"</span> block:^(<span class="built_in">BOOL</span> succeeded, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (succeeded) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>密码重置流程如下：</p>
<ol>
<li>用户输入注册的电子邮件，请求重置密码；</li>
<li>LeanCloud 向该邮箱发送一封包含重置密码的特殊链接的电子邮件；</li>
<li>用户点击重置密码链接后，一个特殊的页面会打开，让他们输入新密码；</li>
<li>用户的密码已被重置为新输入的密码。</li>
</ol>
<p>关于自定义邮件模板和验证链接，请参考这篇 <a href="http://blog.leancloud.cn/blog/2014/01/09/zi-ding-yi-ying-yong-nei-yong-hu-zhong-she-mi-ma-he-you-xiang-yan-zheng-ye-mian/" target="_blank" rel="external">博客</a> 。</p>
<h3 id="修改密码">修改密码</h3><p>当用户系统中存在密码时，自然会有更改密码的需求。我们所提供的方法能够同时验证老密码和修改新密码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVUser</span> logInWithUsername:<span class="string">@"username"</span> password:<span class="string">@"111111"</span>]; <span class="comment">//请确保用户当前的有效登录状态</span></span><br><span class="line">[[<span class="built_in">AVUser</span> currentUser] updatePassword:<span class="string">@"111111"</span> newPassword:<span class="string">@"123456"</span> block:^(<span class="keyword">id</span> object, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="comment">//处理结果</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>如果要求更改密码的用户尚未登录、原密码错误或用户不存在，这些情况都会通过回调返回操作错误信息。</p>
<h3 id="手机号码验证">手机号码验证</h3><p>如果在应用设置的 <strong>应用选项</strong> 中打开了 <strong>验证注册用户手机号码</strong> 选项，那么当用户在注册时填写完手机字段后，LeanCloud 会自动向该手机号码发送一条验证短信，用户输入验证码后，该用户即被标识为已经验证过手机了。</p>
<p>以下代码将注册验证码发送到用户手机上：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVUser</span> *user = [<span class="built_in">AVUser</span> user];</span><br><span class="line">user<span class="variable">.username</span> = <span class="string">@"hjiang"</span>;</span><br><span class="line">user<span class="variable">.password</span> =  <span class="string">@"f32@ds*@&amp;dsa"</span>;</span><br><span class="line">user<span class="variable">.email</span> = <span class="string">@"hang@leancloud.rocks"</span>;</span><br><span class="line">user<span class="variable">.mobilePhoneNumber</span> = <span class="string">@"18612340000"</span>;</span><br><span class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">[user signUp:&amp;error];</span><br></pre></td></tr></table></figure>
<p>调用以下代码即可验证验证码:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVUser</span> verifyMobilePhone:<span class="string">@"123456"</span> withBlock:^(<span class="built_in">BOOL</span> succeeded, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">       <span class="comment">//验证结果</span></span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure>
<p>验证成功后，用户的 <code>mobilePhoneVerified</code> 属性变为 <code>true</code>，并会触发调用云代码的 <code>AV.Cloud.onVerifed(&#39;sms&#39;, function)</code> 方法。</p>
<h3 id="手机号码登录">手机号码登录</h3><p>当手机号码通过验证后，用户可以使用该手机号码进行登录。手机号码包括两种方式：</p>
<ul>
<li>手机号码＋密码方式</li>
<li>手机号码＋短信验证码</li>
</ul>
<p>用「手机号码＋密码」来登录的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVUser</span> logInWithMobilePhoneNumberInBackground:<span class="string">@"18612340000"</span> password:<span class="string">@"yourpassword"</span> block:^(<span class="built_in">AVUser</span> *user, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>发送登录短信验证码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVUser</span> requestLoginSmsCode:<span class="string">@"123456"</span> withBlock:^(<span class="built_in">BOOL</span> succeeded, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>最后使用「短信验证码＋手机号码」进行登录：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVUser</span> logInWithMobilePhoneNumberInBackground:<span class="string">@"18612340000"</span> smsCode:smsCode block:^(<span class="built_in">AVUser</span> *user, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="手机号码重置密码">手机号码重置密码</h3><p>与使用「电子邮件地址重置密码」类似，「手机号码重置密码」使用下面的方法来获取短信验证码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVUser</span> requestPasswordResetWithPhoneNumber:<span class="string">@"18612340000"</span> block:^(<span class="built_in">BOOL</span> succeeded, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (succeeded) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>注意！用户需要先绑定手机号码，然后使用短信验证码来重置密码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVUser</span> resetPasswordWithSmsCode:<span class="string">@"123456"</span> newPassword:<span class="string">@"password"</span> block:^(<span class="built_in">BOOL</span> succeeded, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (succeeded) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="查询-1">查询</h3><p><strong>请注意，新创建应用的 <code>_User</code> 表的查询权限默认是关闭的，通常我们推荐你在云引擎里封装用户查询，只查询特定条件的用户，避免开放用户表的全部查询权限。此外，你可以通过 class 权限设置打开查询权限，请参考 <a href="data_security.html#Class_级别的权限">数据与安全 - Class 级别的权限</a>。</strong></p>
<p>查询用户的信息，需要使用特殊的用户查询对象来完成：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVUser</span> query];</span><br><span class="line">[query whereKey:<span class="string">@"gender"</span> equalTo:<span class="string">@"female"</span>];</span><br><span class="line">[query findObjectsInBackgroundWithBlock:^(<span class="built_in">NSArray</span> *objects, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (error == <span class="literal">nil</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="浏览器中查看用户表">浏览器中查看用户表</h3><p>用户表是一个特殊的表，专门存储 <code>AVUser</code> 对象。在浏览器端，打开 LeanCloud 账户页面的 <strong>存储</strong> 菜单，找到名为 <code>_User</code> 的表来查看数据。</p>
<h3 id="匿名用户">匿名用户</h3><p>要创建匿名用户，可以使用 <code>AVAnonymousUtils</code> 来完成。通过如下代码，服务端会自动创建一个 <code>AVUser</code> 对象，其用户名为随机字符串。完成之后，此用户对象会被设置为 <code>currentUser</code>，之后的修改、保存、登出等操作都可以使用 <code>currentUser</code> 来完成。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVAnonymousUtils</span> logInWithBlock:^(<span class="built_in">AVUser</span> *user, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (user) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h2 id="地理位置">地理位置</h2><p>LeanCloud 允许用户根据地球的经度和纬度坐标进行基于地理位置的信息查询。只要将 <code>AVGeoPoint</code> 添加到 <code>AVObject</code> 中，那么在查询时，即可轻松实现如找出离当前用户最近的信息或地点的功能。</p>
<h3 id="地理位置对象">地理位置对象</h3><p>首先要创建一个 <code>AVGeoPoint</code> 对象。例如，创建一个北纬 39.9 度、东经 116.4 度的 <code>AVGeoPoint</code> 对象（LeanCloud 北京办公室所在地）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVGeoPoint</span> *point = [<span class="built_in">AVGeoPoint</span> geoPointWithLatitude:<span class="number">39.9</span> longitude:<span class="number">116.4</span>];</span><br></pre></td></tr></table></figure>
<p>添加地理位置信息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[postObject setObject:point forKey:<span class="string">@"location"</span>];</span><br></pre></td></tr></table></figure>
<h3 id="地理查询">地理查询</h3><p>假设现在数据表中已保存了一些地理坐标数据，接下来使用 <code>AVQuery</code> 对象的 <code>whereNear</code> 方法来试着找出最接近某个点的信息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVObject</span> *userObject = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">AVGeoPoint</span> *userLocation =  (<span class="built_in">AVGeoPoint</span> *) [userObject objectForKey:<span class="string">@"location"</span>];</span><br><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[query whereKey:<span class="string">@"location"</span> nearGeoPoint:userLocation];</span><br><span class="line"><span class="comment">//获取最接近用户地点的10条微博</span></span><br><span class="line">query<span class="variable">.limit</span> = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">NSArray</span>&lt;<span class="built_in">AVObject</span> *&gt; nearPosts = [query findObjects];</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，<code>nearPosts</code> 返回的是与 <code>userLocation</code> 这一点按距离排序（由近到远）的对象数组。注意：<strong>如果在此之后又使用了 <code>orderByAscending:</code> 或 <code>orderByDescending:</code> 方法，则按距离排序会被新排序覆盖。</strong></p>
<p>要查找指定距离范围内的数据，可使用 <code>whereWithinKilometers</code> 、 <code>whereWithinMiles</code> 或 <code>whereWithinRadians</code> 方法。</p>
<p>要查找位于矩形范围内的信息，可使用 <code>whereWithinGeoBox</code> 来实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVGeoPoint</span> *point1 = [<span class="built_in">AVGeoPoint</span> geoPointWithLatitude:<span class="number">39.97</span> longitude:<span class="number">116.33</span>];</span><br><span class="line"><span class="built_in">AVGeoPoint</span> *point2 = [<span class="built_in">AVGeoPoint</span> geoPointWithLatitude:<span class="number">39.99</span> longitude:<span class="number">116.37</span>];</span><br><span class="line"><span class="built_in">AVQuery</span> *query = [<span class="built_in">AVQuery</span> queryWithClassName:<span class="string">@"Post"</span>];</span><br><span class="line">[query whereKey:<span class="string">@"location"</span> withinGeoBoxFromSouthwest:point1 toNortheast:point2];</span><br><span class="line"><span class="built_in">NSArray</span>&lt;<span class="built_in">AVObject</span> *&gt; *posts = [query findObjects];</span><br></pre></td></tr></table></figure>
<h3 id="注意事项">注意事项</h3><p>目前需要注意以下方面：</p>
<ul>
<li>每个 <code>AVObject</code> 数据对象中只能有一个 <code>AVGeoPoint</code> 对象。</li>
<li>地理位置的点不能超过规定的范围。纬度的范围应该是在 <code>-90.0</code> 到 <code>90.0</code> 之间，经度的范围应该是在 <code>-180.0</code> 到 <code>180.0</code> 之间。如果添加的经纬度超出了以上范围，将导致程序错误。</li>
<li>iOS 8.0 之后，使用定位服务之前，需要调用 <code>[locationManager requestWhenInUseAuthorization]</code> 或 <code>[locationManager requestAlwaysAuthorization]</code> 来获取用户的「使用期授权」或「永久授权」，而这两个请求授权需要在 <code>info.plist</code> 里面对应添加 <code>NSLocationWhenInUseUsageDescription</code> 或 <code>NSLocationAlwaysUsageDescription</code> 的键值对，值为开启定位服务原因的描述。SDK 内部默认使用的是「使用期授权」。</li>
</ul>
<h2 id="调用云代码">调用云代码</h2><h3 id="调用云代码函数">调用云代码函数</h3><p>使用 <code>AVCloud</code> 类的静态方法来调用云代码中定义的函数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *parameters=@&#123;...&#125;;</span><br><span class="line"></span><br><span class="line">[<span class="built_in">AVCloud</span> callFunctionInBackground:<span class="string">@"aFunctionName"</span> withParameters:parameters block:^(<span class="keyword">id</span> object, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="comment">// 执行结果</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p><code>aFunctionName</code> 是函数的名称，<code>parameters</code> 是传入的函数参数，<code>block</code> 对象作为调用结果的回调传入。</p>
<h3 id="区分生产环境调用">区分生产环境调用</h3><p>云代码区分「测试环境」和「生产环境」，使用 <code>AVCloud</code> 的 <code>setProductionMode</code> 方法可以切换环境：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">AVCloud</span> setProductionMode:<span class="literal">NO</span>];</span><br></pre></td></tr></table></figure>
<p>其中 <code>NO</code> 表示「测试环境」，默认调用生产环境云代码。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="iOS_/_OS_X_数据存储开发指南">iOS / OS X 数据存储开发指南</h1><p>如果还没有安装 LeanCloud iOS SDK，请阅读 <a href="/start.html">快速入门</a> 来获得该 SDK，并在 Xcode 中运行和熟]]>
    </summary>
    
      <category term="leancloud" scheme="http://yoursite.com/tags/leancloud/"/>
    
      <category term="leancloud" scheme="http://yoursite.com/categories/leancloud/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[错误码详解]]></title>
    <link href="http://yoursite.com/2015/12/30/avos/error_code/"/>
    <id>http://yoursite.com/2015/12/30/avos/error_code/</id>
    <published>2015-12-29T23:56:29.000Z</published>
    <updated>2015-12-18T10:23:52.853Z</updated>
    <content type="html"><![CDATA[<h1 id="错误码详解">错误码详解</h1><p>本文档尝试为所有服务端和SDK返回的错误码给出相对详细的解释，具体到各个SDK的错误码，请参考下列文档链接：</p>
<ul>
<li>iOS 的 <a href="/api-docs/iOS/docs/AVConstants.html">AVConstants</a>。</li>
<li>iOS v3.1.5 及之后的版本，网络请求操作相关的错误码，比如：28 表示请求超时、7 表示连接服务器失败，这些请参考 <a href="http://curl.haxx.se/libcurl/c/libcurl-errors.html" target="_blank" rel="external"><strong>libcurl error codes</strong></a>。</li>
<li>Android 的 <a href="/api-docs/android/doc/index.html">AVException</a>。</li>
</ul>
<h2 id="实时通信错误码">实时通信错误码</h2><p>相关参考链接：</p>
<ul>
<li><a href="realtime_v2.html#服务器端错误码说明">实时通信服务端错误码说明</a>。</li>
<li>iOS SDK 在进行 WebSocket 通信过程中，相关的状态码请参考  <a href="http://tools.ietf.org/html/rfc6455#section-7.4" target="_blank" rel="external"><strong>RFC 6455 – Status Codes</strong></a>。</li>
</ul>
<h2 id="1">1</h2><ul>
<li>信息 - <code>Internal server error. No information available.</code></li>
<li>含义 - 服务器内部错误或者参数错误，一般是因为传入了错误的参数，或者没有在本文档里明确定义的运行时错误，都会以代码 1 指代。</li>
</ul>
<h2 id="100">100</h2><ul>
<li>信息 - <code>The connection to the AVOS servers failed.</code></li>
<li>含义 - 无法建立 TCP 连接到 LeanCloud 服务器，通常是因为网络故障，或者我们服务器故障引起的，我们的服务器状态可以查看 <a href="http://status.leancloud.cn/" target="_blank" rel="external">健康状态检查</a>。</li>
</ul>
<h2 id="101">101</h2><ul>
<li>信息 - <code>Object doesn&#39;t exist, or has an incorrect password.</code></li>
<li>含义 - 查询的 Class 不存在，或者要关联的 Pointer 对象不存在。</li>
</ul>
<h2 id="103">103</h2><ul>
<li>信息 - <code>Missing or invalid classname. Classnames are case-sensitive. They must start with a letter, and a-zA-Z0-9_ are the only valid characters.</code></li>
<li>含义 - 非法的 Class 名称，Class 名称大小写敏感，并且必须以英文字母开头，有效的字符仅限在英文字母、数字以及下划线。</li>
</ul>
<h2 id="104">104</h2><ul>
<li>信息 - <code>Missing object id.</code></li>
<li>含义 - 缺少 objectId，通常是在查询的时候没有传入 objectId，或者 objectId 非法。objectId 只能为字母、数字组成的字符串。</li>
</ul>
<h2 id="105">105</h2><ul>
<li>信息 - <code>Invalid key name. Keys are case-sensitive. They must start with a letter, and a-zA-Z0-9_ are the only valid characters.</code></li>
<li>含义 - 无效的 key 名称，也就是 Class 的列名无效，列名必须以英文字母开头，有效的字符仅限在英文字母、数字以及下划线。</li>
</ul>
<h2 id="106">106</h2><ul>
<li>信息 - <code>Malformed pointer. Pointers must be arrays of a classname and an object id.</code></li>
<li>含义 - 无效的 Pointer 格式，Pointer必须为形如 <code>{className: &#39;Post&#39;, objectId:&#39;xxxxxx&#39;}</code> 的 JSON 对象。</li>
</ul>
<h2 id="107">107</h2><ul>
<li>信息 - <code>Malformed json object. A json dictionary is expected.</code></li>
<li>含义 - 无效的 JSON 对象，解析 JSON 数据失败。</li>
</ul>
<h2 id="108">108</h2><ul>
<li>信息 - <code>Tried to access a feature only available internally.</code></li>
<li>含义 - 此 API 仅供内部使用。</li>
</ul>
<h2 id="111">111</h2><ul>
<li>信息 - <code>Field set to incorrect type.</code></li>
<li>含义 - 想要存储的值不匹配列的类型，请检查你的数据管理平台中列定义的类型，查看存储的数据是否匹配这些类型。</li>
</ul>
<h2 id="112">112</h2><ul>
<li>信息 - <code>Invalid channel name. A channel name is either an empty string (the broadcast channel) or contains only a-zA-Z0-9_ characters and starts with a letter.</code></li>
<li>含义 - 推送订阅的频道无效，频道名称必须不是空字符串，只能包含英文字母、数字以及下划线，并且只能以英文字母开头。</li>
</ul>
<h2 id="113">113</h2><ul>
<li>信息 - <code>Key is required.</code></li>
<li>含义 - Class 中的某个字段设定成必须，保存的对象缺少该字段。</li>
</ul>
<h2 id="114">114</h2><ul>
<li>信息 - <code>Invalid device token.</code></li>
<li>含义 - iOS 推送存储的 deviceToken 无效，如何存储 installation 请阅读 <a href="./push_guide.html#iOS_消息推送">消息推送开发指南</a>。</li>
</ul>
<h2 id="116">116</h2><ul>
<li>信息 - <code>The object is too large.</code></li>
<li>含义 - 要存储的对象超过了大小限制，我们限制单个对象的最大大小在 16 M。</li>
</ul>
<h2 id="117">117</h2><ul>
<li>信息 - <code>The key is read only.</code></li>
<li>含义 - 更新的 Key 是只读属性，无法更新。</li>
</ul>
<h2 id="119">119</h2><ul>
<li>信息 - <code>That operation isn&#39;t allowed for clients.</code></li>
<li>含义 - 该操作无法从客户端发起。通常可以通过在应用设置里开启对应选项就可以解决。</li>
</ul>
<h2 id="120">120</h2><ul>
<li>信息 - <code>The results were not found in the cache.</code></li>
<li>含义 - 查询结果无法从缓存中找到，SDK 在使用从查询缓存的时候，如果发生缓存没有命中，返回此错误。</li>
</ul>
<h2 id="121">121</h2><ul>
<li>信息 - <code>Keys in NSDictionary values may not include &#39;$&#39; or &#39;.&#39;.</code></li>
<li>含义 - JSON 对象中 key 的名称不能包含 <code>$</code> 和 <code>.</code> 符号。</li>
</ul>
<h2 id="122">122</h2><ul>
<li>信息 - <code>Invalid file name. A file name contains only a-zA-Z0-9_. characters and is between 1 and 36 characters.</code></li>
<li>含义 - 无效的文件名称，文件名称只能是英文字母、数字和下划线组成，并且名字长度限制在 1 到 36 之间。</li>
</ul>
<h2 id="123">123</h2><ul>
<li>信息 - <code>Invalid ACL. An ACL with an invalid format was saved. This should not happen if you use AVACL.</code></li>
<li>含义 - ACL 格式错误，如果您是使用 SDK 提供的 AVACL 类，理论上这不应该发生，正确的 ACL 格式请参考 <a href="./rest_api.html#安全性">REST API</a>。</li>
</ul>
<h2 id="124">124</h2><ul>
<li>信息 - <code>The request timed out on the server. Typically this indicates the request is too expensive.</code></li>
<li>含义 - 请求超时，超过一定时间（默认 10 秒）没有返回，通常是因为网络故障或者该操作太耗时引起的。</li>
</ul>
<h2 id="125">125</h2><ul>
<li>信息 - <code>The email address was invalid.</code></li>
<li>含义 - 电子邮箱地址无效。</li>
</ul>
<h2 id="126">126</h2><ul>
<li>信息 - <code>Invalid user id.</code></li>
<li>含义 - 无效的用户 Id，可能用户不存在。</li>
</ul>
<h2 id="127">127</h2><ul>
<li>信息 - <code>The mobile phone number was invalid.</code></li>
<li>含义 - 手机号码无效。</li>
</ul>
<h2 id="137">137</h2><ul>
<li>信息 - <code>A unique field was given a value that is already taken.</code></li>
<li>含义 - 违反 class 中的唯一性索引约束（unique），尝试存储重复的值。</li>
</ul>
<h2 id="139">139</h2><ul>
<li>信息 - <code>Role&#39;s name is invalid.</code></li>
<li>含义 - 角色名称非法，角色名称只能以英文字母、数字或下划线组成。</li>
</ul>
<h2 id="140">140</h2><ul>
<li>信息 - <code>Exceeded an application quota. Upgrade to resolve.</code></li>
<li>含义 - 超过应用的容量限额，请升级账户等级。</li>
</ul>
<h2 id="141">141</h2><ul>
<li>信息 - <code>Cloud Code script had an error.</code></li>
<li>含义 - 云引擎脚本编译或者运行报错。</li>
</ul>
<h2 id="142">142</h2><ul>
<li>信息 - <code>Cloud Code validation failed.</code></li>
<li>含义 - 云引擎校验错误，通常是因为 beforeSave、beforeDelete 等函数返回 error。</li>
</ul>
<h2 id="145">145</h2><ul>
<li>信息 - <code>Payment is disabled on this device.</code></li>
<li>含义 - 本设备没有启用支付功能。</li>
</ul>
<h2 id="150">150</h2><ul>
<li>信息 - <code>Fail to convert data to image.</code></li>
<li>含义 - 转换数据到图片失败。</li>
</ul>
<h2 id="160">160</h2><ul>
<li>信息 - <code>Insufficient balance.</code></li>
<li>含义 - 账户余额不足。</li>
</ul>
<h2 id="200">200</h2><ul>
<li>信息 - <code>Username is missing or empty</code></li>
<li>含义 - 没有提供用户名，或者用户名为空。</li>
</ul>
<h2 id="201">201</h2><ul>
<li>信息 - <code>Password is missing or empty.</code></li>
<li>含义 - 没有提供密码，或者密码为空。</li>
</ul>
<h2 id="202">202</h2><ul>
<li>信息 - <code>Username has already been taken.</code></li>
<li>含义 - 用户名已经被占用。</li>
</ul>
<h2 id="203">203</h2><ul>
<li>信息 - <code>Email has already been taken.</code></li>
<li>含义 - 电子邮箱地址已经被占用。</li>
</ul>
<h2 id="204">204</h2><ul>
<li>信息 - <code>The email is missing, and must be specified.</code></li>
<li>含义 - 没有提供电子邮箱地址。</li>
</ul>
<h2 id="205">205</h2><ul>
<li>信息 - <code>A user with the specified email was not found.</code></li>
<li>含义 - 找不到电子邮箱地址对应的用户。</li>
</ul>
<h2 id="206">206</h2><ul>
<li>信息 - <code>The user cannot be altered by a client without the session.</code></li>
<li>含义 - 没有提供 session，无法修改用户信息，这通常是因为没有登录的用户想修改信息。修改用户信息必须登录，除非在云引擎里，或者使用 master key 调用 REST API。</li>
</ul>
<h2 id="207">207</h2><ul>
<li>信息 - <code>Users can only be created through sign up.</code></li>
<li>含义 - 只能通过注册创建用户，不允许第三方登录。</li>
</ul>
<h2 id="208">208</h2><ul>
<li>信息 - <code>An existing account already linked to another user.</code></li>
<li>含义 - 第三方帐号已经绑定到一个用户，不可绑定到其他用户。</li>
</ul>
<h2 id="210">210</h2><ul>
<li>信息 - <code>The username and password mismatch.</code></li>
<li>含义 - 用户名和密码不匹配。</li>
</ul>
<h2 id="211">211</h2><ul>
<li>信息 - <code>Could not find user.</code></li>
<li>含义 - 找不到用户。</li>
</ul>
<h2 id="212">212</h2><ul>
<li>信息 - <code>The mobile phone number is missing, and must be specified.</code></li>
<li>含义 - 请提供手机号码。</li>
</ul>
<h2 id="213">213</h2><ul>
<li>信息 - <code>A user with the specified mobile phone number was not found.</code></li>
<li>含义 - 手机号码对应的用户不存在。</li>
</ul>
<h2 id="214">214</h2><ul>
<li>信息 - <code>Mobile phone number has already been taken.</code></li>
<li>含义 - 手机号码已经被注册。</li>
</ul>
<h2 id="215">215</h2><ul>
<li>信息 - <code>Mobile phone number isn&#39;t verified.</code></li>
<li>含义 - 未验证的手机号码。</li>
</ul>
<h2 id="216">216</h2><ul>
<li>信息 - <code>Email address isn&#39;t verified.</code></li>
<li>含义 - 未验证的邮箱地址。</li>
</ul>
<h2 id="217">217</h2><ul>
<li>信息 - <code>Invalid username, it must be a non-blank string.</code></li>
<li>含义 - 无效的用户名，不允许空白用户名。</li>
</ul>
<h2 id="218">218</h2><ul>
<li>信息 - <code>Invalid password, it must be a non-blank string.</code></li>
<li>含义 - 无效的密码，不允许空白密码。</li>
</ul>
<h2 id="250">250</h2><ul>
<li>信息 - <code>Linked id missing from request</code></li>
<li>含义 - 连接的第三方账户没有返回用户唯一标示 id</li>
</ul>
<h2 id="251">251</h2><ul>
<li>信息 - <code>Invalid linked session</code>或者<code>Invalid Weibo session</code></li>
<li>含义 - 无效的账户连接，一般是因为 access token 非法引起的。</li>
</ul>
<h2 id="252">252</h2><ul>
<li>信息 - <code>Invalid Weixin session</code></li>
<li>含义 - 无效的微信授权信息。</li>
</ul>
<h2 id="300">300</h2><ul>
<li>信息 - <code>CQL syntax error.</code></li>
<li>含义 - CQL 语法错误。详情参考 <a href="./cql_guide.html">CQL 语法详细指南</a></li>
</ul>
<h2 id="301">301</h2><ul>
<li>信息 - <code>Fails to insert new document.</code></li>
<li>含义 - 新增对象失败，通常是数据格式问题。</li>
</ul>
<h2 id="302">302</h2><ul>
<li>信息 - <code>Invalid GeoPoint values.</code></li>
<li>含义 - 无效的 GeoPoint 类型，请确保经度在 -180 到 180 之间，纬度在 -90 到 90 之间。</li>
</ul>
<h2 id="303">303</h2><ul>
<li>信息 - <code>Fail to execute operation on storage.</code></li>
<li>含义 - 插入数据库失败，一般是数据格式或者内部错误，通常错误里包含更具体的错误信息。</li>
</ul>
<h2 id="401">401</h2><ul>
<li>信息 - <code>Unauthorized.</code></li>
<li>含义 - 未经授权的访问，没有提供 App id，或者 App id 和 App key 校验失败，请检查配置。</li>
</ul>
<h2 id="403">403</h2><ul>
<li>信息 - <code>Forbidden to xxx by class permissions</code></li>
<li>含义 - 操作被禁止，因为 <a href="./data_security.html#Class_级别的权限">Class 权限限制</a>。</li>
</ul>
<h2 id="502">502</h2><ul>
<li>信息 - <code>Server is in maintenance.</code></li>
<li>含义 - 服务器维护中。</li>
</ul>
<h2 id="503">503</h2><ul>
<li>信息 - <code>Rate limit exceeded.</code></li>
<li>含义 - 超过流量访问限制，默认 API 并发 1000 访问每秒，通过数据管理平台每秒限制上传一个文件，并且每分钟最多上传 30 个文件，如需提升，请联系我们。</li>
</ul>
<h2 id="511">511</h2><ul>
<li>信息 - <code>Temporarily Unavailable.</code></li>
<li>含义 -  该请求 API 暂时不可用，请稍后重试。一般是运维操作临时禁止了某个 API 访问，一段时间后会自然恢复，或者联系我们处理。</li>
</ul>
<h2 id="600">600</h2><ul>
<li>信息 - <code>Invalid SMS signature.</code></li>
<li>含义 - 无效的短信签名。短信签名是指附加在短信文本前后位置，使用中文括号【】括起来的文字，短信签名只能位于短信开头或者结束的位置，并且限制在 10（包含 10 个字符）个字符内。<pre><code>默认发送的短信签名使用的是应用名称，应用名称可以在应用设置里修改。短信自定义模板可以在模板里自定义签名。
</code></pre></li>
</ul>
<h2 id="601">601</h2><ul>
<li>信息 - <code>Can&#39;t send SMS too frequently.</code></li>
<li>含义 -  发送短信过于频繁。我们限制验证类短信一分钟一条，每天每个号码限制在 10 条左右。我们强烈建议用户使用图形验证码或者倒数计时等方式来避免用户重复发送验证码，以及可能存在的短信验证码攻击。</li>
</ul>
<h2 id="602">602</h2><ul>
<li>信息 - <code>Fails to send message.</code></li>
<li>含义 -  发送短信或者语音验证码失败，这是短信提供商返回错误，如果确认手机号码没有问题，请联系我们处理。</li>
</ul>
<h2 id="603">603</h2><ul>
<li>信息 - <code>Invalid SMS code.</code></li>
<li>含义 - 无效的短信验证码，通常是不匹配或者过期。</li>
</ul>
<h2 id="604">604</h2><ul>
<li>信息 - <code>SMS template not found.</code></li>
<li>含义 - 找不到自定义的短信模板，请检查模板名称是否正确或者模板是否已经创建并审核通过。</li>
</ul>
<h2 id="605">605</h2><ul>
<li>信息 - <code>SMS template not verified.</code></li>
<li>含义 - 短信模板未审核。</li>
</ul>
<h2 id="606">606</h2><ul>
<li>信息 - <code>Fails to render SMS template.</code></li>
<li>含义 - 渲染短信模板失败，通常是模板语法问题，我们的短信模板仅支持 <a href="http://handlebarsjs.com/" target="_blank" rel="external">handlerbars</a> 模板语法。</li>
</ul>
<h2 id="700">700</h2><ul>
<li>信息 - <code>Nonexistent query keys</code></li>
<li>含义 - 无效的查询或者排序字段，请确认查询或者排序的字段在表中存在。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="错误码详解">错误码详解</h1><p>本文档尝试为所有服务端和SDK返回的错误码给出相对详细的解释，具体到各个SDK的错误码，请参考下列文档链接：</p>
<ul>
<li>iOS 的 <a href="/api-docs/iOS/docs/AVConstant]]>
    </summary>
    
      <category term="leancloud" scheme="http://yoursite.com/tags/leancloud/"/>
    
      <category term="leancloud" scheme="http://yoursite.com/categories/leancloud/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeanCloud FAQ]]></title>
    <link href="http://yoursite.com/2015/12/30/avos/faq/"/>
    <id>http://yoursite.com/2015/12/30/avos/faq/</id>
    <published>2015-12-29T23:56:29.000Z</published>
    <updated>2015-12-18T10:24:01.208Z</updated>
    <content type="html"><![CDATA[<h1 id="LeanCloud_FAQ">LeanCloud FAQ</h1><h2 id="账户和平台常见问题">账户和平台常见问题</h2><h3 id="LeanCloud_部署在哪个云平台上">LeanCloud 部署在哪个云平台上</h3><p>LeanCloud 部署在国内多个云计算平台上，并采用在双线机房内同时使用虚拟机和实体机的混合部署策略，来保证应用的访问体验和可靠性。</p>
<h3 id="获取客服支持有哪些途径">获取客服支持有哪些途径</h3><ul>
<li>到免费的<a href="https://forum.leancloud.cn/" target="_blank" rel="external">用户社区</a> 进行提问。</li>
<li>购买 <a href="/bill.html#/bill/general">技术支持</a>，进入 <a href="https://ticket.leancloud.cn/" target="_blank" rel="external">工单系统</a> 来提交问题。</li>
<li>发送邮件到 <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#x73;&#117;&#112;&#112;&#111;&#x72;&#116;&#64;&#108;&#101;&#x61;&#x6e;&#x63;&#108;&#x6f;&#x75;&#x64;&#46;&#114;&#x6f;&#x63;&#x6b;&#x73;">&#x73;&#117;&#112;&#112;&#111;&#x72;&#116;&#64;&#108;&#101;&#x61;&#x6e;&#x63;&#108;&#x6f;&#x75;&#x64;&#46;&#114;&#x6f;&#x63;&#x6b;&#x73;</a> 获取帮助。</li>
<li>紧急情况拨打客服电话：010-82800646。</li>
</ul>
<h3 id="计费是基于账号还是应用">计费是基于账号还是应用</h3><p>计费都基于用户账号，详细信息请参考 <a href="/pricing.html">价格</a> 页面。</p>
<h3 id="如果没有缴费会怎么样">如果没有缴费会怎么样</h3><p>账单逾期四周未缴，账户服务将被停止；应用数据被置于不可见模式，但仍会在 LeanCloud 云端保留一个月。如需要恢复服务和访问应用数据，请登录控制台，支付欠款。</p>
<p>我们为账单支付提供一段缓冲期，请在收到账单的十天内完成缴费即可。在此期间，我们会通过邮件或者电话等方式与您联系，因此强烈建议完整填写 <a href="/settings.html#/setting/info">开发者信息</a>，以免错过我们的提醒和最佳付款时机。</p>
<h3 id="如何付费">如何付费</h3><ul>
<li><p>支付宝 <a href="/bill.html#/bill/charge">充值</a></p>
<p>我们将每个月自动从您的账户余额里扣除上月账单的费用。每次扣费优先使用充值金额，其次是赠送金额。</p>
</li>
<li><p>对公账户付款</p>
<p>公司税号：<strong>110108597742364</strong><br>公司名称：<strong>美味书签（北京）信息技术有限公司</strong><br><br>开户银行：<strong>中国银行股份有限公司北京大运村支行</strong><br><br>银行账号：<strong>344159259324</strong><br><br>银行地址：<strong>北京市海淀区知春路 6 号锦秋国际大厦一层</strong><br>银行行号：<strong>104100004013</strong></p>
</li>
</ul>
<h3 id="如何申请开具发票">如何申请开具发票</h3><ul>
<li><p>申请开发票前，请先按系统要求，完善所有必填的用户信息。</p>
</li>
<li><p>无论采取哪一种付款方式，只有当累计支付金额达到人民币<strong>壹仟元</strong>后系统才允许申请，单笔开票金额不低于人民币<strong>壹仟元</strong>。</p>
</li>
<li><p>如有特别需求，如按月度账单金额结算，或先开发票后付款，请联系我们的市场部专员 <a href="&#109;&#x61;&#105;&#108;&#x74;&#111;&#x3a;&#98;&#x75;&#x73;&#105;&#110;&#x65;&#x73;&#115;&#x40;&#108;&#x65;&#97;&#110;&#99;&#x6c;&#x6f;&#x75;&#x64;&#46;&#114;&#x6f;&#99;&#107;&#x73;">&#98;&#x75;&#x73;&#105;&#110;&#x65;&#x73;&#115;&#x40;&#108;&#x65;&#97;&#110;&#99;&#x6c;&#x6f;&#x75;&#x64;&#46;&#114;&#x6f;&#99;&#107;&#x73;</a>，QQ号：2607695496。</p>
</li>
<li><p>开具发票时段为每月 10 日至 30 日，发票以快递寄送。如需开具增值税专用发票，也请联系我们的市场部专员。</p>
</li>
<li><p>发票免费邮寄。</p>
</li>
</ul>
<h3 id="哪里获取平台的更新信息">哪里获取平台的更新信息</h3><p>通常情况下，我们新版本的更新周期为一到两周。获取更新信息可以通过：</p>
<ul>
<li><a href="http://blog.leancloud.cn/" target="_blank" rel="external">官方博客</a>（每次更新的详细信息都会发布在那里）</li>
<li><a href="http://weibo.com/avoscloud" target="_blank" rel="external">官方微博</a></li>
<li>官方微信公众号：LeanCloud</li>
<li>每月初，我们会将每月的更新摘要发送到您的注册邮箱。</li>
<li>在控制台页面的右上方有 <a href="/info-center.html#/index">消息中心</a>，请注意查看新通知。</li>
</ul>
<h3 id="API_开放吗">API 开放吗</h3><p>我们的 API 完全开放。我们提供的 SDK 也都是基于开放 API 实现的。详情请阅读 <a href="/docs/rest_api.html">REST API 详解</a>。</p>
<h3 id="提供哪些平台的_SDK">提供哪些平台的 SDK</h3><p>目前官方提供的 SDK 种类包括：</p>
<ul>
<li>iOS 和 OS X</li>
<li>Android</li>
<li>JavaScript</li>
<li>Windows Phone</li>
<li>Unity</li>
<li>Python</li>
<li>PHP</li>
</ul>
<p>来自第三方的开源项目有：</p>
<ul>
<li><a href="https://github.com/freewing99/BaasReponsitory" target="_blank" rel="external">C#</a></li>
</ul>
<p>详情请访问 <a href="/docs/sdk_down.html">SDK 下载</a> 页面。</p>
<h3 id="iOS_和_Android_是否可以使用同一个_App">iOS 和 Android 是否可以使用同一个 App</h3><p>当然可以。使用我们的 SDK，可以为同一个应用开发多个平台的版本，共享后端数据。</p>
<h3 id="支持_Unity_3D_吗">支持 Unity 3D 吗</h3><p>支持。请到 <a href="sdk_down.html">SDK 下载</a> 页面下载 Unity SDK。</p>
<h3 id="开发文档有提供搜索功能吗">开发文档有提供搜索功能吗</h3><p> <strong>官网文档</strong> 首页右上角就有搜索框，也可以直接访问 <a href="/search.html">搜索</a> 页面。</p>
<h2 id="API_相关">API 相关</h2><h3 id="API_调用次数有什么限制吗">API 调用次数有什么限制吗</h3><p>我们每个月提供 100 万次的免费额度，超过的部分才收费。免费额度不会将完全免费的推送服务和统计服务计算进去。另外，对于免费版和专业版，默认情况下，每个应用都有每秒 1000 次的并发访问上限，如果需要提高上限，请与我们联系。</p>
<p>对于从控制台或者使用 JavaScript SDK 上传文件（包括云引擎内），我们限制每秒最多上传 1 个文件，一分钟内最多上传 30 个文件。</p>
<h3 id="API_调用次数的计算">API 调用次数的计算</h3><p>对于「数据存储」来说，每次 create 和 update 一条数据算一次请求，如调用一次 <code>object.saveInBackground</code> 算一次 API 请求。</p>
<p><code>fetch</code>、<code>find</code>、<code>delete</code>、<code>deleteAll</code> 算<strong>一次请求</strong>：</p>
<ul>
<li>调用一次 fetch / find 通过 include 返回了 100 个关联对象，算一次 API 请求。</li>
<li>调用一次 find / deleteAll 来查找或删除 500 条记录，只算一次 API 请求。</li>
</ul>
<p><code>saveAll</code>、<code>fetchAll</code> 算<strong>多次请求</strong>：</p>
<ul>
<li>调用一次 saveAll / fetchAll 来保存或获取 array 里面 100 个 对象，算 100 次 API 请求。</li>
</ul>
<p>对于「<a href="status_system.html">应用内社交</a>」，create 和 update 按照 Status 和 Follower/Followee 的对象数量来计费。对于 query 则是按照请求数来计费，与结果的大小无关。collection fetch 也是按照请求次数来计费。</p>
<h3 id="可以在线测试_API_吗">可以在线测试 API 吗</h3><p>请访问 <a href="/apionline/">API 在线测试工具</a>。</p>
<h3 id="403_错误">403 错误</h3><p>403 错误分为两类：</p>
<ul>
<li>错误信息 <code>The user cannot be altered by a client without the session.</code>：用户没有登录，无法修改用户信息。</li>
<li>错误信息 <code>Forbidden to write by class permissions.</code> 或者 <code>Forbidden to read by class permissions.</code>：想要修改的 class 表没有打开「读」或者「写」的权限。在 <a href="/data.html">数据</a> 管理平台，点击相应的 class，在右侧选择 <strong>其他</strong> 下拉菜单，进入 <strong>权限管理</strong> 来设置 class 权限。</li>
</ul>
<p><img src="images/permission.png" alt="image"></p>
<h3 id="Unauthorized_错误">Unauthorized 错误</h3><p>应用 API 授权失败，请检查是否初始化了 App Id 和 App Key。</p>
<ul>
<li>如何进行初始化，请查看 <a href="/start.html">快速入门</a>。</li>
<li>App Id 和 App Key 在应用的 <strong>设置</strong> 菜单里可以找到。</li>
</ul>
<h3 id="错误信息代码和详细解释在哪里">错误信息代码和详细解释在哪里</h3><ul>
<li><a href="./error_code.html">错误代码详解</a></li>
<li>iOS SDK：<a href="/api-docs/iOS/docs/AVConstants.html">AVConstants</a></li>
<li>Android SDK：<a href="/api-docs/android/doc/index.html">AVException</a></li>
</ul>
<p>REST API 返回的错误信息跟 SDK 保持一致。</p>
<h3 id="其他语言调用_REST_API_如何对参数进行编码">其他语言调用 REST API 如何对参数进行编码</h3><p>REST API 文档使用 curl 作为示范，其中 <code>--data-urlencode</code> 表示要对参数进行 URL encode 编码。如果是 GET 请求，直接将经过 URL encode 的参数通过 <code>&amp;</code> 连接起来，放到 URL 的问号后。如 <code>https://leancloud.cn/1.1/login?username=xxxx&amp;password=xxxxx</code>。</p>
<h3 id="如何实现大小写不敏感的查询">如何实现大小写不敏感的查询</h3><p>目前不提供直接支持，可采用正则表达式查询的办法，具体参考 <a href="http://stackoverflow.com/questions/1863399/mongodb-is-it-possible-to-make-a-case-insensitive-query" target="_blank" rel="external">StackOverflow - MongoDB: Is it possible to make a case-insensitive query</a>。</p>
<p>使用各平台 SDK 的 AVQuery 对象提供的 <code>matchesRegex</code> 方法（Android SDK 用 <code>whereMatches</code> 方法）。</p>
<h3 id="应用内用户的密码需要加密吗">应用内用户的密码需要加密吗</h3><p>不需要加密密码，我们的服务端已使用随机生成的 salt，自动对密码做了加密。 如果用户忘记了密码，可以调用 <code>requestResetPassword</code> 方法（具体查看 SDK 的 AVUser 用法），向用户注册的邮箱发送邮件，用户以此可自行重设密码。 在整个过程中，密码都不会有明文保存的问题，密码也不会在客户端保存，只是会保存 sessionToken 来标示用户的登录状态。</p>
<h2 id="控制台相关">控制台相关</h2><h3 id="如何导入或者导出数据？">如何导入或者导出数据？</h3><p>请参考《数据与安全》文档的 <a href="./data_security.html#导入数据">导入数据</a> 和 <a href="./data_security.html#导出数据">导出数据</a> 部分。</p>
<h3 id="如何在_App_邮件内完全使用自己的品牌">如何在 App 邮件内完全使用自己的品牌</h3><p>请参考博文 <a href="http://blog.leancloud.cn/blog/2014/01/09/zi-ding-yi-ying-yong-nei-yong-hu-zhong-she-mi-ma-he-you-xiang-yan-zheng-ye-mian/" target="_blank" rel="external">《自定义应用内用户重设密码和邮箱验证页面》</a>。</p>
<h3 id="创建唯一索引失败">创建唯一索引失败</h3><p>请确认想要创建索引的列没有已经存在的重复值。</p>
<h3 id="如何上传文件">如何上传文件</h3><p>任何一个 Class 如果有 File 类型的列，就可以直接在 <strong>数据</strong> 管理平台中将文件上传到该列。如果没有，请自行创建列，类型指定为 File。</p>
<h3 id="如何在应用之间共享数据">如何在应用之间共享数据</h3><p>请参考我们的博客文章 <a href="http://blog.leancloud.cn/blog/2014/03/31/2014nian-3yue-di-4zhou-avos-cloud-geng-xin/" target="_blank" rel="external">《2014 年 3 月第 4 周更新日志》</a>。</p>
<h2 id="iOS/OS_X_SDK">iOS/OS X SDK</h2><h3 id="安装_Cocopods_失败怎么解决">安装 Cocopods 失败怎么解决</h3><p>推荐使用淘宝提供的 Gem 源，访问 <a href="https://ruby.taobao.org/" target="_blank" rel="external">https://ruby.taobao.org/</a>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources --add https://ruby.taobao.org/ --remove https://rubygems.org/</span><br><span class="line">$ gem sources <span class="operator">-l</span></span><br><span class="line">*** CURRENT SOURCES ***</span><br><span class="line"></span><br><span class="line">https://ruby.taobao.org</span><br><span class="line"><span class="comment"># 请确保只有 ruby.taobao.org</span></span><br><span class="line">$ gem install cocoapods</span><br></pre></td></tr></table></figure>
<p>由于淘宝已经停止基于 HTTP 协议的镜像服务，如果之前使用的是 <a href="http://ruby.taobao.org/" target="_blank" rel="external">http://ruby.taobao.org/</a>，这也可能导致安装 Cocopods 失败。</p>
<p>需要在配置中使用 HTTPS 协议代替：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources --add https://ruby.taobao.org/ --remove http://ruby.taobao.org/</span><br><span class="line">$ gem sources <span class="operator">-l</span></span><br><span class="line">*** CURRENT SOURCES ***</span><br><span class="line"></span><br><span class="line">https://ruby.taobao.org</span><br><span class="line"><span class="comment"># 请确保只有 ruby.taobao.org</span></span><br><span class="line">$ gem install cocoapods</span><br></pre></td></tr></table></figure>
<h3 id="编译失败">编译失败</h3><h4 id="Symbol(s)_not_found_x86_64">Symbol(s) not found x86_64</h4><p>请使用 32 位模拟器进行编译和调试.</p>
<h4 id="Undefined_symbols_for_architecture">Undefined symbols for architecture</h4><p>一般是由于 Framework 的链接找不到造成的，建议用 CocoaPods 更新一下。没使用 CocoaPods 的项目可以删除对 Framework 的引用，然后再重新加进来。</p>
<p>LeanCloud 依赖的 Framework 包括：</p>
<ul>
<li>SystemConfiguration.framework</li>
<li>MobileCoreServices.framework</li>
<li>CoreTelephony.framework</li>
<li>CoreLocation.framework</li>
</ul>
<p>如果是 <code>for architecture arm64</code>，这是因为 Xcode 更新到 5.1 后，CocoaPods 没有及时更新对 64 位 CPU 的支持，解决方法参考 <a href="http://stackoverflow.com/questions/19213782/undefined-symbols-for-architecture-arm64" target="_blank" rel="external">《StackOverflow - Undefined symbols for architecture arm64》</a></p>
<h3 id="请求报错">请求报错</h3><p>请参考请求返回的错误码 <a href="error_code.html">详细说明</a>。</p>
<h3 id="地理位置查询错误">地理位置查询错误</h3><p>如果错误信息类似于 <code>can&#39;t find any special indices: 2d (needs index), 2dsphere (needs index), for 字段名</code>，就代表用于查询的字段没有建立 2D 索引，可以在 Class 管理的 <strong>其他</strong> 菜单里找到 <strong>索引</strong> 管理，点击进入，找到字段名称，选择并创建「2dsphere」索引类型。</p>
<p><img src="images/geopoint_faq.png" alt="image"></p>
<h2 id="Android_SDK">Android SDK</h2><h3 id="对_AVObject_对象使用_getDate(“createdAt”)_方法读取创建时间为什么会返回_null">对 AVObject 对象使用 getDate(“createdAt”) 方法读取创建时间为什么会返回 null</h3><p>请用 <code>AVObject</code> 的 <code>getCreatedAt</code> 方法；获取 <code>updatedAt</code> 用 <code>getUpdatedAt</code>。</p>
<h2 id="JavaScript_SDK">JavaScript SDK</h2><h3 id="有没有同步_API">有没有同步 API</h3><p>JavaScript SDK 由于平台的特殊性（运行在单线程运行的浏览器或者 Node.js 环境中），不提供同步 API，所有需要网络交互的 API 都需要以 callback 的形式调用。我们提供了 <a href="js_guide.html#promise">Promise 模式</a> 来减少 callback 嵌套过多的问题。</p>
<h2 id="消息推送">消息推送</h2><h3 id="推送的到达率如何">推送的到达率如何</h3><p>关于到达率这个概念，业界并没没有统一的标准。我们测试过，在线用户消息的到达率基本达到 100%。我们的 SDK 做了心跳和重连等功能，尽量维持对推送服务器的长连接存活，提升消息到达用户手机的实时性和可靠性。</p>
<h3 id="推送是基于_XMPP_还是其他协议">推送是基于 XMPP 还是其他协议</h3><p>老版本推送基于 XMPP 协议，v2.4.1 版本开始，推送采用了 WebSocket 协议，方便支持多平台，包括将要推出的 Web 端消息推送功能。</p>
<h3 id="iOS_推送如何区分开发证书和生产证书">iOS 推送如何区分开发证书和生产证书</h3><p>暂不提供在同一个 App 里同时上传开发证书和生产证书。推荐创建单独的测试 App，可以利用数据导出和导入来快速模拟生产环境。</p>
<h3 id="Android_消息接收能不能自定义_Receiver_不弹出通知">Android 消息接收能不能自定义 Receiver 不弹出通知</h3><p>可以。请参考 <a href="push_guide.html#消息内容_Data">消息推送开发指南</a>。</p>
<p>如果要自定义 receiver，必须在消息的 data 里带上自定义的 action。LeanCloud 在接收到消息后，将广播 action 为您定义的值的 intent 事件，您的 receiver 里也必须带上 <code>intent-filter</code> 来捕获该 action 值的 intent 事件。</p>
<h2 id="统计">统计</h2><h3 id="统计服务免费吗">统计服务免费吗</h3><p>统计服务完全免费，不占用每月的 API 免费额度。</p>
<h3 id="统计服务支持哪些平台">统计服务支持哪些平台</h3><p>目前支持</p>
<ul>
<li>iOS</li>
<li>OS X</li>
<li>Android</li>
</ul>
<p>更多平台 SDK 正在开发中。</p>
<h3 id="统计支持哪些发送策略">统计支持哪些发送策略</h3><ul>
<li>启动时发送（默认策略，推荐使用）</li>
<li>批量发送</li>
<li>按最小间隔发送</li>
</ul>
<p>可以在 <strong>分析</strong> &gt; <strong>Android（或者 iOS）统计</strong> &gt; <strong>统计设置</strong> &gt; <strong>数据发送策略</strong> 的菜单里实时修改这些策略。</p>
<h2 id="云引擎">云引擎</h2><h3 id="定时器_crontab_的语法">定时器 crontab 的语法</h3><p>请参考 <a href="http://www.quartz-scheduler.org/documentation/quartz-1.x/tutorials/crontrigger" target="_blank" rel="external">Quartz 文档</a>。</p>
<h3 id="云端代码都支持那些语言">云端代码都支持那些语言</h3><p>目前支持 Node.js 和 Python 运行环境，未来可能还会引入 PHP 等其他语言。</p>
<h3 id="云引擎如何上传文件">云引擎如何上传文件</h3><p>请参考这篇博文 <a href="http://blog.leancloud.cn/blog/2013/11/23/zai-yun-dai-ma-zhong-chu-li-shang-chuan-wen-jian/" target="_blank" rel="external">《在云代码中处理上传文件》</a>，或者 <a href="leanengine_guide-cloudcode.html#上传文件">云引擎指南 - 上传文件</a> 中的相关内容。</p>
<h3 id="云引擎中如何处理用户登录和_Cookie">云引擎中如何处理用户登录和 Cookie</h3><p>请参考这篇博文 <a href="http://blog.leancloud.cn/blog/2013/12/16/zai-yun-dai-ma-zhong-chu-li-yong-hu-deng-lu/" target="_blank" rel="external">《在云代码中处理用户登录》</a>，或者 <a href="leanengine_guide-cloudcode.html#处理用户登录和登出">云引擎指南</a> 中的相关内容。</p>
<h3 id="云引擎的二级域名多久生效">云引擎的二级域名多久生效</h3><p>我们设置的 TTL 是 10 秒，但是因为使用 Amazon 的 DNS 服务，因此可能国内部分地区会有一定延迟，最迟应该在 24 小时内生效。如果没有，请及时联系我们处理。</p>
<h3 id="云引擎二级域名可以启用_HTTPS_吗">云引擎二级域名可以启用 HTTPS 吗</h3><p>请参考这篇博文 <a href="http://blog.leancloud.cn/blog/2013/12/20/wei-yun-dai-ma-tuo-guan-wang-zhan-qi-yong-https/" target="_blank" rel="external">《为云代码托管网站启用 HTTPS》</a>。</p>
<h3 id="云引擎_Web_Hosting_备案">云引擎 Web Hosting 备案</h3><p>只有网站类的才需要备案，并且在主域名已备案的情况下，二级子域名不需要备案。</p>
<p>如果主站需要托管在我们这边，而且主站还没经过备案，请参考文档 <a href="leanengine_guide-cloudcode.html#域名备案流程">云引擎指南 - 域名备案流程</a> 部分来了解具体的备案流程。</p>
<h2 id="文件">文件</h2><h3 id="文件存储有_CDN_加速吗？">文件存储有 CDN 加速吗？</h3><p>有的。我们的文件存储目前由 <a href="http://qiniu.com" target="_blank" rel="external">七牛</a> 提供，都有 CDN 加速访问。</p>
<h3 id="文件存储有大小限制吗？">文件存储有大小限制吗？</h3><p>没有。除了在浏览器里通过 JavaScript SDK 上传文件，或者通过我们网站直接上传文件，有 10 MB 的大小限制之外，其他 SDK 都没有限制。 JavaScript SDK 在 Node.js 环境中也没有大小限制。</p>
<h3 id="存储图片可以做缩略图等处理吗？">存储图片可以做缩略图等处理吗？</h3><p>可以。默认我们的 <code>AVFile</code> 类提供了缩略图获取方法，可以参见各个 SDK 的开发指南。如果要自己处理，可以通过获取 <code>AVFile</code> 的 <code>URL</code> 属性，使用 <a href="http://docs.qiniu.com/api/v6/image-process.html" target="_blank" rel="external">七牛图片处理 API</a> 执行处理，例如添加水印、裁剪等。</p>
<h2 id="短信">短信</h2><p>详情请参照<a href="/docs/rest_sms_api.html#常见问题_FAQ">短信收发常见问题一览</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="LeanCloud_FAQ">LeanCloud FAQ</h1><h2 id="账户和平台常见问题">账户和平台常见问题</h2><h3 id="LeanCloud_部署在哪个云平台上">LeanCloud 部署在哪个云平台上</h3><p>LeanCloud ]]>
    </summary>
    
      <category term="leancloud" scheme="http://yoursite.com/tags/leancloud/"/>
    
      <category term="leancloud" scheme="http://yoursite.com/categories/leancloud/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据和安全]]></title>
    <link href="http://yoursite.com/2015/12/30/avos/data_security/"/>
    <id>http://yoursite.com/2015/12/30/avos/data_security/</id>
    <published>2015-12-29T23:56:29.000Z</published>
    <updated>2015-12-18T10:22:58.806Z</updated>
    <content type="html"><![CDATA[<h1 id="数据和安全">数据和安全</h1><h2 id="安全总览">安全总览</h2><p>几乎每一位使用 LeanCloud 的用户都会问，如何能够保证自己应用的安全？对安全的关注说明你也位对产品负责、对用户负责、对自己负责、做事态度认真的开发者，这也正是 <a href="http://open.leancloud.cn" target="_blank" rel="external">LeanCloud 所信守的价值观</a>。</p>
<p>安全界有个说法——绝对的安全是不存在的。其中关键要点是要梳理清楚「安全边界」，即你对于业务安全范围的一个清晰的界定。业内一个很著名的例子就是 Chrome 浏览器的查看密码功能，查看已存储的密码不需要再输入 Google 账号的密码。</p>
<p>LeanCloud 通过以下三重级别来总体控制每个应用的安全：</p>
<ul>
<li>SSL 安全连接（HTTPS）</li>
<li>Web 安全域名</li>
<li>ACL 权限控制</li>
</ul>
<p>数据层面，云端每天会备份一次数据，防止误操作等情况删除重要数据。其他安全设置还包括云端验证和检测，比如实时通信可以支持自定义的云端认证、短信验证的各种安全设置、SDK 中的各种安全细节等。</p>
<p>每个应用都有自己的 AppId，并且需要通过这个唯一的 id 从服务端申请和调用资源。理论上说这个 AppId 应该严格保密，但是实际中它总会泄露。如果说用反编译原生应用的方法来破解 AppId 还要费些周折，那对于 Web 应用，只要查看到页面源码就能找出 AppId。所以我们要需要做哪些防御？关键点是，我们要能够保证其他人把你的 AppId 偷过去之后，他也无法直接使用你的服务器资源。Web 端可以通过 <code>Web 安全域名</code> 来对请求来源做限制，可以简单的防御住 Web 的服务器资源盗取。但是 <strong>安全域名</strong> 对 Native 类的应用又是无效的，所以如果你是使用 Native App 的 SDK，那么设置安全域名就不够了，这个时候就要考虑使用「ACL 权限控制」。</p>
<p>注意，这里每次的调整都是对安全边界的一次次评估，不是每个设置每个应用都需要如此操作。</p>
<p>ACL 权限控制是如何管理安全的呢？举个例子：</p>
<p>比如你要做一个账号系统，这个系统中每个用户账号都有头像，所以你会有一个用户上传头像接口。那么，如果你把这个上传头像的功能放在注册成功之前，每个没有经过你的 ACL 权限认证（没有登录）的用户都可以通过这个接口上传头像，所以你这个上传头像的接口是存在滥用的。如果接口 ACL 权限设置为注册成功的某类用户，则用户必须要经过 ACL 权限认证为是属于某个权限的用户（即登录），并且此时他才可以使用这个接口。所以，上传接口如此，其他的类似功能也是同理，但凡是通过 SDK 或者 API 调用的接口操作，你都要确保他们的 ACL 权限控制是在你的控制范围内。这需要你的智慧和设计来保证安全，相信你也一定能做到。</p>
<p>SSL 其实没有什么好说的，所有的数据都采用加密链路，这样做可以保证数据的私密性。</p>
<p>总之，一切安全设计的背后都是需要你考虑清楚你的 App、你的产品的「安全边界」，制定对应的安全策略。当然安全是后话，首先通过使用 LeanCloud 节省大量时间成本、研发成本、机会成本把产品快速迭代起来才是正经事。</p>
<h2 id="安全中心">安全中心</h2><p>安全中心，是我们为每个应用提供的设置基本安全的入口，位置在 <a href="/app.html?appid=#/security">控制台 / 设置 / 安全中心</a>。</p>
<h3 id="服务开关">服务开关</h3><p>服务开关，是用来开启或者关闭当前应用所使用的服务，从根本上防止由于 AppId 和 AppKey 泄露后而可能会引发的服务资源被盗取的问题。</p>
<p><img src="images/security/service-switch.png" alt="image"></p>
<h3 id="Web_安全域名">Web 安全域名</h3><p>如果在前端使用 JavaScript SDK，当你打算正式发布出去的时候，请务必配置 <strong>Web 安全域名</strong>，方法是进入 <a href="/app.html?appid=#/security">控制台 / 设置 / 安全中心 / <strong>Web 安全域名</strong></a>。</p>
<p>设置「Web 安全域名」后，仅可在该域名下通过 JavaScript SDK 调用服务器资源，域名配置策略与浏览器域安全策略一致，要求域名协议、域和端口号都需严格一致，不支持子域和通配符。所以如果你要配置一个域名，要写清楚协议、域和端口，缺少一个都可能导致访问被禁止。举例说明一下域名的区别：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跨域</span></span><br><span class="line">www<span class="class">.a</span><span class="class">.com</span>:<span class="number">8080</span></span><br><span class="line">www<span class="class">.a</span><span class="class">.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 跨域 </span></span><br><span class="line">www<span class="class">.a</span><span class="class">.com</span>:<span class="number">8080</span></span><br><span class="line">www<span class="class">.a</span><span class="class">.com</span>:<span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 跨域  </span></span><br><span class="line"><span class="tag">a</span><span class="class">.com</span></span><br><span class="line">www<span class="class">.a</span><span class="class">.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 跨域</span></span><br><span class="line">xxx<span class="class">.a</span><span class="class">.com</span></span><br><span class="line">www<span class="class">.a</span><span class="class">.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同协议，跨域         </span></span><br><span class="line">http:</span><br><span class="line">https:</span><br></pre></td></tr></table></figure>
<p>这样就可以防止其他人通过外网其他地址盗用你的服务器资源。但是要注意，<strong>Web 安全域名</strong>所能达到的目的是防御恶意部署，而不是防御伪造脏数据（恶意用户通过绑定 host 方式还是有可能访问到应用的数据），所以要想对数据进行更多细粒度的控制，需要配合 ACL 来使用。</p>
<p>在 WebView 中使用，建议通过 WebView 去加载一个部署好的、有域名的 Web，然后缓存在本地，这样可以通过 <strong>Web 安全域名</strong> 来做限制。</p>
<p><img src="images/security/web-host.png" alt="image"></p>
<h3 id="操作日志">操作日志</h3><p>操作日志中会显示应用创建者及所有协作者的重要操作记录，比如删除数据操作的历史、操作用户名、操作 IP 及操作时间等，这个日志的目的是为了遇到问题更好地定位故障缘由，排查可能的恶意操作，防止应用数据被错误地改动。</p>
<h2 id="数据">数据</h2><h3 id="自动备份">自动备份</h3><p>LeanCloud 目前会每天备份一次应用数据，防止用户误操作删除了重要数据。如果发生误删除，请及时联系我们进行恢复。</p>
<h3 id="有效的数据类型">有效的数据类型</h3><p>我们已经仔细设计并实现了客户端 SDK，在你使用 iOS 或者 Android SDK 的时候，通常来说你不需要担心数据是如何保存的。只要简单地往 AVObject 添加数据，它们都能被正确地保存。</p>
<p>尽管如此，有些情况下了解数据如何存储在 LeanCloud 平台上还是有一些用处。</p>
<p>在平台内部，LeanCloud 将数据存储为 JSON，因此所有能被转换成 JSON 的数据类型都可以保存在 LeanCloud 平台上。并且，框架还可以处理日期、Bytes 以及文件类型。总结来说，对象中字段允许的类型包括：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>字符串</td>
</tr>
<tr>
<td>Number</td>
<td>数字</td>
</tr>
<tr>
<td>Boolean</td>
<td>布尔类型</td>
</tr>
<tr>
<td>Array</td>
<td>数组</td>
</tr>
<tr>
<td>Object</td>
<td>对象，或者 Pointer </td>
</tr>
<tr>
<td>Date</td>
<td>日期</td>
</tr>
<tr>
<td>Bytes</td>
<td>Base64 编码的二进制数据</td>
</tr>
<tr>
<td>File</td>
<td>文件</td>
</tr>
<tr>
<td>Null</td>
<td>空值</td>
</tr>
</tbody>
</table>
<p>Object 类型简单地表示每个字段的值都可以由能 JSON 编码的内嵌对象组合而成。凡是对象的键（key） 包含 <code>$</code> 或者 <code>.</code>，或者同时有 <code>__type</code> 键，都是框架内保留用来做一些额外处理的特殊键，因此请不要在你的对象中使用这样的 Key。</p>
<p>我们的 SDK 会处理原生的 Objective-C 和 Java 类型到 JSON 之间的转换。例如，当你保存一个 NSString 对象的时候，它在我们的系统中会被自动转换成 String 类型。</p>
<p>有两种方式可以存储原生的二进制数据。Bytes 类型允许直接在 AVObject 中关联 NSData 或者 bytes[] 类型的数据。这种方式只推荐用来存储小片的二进制数据。当要保存实际文件（例如图片、视频、文档等），请使用 AVFile 来表示 File 类型，并且 File 类型可以被保存到对象字段中关联起来。</p>
<h3 id="数据类型锁定">数据类型锁定</h3><p>当一个 Class 初次创建的时候，它不包含任何预先定义并继承的 schema。也就是说对于存储的第一个对象，它的字段可以包含任何有效的类型。</p>
<p>但是，当一个字段被保存至少一次的时候，这个字段将被锁定为保存过的数据类型。例如，如果一个 User 对象保存了一个字段 name，类型为 String，那么这个 name 字段将被严格限制为只允许保存 String 类型。如果你尝试保存其他类型到这个字段，我们的 SDK 会返回错误。</p>
<p>一个特例是任何字段都允许被设置为 null，无论它是什么类型。</p>
<h3 id="数据管理">数据管理</h3><p><a href="/data.html?appid=&lt;!--￼11--">数据管理</a> 是一个允许在你任意的一个应用里更新或者创建对象的一个 Web 界面的管理平台。在这里，你可以看到保存在 Class里的每个对象的原生 JSON 值。</p>
<p>当使用这个平台的时候，请牢记：</p>
<ul>
<li>输入 <code>null</code> 将会将值设为特殊的空值 <strong>null</strong>，而非字符串 <code>&quot;null&quot;</code>。</li>
<li>objectId、createdAt 和 updatedAt 不可编辑，它们都是系统自动设置的。</li>
<li>下划线开始的 Class 为系统内置数据表，不可删除，并且请轻易不要修改它的默认字段，但是可以向其中添加字段。</li>
</ul>
<h3 id="导入数据">导入数据</h3><p>除了 REST API 之外，我们还提供通过 JSON 文件和 CSV 格式文件的导入数据的功能。</p>
<p>要使用 JSON 文件创建一个新 Class，请进入 <a href="/data.html?appid=&lt;!--￼12--">控制台 / 存储 / 数据管理</a>，点击左侧 Class 导航栏的小齿轮图标，选择 <strong>数据导入</strong>。</p>
<div class="callout callout-info">数据文件的扩展名必须是 <code>.csv</code> 或者 <code>.json</code> 结尾，我们以此来判断导入数据的类型。</div>

<h4 id="JSON_文件格式">JSON 文件格式</h4><p>JSON 格式要求是一个符合我们 REST 格式的 JSON 对象数组，或者是一个包含了键名为 results、值为对象数组的 JSON 对象。例如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123; "<span class="attribute">results</span>": <span class="value">[</span><br><span class="line">  &#123;</span><br><span class="line">    "<span class="attribute">likes</span>": <span class="value"><span class="number">2333</span></span>,</span><br><span class="line">    "<span class="attribute">title</span>": <span class="value"><span class="string">"讲讲明朝的那些事儿"</span></span>,</span><br><span class="line">    "<span class="attribute">author</span>": <span class="value">&#123;</span><br><span class="line">      "<span class="attribute">__type</span>": <span class="value"><span class="string">"Pointer"</span></span>,</span><br><span class="line">      "<span class="attribute">className</span>": <span class="value"><span class="string">"Author"</span></span>,</span><br><span class="line">      "<span class="attribute">objectId</span>": <span class="value"><span class="string">"mQtjuMF5xk"</span></span><br><span class="line">    </span>&#125;</span>,</span><br><span class="line">    "<span class="attribute">isDraft</span>": <span class="value"><span class="literal">false</span></span>,</span><br><span class="line">    "<span class="attribute">createdAt</span>": <span class="value"><span class="string">"2015-11-25T17:15:33.347Z"</span></span>,</span><br><span class="line">    "<span class="attribute">updatedAt</span>": <span class="value"><span class="string">"2015-11-27T19:05:21.377Z"</span></span>,</span><br><span class="line">    "<span class="attribute">publishedAt</span>": <span class="value">&#123;</span><br><span class="line">      "<span class="attribute">__type</span>": <span class="value"><span class="string">"Date"</span></span>,</span><br><span class="line">      "<span class="attribute">iso</span>": <span class="value"><span class="string">"2015-11-27T19:05:21.377Z"</span></span><br><span class="line">    </span>&#125;</span>,</span><br><span class="line">    "<span class="attribute">objectId</span>": <span class="value"><span class="string">"fchpZwSuGG"</span></span><br><span class="line">  </span>&#125;]</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>【日期】示例中，<code>publishedAt</code> 是一个日期型字段，其格式要求请参考 <a href="rest_api.html#datatype_date">REST API &middot; 数据类型</a>。</p>
<p>【密码】导入用户密码需要使用一个特殊的字段 <code>bcryptPassword</code>，并且完全遵循 <a href="http://stackoverflow.com/a/5882472/1351961" target="_blank" rel="external">Stackoverflow &middot; What column type/length should I use for storing a Bcrypt hashed password in a Database?</a>  所描述的加密算法加密后，才可以作为合法的密码进行导入。</p>
<p>【关系】导入 Relation 关联数据时，需要填写要导入的 Class 名称、导入后的字段名称、关联的 Class 名称等信息，才能完整导入，例如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123; "<span class="attribute">results</span>": <span class="value">[</span><br><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">owningId</span>": <span class="value"><span class="string">"dMEbKFJiQo"</span></span>,</span><br><span class="line">  "<span class="attribute">relatedId</span>": <span class="value"><span class="string">"19rUj9I0cy"</span></span><br><span class="line"></span>&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">owningId</span>": <span class="value"><span class="string">"mQtjuMF5xk"</span></span>,</span><br><span class="line">  "<span class="attribute">relatedId</span>": <span class="value"><span class="string">"xPVrHL0W4n"</span></span><br><span class="line"></span>&#125;]</span>&#125;</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>owningId</code>： 将要导入的 Class 表内已经存在的对象的 objectId。</li>
<li><code>relatedId</code>：将要关联的 Class 里的对象的 objectId。</li>
</ul>
<p>例如，Post 有一个字段 comments 是 Relation 类型，对应的 Class 是 Comment，那么 owningId 就是已存在的 Post 的 objectId，而 relatedId 就是关联的 Comment 的 objectId。</p>
<h3 id="CSV格式文件">CSV格式文件</h3><p>导入 Class 的 csv 文件格式必须符合我们的扩展要求：</p>
<ul>
<li>第一行必须是字段的类型描述，支持 <code>int</code>、<code>long</code>、<code>number</code>、<code>double</code>、<code>string</code>、<code>date</code>、<code>boolean</code>、<code>file</code>、<code>array</code>、<code>object</code>、<code>geopoint</code> 等。</li>
<li>第二行是字段的名称</li>
<li>第三行开始才是要导入的数据</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string,int,string,double,date&#10;name,age,address,account,createdAt&#10;&#24352;&#19977;,33,&#21271;&#20140;,300.0,2014-05-07T19:45:50.701Z&#10;&#26446;&#22235;,25,&#33487;&#24030;,400.03,2014-05-08T15:45:20.701Z&#10;&#29579;&#20116;,21,&#19978;&#28023;,1000.5,2012-04-22T09:21:35.701Z</span><br></pre></td></tr></table></figure>
<p>导入的 <code>geopoint</code> 格式是一个用空格隔开字符串：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geopoint,string,int,string,double,date&#10;location,name,age,address,account,createdAt&#10;20 20,&#24352;&#19977;,33,&#21271;&#20140;,300.0,2014-05-07T19:45:50.701Z&#10;30 30,&#26446;&#22235;,25,&#33487;&#24030;,400.03,2014-05-08T15:45:20.701Z&#10;40 40,&#29579;&#20116;,21,&#19978;&#28023;,1000.5,2012-04-22T09:21:35.701Z</span><br></pre></td></tr></table></figure>
<p>导入的 Relation 数据，比 JSON 简单一些，第一列对应 JSON 的 <code>owningId</code>，也就是要导入的 Class 的存在对象的 objectId，第二列对应 <code>relatedId</code>，对应关联 Class 的 objectId。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dMEbKFJiQo,19rUj9I0cy&#10;mQtjuMF5xk,xPVrHL0W4n</span><br></pre></td></tr></table></figure>
<p>csv 导入也支持 Pointer 类型，要求类型声明为 <code>pointer:类名</code>，其中类名就是该 Pointer 列所指定的 className，列的值只要提供 objectId 即可，例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string,pointer:Player&#10;playerName,player&#10;&#24352;&#19977;,mQtjuMF5xk&#10;&#26446;&#22235;,xPVrHL0W4n</span><br></pre></td></tr></table></figure>
<h3 id="导出数据">导出数据</h3><p>我们还支持你可以导出所有的应用数据（包括加密后的用户密码），只要进入 <a href="/app.html?appid=#/export">控制台 / 应用设置 / 数据导出</a> 点击导出按钮即可开始导出任务。我们会在导出完成之后发送下载链接到你的注册邮箱。</p>
<p>导出还可以限定日期，我们将导出在限定时间内有过更新或者新增加的数据。</p>
<p>我们还提供了数据导出的 <a href="./rest_api.html#数据导出_API">RETS API</a>。</p>
<h4 id="导出用户数据的加密算法">导出用户数据的加密算法</h4><p>我们通过一个 Ruby 脚本来描述这个用户密码加密算法：</p>
<ol>
<li>创建 SHA-512 加密算法 hasher</li>
<li>使用 salt 和 password（原始密码） 调用 hasher.update</li>
<li>获取加密后的值 <code>hv</code></li>
<li>重复 512 次调用 <code>hasher.update(hv)</code>，每次hv都更新为最新的 <code>hasher.digest</code> 加密值</li>
<li>最终的 hv 值做 base64 编码，保存为 password</li>
</ol>
<p>假设：</p>
<table width="100%" border="0" cellpadding="6"><br>  <tbody><br>    <tr><br>      <td nowrap="">salt</td><br>      <td><pre style="margin:0;"><code>h60d8x797d3oa0naxybxxv9bn7xpt2yiowz68mpiwou7gwr2</code></pre></td><br>    </tr><br>    <tr><br>      <td nowrap="">原始密码</td><br>      <td><code>password</code></td><br>    </tr><br>    <tr><br>      <td nowrap="">加密后</td><br>      <td><pre style="margin:0;"><code>tA7BLW+NK0UeARng0693gCaVnljkglCB9snqlpCSUKjx2RgYp8VZZOQt0S5iUtlDrkJXfT3gknS4rRqjYsd/Ug==</code></pre></td><br>    </tr><br>  </tbody><br></table>

<p>实现代码：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'digest/sha2'</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">"base64"</span></span><br><span class="line"></span><br><span class="line">hasher = <span class="constant">Digest::SHA512</span>.new</span><br><span class="line">hasher.reset</span><br><span class="line">hasher.update <span class="string">"h60d8x797d3oa0naxybxxv9bn7xpt2yiowz68mpiwou7gwr2"</span></span><br><span class="line">hasher.update <span class="string">"password"</span></span><br><span class="line"></span><br><span class="line">hv = hasher.digest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hashme</span><span class="params">(hasher, hv)</span></span></span><br><span class="line">  <span class="number">512</span>.times <span class="keyword">do</span></span><br><span class="line">    hasher.reset</span><br><span class="line">    hv = hasher.digest hv</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  hv</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">result = <span class="constant">Base64</span>.encode64(hashme(hasher,hv))</span><br><span class="line">puts result.gsub(<span class="regexp">/\n/</span>,<span class="string">''</span>)</span><br></pre></td></tr></table></figure>
<p>非常感谢用户残圆贡献了一段 C# 语言示例代码：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/// 根据数据字符串和自定义 salt 值，获取对应加密后的字符串</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=<span class="string">"password"</span>&gt;数据字符串&lt;/param&gt;</span><br><span class="line">/// &lt;param name=<span class="string">"salt"</span>&gt;自定义 salt 值&lt;/param&gt;</span><br><span class="line">/// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">public <span class="keyword">static</span> <span class="type">string</span> <span class="type">SHA512Encrypt</span>(<span class="type">string</span> password, <span class="type">string</span> salt)</span><br><span class="line">&#123;</span><br><span class="line">    /*</span><br><span class="line">    用户密码加密算法</span><br><span class="line">    </span><br><span class="line">    <span class="number">1</span>、创建 <span class="type">SHA</span>-<span class="number">512</span> 加密算法 hasher</span><br><span class="line">    <span class="number">2</span>、使用 salt 和 password（原始密码） 调用 hasher.update</span><br><span class="line">    <span class="number">3</span>、获取加密后的值 hv</span><br><span class="line">    <span class="number">4</span>、重复 <span class="number">512</span> 次调用 hasher.update(hv)，每次hv都更新为最新的 hasher.digest 加密值</span><br><span class="line">    <span class="number">5</span>、最终的 hv 值做 base64 编码，保存为 password</span><br><span class="line">    */</span><br><span class="line">    password = salt + password;</span><br><span class="line">    byte[] bytes = <span class="type">System</span>.<span class="type">Text</span>.<span class="type">Encoding</span>.<span class="type">UTF8</span>.<span class="type">GetBytes</span>(password);</span><br><span class="line">    byte[] <span class="literal">result</span>;</span><br><span class="line">    <span class="type">System</span>.<span class="type">Security</span>.<span class="type">Cryptography</span>.<span class="type">SHA512</span> shaM = new <span class="type">System</span>.<span class="type">Security</span>.<span class="type">Cryptography</span>.<span class="type">SHA512Managed</span>();</span><br><span class="line">    <span class="literal">result</span> = shaM.<span class="type">ComputeHash</span>(bytes);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i++ &lt; <span class="number">512</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="literal">result</span> = shaM.<span class="type">ComputeHash</span>(<span class="literal">result</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    shaM.<span class="type">Clear</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Convert</span>.<span class="type">ToBase64String</span>(<span class="literal">result</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="安全性">安全性</h2><p>对于任何移动应用来说。因为客户端代码运行在一台移动设备上，因此可能会有不受信任的客户强行修改代码并发起恶意的请求。选择正确的方式来保护你的应用非常重要，但是正确的方式取决于你的应用，以及应用存储的数据。</p>
<p>我们提供多种方式使用权限控制来获得安全性。如果你有关于任何保护你应用安全的最佳方式的问题，我们都鼓励你联系我们的客户支持。</p>
<h3 id="SSL_加密传输">SSL 加密传输</h3><p>首先，我们所有的 API 请求都通过 <a href="http://zh.wikipedia.org/wiki/%E5%AE%89%E5%85%A8%E5%A5%97%E6%8E%A5%E5%B1%82" target="_blank" rel="external">SSL加密传输</a>，保证传输过程中的数据安全性和可靠性。</p>
<h3 id="对象级别的权限">对象级别的权限</h3><p><img src="images/acl.png" alt="image"></p>
<p>最灵活的保护你应用数据安全的方式是通过访问控制列表（Access Control List），通常简称为 ACL 机制。ACL 背后的思想是为每个对象关联一系列 User 或者 Role，这些 User 或者 Role 包含了特定的权限。一个 User 必须拥有读权限（或者属于一个拥有读权限的 Role）才可以获取一个对象的数据，同时，一个 User 需要写权限（或者属于一个拥有写权限的 Role）才可以更改或者删除一个对象。</p>
<p>大多数应用都通过 ACL 来规范它们的访问模式。例如：</p>
<ul>
<li>对于私有数据，read 和 write 都可以限制为对象拥有者（owner）所有。</li>
<li>一个信息公告板的帖子，作者和属于「版主」角色的成员可拥有 write 权限，通常 public 允许 read 访问（也就是允许公开读取帖子）。</li>
<li>高优先级用户或者开发者创建的数据，例如全局的每日广播消息，可以让 public拥有 read 许可，但是严格限制 write 权限给「管理员」角色。</li>
<li>一条从一个用户发往另一个用户的消息，可以将读和写的访问许可限制到关联的这两个用户。</li>
</ul>
<p>使用 LeanCloud SDK，你可以设置一个默认的 ACL 给客户端所有创建的对象。如果你同时开启自动匿名用户创建的功能，你可以保证你的数据拥有严格限制到每个单独用户的ACL权限。请仔细阅读 iOS 和 Android 指南关于选择默认安全策略的章节。</p>
<p>通过设置 Master Key的 REST API，你还是可以绕过 ACL 限制执行任何操作。这可以让开发者更容易地管理数据。例如，你可以通过 REST API 删除一条私有消息，哪怕这条消息设置为拥有者私有。</p>
<p>代码中如何使用 ACL，请阅读相应的 ACL 文档。</p>
<h3 id="列级别的权限">列级别的权限</h3><p>这个概念比较简单，通过编辑数据管理页面某个 Class 的列属性，某一列数据可以设置为「只读」。对于 <code>_User</code> 数据表，还可以设置为 「只限当前用户读写」，即只能当前登录的用户读写自己的数据。</p>
<p>某一列的数据还可以设置为 「客户端不可见」。设置了之后，当客户端发起查询的时候，返回的结果将不包含相关字段。比如，匿名发帖的应用，你仍然希望发帖的时候，也记录下真实的作者，但不希望将此信息返回给客户端，所以，这时候就可以设置作者字段为「客户端不可见」。</p>
<h3 id="Class_级别的权限">Class 级别的权限</h3><p><img src="images/cla_permission.png" alt="image"></p>
<p>在一些情况下，设置整个class允许的权限是一种更自然的方式。例如，你可能想设置整个 Class 只读，或者只写。</p>
<p>为了简单地做到这一点，我们让你可以设置每个 Class 允许的操作。为了访问这些设置，请进入数据管理平台，选择一个 Class，并点击右侧菜单中的 <strong>其他</strong> 下拉框找到权限设置。</p>
<p>你可以为选中的 Class 禁止客户端执行下列操作的能力：</p>
<ul>
<li>GET - 通过objectId获取对象。</li>
<li>Find - 发起一次对象列表查询。</li>
<li>Update - 保存一个已经存在并且被修改的对象。</li>
<li>Create - 保存一个从未创建过的新对象。</li>
<li>Delete - 删除一个对象。</li>
<li>Add fields - 添加新字段到class</li>
</ul>
<h3 id="App_安全选项">App 安全选项</h3><p>进入应用设置菜单，在左侧菜单可以看到 <strong>应用选项设置</strong>：</p>
<p>点击选中或者取消选中就可以启用或者关闭这些选项，大概介绍下功能：</p>
<ul>
<li><strong>启用注册用户邮箱验证</strong>：是否要求你应用里的注册用户验证邮箱， 默认不启用。如果启用，每次用户注册，都会发送一封邮件到用户提供的邮箱，要求认证，具体请看开发指南里的用户一节。</li>
<li><strong>禁止客户端创建 Class</strong>：是否禁止客户端动态创建 Class。如果启用，那么通过 SDK 或者 REST API 都没办法动态创建不存在的 Class 了，这种情况下只能通过我们的数据管理平台来创建新 Class。</li>
<li><strong>禁止消息推送</strong>：是否彻底禁止消息推送。如果启用，任何消息推送的调用都不允许。</li>
<li><strong>禁止从客户端推送消息</strong>：是否禁止从客户端推送消息，如果启用，这那么通过 SDK 或者 REST API 都被禁止推送消息，只能通过我们管理平台提供的推送界面来推送消息。</li>
</ul>
<h2 id="第三方加密">第三方加密</h2><p>对于 Android 应用，除了代码混淆之外，还可以使用第三方加密工具，隐藏 classes.dex，通过动态加载的方法进一步提高应用的安全性。下面我们简单介绍一下爱加密。</p>
<h3 id="爱加密">爱加密</h3><p><a href="http://www.ijiami.cn/" target="_blank" rel="external">爱加密</a> 是专为移动开发者提供安全服务的一个平台，可解决开发者面临的应用安全问题。加密的步骤很简单：</p>
<ol>
<li>提交应用；</li>
<li>下载加密后的 apk 文件；</li>
<li>下载爱加密提供的签名工具，对应用进行签名。</li>
</ol>
<p>相关步骤还可以见下面的截图。</p>
<p>申请账号，提交应用，下载签名工具：</p>
<p><img src="images/ijiami_2.png" alt="image"></p>
<p>加密后重新签名：</p>
<p><img src="images/ijiami_1.png" alt="image"></p>
<p>这样得到的 apk 文件，普通的反编译之后得到的是，</p>
<p><img src="images/decompile.png" alt="image"></p>
<p>可以看到，代码被隐藏起来了，应用被破解的难度大幅增加了。</p>
<p>我们一直努力提供更多功能给开发者来保护你的应用，也希望大家持续地给我们反馈，感谢。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="数据和安全">数据和安全</h1><h2 id="安全总览">安全总览</h2><p>几乎每一位使用 LeanCloud 的用户都会问，如何能够保证自己应用的安全？对安全的关注说明你也位对产品负责、对用户负责、对自己负责、做事态度认真的开发者，这也正是 <a hr]]>
    </summary>
    
      <category term="leancloud" scheme="http://yoursite.com/tags/leancloud/"/>
    
      <category term="leancloud" scheme="http://yoursite.com/categories/leancloud/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[云引擎常见问题和解答]]></title>
    <link href="http://yoursite.com/2015/12/30/avos/cloud_code_faq/"/>
    <id>http://yoursite.com/2015/12/30/avos/cloud_code_faq/</id>
    <published>2015-12-29T23:56:29.000Z</published>
    <updated>2015-12-18T10:22:41.164Z</updated>
    <content type="html"><![CDATA[<h1 id="云引擎常见问题和解答">云引擎常见问题和解答</h1><h2 id="如何判断当前是测试环境还是生产环境？">如何判断当前是测试环境还是生产环境？</h2><p>请参考文档 <a href="/leanengine_guide-node.html#运行环境区分">云引擎开发指南 Node.js</a> / <a href="/leanengine_guide-python.html#运行环境区分">Python</a> - 运行环境区分。</p>
<h2 id="怎么添加第三方模块">怎么添加第三方模块</h2><p>云引擎 2.0 开始支持添加第三方模块（请参考 <a href="leanengine_guide-cloudcode.html#云代码_2_0_版">云引擎指南 - 升级到 2.0</a>），只需要像普通的 Node.js 项目那样，在项目根目录创建文件 <code>package.json</code>，下面是一个范例：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "<span class="attribute">name</span>": <span class="value"><span class="string">"cloud-engine-test"</span></span>,</span><br><span class="line">  "<span class="attribute">description</span>": <span class="value"><span class="string">"Cloud Engine test project."</span></span>,</span><br><span class="line">  "<span class="attribute">version</span>": <span class="value"><span class="string">"0.0.1"</span></span>,</span><br><span class="line">  "<span class="attribute">private</span>": <span class="value"><span class="literal">true</span></span>,</span><br><span class="line">  "<span class="attribute">dependencies</span>": <span class="value">&#123;</span><br><span class="line">    "<span class="attribute">async</span>": <span class="value"><span class="string">"0.9.0"</span></span>,</span><br><span class="line">    "<span class="attribute">moment</span>": <span class="value"><span class="string">"2.9.0"</span></span><br><span class="line">  </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p><code>dependencies</code> 内的内容表明了该项目依赖的三方模块（比如示例中的 <code>async</code> 和 <code>moment</code>）。</p>
<p>然后在项目根目录执行：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span></span><br></pre></td></tr></table></figure>
<p>即可下载相关三方包到 <code>node_modules</code> 目录。</p>
<p>然后即可在代码中引入三方包：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">async</span> = <span class="built_in">require</span>(<span class="string">'async'</span>);</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：命令行工具部署时是不会上传 <code>node_modules</code> 目录，因为云代码服务器会根据 <code>package.json</code> 的内容自动下载三方包。所以也建议将 <code>node_modules</code> 目录添加到 <code>.gitignore</code> 中，使其不加入版本控制。</p>
<h2 id="Maximum_call_stack_size_exceeded_如何解决？">Maximum call stack size exceeded 如何解决？</h2><p><code>AV.Object.extend</code> 产生的对象需要作为全局变量保存（即定义在 AV.Cloud.define 方法之外）。因为每调用一次，就会产生一个新的类的实例，并且和之前创建的实例形成一个链表。调用次数过多后（几万次）就会堆栈溢出。如果你的应用时不时出现 <strong>Maximum call stack size exceeded</strong> 错误，请确认是否误用了 <code>AV.Object.extend</code> 方法。</p>
<p>我们在 <a href="./js_guide.html#AV_Object">JavaScript 指南 - AV.Object</a> 章节中也进行了描述。</p>
<h2 id="目前支持哪些语言？">目前支持哪些语言？</h2><p>我们提供了 JavaScript SDK，支持 Node.js 和 Python 环境，未来可能会引入 PHP 等其他语言。</p>
<h2 id="Web_Hosting_备案如何操作？">Web Hosting 备案如何操作？</h2><p>只有网站类的才需要备案，并且在主域名已备案的情况下，二级子域名不需要备案。 如果主站需要托管在我们这边，且还没有备案过，我们可以协助你完成备案，请参考文档 <a href="leanengine_guide-node.html#绑定独立域名">绑定独立域名 Node.js</a> / <a href="leanengine_guide-python.html#绑定独立域名">Python</a>。</p>
<h2 id="调用云引擎方法如何收费？">调用云引擎方法如何收费？</h2><p>现在云引擎本身不收费，云引擎中如果有 LeanCloud 的存储等 API 调用，按 API 收费策略收费。</p>
<h2 id="「定义函数」和「Git_部署」可以混用吗？">「定义函数」和「Git 部署」可以混用吗？</h2><p>「定于函数」的产生是为了方便大家初次体验云引擎，或者只是需要一些简单 hook 方法的应用使用。我们的实现方式就是把定义的函数拼接起来，生成一个云引擎项目然后部署。</p>
<p>所以可以认为「定义函数」和 「git 部署」最终是一样的，都是一个完整的项目。<br>是一个单独功能，可以不用使用基础包，git 等工具快速的生成和编辑云引擎。<br>当然，你也可以使用基础包，自己写代码并部署项目。<br>这两条路是分开的，任何一个部署，就会导致另一种方式失效掉。</p>
<h2 id="为什么查询_include_没有生效？">为什么查询 include 没有生效？</h2><p>以 JavaScript 云引擎为例子，很多时候，经常会定义一个云函数，在里面使用 <code>AV.Query</code> 查询一张表，并 include 其中一个 pointer 类型的字段，然后返回给客户端:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AV.Cloud.define(<span class="string">'querySomething'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> query = <span class="keyword">new</span> AV.Query(<span class="string">'Something'</span>);</span><br><span class="line">  <span class="comment">//假设 user 是 Something 表的一个 Pointer 列。</span></span><br><span class="line">  query.include(<span class="string">'user'</span>);</span><br><span class="line">  <span class="comment">//……其他条件或者逻辑……</span></span><br><span class="line">  query.find().then(<span class="function"><span class="keyword">function</span>(<span class="params">results</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//返回查询结果给客户端</span></span><br><span class="line">    res.success(results);</span><br><span class="line">  &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//返回错误给客户端</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>你会看到返回的结果里， user 仍然是 pointer 类型，似乎 include 没有生效？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> result: [</span><br><span class="line">   &#123;</span><br><span class="line">     ……Something 其他字段</span><br><span class="line">     "user": &#123;</span><br><span class="line">       "className": "_User",</span><br><span class="line">       "__type": "Pointer",</span><br><span class="line">       "objectId": "abcdefg"</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ……</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这其实是因为 <code>res.success(results)</code> 会调用到 <code>AV.Object#toJSON</code> 方法，将结果序列化为 JSON 对象返回给客户端。<br>而 <code>AV.Object#toJSON</code> 方法为了防止循环引用，当遇到属性是 Pointer 类型会返回 pointer 元信息，不会将 include 的其他字段添加进去。<br>因此，你需要主动将该字段进行 JSON 序列化，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">query.find().then(<span class="function"><span class="keyword">function</span>(<span class="params">results</span>) </span>&#123;</span><br><span class="line">   <span class="comment">//主动序列化 json 列。</span></span><br><span class="line">   results.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">     result.set(<span class="string">'user'</span>, result.get(<span class="string">'user'</span>) ?  result.get(<span class="string">'user'</span>).toJSON() : <span class="literal">null</span>);</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="comment">//再返回结果</span></span><br><span class="line">   res.success(results);</span><br><span class="line"> &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">   <span class="comment">//返回错误给客户端</span></span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="云引擎常见问题和解答">云引擎常见问题和解答</h1><h2 id="如何判断当前是测试环境还是生产环境？">如何判断当前是测试环境还是生产环境？</h2><p>请参考文档 <a href="/leanengine_guide-node.html#运行环境区分">]]>
    </summary>
    
      <category term="leancloud" scheme="http://yoursite.com/tags/leancloud/"/>
    
      <category term="leancloud" scheme="http://yoursite.com/categories/leancloud/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cloud Query Language]]></title>
    <link href="http://yoursite.com/2015/12/30/avos/cql_guide/"/>
    <id>http://yoursite.com/2015/12/30/avos/cql_guide/</id>
    <published>2015-12-29T23:56:29.000Z</published>
    <updated>2015-12-18T10:22:50.498Z</updated>
    <content type="html"><![CDATA[<h1 id="Cloud_Query_Language_详细指南">Cloud Query Language 详细指南</h1><p>Cloud Query Language（简称 CQL） 是 LeanCloud 为查询 API 定制的一套类似 SQL 查询语法的子集和变种，主要目的是降低大家学习 LeanCloud 查询的 API 的成本，可以使用传统的 SQL 语法来查询 LeanCloud 应用内的数据。</p>
<p>本文档将详细介绍 CQL 的语法和常见用法。</p>
<h2 id="介绍及基本语法">介绍及基本语法</h2><p>最基本的一个查询某个 class 下的 100 条数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore</span></span><br></pre></td></tr></table></figure>
<p>等价于（以 Android 为例子）:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AVQuery&lt;AVObject&gt; query = <span class="keyword">new</span> AVQuery&lt;AVObject&gt;(<span class="string">"GameScore"</span>);</span><br><span class="line">List&lt;AVObject&gt; avObjects = query.find()</span><br></pre></td></tr></table></figure>
<p><code>select</code> 一个完整的语法形式类似这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> [查询字段列表，逗号隔开] <span class="keyword">from</span> [<span class="keyword">class</span> 名称]</span><br><span class="line">   [<span class="keyword">where</span> [条件列表]</span><br><span class="line">   [<span class="keyword">limit</span> [<span class="keyword">skip</span>],<span class="keyword">limit</span></span><br><span class="line">   [<span class="keyword">order</span> <span class="keyword">by</span> [排序字段列表] [<span class="keyword">asc</span> |<span class="keyword">desc</span>]]]]</span></span><br></pre></td></tr></table></figure>
<p>一些小例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//查询结果只包含 name,score 以及内置字段(objectId,createdAt等)</span><br><span class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">name</span>,score <span class="keyword">from</span> GameScore</span><br><span class="line"></span><br><span class="line">//根据 <span class="keyword">name</span> 查找</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'dennis'</span></span><br><span class="line"></span><br><span class="line">//根据 <span class="keyword">name</span> 和 score 同时查找</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">is</span> <span class="keyword">exists</span> <span class="keyword">and</span> score &gt; <span class="number">80</span> <span class="keyword">and</span> score &lt;= <span class="number">100</span></span><br><span class="line"></span><br><span class="line">//分页查找，从第 <span class="number">100</span> 条开始向后查找 <span class="number">10</span> 条数据</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">limit</span> <span class="number">100</span>,<span class="number">10</span></span><br><span class="line"></span><br><span class="line">//根据 score 和 <span class="keyword">name</span> 排序</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">order</span> <span class="keyword">by</span> score,+<span class="keyword">name</span> <span class="keyword">desc</span></span></span><br></pre></td></tr></table></figure>
<h2 id="查询条件">查询条件</h2><p><code>where</code> 之后的查询条件基本跟 SQL 语法相似，比如支持 <code>or</code> 和 <code>and</code> 的复合查询，支持 <code>=</code>、<code>!=</code>、<code>&lt;</code>、<code>&lt;</code> 等比较运算符，支持子查询、in 查询等。详细解释如下。</p>
<h3 id="基本查询">基本查询</h3><p>查询指定信息的对象，用 <code>=</code> 比较符：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'dennis'</span></span></span><br></pre></td></tr></table></figure>
<p>查询不等于指定信息的对象：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span>!=<span class="string">'dennis'</span></span></span><br></pre></td></tr></table></figure>
<p>也可以用 <code>&lt;&gt;</code> 运算符来表示不等于。</p>
<p>比较日期，使用 <code>date</code> 函数来转换，比如查询特定时间之前创建的对象：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> createdAt &lt; <span class="built_in">date</span>(<span class="string">'2011-08-20T02:06:57.931Z'</span>)</span></span><br></pre></td></tr></table></figure>
<p>date 函数接收的日期格式必须是 <code>2011-08-20T02:06:57.931Z</code> 的 UTC 时间。更多内置函数请看最后的 <a href="#内置函数">内置函数</a> 部分。</p>
<p>一些常见的查询运算符：</p>
<table><br>  <tr><th>Key</th><th>Operation</th></tr><br>  <tr><td>&lt;</td><td>小于</td></tr><br>  <tr><td>&lt;=</td><td>小于等于</td></tr><br>  <tr><td>&gt;</td><td>大于</td></tr><br>  <tr><td>&gt;=</td><td>大于等于</td></tr><br>  <tr><td> != 或者 &lt;&gt;</td><td>不等于</td></tr><br>  <tr><td>[not] like</td><td>模糊查询</td></tr><br>  <tr><td>[not] regexp</td><td>正则匹配</td></tr><br>  <tr><td>[not] in(子查询或者数组)</td><td>包含或者不包含</td></tr><br>  <tr><td>is [not] exists</td><td>这个 Key 有值或者不存在值</td></tr><br></table>

<p>比较运算符可以用在日期、字符串、数字甚至对象上。</p>
<h4 id="模糊查询">模糊查询</h4><p>模糊查询可以使用 <code>like</code>，比如查询名字以 dennis 开头的对象。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'dennis%'</span></span></span><br></pre></td></tr></table></figure>
<p><code>%</code> 表示模糊匹配的位置占位符。</p>
<p>like 本质上是转成 <code>regexp</code> 的正则匹配查询，因此上面的例子还可以写成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span> regexp <span class="string">'dennis.*'</span></span></span><br></pre></td></tr></table></figure>
<p>否定形式，查询名字不以 dennis 开头的对象：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">not</span> <span class="keyword">like</span> <span class="string">'dennis%'</span></span><br><span class="line">或者</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">not</span> regexp <span class="string">'dennis.*'</span></span></span><br></pre></td></tr></table></figure>
<p>正则匹配的效率一般，类似这种全文搜索请求，我们都推荐采用 <a href="app_search_guide.html">应用内全文搜索</a>。</p>
<h5 id="值是否存在查询">值是否存在查询</h5><p>只返回 <code>level</code> 字段值存在的对象：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">level</span> <span class="keyword">is</span> <span class="keyword">exists</span></span></span><br></pre></td></tr></table></figure>
<p>反之，使用 <code>is not exists</code>。</p>
<h3 id="数组查询">数组查询</h3><p>假设 <code>scores</code> 字段是一个数组，我们想查询分数里有 100 的成绩列表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> scores=<span class="number">100</span></span></span><br></pre></td></tr></table></figure>
<p>如果想查找分数<strong>只有</strong>两个 100 分的成绩：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> scores all (<span class="number">100</span>,<span class="number">100</span>)</span></span><br></pre></td></tr></table></figure>
<p><code>all</code> 表示数组完全匹配。</p>
<p>查询数组长度为特定值的对象：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="function"><span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="title">size</span>(<span class="params">scores</span>) </span>= <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>数组长度查询仅支持等于号，不支持大小和小于等其他比较运算符。</p>
<h3 id="子查询">子查询</h3><p>使用 <code>in</code> 来做子查询，后面跟的可以是一个列表，例如查询名字是 dennis、catty 和 green 三个玩家的成绩：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">in</span> (<span class="string">'dennis'</span>,<span class="string">'catty'</span>,<span class="string">'green'</span>)</span></span><br></pre></td></tr></table></figure>
<p>当然，如果想查询的不在列表里，那可以使用 <code>not in</code>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">'dennis'</span>,<span class="string">'catty'</span>,<span class="string">'green'</span>)</span></span><br></pre></td></tr></table></figure>
<p>in 后面还可以是一个子查询，比如查询玩家信息，并且成绩大于 80 分的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> Player <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> GameScore <span class="keyword">where</span> score&gt;<span class="number">80</span>)</span></span><br></pre></td></tr></table></figure>
<p>注意子查询必须指定查询的字段名称是 <code>select name</code>。</p>
<p>子查询另一种常见形式是使用 <code>=</code> 或 <code>!=</code> 跟一条查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> Player <span class="keyword">where</span> <span class="keyword">name</span> =(<span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> GameScore <span class="keyword">where</span> score&gt;<span class="number">80</span>)</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> Player <span class="keyword">where</span> <span class="keyword">name</span> !=(<span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> GameScore <span class="keyword">where</span> score&lt;=<span class="number">80</span>)</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：子查询的语句也受上限 1000 条记录的限制。</strong></p>
<h3 id="地理位置信息查询">地理位置信息查询</h3><p>可以通过 CQL 进行地理位置信息查询，比如我想查询自己附近的玩家（从近到远排序），假设 <code>location</code> 字段是 GeoPoint 类型：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> Player <span class="keyword">where</span> location near [<span class="number">116.4</span>, <span class="number">39.9</span>]</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>[116.4, 39.9]</code> 是经纬度坐标。也可以使用 <code>geopoint</code> 函数来创建：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> Player <span class="keyword">where</span> location near geopoint(<span class="number">116.4</span>, <span class="number">39.9</span>)</span></span><br></pre></td></tr></table></figure>
<p>只有在地理位置信息查询里才可以使用 <code>[longitude, latitude]</code> 这样的语法。在其他查询里将被作为数组类型。</p>
<p>为了限定搜索的最大距离，还可以使用 <code>max [距离]</code> 来限定，比如限定在 1 公里内：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> Player <span class="keyword">where</span> location near geopoint(<span class="number">116.4</span>, <span class="number">39.9</span>) <span class="keyword">max</span> <span class="number">1</span> km</span></span><br></pre></td></tr></table></figure>
<p>距离长度的其他单位包括 <code>miles</code>（英里）和 <code>radians</code>（弧度），如果不提供明确的单位，默认是<strong>弧度</strong>。</p>
<p>通过 <code>min [距离]</code> 还可以限定最小距离：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> Player <span class="keyword">where</span> location near geopoint(<span class="number">116.4</span>, <span class="number">39.9</span>) <span class="keyword">min</span> <span class="number">0.5</span> km</span></span><br></pre></td></tr></table></figure>
<p><code>min</code> 和 <code>max</code> 同时限定的时候，<code>min</code> 必须出现在 <code>max</code> 之前：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> Player <span class="keyword">where</span> location near geopoint(<span class="number">116.4</span>, <span class="number">39.9</span>) <span class="keyword">min</span> <span class="number">0.5</span> km <span class="keyword">max</span> <span class="number">1</span> km</span></span><br></pre></td></tr></table></figure>
<p>如果想查询某个矩形框内的对象，可以使用 <code>within [西南坐标] and [东北坐标]</code> 的语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> Player <span class="keyword">where</span> location <span class="keyword">within</span> [<span class="number">116.33</span>, <span class="number">39.97</span>] <span class="keyword">and</span> [<span class="number">116.37</span>, <span class="number">39.99</span>]</span></span><br></pre></td></tr></table></figure>
<h3 id="查询个数(count)">查询个数(count)</h3><p>使用 <code>count</code> 查询来返回符合查询条件的数目，比如查询整张表的记录数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> GameScore</span></span><br></pre></td></tr></table></figure>
<p><code>count</code> 不支持 <code>distinct</code> 等语法。仅限 <code>count(*)</code> 和 <code>count(objectId)</code>。</p>
<p>查询分数大于 60 并且小于等于 80 的成绩数目：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> GameScore <span class="keyword">where</span> score&gt;<span class="number">60</span> <span class="keyword">and</span> score&lt;=<span class="number">80</span></span></span><br></pre></td></tr></table></figure>
<p>查询个数的同时可以返回对象：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">count</span>(*),* <span class="keyword">from</span> GameScore</span></span><br></pre></td></tr></table></figure>
<p>也可以返回特定的字段：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">count</span>(*),<span class="keyword">name</span> <span class="keyword">from</span> GameScore</span></span><br></pre></td></tr></table></figure>
<h3 id="关系查询">关系查询</h3><p>有几种方式来查询对象之间的关系数据。如果你想获取对象，而这个对象的一个字段对应了另一个对象， 你可以用一个 where 查询，自己构造一个 Pointer，和其他数据类型一样。</p>
<p>举例说，如果每一个 Comment 有一个 Post 对象在它的 post 字段上（Pointer 类型），你可以对一个 post 取得所有 comment：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">Comment</span> <span class="keyword">where</span> post=pointer(<span class="string">'Post'</span>,<span class="string">'51e3a359e4b015ead4d95ddc'</span>)</span></span><br></pre></td></tr></table></figure>
<p><code>pointer</code> 函数接收 className 和 objectId。</p>
<p>如果你想获取对象, 这个对象的一个字段指向的对象（必须是 Pointer）是符合另一个查询的， 你可以使用 in 查询。注意默认的 limit 是 100 而且最大的 limit 是 1000，这个限制同样适用于内部的查询，所以对于较大的数据集你可能需要细心地构建查询来获得期望的行为。举例说，假设你有一个 Post 类和一个 Comment 类，每个 Comment 都有一个指向它的 Post 的 Pointer，你可以找到对于有图片的 Post 的 Comment：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">Comment</span> <span class="keyword">where</span> post <span class="keyword">in</span> (<span class="keyword">select</span> * <span class="keyword">from</span> Post <span class="keyword">where</span> image <span class="keyword">is</span> <span class="keyword">exists</span>)</span></span><br></pre></td></tr></table></figure>
<p>如果 Post 下面有一个 key 是 Relation 类型，并且叫做 likes，存储了喜欢这个 Post 的 User。你可以找到这些 user，他们都 like 过同一个指定的 post：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> _User <span class="keyword">where</span> related likes <span class="keyword">to</span> pointer(<span class="string">'Post'</span>, <span class="string">'51e3a359e4b015ead4d95ddc'</span>)</span></span><br></pre></td></tr></table></figure>
<p>基本的查询形式是 <code>releated &lt;key&gt; to &lt;pointer&gt;</code>。</p>
<p>如果某个字段是 Pointer，默认查询的时候，只会返回 <code>{__type: &#39;Pointer&#39;, objectId: &#39;objectId&#39;, className:&#39;Post&#39;}</code> 这些基本信息，如果希望同时将这个对象的其他信息查询下来，可以使用 include，比如查询 Comment 同时将 Post 带下来：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">include</span> post, * <span class="keyword">from</span> <span class="keyword">Comment</span></span></span><br></pre></td></tr></table></figure>
<p>在 select 中采用 <code>include &lt;key&gt;</code> 就可以将某个 Pointer 字段关联查询出来。多个字段要多次 include：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">include</span> post,<span class="keyword">include</span> author <span class="keyword">from</span> <span class="keyword">Comment</span></span></span><br></pre></td></tr></table></figure>
<p>同样，还可以支持嵌套的 include 查询，比如 Post 里还有一个 Pointer 指向 Category：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> <span class="keyword">include</span> post.<span class="keyword">category</span>,* <span class="keyword">from</span> <span class="keyword">Comment</span></span></span><br></pre></td></tr></table></figure>
<h3 id="复合查询">复合查询</h3><p>你可以使用 <code>and</code> 和 <code>or</code> 来做符合查询，例如查询分数在 80 到 100 之间，可以用 <code>and</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> score&gt;<span class="number">80</span> <span class="keyword">and</span> score&lt;=<span class="number">100</span></span></span><br></pre></td></tr></table></figure>
<p>再加个条件，或者分数为 0 分的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> score&gt;<span class="number">80</span> <span class="keyword">and</span> score&lt;=<span class="number">100</span> <span class="keyword">or</span> score=<span class="number">0</span></span></span><br></pre></td></tr></table></figure>
<p><code>and</code> 的优先级高于 <code>or</code>，因此上面的查询也可以用括号来明确地表示这种优先级：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> (score&gt;<span class="number">80</span> <span class="keyword">and</span> score&lt;=<span class="number">100</span>) <span class="keyword">or</span> score=<span class="number">0</span></span></span><br></pre></td></tr></table></figure>
<h2 id="限定返回值">限定返回值</h2><p>通过 <code>limit</code> 语句来限定返回结果大小，比如限定返回 100 个：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">Comment</span> <span class="keyword">limit</span> <span class="number">100</span></span></span><br></pre></td></tr></table></figure>
<p>可以设定从第 m+1 个元素开始，例如从第 101 个元素（包含）开始往后取 10 个：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">Comment</span> <span class="keyword">limit</span> <span class="number">100</span>,<span class="number">10</span></span></span><br></pre></td></tr></table></figure>
<p>这个形式跟 MySQL 是类似的。</p>
<h3 id="占位符">占位符</h3><p>查询条件和 limit 子句还支持占位符，也就是可以用问号 <code>?</code> 替代值，值的列表通过 SDK 提供的方法传入，具体请参考各 SDK 用法，例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">where</span> <span class="keyword">name</span>=? <span class="keyword">and</span> score&gt;? <span class="keyword">limit</span> ?,?</span></span><br></pre></td></tr></table></figure>
<p>占位符支持所有 LeanCloud 平台上的有效类型，复杂类型（如日期、GeoPoint）要求以 <a href="./rest_api.html#数据类型">REST API</a> 文档说明的 JSON 格式来提供。</p>
<p><strong>我们推荐使用占位符的方式来使用 CQL，查询语句可以通过预编译被缓存起来，降低 CQL 的转换开销。</strong></p>
<h2 id="排序">排序</h2><p>通过 <code>order</code> 语句来排序，<code>order</code> 语句只能出现在最后，不能在 <code>where</code> 和 <code>limit</code> 之前。</p>
<p>例如按照分数倒序排（分数高的前）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span></span></span><br></pre></td></tr></table></figure>
<p>也可以写成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">order</span> <span class="keyword">by</span> -score</span></span><br></pre></td></tr></table></figure>
<p>加号表示升序，减号表示降序。</p>
<p>多个字段组合排序，例如分数高的前，名字相同的「更小」的在前（字母顺序）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">order</span> <span class="keyword">by</span> -score,<span class="keyword">name</span></span></span><br></pre></td></tr></table></figure>
<p>同样的语句可以写成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">order</span> <span class="keyword">by</span> score,+<span class="keyword">name</span> <span class="keyword">desc</span></span><br><span class="line">或者</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> GameScore <span class="keyword">order</span> <span class="keyword">by</span> -score,<span class="keyword">name</span> <span class="keyword">asc</span></span></span><br></pre></td></tr></table></figure>
<p>没有写上明确的加号或者减号的字段，将根据最后的 <code>desc</code> 或者 <code>asc</code> 来决定采用升序还是降序。</p>
<h2 id="内置函数">内置函数</h2><p>CQL 提供了一些内置函数来方便地创建 pointer、geopoint 等类型：</p>
<table><br>  <tr><th>Name</th><th>Operation</th></tr><br>  <tr><td>date(‘YYYY-MM-DDTHH:MM:SS.MMMMZ’)</td><td>创建日期类型</td></tr><br>  <tr><td>pointer(className, objectId)</td><td>创建 Pointer</td></tr><br>  <tr><td>geopoint(经度, 纬度)</td><td>创建 GeoPoint</td></tr><br>  <tr><td>file(objectId)</td><td>创建 file 类型</td></tr><br>  <tr><td>base64(base64编码字符串)</td><td>创建 Bytes 类型</td></tr><br>  <tr><td>current_timestamp()</td><td>创建当前日期</td></tr><br></table>

<p>如果不使用这些函数，你也使用 <a href="./rest_api.html#数据类型">REST API 文档</a> 定义的 JSON 对象来创建特定类型，例如 Pointer：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">Comment</span> <span class="keyword">where</span> post=</span><br><span class="line">  &#123;className:<span class="string">'Post'</span>, objectId:<span class="string">'51e3a334e4b0b3eb44adbe1a'</span>,__type:<span class="string">'Pointer'</span>&#125;</span></span><br></pre></td></tr></table></figure>
<p>当然这样写就相对繁琐了。</p>
<h2 id="性能和建议">性能和建议</h2><p>CQL 最终还是转换成 <a href="./rest_api.html">REST API</a> 里查询部分提到的各种 where 条件，因为多了一层转换，理论上会比直接使用 <code>where</code> 查询慢一点。并且 CQL 对长度有所限制，要求在 4096 字节以内。</p>
<p>此外，我们推荐查询语句都采用占位符的方式，使用占位符的查询语句将有机会被缓存复用，避免重复解释的开销。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Cloud_Query_Language_详细指南">Cloud Query Language 详细指南</h1><p>Cloud Query Language（简称 CQL） 是 LeanCloud 为查询 API 定制的一套类似 SQL 查询语法的子集和变种，]]>
    </summary>
    
      <category term="leancloud" scheme="http://yoursite.com/tags/leancloud/"/>
    
      <category term="leancloud" scheme="http://yoursite.com/categories/leancloud/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[下载 Android SDK]]></title>
    <link href="http://yoursite.com/2015/12/30/avos/android_start/"/>
    <id>http://yoursite.com/2015/12/30/avos/android_start/</id>
    <published>2015-12-29T23:56:29.000Z</published>
    <updated>2015-12-18T10:22:30.479Z</updated>
    <content type="html"><![CDATA[<p><a id="link" class="btn btn-default" href="sdk_down.html">下载 Android SDK</a></p>

<p>下载 SDK，将下载后的文件解压缩后的所有 jar 文件放入 Android 项目的 <strong>libs</strong> 目录。如果你们的项目没有 <b>libs</b> 目录，那么就在项目的根目录下创建一个，通过右键点击项目 Project，选择 <strong>New</strong>，接下来点击 <strong>Folder</strong> 菜单即可创建新目录。</p>
<p>添加下列 <code>import</code> 语句到你的 Application 或主 Activity 类：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">import</span> <span class="tag">com</span><span class="class">.avos</span><span class="class">.avoscloud</span><span class="class">.AVOSCloud</span>;</span><br><span class="line"><span class="tag">import</span> <span class="tag">com</span><span class="class">.avos</span><span class="class">.avoscloud</span><span class="class">.AVAnalytics</span>;</span><br></pre></td></tr></table></figure>
<p>在 Application 的 <code>onCreate</code> 方法调用 <code>AVOSCloud.initialize</code> 来设置您应用的 Application ID 和 Key：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果使用美国节点，请加上这行代码 AVOSCloud.useAVCloudUS();</span></span><br><span class="line">    AVOSCloud.initialize(<span class="keyword">this</span>, <span class="string">"&#123;&#123;appid&#125;&#125;"</span>, <span class="string">"&#123;&#123;appkey&#125;&#125;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建应用后，可以在 <a href="/app.html?appid=#/key">控制台 - 应用设置</a> 里面找到应用对应的 id 和 key。</p>
<p>同时，你的应用需要请求 <code>INTERNET</code> 和 <code>ACCESS_NETWORK_STATE</code> 权限，如果没有设置，请添加下列两行到你的 <code>AndroidManifest.xml</code> 文件里的 <code>&lt;application&gt;</code> 标签前：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:<span class="property">name</span>=<span class="string">"android.permission.INTERNET"</span> /&gt;</span><br><span class="line">&lt;uses-permission android:<span class="property">name</span>=<span class="string">"android.permission.ACCESS_NETWORK_STATE"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>如果你想跟踪统计应用的打开情况，添加下列代码到你的主 <code>Activity</code> 的 <code>onCreate</code> 方法：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">AVAnalytics</span><span class="class">.trackAppOpened</span>(<span class="tag">getIntent</span>());</span><br></pre></td></tr></table></figure>
<p>接下来可以尝试测试一段代码，拷贝下列代码到你的 app 里，比如放到 <code>Application.onCreate</code> 方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AVObject <span class="built_in">test</span>Object = new AVObject(<span class="string">"TestObject"</span>);</span><br><span class="line"><span class="built_in">test</span>Object.put(<span class="string">"foo"</span>, <span class="string">"bar"</span>);</span><br><span class="line"><span class="built_in">test</span>Object.saveInBackground();</span><br></pre></td></tr></table></figure>
<p>运行你的 app。一个类 <code>TestObject</code> 的新对象将被发送到 LeanCloud 并保存下来。当你做完这一切，访问 <a href="/data.html?appid=#/TestObject">控制台 - 数据管理</a> 可以看到上面创建的 <code>TestObject</code> 的相关数据。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a id="link" class="btn btn-default" href="sdk_down.html">下载 Android SDK</a></p>

<p>下载 SDK，将下载后的文件解压缩后的所有 jar 文件放入 Android 项目的 <strong>l]]>
    </summary>
    
      <category term="leancloud" scheme="http://yoursite.com/tags/leancloud/"/>
    
      <category term="leancloud" scheme="http://yoursite.com/categories/leancloud/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 统计 SDK 开发指南]]></title>
    <link href="http://yoursite.com/2015/12/30/avos/android_statistics/"/>
    <id>http://yoursite.com/2015/12/30/avos/android_statistics/</id>
    <published>2015-12-29T23:56:29.000Z</published>
    <updated>2015-12-18T10:22:27.806Z</updated>
    <content type="html"><![CDATA[<h1 id="Android_统计_SDK_开发指南">Android 统计 SDK 开发指南</h1><h2 id="安装与初始化">安装与初始化</h2><p>首先在 <a href="https://leancloud.cn/applist.html#/apps" target="_blank" rel="external">控制台</a> 上创建新的应用，然后 <a href="sdk_down.html">下载 LeanCloud Android SDK</a> 以及相应的 Demo。</p>
<h3 id="导入_SDK">导入 SDK</h3><p>除了必须的 avoscloud.jar 外，你还需要额外的导入 avosstatistics.jar。<br>请将下载的 jar 包放到 libs 目录下，以便你的 IDE（Eclipse 或者 Intellij IDEA 等)可以正常识别导入的 jar 包。如以下图片所示：</p>
<p><img src="images/android_statistics_ide.png" alt="image"></p>
<h3 id="配置_AndroidManifest-xml_文件">配置 AndroidManifest.xml 文件</h3><p>请务必确保你的应用拥有如下权限：</p>
<ul>
<li><code>android.permission.INTERNET</code><br><br>向 LeanCloud 的统计服务器发送用户分析数据。</li>
<li><code>android.permission.READ_PHONE_STATE</code><br><br><code>android.permission.ACCESS_WIFI_STATE</code><br><br>这两个权限是为了获取用户手机的 IMEI 以及 WiFi 的 Mac 地址，用来唯一的标识用户。</li>
<li><code>android.permission.ACCESS_NETWORK_STATE</code><br><br>检测网络状态。</li>
<li><code>android.permission.READ_LOGS</code><br><br>获取客户端 crash log。通过将 crash log 汇报到服务器上，你可以了解你的应用 crash 的原因以及次数。</li>
<li><code>android.permission.WRITE_EXTERNAL_STORAGE</code><br><br>保存离线报告的缓存数据。</li>
</ul>
<p>示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">manifest</span> <span class="attribute">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">application</span> <span class="attribute">...</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="title">activity</span> <span class="attribute">...</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">application</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.WRITE_EXTERNAL_STORAGE"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.INTERNET"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.ACCESS_NETWORK_STATE"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.READ_PHONE_STATE"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.ACCESS_WIFI_STATE"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.READ_LOGS"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果你想指定你的发布渠道，请在 AndroidManifest.xml 中加入如下内容：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">application</span>  <span class="attribute">...</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="title">meta-data</span> <span class="attribute">android:name</span>=<span class="value">"Channel ID"</span> <span class="attribute">android:value</span>=<span class="value">"LeanCloud"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">application</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>你可以根据你的实际发布渠道，修改上述的 android:value 中对应的值，比如将 <code>LeanCloud</code> 改为 <code>Your Channel</code>，重新打包后发布。<strong>请不要修改 <code>android:name=&quot;Channel ID&quot;</code> 字段，以免影响使用。</strong></p>
<p>由于很多用户反映在部分第三方发布平台中间，不允许出现 meta-data 中间的 key 出现空格字符，我们在 2.6.8 以后，增加了一个等效的 key：<code>leancloud</code>。<br>以下代码也可以用于指定渠道了，但是请不要反复定义。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">application</span>  <span class="attribute">...</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="title">meta-data</span> <span class="attribute">android:name</span>=<span class="value">"leancloud"</span> <span class="attribute">android:value</span>=<span class="value">"LeanCloud"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">application</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当然你也可以通过代码来指定发布渠道。但是代码设置的渠道优先级没有 <code>AndroidManifest.xml</code> 中的配置高，同时出现时优先取 <code>AndroidManifest.xml</code> 中的配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">AVAnalytics.setAppChannel(<span class="string">"SomeChannel"</span>);</span><br><span class="line"><span class="comment">// 参数依次是 context, appId, appKey</span></span><br><span class="line">AVOSCloud.initialize(getContext(),<span class="string">"&#123;&#123;appid&#125;&#125;"</span>,<span class="string">"&#123;&#123;appKey&#125;&#125;"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="添加使用代码">添加使用代码</h2><h3 id="添加引用">添加引用</h3><p>经过我们的一系列更新升级，使用最新的 SDK 你不需要任何代码上的操作就可以使用统计的基本功能，统计功能为默认打开。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.avos.avoscloud.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YourApp</span> <span class="keyword">extends</span> <span class="title">Application</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        AVOSCloud.initialize(<span class="keyword">this</span>, <span class="string">"&#123;&#123;appid&#125;&#125;"</span>, <span class="string">"&#123;&#123;appkey&#125;&#125;"</span>);</span><br><span class="line">        <span class="comment">//AVAnalytics.start(this);    已经不再需要这行代码了</span></span><br><span class="line">        AVAnalytics.enableCrashReport(<span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="统计页面路径">统计页面路径</h2><p>在需要的 Activity 中调用统计 SDK。在每个 Activity 的 <code>onResume</code> 和 <code>onPause</code> 方法中调用相应的统计方法，传入的参数为当前 context（比如当前的 Activity）的引用。 这里请不要将全局的 Application Context 传入。如示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onPause();</span><br><span class="line">    AVAnalytics.onPause(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume();</span><br><span class="line">    AVAnalytics.onResume(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请确保在所需要的所有的 Activity 中都调用 <code>AVAnalytics.onResume()</code> 和 <code>AVAnalytics.onPause()</code> 方法，这两个调用将不会阻塞应用程序的主线程，也不会影响应用程序的性能。</p>
<p>注意：如果你的 Activity 之间有继承或者控制关系请不要同时在父和子 Activity 中重复添加 onPause 和 onResume 方法，否则会造成重复统计，比如在使用 TabHost、TabActivity、ActivityGroup 时。一个应用程序在多个 Activity 之间连续切换时，将会被视为同一个 session（会话或者一次使用过程）。</p>
<p>当用户两次使用之间间隔超过 30 秒时，将被认为是两个的独立的 session，例如用户回到 home，或进入其他程序，经过一段时间后再返回之前的应用。我们也提供了新的接口来自定义这个时间间隔，你只要调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVAnalytics.setSessionContinueMillis(<span class="keyword">long</span> mills);</span><br></pre></td></tr></table></figure>
<p>传入适当的参数，就可以控制 session 重新启动时间，注意参数是以毫秒为单位的。 例如，如果你认为在 60 秒之内返回应用可视为同一次启动，超过 60 秒返回当前应用可视为一次新的启动，那么请写成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVAnalytics.setSessionContinueMillis(<span class="number">60</span> * <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<h2 id="统计_Fragment_页面">统计 Fragment 页面</h2><p>Android 3.0 引入了 Fragment。使用 Fragment，你可以在一个 Activity 中展示多个用户界面，也可根据你的需要，为不同的设备适配界面。LeanCloud SDK 1.4.2 开始增加了对于 Fragment 统计的支持。你可以使用以下代码统计 Fragment 页面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListFragment</span> <span class="keyword">extends</span> <span class="title">ListFragment</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttach</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onAttach(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">        AVAnalytics.onFragmentEnd(<span class="string">"my-list-fragment"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        AVAnalytics.onFragmentStart(<span class="string">"my-list-fragment"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试">测试</h2><ul>
<li>确认所需的权限都已经添加：<ul>
<li><code>INTERNET</code></li>
<li><code>READ_PHONE_STATE</code></li>
<li><code>READ_LOGS</code></li>
<li><code>WRITE_EXTERNAL_STORAGE</code></li>
</ul>
</li>
<li>确认所有的 Activity 中都调用了 onResume 和 onPause 方法。</li>
<li>确认测试手机（或者模拟器）已成功连入网络。</li>
<li>启动应用程序，几分钟之内你应该已经可以在 <a href="/stat.html?appid=}#/statrealtime">控制台 / 分析</a> 中的相应菜单中看到报表了。</li>
</ul>
<h2 id="数据时效性">数据时效性</h2><p>在控制台的 <strong>分析</strong> 页面中，有些报告可以展示实时数据，有些报告则依靠 <a href="leaninsight_guide.html">离线数据</a> 进行分析，因此有时你会看不到当天的数据。</p>
<p>如果当前页面中存在 <strong>日期选择</strong> 选项（通常在页面右上角），你可以以此判断当前的统计结果是否有延迟。如果 <strong>结束日期</strong> 显示为 <strong>当日日期</strong> 或在其下拉菜单中有「今日」选项，即为实时数据；反之则为离线数据（如下图所示），要推迟一天才能看到当日的情况。</p>
<p><img src="../images/analytics_datepicker_for_offline_data.png" alt="" width="231" height="256"></p>
<h2 id="使用自定义事件">使用自定义事件</h2><h3 id="基本简单事件">基本简单事件</h3><p>除了基本统计分析功能外，SDK 还支持你自定义的事件分析，例如你可以统计你的应用中有多少人点击了 like 按键，某个文章的点击次数或者视频被播放的次数等等。</p>
<p>在你希望发送事件报告的代码段，调用如下方法就可以向服务器发送事件记录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVAnalytics.onEvent(Context context, String eventName);</span><br></pre></td></tr></table></figure>
<p>统计 eventName 对应事件的发生次数、变化趋势，例如 like 点击、浏览数量等等。参数 context 为当前 context 的引用。eventName 为当前统计的事件 name。【注意】eventName 中不要加空格或其他的转义字符。</p>
<p>比如，应用中的一条微视频被转发的事件被定义为「Forward」，那么在点击转发的函数里调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVAnalytics.onEvent(<span class="keyword">this</span>, <span class="string">"Forward"</span>)</span><br></pre></td></tr></table></figure>
<p>就会向服务器汇报一个转发的事件。</p>
<h3 id="多标签事件">多标签事件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVAnalytics.onEvent(Context context, String eventName, String  tag);</span><br></pre></td></tr></table></figure>
<p>除了能够统计 eventName 所对应事件的发生次数，变化趋势外，还能统计事件中具体标签所占的比例。tag 为当前标签，同样这里的 eventName 字符串中也请不要使用空格。<br>比如，在玩拍程序中，我们定义了一个发布微视频的多标签事件 Publish，对应的发布内容有 title（发布标题）、Video（发视频）、type（视频类型）来对应不同的发布类型，这样我们不仅可以记录 Publish 事件的点击数量还可以看到不同内容对应的比例。</p>
<h3 id="事件累计">事件累计</h3><p>在应用程序中某些自定义事件可能会被频繁触发，例如用户点击某个按钮。开发者可以在程序中维护一个计数器，这样某个事件被多次触发但只需要生成一个消息，这个消息中包括该事件被触发的次数。为了支持这个功能，我们提供了重载的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AVAnalytics.onEvent(Context context, String eventName, <span class="keyword">int</span> count);</span><br><span class="line">AVAnalytics.onEvent(Context context, String eventName, String label, <span class="keyword">int</span> count)</span><br></pre></td></tr></table></figure>
<p>参数 count 是对应事件（和对应标签）被触发的次数。</p>
<h2 id="设置数据发送策略">设置数据发送策略</h2><p>你可以进入应用的 <a href="/stat.html?appid=&amp;os=android#/statconfig/trans_strategoy"><strong>分析</strong> &gt; <strong>统计设置</strong><span class="text-muted">（左下角）</span> &gt; <strong>数据发送策略</strong></a> 在线更改 SDK 端的数据报告发送策略。在没有取到在线配置的发送策略的情况下，会使用默认的发送策略。</p>
<p>以下均为在线配置中的可选策略。</p>
<h3 id="启动时发送">启动时发送</h3><p>【推荐使用】应用程序每次会在启动时会向服务器发送一次消息，在应用程序过程中产生的所有消息（包括自定义事件和本次使用时长）都会在下次启动时候发送。如果应用程序启动时处在不联网状态，那么消息将会缓存在本地，下次再尝试发送。</p>
<p>发送策略默认为启动时发送。</p>
<h3 id="批量发送">批量发送</h3><p>批量发送，默认当消息数量达到 30 条时发送一次。</p>
<h3 id="按最小间隔发送">按最小间隔发送</h3><p>间隔一段时间发送，每隔一段时间一次性发送到服务器。</p>
<h2 id="自定义参数设置">自定义参数设置</h2><p>你可以控制台某个应用的 <strong>组件</strong> &gt; <strong>自定义参数</strong> 设置中配置你的自定义在线参数。这些参数会在我们每次更新统计配置时进行更新，你可以用以下方法来获得对应的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVAnalytics.getConfigParams(<span class="keyword">this</span>.getContext(), <span class="string">"key"</span>)</span><br></pre></td></tr></table></figure>
<p>但是请注意三点：</p>
<ul>
<li>key 必须跟你在控制台配置的参数一致，大小写敏感。</li>
<li><p>由于统计参数更新时一个后台更新，你可能在直接调用 <code>AVAnalytics.getConfigParams(this.getContext(), &quot;key&quot;)</code> 时遇到返回值为 null 的情况。你可以通过设置 AVOnlineConfigureListener 和强制调用 updateOnlineConfig 来保证自定义配置的获取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AVAnalytics.setOnlineConfigureListener(<span class="keyword">new</span> AVOnlineConfigureListener() &#123;</span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataReceived</span><span class="params">(JSONObject data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       AVAnalytics.getConfigParams(getContext(), <span class="string">"key"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;);</span><br><span class="line">AVAnalytics.updateOnlineConfig(getContext());</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于统计参数在客户端会有定时更新的策略，所以 AVOnlineConfigureListener 在客户端会发生多次调用的情况，请在 OnDataReceived 方法中不要放入太多函数副作用。</p>
</li>
</ul>
<h2 id="开发选项">开发选项</h2><p>如果你不准备区分开发 AppKey 与生产环境 AppKey，但是又不想开发时期的统计数据会影响产品上线后的统计数据，你可以使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AVAnalytics.setAnalyticsEnabled(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 参数依次为 context, AppId, AppKey</span></span><br><span class="line">AVOSCloud.initialize(context,&#123;&#123;appid&#125;&#125;,&#123;&#123;appkey&#125;&#125;);</span><br></pre></td></tr></table></figure>
<p>在开发阶段关闭统计的功能。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Android_统计_SDK_开发指南">Android 统计 SDK 开发指南</h1><h2 id="安装与初始化">安装与初始化</h2><p>首先在 <a href="https://leancloud.cn/applist.html#/apps" tar]]>
    </summary>
    
      <category term="leancloud" scheme="http://yoursite.com/tags/leancloud/"/>
    
      <category term="leancloud" scheme="http://yoursite.com/categories/leancloud/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android SDK 常见问题及解答]]></title>
    <link href="http://yoursite.com/2015/12/30/avos/android_faq/"/>
    <id>http://yoursite.com/2015/12/30/avos/android_faq/</id>
    <published>2015-12-29T23:56:29.000Z</published>
    <updated>2015-12-18T10:21:50.943Z</updated>
    <content type="html"><![CDATA[<h1 id="Android_SDK_常见问题及解答">Android SDK 常见问题及解答</h1><h2 id="代码混淆怎么做">代码混淆怎么做</h2><p>为了保证 SDK 在代码混淆后能正常运作，需要保证部分类和第三方库不被混淆，参考下列配置：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"># proguard.cfg</span><br><span class="line"></span><br><span class="line">-<span class="ruby">keepattributes <span class="constant">Signature</span></span><br><span class="line"></span>-<span class="ruby">dontwarn com.jcraft.jzlib.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">jcraft</span>.<span class="title">jzlib</span>.**  &#123; *;</span>&#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn sun.misc.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">sun</span>.<span class="title">misc</span>.** &#123; *;</span>&#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn com.alibaba.fastjson.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">alibaba</span>.<span class="title">fastjson</span>.** &#123; *;</span>&#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn sun.security.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">sun</span>.<span class="title">security</span>.** &#123; *;</span> &#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn com.google.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">google</span>.** &#123; *;</span>&#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn com.avos.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">avos</span>.** &#123; *;</span>&#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">keep public <span class="class"><span class="keyword">class</span> <span class="title">android</span>.<span class="title">net</span>.<span class="title">http</span>.<span class="title">SslError</span></span></span><br><span class="line"></span>-<span class="ruby">keep public <span class="class"><span class="keyword">class</span> <span class="title">android</span>.<span class="title">webkit</span>.<span class="title">WebViewClient</span></span></span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn android.webkit.<span class="constant">WebView</span></span><br><span class="line"></span>-<span class="ruby">dontwarn android.net.http.<span class="constant">SslError</span></span><br><span class="line"></span>-<span class="ruby">dontwarn android.webkit.<span class="constant">WebViewClient</span></span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn android.support.**</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn org.apache.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">apache</span>.** &#123; *;</span>&#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn org.jivesoftware.smack.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">jivesoftware</span>.<span class="title">smack</span>.** &#123; *;</span>&#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn com.loopj.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">loopj</span>.** &#123; *;</span>&#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn com.squareup.okhttp.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">squareup</span>.<span class="title">okhttp</span>.** &#123; *;</span>&#125;</span><br><span class="line"></span>-<span class="ruby">keep interface com.squareup.okhttp.** &#123; *; &#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn okio.**</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn org.xbill.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">xbill</span>.** &#123; *;</span>&#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">keepattributes *<span class="constant">Annotation</span>*</span></span><br></pre></td></tr></table></figure>
<h2 id="使用美国节点时_SDK_报错：create_SSL_socket_factory_失败">使用美国节点时 SDK 报错：<code>create SSL socket factory</code> 失败</h2><p>在使用美国节点的时候，SDK 初始化时即报错，显示 <code>create SSL socket factory</code> 失败。怎么办？</p>
<p>这是因为 LeanCloud 的 SSL 证书不在工程资源里面导致的，解决办法如下：</p>
<p>请下载 <a href="https://download.leancloud.cn/sdk/android/current/avoscloud_us_ssl.bks" target="_blank" rel="external">SSL 证书</a>，并拷贝到你项目的 <code>res/raw/</code> 目录下，重新打包即可。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Android_SDK_常见问题及解答">Android SDK 常见问题及解答</h1><h2 id="代码混淆怎么做">代码混淆怎么做</h2><p>为了保证 SDK 在代码混淆后能正常运作，需要保证部分类和第三方库不被混淆，参考下列配置：</p>
<figu]]>
    </summary>
    
      <category term="leancloud" scheme="http://yoursite.com/tags/leancloud/"/>
    
      <category term="leancloud" scheme="http://yoursite.com/categories/leancloud/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[01Getting Started-基本设置]]></title>
    <link href="http://yoursite.com/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/01Getting%20Started/Basic%20Setup/"/>
    <id>http://yoursite.com/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/01Getting Started/Basic Setup/</id>
    <published>2015-12-26T15:00:00.000Z</published>
    <updated>2015-12-17T11:15:08.815Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>翻译：<a href="https://github.com/Creolophus" target="_blank" rel="external">Creolophus</a></p>
<p>校正：<a href="https://github.com/Evilcome" target="_blank" rel="external">Evilcome</a> <a href="https://github.com/dabing1022" target="_blank" rel="external">ChildhoodAndy</a></p>
</blockquote>
<h1 id="基本设置">基本设置</h1><hr>
<p>本页包含内容：</p>
<ul>
<li><a href="#setting_up_your_swift_environment">建立你的 Swift 环境</a></li>
<li><a href="#understanding_the_swift_import_process">理解 Swift 导入过程</a></li>
</ul>
<blockquote>
<p>重要事项</p>
<p>这是一个正在研发的API或技术的概要文件，苹果公司提供这些信息主要是为了帮助你通过苹果产品使用这些技术或者编程接口而做好计划，该信息有可能会在未来发生改变，本文当中提到的软件应该以最终发布的操作系统测试和最终文档为准，未来有可能会提供新版本的文档信息。</p>
</blockquote>
<p>Swift 被设计用来无缝兼容 Cocoa 和 Objective-C 。在 Swift 中，你可以使用 Objective-C 的 API（包括系统框架和你自定义的代码），你也可以在 Objective-C中 使用 Swift 的 API。这种兼容性使 Swift 变成了一个简单、方便并且强大的工具集成到你的 Cocoa 应用开发工作流程中。</p>
<p>这篇指南包括了三个有关兼容性的重要方面方便你更好地利用来开发 Cocoa 应用：</p>
<ul>
<li><strong>互用性</strong> 使你将 Swift 和 Objective-C 相接合，允许在 Objective-C 中使用 Swift 的 Class 并且当你在写 Swift 代码时利用熟悉的 Cocoa Class、Pattern、Practice。</li>
<li><strong>混合和匹配</strong> 允许你创建结合了 Swift 和 Objective-C 文件的混合语言应用，他们能跟彼此进行通信。</li>
<li><strong>迁移</strong> 由于以上两点，从已经存在的 Objective-C 代码迁移到 Swift 是非常简单的，使得用最新的 Swift 特性代替你的 Objective-C 应用部分内容成为了可能。</li>
</ul>
<p>在你开始学习这些特性前，你需要对如何建立 Swift 环境来访问 Cocoa 系统框架有个大体了解。</p>
<p><a name="setting_up_your_swift_environment"></a></p>
<p>##建立你的 Swift 环境</p>
<p>为了开始体验在 Swift 中访问 Cocoa 框架，使用 Xcode 的一个模板来创建一个基于 Swift 应用。</p>
<p>###在 Xcode 中创建一个 Swift 项目</p>
<p>1.选择 File &gt; New &gt; Project &gt; (iOS or OS X) &gt; Application &gt; your <em>template of choice</em>。</p>
<p>2.点击 Language 弹出菜单并选择 Swift。</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/Art/newproject_2x.png" alt="image"></p>
<p>Swift 项目的结构几乎和 Objective-C 项目一模一样，只有一个重要的区别：Swift 没有头文件。在实现和接口之间没有显示的划分，所以一个特定类中的所有信息都存储在单独的<code>.swift</code>文件中。</p>
<p>现在开始，你可以开始体验在<code>app delegate</code>中写 Swift 代码，或者你可以通过选择 File &gt; New &gt; File &gt; (iOS or OS X) &gt; Other &gt; Swift来创建一个 Swift 类。</p>
<p><a name="understanding_the_swift_import_process"></a></p>
<p>##理解 Swift 导入过程</p>
<p>在你建立 Xcode 项目后，你可以在 Swift 里导入任意用 Objective-C 来工作的 Cocoa 平台框架。</p>
<p>任意 Objective-C 的框架（或 C 类库）将作为一个<em>module</em>，能直接导入到 Swift 中。这些包括了所有 Objective-C 系统框架-比如 Foundation、UIKit 和 SpriteKit，就像系统支持公共 C 类库。举个例子，想导入 Foundation，只要简单地添加 import 语句到你写的 Swift 文件的顶部。</p>
<blockquote>
<p>SWIFT</p>
<p><code>import Foundation</code></p>
</blockquote>
<p>这个 import 导入了所有 Foundation 的 API，包括<code>NSDate</code>，<code>NSURL</code>，<code>NSMutableData</code>，并且他们的所有方法、属性和类别都可以在 Swift 中直接使用。</p>
<p>导入过程是非常简洁的。Objective-C 框架在头文件中申明 API。在 Swift 中，那些头文件被编译成 Objective-C 的 module，接着被导入到 Swift 作为 Swift 的 API。导入决定了 Objective-C 的 Function，Class，Method 和 Type 如何在 Swift 中出现。对于 Function 和 Method，这个过程影响他们的参数和返回值。导入过程可以做下面这些事情：</p>
<ul>
<li>重映射确定的 Objective-C 类型到 Swift 中的同等类型，就像 id 到<code>AnyObject</code></li>
<li>重映射确定的 Objective-C 核心类型到 Swift 中的替代类型， 就像<code>NSString</code>到<code>String</code></li>
<li>重映射确定的 Objective-C 概念到 Swift 中相匹配的概念，如<code>pointers</code>到<code>optionals</code></li>
</ul>
<p>在互用性章节，你将会了解到更多关于这些映射如何在你的 Swift 代码进行取舍。<br>导入 Swift 的模型到 Objective-C 和从 Objective-C 导入 Swift 是非常相似的。Swift 申明它的 API，比如一个框架作为 Swift modules。同时这些 Swift modules 会生成 Objective-C 的头文件。这些头文件可以映射回 Objective-C 的 API 中。一些 Swift 的 API 不映射回 Objective-C 因为他们取舍了语言特性发现这些在 Objective-C 中不可用。关于在 Objective-C 中使用 Swift 的更多特性，请参看<a href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/03Mix%20and%20Match/Swift%20and%20Objective-C%20in%20the%20Same%20Project/">在同一项目中使用 Swift 和 Objective-C</a>。</p>
<blockquote>
<p>注意</p>
<p>你不能直接把 C++ 代码导入 Swift。解决办法是为 C++ 代码创建一个 Objective-C 或者 C 的封装。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>翻译：<a href="https://github.com/Creolophus" target="_blank" rel="external">Creolophus</a></p>
<p>校正：<a href="https://github.c]]>
    </summary>
    
      <category term="Using Swift with Cocoa and Objective-C" scheme="http://yoursite.com/tags/Using-Swift-with-Cocoa-and-Objective-C/"/>
    
      <category term="Using-Swift-with-Cocoa-and-Objective-C" scheme="http://yoursite.com/categories/Using-Swift-with-Cocoa-and-Objective-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[02Interoperability-01与 Objective-C 的 API 交互]]></title>
    <link href="http://yoursite.com/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/01Interacting%20with%20Objective-C%20APIs/"/>
    <id>http://yoursite.com/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/01Interacting with Objective-C APIs/</id>
    <published>2015-12-26T14:00:10.000Z</published>
    <updated>2015-12-17T11:11:15.941Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>翻译：<a href="https://github.com/Creolophus" target="_blank" rel="external">Creolophus</a></p>
<p>校正：<a href="https://github.com/Evilcome" target="_blank" rel="external">Evilcome</a> <a href="https://github.com/dabing1022" target="_blank" rel="external">ChildhoodAndy</a></p>
</blockquote>
<p>#与 Objective-C 的 API 交互</p>
<hr>
<p>本页包含内容：</p>
<ul>
<li><a href="#initialization">初始化</a></li>
<li><a href="#failable_initialization">可失败初始化</a></li>
<li><a href="#accessing_properties">访问属性</a></li>
<li><a href="#working_with_methods">方法</a></li>
<li><a href="#id_compatibility">id 兼容性（id Compatibility）</a></li>
<li><a href="#Nullability_and_Optionals">空值和可选值</a></li>
<li><a href="#extensions">扩展（Extensions）</a></li>
<li><a href="#closures">闭包（Closures）</a></li>
<li><a href="#object_comparison">比较对象</a></li>
<li><a href="#swift_type_compatibility">Swift 类型兼容性</a></li>
<li><a href="#Requiring_Dynamic_Dispatch">动态分发</a></li>
<li><a href="#Lightweight_Generics">轻量级泛型</a></li>
<li><a href="#objective_c_selectors">Objective-C 选择器（Selectors）</a></li>
</ul>
<p><strong>互用性</strong>是让 Swift 和 Objective-C 相接合的一种特性，使你能够在一种语言编写的文件中使用另一种语言。当你准备开始把 Swift 融入到你的开发流程中时，你应该懂得如何利用互用性来重新定义并提高你写 Cocoa 应用的方案。</p>
<p>互用性很重要的一点就是允许你在写 Swift 代码时使用 Objective-C 的 API 接口。当你导入一个 Objective-C 框架后，你可以使用原生的 Swift 语法实例化它的 Class 并且与之交互。</p>
<p><a name="initialization"></a></p>
<p>##初始化</p>
<p>为了使用 Swift 实例化 Objective-C 的 Class，你应该使用 Swift 语法调用它的一个初始化器。当 Objective-C 的<code>init</code>方法变化到 Swift，他们用 Swift 初始化语法呈现。“init”前缀被截断当作一个关键字，用来表明该方法是初始化方法。那些以“initWith”开头的<code>init</code>方法，“With”也会被去除。从“init”或者“initWith”中分离出来的这部分方法名首字母变成小写，并且被当做是第一个参数的参数名。其余的每一部分方法名依次变为参数名。这些方法名都在圆括号中被调用。</p>
<p>举个例子，你在使用 Objective-C 时会这样做：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UITableView *myTableView = [[UITableView alloc] &#10;initWithFrame:CGRectZero style:UITableViewStyleGrouped];</span><br></pre></td></tr></table></figure>
<p>在 Swift 中，你应该这样做：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myTableView: <span class="type">UITableView</span> = <span class="type">UITableView</span>(frame: <span class="type">CGRectZero</span>, style: .<span class="type">Grouped</span>)</span><br></pre></td></tr></table></figure>
<p>你不需要调用<code>alloc</code>，Swift 能够正确的为你处理。注意，当使用 Swift 风格的初始化函数的时候，“init”不会出现。</p>
<p>你可以在初始化时显式的声明对象的类型，也可以忽略它，Swift 能够正确判断对象的类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myTextField = <span class="type">UITextField</span>(frame: <span class="type">CGRect</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">200.0</span>, <span class="number">40.0</span>))</span><br></pre></td></tr></table></figure>
<p>这里的<code>UITableView</code>和<code>UITextField</code>对象和你在 Objective-C 中使用的具有相同的功能。你可以用一样的方式使用他们，包括访问属性或者调用各自的类中的方法。</p>
<p>为了统一和简易，Objective-C 的工厂方法也在 Swift 中映射为方便的初始化方法。这种映射能够让他们使用同样简洁明了的初始化方法。例如，在 Objective-C 中你可能会像下面这样调用一个工厂方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIColor *color = [UIColor colorWithRed:0.5 green:0.0 blue:0.5 alpha:1.0];</span><br></pre></td></tr></table></figure>
<p>在 Swift 中，你应该这样做：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> color = <span class="type">UIColor</span>(red: <span class="number">0.5</span>, green: <span class="number">0.0</span>, blue: <span class="number">0.5</span>, alpha: <span class="number">1.0</span>)</span><br></pre></td></tr></table></figure>
<p><a name="failable_initialization"></a></p>
<p>##可失败初始化</p>
<p>在 Objective-C 中，构造器会直接返回他们初始化的对象。为了通知调用者初始化失败，Objective-C 构造器会返回<code>nil</code>。在 Swift 中，这种模式被内置到语言特性中，被称为<em>可失败初始化</em>。在 iOS 和 OSX 系统框架中许多 Objective-C 构造器会被检查是否会初始化失败。如果初始化不会失败，这些 Objective-C 构造器便会以<code>init(...)</code>被导入，如果初始化可能会失败，则会以<code>init?(...)</code>被导入。在我们自己的 Objective-C 类以及未被检查的框架类中，构造器会以<code>init!(...)</code>被导入。例如，当图片文件在指定路径中不存在时，<code>UIImage(contentsOfFile:)</code>构造器初始化<code>UIImage</code>对象便会失败。如果初始化成功，我们可以用可选值绑定来对可失败初始化的结果进行解包。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> image = <span class="type">UIImage</span>(contentsOfFile: <span class="string">"MyImage.png"</span>) &#123;</span><br><span class="line">    <span class="comment">// loaded the image successfully</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// could not load the image</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="accessing_properties"></a></p>
<p>##访问属性</p>
<p>在 Swift 中访问和设置 Objective-C 对象的属性时，使用点语法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myTextField.textColor = <span class="type">UIColor</span>.darkGrayColor()</span><br><span class="line">myTextField.text = <span class="string">"Hello world"</span></span><br></pre></td></tr></table></figure>
<p>当 get 或 set 属性时，直接使用属性名称，不需要附加圆括号。注意，<code>darkGrayColor</code>后面附加了一对圆括号，这是因为<code>darkGrayColor</code>是<code>UIColor</code>的一个类方法，不是一个属性。</p>
<p>在 Objective-C 中，一个有返回值的无参数方法可以被作为一个隐式的访问函数，并且可以与访问器使用同样的方法调用。但在 Swift 中不再能够这样做了，只有在 Objective-C 中 使用<code>@property</code>关键字声明的属性才会被作为属性引入。方法被导入和调用见<a href="#working_with_methods">方法</a>描述。</p>
<p><a name="working_with_methods"></a></p>
<p>##方法</p>
<p>在 Swift 中调用 Objective-C 方法时，使用点语法。</p>
<p>当 Objective-C 方法转换到 Swift 时，Objective-C 的<code>selector</code>的第一部分将会成为方法名并出现在圆括号的前面，而第一个参数将直接在括号中出现，并且没有参数名，而剩下的参数名与参数则一一对应的填入圆括号中。选择器的所有部分在调用时都是必需的。</p>
<p>举个例子，你在使用 Objective-C 时会这样做：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[myTableView insertSubview:mySubview atIndex:2];</span><br></pre></td></tr></table></figure>
<p>在 Swift 中，你应该这样做：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myTableView.insertSubview(mySubview, atIndex: <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>如果你调用一个无参方法，仍必须在方法名后面加上一对圆括号</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myTableView.layoutIfNeeded()</span><br></pre></td></tr></table></figure>
<p><a name="id_compatibility"></a></p>
<p>##id 兼容性（id Compatibility）</p>
<p>Swift 包含一个叫做<code>AnyObject</code>的协议类型，表示任意类型的对象，就像 Objective-C 中的<code>id</code>一样。<code>AnyObject</code>协议允许你编写类型安全的 Swift 代码同时维持无类型对象的灵活性。因为<code>AnyObject</code>协议保证了这种安全，Swift 将<code>id</code>对象导入为<code>AnyObject</code>。</p>
<p>举个例子，跟<code>id</code>一样，你可以为<code>AnyObject</code>类型的对象分配任何其它类型的对象，你也同样可以为它重新分配其它类型的对象。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject: <span class="type">AnyObject</span> = <span class="type">UITableViewCell</span>()</span><br><span class="line">myObject = <span class="type">NSDate</span>()</span><br></pre></td></tr></table></figure>
<p>你也可以在调用 Objective-C 方法或者访问属性时不将它转换为具体类的类型。这包括了 Objective-C 中标记为<code>@objc</code>的方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> futureDate = myObject.dateByAddingTimeInterval(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">let</span> timeSinceNow = myObject.timeIntervalSinceNow</span><br></pre></td></tr></table></figure>
<p>然而，由于直到运行时才知道<code>AnyObject</code>的对象类型，所以有可能在不经意间写出不安全代码。另外，与 Objective-C 不同的是，如果你调的用方法或者访问的属性<code>AnyObject</code>对象没有声明，将会报运行时错误。比如下面的代码在运行时将会报出一个<code>unrecognized selector error</code>错误：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myObject.characterAtIndex(<span class="number">5</span>)</span><br><span class="line"><span class="comment">// crash, myObject does't respond to that method</span></span><br></pre></td></tr></table></figure>
<p>但是，你可以通过 Swift 的可选值特性来排除这个 Objective-C 中常见的错误，当你用<code>AnyObject</code>对象调用一个 Objective-C 方法时，这次调用将会变成一次隐式展开可选值的行为。你可以通过可选值特性来决定<code>AnyObject</code>类型的对象是否调用该方法，同样的，你可以把这种特性应用在属性上。</p>
<blockquote>
<p>注</p>
<p>通过<code>AnyObject</code>访问的属性永远返回一个可选值。</p>
</blockquote>
<p>举个例子，在下面的代码中，第一和第二行代码将不会被执行因为<code>length</code>属性和<code>characterAtIndex:</code>方法不存在于 NSDate 对象中。<code>myLength</code>常量会被推测成可选的<code>Int</code>类型并且被赋值为<code>nil</code>。同样你可以使用<code>if-let</code>声明来有条件的展开这个方法的返回值，从而判断对象是否能执行这个方法。就像第三行做的一样。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myLength = myObject.length?</span><br><span class="line"><span class="keyword">let</span> myChar = myObject.characterAtIndex?(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> fifthCharacter = myObject.characterAtIndex(<span class="number">5</span>) &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"Found <span class="subst">\(fifthCharacter)</span> at index 5"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 Swift 中的强制类型转换，从<code>AnyObject</code>类型的对象转换成明确的类型并不会保证成功，所以它会返回一个可选的值。而你需通过检查该值的类型来确认转换是否成功。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="keyword">let</span> userDefaults = <span class="type">NSUserDefaults</span>.standardUserDefaults()</span><br><span class="line"><span class="keyword">let</span> lastRefreshDate: <span class="type">AnyObject</span>? = userDefaults.objectForKey(<span class="string">"LastRefreshDate"</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> date = lastRefreshDate <span class="keyword">as</span>? <span class="type">NSDate</span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"<span class="subst">\(date.timeIntervalSinceReferenceDate)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，如果你能确定这个对象的类型（并且确定不是<code>nil</code>），你可以添加<code>as</code>操作符强制调用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myDate = lastRefreshDate <span class="keyword">as</span> <span class="type">NSDate</span></span><br><span class="line"><span class="keyword">let</span> timeInterval = myDate.timeIntervalSinceReferenceDate</span><br></pre></td></tr></table></figure>
<p><a name="Nullability_and_Optionals"></a></p>
<h2 id="空值和可选值">空值和可选值</h2><p>在 Objective-C 中，对象的引用可以是值为<code>NULL</code>的原始指针（在 Objective-C 中的简称为<code>nil</code>）。而在Swift中，所有的值–包括结构体与对象的引用–都被保证为非空。作为替代，你将这个可以为空的值包装为optional type。当你需要宣告值为空时，你需要使用<code>nil</code>。你可以在<a href="https://github.com/CocoaChina-editors/Welcome-to-Swift/blob/master/The%20Swift%20Programming%20Language/02Language%20Guide/01The%20Basics.md#optionals" target="_blank" rel="external">Optionals</a>中了解更多。</p>
<p>Objective-C 能够使用空值标记来设定一个参数类型，属性类型或者返回值类型是否可以为 NULL 或者 为 nil 值。单独的类型声明可以使用<code>__nullable</code>和<code>__nonnull</code>标注，空值的范围性的声明可以使用<code>NS_ASSUME_NONNULL_BEGIN</code>和<code>NS_ASSUME_NONNULL_END</code>宏。如果一个类型没有任何的空值标注信息，Swift 就不能分辨出可选值和非可选值类型，并且将作为隐式的解包可选值导入。</p>
<ul>
<li>以<code>__nonnull</code>或者范围宏标注声明的空值类型，被作为非空可选值<code>non-optional</code>导入到 Swift。</li>
<li>以<code>__nullable</code>标注声明的空值类型，被作为可选值导入到 Swift。</li>
<li>没有以空值标注声明的类型被作为隐式的解包可选值导入到 Swift。</li>
</ul>
<p>例如，考虑如下的 Objective-C 声明：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nullable) id  nullableProperty;&#10;@property (nonnull) id nonNullProperty;&#10;@property id unannotatedProperty;&#10; &#10;NS_ASSUME_NONNULL_BEGIN&#10;- (id)returnsNonNullValue;&#10;- (void)takesNonNullParameter:(id)value;&#10;NS_ASSUME_NONNULL_END&#10; &#10;- (nullable id)returnsNullableValue;&#10;- (void)takesNullableParameter:(nullable id)value;&#10; &#10;- (id)returnsUnannotatedValue;&#10;- (void)takesUnannotatedParameter:(id)value;</span><br></pre></td></tr></table></figure>
<p>下面是他们如何被导入 Swift 中的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nullableProperty: <span class="type">AnyObject</span>?</span><br><span class="line"><span class="keyword">var</span> nonNullProperty: <span class="type">AnyObject</span></span><br><span class="line"><span class="keyword">var</span> unannotatedProperty: <span class="type">AnyObject</span>!</span><br><span class="line"> </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">returnsNonNullValue</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesNonNullParameter</span><span class="params">(value: AnyObject)</span></span></span><br><span class="line"> </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">returnsNullableValue</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span>?</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesNullableParameter</span><span class="params">(value: AnyObject?)</span></span></span><br><span class="line"> </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">returnsUnannotatedValue</span><span class="params">()</span></span> -&gt; <span class="type">AnyObject</span>!</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesUnannotatedParameter</span><span class="params">(value: AnyObject!)</span></span></span><br></pre></td></tr></table></figure>
<p>大多数 Objective-C 的系统框架，包括 Foundation，都已经提供了可空的注解，允许你使用惯用和类型安全的方式与值打交道。</p>
<p><a name="extensions"></a></p>
<p>##扩展（Extensions）</p>
<p>Swift 的扩展和 Objective-C 的类别（Category）相似。扩展为原有的类，结构和枚举丰富了功能，包括在 Objective-C 中定义过的。你可以为系统的框架或者你自己的类型增加扩展，只需要导入合适的模块并且保证你在 Objective-C 中使用的类、结构或枚举拥有相同的名字。</p>
<p>举个例子，你可以扩展<code>UIBezierPath</code>类来为它增加一个等边三角形，这个方法只需提供三角形的边长与起点。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIBezierPath</span> </span>&#123;</span><br><span class="line">    convenience <span class="keyword">init</span>(triangleSideLength: <span class="type">Float</span>, origin: <span class="type">CGPoint</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">let</span> squareRoot = <span class="type">Float</span>(sqrt(<span class="number">3</span>))</span><br><span class="line">        <span class="keyword">let</span> altitude = (squareRoot * triangleSideLength) / <span class="number">2</span></span><br><span class="line">        moveToPoint(origin)</span><br><span class="line">        addLineToPoint(<span class="type">CGPoint</span>(triangleSideLength, origin.x))</span><br><span class="line">        addLineToPoint(<span class="type">CGPoint</span>(triangleSideLength / <span class="number">2</span>, altitude))</span><br><span class="line">        closePath()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以使用扩展来增加属性（包括类的属性与静态属性）。然而，这些属性必须是通过计算才能获取的，扩展不会为类，结构体，枚举添加存储属性。下面这个例子为<code>CGRect</code>类增加了一个叫<code>area</code>的属性。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CGRect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">CGFloat</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> width * height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> rect = <span class="type">CGRect</span>(x: <span class="number">0.0</span>, y: <span class="number">0.0</span>, width: <span class="number">10.0</span>, height: <span class="number">50.0</span>)</span><br><span class="line"><span class="keyword">let</span> area = rect.area</span><br><span class="line"><span class="comment">// area: CGFloat = 500.0</span></span><br></pre></td></tr></table></figure>
<p>你同样可以使用扩展来为类添加协议而无需增加它的子类。如果这个协议是在 Swift 中被定义的，你可以添加 comformance 到它的结构或枚举中无论它们在 Objective-C 或在 Swift 中被定义。</p>
<p>你不能使用扩展来覆盖 Objective-C 类型中存在的方法与属性。</p>
<p><a name="closures"></a></p>
<p>##闭包（Closures）</p>
<p>Objective-C 中的<code>blocks</code>会被自动导入为 Swift 中的闭包。例如，下面是一个 Objective-C 中的 block 变量：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void (^completionBlock)(NSData *, NSError *) = ^(NSData *data, NSError *error) &#123;/* ... */&#125;</span><br></pre></td></tr></table></figure>
<p>而它在 Swift 中的形式为</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> completionBlock: (<span class="type">NSData</span>, <span class="type">NSError</span>) -&gt; <span class="type">Void</span> = &#123;data, error <span class="keyword">in</span> <span class="comment">/* ... */</span>&#125;</span><br></pre></td></tr></table></figure>
<p>Swift 的闭包与 Objective-C 中的 blocks 能够和睦相处，所以你可以把一个 Swift 闭包传递给一个把 block 作为参数的 Objective-C 函数。Swift 闭包与函数具有互通的类型，所以你甚至可以传递 Swift 函数的名字。</p>
<p>闭包与 blocks 语义上相通但是在一个地方不同：变量是可以直接改变的，而不是像 block 那样会拷贝变量。换句话说，Swift 中变量的默认行为与 Objective-C 中 __block 变量一致。</p>
<p><a name="object_comparison"></a></p>
<p>##比较对象</p>
<p>当比较两个 Swift 中的对象时，可以使用两种方式。第一种，使用（==），判断两个对象内容是否相同。第二种，使用(===)，判断常量或者变量是否为同一个对象的实例。</p>
<p>Swift 与 Objective-C 一般使用 == 与 === 操作符来做比较。Swift 的 == 操作符为源自 NSObject 的对象提供了默认的实现。在实现 == 操作符时，Swift 调用 NSObject 定义的 isEqual: 方法。</p>
<p>NSObject 类仅仅做了身份的比较，所以你需要在你自己的类中重新实现 isEqual: 方法。因为你可以直接传递 Swift 对象给 Objective-C 的 API，你也应该为这些对象实现自定义的 isEqual: 方法，如果你希望比较两个对象的内容是否相同而不是仅仅比较他们是不是由相同的对象派生。</p>
<p>作为实现比较函数的一部分，确保根据<a href="//https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/DevPedia-CocoaCore/ObjectComparison.html#//apple_ref/doc/uid/TP40008195-CH37">Object comparison</a>实现对象的<code>hash</code>属性。更进一步的说，如果你希望你的类能够作为字典中的键，也需要遵从<code>Hashable</code>协议以及实现<code>hashValues</code>属性。</p>
<p><a name="swift_type_compatibility"></a></p>
<h2 id="Swift_类型兼容性">Swift 类型兼容性</h2><p>当你在 Swift 中创建了一个继承自 Objective-C 类的子类时，该类以及该类的成员-属性，方法，下标和构造器，便会在 Objective-C 中自动可用。在某些情况下，你需要更细粒度的控制如何将 Swift API 暴漏给 Objective-C。如果你的 Swift 类没有继承自 Objective-C 的类，又或者你想更改暴漏给 Objective-C 代码的接口符号名称，你便可以使用<code>@objc</code>属性。如果你正在使用如键值观察的 API 来动态替换方法的实现，也可以通过使用<code>dynamic</code>修饰符来获得对 Objective-C 运行时被自动派发的成员的访问。</p>
<h3 id="在_Objective-C_中暴漏_Swift_接口">在 Objective-C 中暴漏 Swift 接口</h3><p>当你定义一个继承自<code>NSObject</code>类或者其他 Objective-C 类的 Swift 子类时，该类便会自动兼容 Objective-C。Swift 编译器已经为你做好了这部分所需要的工作。</p>
<p>所有的步骤都由 Swift 编译器自动完成，如果你从未在 Objective-C 代码中导入 Swift 类，你也不需要担心类型适配问题。另外一种情况，如果你的 Swift 类并不继承于 Objective-C 类而你希望能在 Objective-C 的代码中使用它，你可以使用下面描述的<code>@objc</code>属性。</p>
<p><code>@objc</code>可以让你的 Swift API 在 Objective-C 中使用。换句话说，你可以通过在任何 Swift 方法、类、属性前添加<code>@objc</code>，来使得他们可以在 Objective-C 代码中使用。如果你的类继承自 Objective-C，编译器会自动帮助你完成这一步。编译器还会在所有的变量、方法、属性前加 @objc，如果这个类自己前面加上了<code>@objc</code>关键字。当你使用<code>@IBOutlet</code>，<code>@IBAction</code>，或者是<code>@NSManaged</code>属性时，<code>@objc</code>也会自动加在前面。这个关键字也可以用在 Objetive-C 中的 target-action 设计模式中，例如，<code>NSTimer</code>或者<code>UIButton</code>。</p>
<p>当你在 Objective-C 中使用 Swift API，编译器通常会对语句做直接的翻译。例如，Swift API <code>func playSong(name: String)</code>会被解释为<code>- (void)playSong:(NSString *)name</code>。然而，有一个例外：当在 Objective-C 中使用 Swift 的初始化函数，编译器会在方法前添加“initWith”并且将原初始化函数的第一个参数首字母大写。例如，这个 Swift 初始化函数<code>init (songName: String, artist: String</code>将被翻译为<code>- (instancetype)initWithSongName:(NSString *)songName artist:(NSString *)artist</code>。</p>
<p>Swift 同时也提供了一个<code>@objc</code>关键字的变体，通过它你可以自定义在 Objective-C 中转换的函数名。例如，如果你的 Swift 类的名字包含 Objective-C 中不支持的字符，你就可以为 Objective-C 提供一个可供替代的名字。如果你要为 Swift 函数提供一个 Objective-C 名字，记得为带参数的函数添加（:）</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="preprocessor">@objc</span>(<span class="type">Squirrel</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> Белка </span>&#123;</span><br><span class="line">    <span class="preprocessor">@objc</span>(initWithName:)</span><br><span class="line">    <span class="keyword">init</span> (имя: <span class="type">String</span>) &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">    <span class="preprocessor">@objc</span>(hideNuts:inTree:)</span><br><span class="line">    <span class="func"><span class="keyword">func</span> прячьОрехи<span class="params">(Int, вДереве: Дерево)</span></span> &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你在 Swift 类中使用<code>@objc(&lt;#name#&gt;)</code>关键字，这个类可以不需要命名空间即可在 Objective-C 中使用。这个关键字在你迁徙 Objecive-C 代码到 Swift 时同样也非常有用。由于归档过的对象存贮了类的名字，你应该使用<code>@objc(&lt;#name#&gt;)</code>来声明与旧的归档过的类相同的名字，这样旧的类才能被新的 Swift 类解档。</p>
<p><a name="Requiring_Dynamic_Dispatch"></a></p>
<h2 id="请求动态分配">请求动态分配</h2><p>@objc 属性将你的 Swift API 暴露给了 Objective-C 运行时，但是它并不能保证一个属性，方法，下标，或构造器的动态调度。通过绕过 Objective-C 运行时，Swift 编译器可能仍然 devirtualize 或内联成员访问来优化代码的性能。当你用动态修改符标记一个成员声明时，对该成员的访问始终是动态调度。由于标有动态修改声明使用 Objective-C 运行时来调度，它们被隐式的用 @objc 属性标记。</p>
<p>动态分配的需求很少是必要的。但是，当你要在运行时替换一个 API 的实现时你必须使用动态修改。例如，你可以使用 Objective-C 运行时方法<code>method_exchangeImplementations</code>函数来替换 app 正在运行时某个方法的实现。如果 Swift 编译器内联了方法的实现或者 devirtualized 对它的访问，新的实现将不会被使用。</p>
<p><a name="Lightweight_Generics"></a></p>
<h2 id="轻量级泛型">轻量级泛型</h2><p>使用轻量级泛型参数的 Objective-C 声明类型，如<code>NSArray</code>，<code>NSSet</code>以及<code>NSDictionary</code>，在被导入到 Swift 时会附带上他们内容保存的类型。</p>
<p>例如，考虑下面的 Objective-C 属性声明：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property NSArray&#60;NSDate *&#62;* dates;&#10;@property NSSet&#60;NSString *&#62;* words;&#10;@property NSDictionary&#60;KeyType: NSURL *, NSData *&#62;* cachedData;</span><br></pre></td></tr></table></figure>
<p>下面是 Swift 导入后：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dates: [<span class="type">NSDate</span>]</span><br><span class="line"><span class="keyword">var</span> words: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;</span><br><span class="line"><span class="keyword">var</span> cachedData: [<span class="type">NSURL</span>: <span class="type">NSData</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>除了 Foundation 中的集合类， Objective-C 的轻量级泛型会被 Swift 忽略掉。任何其他使用轻量级泛型的类型在导入到 Swift 中时会被视为无参数化。</p>
</blockquote>
<p><a name="objective_c_selectors"></a></p>
<h2 id="Objective-C_选择器">Objective-C 选择器</h2><p>Objective-C 选择器是一种指向 Objective-C 方法名的类型。在 Swift 里，Objective-C 的选择器被<code>Selector</code>结构体替代。你可以通过字符串创建一个选择器，比如<code>let mySelector: Selector = &quot;tappedButton:&quot;</code>。因为字符串字面量能够自动被转换为选择器，所以你可以把字符串字面量直接传递给任何能够接受选择器的方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> myButton = <span class="type">UIButton</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">100</span>, height: <span class="number">50</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>?(nibName nibNameOrNil: <span class="type">String</span>?, bundle nibBundleOrNil: <span class="type">NSBundle</span>?) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: nibNameOrNil, bundle: nibBundleOrNil)</span><br><span class="line">        myButton.addTarget(<span class="keyword">self</span>, action: <span class="string">"tappedButton:"</span>, forControlEvents: .<span class="type">TouchUpInside</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">tappedButton</span><span class="params">(sender: UIButton!)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"tapped button"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    required <span class="keyword">init</span>?(coder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: coder)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
<p><code>performSelector:</code>方法和相关的调用选择器的方法没有导入到 Swift 中因为它们本质上是不安全的。</p>
</blockquote>
<p>如果你的 Swift 类继承自 Objective-C 的类，你的所有方法都可以用作 Objective-C 的选择器。反之，如果你的 Swift 类不是继承自 Objective-C，你需要在想要使用的选择器前面加上<code>@objc</code>属性前缀，详情请看<a href="#swift_type_compatibility">Swift 类型兼容性</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>翻译：<a href="https://github.com/Creolophus" target="_blank" rel="external">Creolophus</a></p>
<p>校正：<a href="https://github.c]]>
    </summary>
    
      <category term="Using Swift with Cocoa and Objective-C" scheme="http://yoursite.com/tags/Using-Swift-with-Cocoa-and-Objective-C/"/>
    
      <category term="Using-Swift-with-Cocoa-and-Objective-C" scheme="http://yoursite.com/categories/Using-Swift-with-Cocoa-and-Objective-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[02Interoperability-02特性编写Swift类]]></title>
    <link href="http://yoursite.com/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/02Writing%20Swift%20Classes%20with%20Objective-C%20Behavior/"/>
    <id>http://yoursite.com/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/02Writing Swift Classes with Objective-C Behavior/</id>
    <published>2015-12-26T14:00:09.000Z</published>
    <updated>2015-12-17T11:11:20.922Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>翻译：<a href="https://github.com/halinuya" target="_blank" rel="external">halinuya</a></p>
<p>校对：<a href="https://github.com/song-buaa" target="_blank" rel="external">song-buaa</a> <a href="https://github.com/MonicaZhou" target="_blank" rel="external">MonicaZhou</a> <a href="https://github.com/dabing1022" target="_blank" rel="external">ChildhoodAndy</a></p>
</blockquote>
<h1 id="使用Objective-C特性编写Swift类">使用Objective-C特性编写Swift类</h1><hr>
<p>本节包括内容：</p>
<ul>
<li><a href="#inheriting_from_objective-c_classes">继承Objective-C的类（Inheriting from Objective-C Classes）</a></li>
<li><a href="#adopting_protocols">采用协议（Adopting Protocols）</a></li>
<li><a href="#writing_initializers_and_deinitializers">编写构造器和析构器（Writing Initializers and Deinitializers）</a></li>
<li><a href="#integrating_with_interface_builder">集成Interface Builder（Integrating with Interface Builder）</a></li>
<li><a href="#specifying_property_attributes">指明属性特性（Specifying Property Attributes）</a></li>
<li><a href="#implementing_core_data_managed_object_subclasses">实现Core Data Managed Object子类（Implementing Core Data Managed Object Subclasses）</a></li>
<li><a href="#using_swift_class_names_with_objective_c_apis">使用带Objective-C API的Swift类名</a></li>
</ul>
<p>互用性（互操作性）使开发者可以定义融合了 Objective-C 语言特性的Swift类。编写 Swift 类时，不仅可以继承 Objective-C 语言编写的父类，采用 Objective-C 的协议，还可以利用 Objective-C 的一些其它功能。这意味着，开发者可以基于 Objective-C 中已有的熟悉、可靠的类、方法和框架来创建 Swift 类，并结合 Swift 提供的现代化和更有效的语言特点对其进行优化。</p>
<p><a name="inheriting_from_objective-c_classes"></a></p>
<h2 id="继承Objective-C的类">继承Objective-C的类</h2><p>在 Swift 中，开发者可以定义一个子类，该子类继承自使用 Objective-C 编写的类。创建该子类的方法是，在 Swift 的类名后面加上一个冒号（:），冒号后面跟上 Objective-C 的类名。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySwiftViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 定义类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开发者能够从 Objective-C 的父类中继承所有的功能。如果开发者要覆盖父类中的方法，不要忘记使用<code>override</code>关键字。</p>
<h3 id="NSCoding协议">NSCoding协议</h3><p><code>NSCoding</code>协议要求符合的类型实现所需的构造器<code>init(coder:)</code>。直接采用<code>NSCoding</code>协议的类必须实现这个方法。采用<code>NSCoding</code>协议的类的子类，这些类有一个或者多个自定义的构造器或者不带初始化值的属性，也必须实现这个方法。Xcode提供了以下占位实现来提醒：</p>
<pre><code>required init(coder aDecoder: NSCoder) {
<span class="code">    fatalError("init(coder:) has not been implemented")</span>
}
<span class="xml"><span class="comment"><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">对那些从 Storyboards 里加载的对象，或者用 NSUserDefaults 或 NSKeyedArchiver 类归档到磁盘的对象，你必须提供一个完整的初始化程序的实现。然而，当类型以此种方式无法实例化的时候，你可能并不需要实现构造器。</span><br><span class="line"></span><br><span class="line">&lt;a name=<span class="string">"adopting_protocols"</span>&gt;&lt;/a&gt;</span><br><span class="line"><span class="comment">## 采用协议</span></span><br><span class="line"></span><br><span class="line">在 Swift 中，开发者可以采用 Objective-C 中定义好的协议。和 Swift 协议一样，所有 Objective-C 协议都写在一个用逗号隔开的列表中，跟在所在类的父类名后面（如果它有父类的话）。</span><br><span class="line"></span><br><span class="line">`<span class="javascript"></span>``<span class="javascript">swift</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySwiftViewController</span>: <span class="title">UIViewController</span>, <span class="title">UITableViewDelegate</span>, <span class="title">UITableViewDataSource</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 定义类</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></span></span>

Objective-C 协议与 Swift 协议使用上是一致的。如果开发者想在 Swift 代码中引用 <span class="code">`UITableViewDelegate`</span>协议，可以直接使用<span class="code">`UITableViewDelegate`</span>（跟在 Objective-C 中引用<span class="code">`id&lt;UITableViewDelegate&gt;`</span>是等价的）。

因为在 Swift 中，类和协议的命名空间是统一的，Objective-C 里的 NSObject 协议被重新映射到 Swift 里的 NSObjectProtocol。

<span class="xml"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">name</span>=<span class="value">"writing_initializers_and_deinitializers"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="title">a</span>&gt;</span></span>
<span class="header">## 编写构造器和析构器</span>

Swift 的编译器确保在初始化时，构造器不允许类里有任何未初始化的属性，这样做能够增加代码的安全性和可预测性。另外，与 Objective-C 语言不同，Swift 不提供单独的内存分配方法供开发者调用。当你使用原生的 Swift 初始化方法时（即使是和 Objective-C 类协作），Swift 会将 Objective-C 的初始化方法转换为 Swift 的初始化方法。关于如何实现开发者自定义构造器的更多信息，请查看[<span class="link_label">构造器</span>](<span class="link_url">https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18</span>)。

当开发者希望在类被释放前，执行额外的清理工作时，需要执行一个析构过程来代替<span class="code">`dealloc`</span>方法。在实例被释放前，Swift 会自动调用析构器来执行析构过程。Swift 调用完子类的析构器后，会自动调用父类的析构器。当开发者使用 Objective-C 类或者是继承自 Objective-C 类的 Swift 类时，Swift 也会自动为开发者调用这个类的父类里的<span class="code">`dealloc`</span>方法。关于如何实现开发者自定义析构器的更多信息，请查看[析构器]https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift<span class="emphasis">_Programming_</span>Language/Deinitialization.html#//apple_ref/doc/uid/TP40014097-CH19)。

<span class="xml"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">name</span>=<span class="value">"integrating_with_interface_builder"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="title">a</span>&gt;</span></span>
<span class="header">## 集成Interface Builder</span>

Swift 编译器包含一些属性，使得开发者的 Swift 类集成了 Interface Builder 里的一些特色功能。和 Objective-C 里一样，你能在 Swift 里面使用 outlets，actions 和实时渲染（live rendering）。

<span class="header">### 使用Outlets和Action</span>

使用 Outlets 和 Action 可以连接源代码和 Interface Builder 的 UI 对象。在Swift里面使用 Outlets 和 Action，需要在属性和方法声明前插入<span class="code">`@IBOutlet`</span>或者<span class="code">`@IBAction`</span>关键字。声明一个 Outlet 集合同样是用<span class="code">`@IBOutlet`</span>属性，即为类型指定一个数组。

当开发者在 Swift 里面声明了一个 Outlet 时，Swift 编译器会自动将该类型转换为弱（weak）、隐式（implicitly）、未包装（unwrapped）的 optional（Objective-C 里面对应指针类型）数据类型，并为它分配一个初始化的空值<span class="code">`nil`</span>。实际上，编译器使用<span class="code">`@IBOutlet weak var name: Type! = nil`</span>来代替 <span class="code">`@IBOutlet var name: Type`</span>。编译器将该类型转换成了弱（weak）、隐式（implicitly）、未包装（unwrapped）的 optional 类型，因此开发者就不需要在构造器中为该类型分配一个初始值了。当开发者从故事板（storyboard）或者<span class="code">`xib`</span>文件里面初始化对象 class 后，定义好的 Outlet 和这些对象连接在一起了，所以，这些 Outlet 是隐式的，未包装的。由于创建的 outlets 一般都是弱关系，因此默认 outlets 是弱类型。

例如，下面的 Swift 代码声明了一个拥有 Outlet、Outlet 集合和 Action 的类：

<span class="xml"><span class="comment"><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="preprocessor">@IBOutlet</span> <span class="keyword">var</span> button: <span class="type">UIButton</span></span><br><span class="line"></span><br><span class="line">	<span class="preprocessor">@IBOutlet</span> <span class="keyword">var</span> textFields: <span class="type">UITextField</span>[]</span><br><span class="line"></span><br><span class="line">	<span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">buttonTapped</span><span class="params">(AnyObject)</span></span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"button tapped!"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></span></span>

在<span class="code">`buttonTapped`</span>方法中，消息发送者的信息没有被使用，因此可以省略该方法的参数名。

<span class="header">### 实时渲染（live rendering）</span>
开发者可以在 Interface Builder 中用<span class="code">`@IBDesignable`</span>和<span class="code">`@IBInspectable`</span>来创建生动、可交互的自定义视图（view）。开发者继承<span class="code">`UIView`</span>或者<span class="code">`NSView`</span>来自定义一个视图（view）时，可以在类声明前添加<span class="code">`@IBDesignable`</span>属性。当你在 Interface Builder 里添加了自定义的视图后（在监视器面板的自定义视图类中进行设置），Interface Builder 将在画布上渲染你自定义的视图。


&gt;注意：只能针对框架里对象进行实时渲染

你也可以将<span class="code">`@IBInspectable`</span>属性添加到和用户定义的运行时属性兼容的类型属性里。这样，当开发者将自定义的视图添加到 Interface Builder 里后，就可以在监视器面板中编辑这些属性。

<span class="xml"><span class="comment"><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">@IBDesignable</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCustomView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">	<span class="preprocessor">@IBInspectable</span> <span class="keyword">var</span> textColor: <span class="type">UIColor</span></span><br><span class="line">	<span class="preprocessor">@IBInspectable</span> <span class="keyword">var</span> iconHeight: <span class="type">CGFloat</span></span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></span></span>

<span class="xml"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">name</span>=<span class="value">"specifying_property_attributes"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="title">a</span>&gt;</span></span>
<span class="header">## 指明属性特性</span>

在 Objective-C 中，属性通常都有一组特性（Attributes）说明来指明该属性的一些附加信息。在 Swift 中，开发者可以通过不同的方法来指明属性的这些特性。

<span class="header">### 强类型和弱类型</span>

Swift 里属性默认都是强类型的。使用<span class="code">`weak`</span>关键字修饰一个属性，能指明其对象存储时是一个弱引用。该关键字仅能修饰 optional 对象类型。更多的信息，请查阅[<span class="link_label">特性</span>](<span class="link_url">https://github.com/CocoaChina-editors/Welcome-to-Swift/blob/master/The%20Swift%20Programming%20Language/02Language%20Guide/09Classes%20and%20Structures.md</span>)。

<span class="header">### 读／写和只读</span>

在 Swift 中，没有<span class="code">`readwrite`</span>和<span class="code">`readonly`</span>特性。当声明一个存储型属性时，使用<span class="code">`let`</span>修饰其为只读；使用<span class="code">`var`</span>修饰其为可读／写。当声明一个计算型属性时，为其提供一个 getter 方法，使其成为只读的；提供 getter 方法和 setter 方法，使其成为可读／写的。更多信息，请查阅[<span class="link_label">属性</span>](<span class="link_url">https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13</span>)。

<span class="header">### 拷贝</span>

在 Swift 中，Objective-C 的<span class="code">`copy`</span>特性被转换为<span class="code">`@NSCopying`</span>属性。这一类的属性必须遵守 <span class="code">`NSCopying`</span>协议。更多信息，请查阅[<span class="link_label">特性</span>](<span class="link_url">https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13</span>)。

<span class="xml"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">name</span>=<span class="value">"implementing_core_data_managed_object_subclasses"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="title">a</span>&gt;</span></span>
<span class="header">## 实现Core Data Managed Object子类</span>

Core Data 提供了基本存储和实现<span class="code">`NSManagedObject`</span>子类的一组属性。在与Core Data 模型中管理对象子类相关的特性或者关系的每个属性定义之前，将<span class="code">`@NSmanaged`</span>特性加入。与 Objective-C 里面的 <span class="code">`@dynamic`</span>特性类似，<span class="code">`@NSManaged`</span>特性告知 Swift 编译器，这个属性的存储和实现将在运行时完成。但是，与<span class="code">`@dynamic`</span>不同的是，<span class="code">`@NSManaged`</span>特性仅在 Core Data 支持中可用。

Swift 类被命名空间化---他们局限于被编译的模块中（最典型的是Target）。
为了使用带 Core Data 模型的<span class="code">`NSManagedObject`</span>类的 Swift 子类，在模型实体监视器的类区域里，用模块名字作为类名的前缀。

![](https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/Art/coredatanamespace_2x.png)

<span class="xml"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">name</span>=<span class="value">"using_swift_class_names_with_objective_c_apis"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="title">a</span>&gt;</span></span>
<span class="header">## 使用带Objective-C API的Swift类名</span>

Swift 类的命名基于他们被编译的模块，即使是使用来自 Objective-C 的代码。和 Objective-C 不同的是，所有的类都是全局命名空间的一部分，必须没有相同的名字，Swift 类可以基于他们存在的模块来消除歧义。比如，被称为 MyFramework 框架中的被叫做DataManager 的 Swift 类的全限定名就是 MyFramework.DataManager。一个 Swift 应用目标就是模块本身，所以，在一个叫 MyGreatApp 的应用里，叫 Observer 的 Swift 类的全限定名是 MyGreatApp.Observer。

为了保存在 Objective-C 代码里使用的 Swift 类，Swift类用他们的全限定名暴漏给 Objective-C 运行时。因此，当你使用那些对 Swift 类的字符串代表起作用的 API，必须包含类的全限定名。比如，当你创建一个基于文档的 Mac 应用，要在应用的 Info.plist 里提供 NSDocument 子类的名字。Swift里，你必须使用文档子类的全名，包括从你的应用或者框架里派生出来的模块名字。
<span class="code">    下面的例子中，`NSClassFromString`方法用于检索一个来自字符串代表的类的引用。为了检索 Swift 类，需要使用全限定名，包括应用的名字。</span>

<span class="code">```</span>    swift
let myPersonClass:AnyClass(NSClassFromString("MyGreatApp.Person"))
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>翻译：<a href="https://github.com/halinuya" target="_blank" rel="external">halinuya</a></p>
<p>校对：<a href="https://github.com/s]]>
    </summary>
    
      <category term="Using Swift with Cocoa and Objective-C" scheme="http://yoursite.com/tags/Using-Swift-with-Cocoa-and-Objective-C/"/>
    
      <category term="Using-Swift-with-Cocoa-and-Objective-C" scheme="http://yoursite.com/categories/Using-Swift-with-Cocoa-and-Objective-C/"/>
    
  </entry>
  
</feed>
