

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Sequences And Collections in Swift &mdash; Swift Programming Language documentation 0.1.9 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Swift Programming Language documentation 0.1.9 documentation" href="index.html"/>
        <link rel="next" title="Swift Binary Serialization Format" href="Serialization.html"/>
        <link rel="prev" title="Swift Intermediate Language (SIL)" href="SIL.html"/>
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>


  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Swift Programming Language documentation
          

          
          </a>

          
            
            
              <div class="version">
                0.1.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">swift docs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="ABI.html">The Swift ABI</a></li>
<li class="toctree-l1"><a class="reference internal" href="ARCOptimization.html">ARC Optimization for Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="AccessControl.html">Access Control</a></li>
<li class="toctree-l1"><a class="reference internal" href="AccessControlInStdlib.html">Scope and introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="AccessControlInStdlib.html#public"><cite>public</cite></a></li>
<li class="toctree-l1"><a class="reference internal" href="AccessControlInStdlib.html#internal"><cite>internal</cite></a></li>
<li class="toctree-l1"><a class="reference internal" href="AccessControlInStdlib.html#private"><cite>private</cite></a></li>
<li class="toctree-l1"><a class="reference internal" href="AccessControlInStdlib.html#leading-underscore-rule">Leading Underscore Rule</a></li>
<li class="toctree-l1"><a class="reference internal" href="Arrays.html">The Swift Array Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="CallingConvention.html">The Swift Calling Convention</a></li>
<li class="toctree-l1"><a class="reference internal" href="DebuggingTheCompiler.html">Debugging the Swift Compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="Dependency Analysis.html">Dependency Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="DriverInternals.html">Driver Design &amp; Internals</a></li>
<li class="toctree-l1"><a class="reference internal" href="DriverParseableOutput.html">Parseable Driver Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="ErrorHandling.html">Error Handling in Swift 2.0</a></li>
<li class="toctree-l1"><a class="reference internal" href="ErrorHandlingRationale.html">Error Handling Rationale and Proposal</a></li>
<li class="toctree-l1"><a class="reference internal" href="Failable Initializers.html">Failable initializers</a></li>
<li class="toctree-l1"><a class="reference internal" href="Generics.html">Generics in Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="GitWorkflows.html">Git Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="GitWorkflows.html#svn-git-workflows">SVN -&gt; GIT Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="HighLevelSILOptimizations.html">High-Level Optimizations in SIL</a></li>
<li class="toctree-l1"><a class="reference internal" href="Import.html">IMPORT SYNTAX</a></li>
<li class="toctree-l1"><a class="reference internal" href="Import.html#resolving-name-clashes">RESOLVING NAME CLASHES</a></li>
<li class="toctree-l1"><a class="reference internal" href="Import.html#future-extensions">FUTURE EXTENSIONS</a></li>
<li class="toctree-l1"><a class="reference internal" href="IndexInvalidation.html">Index Invalidation Rules in the Swift Standard Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#using-versioned-api">Using Versioned API</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#publishing-versioned-api">Publishing Versioned API</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#giving-up-flexibility">Giving Up Flexibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#optimization">Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#resilience-domains">Resilience Domains</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#protocol-conformances">Protocol Conformances</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#checking-binary-compatibility">Checking Binary Compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#summary">Summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#glossary">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="Literals.html">Literals</a></li>
<li class="toctree-l1"><a class="reference internal" href="LogicalObjects.html">Logical Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="Modules.html">High-Level Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="Modules.html#import"><code class="docutils literal"><span class="pre">import</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="Modules.html#interoperability-with-objective-c-via-clang">Interoperability with Objective-C via Clang</a></li>
<li class="toctree-l1"><a class="reference internal" href="Modules.html#glossary">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="MutationModel.html">Immutability and Read-Only Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="ObjectInitialization.html">Object Initialization</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html">Writing High-Performance Swift Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#enabling-optimizations">Enabling Optimizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#whole-module-optimizations">Whole Module Optimizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#reducing-dynamic-dispatch">Reducing Dynamic Dispatch</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#using-container-types-efficiently">Using Container Types Efficiently</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#unchecked-operations">Unchecked operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#generics">Generics</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#the-cost-of-large-swift-values">The cost of large swift values</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#unsafe-code">Unsafe code</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#protocols">Protocols</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#footnotes">Footnotes</a></li>
<li class="toctree-l1"><a class="reference internal" href="Pattern Matching.html">Pattern Matching</a></li>
<li class="toctree-l1"><a class="reference internal" href="SIL.html">Swift Intermediate Language (SIL)</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Sequences And Collections in Swift</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#sequences">Sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="#generators">Generators</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#operating-on-sequences-generically">Operating on Sequences Generically</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#collections">Collections</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#mutable-collections">Mutable Collections</a></li>
<li class="toctree-l3"><a class="reference internal" href="#range-replaceable-collections">Range Replaceable Collections</a></li>
<li class="toctree-l3"><a class="reference internal" href="#index-protocols">Index Protocols</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#conclusion">Conclusion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Serialization.html">Swift Binary Serialization Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="StdlibAPIGuidelines.html">Swift Standard Library API Design Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="StdlibRationales.html">Rationales for the Swift standard library designs</a></li>
<li class="toctree-l1"><a class="reference internal" href="StoredAndComputedVariables.html">Stored and Computed Variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="StringDesign.html">Swift String Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="Testing.html">Testing Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="TextFormatting.html">Text Formatting in Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="TransparentAttr.html"><code class="docutils literal"><span class="pre">&#64;_transparent</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="TypeChecker.html">Type Checker Design and Implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="contents.html">Contents</a></li>
<li class="toctree-l1"><a class="reference internal" href="weak.html">Weak References</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Swift Programming Language documentation</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Sequences And Collections in Swift</li>
    <li class="wy-breadcrumbs-aside">
      
        
          <a href="_sources/SequencesAndCollections.txt" rel="nofollow"> View page source</a>
        
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="sequences-and-collections-in-swift">
<h1>Sequences And Collections in Swift<a class="headerlink" href="#sequences-and-collections-in-swift" title="Permalink to this headline">¶</a></h1>
<p>Unlike many languages, Swift provides a rich taxonomy of abstractions
for processing series of elements.  This document explains why that
taxonomy exists and how it is structured.</p>
<div class="section" id="sequences">
<h2>Sequences<a class="headerlink" href="#sequences" title="Permalink to this headline">¶</a></h2>
<p>It all begins with Swift&#8217;s <code class="code docutils literal"><span class="pre">for</span></code>…<code class="code docutils literal"><span class="pre">in</span></code> loop:</p>
<div class="highlight-python"><div class="highlight"><pre>for x in s {
  doSomethingWith(x)
}
</pre></div>
</div>
<p>Because this construct is generic, <code class="code docutils literal"><span class="pre">s</span></code> could be</p>
<ul class="simple">
<li>an array</li>
<li>a set</li>
<li>a linked list</li>
<li>a series of UI events</li>
<li>a file on disk</li>
<li>a stream of incoming network packets</li>
<li>an infinite series of random numbers</li>
<li>a user-defined data structure</li>
<li>etc.</li>
</ul>
<p>In Swift, all of the above are called <strong>sequences</strong>, an abstraction
represented by the <code class="code docutils literal"><span class="pre">SequenceType</span></code> protocol:</p>
<div class="highlight-python"><div class="highlight"><pre>protocol SequenceType {
  typealias Generator : GeneratorType
  func generate() -&gt; Generator
}
</pre></div>
</div>
<div class="sidebar">
<p class="first sidebar-title">Hiding Generator Type Details</p>
<p class="last">A sequence&#8217;s generator is an associated type—rather than something
like <a class="reference external" href="http://swiftdoc.org/type/AnyGenerator/"><code class="code docutils literal"><span class="pre">AnyGenerator&lt;T&gt;</span></code></a> that depends only on the element type—for
performance reasons.  Although the alternative design has
significant usability benefits, it requires one dynamic
allocation/deallocation pair and <em>N</em> dynamic dispatches to traverse
a sequence of length <em>N</em>.  That said, our optimizer has improved to
the point where it can sometimes remove these overheads completely,
and we are <a class="reference external" href="rdar://19755076">considering</a> changing the design
accordingly.</p>
</div>
<p>As you can see, sequence does nothing more than deliver a generator.
To understand the need for generators, it&#8217;s important to distinguish
the two kinds of sequences.</p>
<ul class="simple">
<li><strong>Volatile</strong> sequences like “stream of network packets,” carry
their own traversal state, and are expected to be “consumed” as they
are traversed.</li>
<li><strong>Stable</strong> sequences, like arrays, should <em>not</em> be mutated by <code class="code docutils literal"><span class="pre">for</span></code>…<code class="code docutils literal"><span class="pre">in</span></code>, and thus require <em>separate traversal state</em>.</li>
</ul>
<p>To get an initial traversal state for an arbitrary sequence <code class="code docutils literal"><span class="pre">x</span></code>, Swift
calls <code class="code docutils literal"><span class="pre">x.generate()</span></code>.  The sequence delivers that state, along with
traversal logic, in the form of a <strong>generator</strong>.</p>
</div>
<div class="section" id="generators">
<h2>Generators<a class="headerlink" href="#generators" title="Permalink to this headline">¶</a></h2>
<p><code class="code docutils literal"><span class="pre">for</span></code>…<code class="code docutils literal"><span class="pre">in</span></code> needs three operations from the generator:</p>
<ul class="simple">
<li>get the current element</li>
<li>advance to the next element</li>
<li>detect whether there are more elements</li>
</ul>
<p>If we literally translate the above into protocol requirements, we get
something like this:</p>
<div class="highlight-python"><div class="highlight"><pre>protocol NaiveGeneratorType {
  typealias Element
  var current() -&gt; Element      // get the current element
  mutating func advance()       // advance to the next element
  var isExhausted: Bool         // detect whether there are more elements
}
</pre></div>
</div>
<p>Such a protocol, though, places a burden on implementors of volatile
sequences: either the generator must buffer the current element
internally so that <code class="code docutils literal"><span class="pre">current</span></code> can repeatedly return the same value, or
it must trap when <code class="code docutils literal"><span class="pre">current</span></code> is called twice without an intervening
call to <code class="code docutils literal"><span class="pre">moveToNext</span></code>.  Both semantics have a performance cost, and
the latter unnecessarily adds the possibility of incorrect usage.</p>
<div class="sidebar">
<p class="first sidebar-title"><code class="code docutils literal"><span class="pre">NSEnumerator</span></code></p>
<p>You might recognize the influence on generators of the
<code class="code docutils literal"><span class="pre">NSEnumerator</span></code> API:</p>
<div class="last highlight-python"><div class="highlight"><pre>class NSEnumerator : NSObject {
  func nextObject() -&gt; AnyObject?
}
</pre></div>
</div>
</div>
<p>Therefore, Swift&#8217;s <code class="code docutils literal"><span class="pre">GeneratorType</span></code> merges the three operations into one,
returning <code class="code docutils literal"><span class="pre">nil</span></code> when the generator is exhausted:</p>
<div class="highlight-python"><div class="highlight"><pre>protocol GeneratorType {
  typealias Element
  mutating func next() -&gt; Element?
}
</pre></div>
</div>
<p>Combined with <code class="code docutils literal"><span class="pre">SequenceType</span></code>, we now have everything we need to
implement a generic <code class="code docutils literal"><span class="pre">for</span></code>…<code class="code docutils literal"><span class="pre">in</span></code> loop.</p>
<div class="sidebar">
<p class="first sidebar-title">Adding a Buffer</p>
<p>The use-cases for singly-buffered generators are rare enough that it
is not worth complicating <code class="code docutils literal"><span class="pre">GeneratorType</span></code>, <a class="footnote-reference" href="#input-iterator" id="id2">[1]</a> but
support for buffering would fit nicely into the scheme, should it
prove important:</p>
<div class="highlight-python"><div class="highlight"><pre>public protocol BufferedGeneratorType
  : GeneratorType {
  var latest: Element? {get}
}
</pre></div>
</div>
<p>The library could easily offer a generic wrapper that adapts any
<code class="code docutils literal"><span class="pre">GeneratorType</span></code> to create a <code class="code docutils literal"><span class="pre">BufferedGeneratorType</span></code>:</p>
<div class="last highlight-python"><div class="highlight"><pre>/// Add buffering to any GeneratorType G
struct BufferedGenerator&lt;G: GeneratorType&gt;
  : BufferedGeneratorType {

  public init(_ baseGenerator: G) {
    self._baseGenerator = baseGenerator
  }
  public func next() -&gt; Element? {
    latest = _baseGenerator.next() ?? latest
    return latest
  }
  public private(set) var
    latest: G.Element? = nil
  private var _baseGenerator: G
}
</pre></div>
</div>
</div>
<div class="section" id="operating-on-sequences-generically">
<h3>Operating on Sequences Generically<a class="headerlink" href="#operating-on-sequences-generically" title="Permalink to this headline">¶</a></h3>
<p>Given an arbitrary <code class="code docutils literal"><span class="pre">SequenceType</span></code>, aside from a simple <code class="code docutils literal"><span class="pre">for</span></code>…<code class="code docutils literal"><span class="pre">in</span></code> loop,
you can do anything that requires reading elements from beginning to
end.  For example:</p>
<div class="highlight-python"><div class="highlight"><pre>// Return an array containing the elements of `source`, with
// `separator` interposed between each consecutive pair.
func array&lt;S: SequenceType&gt;(
  source: S,
  withSeparator separator: S.Generator.Element
) -&gt; [S.Generator.Element] {
  var result: [S.Generator.Element] = []
  var g = source.generate()
  if let start = g.next() {
    result.append(start)
    while let next = g.next() {
      result.append(separator)
      result.append(next)
    }
  }
  return result
}

let s = String(array(&quot;Swift&quot;, withSeparator: &quot;|&quot;))
print(s)        // &quot;S|w|i|f|t&quot;
</pre></div>
</div>
<p>Because sequences may be volatile, though, you can—in general—only
make a single traversal.  This capability is quite enough for many
languages: the iteration abstractions of Java, C#, Python, and Ruby
all go about as far as <code class="code docutils literal"><span class="pre">SequenceType</span></code>, and no further.  In Swift,
though, we want to do much more generically.  All of the following
depend on stability that an arbitrary sequence can&#8217;t provide:</p>
<ul class="simple">
<li>Finding a sub-sequence</li>
<li>Finding the element that occurs most often</li>
<li>Meaningful in-place element mutation (including sorting,
partitioning, rotations, etc.)</li>
</ul>
<div class="sidebar">
<p class="first sidebar-title">Generators Should Be Sequences</p>
<p>In principle, every generator is a volatile sequence containing
the elements it has yet to return from <code class="code docutils literal"><span class="pre">next()</span></code>.  Therefore, every
generator <em>could</em> satisfy the requirements of <code class="code docutils literal"><span class="pre">SequenceType</span></code> by
simply declaring conformance, and returning <code class="code docutils literal"><span class="pre">self</span></code> from its
<code class="code docutils literal"><span class="pre">generate()</span></code> method.  In fact, if it weren&#8217;t for <a class="reference external" href="rdar://17986597">current language
limitations</a>, <code class="code docutils literal"><span class="pre">GeneratorType</span></code> would refine
<code class="code docutils literal"><span class="pre">SequenceType</span></code>, as follows:</p>
<pre class="literal-block">
protocol GeneratorType <strong>: SequenceType</strong> {
  typealias Element
  mutating func next() -&gt; Element?
}
</pre>
<p class="last">Though we may not currently be able to <em>require</em> that every
<code class="code docutils literal"><span class="pre">GeneratorType</span></code> refines <code class="code docutils literal"><span class="pre">SequenceType</span></code>, most generators in the
standard library do conform to <code class="code docutils literal"><span class="pre">SequenceType</span></code>.</p>
</div>
<p>Fortunately, many real sequences <em>are</em> stable. To take advantage of
that stability in generic code, we&#8217;ll need another protocol.</p>
</div>
</div>
<div class="section" id="collections">
<h2>Collections<a class="headerlink" href="#collections" title="Permalink to this headline">¶</a></h2>
<p>A <strong>collection</strong> is a stable sequence with addressable “positions,”
represented by an associated <code class="code docutils literal"><span class="pre">Index</span></code> type:</p>
<div class="highlight-python"><div class="highlight"><pre>protocol CollectionType : SequenceType {
  typealias Index : ForwardIndexType             // a position
  subscript(i: Index) -&gt; Generator.Element {get}

  var startIndex: Index {get}
  var endIndex: Index {get}
}
</pre></div>
</div>
<p>The way we address positions in a collection is a generalization of
how we interact with arrays: we subscript the collection using its
<code class="code docutils literal"><span class="pre">Index</span></code> type:</p>
<div class="highlight-python"><div class="highlight"><pre>let ith = c[i]
</pre></div>
</div>
<p>An <strong>index</strong>—which must model <code class="code docutils literal"><span class="pre">ForwardIndexType</span></code>—is a type with a
linear series of discrete values that can be compared for equality:</p>
<div class="sidebar">
<p class="first sidebar-title">Dictionary Keys</p>
<p class="last">Although dictionaries overload <code class="code docutils literal"><span class="pre">subscript</span></code> to also operate on keys,
a <code class="code docutils literal"><span class="pre">Dictionary</span></code>&#8216;s <code class="code docutils literal"><span class="pre">Key</span></code> type is distinct from its <code class="code docutils literal"><span class="pre">Index</span></code> type.
Subscripting on an index is expected to offer direct access,
without introducing overheads like searching or hashing.</p>
</div>
<div class="highlight-python"><div class="highlight"><pre>protocol ForwardIndexType : Equatable {
  typealias Distance : SignedIntegerType
  func successor() -&gt; Self
}
</pre></div>
</div>
<p>While one can use <code class="code docutils literal"><span class="pre">successor()</span></code> to create an incremented index value,
indices are more commonly advanced using an in-place increment
operator, just as one would when traversing an array: <code class="code docutils literal"><span class="pre">++i</span></code> or <code class="code docutils literal"><span class="pre">i++</span></code>.
These operators are defined generically, for all models of
<code class="code docutils literal"><span class="pre">ForwardIndexType</span></code>, in terms of the <code class="code docutils literal"><span class="pre">successor()</span></code> method.</p>
<p>Every collection has two special indices: a <code class="code docutils literal"><span class="pre">startIndex</span></code> and an
<code class="code docutils literal"><span class="pre">endIndex</span></code>.  In an empty collection, <code class="code docutils literal"><span class="pre">startIndex</span> <span class="pre">==</span> <span class="pre">endIndex</span></code>.
Otherwise, <code class="code docutils literal"><span class="pre">startIndex</span></code> addresses the collection&#8217;s first element, and
<code class="code docutils literal"><span class="pre">endIndex</span></code> is the successor of an index addressing the collection&#8217;s
last element.  A collection&#8217;s <code class="code docutils literal"><span class="pre">startIndex</span></code> and <code class="code docutils literal"><span class="pre">endIndex</span></code> form a
half-open range containing its elements: while a collection&#8217;s
<code class="code docutils literal"><span class="pre">endIndex</span></code> is a valid index value for comparison, it is not a valid
index for subscripting the collection:</p>
<div class="highlight-python"><div class="highlight"><pre>if c.startIndex != c.endIndex { } // OK
c[c.endIndex]                     // Oops! (index out-of-range)
</pre></div>
</div>
<div class="section" id="mutable-collections">
<h3>Mutable Collections<a class="headerlink" href="#mutable-collections" title="Permalink to this headline">¶</a></h3>
<p>A <strong>mutable collection</strong> is a collection that supports in-place element
mutation.  The protocol is a simple refinement of <code class="code docutils literal"><span class="pre">CollectionType</span></code> that adds a
subscript setter:</p>
<pre class="literal-block">
protocol MutableCollectionType : CollectionType {
  subscript(i: Index) -&gt; Generator.Element { get <strong>set</strong> }
}
</pre>
<p>The <code class="code docutils literal"><span class="pre">CollectionType</span></code> protocol does not require collection to support mutation,
so it is not possible to tell from the protocol itself whether the order of
elements in an instance of a type that conforms to <code class="code docutils literal"><span class="pre">CollectionType</span></code> has a
domain-specific meaning or not.  (Note that since elements in collections have
stable indices, the element order within the collection itself is stable; the
order sometimes does not have a meaning and is not chosen by the code that uses
the collection, but by the implementation details of the collection itself.)</p>
<p><code class="code docutils literal"><span class="pre">MutableCollectionType</span></code> protocol allows the to replace a specific element,
identified by an index, with another one in the same position.  This capability
essentially allows to rearrange the elements inside the collection in any
order, thus types that conform to <code class="code docutils literal"><span class="pre">MutableCollectionType</span></code> can represent
collections with a domain-specific element order (not every instance of a
<code class="code docutils literal"><span class="pre">MutableCollectionType</span></code> has an interesting order, though).</p>
</div>
<div class="section" id="range-replaceable-collections">
<h3>Range Replaceable Collections<a class="headerlink" href="#range-replaceable-collections" title="Permalink to this headline">¶</a></h3>
<p>The <code class="code docutils literal"><span class="pre">MutableCollectionType</span></code> protocol implies only mutation of content, not of
structure (for example, changing the number of elements).  The
<code class="code docutils literal"><span class="pre">RangeReplaceableCollectionType</span></code> protocol adds the capability to perform
structural mutation, which in its most general form is expressed as replacing a
range of elements, denoted by two indices, by elements from a collection with a
<strong>different</strong> length.</p>
<div class="highlight-python"><div class="highlight"><pre>public protocol RangeReplaceableCollectionType : MutableCollectionType {
  mutating func replaceRange&lt;
    C: CollectionType where C.Generator.Element == Self.Generator.Element
  &gt;(
    subRange: Range&lt;Index&gt;, with newElements: C
  )
}
</pre></div>
</div>
</div>
<div class="section" id="index-protocols">
<h3>Index Protocols<a class="headerlink" href="#index-protocols" title="Permalink to this headline">¶</a></h3>
<p>As a generalization designed to cover diverse data structures,
<code class="code docutils literal"><span class="pre">CollectionType</span></code> provides weaker guarantees than arrays do.  In
particular, an arbitrary collection does not necessarily offer
efficient random access; that property is determined by the protocol
conformances of its <code class="code docutils literal"><span class="pre">Index</span></code> type.</p>
<p><strong>Forward indices</strong> are the simplest and most general, capturing the
capabilities of indices into a singly-linked list:</p>
<ol class="arabic simple">
<li>advance to the next position</li>
<li>detect the end position</li>
</ol>
<p><strong>Bidirectional indices</strong> are a refinement of forward indices that
additionally support reverse traversal:</p>
<div class="highlight-python"><div class="highlight"><pre>protocol BidirectionalIndexType : ForwardIndexType {
  func predecessor() -&gt; Self
}
</pre></div>
</div>
<p>Indices into a doubly-linked list would be bidirectional, as are the
indices that address <code class="code docutils literal"><span class="pre">Character</span></code>s and <code class="code docutils literal"><span class="pre">UnicodeScalar</span></code>s in a
<code class="code docutils literal"><span class="pre">String</span></code>.  Reversing the order of a collection&#8217;s elements is a simple
example of a generic algorithm that depends on bidirectional traversal.</p>
<p><strong>Random access indices</strong> have two more requirements: the ability to
efficiently measure the number of steps between arbitrary indices
addressing the same collection, and the ability to advance an index by
a (possibly negative) number of steps:</p>
<div class="highlight-python"><div class="highlight"><pre>public protocol RandomAccessIndexType : BidirectionalIndexType {
  func distanceTo(other: Self) -&gt; Distance
  func advancedBy(n: Distance) -&gt; Self
}
</pre></div>
</div>
<p>From these methods, the standard library derives several other
features such as <code class="code docutils literal"><span class="pre">Comparable</span></code> conformance, index subtraction, and
addition/subtraction of integers to/from indices.</p>
<p>The indices of a <a class="reference external" href="http://en.wikipedia.org/wiki/Double-ended_queue">deque</a> can provide random
access, as do the indices into <code class="code docutils literal"><span class="pre">String.UTF16View</span></code> (when Foundation is
loaded) and, of course, array indices.  Many common sorting and
selection algorithms, among others, depend on these capabilities.</p>
<p>All direct operations on indices are intended to be lightweight, with
amortized O(1) complexity.  In fact, indices into <code class="code docutils literal"><span class="pre">Dictionary</span></code> and
<code class="code docutils literal"><span class="pre">Set</span></code> <em>could</em> be bidirectional, but are limited to modeling
<code class="code docutils literal"><span class="pre">ForwardIndexType</span></code> because the APIs of <code class="code docutils literal"><span class="pre">NSDictionary</span></code> and
<code class="code docutils literal"><span class="pre">NSSet</span></code>—which can act as backing stores of <code class="code docutils literal"><span class="pre">Dictionary</span></code> and <code class="code docutils literal"><span class="pre">Set</span></code>—do
not efficiently support reverse traversal.</p>
</div>
</div>
<div class="section" id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this headline">¶</a></h2>
<p>Swift&#8217;s sequence, collection, and index protocols allow us to write
general algorithms that apply to a wide variety of series and data
structures.  The system has been both easy to extend, and predictably
performant.  Thanks for taking the tour!</p>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="input-iterator" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>This trade-off is not as obvious as it might
seem.  For example, the C# and C++ analogues for <code class="code docutils literal"><span class="pre">GeneratorType</span></code>
(<code class="code docutils literal"><span class="pre">IEnumerable</span></code> and <code class="code docutils literal"><span class="pre">input</span> <span class="pre">iterator</span></code>) are saddled with the
obligation to provide buffering.</td></tr>
</tbody>
</table>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Serialization.html" class="btn btn-neutral float-right" title="Swift Binary Serialization Format" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="SIL.html" class="btn btn-neutral" title="Swift Intermediate Language (SIL)" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright apple.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.1.9',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>