

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Initializer Inheritance &mdash; Swift Programming Language documentation 0.1.9 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Swift Programming Language documentation 0.1.9 documentation" href="../index.html"/>
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>


  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Swift Programming Language documentation
          

          
          </a>

          
            
            
              <div class="version">
                0.1.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">swift docs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../ABI.html">The Swift ABI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ARCOptimization.html">ARC Optimization for Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="../AccessControl.html">Access Control</a></li>
<li class="toctree-l1"><a class="reference internal" href="../AccessControlInStdlib.html">Scope and introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../AccessControlInStdlib.html#public"><cite>public</cite></a></li>
<li class="toctree-l1"><a class="reference internal" href="../AccessControlInStdlib.html#internal"><cite>internal</cite></a></li>
<li class="toctree-l1"><a class="reference internal" href="../AccessControlInStdlib.html#private"><cite>private</cite></a></li>
<li class="toctree-l1"><a class="reference internal" href="../AccessControlInStdlib.html#leading-underscore-rule">Leading Underscore Rule</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Arrays.html">The Swift Array Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CallingConvention.html">The Swift Calling Convention</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DebuggingTheCompiler.html">Debugging the Swift Compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Dependency Analysis.html">Dependency Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DriverInternals.html">Driver Design &amp; Internals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DriverParseableOutput.html">Parseable Driver Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ErrorHandling.html">Error Handling in Swift 2.0</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ErrorHandlingRationale.html">Error Handling Rationale and Proposal</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Failable Initializers.html">Failable initializers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Generics.html">Generics in Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="../GitWorkflows.html">Git Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../GitWorkflows.html#svn-git-workflows">SVN -&gt; GIT Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HighLevelSILOptimizations.html">High-Level Optimizations in SIL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Import.html">IMPORT SYNTAX</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Import.html#resolving-name-clashes">RESOLVING NAME CLASHES</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Import.html#future-extensions">FUTURE EXTENSIONS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../IndexInvalidation.html">Index Invalidation Rules in the Swift Standard Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#using-versioned-api">Using Versioned API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#publishing-versioned-api">Publishing Versioned API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#giving-up-flexibility">Giving Up Flexibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#optimization">Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#resilience-domains">Resilience Domains</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#protocol-conformances">Protocol Conformances</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#checking-binary-compatibility">Checking Binary Compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#summary">Summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#glossary">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Literals.html">Literals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LogicalObjects.html">Logical Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Modules.html">High-Level Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Modules.html#import"><code class="docutils literal"><span class="pre">import</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../Modules.html#interoperability-with-objective-c-via-clang">Interoperability with Objective-C via Clang</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Modules.html#glossary">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../MutationModel.html">Immutability and Read-Only Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ObjectInitialization.html">Object Initialization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html">Writing High-Performance Swift Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#enabling-optimizations">Enabling Optimizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#whole-module-optimizations">Whole Module Optimizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#reducing-dynamic-dispatch">Reducing Dynamic Dispatch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#using-container-types-efficiently">Using Container Types Efficiently</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#unchecked-operations">Unchecked operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#generics">Generics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#the-cost-of-large-swift-values">The cost of large swift values</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#unsafe-code">Unsafe code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#protocols">Protocols</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#footnotes">Footnotes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Pattern Matching.html">Pattern Matching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SIL.html">Swift Intermediate Language (SIL)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SequencesAndCollections.html">Sequences And Collections in Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Serialization.html">Swift Binary Serialization Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="../StdlibAPIGuidelines.html">Swift Standard Library API Design Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../StdlibRationales.html">Rationales for the Swift standard library designs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../StoredAndComputedVariables.html">Stored and Computed Variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../StringDesign.html">Swift String Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Testing.html">Testing Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="../TextFormatting.html">Text Formatting in Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="../TransparentAttr.html"><code class="docutils literal"><span class="pre">&#64;_transparent</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../TypeChecker.html">Type Checker Design and Implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contents.html">Contents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../weak.html">Weak References</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">Swift Programming Language documentation</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
    <li>Initializer Inheritance</li>
    <li class="wy-breadcrumbs-aside">
      
        
          <a href="../_sources/proposals/InitializerInheritance.txt" rel="nofollow"> View page source</a>
        
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="initializer-inheritance">
<h1><a class="toc-backref" href="#id5">Initializer Inheritance</a><a class="headerlink" href="#initializer-inheritance" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body">Doug Gregor, John McCall</td>
</tr>
</tbody>
</table>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#initializer-inheritance" id="id5">Initializer Inheritance</a><ul>
<li><a class="reference internal" href="#introduction" id="id6">Introduction</a></li>
<li><a class="reference internal" href="#background" id="id7">Background</a><ul>
<li><a class="reference internal" href="#subobject-initializers" id="id8">Subobject initializers</a></li>
<li><a class="reference internal" href="#complete-object-initializers" id="id9">Complete object initializers</a></li>
<li><a class="reference internal" href="#guaranteed-initializers" id="id10">Guaranteed initializers</a></li>
<li><a class="reference internal" href="#virtual-initializers" id="id11">Virtual initializers</a></li>
</ul>
</li>
<li><a class="reference internal" href="#proposal" id="id12">Proposal</a><ul>
<li><a class="reference internal" href="#id1" id="id13">Complete object initializers</a></li>
<li><a class="reference internal" href="#id2" id="id14">Initializer inheritance</a></li>
<li><a class="reference internal" href="#id3" id="id15">Virtual initializers</a></li>
<li><a class="reference internal" href="#objective-c-interoperability" id="id16">Objective-C interoperability</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id6">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This proposal introduces the notion of initializer inheritance into
the Swift initialization model. The intent is to more closely model
Objective-C&#8217;s initializer inheritance model while maintaining memory
safety.</p>
</div>
<div class="section" id="background">
<h2><a class="toc-backref" href="#id7">Background</a><a class="headerlink" href="#background" title="Permalink to this headline">¶</a></h2>
<p>An initializer is a definition, and it belongs to the class that
defines it.  However, it also has a signature, and it makes sense to
talk about other initializers in related classes that share that
signature.</p>
<p>Initializers come in two basic kinds: complete object and subobject.
That is, an initializer either takes responsibility for initializing
the complete object, potentially including derived class subobjects,
or it takes responsibility for initializing only the subobjects of its
class and its superclasses.</p>
<p>There are three kinds of delegation:</p>
<ul class="simple">
<li><strong>super</strong>: runs an initializer belonging to a superclass (in ObjC,
<code class="docutils literal"><span class="pre">[super</span> <span class="pre">init…]</span></code>; in Swift, <code class="docutils literal"><span class="pre">super.init(...)</span></code>).</li>
<li><strong>peer</strong>:  runs an initializer belonging to the current class (ObjC
does not have syntax for this, although it is supported by the
runtime; in Swift, the current meaning of <code class="docutils literal"><span class="pre">self.init(...)</span></code>)</li>
<li><strong>dispatched</strong>: given a signature, runs the initializer with that
signature that is either defined or inherited by the most-derived
class (in ObjC, <code class="docutils literal"><span class="pre">[self</span> <span class="pre">init…]</span></code>; not currently supported by Swift)</li>
</ul>
<p>We can also distinguish two ways to originally invoke an initializer:</p>
<ul class="simple">
<li><strong>direct</strong>: the most-derived class is statically known</li>
<li><strong>indirect</strong>: the most-derived class is not statically known and
an initialization must be dispatched</li>
</ul>
<p>Either kind of dispatched initialization poses a soundness problem
because there may not be a sound initializer with any given signature
in the most-derived class.  In ObjC, initializers are normal instance
methods and are therefore inherited like normal, but this isn’t really
quite right; initialization is different from a normal method in that
it’s not inherently sensible to require subclasses to provide
initializers at all the signatures that their superclasses provide.</p>
<div class="section" id="subobject-initializers">
<h3><a class="toc-backref" href="#id8">Subobject initializers</a><a class="headerlink" href="#subobject-initializers" title="Permalink to this headline">¶</a></h3>
<p>The defining class of a subobject initializer is central to its
behavior.  It can be soundly inherited by a class C only if is trivial
to initialize the ivars of C, but it’s convenient to ignore that and
assume that subobjects will always trivially wrap and delegate to
superclass subobject initializers.</p>
<p>A subobject initializer must either (1) delegate to a peer subobject
initializer or (2) take responsibility for initializing all ivars of
its defining class and delegate to a subobject initializer of its
superclass.  It cannot initialize any ivars of its defining class if
it then delegates to a peer subobject initializer, although it can
re-assign ivars after initialization completes.</p>
<p>A subobject initializer soundly acts like a complete object
initializer of a class C if and only if it is defined by C.</p>
</div>
<div class="section" id="complete-object-initializers">
<h3><a class="toc-backref" href="#id9">Complete object initializers</a><a class="headerlink" href="#complete-object-initializers" title="Permalink to this headline">¶</a></h3>
<p>The defining class of a complete object initializer doesn’t really
matter.  In principle, complete object initializers could just as well
be freestanding functions to which a metatype is passed.  It can make
sense to inherit a complete object initializer.</p>
<p>A complete object initializer must either (1) delegate (in any way) to
another complete object initializer or (2) delegate (dispatched) to a
subobject initializer of the most-derived class.  It may not
initialize any ivars, although it can re-assign them after
initialization completes.</p>
<p>A complete object initializer soundly acts like a complete object
initializer of a class C if and only if it delegates to an initializer
which soundly acts like a complete object initializer of C.</p>
<p>These rules are not obvious to check statically because they’re
dependent on the dynamic value of the most-derived class C.  Therefore
any ability to check them depends on restricting C somehow relative to
the defining class of the initializer.  Since, statically, we only
know the defining class of the initializer, we can’t establish
soundness solely at the definition site; instead we have to prevent
unsound initializers from being called.</p>
</div>
<div class="section" id="guaranteed-initializers">
<h3><a class="toc-backref" href="#id10">Guaranteed initializers</a><a class="headerlink" href="#guaranteed-initializers" title="Permalink to this headline">¶</a></h3>
<p>The chief soundness question comes back to dispatched initialization:
when can we reasonably assume that the most-derived class provides an
initializer with a given signature?</p>
<p>Only a complete object initializer can perform dispatched delegation.
A dispatched delegation which invokes another complete object
initializer poses no direct soundness issues.  The dynamic requirement
for soundness is that, eventually, the chain of dispatches leads to a
subobject initializer that soundly acts like a complete object
initializer of the most-derived class.</p>
</div>
<div class="section" id="virtual-initializers">
<h3><a class="toc-backref" href="#id11">Virtual initializers</a><a class="headerlink" href="#virtual-initializers" title="Permalink to this headline">¶</a></h3>
<p>The above condition is not sufficient to make indirect initialization
sound, because it relies on the ability to simply not use an
initializer in cases where its delegation behavior isn&#8217;t known to be
sound, and we can’t do that to arbitrary code.  For that, we would
need true virtual initializers.</p>
<p>A virtual initializer is a contract much more like that of a standard
virtual method: it guarantees that every subclass will either define
or inherit a constructor with a given signature, which is easy to
check at the time of definition of the subclass.</p>
</div>
</div>
<div class="section" id="proposal">
<h2><a class="toc-backref" href="#id12">Proposal</a><a class="headerlink" href="#proposal" title="Permalink to this headline">¶</a></h2>
<p>Currently, all Swift initializers are subobject initializers, and
there is no way to express the notion of a complete subobject
initializer. We propose to introduce complete subobject initializers
into Swift and to make them inheritable when we can guarantee that
doing so is safe.</p>
<div class="section" id="id1">
<h3><a class="toc-backref" href="#id13">Complete object initializers</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>Introduce the notion of a complete object initializer, which is
written as an initializer with <code class="docutils literal"><span class="pre">Self</span></code> as its return type [#], e.g.:</p>
<div class="highlight-python"><div class="highlight"><pre>init() -&gt; Self {
  // ...
}
</pre></div>
</div>
<p>The use of <code class="docutils literal"><span class="pre">Self</span></code> here fits well with dynamic <code class="docutils literal"><span class="pre">Self</span></code>, because a
complete object initializer returns an instance of the dynamic type
being initialized (rather than the type that defines the initializer).</p>
<p>A complete object initializer must delegate to another initializer via
<code class="docutils literal"><span class="pre">self.init</span></code>, which may itself be either a subobject initializer or a
complete object initializer. The delegation itself is dispatched. For
example:</p>
<div class="highlight-python"><div class="highlight"><pre>class A {
  var title: String

  init() -&gt; Self { // complete object initializer
    self.init(withTitle:&quot;The Next Great American Novel&quot;)
  }

  init withTitle(title: String) { // subobject initializer
    self.title = title
  }
}
</pre></div>
</div>
<p>Subobject initializers become more restricted. They must initialize
A&#8217;s instance variables and then perform super delegation to a
subobject initializer of the superclass (if any).</p>
</div>
<div class="section" id="id2">
<h3><a class="toc-backref" href="#id14">Initializer inheritance</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>A class inherits the complete object initializers of its direct
superclass when it overrides all of the subobject initializers of its
direct superclass. Subobject initializers are never inherited. Some
examples:</p>
<div class="highlight-python"><div class="highlight"><pre>class B1 : A {
  var counter: Int

  init withTitle(title: String) { // subobject initializer
    counter = 0
    super.init(withTitle:title)
  }

  // inherits A&#39;s init()
}

class B2 : A {
  var counter: Int

  init withTitle(title: String) -&gt; Self { // complete object initializer
    self.init(withTitle: title, initialCount: 0)
  }

  init withTitle(title: String) initialCount(Int) { // subobject initializer
    counter = initialCount
    super.init(withTitle:title)
  }

  // inherits A&#39;s init()
}

class B3 : A {
  var counter: Int

  init withInitialCount(initialCount: Int)  { // subobject initializer
    counter = initialCount
    super.init(withTitle: &quot;Unnamed&quot;)
  }

  init withStringCount(str: String) -&gt; Self { // complete object initializer
    var initialCount = 0
    if let count = str.toInt() { initialCount = count }
    self.init(withInitialCount: initialCount)
  }

  // does not inherit A&#39;s init(), because init withTitle(String) is not
  // overridden.
}
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">B3</span></code> does not override <code class="docutils literal"><span class="pre">A</span></code>&#8216;s subobject initializer, so it does not
inherit <code class="docutils literal"><span class="pre">init()</span></code>. Classes <code class="docutils literal"><span class="pre">B1</span></code> and <code class="docutils literal"><span class="pre">B2</span></code>, however, both inherit
the initializer <code class="docutils literal"><span class="pre">init()</span></code> from <code class="docutils literal"><span class="pre">A</span></code>, because both override its only
subobject initializer, <code class="docutils literal"><span class="pre">init</span> <span class="pre">withTitle(String)</span></code>. This means that one
can construct either a <code class="docutils literal"><span class="pre">B1</span></code> or a <code class="docutils literal"><span class="pre">B2</span></code> with no arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">B1</span><span class="p">()</span> <span class="o">//</span> <span class="n">okay</span>
<span class="n">B2</span><span class="p">()</span> <span class="o">//</span> <span class="n">okay</span>
<span class="n">B3</span><span class="p">()</span> <span class="o">//</span> <span class="n">error</span>
</pre></div>
</div>
<p>That <code class="docutils literal"><span class="pre">B1</span></code> uses a subobject initializer to override it&#8217;s superclass&#8217;s
subobject initializer while <code class="docutils literal"><span class="pre">B2</span></code> uses a complete object initializer
has an effect on future subclasses. A few more examples:</p>
<div class="highlight-python"><div class="highlight"><pre>class C1 : B1 {
  init withTitle(title: String) { // subobject initializer
    super.init(withTitle:title)
  }

  init withTitle(title: String) initialCount(Int) { // subobject initializer
    counter = initialCount
    super.init(withTitle:title)
  }
}

class C2 : B2 {
  init withTitle(title: String) initialCount(Int) { // subobject initializer
    super.init(withTitle: title, initialCount:initialCount)
  }

  // inherits A&#39;s init(), B2&#39;s init withTitle(String)
}

class C3 : B3 {
  init withInitialCount(initialCount: Int) { // subobject initializer
    super.init(withInitialCount: initialCount)
  }

  // inherits B3&#39;s init withStringCount(str: String)
  // does not inherit A&#39;s init()
}
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h3><a class="toc-backref" href="#id15">Virtual initializers</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>With the initializer inheritance rules described above, there is no
guarantee that one can dynamically dispatch to an initializer via a
metatype of the class. For example:</p>
<div class="highlight-python"><div class="highlight"><pre>class D {
  init() { }
}

func f(meta: D.Type) {
  meta() // error: no guarantee that an arbitrary of subclass D has an init()
}
</pre></div>
</div>
<p>Virtual initializers, which are initializers that have the <code class="docutils literal"><span class="pre">virtual</span></code>
attribute, are guaranteed to be available in every subclass of
<code class="docutils literal"><span class="pre">D</span></code>. For example, if <code class="docutils literal"><span class="pre">D</span></code> was written as:</p>
<div class="highlight-python"><div class="highlight"><pre>class D {
  @virtual init() { }
}

func f(meta: D.Type) {
  meta() // okay: every subclass of D guaranteed to have an init()
}
</pre></div>
</div>
<p>Note that <code class="docutils literal"><span class="pre">&#64;virtual</span></code> places a requirement on all subclasses to
ensure that an initializer with the same signature is available in
every subclass. For example:</p>
<div class="highlight-python"><div class="highlight"><pre>class E1 : D {
  var title: String

  // error: E1 must provide init()
}

class E2 : D {
  var title: String

  @virtual init() {
    title = &quot;Unnamed&quot;
    super.init()
  }

  // okay, init() is available here
}

class E3 : D {
  var title: String

  @virtual init() -&gt; Self {
    self.init(withTitle: &quot;Unnamed&quot;)
  }

  init withTitle(title: String) {
    self.title = title
    super.init()
  }
}
</pre></div>
</div>
<p>Whether an initializer is virtual is orthogonal to whether it is a
complete object or subobject initializer. However, an inherited
complete object initializer can be used to satisfy the requirement for
a virtual requirement. For example, <code class="docutils literal"><span class="pre">E3</span></code>&#8216;s subclasses need not
provide an <code class="docutils literal"><span class="pre">init()</span></code> if they override <code class="docutils literal"><span class="pre">init</span> <span class="pre">withTitle(String)</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>class F3A : E3 {
  init withTitle(title: String) {
    super.init(withTitle: title)
  }

  // okay: inherited ``init()`` from E3 satisfies requirement for virtual init()
}

class F3B : E3 {
  // error: requirement for virtual init() not satisfied, because it is neither defined nor inherited
}

class F3C : E3 {
  @virtual init() {
    super.init(withTitle: &quot;TSPL&quot;)
  }

  // okay: satisfies requirement for virtual init().
}
</pre></div>
</div>
</div>
<div class="section" id="objective-c-interoperability">
<h3><a class="toc-backref" href="#id16">Objective-C interoperability</a><a class="headerlink" href="#objective-c-interoperability" title="Permalink to this headline">¶</a></h3>
<p>When an Objective-C class that contains at least one
designated-initializer annotation (i.e., via
<code class="docutils literal"><span class="pre">NS_DESIGNATED_INITIALIZER</span></code>) is imported into Swift, it&#8217;s designated
initializers are considered subobject initializers. Any non-designed
initializers (i.e., secondary or convenience initializers) are
considered to be complete object initializers. No other special-case
behavior is warranted here.</p>
<p>When an Objective-C class with no designated-initializer annotations
is imported into Swift, all initializers in the same module as the
class definition are subobject initializers, while initializers in a
different module are complete object initializers. This effectively
means that subclassing Objective-C classes without designated-initializer
annotations will provide little or no initializer inheritance, because
one would have to override nearly <em>all</em> of its initializers before
getting the others inherited. This seems acceptable so long as we get
designated-initializer annotations into enough of the SDK.</p>
<p>In Objective-C, initializers are always inherited, so an error of
omission on the Swift side (failing to override a subobject
initializer from a superclass) can result in runtime errors if an
Objective-C framework messages that initializer. For example, consider
a trivial <code class="docutils literal"><span class="pre">NSDocument</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>class MyDocument : NSDocument {
  var title: String
}
</pre></div>
</div>
<p>In Swift, there would be no way to create an object of type
<code class="docutils literal"><span class="pre">MyDocument</span></code>. However, the frameworks will allocate an instance of
<code class="docutils literal"><span class="pre">MyDocument</span></code> and then send an message such as
<code class="docutils literal"><span class="pre">initWithContentsOfURL:ofType:error:</span></code> to the object. This will find
<code class="docutils literal"><span class="pre">-[NSDocument</span> <span class="pre">initWithContentsOfURL:ofType:error:]</span></code>, which delegates
to <code class="docutils literal"><span class="pre">-[NSDocument</span> <span class="pre">init]</span></code>, leaving <code class="docutils literal"><span class="pre">MyDocument</span></code>&#8216;s stored properties
uninitialized.</p>
<p>We can improve the experience slightly by producing a diagnostic when
there are no initializers for a given class. However, a more
comprehensive approach is to emit Objective-C entry points for each of
the subobject initializers of the direct superclass that have not been
implemented. These entry points would immediately abort with some
diagnostic indicating that the initializer needs to be
implemented.</p>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Syntax suggestion from Joe Groff.</td></tr>
</tbody>
</table>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright apple.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.1.9',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>