

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The Pointer Types &mdash; Swift Programming Language documentation 0.1.9 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Swift Programming Language documentation 0.1.9 documentation" href="../index.html"/>
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>


  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Swift Programming Language documentation
          

          
          </a>

          
            
            
              <div class="version">
                0.1.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">swift docs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../ABI.html">The Swift ABI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ARCOptimization.html">ARC Optimization for Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="../AccessControl.html">Access Control</a></li>
<li class="toctree-l1"><a class="reference internal" href="../AccessControlInStdlib.html">Scope and introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../AccessControlInStdlib.html#public"><cite>public</cite></a></li>
<li class="toctree-l1"><a class="reference internal" href="../AccessControlInStdlib.html#internal"><cite>internal</cite></a></li>
<li class="toctree-l1"><a class="reference internal" href="../AccessControlInStdlib.html#private"><cite>private</cite></a></li>
<li class="toctree-l1"><a class="reference internal" href="../AccessControlInStdlib.html#leading-underscore-rule">Leading Underscore Rule</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Arrays.html">The Swift Array Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CallingConvention.html">The Swift Calling Convention</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DebuggingTheCompiler.html">Debugging the Swift Compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Dependency Analysis.html">Dependency Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DriverInternals.html">Driver Design &amp; Internals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DriverParseableOutput.html">Parseable Driver Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ErrorHandling.html">Error Handling in Swift 2.0</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ErrorHandlingRationale.html">Error Handling Rationale and Proposal</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Failable Initializers.html">Failable initializers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Generics.html">Generics in Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="../GitWorkflows.html">Git Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../GitWorkflows.html#svn-git-workflows">SVN -&gt; GIT Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HighLevelSILOptimizations.html">High-Level Optimizations in SIL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Import.html">IMPORT SYNTAX</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Import.html#resolving-name-clashes">RESOLVING NAME CLASHES</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Import.html#future-extensions">FUTURE EXTENSIONS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../IndexInvalidation.html">Index Invalidation Rules in the Swift Standard Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#using-versioned-api">Using Versioned API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#publishing-versioned-api">Publishing Versioned API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#giving-up-flexibility">Giving Up Flexibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#optimization">Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#resilience-domains">Resilience Domains</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#protocol-conformances">Protocol Conformances</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#checking-binary-compatibility">Checking Binary Compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#summary">Summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#glossary">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Literals.html">Literals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LogicalObjects.html">Logical Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Modules.html">High-Level Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Modules.html#import"><code class="docutils literal"><span class="pre">import</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../Modules.html#interoperability-with-objective-c-via-clang">Interoperability with Objective-C via Clang</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Modules.html#glossary">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../MutationModel.html">Immutability and Read-Only Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ObjectInitialization.html">Object Initialization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html">Writing High-Performance Swift Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#enabling-optimizations">Enabling Optimizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#whole-module-optimizations">Whole Module Optimizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#reducing-dynamic-dispatch">Reducing Dynamic Dispatch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#using-container-types-efficiently">Using Container Types Efficiently</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#unchecked-operations">Unchecked operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#generics">Generics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#the-cost-of-large-swift-values">The cost of large swift values</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#unsafe-code">Unsafe code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#protocols">Protocols</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#footnotes">Footnotes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Pattern Matching.html">Pattern Matching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SIL.html">Swift Intermediate Language (SIL)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SequencesAndCollections.html">Sequences And Collections in Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Serialization.html">Swift Binary Serialization Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="../StdlibAPIGuidelines.html">Swift Standard Library API Design Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../StdlibRationales.html">Rationales for the Swift standard library designs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../StoredAndComputedVariables.html">Stored and Computed Variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../StringDesign.html">Swift String Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Testing.html">Testing Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="../TextFormatting.html">Text Formatting in Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="../TransparentAttr.html"><code class="docutils literal"><span class="pre">&#64;_transparent</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../TypeChecker.html">Type Checker Design and Implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contents.html">Contents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../weak.html">Weak References</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">Swift Programming Language documentation</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
    <li>The Pointer Types</li>
    <li class="wy-breadcrumbs-aside">
      
        
          <a href="../_sources/proposals/C Pointer Interop Language Model.txt" rel="nofollow"> View page source</a>
        
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <p>We have a pretty good user model for C pointer interop now, but the language
model still needs improvement. Building the user model on top of implicit
conversions has a number of undesirable side effects. We end up with a mess of
pointer types—the intended user-facing, one-word pointer types
<code class="docutils literal"><span class="pre">UnsafeMutablePointer</span></code> and <code class="docutils literal"><span class="pre">COpaquePointer</span></code>, which expose a full pointer-ish API
and are naturally ABI-compatible with C pointers; and the bridging pointer
types, <code class="docutils literal"><span class="pre">ObjCMutablePointer</span></code>, <code class="docutils literal"><span class="pre">CMutablePointer</span></code>, <code class="docutils literal"><span class="pre">CConstPointer</span></code>,
<code class="docutils literal"><span class="pre">CMutableVoidPointer</span></code>, and <code class="docutils literal"><span class="pre">CConstVoidPointer</span></code>, which have no real API yet
but exist only to carry an owner reference and be implicitly convertible, and
rely on compiler magic to be passed to C functions. Since we can do the magic
pointer bridging only in limited places, we assault users writing method
overrides and reading synthesized headers with both sets of pointer types in a
confusing jumble.</p>
<p>The best solution to this is to burn the user model into the language, giving
function applications special powers to provide the user model for pointers. We
then provide only one set of plain pointer types, with
special intrinsic behavior when used as function arguments.</p>
<div class="section" id="the-pointer-types">
<h1>The Pointer Types<a class="headerlink" href="#the-pointer-types" title="Permalink to this headline">¶</a></h1>
<p>In the standard library, we provide three pointer types:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">UnsafePointer&lt;T&gt;</span></code>, corresponding to <code class="docutils literal"><span class="pre">T</span> <span class="pre">const</span> <span class="pre">*</span></code> in C and ARC,</li>
<li><code class="docutils literal"><span class="pre">UnsafeMutablePointer&lt;T&gt;</span></code>, corresponding to <code class="docutils literal"><span class="pre">T</span> <span class="pre">*</span></code> in C, and <code class="docutils literal"><span class="pre">T*</span> <span class="pre">__strong</span> <span class="pre">*</span></code> in
ARC for class types, and</li>
<li><code class="docutils literal"><span class="pre">AutoreleasingUnsafeMutablePointer&lt;T&gt;</span></code> (for all <code class="docutils literal"><span class="pre">T:</span> <span class="pre">AnyObject</span></code>), corresponding
to <code class="docutils literal"><span class="pre">T*</span> <span class="pre">__autoreleasing</span> <span class="pre">*</span></code> in ARC.</li>
</ul>
<p>These types are all one word, have no ownership semantics, and share a common
interface. <code class="docutils literal"><span class="pre">UnsafePointer</span></code> does not expose operations for storing to the
referenced memory. <code class="docutils literal"><span class="pre">UnsafeMutablePointer</span></code> and <code class="docutils literal"><span class="pre">AutoreleasingUnsafeMutablePointer</span></code> differ
in store behavior: <code class="docutils literal"><span class="pre">UnsafeMutablePointer</span></code> assumes that the pointed-to reference has
ownership semantics, so <code class="docutils literal"><span class="pre">ptr.initialize(x)</span></code> consumes a reference to <code class="docutils literal"><span class="pre">x</span></code>,
and <code class="docutils literal"><span class="pre">ptr.assign(x)</span></code> releases the originally stored value before storing the
new value.  <code class="docutils literal"><span class="pre">AutoreleasingUnsafeMutablePointer</span></code> assumes that the pointed-to
reference does not have ownership semantics, so values are autoreleased before
being stored by either initialize() or assign(), and no release is done on
reassignment. Loading from any of the three kinds of pointer does a strong
load, so there is no need for a separate <code class="docutils literal"><span class="pre">AutoreleasingUnsafePointer</span></code>.</p>
</div>
<div class="section" id="conversion-behavior-for-pointer-arguments">
<h1>Conversion behavior for pointer arguments<a class="headerlink" href="#conversion-behavior-for-pointer-arguments" title="Permalink to this headline">¶</a></h1>
<p>The user model for pointer arguments becomes an inherent capability of function applications. The rules are:</p>
<div class="section" id="unsafemutablepointer-t">
<h2>UnsafeMutablePointer&lt;T&gt;<a class="headerlink" href="#unsafemutablepointer-t" title="Permalink to this headline">¶</a></h2>
<p>When a function is declared as taking an <code class="docutils literal"><span class="pre">UnsafeMutablePointer&lt;T&gt;</span></code> argument, it can
accept any of the following:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">nil</span></code>, which is passed as a null pointer,</li>
<li>an <code class="docutils literal"><span class="pre">UnsafeMutablePointer&lt;T&gt;</span></code> value, which is passed verbatim,</li>
<li>an inout expression whose operand is a stored lvalue of type <code class="docutils literal"><span class="pre">T</span></code>, which is
passed as the address of the lvalue, or</li>
<li>an inout <code class="docutils literal"><span class="pre">Array&lt;T&gt;</span></code> value, which is passed as a pointer to the start of the
array, and lifetime-extended for the duration of the callee.</li>
</ul>
<p>As a special case, when a function is declared as taking an
<code class="docutils literal"><span class="pre">UnsafeMutablePointer&lt;Void&gt;</span></code> argument, it can accept the same operands as
<code class="docutils literal"><span class="pre">UnsafeMutablePointer&lt;T&gt;</span></code> for any type T.</p>
<p>So if you have a function declared:</p>
<div class="highlight-python"><div class="highlight"><pre>func foo(x: UnsafeMutablePointer&lt;Float&gt;)
</pre></div>
</div>
<p>You can call it as any of:</p>
<div class="highlight-python"><div class="highlight"><pre>var x: Float = 0.0
var p: UnsafeMutablePointer&lt;Float&gt; = nil
var a: Float[] = [1.0, 2.0, 3.0]
foo(nil)
foo(p)
foo(&amp;x)
foo(&amp;a)
</pre></div>
</div>
<p>And if you have a function declared:</p>
<div class="highlight-python"><div class="highlight"><pre>func bar(x: UnsafeMutablePointer&lt;Void&gt;)
</pre></div>
</div>
<p>You can call it as any of:</p>
<div class="highlight-python"><div class="highlight"><pre>var x: Float = 0.0, y: Int = 0
var p: UnsafeMutablePointer&lt;Float&gt; = nil, q: UnsafeMutablePointer&lt;Int&gt; = nil
var a: Float[] = [1.0, 2.0, 3.0], b: Int = [1, 2, 3]
bar(nil)
bar(p)
bar(q)
bar(&amp;x)
bar(&amp;y)
bar(&amp;a)
bar(&amp;b)
</pre></div>
</div>
</div>
<div class="section" id="autoreleasingunsafemutablepointer-t">
<h2>AutoreleasingUnsafeMutablePointer&lt;T&gt;<a class="headerlink" href="#autoreleasingunsafemutablepointer-t" title="Permalink to this headline">¶</a></h2>
<p>When a function is declared as taking an <code class="docutils literal"><span class="pre">AutoreleasingUnsafeMutablePointer&lt;T&gt;</span></code>, it
can accept any of the following:</p>
<ul class="simple">
<li>nil, which is passed as a null pointer,</li>
<li>an <code class="docutils literal"><span class="pre">AutoreleasingUnsafeMutablePointer&lt;T&gt;</span></code> value, which is passed verbatim, or</li>
<li>an inout expression, whose operand is primitive-copied to a temporary
nonowning buffer. The address of that buffer is passed to the callee, and on
return, the value in the buffer is loaded, retained, and reassigned into the
operand.</li>
</ul>
<p>Note that the above list does not include arrays, since implicit autoreleasing-to-strong writeback of an entire array would probably not be desirable.</p>
<p>So if you have a function declared:</p>
<div class="highlight-python"><div class="highlight"><pre>func bas(x: AutoreleasingUnsafeMutablePointer&lt;NSBas?&gt;)
</pre></div>
</div>
<p>You can call it as any of:</p>
<div class="highlight-python"><div class="highlight"><pre>var x: NSBas? = nil
var p: AutoreleasingUnsafeMutablePointer&lt;NSBas?&gt; = nil
bas(nil)
bas(p)
bas(&amp;x)
</pre></div>
</div>
</div>
<div class="section" id="unsafepointer-t">
<h2>UnsafePointer&lt;T&gt;<a class="headerlink" href="#unsafepointer-t" title="Permalink to this headline">¶</a></h2>
<p>When a function is declared as taking an <code class="docutils literal"><span class="pre">UnsafeMutablePointer&lt;T&gt;</span></code> argument, it can
accept any of the following:</p>
<ul class="simple">
<li>nil, which is passed as a null pointer,</li>
<li>an <code class="docutils literal"><span class="pre">UnsafeMutablePointer&lt;T&gt;</span></code>, <code class="docutils literal"><span class="pre">UnsafePointer&lt;T&gt;</span></code>, or
<code class="docutils literal"><span class="pre">AutoreleasingUnsafeMutablePointer&lt;T&gt;</span></code> value, which is converted to
<code class="docutils literal"><span class="pre">UnsafePointer&lt;T&gt;</span></code> if necessary and passed verbatim,</li>
<li>an inout expression whose operand is an lvalue of type <code class="docutils literal"><span class="pre">T</span></code>, which is passed
as the address of (the potentially temporary writeback buffer of) the lvalue,
or</li>
<li>an <code class="docutils literal"><span class="pre">Array&lt;T&gt;</span></code> value, which is passed as a pointer to the start of the
array, and lifetime-extended for the duration of the callee.</li>
</ul>
<p>As a special case, when a function is declared as taking an
<code class="docutils literal"><span class="pre">UnsafePointer&lt;Void&gt;</span></code> argument, it can accept the same operands as
<code class="docutils literal"><span class="pre">UnsafePointer&lt;T&gt;</span></code> for any type <code class="docutils literal"><span class="pre">T</span></code>. Pointers to certain integer
types can furthermore interoperate with strings; see <a class="reference internal" href="#strings">Strings</a> below.</p>
<p>So if you have a function declared:</p>
<div class="highlight-python"><div class="highlight"><pre>func zim(x: UnsafePointer&lt;Float&gt;)
</pre></div>
</div>
<p>You can call it as any of:</p>
<div class="highlight-python"><div class="highlight"><pre>var x: Float = 0.0
var p: UnsafePointer&lt;Float&gt; = nil
zim(nil)
zim(p)
zim(&amp;x)
zim([1.0, 2.0, 3.0])
</pre></div>
</div>
<p>And if you have a function declared:</p>
<div class="highlight-python"><div class="highlight"><pre>func zang(x: UnsafePointer&lt;Void&gt;)
</pre></div>
</div>
<p>You can call it as any of:</p>
<div class="highlight-python"><div class="highlight"><pre>var x: Float = 0.0, y: Int = 0
var p: UnsafePointer&lt;Float&gt; = nil, q: UnsafePointer&lt;Int&gt; = nil
zang(nil)
zang(p)
zang(q)
zang(&amp;x)
zang(&amp;y)
let doubles = [1.0, 2.0, 3.0]
let ints = [1, 2, 3]
zang(doubles)
zang(ints)
</pre></div>
</div>
<p>A type checker limitation prevents array literals from being passed directly
to <code class="docutils literal"><span class="pre">UnsafePointer&lt;Void&gt;</span></code> arguments without type annotation. As a
workaround, you can bind the array literal to a constant, as above, or
specify the array type with <code class="docutils literal"><span class="pre">as</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>zang([1.0, 2.0, 3.0] as [Double])
zang([1, 2, 3] as [Int])
</pre></div>
</div>
<p>This limitation is tracked as &lt;<a class="reference external" href="rdar://problem/17444930">rdar://problem/17444930</a>&gt;.</p>
</div>
</div>
<div class="section" id="strings">
<h1>Strings<a class="headerlink" href="#strings" title="Permalink to this headline">¶</a></h1>
<p>Pointers to the following C integer and character types can interoperate with
Swift <code class="docutils literal"><span class="pre">String</span></code> values and string literals:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">CChar</span></code>, <code class="docutils literal"><span class="pre">CSignedChar</span></code>, and <code class="docutils literal"><span class="pre">CUnsignedChar</span></code>, which interoperate with
<code class="docutils literal"><span class="pre">String</span></code> as a UTF-8 code unit array;</li>
<li>(not implemented yet) <code class="docutils literal"><span class="pre">CShort</span></code>, <code class="docutils literal"><span class="pre">CUnsignedShort</span></code>, and <code class="docutils literal"><span class="pre">CChar16</span></code>, which interoperate with
<code class="docutils literal"><span class="pre">String</span></code> as a UTF-16 code unit array; and</li>
<li>(not implemented yet) <code class="docutils literal"><span class="pre">CInt</span></code>, <code class="docutils literal"><span class="pre">CUnsignedInt</span></code>, <code class="docutils literal"><span class="pre">CWideChar</span></code>, and <code class="docutils literal"><span class="pre">CChar32</span></code>, which interoperate
with <code class="docutils literal"><span class="pre">String</span></code> as a UTF-32 code unit array.</li>
</ul>
<p>A <code class="docutils literal"><span class="pre">UnsafePointer</span></code> parameter with any of the above element types may take
a <code class="docutils literal"><span class="pre">String</span></code> value as an argument. The string is transcoded to a null-terminated
buffer of the appropriate encoding, if necessary, and a pointer to the buffer
is passed to the function.  The callee may not mutate through the array, and
the referenced memory is only guaranteed to live for the duration of the call.</p>
</div>


           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright apple.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.1.9',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>