

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Option Sets &mdash; Swift Programming Language documentation 0.1.9 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Swift Programming Language documentation 0.1.9 documentation" href="../index.html"/>
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>


  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Swift Programming Language documentation
          

          
          </a>

          
            
            
              <div class="version">
                0.1.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">swift docs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../ABI.html">The Swift ABI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ARCOptimization.html">ARC Optimization for Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="../AccessControl.html">Access Control</a></li>
<li class="toctree-l1"><a class="reference internal" href="../AccessControlInStdlib.html">Scope and introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../AccessControlInStdlib.html#public"><cite>public</cite></a></li>
<li class="toctree-l1"><a class="reference internal" href="../AccessControlInStdlib.html#internal"><cite>internal</cite></a></li>
<li class="toctree-l1"><a class="reference internal" href="../AccessControlInStdlib.html#private"><cite>private</cite></a></li>
<li class="toctree-l1"><a class="reference internal" href="../AccessControlInStdlib.html#leading-underscore-rule">Leading Underscore Rule</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Arrays.html">The Swift Array Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CallingConvention.html">The Swift Calling Convention</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DebuggingTheCompiler.html">Debugging the Swift Compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Dependency Analysis.html">Dependency Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DriverInternals.html">Driver Design &amp; Internals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DriverParseableOutput.html">Parseable Driver Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ErrorHandling.html">Error Handling in Swift 2.0</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ErrorHandlingRationale.html">Error Handling Rationale and Proposal</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Failable Initializers.html">Failable initializers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Generics.html">Generics in Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="../GitWorkflows.html">Git Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../GitWorkflows.html#svn-git-workflows">SVN -&gt; GIT Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HighLevelSILOptimizations.html">High-Level Optimizations in SIL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Import.html">IMPORT SYNTAX</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Import.html#resolving-name-clashes">RESOLVING NAME CLASHES</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Import.html#future-extensions">FUTURE EXTENSIONS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../IndexInvalidation.html">Index Invalidation Rules in the Swift Standard Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#using-versioned-api">Using Versioned API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#publishing-versioned-api">Publishing Versioned API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#giving-up-flexibility">Giving Up Flexibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#optimization">Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#resilience-domains">Resilience Domains</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#protocol-conformances">Protocol Conformances</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#checking-binary-compatibility">Checking Binary Compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#summary">Summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#glossary">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Literals.html">Literals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LogicalObjects.html">Logical Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Modules.html">High-Level Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Modules.html#import"><code class="docutils literal"><span class="pre">import</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../Modules.html#interoperability-with-objective-c-via-clang">Interoperability with Objective-C via Clang</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Modules.html#glossary">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../MutationModel.html">Immutability and Read-Only Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ObjectInitialization.html">Object Initialization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html">Writing High-Performance Swift Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#enabling-optimizations">Enabling Optimizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#whole-module-optimizations">Whole Module Optimizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#reducing-dynamic-dispatch">Reducing Dynamic Dispatch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#using-container-types-efficiently">Using Container Types Efficiently</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#unchecked-operations">Unchecked operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#generics">Generics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#the-cost-of-large-swift-values">The cost of large swift values</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#unsafe-code">Unsafe code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#protocols">Protocols</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#footnotes">Footnotes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Pattern Matching.html">Pattern Matching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SIL.html">Swift Intermediate Language (SIL)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SequencesAndCollections.html">Sequences And Collections in Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Serialization.html">Swift Binary Serialization Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="../StdlibAPIGuidelines.html">Swift Standard Library API Design Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../StdlibRationales.html">Rationales for the Swift standard library designs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../StoredAndComputedVariables.html">Stored and Computed Variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../StringDesign.html">Swift String Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Testing.html">Testing Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="../TextFormatting.html">Text Formatting in Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="../TransparentAttr.html"><code class="docutils literal"><span class="pre">&#64;_transparent</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../TypeChecker.html">Type Checker Design and Implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contents.html">Contents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../weak.html">Weak References</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">Swift Programming Language documentation</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
    <li>Option Sets</li>
    <li class="wy-breadcrumbs-aside">
      
        
          <a href="../_sources/proposals/OptionSets.txt" rel="nofollow"> View page source</a>
        
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <p>SUMMARY: Option sets should be structs of Bools, with a protocol to provide
bitwise-ish operations.</p>
<div class="section" id="option-sets">
<h1>Option Sets<a class="headerlink" href="#option-sets" title="Permalink to this headline">¶</a></h1>
<p>Option sets in C and ObjC are often represented using enums with bit-pattern
constants, as used in Cocoa&#8217;s NS_OPTIONS idiom. For example:</p>
<div class="highlight-python"><div class="highlight"><pre>// ObjC
typedef NS_OPTIONS(NSUInteger, NSStringCompareOptions) {
  NSCaseInsensitiveSearch = 1,
  NSLiteralSearch = 2,
  NSBackwardsSearch = 4,
  NSAnchoredSearch = 8,
  NSNumericSearch = 64,
  NSDiacriticInsensitiveSearch = 128,
  NSWidthInsensitiveSearch = 256,
  NSForcedOrderingSearch = 512,
  NSRegularExpressionSearch = 1024
};
</pre></div>
</div>
<p>This approach doesn&#8217;t map well to Swift&#8217;s enums, which are intended to be
strict enumerations of states, or &#8220;sum types&#8221; to use the type-theory-nerd term.
An option set is more like a product type, and so more naturally map to a
struct of booleans:</p>
<div class="highlight-python"><div class="highlight"><pre>// Swift
struct NSStringCompareOptions {
  var CaseInsensitiveSearch,
      LiteralSearch,
      BackwardsSearch,
      AnchoredSearch,
      NumericSearch,
      DiacriticInsensitiveSearch,
      WidthInsensitiveSearch,
      ForcedOrderingSearch,
      RegularExpressionSearch : Bool = false
}
</pre></div>
</div>
<p>There are a few reasons this doesn&#8217;t fly in C:</p>
<ul>
<li><p class="first">Boolean fields in C structs waste a byte by default. Option set enums are
compact.</p>
</li>
<li><p class="first">Bitfield ABI has historically been weird and unstable across C
implementations. Option set enums have a very concrete binary representation.</p>
</li>
<li><p class="first">Prior to C99 it was difficult to use struct literals in expressions.</p>
</li>
<li><p class="first">It&#8217;s useful to apply bitwise operations to option sets, which can&#8217;t be
applied to C structs.</p>
</li>
<li><p class="first">Bitmasks also provide a natural way to express common option subsets as
constants, as in the <code class="docutils literal"><span class="pre">AllEdges</span></code> constants in the following example:</p>
<div class="highlight-python"><div class="highlight"><pre>// ObjC
typedef NS_OPTIONS(unsigned long long, NSAlignmentOptions) {
    NSAlignMinXInward   = 1ULL &lt;&lt; 0,
    NSAlignMinYInward   = 1ULL &lt;&lt; 1,
    NSAlignMaxXInward   = 1ULL &lt;&lt; 2,
    NSAlignMaxYInward   = 1ULL &lt;&lt; 3,
    NSAlignWidthInward  = 1ULL &lt;&lt; 4,
    NSAlignHeightInward = 1ULL &lt;&lt; 5,

    NSAlignMinXOutward   = 1ULL &lt;&lt; 8,
    NSAlignMinYOutward   = 1ULL &lt;&lt; 9,
    NSAlignMaxXOutward   = 1ULL &lt;&lt; 10,
    NSAlignMaxYOutward   = 1ULL &lt;&lt; 11,
    NSAlignWidthOutward  = 1ULL &lt;&lt; 12,
    NSAlignHeightOutward = 1ULL &lt;&lt; 13,

    NSAlignMinXNearest   = 1ULL &lt;&lt; 16,
    NSAlignMinYNearest   = 1ULL &lt;&lt; 17,
    NSAlignMaxXNearest   = 1ULL &lt;&lt; 18,
    NSAlignMaxYNearest   = 1ULL &lt;&lt; 19,
    NSAlignWidthNearest  = 1ULL &lt;&lt; 20,
    NSAlignHeightNearest = 1ULL &lt;&lt; 21,

    NSAlignRectFlipped = 1ULL &lt;&lt; 63, // pass this if the rect is in a flipped coordinate system. This allows 0.5 to be treated in a visually consistent way.

    // convenience combinations
    NSAlignAllEdgesInward = NSAlignMinXInward|NSAlignMaxXInward|NSAlignMinYInward|NSAlignMaxYInward,
    NSAlignAllEdgesOutward = NSAlignMinXOutward|NSAlignMaxXOutward|NSAlignMinYOutward|NSAlignMaxYOutward,
    NSAlignAllEdgesNearest = NSAlignMinXNearest|NSAlignMaxXNearest|NSAlignMinYNearest|NSAlignMaxYNearest,
};
</pre></div>
</div>
</li>
</ul>
<p>However, we can address all of these issues in Swift. We should make the
theoretically correct struct-of-Bools representation also be the natural and
optimal way to express option sets.</p>
<div class="section" id="the-optionset-protocol">
<h2>The &#8216;OptionSet&#8217; Protocol<a class="headerlink" href="#the-optionset-protocol" title="Permalink to this headline">¶</a></h2>
<p>One of the key features of option set enums is that, by using the standard C
bitwise operations, they provide easy and expressive intersection, union, and
negation of option sets. We can encapsulate these capabilities into a
protocol:</p>
<div class="highlight-python"><div class="highlight"><pre>// Swift
protocol OptionSet : Equatable {
  // Set intersection
  @infix func &amp;(_:Self, _:Self) -&gt; Self
  @infix func &amp;=(@inout _:Self, _:Self)

  // Set union
  @infix func |(_:Self, _:Self) -&gt; Self
  @infix func |=(@inout _:Self, _:Self)

  // Set xor
  @infix func ^(_:Self, _:Self) -&gt; Self
  @infix func ^=(@inout _:Self, _:Self)

  // Set negation
  @prefix func ~(_:Self) -&gt; Self

  // Are any options set?
  func any() -&gt; Bool

  // Are all options set?
  func all() -&gt; Bool

  // Are no options set?
  func none() -&gt; Bool
}
</pre></div>
</div>
<p>The compiler can derive a default conformance for a struct whose instance stored
properties are all <code class="docutils literal"><span class="pre">Bool</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>// Swift
struct NSStringCompareOptions : OptionSet {
  var CaseInsensitiveSearch,
      LiteralSearch,
      BackwardsSearch,
      AnchoredSearch,
      NumericSearch,
      DiacriticInsensitiveSearch,
      WidthInsensitiveSearch,
      ForcedOrderingSearch,
      RegularExpressionSearch : Bool = false
}

var a = NSStringCompareOptions(CaseInsensitiveSearch: true,
                               BackwardsSearch: true)
var b = NSStringCompareOptions(WidthInsensitiveSearch: true,
                               BackwardsSearch: true)
var c = a &amp; b
(a &amp; b).any() // =&gt; true
c == NSStringCompareOptions(BackwardsSearch: true) // =&gt; true
</pre></div>
</div>
</div>
<div class="section" id="optimal-layout-of-bool-fields-in-structs">
<h2>Optimal layout of Bool fields in structs<a class="headerlink" href="#optimal-layout-of-bool-fields-in-structs" title="Permalink to this headline">¶</a></h2>
<p>Boolean fields should take up a single bit inside aggregates, avoiding the need
to mess with bitfields to get efficient layout. When used as inout arguments,
boolean fields packed into bits can go through writeback buffers.</p>
</div>
<div class="section" id="option-subsets">
<h2>Option Subsets<a class="headerlink" href="#option-subsets" title="Permalink to this headline">¶</a></h2>
<p>Option subsets can be expressed as static functions of the type.
(Ideally these would be static constants, if we had those.)
For example:</p>
<div class="highlight-python"><div class="highlight"><pre>// Swift
struct NSAlignmentOptions : OptionSet {
  var AlignMinXInward,
      AlignMinYInward,
      AlignMaxXInward,
      AlignMaxYInward,
      AlignWidthInward,
      AlignHeightInward : Bool = false

  // convenience combinations
  static func NSAlignAllEdgesInward() {
    return NSAlignmentOptions(AlignMinXInward: true,
                              AlignMaxXInward: true,
                              AlignMinYInward: true,
                              AlignMaxYInward: true)
  }
}
</pre></div>
</div>
</div>
<div class="section" id="importing-option-sets-from-cocoa">
<h2>Importing option sets from Cocoa<a class="headerlink" href="#importing-option-sets-from-cocoa" title="Permalink to this headline">¶</a></h2>
<p>When importing an NS_OPTIONS declaration from Cocoa, we import it as an
OptionSet-conforming struct, with each single-bit member of the Cocoa enum
mapping to a Bool field of the struct with a default value of <code class="docutils literal"><span class="pre">false</span></code>.
Their IR-level layout places the fields
at the correct bits to be ABI-compatible with the C type.
Multiple-bit constants are imported as <a class="reference internal" href="#option-subsets">option subsets</a>, mapping to static
functions.</p>
<p><em>OPEN QUESTION</em>: What to do with bits that only appear as parts of option
subsets, as in:</p>
<div class="highlight-python"><div class="highlight"><pre>// ObjC
typedef NS_OPTIONS(unsigned, MyOptions) {
  Foo = 0x01,
  Bar = 0x03, // 0x02 | 0x01
  Bas = 0x05, // 0x04 | 0x01
};
</pre></div>
</div>
</div>
<div class="section" id="areas-for-potential-syntactic-refinement">
<h2>Areas for potential syntactic refinement<a class="headerlink" href="#areas-for-potential-syntactic-refinement" title="Permalink to this headline">¶</a></h2>
<p>There are some things that are a bit awkward under this proposal which
I think are worthy of some examination. I don&#8217;t have great solutions to any of
these issues off the top of my head.</p>
<div class="section" id="type-and-default-value-of-option-fields">
<h3>Type and default value of option fields<a class="headerlink" href="#type-and-default-value-of-option-fields" title="Permalink to this headline">¶</a></h3>
<p>It&#8217;s a bit boilerplate-ish to have to spell out the <code class="docutils literal"><span class="pre">:</span> <span class="pre">Bool</span> <span class="pre">=</span> <span class="pre">true</span></code> for the
set of fields:</p>
<div class="highlight-python"><div class="highlight"><pre>// Swift
struct MyOptions : OptionSet {
  var Foo,
      Bar,
      Bas : Bool = false
}
</pre></div>
</div>
<p>(though by comparison with C, it&#8217;s still a net win, since the bitshifted
constants don&#8217;t need to be manually spelled out and maintained. Is this a big
deal?)</p>
</div>
<div class="section" id="construction-of-option-sets">
<h3>Construction of option sets<a class="headerlink" href="#construction-of-option-sets" title="Permalink to this headline">¶</a></h3>
<p>The implicit elementwise keyworded constructor for structs works naturally for
option set structs, except that it requires a bulky and repetitive <code class="docutils literal"><span class="pre">:</span> <span class="pre">true</span></code>
(or <code class="docutils literal"><span class="pre">:</span> <span class="pre">false</span></code>) after each keyword:</p>
<div class="highlight-python"><div class="highlight"><pre>// Swift
var myOptions = MyOptions(Foo: true, Bar: true)
</pre></div>
</div>
<p>Some sort of shorthand for <code class="docutils literal"><span class="pre">keyword:</span> <span class="pre">true</span></code>/<code class="docutils literal"><span class="pre">keyword:</span> <span class="pre">false</span></code> would be nice
and would be generally useful beyond option sets, though I don&#8217;t have any
awesome ideas of how that should look right now.</p>
</div>
<div class="section" id="nonuniformity-of-single-options-and-option-subsets">
<h3>Nonuniformity of single options and option subsets<a class="headerlink" href="#nonuniformity-of-single-options-and-option-subsets" title="Permalink to this headline">¶</a></h3>
<p>Treating individual options and <a class="reference internal" href="#option-subsets">option subsets</a> differently disrupts some
of the elegance of the bitmask idiom. As static functions, option subsets can&#8217;t
be combined freely in constructor calls like they can with <code class="docutils literal"><span class="pre">|</span></code> in C. As
instance stored properties, individual options must be first constructed before
bitwise operations can be applied to them.</p>
<div class="highlight-python"><div class="highlight"><pre>// ObjC
typedef NS_OPTIONS(unsigned, MyOptions) {
  Foo = 0x01,
  Bar = 0x02,
  Bas = 0x04,

  Foobar = 0x03,
};

MyOptions x = Foobar | Bas;
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre>// Swift, under this proposal
struct MyOptions : OptionSet {
  var Foo, Bar, Bas : Bool = false

  static func Foobar() -&gt; MyOptions {
    return MyOptions(Foo: true, Bar: true)
  }
}

var x: MyOptions = .Foobar() | MyOptions(Bas: true)
</pre></div>
</div>
<p>This nonuniformity could potentially be addressed by introducing additional
implicit decls, such as adding implicit static properties corresponding to each
individual option:</p>
<div class="highlight-python"><div class="highlight"><pre>// Swift
struct MyOptions : OptionSet {
  // Stored properties of instances
  var Foo, Bar, Bas : Bool = false

  static func Foobar() -&gt; MyOptions {
    return MyOptions(Foo: true, Bar: true)
  }

  // Implicitly-generated static properties?
  static func Foo() -&gt; MyOptions { return MyOptions(Foo: true) }
  static func Bar() -&gt; MyOptions { return MyOptions(Bar: true) }
  static func Bas() -&gt; MyOptions { return MyOptions(Bas: true) }
}

var x: MyOptions = .Foobar() | .Bas()
</pre></div>
</div>
<p>This is getting outside of strict protocol conformance derivation, though.</p>
</div>
<div class="section" id="lack-of-static-properties">
<h3>Lack of static properties<a class="headerlink" href="#lack-of-static-properties" title="Permalink to this headline">¶</a></h3>
<p>Static constant properties seem to me like a necessity to make option subsets
really acceptable to declare and use. This would be a much nicer form of the
above:</p>
<div class="highlight-python"><div class="highlight"><pre>// Swift
struct MyOptions : OptionSet {
  // Stored properties of instances
  var Foo, Bar, Bas : Bool = false

  static val Foobar = MyOptions(Foo: true, Bar: true)

  // Implicitly-generated static properties
  static val Foo = MyOptions(Foo: true)
  static val Bar = MyOptions(Bar: true)
  static val Bas = MyOptions(Bas: true)
}

var x: MyOptions = .Foobar | .Bas
</pre></div>
</div>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright apple.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.1.9',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>