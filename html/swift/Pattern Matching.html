

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Pattern Matching &mdash; Swift Programming Language documentation 0.1.9 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Swift Programming Language documentation 0.1.9 documentation" href="index.html"/>
        <link rel="up" title="Contents" href="contents.html"/>
        <link rel="next" title="Stored and Computed Variables" href="StoredAndComputedVariables.html"/>
        <link rel="prev" title="Object Initialization" href="ObjectInitialization.html"/>
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>


  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Swift Programming Language documentation
          

          
          </a>

          
            
            
              <div class="version">
                0.1.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">swift docs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="ABI.html">The Swift ABI</a></li>
<li class="toctree-l1"><a class="reference internal" href="ARCOptimization.html">ARC Optimization for Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="AccessControl.html">Access Control</a></li>
<li class="toctree-l1"><a class="reference internal" href="AccessControlInStdlib.html">Scope and introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="AccessControlInStdlib.html#public"><cite>public</cite></a></li>
<li class="toctree-l1"><a class="reference internal" href="AccessControlInStdlib.html#internal"><cite>internal</cite></a></li>
<li class="toctree-l1"><a class="reference internal" href="AccessControlInStdlib.html#private"><cite>private</cite></a></li>
<li class="toctree-l1"><a class="reference internal" href="AccessControlInStdlib.html#leading-underscore-rule">Leading Underscore Rule</a></li>
<li class="toctree-l1"><a class="reference internal" href="Arrays.html">The Swift Array Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="CallingConvention.html">The Swift Calling Convention</a></li>
<li class="toctree-l1"><a class="reference internal" href="DebuggingTheCompiler.html">Debugging the Swift Compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="Dependency Analysis.html">Dependency Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="DriverInternals.html">Driver Design &amp; Internals</a></li>
<li class="toctree-l1"><a class="reference internal" href="DriverParseableOutput.html">Parseable Driver Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="ErrorHandling.html">Error Handling in Swift 2.0</a></li>
<li class="toctree-l1"><a class="reference internal" href="ErrorHandlingRationale.html">Error Handling Rationale and Proposal</a></li>
<li class="toctree-l1"><a class="reference internal" href="Failable Initializers.html">Failable initializers</a></li>
<li class="toctree-l1"><a class="reference internal" href="Generics.html">Generics in Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="GitWorkflows.html">Git Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="GitWorkflows.html#svn-git-workflows">SVN -&gt; GIT Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="HighLevelSILOptimizations.html">High-Level Optimizations in SIL</a></li>
<li class="toctree-l1"><a class="reference internal" href="Import.html">IMPORT SYNTAX</a></li>
<li class="toctree-l1"><a class="reference internal" href="Import.html#resolving-name-clashes">RESOLVING NAME CLASHES</a></li>
<li class="toctree-l1"><a class="reference internal" href="Import.html#future-extensions">FUTURE EXTENSIONS</a></li>
<li class="toctree-l1"><a class="reference internal" href="IndexInvalidation.html">Index Invalidation Rules in the Swift Standard Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#using-versioned-api">Using Versioned API</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#publishing-versioned-api">Publishing Versioned API</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#giving-up-flexibility">Giving Up Flexibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#optimization">Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#resilience-domains">Resilience Domains</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#protocol-conformances">Protocol Conformances</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#checking-binary-compatibility">Checking Binary Compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#summary">Summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#glossary">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="Literals.html">Literals</a></li>
<li class="toctree-l1"><a class="reference internal" href="LogicalObjects.html">Logical Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="Modules.html">High-Level Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="Modules.html#import"><code class="docutils literal"><span class="pre">import</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="Modules.html#interoperability-with-objective-c-via-clang">Interoperability with Objective-C via Clang</a></li>
<li class="toctree-l1"><a class="reference internal" href="Modules.html#glossary">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="MutationModel.html">Immutability and Read-Only Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="ObjectInitialization.html">Object Initialization</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html">Writing High-Performance Swift Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#enabling-optimizations">Enabling Optimizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#whole-module-optimizations">Whole Module Optimizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#reducing-dynamic-dispatch">Reducing Dynamic Dispatch</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#using-container-types-efficiently">Using Container Types Efficiently</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#unchecked-operations">Unchecked operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#generics">Generics</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#the-cost-of-large-swift-values">The cost of large swift values</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#unsafe-code">Unsafe code</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#protocols">Protocols</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#footnotes">Footnotes</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Pattern Matching</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#elimination-rules">Elimination rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="#alternatives-for-alternatives">Alternatives for alternatives</a></li>
<li class="toctree-l2"><a class="reference internal" href="#selection-statement">Selection statement</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#default">Default</a></li>
<li class="toctree-l3"><a class="reference internal" href="#case-groups">Case groups</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scoping">Scoping</a></li>
<li class="toctree-l3"><a class="reference internal" href="#case-selection-semantics">Case selection semantics</a></li>
<li class="toctree-l3"><a class="reference internal" href="#non-exhaustive-switches">Non-exhaustive switches</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#other-uses-of-patterns">Other uses of patterns</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#var-bindings">Var bindings</a></li>
<li class="toctree-l3"><a class="reference internal" href="#function-parameters">Function parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="#assignment">Assignment</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pattern-match-expression">Pattern-match expression</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#is-or-isa">&#8216;is&#8217; or &#8216;isa&#8217;</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dominance">Dominance</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pattern-grammar">Pattern grammar</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#two-kinds-of-pattern">Two kinds of pattern</a></li>
<li class="toctree-l3"><a class="reference internal" href="#binding-patterns">Binding patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="#annotation-patterns">Annotation patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="#is-patterns">&#8216;is&#8217; patterns</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ambiguity-with-type-value-matching">Ambiguity with type value matching</a></li>
<li class="toctree-l4"><a class="reference internal" href="#type-refinement">Type refinement</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#call-patterns">&#8220;Call&#8221; patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="#expression-patterns">Expression patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="#satisfying-an-expression-pattern">Satisfying an expression pattern</a></li>
<li class="toctree-l3"><a class="reference internal" href="#order-of-evaluation-of-patterns">Order of evaluation of patterns</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#miscellaneous">Miscellaneous</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="SIL.html">Swift Intermediate Language (SIL)</a></li>
<li class="toctree-l1"><a class="reference internal" href="SequencesAndCollections.html">Sequences And Collections in Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="Serialization.html">Swift Binary Serialization Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="StdlibAPIGuidelines.html">Swift Standard Library API Design Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="StdlibRationales.html">Rationales for the Swift standard library designs</a></li>
<li class="toctree-l1"><a class="reference internal" href="StoredAndComputedVariables.html">Stored and Computed Variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="StringDesign.html">Swift String Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="Testing.html">Testing Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="TextFormatting.html">Text Formatting in Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="TransparentAttr.html"><code class="docutils literal"><span class="pre">&#64;_transparent</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="TypeChecker.html">Type Checker Design and Implementation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="contents.html">Contents</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="IndexInvalidation.html">Index Invalidation Rules in the Swift Standard Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="AccessControl.html">Access Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="DriverInternals.html">Driver Design &amp; Internals</a></li>
<li class="toctree-l2"><a class="reference internal" href="DriverParseableOutput.html">Parseable Driver Output</a></li>
<li class="toctree-l2"><a class="reference internal" href="ErrorHandling.html">Error Handling in Swift 2.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="ErrorHandlingRationale.html">Error Handling Rationale and Proposal</a></li>
<li class="toctree-l2"><a class="reference internal" href="Generics.html">Generics in Swift</a></li>
<li class="toctree-l2"><a class="reference internal" href="LogicalObjects.html">Logical Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="ObjectInitialization.html">Object Initialization</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Pattern Matching</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#elimination-rules">Elimination rules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#alternatives-for-alternatives">Alternatives for alternatives</a></li>
<li class="toctree-l3"><a class="reference internal" href="#selection-statement">Selection statement</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#default">Default</a></li>
<li class="toctree-l4"><a class="reference internal" href="#case-groups">Case groups</a></li>
<li class="toctree-l4"><a class="reference internal" href="#scoping">Scoping</a></li>
<li class="toctree-l4"><a class="reference internal" href="#case-selection-semantics">Case selection semantics</a></li>
<li class="toctree-l4"><a class="reference internal" href="#non-exhaustive-switches">Non-exhaustive switches</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#other-uses-of-patterns">Other uses of patterns</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#var-bindings">Var bindings</a></li>
<li class="toctree-l4"><a class="reference internal" href="#function-parameters">Function parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="#assignment">Assignment</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pattern-match-expression">Pattern-match expression</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#pattern-grammar">Pattern grammar</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#two-kinds-of-pattern">Two kinds of pattern</a></li>
<li class="toctree-l4"><a class="reference internal" href="#binding-patterns">Binding patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="#annotation-patterns">Annotation patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="#is-patterns">&#8216;is&#8217; patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="#call-patterns">&#8220;Call&#8221; patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="#expression-patterns">Expression patterns</a></li>
<li class="toctree-l4"><a class="reference internal" href="#satisfying-an-expression-pattern">Satisfying an expression pattern</a></li>
<li class="toctree-l4"><a class="reference internal" href="#order-of-evaluation-of-patterns">Order of evaluation of patterns</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#miscellaneous">Miscellaneous</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="StoredAndComputedVariables.html">Stored and Computed Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="SIL.html">Swift Intermediate Language (SIL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="TypeChecker.html">Type Checker Design and Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="DebuggingTheCompiler.html">Debugging the Swift Compiler</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="weak.html">Weak References</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Swift Programming Language documentation</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
        <li><a href="contents.html">Contents</a> &raquo;</li>
      
    <li>Pattern Matching</li>
    <li class="wy-breadcrumbs-aside">
      
        
          <a href="_sources/Pattern Matching.txt" rel="nofollow"> View page source</a>
        
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="pattern-matching">
<span id="patternmatching"></span><h1>Pattern Matching<a class="headerlink" href="#pattern-matching" title="Permalink to this headline">¶</a></h1>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This document was used in designing the pattern-matching features
of Swift 1.0. It has not been kept to date and does not describe the current
or planned behavior of Swift.</p>
</div>
<div class="section" id="elimination-rules">
<h2>Elimination rules<a class="headerlink" href="#elimination-rules" title="Permalink to this headline">¶</a></h2>
<p>When type theorists consider a programming language, we break it down like this:</p>
<ul class="simple">
<li>What are the kinds of fundamental and derived types in the language?</li>
<li>For each type, what are its introduction rules, i.e. how do you get
values of that type?</li>
<li>For each type, what are its elimination rules, i.e. how do you use
values of that type?</li>
</ul>
<p>Swift has a pretty small set of types right now:</p>
<ul class="simple">
<li>Fundamental types: currently i1, i8, i16, i32, and i64;
float and double; eventually maybe others.</li>
<li>Function types.</li>
<li>Tuples. Heterogeneous fixed-length products. Swift&#8217;s system
provides two basic kinds of element: positional and labelled.</li>
<li>Arrays. Homogeneous fixed-length aggregates.</li>
<li>Algebraic data types (ADTs), introduce by enum.  Nominal closed
disjoint unions of heterogeneous types.</li>
<li>Struct types.  Nominal heterogeneous fixed-length products.</li>
<li>Class types.  Nominal, subtypeable heterogeneous fixed-length products
with identity.</li>
<li>Protocol and protocol-composition types.</li>
</ul>
<p>In addition, each of the nominal types can be made generic; this
doesn&#8217;t affect the overall introduction/elimination design because an
&#8220;unapplied&#8221; generic type isn&#8217;t first-class (intentionally), and an
&#8220;applied&#8221; generic type behaves essentially like a non-generic type
(also intentionally).</p>
<p>The point is that adding any other kind of type (e.g. SIMD vectors)
means that we need to consider its intro/elim rules.</p>
<p>For most of these, intro rules are just a question of picking syntax, and we
don&#8217;t really need a document for that. So let&#8217;s talk elimination. Generally, an
elimination rule is a way at getting back to the information the intro rule(s)
wrote into the value. So what are the specific elimination rules for these
types? How do we use them, other than in type-generic ways like passing them as
arguments to calls?</p>
<p><strong>Functions</strong> are used by calling them. This is something of a special case:
some values of function type may carry data, there isn&#8217;t really a useful model
for directly accessing it. Values of function type are basically completely
opaque, except that we do provide thin vs. thick function types, which is
potentially something we could pattern-match on, although many things can
introduce thunks and so the result would not be reliable.</p>
<p><strong>Scalars</strong> are used by feeding them to primitive binary operators.  This is
also something of a special case, because there&#8217;s no useful way in which scalars
can be decomposed into separate values.</p>
<p><strong>Tuples</strong>, <strong>structs</strong>, and <strong>classes</strong> are used by projecting out
their elements.  Classes may also be turned into an object of a
supertype (which is always a class).</p>
<p><strong>Arrays</strong> are used by projecting out slices and elements.</p>
<p><strong>Existentials</strong> are used by performing one of the operations that the
type is known to support.</p>
<p><strong>ADTs</strong> are used by projecting out elements of the current alternative, but how
we determine the current alternative?</p>
</div>
<div class="section" id="alternatives-for-alternatives">
<h2>Alternatives for alternatives<a class="headerlink" href="#alternatives-for-alternatives" title="Permalink to this headline">¶</a></h2>
<p>I know of three basic designs for determining the current alternative of an ADT:</p>
<ul class="simple">
<li>Visitor pattern: there&#8217;s some way of declaring a method on the full ADT and
then implementing it for each individual alternative. You do this in OO
languages mostly because there&#8217;s no direct language support for closed
disjoint unions (as opposed to open disjoint unions, which subclassing lets
you achieve at some performance cost).<ul>
<li>plus: doesn&#8217;t require language support</li>
<li>plus: easy to &#8220;overload&#8221; and provide different kinds of pattern matching on
the same type</li>
<li>plus: straightforward to add interesting ADT-specific logic, like matching a
CallExpr instead of each of its N syntactic forms</li>
<li>plus: simple form of exhaustiveness checking</li>
<li>minus: cases are separate functions, so data and control flow is awkward</li>
<li>minus: lots of boilerplate to enable</li>
<li>minus: lots of boilerplate to use</li>
<li>minus: nested pattern matching is awful</li>
</ul>
</li>
<li>Query functions: dynamic_cast, dyn_cast, isa, instanceof<ul>
<li>plus: easy to order and mix with other custom conditions</li>
<li>plus: low syntactic overhead for testing the alternative if you don&#8217;t need
to actually decompose</li>
<li>minus: higher syntactic overhead for decomposition<ul>
<li>isa/instanceof pattern requires either a separate cast or unsafe
operations later</li>
<li>dyn_cast pattern needs a fresh variable declaration, which is very awkward
in complex conditions</li>
</ul>
</li>
<li>minus: exhaustiveness checking is basically out the window</li>
<li>minus: some amount of boilerplate to enable</li>
</ul>
</li>
<li>Pattern matching<ul>
<li>plus: no boilerplate to enable</li>
<li>plus: hugely reduced syntax to use if you want a full decomposition</li>
<li>plus: compiler-supported exhaustiveness checking</li>
<li>plus: nested matching is natural</li>
<li>plus: with pattern guards, natural mixing of custom conditions</li>
<li>minus: syntactic overkill to just test for a specific alternative
(e.g. to filter it out)</li>
<li>minus: needs boilerplate to project out a common member across
multiple/all alternatives</li>
<li>minus: awkward to group alternatives (fallthrough is a simple option
but has issues)</li>
<li>minus: traditionally completely autogenerated by compiler and thus
not very flexible</li>
<li>minus: usually a new grammar production that&#8217;s very ambiguous with
the expression grammar</li>
<li>minus: somewhat fragile against adding extra data to an alternative</li>
</ul>
</li>
</ul>
<p>I feel that this strongly points towards using pattern matching as the basic way
of consuming ADTs, maybe with special dispensations for querying the alternative
and projecting out common members.</p>
<p>Pattern matching was probably a foregone conclusion, but I wanted to spell out
that having ADTs in the language is what really forces our hand because the
alternatives are so bad. Once we need pattern-matching, it makes sense to
provide patterns for the other kinds of types as well.</p>
</div>
<div class="section" id="selection-statement">
<h2>Selection statement<a class="headerlink" href="#selection-statement" title="Permalink to this headline">¶</a></h2>
<p>This is the main way we expect users to employ non-obvious pattern- matching. We
obviously need something with statement children, so this has to be a
statement. That&#8217;s also fine because this kind of full pattern match is very
syntactically heavyweight, and nobody would want to embed it in the middle of an
expression. We also want a low-weight matching expression, though, for
relatively simple ADTs:</p>
<div class="highlight-python"><div class="highlight"><pre>stmt            ::= stmt-switch
stmt-switch     ::= &#39;switch&#39; expr &#39;{&#39; switch-group+ &#39;}&#39;
switch-group    ::= case-introducer+ stmt-brace-item+
case-introducer ::= &#39;case&#39; match-pattern-list case-guard? &#39;:&#39;
case-introducer ::= &#39;default&#39; case-guard? &#39;:&#39;
case-guard      ::= &#39;where&#39; expr
match-pattern-list ::= match-pattern
match-pattern-list ::= match-pattern-list &#39;,&#39; match-pattern
</pre></div>
</div>
<p>We can get away with using &#8220;switch&#8221; here because we&#8217;re going to unify
both values and patterns under match-pattern.  The works chiefly by
making decompositional binding a bit more awkward, but has the major
upside of reducing the likelihood of dumb mistakes (rebinding &#8216;true&#8217;,
for example), and it means that C-looking switches actually match our
semantics quite closely.  The latter is something of a priority: a C
switch over an enum is actually pretty elegant &#8212; well, except for
all the explicit scoping and &#8216;break&#8217; statements, but the switching
side of it feels clean.</p>
<div class="section" id="default">
<h3>Default<a class="headerlink" href="#default" title="Permalink to this headline">¶</a></h3>
<p>I keep going back and forth about having a &#8220;default&#8221; case-introducer.
On the one hand, I kind of want to encourage total matches.  On the
other hand, (1) having it is consistent with C, (2) it&#8217;s not an
unnatural style, and (3) there are cases where exhaustive switching
isn&#8217;t going to be possible.  We can certainly recommend complete
matches in switches, though.</p>
<p>If we do have a &#8216;default&#8217;, I think it makes the most sense for it to be
semantically a complete match and therefore require it to be
positioned at the end (on pain of later matches being irrelevant).
First, this gives more sensible behavior to &#8216;default where
x.isPurple()&#8217;, which really doesn&#8217;t seem like it should get reordered
with the surrounding cases; and second, it makes the matching story
very straightforward.  And users who like to put &#8216;default:&#8217; at the top
won&#8217;t accidentally get unexpected behavior because coverage checking
will immediately complain about the fact that every case after an
unguarded &#8216;default&#8217; is obviously dead.</p>
</div>
<div class="section" id="case-groups">
<h3>Case groups<a class="headerlink" href="#case-groups" title="Permalink to this headline">¶</a></h3>
<p>A case-group lets you do the same thing for multiple cases without an
extra syntactic overhead (like a &#8216;fallthrough&#8217; after every case).  For
some types (e.g. classic functional linked lists) this is basically
pointless, but for a lot of other types (Int, enums, etc.) it&#8217;s
pervasive.</p>
<p>The most important semantic design point here is about bound variables
in a grouped case, e.g. (using &#8216;var&#8217; as a &#8220;bind this variable&#8221; introducer;
see the pattern grammar):</p>
<div class="highlight-python"><div class="highlight"><pre>switch (pair) {
case (var x, 0):
case (0, var y):
  return 1
case (var x, var y)
  return foo(x-1,y) + foo(x,y-1)
}
</pre></div>
</div>
<p>It&#8217;s tempting to just say that an unsound name binding (i.e. a name
not bound in all cases or bound to values of different types) is just
always an error, but I think that&#8217;s probably not the way to go.  There
are two things I have in mind here: first, these variables can be
useful in pattern guards even if they&#8217;re not used in the case block
itself, and second, a well-chosen name can make a pattern much more
self-documenting.  So I think it should only be an error to <em>refer</em> to
an unsound name binding.</p>
<p>The most important syntactic design point here is whether to require
(or even allow) the &#8216;case&#8217; keyword to be repeated for each case.  In
many cases, it can be much more compact to allow a comma-separated
list of patterns after &#8216;case&#8217;:</p>
<div class="highlight-python"><div class="highlight"><pre>switch (day) {
case .Terrible, .Horrible, .NoGood, .VeryBad:
  abort()
case .ActuallyPrettyReasonableWhenYouLookBackOnIt:
  continue
}
</pre></div>
</div>
<p>or even more so:</p>
<div class="highlight-python"><div class="highlight"><pre>case 0...2, 5...10, 14...18, 22...:
  flagConditionallyAcceptableAge()
</pre></div>
</div>
<p>On the other hand, if this list gets really long, the wrapping gets a
little weird:</p>
<div class="highlight-python"><div class="highlight"><pre>case .Terrible, .Horrible, .NoGood, .VeryBad,
     .Awful, .Dreadful, .Appalling, .Horrendous,
     .Deplorable, .Unpleasant, .Ghastly, .Dire:
  abort()
</pre></div>
</div>
<p>And while I think pattern guards should be able to apply to multiple
cases, it would be nice to allow different cases in a group to have
different pattern guards:</p>
<div class="highlight-python"><div class="highlight"><pre>case .None:
case .Some(var c) where c.isSpace() || c.isASCIIControl():
  skipToEOL()
</pre></div>
</div>
<p>So really I think we should permit multiple &#8216;case&#8217; introducers:</p>
<div class="highlight-python"><div class="highlight"><pre>case .Terrible, .Horrible, .NoGood, .VeryBad:
case .Awful, .Dreadful, .Appalling, .Horrendous:
case .Deplorable, .Unpleasant, .Ghastly, .Dire:
  abort()
</pre></div>
</div>
<p>With the rule that a pattern guard can only use bindings that are
sound across its guarded patterns (those within the same &#8216;case&#8217;), and
the statement itself can only use bindings that are sound across all
of the cases.  A reference that refers to an unsound binding is an
error; lookup doesn&#8217;t just ignore the binding.</p>
</div>
<div class="section" id="scoping">
<h3>Scoping<a class="headerlink" href="#scoping" title="Permalink to this headline">¶</a></h3>
<p>Despite the lack of grouping braces, the semantics are that the statements in
each case-group form their own scope, and falling off the end causes control to
resume at the end of the switch statement — i.e. &#8220;implicit break&#8221;, not &#8220;implicit
fallthrough&#8221;.</p>
<p>Chris seems motivated to eventually add an explicit &#8216;fallthrough&#8217;
statement. If we did this, my preference would be to generalize it by
allowing the match to be performed again with a new value, e.g.
<code class="code docutils literal"><span class="pre">fallthrough(something)</span></code>, at least optionally.  I think having
local functions removes a lot of the impetus, but not so much as to
render the feature worthless.</p>
<p>Syntactically, braces and the choice of case keywords are all bound
together. The thinking goes as follows. In Swift, statement scopes are always
grouped by braces. It&#8217;s natural to group the cases with braces as well. Doing
both lets us avoid a &#8216;case&#8217; keyword, but otherwise it leads to ugly style,
because either the last case ends in two braces on the same line or cases have
to further indented. Okay, it&#8217;s easy enough to not require braces on the match,
with the grammar saying that cases are just greedily consumed — there&#8217;s no
ambiguity here because the switch statement is necessarily within braces. But
that leaves the code without a definitive end to the cases, and the closing
braces end up causing a lot of unnecessary vertical whitespace, like so:</p>
<div class="highlight-python"><div class="highlight"><pre>switch (x)
case .foo {
  …
}
case .bar {
  …
}
</pre></div>
</div>
<p>So instead, let&#8217;s require the switch statement to have braces, and
we&#8217;ll allow the cases to be written without them:</p>
<div class="highlight-python"><div class="highlight"><pre>switch (x) {
case .foo:
  …
case .bar:
  …
}
</pre></div>
</div>
<p>That&#8217;s really a lot prettier, except it breaks the rule about always grouping
scopes with braces (we <em>definitely</em> want different cases to establish different
scopes). Something has to give, though.</p>
<p>We require the trailing colon because it&#8217;s a huge cue for separating
things, really making single-line cases visually appealing, and the
fact that it doesn&#8217;t suggest closing punctuation is a huge boon.  It&#8217;s
also directly precedented in C, and it&#8217;s even roughly the right
grammatical function.</p>
</div>
<div class="section" id="case-selection-semantics">
<h3>Case selection semantics<a class="headerlink" href="#case-selection-semantics" title="Permalink to this headline">¶</a></h3>
<p>The semantics of a switch statement are to first evaluate the value
operand, then proceed down the list of case-introducers and execute
the statements for the switch-group that had the first satisfied
introducer.</p>
<p>It is an error if a case-pattern can never trigger because earlier
cases are exhaustive.  Some kinds of pattern (like &#8216;default&#8217; cases
and &#8216;_&#8217;) are obviously exhaustive by themselves, but other patterns
(like patterns on properties) can be much harder to reason about
exhaustiveness for, and of course pattern guards can make this
outright undecidable.  It may be easiest to apply very straightforward
rules (like &#8220;ignore guarded patterns&#8221;) for the purposes of deciding
whether the program is actually ill-formed; anything else that we can
prove is unreachable would only merit a warning.  We&#8217;ll probably
also want a way to say explicitly that a case can never occur (with
semantics like llvm_unreachable, i.e. a reliable runtime failure unless
that kind of runtime safety checking is disabled at compile-time).</p>
<p>A &#8216;default&#8217; is satisfied if it has no guard or if the guard evaluates to true.</p>
<p>A &#8216;case&#8217; is satisfied if the pattern is satisfied and, if there&#8217;s a guard,
the guard evaluates to true after binding variables.  The guard is not
evaluated if the pattern is not fully satisfied.  We&#8217;ll talk about satisfying
a pattern later.</p>
</div>
<div class="section" id="non-exhaustive-switches">
<h3>Non-exhaustive switches<a class="headerlink" href="#non-exhaustive-switches" title="Permalink to this headline">¶</a></h3>
<p>Since falling out of a statement is reasonable behavior in an
imperative language — in contrast to, say, a functional language where
you&#8217;re in an expression and you need to produce a value — there&#8217;s a
colorable argument that non-exhaustive matches should be okay.  I
dislike this, however, and propose that it should be an error to
make an non-exhaustive switch; people who want non-exhaustive matches
can explicitly put in default cases.
Exhaustiveness actually isn&#8217;t that difficult to check, at least over
ADTs.  It&#8217;s also really the behavior that I would expect from the
syntax, or at least implicitly falling out seems dangerous in a way
that nonexhaustive checking doesn&#8217;t.  The complications with checking
exhaustiveness are pattern guards and matching expressions. The
obvious conservatively-safe rule is to say &#8220;ignore cases with pattern
guards or matching expressions during exhaustiveness checking&#8221;, but
some people really want to write &#8220;where x &lt; 10&#8221; and &#8220;where x &gt;= 10&#8221;,
and I can see their point. At the same time, we really don&#8217;t want to
go down that road.</p>
</div>
</div>
<div class="section" id="other-uses-of-patterns">
<h2>Other uses of patterns<a class="headerlink" href="#other-uses-of-patterns" title="Permalink to this headline">¶</a></h2>
<p>Patterns come up (or could potentially come up) in a few other places
in the grammar:</p>
<div class="section" id="var-bindings">
<h3>Var bindings<a class="headerlink" href="#var-bindings" title="Permalink to this headline">¶</a></h3>
<p>Variable bindings only have a single pattern, which has to be exhaustive, which
also means there&#8217;s no point in supporting guards here. I think we just get
this:</p>
<div class="highlight-python"><div class="highlight"><pre>decl-var ::= &#39;var&#39; attribute-list? pattern-exhaustive value-specifier
</pre></div>
</div>
</div>
<div class="section" id="function-parameters">
<h3>Function parameters<a class="headerlink" href="#function-parameters" title="Permalink to this headline">¶</a></h3>
<p>The functional languages all permit you to directly pattern-match in the
function declaration, like this example from SML:</p>
<div class="highlight-python"><div class="highlight"><pre>fun length nil = 0
  | length (a::b) = 1 + length b
</pre></div>
</div>
<p>This is really convenient, but there&#8217;s probably no reasonable analogue in
Swift. One specific reason: we want functions to be callable with keyword
arguments, but if you don&#8217;t give all the parameters their own names, that won&#8217;t
work.</p>
<p>The current Swift approximation is:</p>
<div class="highlight-python"><div class="highlight"><pre>func length(list : List) : Int {
  switch list {
    case .nil: return 0
    case .cons(_,var tail): return 1 + length(tail)
  }
}
</pre></div>
</div>
<p>That&#8217;s quite a bit more syntax, but it&#8217;s mostly the extra braces from the
function body. We could remove those with something like this:</p>
<div class="highlight-python"><div class="highlight"><pre>func length(list : List) : Int = switch list {
  case .nil: return 0
  case .cons(_,var tail): return 1 + length(tail)
}
</pre></div>
</div>
<p>Anyway, that&#8217;s easy to add later if we see the need.</p>
</div>
<div class="section" id="assignment">
<h3>Assignment<a class="headerlink" href="#assignment" title="Permalink to this headline">¶</a></h3>
<p>This is a bit iffy. It&#8217;s a lot like var bindings, but it doesn&#8217;t have a keyword,
so it&#8217;s really kind of ambiguous given the pattern grammar.</p>
<p>Also, l-value patterns are weird. I can come up with semantics for this, but I
don&#8217;t know what the neighbors will think:</p>
<div class="highlight-python"><div class="highlight"><pre>var perimeter : double
.feet(x) += yard.dimensions.height // returns Feet, which has one constructor, :feet.
.feet(x) += yard.dimensions.width
</pre></div>
</div>
<p>It&#8217;s probably better to just have l-value tuple expressions and not
try to work in arbitrary patterns.</p>
</div>
<div class="section" id="pattern-match-expression">
<h3>Pattern-match expression<a class="headerlink" href="#pattern-match-expression" title="Permalink to this headline">¶</a></h3>
<p>This is an attempt to provide that dispensation for query functions we were
talking about.</p>
<p>I think this should bind looser than any binary operators except assignments;
effectively we should have:</p>
<div class="highlight-python"><div class="highlight"><pre>expr-binary ::= # most of the current expr grammar

expr ::= expr-binary
expr ::= expr-binary &#39;is&#39; expr-primary pattern-guard?
</pre></div>
</div>
<p>The semantics are that this evaluates to true if the pattern and
pattern-guard are satisfied.</p>
<div class="section" id="is-or-isa">
<h4>&#8216;is&#8217; or &#8216;isa&#8217;<a class="headerlink" href="#is-or-isa" title="Permalink to this headline">¶</a></h4>
<p>Perl and Ruby use &#8216;=~&#8217; as the regexp pattern-matching operator, which
is both obscure and really looks like an assignment operator, so I&#8217;m
stealing Joe&#8217;s &#8216;is&#8217; operator, which is currently used for dynamic
type-checks.  I&#8217;m of two minds about this:  I like &#8216;is&#8217; a lot for
value-matching, but not for dynamic type-checks.</p>
<p>One possibility would be to use &#8216;is&#8217; as the generic pattern-matching
operator but use a different spelling (like &#8216;isa&#8217;) for dynamic
type-checks, including the &#8216;is&#8217; pattern.  This would give us
&#8220;x isa NSObject&#8221; as an expression and &#8220;case isa NSObject:&#8221; as a
case selector, both of which I feel read much better.  But in this
proposal, we just use a single operator.</p>
<p>Other alternatives to &#8216;is&#8217; include &#8216;matches&#8217; (reads very naturally but
is somewhat verbose) or some sort of novel operator like &#8216;~~&#8217;.</p>
<p>Note that this impacts a discussion in the section below about
expression patterns.</p>
</div>
<div class="section" id="dominance">
<h4>Dominance<a class="headerlink" href="#dominance" title="Permalink to this headline">¶</a></h4>
<p>I think that this feature is far more powerful if the name bindings,
type-refinements, etc. from patterns are available in code for which a
trivial analysis would reveal that the result of the expression is
true.  For example:</p>
<div class="highlight-python"><div class="highlight"><pre>if s is Window where x.isVisible {
  // can use Window methods on x here
}
</pre></div>
</div>
<p>Taken a bit further, we can remove the need for &#8216;where&#8217; in the
expression form:</p>
<div class="highlight-python"><div class="highlight"><pre>if x is Window &amp;&amp; x.isVisible { ... }
</pre></div>
</div>
<p>That might be problematic without hard-coding the common
control-flow operators, though.  (As well as hardcoding some
assumptions about Bool.convertToLogicValue...)</p>
</div>
</div>
</div>
<div class="section" id="pattern-grammar">
<h2>Pattern grammar<a class="headerlink" href="#pattern-grammar" title="Permalink to this headline">¶</a></h2>
<p>The usual syntax rule from functional languages is that the pattern
grammar mirrors the introduction-rule expression grammar, but parses a
pattern wherever you would otherwise put an expression.  This means
that, for example, if we add array literal expressions, we should also
add a corresponding array literal pattern. I think that principle is
very natural and worth sticking to wherever possible.</p>
<div class="section" id="two-kinds-of-pattern">
<h3>Two kinds of pattern<a class="headerlink" href="#two-kinds-of-pattern" title="Permalink to this headline">¶</a></h3>
<p>We&#8217;re blurring the distinction between patterns and expressions a lot
here.  My current thinking is that this simplifies things for the
programmer &#8212; the user concept becomes basically &#8220;check whether we&#8217;re
equal to this expression, but allow some holes and some more complex
&#8216;matcher&#8217; values&#8221;.  But it&#8217;s possible that it instead might be really
badly confusing.  We&#8217;ll see!  It&#8217;ll be fun!</p>
<p>This kind of forces us to have parallel pattern grammars for the two
major clients:</p>
<ul class="simple">
<li>Match patterns are used in <code class="code docutils literal"><span class="pre">switch</span></code> and <code class="code docutils literal"><span class="pre">matches</span></code>, where
we&#8217;re decomposing something with a real possibility of failing.
This means that expressions are okay in leaf positions, but that
name-bindings need to be explicitly advertised in some way to
reasonably disambiguate them from expressions.</li>
<li>Exhaustive patterns are used in <code class="code docutils literal"><span class="pre">var</span></code> declarations
and function signatures.  They&#8217;re not allowed to be non-exhaustive,
so having a match expression doesn&#8217;t make any sense.  Name bindings
are common and so shouldn&#8217;t be penalized.</li>
</ul>
<p>You might think that having a &#8220;pattern&#8221; as basic as <code class="code docutils literal"><span class="pre">foo</span></code> mean
something different in two different contexts would be confusing, but
actually I don&#8217;t think people will generally think of these as the
same production — you might if you were in a functional language where
you really can decompose in a function signature, but we don&#8217;t allow
that, and I think that will serve to divide them in programmers&#8217; minds.
So we can get away with some things. :)</p>
</div>
<div class="section" id="binding-patterns">
<h3>Binding patterns<a class="headerlink" href="#binding-patterns" title="Permalink to this headline">¶</a></h3>
<p>In general, a lot of these productions are the same, so I&#8217;m going to
talk about <code class="docutils literal"><span class="pre">*</span></code>-patterns, with some specific special rules that only
apply to specific pattern kinds.</p>
<div class="highlight-python"><div class="highlight"><pre>*-pattern ::= &#39;_&#39;
</pre></div>
</div>
<p>A single-underscore identifier is always an &#8220;ignore&#8221; pattern.  It
matches anything, but does not bind it to a variable.</p>
<div class="highlight-python"><div class="highlight"><pre>exhaustive-pattern ::= identifier
match-pattern ::= &#39;?&#39; identifier
</pre></div>
</div>
<p>Any more complicated identifier is a variable-binding pattern.  It is
illegal to bind the same identifier multiple times within a pattern.
However, the variable does come into scope immediately, so in a match
pattern you can have a latter expression which refers to an
already-bound variable.  I&#8217;m comfortable with constraining this to
only work &#8220;conveniently&#8221; left-to-right and requiring more complicated
matches to use guard expressions.</p>
<p>In a match pattern, variable bindings must be prefixed with a ? to
disambiguate them from an expression consisting of a variable
reference.  I considered using &#8216;var&#8217; instead, but using punctuation
means we don&#8217;t need a space, which means this is much more compact in
practice.</p>
</div>
<div class="section" id="annotation-patterns">
<h3>Annotation patterns<a class="headerlink" href="#annotation-patterns" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>exhaustive-pattern ::= exhaustive-pattern &#39;:&#39; type
</pre></div>
</div>
<p>In an exhaustive pattern, you can annotate an arbitrary sub-pattern
with a type.  This is useful in an exhaustive pattern: the type of a
variable isn&#8217;t always inferable (or correctly inferable), and types
in function signatures are generally outright required.  It&#8217;s not as
useful in a match pattern, and the colon can be grammatically awkward
there, so we disallow it.</p>
</div>
<div class="section" id="is-patterns">
<h3>&#8216;is&#8217; patterns<a class="headerlink" href="#is-patterns" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>match-pattern ::= &#39;is&#39; type
</pre></div>
</div>
<p>This pattern is satisfied if the dynamic type of the matched value
&#8220;satisfies&#8221; the named type:</p>
<blockquote>
<div><ul class="simple">
<li>if the named type is an Objective-C class type, the dynamic type
must be a class type, and an &#8216;isKindOf:&#8217; check is performed;</li>
<li>if the named type is a Swift class type, the dynamic type must be
a class type, and a subtype check is performed;</li>
<li>if the named type is a metatype, the dynamic type must be a metatype,
and the object type of the dynamic type must satisfy the object type
of the named type;</li>
<li>otherwise the named type must equal the dynamic type.</li>
</ul>
</div></blockquote>
<p>This inquiry is about dynamic types; archetypes and existentials are
looked through.</p>
<p>The pattern is ill-formed if it provably cannot be satisfied.</p>
<p>In a &#8216;switch&#8217; statement, this would typically appear like this:</p>
<div class="highlight-python"><div class="highlight"><pre>case is NSObject:
</pre></div>
</div>
<p>It can, however, appear in recursive positions:</p>
<div class="highlight-python"><div class="highlight"><pre>case (is NSObject, is NSObject):
</pre></div>
</div>
<div class="section" id="ambiguity-with-type-value-matching">
<h4>Ambiguity with type value matching<a class="headerlink" href="#ambiguity-with-type-value-matching" title="Permalink to this headline">¶</a></h4>
<p>There is a potential point of confusion here with dynamic type
checking (done by an &#8216;is&#8217; pattern) vs. value equality on type objects
(done by an expression pattern where the expression is of metatype
type.  This is resolved by the proposal (currently outstanding but
generally accepted, I think) to disallow naked references to type
constants and instead require them to be somehow decorated.</p>
<p>That is, this pattern requires the user to write something like this:</p>
<div class="highlight-python"><div class="highlight"><pre>case is NSObject:
</pre></div>
</div>
<p>It is quite likely that users will often accidentally write something
like this:</p>
<div class="highlight-python"><div class="highlight"><pre>case NSObject:
</pre></div>
</div>
<p>It would be very bad if that were actually accepted as a valid
expression but with the very different semantics of testing equality
of type objects.  For the most part, type-checking would reject that
as invalid, but a switch on (say) a value of archetype type would
generally work around that.</p>
<p>However, we have an outstanding proposal to generally forbid &#8216;NSObject&#8217;
from appearing as a general expression;  the user would have to decorate
it like the following, which would let us eliminate the common mistake:</p>
<div class="highlight-python"><div class="highlight"><pre>case NSObject.type:
</pre></div>
</div>
</div>
<div class="section" id="type-refinement">
<h4>Type refinement<a class="headerlink" href="#type-refinement" title="Permalink to this headline">¶</a></h4>
<p>If the value matched is immediately the value of a local variable, I
think it would be really useful if this pattern could introduce a type
refinement within its case, so that the local variable would have the
refined type within that scope.  However, making this kind of type
refinement sound would require us to prevent there from being any sort
of mutable alias of the local variable under an unrefined type.
That&#8217;s usually going to be fine in Swift because we usually don&#8217;t
permit the address of a local to escape in a way that crosses
statement boundaries.  However, closures are a major problem for this
model.  If we had immutable local bindings &#8212; and, better yet, if
they were the default &#8212; this problem would largely go away.</p>
<p>This sort of type refinement could also be a problem with code like:</p>
<div class="highlight-python"><div class="highlight"><pre>while expr is ParenExpr {
  expr = expr.getSubExpr()
}
</pre></div>
</div>
<p>It&#8217;s tricky.</p>
</div>
</div>
<div class="section" id="call-patterns">
<h3>&#8220;Call&#8221; patterns<a class="headerlink" href="#call-patterns" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>match-pattern ::= match-pattern-identifier match-pattern-tuple?
match-pattern-identifier ::= &#39;.&#39; identifier
match-pattern-identifier ::= match-pattern-identifier-tower
match-pattern-identifier-tower ::= identifier
match-pattern-identifier-tower ::= identifier
match-pattern-identifier-tower ::= match-pattern-identifier-tower &#39;.&#39; identifier
</pre></div>
</div>
<p>A match pattern can resemble a global name or a call to a global name.
The global name is resolved as normal, and then the pattern is
interpreted according to what is found:</p>
<ul>
<li><p class="first">If the name resolves to a type, then the dynamic type of the matched
value must match the named type (according to the rules below for
&#8216;is&#8217; patterns).  It is okay for this to be trivially true.</p>
<p>In addition, there must be an non-empty arguments clause, and each
element in the clause must have an identifier.  For each element,
the identifier must correspond to a known property of the named
type, and the value of that property must satisfy the element
pattern.</p>
</li>
<li><p class="first">If the name resolves to a enum element, then the dynamic type
of the matched value must match the enum type as discussed above,
and the value must be of the specified element.  There must be
an arguments clause if and only if the element has a value type.
If so, the value of the element is matched against the clause
pattern.</p>
</li>
<li><p class="first">Otherwise, the argument clause (if present) must also be
syntactically valid as an expression, and the entire pattern is
reinterpreted as an expression.</p>
</li>
</ul>
<p>This is all a bit lookup-sensitive, which makes me uncomfortable, but
otherwise I think it makes for attractive syntax.  I&#8217;m also a little
worried about the way that, say, <code class="code docutils literal"><span class="pre">f(x)</span></code> is always an expression
but <code class="code docutils literal"><span class="pre">A(x)</span></code> is a pattern.  Requiring property names when matching
properties goes some way towards making that okay.</p>
<p>I&#8217;m not totally sold on not allowing positional matching against
struct elements; that seems unfortunate in cases where positionality
is conventionally unambiguous, like with a point.</p>
<p>Matching against struct types requires arguments because this is
intended to be used for structure decomposition, not dynamic type
testing.  For the latter, an &#8216;is&#8217; pattern should be used.</p>
</div>
<div class="section" id="expression-patterns">
<h3>Expression patterns<a class="headerlink" href="#expression-patterns" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre>match-pattern ::= expression
</pre></div>
</div>
<p>When ambiguous, match patterns are interpreted using a
pattern-specific production.  I believe it should be true that, in
general, match patterns for a production accept a strict superset of
valid expressions, so that (e.g.) we do not need to disambiguate
whether an open paren starts a tuple expression or a tuple pattern,
but can instead just aggressively parse as a pattern.  Note that
binary operators can mean that, using this strategy, we sometimes have
to retroactively rewrite a pattern as an expression.</p>
<p>It&#8217;s always possible to disambiguate something as an expression by
doing something not allowing in patterns, like using a unary operator
or calling an identity function; those seem like unfortunate language
solutions, though.</p>
</div>
<div class="section" id="satisfying-an-expression-pattern">
<h3>Satisfying an expression pattern<a class="headerlink" href="#satisfying-an-expression-pattern" title="Permalink to this headline">¶</a></h3>
<p>A value satisfies an expression pattern if the match operation
succeeds.  I think it would be natural for this match operation to be
spelled the same way as that match-expression operator, so e.g. a
member function called &#8216;matches&#8217; or a global binary operator called
&#8216;~&#8217; or whatever.</p>
<p>The lookup of this operation poses some interesting questions.  In
general, the operation itself is likely to be associated with the
intended type of the expression pattern, but that type will often
require refinement from the type of the matched value.</p>
<p>For example, consider a pattern like this:</p>
<div class="highlight-python"><div class="highlight"><pre>case 0...10:
</pre></div>
</div>
<p>We should be able to use this pattern when switching on a value which
is not an Int, but if we type-check the expression on its own, we will
assign it the type Range&lt;Int&gt;, which will not necessarily permit us
to match (say) a UInt8.</p>
</div>
<div class="section" id="order-of-evaluation-of-patterns">
<h3>Order of evaluation of patterns<a class="headerlink" href="#order-of-evaluation-of-patterns" title="Permalink to this headline">¶</a></h3>
<p>I&#8217;d like to keep the order of evaluation and testing of expressions
within a pattern unspecified if I can; I imagine that there should be
a lot of cases where we can rule out a case using a cheap test instead
of a more expensive one, and it would suck to have to run the
expensive one just to have cleaner formal semantics.  Specifically,
I&#8217;m worried about cases like <code class="code docutils literal"><span class="pre">case</span> <span class="pre">[foo(),</span> <span class="pre">0]:</span></code>; if we can test
against 0 before calling <code class="code docutils literal"><span class="pre">foo()</span></code>, that would be great.  Also, if
a name is bound and then used directly as an expression later on, it
would be nice to have some flexibility about which value is actually
copied into the variable, but this is less critical.</p>
<div class="highlight-python"><div class="highlight"><pre>*-pattern ::= *-pattern-tuple
*-pattern-tuple ::= &#39;(&#39; *-pattern-tuple-element-list? &#39;...&#39;? &#39;)&#39;
*-pattern-tuple-element-list ::= *-pattern-tuple-element
*-pattern-tuple-element-list ::= *-pattern-tuple-element &#39;,&#39; pattern-tuple-element-list
*-pattern-tuple-element ::= *-pattern
*-pattern-tuple-element ::= identifier &#39;=&#39; *-pattern
</pre></div>
</div>
<p>Tuples are interesting because of the labelled / non-labelled
distinction. Especially with labelled elements, it is really nice to
be able to ignore all the elements you don&#8217;t care about. This grammar
permits some prefix or set of labels to be matched and the rest to be
ignored.</p>
</div>
</div>
<div class="section" id="miscellaneous">
<h2>Miscellaneous<a class="headerlink" href="#miscellaneous" title="Permalink to this headline">¶</a></h2>
<p>It would be interesting to allow overloading / customization of
pattern-matching. We may find ourselves needing to do something like this to
support non-fragile pattern matching anyway (if there&#8217;s some set of restrictions
that make it reasonable to permit that). The obvious idea of compiling into the
visitor pattern is a bit compelling, although control flow would be tricky —
we&#8217;d probably need the generated code to throw an exception. Alternatively, we
could let the non-fragile type convert itself into a fragile type for purposes
of pattern matching.</p>
<p>If we ever allow infix ADT constructors, we&#8217;ll need to allow them in patterns as
well.</p>
<p>Eventually, we will build regular expressions into the language, and we will
allow them directly as patterns and even bind grouping expressions into user
variables.</p>
<p>John.</p>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="StoredAndComputedVariables.html" class="btn btn-neutral float-right" title="Stored and Computed Variables" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="ObjectInitialization.html" class="btn btn-neutral" title="Object Initialization" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright apple.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.1.9',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>