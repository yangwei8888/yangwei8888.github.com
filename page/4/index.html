<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="terry yang's blog | java | scala | bi" />



  <meta name="keywords" content="Hexo,next" />



  <link rel="alternate" href="/atom.xml" title="yosita" type="application/atom+xml" />



  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="terry yang&apos;s blog | java | scala | bi">
<meta property="og:type" content="website">
<meta property="og:title" content="yosita">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="yosita">
<meta property="og:description" content="terry yang&apos;s blog | java | scala | bi">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="yosita">
<meta name="twitter:description" content="terry yang&apos;s blog | java | scala | bi">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>

  <title> yosita </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  

  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?953e46480b0a75d01aaf6d872cc77099";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">yosita</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/05Interacting with C APIs/" itemprop="url">
                02Interoperability-05与 C 的 API 交互
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-26T22:00:06+08:00" content="2015-12-26">
            2015-12-26
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Using-Swift-with-Cocoa-and-Objective-C/" itemprop="url" rel="index">
                  <span itemprop="name">Using-Swift-with-Cocoa-and-Objective-C</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/05Interacting with C APIs/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/02Interoperability/05Interacting with C APIs/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><blockquote>
<p>翻译：<a href="https://github.com/shockinglee" target="_blank" rel="external">shockinglee</a></p>
<p>校对：<a href="https://github.com/shanyimin" target="_blank" rel="external">shanyimin</a> <a href="https://github.com/dabing1022" target="_blank" rel="external">ChildhoodAndy</a> <a href="https://github.com/Phenmod" target="_blank" rel="external">Phenmod</a></p>
</blockquote>
<h1 id="与_C_的_API_交互">与 C 的 API 交互</h1><hr>
<p>本节包含内容：</p>
<ul>
<li><a href="#primitive_types">基本数据类型（Primitive Types）</a></li>
<li><a href="#enumerations">枚举（Enumerations）</a></li>
<li><a href="#pointer">指针（Pointer）</a></li>
<li><a href="#global_constants">全局常量（Global Constants）</a></li>
<li><a href="#preprocessor_directives">预处理指令（Preprocessor Directives）</a></li>
</ul>
<p>作为与Objective-C语言的互用性的一部分，Swift也对一些C语言的类型和特性保持了兼容性。如果你的代码有需要，Swift也提供了一些方式来使用常见的C结构和模式。</p>
<h2 id="基本数据类型">基本数据类型</h2><p>Swift提供了一些与C语言基本类型如<code>char</code>,<code>int</code>,<code>float</code>和<code>double</code>等的对应类型。然而，这些类型和Swift核心基本类型之间不能进行隐式转换，如Int。因此，只有你的代码明确要求时才使用这些类型，其它任何可能的情况下都应该使用Int。</p>
<table>
<thead>
<tr>
<th>C 类型</th>
<th>Swift 类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>bool</td>
<td>CBool</td>
</tr>
<tr>
<td>char, signed char</td>
<td>CChar</td>
</tr>
<tr>
<td>unsigned char</td>
<td>CUnsignedChar</td>
</tr>
<tr>
<td>short</td>
<td>CShort</td>
</tr>
<tr>
<td>unsigned short</td>
<td>CUnsignedShort</td>
</tr>
<tr>
<td>int</td>
<td>CInt</td>
</tr>
<tr>
<td>unsigned int</td>
<td>CUnsignedInt</td>
</tr>
<tr>
<td>long</td>
<td>CLong</td>
</tr>
<tr>
<td>unsigned long</td>
<td>CUnsignedLong</td>
</tr>
<tr>
<td>long long</td>
<td>CLongLong</td>
</tr>
<tr>
<td>unsigned long long</td>
<td>CUnsignedLongLong</td>
</tr>
<tr>
<td>wchar_t</td>
<td>CWideChar</td>
</tr>
<tr>
<td>char16_t</td>
<td>CChar16</td>
</tr>
<tr>
<td>char32_t</td>
<td>CChar32</td>
</tr>
<tr>
<td>float</td>
<td>CFloat</td>
</tr>
<tr>
<td>double</td>
<td>CDouble</td>
</tr>
</tbody>
</table>
<h2 id="枚举">枚举</h2><p>任何用宏<code>NS_ENUM</code>来声明的C风格的枚举，都会被Swfit导入为一个Swfit枚举类型。无论枚举值是在系统框架还是在自己的代码中定义的，当它们导入到Swift时，它们的前缀名将被截掉。</p>
<p>例如，看这个Objective-C枚举的声明：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Objective-C</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UITableViewCellStyle</span>) &#123;</span><br><span class="line">    <span class="built_in">UITableViewCellStyleDefault</span>,</span><br><span class="line">    <span class="built_in">UITableViewCellStyleValue1</span>,</span><br><span class="line">    <span class="built_in">UITableViewCellStyleValue2</span>,</span><br><span class="line">    <span class="built_in">UITableViewCellStyleSubtitle</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在Swift中，会被导入为这样：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//Swift</span><br><span class="line"><span class="keyword">enum</span> UITableViewCellStyle: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">Default</span></span><br><span class="line">    <span class="keyword">case</span> Value1</span><br><span class="line">    <span class="keyword">case</span> Value2</span><br><span class="line">    <span class="keyword">case</span> Subtitle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你需要使用一个枚举值时，使用以点（.）开头的枚举名称：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="keyword">let</span> cellStyle: UITableViewCellStyle = .<span class="built_in">Default</span></span><br></pre></td></tr></table></figure>
<h2 id="选项集">选项集</h2><p>对使用宏<code>NS_OPTIONS</code>声明的C风格的枚举，Swift会把它导入为一个Swfit选项集类型。选项集像枚举一样，会把前缀截掉，只剩下选项值名称。</p>
<p>例如，看这个Objective-C选项的声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Objective-C</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NS_OPTIONS</span><span class="params">(NSUInteger, NSJSONReadingOptions)</span> </span>&#123;</span><br><span class="line">	NSJSONReadingMutableContainers = (<span class="number">1U</span>L &lt;&lt; <span class="number">0</span>),</span><br><span class="line">	NSJSONReadingMutableLeaves = (<span class="number">1U</span>L &lt;&lt; <span class="number">1</span>),</span><br><span class="line">	NSJSONReadingAllowFragments = (<span class="number">1U</span>L &lt;&lt; <span class="number">2</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在Swift中，它被导入为这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NSJSONReadingOptions</span> : <span class="title">OptionSetType</span> </span>&#123;</span><br><span class="line">	<span class="keyword">init</span>(rawValue: <span class="type">UInt</span>)</span><br><span class="line">   </span><br><span class="line">   	<span class="keyword">static</span> <span class="keyword">var</span> <span class="type">MutableContainers</span>: <span class="type">NSJSONReadingOptions</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">   	<span class="keyword">static</span> <span class="keyword">var</span> <span class="type">MutableLeaves</span>: <span class="type">NSJSONReadingOptions</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">   	<span class="keyword">static</span> <span class="keyword">var</span> <span class="type">AllowFragments</span>: <span class="type">NSJSONReadingOptions</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在Objective-C中，一个选项集是整数值的一个位掩码。你可以使用按位或操作符（<code>|</code>）来组合选项值，使用按位与操作符（<code>&amp;</code>）以检测选项值。创建一个选项集，可以使用常量值或者表达式。一个空的选项集使用常数<code>0</code>来表示。</p>
<p>在Swift中，选项集使用一个遵循<code>OptionSetType</code>协议的结构体来表示，其中每个选项值都是一个静态变量。选项集类似于Swift的集合类型<code>Set</code>，你可以用<code>insert(_:)</code>或者<code>unionInPlace(_:)</code>方法来添加选项值，用<code>remove(_:)</code>或者<code>subtractInPlace(_:)</code>方法来删除选项值，用<code>contains(_:)</code>方法来检测选项值。创建一个选项集的值可以使用一个数组字面量，里面的选项值像枚举一样都用点（<code>.</code>）开头。创建一个空的选项集可以使用一个空的数组字面量，也可以调用默认初始化函数。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line">let options: NSDataBase64EncodingOptions = [</span><br><span class="line">	<span class="class">.Encoding76CharacterLineLength</span>,</span><br><span class="line">   	<span class="class">.EncodingEndLineWithLineFeed</span></span><br><span class="line">   ]</span><br><span class="line">let string = data.<span class="function"><span class="title">base64EncodedStringWithOptions</span><span class="params">(options)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="共用体">共用体</h2><p>Swift仅部分支持C的共用体（union）类型。在导入混有C的共用体或者位段（bitfields）的类型时，例如Foundation的<code>NSDecimal</code>类型，Swift不能存取不支持的字段。但是，参数和/或返回值为这些类型的C和Objective-C的API是能够在Swift中使用的。</p>
<h2 id="指针">指针</h2><p>Swift尽可能避免让您直接访问指针。然而，当您需要直接操作内存的时候，Swift也为您提供了多种指针类型。下面的表使用<code>Type</code>作为类型名称的占位符。</p>
<p>对于返回类型，变量和参数，使用如下形式：</p>
<table>
<thead>
<tr>
<th>C 句法</th>
<th>Swift 句法</th>
</tr>
</thead>
<tbody>
<tr>
<td>const Type *</td>
<td>UnsafePointer\<type\></type\></td>
</tr>
<tr>
<td>Type *</td>
<td>UnsafeMutablePointer\<type\></type\></td>
</tr>
</tbody>
</table>
<p>对于类（class）类型，使用如下形式：</p>
<table>
<thead>
<tr>
<th>C 句法</th>
<th>Swift 句法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Type <em> const </em></td>
<td>UnsafePointer\<type\></type\></td>
</tr>
<tr>
<td>Type <em> __strong </em></td>
<td>UnsafeMutablePointer\<type\></type\></td>
</tr>
<tr>
<td>Type **</td>
<td>AutoreleasingUnsafeMutablePointer\<type\></type\></td>
</tr>
</tbody>
</table>
<h3 id="常量指针">常量指针</h3><p>当一个函数被声明为接受<code>UnsafePointer&lt;Type&gt;</code>参数时，这个函数可以接受下列任何一个类型作为参数：</p>
<ul>
<li><code>nil</code>，作为空指针传入；</li>
<li>一个<code>UnsafePointer&lt;Type&gt;</code>，<code>UnsafeMutablePointer&lt;Type&gt;</code>， 或者<code>AutoreleasingUnsafeMutablePointer&lt;Type&gt;</code>的值，在必要情况下会转换成<code>UnsafePointer&lt;Type&gt;</code>的值；</li>
<li>一个<code>String</code>类型的值，如果<code>Type</code>是<code>Int8</code>或者<code>UInt8</code>的话。该字符串会自动在一个缓冲区内被转换为UTF8，该缓冲区在本次调用期间有效；</li>
<li>一个左值操作数为<code>Type</code>类型的输入输出（inout）表达式，传入的是这个左值的内存地址；</li>
<li>一个<code>[Type]</code>值，传入该数组的起始指针，并且它的生命周期将在本次调用期间被延长。</li>
</ul>
<p>如果您这样定义了一个函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesAPointer</span><span class="params">(x: UnsafePointer&lt;Float&gt;)</span></span> &#123; <span class="comment">/*...*/</span> &#125;</span><br></pre></td></tr></table></figure>
<p>那么您可以使用以下任何一种方式来调用这个函数：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//Swift</span></span><br><span class="line">   <span class="tag">var</span> x: Float = <span class="number">0.0</span></span><br><span class="line"><span class="tag">var</span> <span class="tag">p</span>: UnsafePointer&lt;Float&gt; = nil</span><br><span class="line"><span class="function"><span class="title">takesAPointer</span><span class="params">(nil)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAPointer</span><span class="params">(p)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAPointer</span><span class="params">(&amp;x)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAPointer</span><span class="params">([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>])</span></span></span><br></pre></td></tr></table></figure>
<p>如果函数被声明为使用一个<code>UnsafePointer&lt;Void&gt;</code>参数，那么这个函数接受任何<code>Type</code>的<code>UnsafePointer&lt;Type&gt;</code>类型的操作数。<br>￼<br>如果您这样定义了一个函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesAVoidPointer</span><span class="params">(x: UnsafePointer&lt;Void&gt;)</span></span>  &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>那么您可以使用以下任何一种方式来调用这个函数：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//Swift</span></span><br><span class="line">   <span class="tag">var</span> x: Float = <span class="number">0.0</span>, y: Int = <span class="number">0</span></span><br><span class="line"><span class="tag">var</span> <span class="tag">p</span>: UnsafePointer&lt;Float&gt; = nil, <span class="tag">q</span>: UnsafePointer&lt;Int&gt; = nil</span><br><span class="line"><span class="function"><span class="title">takesAVoidPointer</span><span class="params">(nil)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAVoidPointer</span><span class="params">(p)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAVoidPointer</span><span class="params">(q)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAVoidPointer</span><span class="params">(&amp;x)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAVoidPointer</span><span class="params">(&amp;y)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAVoidPointer</span><span class="params">([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>] as [Float])</span></span></span><br><span class="line">let intArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="function"><span class="title">takesAVoidPointer</span><span class="params">(intArray)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="可变指针">可变指针</h3><p>当一个方法被声明为接受<code>UnsafeMutablePointer&lt;Type&gt;</code>参数时，这个函数可以接受下列任何一个类型作为参数：</p>
<ul>
<li><code>nil</code>，作为空指针传入；</li>
<li>一个<code>UnsafeMutablePointer&lt;Type&gt;</code>类型的值；</li>
<li>一个输入输出（inout）表达式，其左值操作数是<code>Type</code>类型的，且被存储起来了。传入的是这个左值的内存地址；</li>
<li>一个输入输出的<code>[Type]</code>类型的值，传入的是该数组的起始指针，并且它的生命周期将在本次调用期间被延长。</li>
</ul>
<p>如果您这样定义了一个函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesAMutablePointer</span><span class="params">(x: UnsafeMutablePointer&lt;Float&gt;)</span></span> &#123; <span class="comment">/*...*/</span> &#125;</span><br></pre></td></tr></table></figure>
<p>那么您可以使用以下任何一种方式来调用这个函数：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//Swift</span></span><br><span class="line">   <span class="tag">var</span> x: Float = <span class="number">0.0</span></span><br><span class="line"><span class="tag">var</span> <span class="tag">p</span>: UnsafeMutablePointer&lt;Float&gt; = nil</span><br><span class="line"><span class="tag">var</span> <span class="tag">a</span>: [Float] = [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>]</span><br><span class="line"><span class="function"><span class="title">takesAMutablePointer</span><span class="params">(nil)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAMutablePointer</span><span class="params">(p)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAMutablePointer</span><span class="params">(&amp;x)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAMutablePointer</span><span class="params">(&amp;a)</span></span></span><br></pre></td></tr></table></figure>
<p>如果函数被声明使用一个<code>UnsafeMutablePointer&lt;Void&gt;</code>参数，那么这个函数接受任何<code>Type</code>的<code>UnsafeMutablePointer&lt;Type&gt;</code>类型的操作数。</p>
<p>如果您这样定义了一个函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesAMutableVoidPointer</span><span class="params">(x: UnsafeMutablePointer&lt;Void&gt;)</span></span>  &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>那么您可以使用以下任何一种方式来调用这个函数：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//Swift</span></span><br><span class="line">   <span class="tag">var</span> x: Float = <span class="number">0.0</span>, y: Int = <span class="number">0</span></span><br><span class="line"><span class="tag">var</span> <span class="tag">p</span>: UnsafeMutablePointer&lt;Float&gt; = nil, <span class="tag">q</span>: UnsafeMutablePointer&lt;Int&gt; = nil</span><br><span class="line"><span class="tag">var</span> <span class="tag">a</span>: [Float] = [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>], <span class="tag">b</span>: [Int] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="function"><span class="title">takesAMutableVoidPointer</span><span class="params">(nil)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAMutableVoidPointer</span><span class="params">(p)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAMutableVoidPointer</span><span class="params">(q)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAMutableVoidPointer</span><span class="params">(&amp;x)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAMutableVoidPointer</span><span class="params">(&amp;y)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAMutableVoidPointer</span><span class="params">(&amp;a)</span></span></span><br><span class="line"><span class="function"><span class="title">takesAMutableVoidPointer</span><span class="params">(&amp;b)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="自动释放指针">自动释放指针</h3><p>当一个函数被声明为接受<code>AutoreleasingUnsafeMutablePointer&lt;Type&gt;</code>参数时，这个函数可以接受下列任何一个类型作为参数：</p>
<ul>
<li><code>nil</code>，作为空指针传入；</li>
<li>一个<code>AutoreleasingUnsafeMutablePointer&lt;Type&gt;</code>类型的值；</li>
<li>一个输入输出（inout）表达式，其操作数首先被拷贝到一个无拥有者的缓冲区，传递给被调用函数的就是这个缓冲区的地址。在调用返回时，缓冲区中的值被加载、保存、并重新复制给操作数。</li>
</ul>
<p>注意，这个列表中没有包含数组。</p>
<p>如果您这样定义了一个函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">takesAnAutoreleasingPointer</span><span class="params">(x: AutoreleasingUnsafeMutablePointer&lt;NSDate?&gt;)</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>那么您可以使用以下任何一种方式来调用这个函数：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//Swift</span></span><br><span class="line">   <span class="keyword">var</span> x: NSDate? = <span class="keyword">nil</span></span><br><span class="line"><span class="keyword">var</span> p: AutoreleasingUnsafeMutablePointer&lt;NSDate?&gt; = <span class="keyword">nil</span></span><br><span class="line">takesAnAutoreleasingPointer(<span class="keyword">nil</span>)</span><br><span class="line">takesAnAutoreleasingPointer(p)</span><br><span class="line">takesAnAutoreleasingPointer(&amp;x)</span><br></pre></td></tr></table></figure>
<p>被指针指向的类型并不会被桥接。例如，<code>NSString **</code>转换到Swift后，是<code>AutoreleasingUnsafeMutablePointer&lt;NSString?&gt;</code>，而不是<code>AutoreleasingUnsafeMutablePointer&lt;String?&gt;</code>。</p>
<h3 id="函数指针">函数指针</h3><p>C语言的函数指针通过调用约定，以闭包的形式被引入Swift中，表示形式为<code>@convention(c)</code>。例如，一个类型为<code>int (*)(void)</code>的C语言函数指针，会转换为Swift的<code>@convention(c) () -&gt; Int32</code>。</p>
<p>在调用一个以函数指针为参数的函数时，给它传的值可以是一个顶层的Swift函数，也可以是个闭包字面量，或者<code>nil</code>。只有符合C语言函数指针调用约定的Swift函数，才能用来给函数指针类型的形参传值。例如，Core Foundation的<code>CFArrayCreateMutable(_:_:_:)</code>函数，它有个参数的类型为<code>CFArrayCallBacks</code>结构体。这个<code>CFArrayCallBacks</code>结构体就是用一些函数指针进行初始化的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">customCopyDescription</span><span class="params">(p: UnsafePointer&lt;Void&gt;)</span></span> -&gt; <span class="type">Unmanaged</span>&lt;<span class="type">CFString</span>&gt;! &#123;</span><br><span class="line">   	<span class="comment">// return an Unmanaged&lt;CFString&gt;! value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> callbacks = <span class="type">CFArrayCallBacks</span>(</span><br><span class="line">   	version: <span class="number">0</span> <span class="keyword">as</span> <span class="type">CFIndex</span>,</span><br><span class="line">   	retain: <span class="literal">nil</span>,</span><br><span class="line">   	release: <span class="literal">nil</span>,</span><br><span class="line">   	copyDescription: customCopyDescription,</span><br><span class="line">   	<span class="built_in">equal</span>: &#123; (p1, p2) -&gt; <span class="type">Boolean</span> <span class="keyword">in</span></span><br><span class="line">       	<span class="comment">// return Boolean value</span></span><br><span class="line">   	&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mutableArray = <span class="type">CFArrayCreateMutable</span>(<span class="literal">nil</span>, <span class="number">0</span>, callbacks)</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，在<code>CFArrayCallBacks</code>初始化时，传给<code>retain</code>和<code>release</code>作参数的是<code>nil</code>，传给<code>copyDescription</code>作参数的是函数<code>customCopyDescription</code>，传给<code>equal</code>作参数的是一个闭包字面量。</p>
<h2 id="全局常量">全局常量</h2><p>在C和Objective-C语言源文件中定义的全局常量会自动地被Swift编译引进并做为Swift的全局常量。</p>
<h2 id="预处理指令">预处理指令</h2><p>Swift编译器不包含预处理器。取而代之的是，它充分利用了编译时属性，生成配置，和语言特性来完成相同的功能。因此，Swift没有引进预处理指令。</p>
<h3 id="简单宏">简单宏</h3><p>在C和Objective-C中，通常使用<code>#define</code>指令来定义一个简单的常数，在Swift，您可以使用全局常量来代替。例如：定义一个常数的<code>#define FADE_ANIMATION_DURATION 0.35</code>，在Swift使用<code>let FADE_ANIMATION_DURATION = 0.35</code>来表述会更好一些。由于简单的用于定义常量的宏会被直接被映射成Swift全局量，Swift编译器会自动引进在C或Objective-C源文件中定义的简单宏。</p>
<h3 id="复杂宏">复杂宏</h3><p>在C和Objective-C中使用的复杂宏在Swift中没有相对应的东西。复杂宏是那些不用来定义常量的宏，包含了括号的函数式宏。您在C和Objective-C使用复杂的宏以避免类型检查的限制或避免重新键入大量的样板代码。然而，宏也会造成debug和重构起来更困难。在Swift中你可以使用函数和泛型来达到同样的效果，而没有任何的委屈折中。因此，在C和Objective-C源文件中定义的复杂宏在Swift是不能使用的。</p>
<h3 id="生成配置">生成配置</h3><p>Swift代码使用和C、Objective-C代码不同的方式进行条件编译。Swift代码可以根据生成配置的组合进行条件编译。生成配置包括<code>true</code>和<code>false</code>字面值，命令行标志，和下表中的平台测试函数。您可以使用<code>-D &lt;＃Flag＃&gt;</code>指定命令行标志。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>有效参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>os()</td>
<td>OSX，iOS，watchOS</td>
</tr>
<tr>
<td>arch()</td>
<td>x86_64，arm，arm64，i386</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意：生成配置<code>arch(arm)</code>不会为64位ARM设备返回<code>true</code>，生成配置<code>arch(i386)</code>在为32位iOS模拟器编译代码时会返回<code>true</code>。</p>
</blockquote>
<p>一个简单的条件编译可以像下面这段代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">if</span> build configuration</span></span><br><span class="line">  statements</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">  statements</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>由零个或多个有效的Swift语句组成的<em>statements</em>，可以包括表达式，普通语句和控制流语句。可以使用<code>&amp;&amp;</code>和<code>||</code>操作符往一个条件编译语句上添加新的编译条件，使用<code>!</code>操作符来否定某条件，使用<code>#elseif</code>来添加编译块：</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">if</span> build configuration &amp;&amp; !build configuration</span></span><br><span class="line">  statements<span class="preprocessor"></span><br><span class="line">#<span class="keyword">elseif</span> build configuration</span></span><br><span class="line">  statements<span class="preprocessor"></span><br><span class="line">#<span class="keyword">else</span></span></span><br><span class="line">  statements<span class="preprocessor"></span><br><span class="line">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>与C语言编译器的条件编译不同的是，Swift条件编译的语句必须是独立完整、语法有效的代码块。这是因为所有的Swift代码都会做语法检查，而不管会不会被编译。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/03Mix and Match/Swift and Objective-C in the Same Project/" itemprop="url">
                03Mix and Match-01Mix and Match 概述（Mix and Match Overview
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-26T22:00:05+08:00" content="2015-12-26">
            2015-12-26
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Using-Swift-with-Cocoa-and-Objective-C/" itemprop="url" rel="index">
                  <span itemprop="name">Using-Swift-with-Cocoa-and-Objective-C</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/03Mix and Match/Swift and Objective-C in the Same Project/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/03Mix and Match/Swift and Objective-C in the Same Project/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><blockquote>
<p>翻译：<a href="https://github.com/haolloyin" target="_blank" rel="external">haolloyin</a></p>
<p>校对：<a href="https://github.com/dabing1022" target="_blank" rel="external">ChildhoodAndy</a></p>
</blockquote>
<h1 id="在同个工程中使用_Swift_和_Objective-C">在同个工程中使用 Swift 和 Objective-C</h1><hr>
<p>本节包含内容：</p>
<ul>
<li><a href="#mix_and_match_overview">Mix and Match 概述（Mix and Match Overview）</a></li>
<li><a href="#importing_code_from_within_the_same_app_target">在同个应用的 target 中导入（Importing Code from Within the Same App Target）</a></li>
<li><a href="#importing_code_from_within_the_same_framework_target">在同个 Framework 的 target 中导入（Importing Code from Within the Same Framework Target）</a></li>
<li><a href="#importing_external_frameworks">导入外部 framework（Importing External Frameworks）</a></li>
<li><a href="#using_swift_from_objective-c">在 Objective-C 中使用 Swift（Using Swift from Objective-C）</a></li>
<li><a href="#overriding_swift_names_for_Objective">为 Objective-C 接口重写 Swift 名称</a></li>
<li><a href="#naming_your_product_module">Product 模块命名（Naming Your Product Module）</a></li>
<li><a href="#troubleshooting_tips_and_reminders">问题解决提示（Troubleshooting Tips and Reminders）</a></li>
</ul>
<p>Swift 与 Objective-C 的兼容能力使你可以在同一个工程中同时使用两种语言。你可以用这种叫做 <code>mix and match</code> 的特性来开发基于混合语言的应用，可以用 Swift 的最新特性实现应用的一部分功能，并无缝地并入已有的 Objective-C 的代码中。</p>
<p><a name="mix_and_match_overview"></a></p>
<h2 id="Mix_and_Match_概述">Mix and Match 概述</h2><p>Objective-C 和 Swift 文件可以在一个工程中并存，不管这个工程原本是基于 Objective-C 还是 Swift。你可以直接往现有工程中简单地添加另一种语言的源文件。这种自然的工作流使得创建混合语言的应用或框架 target，与用单独一种语言时一样简单。</p>
<p>混合语言的工作流程只有一点点区别，这取决于你是在写应用还是写框架。下面描述了普通的用两种语言在一个 target 中导入模型的情况，后续章节会有更多细节。</p>
<p><img src="http://7xp6cn.com1.z0.glb.clouddn.com/DAG_2x.png" alt="DAG_2x.png"></p>
<p><a name="importing_code_from_within_the_same_app_target"></a></p>
<h2 id="在同个应用的_target_中导入">在同个应用的 target 中导入</h2><p>如果你在写混合语言的应用，可能需要用 Swift 代码访问 Objective-C 代码，或者反之。下面的流程描述了在非框架 target 中的应用。</p>
<h3 id="将_Objective-C_导入_Swift">将 Objective-C 导入 Swift</h3><p>在一个应用的 target 中导入一些 Objective-C 文件供 Swift 代码使用时，你需要依赖于 Objective-C 的桥接头文件（<code>bridging header</code>）来暴露给 Swift。当你添加 Swift 文件到现有的 Objective-C 应用（或反之）时，Xcode 会自动创建这些头文件。</p>
<p><img src="http://7xp6cn.com1.z0.glb.clouddn.com/bridgingheader_2x.png" alt="bridgingheader_2x.png"></p>
<p>如果你同意，Xcode 会在源文件创建的同时生成头文件，并用 product 的模块名加上 <code>-Bridging-Header.h</code> 命名。关于 product 的模块名，详见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_85" target="_blank" rel="external">Naming Your Product Module</a>。</p>
<p>你应该编辑这个头文件来对 Swift 暴露出 Objective-C 代码。</p>
<h4 id="在同一_target_中将_Objective-C_代码导入到_Swift_中">在同一 target 中将 Objective-C 代码导入到 Swift 中</h4><ol>
<li>在 Objective-C 桥接头文件中，<code>import</code>任何你想暴露给 Swift 的头文件，例如：</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &#34;XYZCustomCell.h&#34;&#10;#import &#34;XYZCustomView.h&#34;&#10;#import &#34;XYZCustomViewController.h&#34;</span><br></pre></td></tr></table></figure>
<ol>
<li>确保在 <code>Build Settings</code> 中 Objective-C 桥接头文件的 <code>build setting</code> 是基于 Swfit 编译器，即 <code>Code Generation</code> 含有头文件的路径。这个路径必须是头文件自身的路径，而不是它所在的目录。</li>
</ol>
<p>这个路径应该是你工程的相对路径，类似 <code>Info.plist</code> 在 <code>Build Settings</code> 中指定的路径。在大多数情况下，你不需要修改这个设置。</p>
<p>在这个桥接头文件中列出的所有 public 的 Objective-C 头文件都会对 Swift 可见。之后当前 target 的所有 Swift 文件都可以使用这些头文件中的方法，不需要任何 import 语句。用 Swift 语法使用这些 Objective-C 代码，就像使用系统自带的 Swift 类一样。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myCell = <span class="type">XYZCustomCell</span>()</span><br><span class="line">myCell.subtitle = <span class="string">"A custom cell"</span></span><br></pre></td></tr></table></figure>
<h3 id="将_Swift_导入到_Objective-C">将 Swift 导入到 Objective-C</h3><p>当你在将 Swift 代码导入到 Objective-C 中时，你依赖于 Xcode 生成的头文件来将这些文件暴漏给 Objective-C。这个自动生成的文件是一个 Objective-C 头文件，它包含了你的 target 中所有 Swift 代码中定义的接口。可以把这个 Objective-C 头文件看作 Swift 代码的 <code>umbrella header</code>。头文件名称以 product 模块名加 <code>-Swift.h</code> 来命名。（关于 product 的模块名，详见<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_85" target="_blank" rel="external">Naming Your Product Module</a>）。</p>
<p>默认情况下，生成的头文件包含了标记有<code>public</code>修饰符的 Swift 声明接口。它还包含那些打上，如果您的应用程序的目标有一个Objective-C的桥接头内部修改。标有private修饰符声明不会出现在所生成的报头。私人声明没有接触到Objective-C的，除非它们被明确标有@IBAction，@IBOutlet，或@objc为好。如果您的应用程序的目标是编译测试启用，单元测试目标可以访问任何声明与内部修饰，仿佛他们与公众修饰符通过预先@testable的产品模块导入语句声明。</p>
<p>你不需要做任何事情来生成这个头文件，只需要将它导入到你的 Objective-C 代码来使用它。注意这个头文件中的 Swift 接口包含了它所使用到的所有 Objective-C 类型。如果你在 Swift 代码中使用你自己的 Objective-C 类型，确保先将对应的 Objective-C 头文件导入到你的 Swift 代码中，然后才将 Swift 自动生成的头文件导入到 Objective-C .m 源文件中来访问 Swift 代码。</p>
<h5 id="在同一_target_中将_Swift_代码导入到_Objective-C_中">在同一 target 中将 Swift 代码导入到 Objective-C 中</h5><ul>
<li>在相同 target 的 Objective-C .m 源文件中，用下面的语法来导入Swift 代码：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &#34;ProductModuleName-Swift.h&#34;</span><br></pre></td></tr></table></figure>
<p>target 中任何 Swift 文件将会对 Objective-C .m 源文件可见，包括这个 import 语句。关于在 Objective-C 代码中使用 Swift 代码，详见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_84" target="_blank" rel="external">Using Swift from Objective-C</a>。</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">导入到 Swift</th>
<th style="text-align:center">导入到 Objective-C</th>
</tr>
</thead>
<tbody>
<tr>
<td>Swift 代码</td>
<td style="text-align:center">不需要import语句</td>
<td style="text-align:center">#import “ProductModuleName-Swift.h”</td>
</tr>
<tr>
<td>Objective-C 代码</td>
<td style="text-align:center">不需要import语句；需要 Objective-C bridging头文件</td>
<td style="text-align:center">#import “Header.h”</td>
</tr>
</tbody>
</table>
<p><a name="importing_code_from_within_the_same_framework_target"></a></p>
<h2 id="在同个_Framework_的_target_中导入">在同个 Framework 的 target 中导入</h2><p>如果你在写一个混合语言的框架，可能会从 Swift 代码访问 Objective-C 代码，或者反之。</p>
<h3 id="将_Objective-C_导入_Swift-1">将 Objective-C 导入 Swift</h3><p>要将一些 Objective-C 文件导入到同个框架 target 的 Swift 代码中去，你需要将这些文件导入到 Objective-C 的 <code>umbrella header</code> 来供框架使用。</p>
<h5 id="在同一_framework_中将_Objective-C_代码导入到_Swift_中">在同一 framework 中将 Objective-C 代码导入到 Swift 中</h5><p>确保将框架 target 的 <code>Build Settings &gt; Packaging &gt; Defines Module</code> 设置为 <code>Yes</code>。然后在你的 <code>umbrella header</code> 头文件中导入你想暴露给 Swift 访问的 Objective-C 头文件，例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &#60;XYZ/XYZCustomCell.h&#62;&#10;#import &#60;XYZ/XYZCustomView.h&#62;&#10;#import &#60;XYZ/XYZCustomViewController.h&#62;</span><br></pre></td></tr></table></figure>
<p>Swift 将会看到所有你在 <code>umbrella header</code> 中公开暴露出来的头文件，框架 target 中的所有 Swift 文件都可以访问你 Objective-C 文件的内容，不需要任何 import 语句。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myCell = <span class="type">XYZCustomCell</span>()</span><br><span class="line">myCell.subtitle = <span class="string">"A custom cell"</span></span><br></pre></td></tr></table></figure>
<h3 id="将_Swift_导入_Objective-C">将 Swift 导入 Objective-C</h3><p>要将一些 Swift 文件导入到同个框架的 target 的 Objective-C 代码去，你不需要导入任何东西到 <code>umbrella header</code> 文件，而是将 Xcode 为你的 Swift 代码自动生成的头文件导入到你的 Obj .m 源文件去，以便在 Objective-C 代码中访问 Swift 代码。</p>
<h5 id="在同一_framework_中将_Swift_代码导入到_Objective-C_中">在同一 framework 中将 Swift 代码导入到 Objective-C 中</h5><p>确保将框架 target 的 <code>Build Settings &gt; Packaging</code> 中的 <code>Defines Module</code> 设置为 <code>Yes</code>。用下面的语法将 Swift 代码导入到同个框架 target 下的 Objective-C .m 源文件去。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// OBJECTIVE-C&#10;#import &#60;ProductName/ProductModuleName-Swift.h&#62;</span><br></pre></td></tr></table></figure>
<p>这个 import 语句所包含的 Swift 文件都可以被同个框架 target 下的 Objective-C .m 源文件访问。关于在 Objective-C 代码中使用 Swift 代码，详见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_84" target="_blank" rel="external">Using Swift from Objective-C</a>。</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">导入到 Swift</th>
<th style="text-align:center">导入到 Objective-C</th>
</tr>
</thead>
<tbody>
<tr>
<td>Swift 代码</td>
<td style="text-align:center">不需要import语句</td>
<td style="text-align:center">#import “ProductName/ProductModuleName-Swift.h”</td>
</tr>
<tr>
<td>Objective-C 代码</td>
<td style="text-align:center">不需要import语句；需要 Objective-C umbrella头文件</td>
<td style="text-align:center">#import “Header.h”</td>
</tr>
</tbody>
</table>
<p><a name="importing_external_frameworks"></a></p>
<h2 id="导入外部_Framework">导入外部 Framework</h2><p>你可以导入外部框架，不管这个框架是纯 Objective-C，纯 Swift，还是混合语言的。import 外部框架的流程都是一样的，不管这个框架是用一种语言写的，还是包含两种语言。当你导入外部框架时，确保 <code>Build Setting &gt; Pakaging &gt; Defines Module</code> 设置为 <code>Yes</code>。</p>
<p>用下面的语法将框架导入到不同 target 的 Swift 文件中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> FrameworkName</span><br></pre></td></tr></table></figure>
<p>用下面的语法将框架导入到不同 target 的 Objective-C .m 文件中：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import FrameworkName;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">导入到 Swift</th>
<th style="text-align:center">导入到 Objective-C</th>
</tr>
</thead>
<tbody>
<tr>
<td>任意语言框架</td>
<td style="text-align:center">import FrameworkName</td>
<td style="text-align:center">@import FrameworkName;</td>
</tr>
</tbody>
</table>
<p><a name="using_swift_from_objective-c"></a></p>
<h2 id="在_Objective-C_中使用_Swift">在 Objective-C 中使用 Swift</h2><p>当你将 Swift 代码导入 Objective-C 之后，便可用常规的 Objective-C 语法来使用 Swift 类。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MySwiftClass *swiftObject = [[MySwiftClass alloc] init];&#10;[swiftObject swiftMethod];</span><br></pre></td></tr></table></figure>
<p>Swift 的类或协议必须用 <code>@objc</code>属性来标记，以便在 Objective-C 中可访问。这个 属性告诉编译器这块 Swift 代码可以从 Objective-C 代码中访问。如果你的 Swift 类是 Objective-C 类的子类，编译器会自动为你添加 <code>@objc</code>。详见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID53" target="_blank" rel="external">Swift Type Compatibility</a>。</p>
<p>你可以访问在 Swift 类或协议中使用用<code>@objc</code>属性标记的任何对象，只要该对象与 Objective-C 兼容。不包括以下 Swift 独有的特性：</p>
<ul>
<li><p>范型（Generics）</p>
</li>
<li><p>元组（Tuples）</p>
</li>
<li><p>Swift 中定义的枚举不包括<code>Int</code>原始值类型（Enumerations defined in Swift without Int raw value type）</p>
</li>
<li><p>Swift 中定义的结构体（Structures defined in Swift）   </p>
</li>
<li><p>Swift 中定义的顶层函数（Top-level functions defined in Swift）</p>
</li>
<li><p>Swift 中定义的全局变量（Global variables defined in Swift）</p>
</li>
<li><p>Swift 中定义的类型别名（Typealiases defined in Swift）</p>
</li>
<li><p>Swift风格可变参数（Swift-style variadics）</p>
</li>
<li><p>嵌套类型（Nested types）</p>
</li>
<li><p>柯里化函数（Curried functions）</p>
</li>
</ul>
<p>例如，使用范型类型作为参数，或者返回元组的方法将不能在 Objective-C 中使用。</p>
<blockquote>
<p>注意<br>你不能在 Objective-C 继承一个 Swift 类。</p>
</blockquote>
<h3 id="在_Objective-C_头文件中引用_Swift_类">在 Objective-C 头文件中引用 Swift 类</h3><p>这样前向声明 Swift 类：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// OBJECTIVE-C&#10;// MyObjective-CClass.h&#10;&#10;@class MySwiftClass;&#10;&#10;@interface MyObjective-CClass : NSObject&#10;- (MySwiftClass *)returnSwiftObject;&#10;/* ... */&#10;@end</span><br></pre></td></tr></table></figure>
<p><a name="overriding_swift_names_for_Objective-C_interfaces"></a></p>
<h2 id="为_Objective-C_接口重写_Swift_名称">为 Objective-C 接口重写 Swift 名称</h2><p>Swift 编译器自动的将 Objective-C 代码作为常规 Swift 代码导入。它将 Objective-C 的类工厂方法作为 Swift 构造器导入，以及将 Objective-C 的枚举类型名称截断处理。</p>
<p>在你的代码中也许存在不能够被自动处理的边界情况。如果你需要更改导入到 Swift 中的 Objective-C 方法，枚举，或者可选 set 值，你可以使用<code>NS_SWIFT_NAME</code>宏来自定义导入的声明。</p>
<h3 id="类工厂方法">类工厂方法</h3><p>如果 Swift 编译器无法识别类工厂方法，你可以使用<code>NS_SWIFT_NAME</code>宏，来正确导入构造器的 Swift 签名。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)recordWithRPM:(NSUInteger)RPM NS_SWIFT_NAME(init(RPM:));</span><br></pre></td></tr></table></figure>
<p>如果 Swift 编译器错误的将一个方法识别为类工厂方法，你可以使用<code>NS_SWIFT_NAME</code>宏，来正确导入构造器的 Swift 签名。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(id)recordWithQuality:(double)quality NS_SWIFT_NAME(record(quality:));</span><br></pre></td></tr></table></figure>
<h3 id="枚举">枚举</h3><p>默认情况下，Swift 将枚举值的名称前缀做截断来导入枚举。如果要自定义枚举值的名称，你可以使用<code>NS_SWIFT_NAME</code>宏来传递 Swift 枚举值名称。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, ABCRecordSide) &#123;&#10;  ABCRecordSideA,&#10;  ABCRecordSideB NS_SWIFT_NAME(&#34;FlipSide&#34;),&#10;&#125;;</span><br></pre></td></tr></table></figure>
<p><a name="naming_your_product_module"></a></p>
<h2 id="Product_模块命名">Product 模块命名</h2><p>Xcode 为 Swift 代码生成的头文件的名称，以及 Xcode 创建的 Objective-C 桥接头文件名称，都是从你的 product 模块名生成的。默认你的 product 模块名和 product 名一样。然而，如果你的 product 名有特殊字符（nonalphanumeric，非数字、字母的字符），例如点号，那么它们会被下划线（<code>_</code>）替换之后作为你的 product 模块名。如果 product 名以数字开头，那么第一个数字会用下划线替换掉。</p>
<p>你可以给 product 模块名提供一个自定义的名称，Xcode 会用这个名称来命名桥接的和自动生成的头文件。你只需要在修改在 <code>build setting</code> 中的 <code>Product Module Name</code> 即可。</p>
<p><a name="troubleshooting_tips_and_reminders"></a></p>
<h2 id="问题解决提示">问题解决提示</h2><ul>
<li>把 Swift 和 Objective-C 文件看作相同的代码集合，并注意命名冲突。</li>
<li>如果你使用了框架，确保在<code>Packaging</code>下的<code>Defines Module</code>编译设置被设置为 <code>Yes</code>。</li>
<li>如果你使用了 Objective-C 桥接头文件，确保 Swift 编译器中 Objective-C 桥接头文件的编译设置<code>Code Generation</code>有一个与项目相关的头文件的路径。这个路径必须是头文件自身的路径，而不是它所在的目录。</li>
<li>Xcode 使用你的工程模块名，而不是以<code>target</code>的名称来命名 Objective-C 桥接头文件以及为 Swift 代码 自动生成的头文件。详见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-ID138" target="_blank" rel="external">Naming Your Product Module</a>。</li>
<li>为了在 Objective-C 中可用， Swift 类必须是 Objective-C 类的子类，或者用 <code>@objc</code> 标记。</li>
<li>当你将 Swift 导入到 Objective-C 中时，记住 Objective-C 不会将 Swift 独有的特性转化成 Objective-C 对应的特性。详见列表 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-ID136" target="_blank" rel="external">Using Swift from Objective-C</a>。</li>
<li>如果你在 Swift 代码中使用你自己的 Objective-C 类型，确保先将对应的 Objective-C 头文件导入到你的 Swift 代码中，然后才将 Swift 自动生成的头文件导入到 Objective-C .m 源文件中来访问 Swift 代码。</li>
<li>用<code>private</code>修饰符标记的 Swift 声明不会出现在自动生成的头文件中。私有声明不会暴漏给 Objective-C，除非它们被明确标记有<code>@IBAction</code>，<code>@IBOutlet</code>或者<code>@objc</code>等。</li>
<li>对于应用 targets 而言，如果有 Objective-C 桥接头文件时，被<code>internal</code>修饰符标记的声明会出现在自动产生的头文件中。</li>
<li>对于框架 targets 而言，只有被<code>public</code>修饰符标记的声明才会出现在自动生成的头文件中。你仍然可以在框架中的 Objective-C 部分使用被<code>internal</code>修饰符标记的 Swift 方法和属性，只要它们声明所在的类继承自 Objective-C 类。关于访问级别修饰符的更多信息，请查看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097" target="_blank" rel="external">The Swift Programming Language</a>中的<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html#//apple_ref/doc/uid/TP40014097-CH41" target="_blank" rel="external">访问控制(Access Control)</a></li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/04Migration/Migrating Your Objective-C Code to Swift/" itemprop="url">
                04Migration-01为你的Objective-c代码做好迁移准备
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-26T22:00:04+08:00" content="2015-12-26">
            2015-12-26
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Using-Swift-with-Cocoa-and-Objective-C/" itemprop="url" rel="index">
                  <span itemprop="name">Using-Swift-with-Cocoa-and-Objective-C</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/04Migration/Migrating Your Objective-C Code to Swift/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/04Migration/Migrating Your Objective-C Code to Swift/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><blockquote>
<p>翻译：<a href="https://github.com/xudeheng" target="_blank" rel="external">xudeheng</a></p>
<p>校对：<a href="http://github.com/dabing1022" target="_blank" rel="external">ChildhoodAndy</a></p>
</blockquote>
<h1 id="将_Objective-C_代码迁移到_Swift">将 Objective-C 代码迁移到 Swift</h1><hr>
<p>本节内容包括：</p>
<ul>
<li><a href="#preparing_your_objective-c_code_for_migration">为你的Objective-c代码做好迁移准备<br>（Preparing Your Objective-C Code for Migration）</a></li>
<li><a href="#the_migration_process">迁移过程（The Migration Process）</a></li>
<li><a href="#troubleshooting_tips_and_reminders">问题解决提示（Troubleshooting Tips and Reminders）</a></li>
</ul>
<p>迁移工作提供了一个重新审视现有 Objective-C 应用程序的机会，并通过 替换部分Swift 代码来更好的优化应用程序的架构，逻辑以及性能。换句话说，所谓增量app迁移，就是让你使用之前的工具-mix and match 来提升相互之间的可操作性。当要选择哪些特性和功能来用 Swift，哪些依然用 Objective-C 实现时，Mix-and-match让这一切变得简单。Swift 和 Objective-C 的互用性又使得将这些功能集成到 Objective-C 变得并不困难。通过这些工具可以开放 Swift 的扩展功能并集成到现有的 Objective-C 项目中而完全不必立刻使用 Swift 重写整个项目。</p>
<p><a name="preparing_your_objective-c_code_for_migration"></a></p>
<h2 id="为你的Objective-C代码做好迁移准备">为你的Objective-C代码做好迁移准备</h2><p>在开始迁移你的代码之前，请确保你的 Objective-C 和 Swift 代码间有着最佳兼容性。这意味着整理并使用 Objective-C 的现代化特性来优化你的现有项目。为了和 Swift 进行更容易的无缝交互，你的现有代码需要遵循现代编码实践。在开始前，有个简短的适配练习列表，参看<a href="https://developer.apple.com/library/prerelease/ios/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html#//apple_ref/doc/uid/TP40014150" target="_blank" rel="external">Adopting Mordern Objective-C</a>。</p>
<p><a name="the_migration_process"></a></p>
<h2 id="迁移过程">迁移过程</h2><p>最有效迁移代码的方式是基于逐个文件，即一次完成一个类。由于你不能在 Objective-C 中继承 Swift类， 最好选择一个没有子类的（译者：从类的继承角度来看，应该先从类族树的叶子节点开始，自底向上的进行迁移操作）。你就可以用单个<code>.swift</code>文件来代替对应的<code>.m</code>和<code>.h</code>文件了。你所有的实现代码和接口将直接放进单个 Swift 文件。你不用再创建头文件了；Xcode 会在你需要引用的时候自动生成头文件。(译者：当然这是在xcode内部机制完成的了，对开发者是透明的)</p>
<h3 id="准备工作">准备工作</h3><ul>
<li>在 Xcode 中:File&gt;New&gt;File&gt;(iOS 或者 OS X) &gt; Other &gt; Swift 为对应的 Objective-C<code>.m</code> 和<code>.h</code>文件创建一个 Swift 类。</li>
<li>导入相关系统框架。</li>
<li>如果你希望在 Swift 文件中访问 Objective-C 代码的话，可以填入一个 Objective-C 桥接头。具体的操作步骤，请看 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_77" target="_blank" rel="external">Importing Code from Within the Same App Target</a>。</li>
<li>为使你的 Swift 类能在 Objective-C 中访问使用，可以继承 Objective-C 类，或者标记上<code>@objc</code>属性。为类指定特殊的名称，以在 Objective-C 中使用，标记上<code>@objc(#name#)</code>, <code>&lt;#name#&gt;</code>就是在 Objective-C 中引用的 Swift 类名。 更多信息，请看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-XID_36" target="_blank" rel="external">Swift Type Compatibility</a>。</li>
</ul>
<h3 id="开始工作">开始工作</h3><ul>
<li>你可以通过继承 Objective-C 类，适配 Objective-C 协议，或者更多的方式，来让 Swift 类集成  Objective-C 行为。更多信息，请看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WritingSwiftClassesWithObjective-CBehavior.html#//apple_ref/doc/uid/TP40014216-CH5-XID_54" target="_blank" rel="external">Writing Swift Classes with Objective-C Behavior</a></li>
<li>当你使用 Objective-C APIs 的时候，你需要知道 Swift 是怎样来翻译某些 Objective-C 特性的。更多信息，请看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-XID_26" target="_blank" rel="external">Interacting with Objective-C APIs</a></li>
<li>当用 Swift 编写用到 Cocoa 框架的代码时，记住某些类型是被桥接的，意味着你可以使用某些 Swift 类型来替代 Objective-C 类型。更多信息，请看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-XID_40" target="_blank" rel="external">Working with Cocoa Data Types</a></li>
<li>当你在 Swift 中运用 Cocoa设计模式得时候，请看 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-XID_5" target="_blank" rel="external">Adopting Cocoa Design Patterns</a>获取更多的通用设计模式的转换信息。</li>
<li>对于打算将项目从 Objective-C 转换到 Swfit 的人，请看 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13" target="_blank" rel="external">Properties</a>。</li>
<li>在必要的时候，请为 Swift 的属性或方法，通过<code>@objc(&lt;#name#&gt;)</code>属性来提供 Objective-C 名称，就像这样：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> enabled: <span class="type">Bool</span> &#123;</span><br><span class="line">	<span class="preprocessor">@objc</span>(isEnabled) <span class="keyword">get</span> &#123;</span><br><span class="line">		<span class="comment">/* ... */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>分别用<code>func</code>和<code>class func</code>来表示 instance(-) 和 class(+) 方法。</li>
<li>声明简单的宏来作为常量，将复杂的宏转换为函数。</li>
</ul>
<h3 id="大功告成">大功告成</h3><ul>
<li>在你的 Objective-C 代码中更新 import 语句为 #import “模块名-Swift.h”，可参阅<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_77" target="_blank" rel="external">Importing Code from Within the Same App Target</a>中曾有提到。</li>
<li>在Target 的成员选择框中去掉勾选框来移除原始的 Objective-C<code>.m</code>文件.不要立刻删除<code>.m</code>和<code>.h</code>文件，以备解决问题用。</li>
<li>如果你给 Swift 类起了一个不同的名字，请使用 Swift 类名代替 Objective-C 名。</li>
</ul>
<p><a name="troubleshooting_tips_and_reminders"></a></p>
<h2 id="问题解决提示">问题解决提示</h2><p>尽管对于不同的项目，迁移的经历是不尽相同的，无论怎样，都有一些通用的步骤和工具能帮你解决代码迁移时碰到的问题：</p>
<ul>
<li>记住：你不能在 Objective-C 中继承 Swift 类。因此，被你迁移的类不能有任何的 Objective-C 子类存在于你的应用中。</li>
<li>当你迁移一个类到 Swift 的时候，你必须从 target 中移除相关的<code>.m</code>文件，以避免编译时提示出现重复的符号等编译错误。</li>
<li>为了在 Objective-C 中可以访问并使用，Swift 类必须是一个 Objective-C 类的子类，或者被标记为<code>@objc</code>。</li>
<li>当你在 Objective-C 中使用 Swift 代码的时候，记住 Objective-C 不能理解那些 Swift 的某些特性，请看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-XID_84" target="_blank" rel="external">Using Swift from Objective-C</a>。</li>
<li>可以通过<code>Commond + 单击</code>一个 Swift 类名来查看它生成的头文件。</li>
<li>可以通过<code>Option + 单击</code>一个符号来查看更详细的信息，比如它的类型，属性以及文档注释等。</li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/05Revision History/Document Revision History/" itemprop="url">
                05Revision History-Document Revision History
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-26T22:00:03+08:00" content="2015-12-26">
            2015-12-26
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/Using-Swift-with-Cocoa-and-Objective-C/" itemprop="url" rel="index">
                  <span itemprop="name">Using-Swift-with-Cocoa-and-Objective-C</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/05Revision History/Document Revision History/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/26/Using-Swift-with-Cocoa-and-Objective-C/05Revision History/Document Revision History/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="文档修订历史">文档修订历史</h1><p>该表格描述了 Using Swift with Cocoa and Objective-C 一书的改动。</p>
<table class="graybox" border="0" cellspacing="0" cellpadding="5"><br><thead><br>    <tr><br>        <th scope="col" width="100">日期</th><br>       <th scope="col">变更记录</th><br>    </tr><br></thead><br><tbody><br>    <tr><br>    <td scope="row">2015-06-08</td><br>    <td><ul class="list-bullet"><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID35" target="_blank" rel="external"> Interacting with Objective-C APIs </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WritingSwiftClassesWithObjective-CBehavior.html#//apple_ref/doc/uid/TP40014216-CH5-ID152" target="_blank" rel="external"> NSCoding </a>部分。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID61" target="_blank" rel="external"> Working with Cocoa Data Types </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID83" target="_blank" rel="external"> Memory Managed Objects </a>部分。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID61" target="_blank" rel="external"> Working with Cocoa Data Types </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID151" target="_blank" rel="external"> Sets </a>部分。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216-CH2-ID2" target="_blank" rel="external"> Setting Up Your Swift Environment </a>中补充说明有关由命令行建立的可执行文件的 Swift target 系统要求。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID35" target="_blank" rel="external"> Interacting with Objective-C APIs </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID45" target="_blank" rel="external"> Nullability and Optionals </a>部分。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID35" target="_blank" rel="external"> Interacting with Objective-C APIs </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-ID170" target="_blank" rel="external"> Unions </a>部分。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID35" target="_blank" rel="external"> Interacting with Objective-C APIs </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-ID169" target="_blank" rel="external"> Option Sets </a>部分。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-ID6" target="_blank" rel="external"> Adopting Cocoa Design Patterns </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-ID160" target="_blank" rel="external"> API Availability </a>部分。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID35" target="_blank" rel="external"> Interacting with Objective-C APIs </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-ID162" target="_blank" rel="external"> Overriding Swift Names for Objective-C Interfaces </a>部分。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-ID6" target="_blank" rel="external"> Adopting Cocoa Design Patterns </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-ID10" target="_blank" rel="external"> Error Handling </a>部分。<br>        </p></li><br>        <li><p><br>        更新<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html#//apple_ref/doc/uid/TP40014216-CH10-ID122" target="_blank" rel="external"> Swift and Objective-C in the Same Project </a>章节中关于 @testable 注解的信息。<br>        </p></li><br>        <li><p><br>        更新<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-ID148" target="_blank" rel="external"> Function Pointers </a>章节中关于将 Swift 函数和闭包与 C 函数指针桥接的信息。<br>        </p></li><br>        <li><p><br>        更新<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-ID146" target="_blank" rel="external"> Constant Pointers </a>章节中关于将 Swift String 值与 C 指针桥接的信息。<br>        </p></li><br>        <li><p><br>        更新<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID55" target="_blank" rel="external"> Exposing Swift Interfaces in Objective-C </a>章节中关于在 Swift 中使用 @objc 来标注枚举的信息。<br>        </p></li><br>        <li><p><br>        更新<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID69" target="_blank" rel="external"> Collection Classes </a>章节，讨论 Swift 对 Objective-C 集合类的参数化桥接。<br>        </p></li><br>        </ul><br>    </td><br>  </tr><br><br>      <tr><br>    <td scope="row">2015-02-23</td><br>    <td><ul class="list-bullet"><br>        <li><p><br>        更新<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID61" target="_blank" rel="external"> Working with Cocoa Data Types </a>章节，在 Swift 1.2 中使用 as! 操作符和桥接语义。<br>        </p></li><br>        </ul><br>    </td><br>   </tr><br><br>    <tr><br>    <td scope="row">2015-01-18</td><br>    <td><ul class="list-bullet"><br>        <li><p><br>        修复了 UIBezierPath 例子以正确的创建一个三角形<br>        </p></li><br>        </ul><br>    </td><br>   </tr><br><br>    <tr><br>    <td scope="row">2015-01-18</td><br>    <td><ul class="list-bullet"><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID35" target="_blank" rel="external"> Interacting with Objective-C APIs </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID145" target="_blank" rel="external"> Failable Initialization </a>部分。<br><br>        </p></li><br>        </ul><br>    </td><br>   </tr><br><br>       <tr><br>    <td scope="row">2014-09-02</td><br>    <td><ul class="list-bullet"><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WritingSwiftClassesWithObjective-CBehavior.html#//apple_ref/doc/uid/TP40014216-CH5-ID86" target="_blank" rel="external"> Writing Swift Classes with Objective-C Behavior </a>中添加<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WritingSwiftClassesWithObjective-CBehavior.html#//apple_ref/doc/uid/TP40014216-CH5-ID107" target="_blank" rel="external"> Using Swift Class Names with Objective-C APIs </a>部分。<br>        </p></li><br>        <li><p><br>        纠正<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WritingSwiftClassesWithObjective-CBehavior.html#//apple_ref/doc/uid/TP40014216-CH5-ID98" target="_blank" rel="external"> Live Rendering </a>只对编译在框架中的 designable 类生效的陈述。这个限制已经不再存在。<br>        </p></li><br>        <li><p><br>        在<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-ID12" target="_blank" rel="external"> Key-Value Observing </a>中添加对 deinit 的实现以及以往代码中对 super 的调用。<br>        </p></li><br>        </ul><br>    </td><br>   </tr><br></tbody><br></table>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/26/swift-cn/SUMMARY/" itemprop="url">
                Summary
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-26T12:00:00+08:00" content="2015-12-26">
            2015-12-26
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn/</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/26/swift-cn/SUMMARY/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/26/swift-cn/SUMMARY/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="Summary">Summary</h1><ul>
<li><a href="/2015/12/25/swift-cn/chapter1/chapter1/">欢迎使用 Swift</a><ul>
<li><a href="/2015/12/25/swift-cn/chapter1/01_swift/">关于 Swift</a></li>
<li><a href="/2015/12/25/swift-cn/chapter1/02_a_swift_tour/">Swift 初见</a></li>
<li><a href="/2015/12/25/swift-cn/chapter1/03_revision_history/">Swift 版本历史记录</a></li>
<li><a href="v1.0/">Swift 1.0 发布内容</a></li>
</ul>
</li>
<li><a href="/2015/12/25/swift-cn/chapter2/chapter2/">Swift 教程</a><ul>
<li><a href="/2015/12/25/swift-cn/chapter2/01_The_Basics/">基础部分</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/02_Basic_Operators/">基本运算符</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/03_Strings_and_Characters/">字符串和字符</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/04_Collection_Types/">集合类型</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/05_Control_Flow/">控制流</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/06_Functions/">函数</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/07_Closures/">闭包</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/08_Enumerations/">枚举</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/09_Classes_and_Structures/">类和结构体</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/10_Properties/">属性</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/11_Methods/">方法</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/12_Subscripts/">下标脚本</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/13_Inheritance/">继承</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/14_Initialization/">构造过程</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/15_Deinitialization/">析构过程</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/16_Automatic_Reference_Counting/">自动引用计数</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/17_Optional_Chaining/">可选链</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/18_Error_Handling/">错误处理</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/19_Type_Casting/">类型转换</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/20_Nested_Types/">嵌套类型</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/21_Extensions/">扩展</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/22_Protocols/">协议</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/23_Generics/">泛型</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/24_Access_Control/">访问控制</a></li>
<li><a href="/2015/12/25/swift-cn/chapter2/25_Advanced_Operators/">高级运算符</a></li>
</ul>
</li>
<li>语言参考<ul>
<li><a href="/2015/12/25/swift-cn/chapter3/01_About_the_Language_Reference/">关于语言参考</a></li>
<li><a href="/2015/12/25/swift-cn/chapter3/02_Lexical_Structure/">词法结构</a></li>
<li><a href="/2015/12/25/swift-cn/chapter3/03_Types/">类型</a></li>
<li><a href="/2015/12/25/swift-cn/chapter3/04_Expressions/">表达式</a></li>
<li><a href="/2015/12/25/swift-cn/chapter3/10_Statements/">语句</a></li>
<li><a href="/2015/12/25/swift-cn/chapter3/05_Declarations/">声明</a></li>
<li><a href="/2015/12/25/swift-cn/chapter3/06_Attributes/">特性</a></li>
<li><a href="/2015/12/25/swift-cn/chapter3/07_Patterns/">模式</a></li>
<li><a href="/2015/12/25/swift-cn/chapter3/08_Generic_Parameters_and_Arguments/">泛型参数</a></li>
<li><a href="/2015/12/25/swift-cn/chapter3/09_Summary_of_the_Grammar/">语法总结</a></li>
</ul>
</li>
<li>苹果官方Blog官方翻译<ul>
<li><a href="/2015/12/25/swift-cn/chapter4/01_Access_Control/">Access Control 权限控制的黑与白</a></li>
<li><a href="/2015/12/25/swift-cn/chapter4/02_Type_Custom/">造个类型不是梦-白话Swift类型创建</a></li>
<li><a href="/2015/12/25/swift-cn/chapter4/03_Ballons/">WWDC里面的那个“大炮打气球”</a></li>
<li><a href="/2015/12/25/swift-cn/chapter4/04_Interacting_with_C_Pointers/">Swift与C语言指针友好合作</a></li>
<li><a href="/2015/12/25/swift-cn/chapter4/05_Value_and_Reference_Types/">引用类型和值类型的恩怨</a></li>
<li><a href="/2015/12/25/swift-cn/chapter4/06_Access_Control_and_Protected/">访问控制和Protected</a></li>
<li><a href="/2015/12/25/swift-cn/chapter4/07_Optional_Case_Study/">可选类型完美解决占位问题</a></li>
</ul>
</li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter1/01_swift/" itemprop="url">
                第一章-01关于 Swift（About Swift）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T23:00:00+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter1/01_swift/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter1/01_swift/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="关于_Swift（About_Swift）">关于 Swift（About Swift）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a><br>校对：<a href="https://github.com/yeahdongcn" target="_blank" rel="external">yeahdongcn</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/xtymichael" target="_blank" rel="external">xtymichael</a></p>
</blockquote>
<p>Swift 是一种新的编程语言，用于编写 iOS，OS X 和 watchOS应用程序。Swift 结合了 C 和 Objective-C 的优点并且不受 C 兼容性的限制。Swift 采用安全的编程模式并添加了很多新特性，这将使编程更简单，更灵活，也更有趣。Swift 是基于成熟而且倍受喜爱的 Cocoa 和 Cocoa Touch 框架，它的降临将重新定义软件开发。</p>
<p>Swift 的开发从很久之前就开始了。为了给 Swift 打好基础，苹果公司改进了编译器，调试器和框架结构。我们使用自动引用计数（Automatic Reference Counting, ARC）来简化内存管理。我们在 Foundation 和 Cocoa 的基础上构建框架栈使其完全现代化和标准化。<br>Objective-C 本身支持块、集合语法和模块，所以框架可以轻松支持现代编程语言技术。正是得益于这些基础工作，我们现在才能发布这样一个用于未来苹果软件开发的新语言。</p>
<p>Objective-C 开发者对 Swift 并不会感到陌生。它采用了 Objective-C 的命名参数以及动态对象模型，可以无缝对接到现有的 Cocoa 框架，并且可以兼容 Objective-C 代码。在此基础之上，Swift 还有许多新特性并且支持过程式编程和面向对象编程。</p>
<p>Swift 对于初学者来说也很友好。它是第一个既满足工业标准又像脚本语言一样充满表现力和趣味的脚本语言。它支持代码预览，这个革命性的特性可以允许程序员在不编译和运行应用程序的前提下运行 Swift 代码并实时查看结果。</p>
<p>Swift 将现代编程语言的精华和苹果工程师文化的智慧结合了起来。编译器对性能进行了优化，编程语言对开发进行了优化，两者互不干扰，鱼与熊掌兼得。Swift 既可以用于开发 “hello, world” 这样的小程序，也可以用于开发一套完整的操作系统。所有的这些特性让 Swift 对于开发者和苹果来说都是一项值得的投资。</p>
<p>Swift 是编写 iOS，OS X 和 watchOS应用的极佳手段，并将伴随着新的特性和功能持续演进。我们对 Swift 充满信心，你还在等什么！</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter1/chapter1/" itemprop="url">
                第一章-欢迎使用 Swift
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T20:00:00+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter1/chapter1/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter1/chapter1/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="欢迎使用_Swift">欢迎使用 Swift</h1><p>在本章中您将了解 Swift 的特性和开发历史，并对 Swift 有一个初步的了解。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/01_The_Basics/" itemprop="url">
                第二章-01基础部分（The Basics）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:26+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/01_The_Basics/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/01_The_Basics/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="基础部分（The_Basics）">基础部分（The Basics）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>, <a href="https://github.com/lyuka" target="_blank" rel="external">lyuka</a>, <a href="https://github.com/JaySurplus" target="_blank" rel="external">JaySurplus</a><br>校对：<a href="https://github.com/lslxdx" target="_blank" rel="external">lslxdx</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/xtymichael" target="_blank" rel="external">xtymichael</a></p>
<p>2.1<br>翻译：<a href="https://github.com/futantan" target="_blank" rel="external">Prayer</a><br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#constants_and_variables">常量和变量</a></li>
<li><a href="#declaring">声明常量和变量</a></li>
<li><a href="#type_annotations">类型标注</a></li>
<li><a href="#naming">常量和变量的命名</a></li>
<li><a href="#printing">输出常量和变量</a></li>
<li><a href="#comments">注释</a></li>
<li><a href="#semicolons">分号</a></li>
<li><a href="#integers">整数</a></li>
<li><a href="#integer_bounds">整数范围</a></li>
<li><a href="#Int">Int</a></li>
<li><a href="#UInt">UInt</a></li>
<li><a href="#floating-point_numbers">浮点数</a></li>
<li><a href="#type_safety_and_type_inference">类型安全和类型推断</a></li>
<li><a href="#numeric_literals">数值型字面量</a></li>
<li><a href="#numeric_type_conversion">数值型类型转换</a></li>
<li><a href="#integer_conversion">整数转换</a></li>
<li><a href="#integer_and_floating_point_conversion">数整数和浮点数转换</a></li>
<li><a href="#type_aliases">类型别名</a></li>
<li><a href="#booleans">布尔值</a></li>
<li><a href="#tuples">元组</a></li>
<li><a href="#optionals">可选</a></li>
<li><a href="#nil">nil</a></li>
<li><a href="#if">if 语句以及强制解析</a></li>
<li><a href="#optional_binding">可选绑定</a></li>
<li><a href="#implicityly_unwrapped_optionals">隐式解析可选类型</a></li>
<li><a href="#error_handling">错误处理</a></li>
<li><a href="#assertions">断言</a></li>
</ul>
<p>Swift 是一门开发 iOS, OS X 和 watchOS 应用的新语言。然而，如果你有 C 或者 Objective-C 开发经验的话，你会发现 Swift 的很多内容都是你熟悉的。</p>
<p>Swift 包含了 C 和 Objective-C 上所有基础数据类型，<code>Int</code>表示整型值；<code>Double</code>和<code>Float</code>表示浮点型值；<code>Bool</code>是布尔型值；<code>String</code>是文本型数据。Swift 还提供了三个基本的集合类型，<code>Array</code>，<code>Set</code>和<code>Dictionary</code>，详见<a href="04_Collection_Types.html">集合类型</a>。</p>
<p>就像 C 语言一样，Swift 使用变量来进行存储并通过变量名来关联值。在 Swift 中，广泛的使用着值不可变的变量，它们就是常量，而且比 C 语言的常量更强大。在 Swift 中，如果你要处理的值不需要改变，那使用常量可以让你的代码更加安全并且更清晰地表达你的意图。</p>
<p>除了我们熟悉的类型，Swift 还增加了 Objective-C 中没有的高阶数据类型比如元组（Tuple）。元组可以让你创建或者传递一组数据，比如作为函数的返回值时，你可以用一个元组可以返回多个值。</p>
<p>Swift 还增加了可选（Optional）类型，用于处理值缺失的情况。可选表示“那儿有一个值，并且它等于 x ”或者“那儿没有值”。可选有点像在 Objective-C 中使用<code>nil</code>，但是它可以用在任何类型上，不仅仅是类。可选类型比 Objective-C 中的<code>nil</code>指针更加安全也更具表现力，它是 Swift 许多强大特性的重要组成部分。</p>
<p>Swift 是一门类型安全的语言，可选类型就是一个很好的例子。Swift 可以让你清楚地知道值的类型。如果你的代码期望得到一个<code>String</code>，类型安全会阻止你不小心传入一个<code>Int</code>。你可以在开发阶段尽早发现并修正错误。</p>
<p><a name="constants_and_variables"></a></p>
<h2 id="常量和变量">常量和变量</h2><p>常量和变量把一个名字（比如<code>maximumNumberOfLoginAttempts</code>或者<code>welcomeMessage</code>）和一个指定类型的值（比如数字<code>10</code>或者字符串<code>&quot;Hello&quot;</code>）关联起来。常量的值一旦设定就不能改变，而变量的值可以随意更改。</p>
<p><a name="declaring"></a></p>
<h3 id="声明常量和变量">声明常量和变量</h3><p>常量和变量必须在使用前声明，用<code>let</code>来声明常量，用<code>var</code>来声明变量。下面的例子展示了如何用常量和变量来记录用户尝试登录的次数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> maximumNumberOfLoginAttempts = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> currentLoginAttempt = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这两行代码可以被理解为：</p>
<p>“声明一个名字是<code>maximumNumberOfLoginAttempts</code>的新常量，并给它一个值<code>10</code>。然后，声明一个名字是<code>currentLoginAttempt</code>的变量并将它的值初始化为<code>0</code>。”</p>
<p>在这个例子中，允许的最大尝试登录次数被声明为一个常量，因为这个值不会改变。当前尝试登录次数被声明为一个变量，因为每次尝试登录失败的时候都需要增加这个值。</p>
<p>你可以在一行中声明多个常量或者多个变量，用逗号隔开：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span>, z = <span class="number">0.0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>如果你的代码中有不需要改变的值，请使用<code>let</code>关键字将它声明为常量。只将需要改变的值声明为变量。</p>
</blockquote>
<p><a name="type_annotations"></a></p>
<h3 id="类型标注">类型标注</h3><p>当你声明常量或者变量的时候可以加上类型标注（type annotation），说明常量或者变量中要存储的值的类型。如果要添加类型标注，需要在常量或者变量名后面加上一个冒号和空格，然后加上类型名称。</p>
<p>这个例子给<code>welcomeMessage</code>变量添加了类型标注，表示这个变量可以存储<code>String</code>类型的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> welcomeMessage: <span class="type">String</span></span><br></pre></td></tr></table></figure>
<p>声明中的冒号代表着“是…类型”，所以这行代码可以被理解为：</p>
<p>“声明一个类型为<code>String</code>，名字为<code>welcomeMessage</code>的变量。”</p>
<p>“类型为<code>String</code>”的意思是“可以存储任意<code>String</code>类型的值。”</p>
<p><code>welcomeMessage</code>变量现在可以被设置成任意字符串：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">welcomeMessage = <span class="string">"Hello"</span></span><br></pre></td></tr></table></figure>
<p>你可以在一行中定义多个同样类型的变量，用逗号分割，并在最后一个变量名之后添加类型标注：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> red, green, blue: <span class="type">Double</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>一般来说你很少需要写类型标注。如果你在声明常量或者变量的时候赋了一个初始值，Swift可以推断出这个常量或者变量的类型，请参考<a href="#type_safety_and_type_inference">类型安全和类型推断</a>。在上面的例子中，没有给<code>welcomeMessage</code>赋初始值，所以变量<code>welcomeMessage</code>的类型是通过一个类型标注指定的，而不是通过初始值推断的。</p>
</blockquote>
<p><a name="naming"></a></p>
<h3 id="常量和变量的命名">常量和变量的命名</h3><p>你可以用任何你喜欢的字符作为常量和变量名，包括 Unicode 字符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> π = <span class="number">3.14159</span></span><br><span class="line"><span class="keyword">let</span> 你好 = <span class="string">"你好世界"</span></span><br><span class="line"><span class="keyword">let</span> 🐶🐮 = <span class="string">"dogcow"</span></span><br></pre></td></tr></table></figure>
<p>常量与变量名不能包含数学符号，箭头，保留的（或者非法的）Unicode 码位，连线与制表符。也不能以数字开头，但是可以在常量与变量名的其他地方包含数字。</p>
<p>一旦你将常量或者变量声明为确定的类型，你就不能使用相同的名字再次进行声明，或者改变其存储的值的类型。同时，你也不能将常量与变量进行互转。</p>
<blockquote>
<p>注意：<br>如果你需要使用与Swift保留关键字相同的名称作为常量或者变量名，你可以使用反引号（`）将关键字包围的方式将其作为名字使用。无论如何，你应当避免使用关键字作为常量或变量名，除非你别无选择。</p>
</blockquote>
<p>你可以更改现有的变量值为其他同类型的值，在下面的例子中，<code>friendlyWelcome</code>的值从<code>&quot;Hello!&quot;</code>改为了<code>&quot;Bonjour!&quot;</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> friendlyWelcome = <span class="string">"Hello!"</span></span><br><span class="line">friendlyWelcome = <span class="string">"Bonjour!"</span></span><br><span class="line"><span class="comment">// friendlyWelcome 现在是 "Bonjour!"</span></span><br></pre></td></tr></table></figure>
<p>与变量不同，常量的值一旦被确定就不能更改了。尝试这样做会导致编译时报错：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> languageName = <span class="string">"Swift"</span></span><br><span class="line">languageName = <span class="string">"Swift++"</span></span><br><span class="line"><span class="comment">// 这会报编译时错误 - languageName 不可改变</span></span><br></pre></td></tr></table></figure>
<p><a name="printing"></a></p>
<h3 id="输出常量和变量">输出常量和变量</h3><p>你可以用<code>print(_:separator:terminator:)</code>函数来输出当前常量或变量的值:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(friendlyWelcome)</span><br><span class="line"><span class="comment">// 输出 "Bonjour!"</span></span><br></pre></td></tr></table></figure>
<p><code>print(_:separator:terminator:)</code>是一个用来输出一个或多个值到适当输出区的全局函数。如果你用 Xcode，<code>print(_:separator:terminator:)</code>将会输出内容到“console”面板上。<code>separator</code>和<code>terminator</code>参数具有默认值，因此你调用这个函数的时候可以忽略它们。默认情况下，该函数通过添加换行符来结束当前行。如果不想换行，可以传递一个空字符串给<code>terminator</code>参数–例如，<code>print(someValue, terminator:&quot;&quot;)</code>。关于参数默认值的更多信息，请参考<a href="./06_Functions.html#default_parameter_values">默认参数值</a>。</p>
<p>Swift 用字符串插值（string interpolation）的方式把常量名或者变量名当做占位符加入到长字符串中，Swift 会用当前常量或变量的值替换这些占位符。将常量或变量名放入圆括号中，并在开括号前使用反斜杠将其转义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"The current value of friendlyWelcome is <span class="subst">\(friendlyWelcome)</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "The current value of friendlyWelcome is Bonjour!</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>字符串插值所有可用的选项，请参考<a href="./03_Strings_and_Characters.html#string_interpolation">字符串插值</a>。</p>
</blockquote>
<p><a name="comments"></a></p>
<h2 id="注释">注释</h2><p>请将你的代码中的非执行文本注释成提示或者笔记以方便你将来阅读。Swift 的编译器将会在编译代码时自动忽略掉注释部分。</p>
<p>Swift 中的注释与 C 语言的注释非常相似。单行注释以双正斜杠（<code>//</code>）作为起始标记:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个注释</span></span><br></pre></td></tr></table></figure>
<p>你也可以进行多行注释，其起始标记为单个正斜杠后跟随一个星号（<code>/*</code>），终止标记为一个星号后跟随单个正斜杠（<code>*/</code>）:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这是一个,</span><br><span class="line">多行注释 */</span></span><br></pre></td></tr></table></figure>
<p>与 C 语言多行注释不同，Swift 的多行注释可以嵌套在其它的多行注释之中。你可以先生成一个多行注释块，然后在这个注释块之中再嵌套成第二个多行注释。终止注释时先插入第二个注释块的终止标记，然后再插入第一个注释块的终止标记：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这是第一个多行注释的开头</span><br><span class="line"><span class="comment">/* 这是第二个被嵌套的多行注释 */</span></span><br><span class="line">这是第一个多行注释的结尾 */</span></span><br></pre></td></tr></table></figure>
<p>通过运用嵌套多行注释，你可以快速方便的注释掉一大段代码，即使这段代码之中已经含有了多行注释块。</p>
<p><a name="semicolons"></a></p>
<h2 id="分号">分号</h2><p>与其他大部分编程语言不同，Swift 并不强制要求你在每条语句的结尾处使用分号（<code>;</code>），当然，你也可以按照你自己的习惯添加分号。有一种情况下必须要用分号，即你打算在同一行内写多条独立的语句：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cat = <span class="string">"🐱"</span>; <span class="built_in">print</span>(cat)</span><br><span class="line"><span class="comment">// 输出 "🐱"</span></span><br></pre></td></tr></table></figure>
<p><a name="integers"></a></p>
<h2 id="整数">整数</h2><p>整数就是没有小数部分的数字，比如<code>42</code>和<code>-23</code>。整数可以是<code>有符号</code>（正、负、零）或者<code>无符号</code>（正、零）。</p>
<p>Swift 提供了8，16，32和64位的有符号和无符号整数类型。这些整数类型和 C 语言的命名方式很像，比如8位无符号整数类型是<code>UInt8</code>，32位有符号整数类型是<code>Int32</code>。就像 Swift 的其他类型一样，整数类型采用大写命名法。</p>
<p><a name="integer_bounds"></a></p>
<h3 id="整数范围">整数范围</h3><p>你可以访问不同整数类型的<code>min</code>和<code>max</code>属性来获取对应类型的最小值和最大值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> minValue = <span class="type">UInt8</span>.<span class="built_in">min</span>  <span class="comment">// minValue 为 0，是 UInt8 类型</span></span><br><span class="line"><span class="keyword">let</span> maxValue = <span class="type">UInt8</span>.<span class="built_in">max</span>  <span class="comment">// maxValue 为 255，是 UInt8 类型</span></span><br></pre></td></tr></table></figure>
<p><code>min</code>和<code>max</code>所传回值的类型，正是其所对的整数类型(如上例UInt8, 所传回的类型是UInt8)，可用在表达式中相同类型值旁。</p>
<p><a name="Int"></a></p>
<h3 id="Int">Int</h3><p>一般来说，你不需要专门指定整数的长度。Swift 提供了一个特殊的整数类型<code>Int</code>，长度与当前平台的原生字长相同：</p>
<ul>
<li>在32位平台上，<code>Int</code>和<code>Int32</code>长度相同。</li>
<li>在64位平台上，<code>Int</code>和<code>Int64</code>长度相同。</li>
</ul>
<p>除非你需要特定长度的整数，一般来说使用<code>Int</code>就够了。这可以提高代码一致性和可复用性。即使是在32位平台上，<code>Int</code>可以存储的整数范围也可以达到<code>-2,147,483,648</code>~<code>2,147,483,647</code>，大多数时候这已经足够大了。</p>
<p><a name="UInt"></a></p>
<h3 id="UInt">UInt</h3><p>Swift 也提供了一个特殊的无符号类型<code>UInt</code>，长度与当前平台的原生字长相同：</p>
<ul>
<li>在32位平台上，<code>UInt</code>和<code>UInt32</code>长度相同。</li>
<li>在64位平台上，<code>UInt</code>和<code>UInt64</code>长度相同。</li>
</ul>
<blockquote>
<p>注意：<br>尽量不要使用<code>UInt</code>，除非你真的需要存储一个和当前平台原生字长相同的无符号整数。除了这种情况，最好使用<code>Int</code>，即使你要存储的值已知是非负的。统一使用<code>Int</code>可以提高代码的可复用性，避免不同类型数字之间的转换，并且匹配数字的类型推断，请参考<a href="#type_safety_and_type_inference">类型安全和类型推断</a>。</p>
</blockquote>
<p><a name="floating-point_numbers"></a></p>
<h2 id="浮点数">浮点数</h2><p>浮点数是有小数部分的数字，比如<code>3.14159</code>，<code>0.1</code>和<code>-273.15</code>。</p>
<p>浮点类型比整数类型表示的范围更大，可以存储比<code>Int</code>类型更大或者更小的数字。Swift 提供了两种有符号浮点数类型：</p>
<ul>
<li><code>Double</code>表示64位浮点数。当你需要存储很大或者很高精度的浮点数时请使用此类型。</li>
<li><code>Float</code>表示32位浮点数。精度要求不高的话可以使用此类型。</li>
</ul>
<blockquote>
<p>注意：<br><code>Double</code>精确度很高，至少有15位数字，而<code>Float</code>最少只有6位数字。选择哪个类型取决于你的代码需要处理的值的范围。</p>
</blockquote>
<p><a name="type_safety_and_type_inference"></a></p>
<h2 id="类型安全和类型推断">类型安全和类型推断</h2><p>Swift 是一个<em>类型安全（type safe）</em>的语言。类型安全的语言可以让你清楚地知道代码要处理的值的类型。如果你的代码需要一个<code>String</code>，你绝对不可能不小心传进去一个<code>Int</code>。</p>
<p>由于 Swift 是类型安全的，所以它会在编译你的代码时进行<em>类型检查（type checks）</em>，并把不匹配的类型标记为错误。这可以让你在开发的时候尽早发现并修复错误。</p>
<p>当你要处理不同类型的值时，类型检查可以帮你避免错误。然而，这并不是说你每次声明常量和变量的时候都需要显式指定类型。如果你没有显式指定类型，Swift 会使用<em>类型推断（type inference）</em>来选择合适的类型。有了类型推断，编译器可以在编译代码的时候自动推断出表达式的类型。原理很简单，只要检查你赋的值即可。</p>
<p>因为有类型推断，和 C 或者 Objective-C 比起来 Swift 很少需要声明类型。常量和变量虽然需要明确类型，但是大部分工作并不需要你自己来完成。</p>
<p>当你声明常量或者变量并赋初值的时候类型推断非常有用。当你在声明常量或者变量的时候赋给它们一个字面量（literal value 或 literal）即可触发类型推断。（字面量就是会直接出现在你代码中的值，比如<code>42</code>和<code>3.14159</code>。）</p>
<p>例如，如果你给一个新常量赋值<code>42</code>并且没有标明类型，Swift 可以推断出常量类型是<code>Int</code>，因为你给它赋的初始值看起来像一个整数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> meaningOfLife = <span class="number">42</span></span><br><span class="line"><span class="comment">// meaningOfLife 会被推测为 Int 类型</span></span><br></pre></td></tr></table></figure>
<p>同理，如果你没有给浮点字面量标明类型，Swift 会推断你想要的是<code>Double</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pi = <span class="number">3.14159</span></span><br><span class="line"><span class="comment">// pi 会被推测为 Double 类型</span></span><br></pre></td></tr></table></figure>
<p>当推断浮点数的类型时，Swift 总是会选择<code>Double</code>而不是<code>Float</code>。</p>
<p>如果表达式中同时出现了整数和浮点数，会被推断为<code>Double</code>类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherPi = <span class="number">3</span> + <span class="number">0.14159</span></span><br><span class="line"><span class="comment">// anotherPi 会被推测为 Double 类型</span></span><br></pre></td></tr></table></figure>
<p>原始值<code>3</code>没有显式声明类型，而表达式中出现了一个浮点字面量，所以表达式会被推断为<code>Double</code>类型。</p>
<p><a name="numeric_literals"></a></p>
<h2 id="数值型字面量">数值型字面量</h2><p>整数字面量可以被写作：</p>
<ul>
<li>一个<em>十进制</em>数，没有前缀</li>
<li>一个<em>二进制</em>数，前缀是<code>0b</code></li>
<li>一个<em>八进制</em>数，前缀是<code>0o</code></li>
<li>一个<em>十六进制</em>数，前缀是<code>0x</code></li>
</ul>
<p>下面的所有整数字面量的十进制值都是<code>17</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decimalInteger = <span class="number">17</span></span><br><span class="line"><span class="keyword">let</span> binaryInteger = <span class="number">0b10001</span>       <span class="comment">// 二进制的17</span></span><br><span class="line"><span class="keyword">let</span> octalInteger = <span class="number">0o21</span>           <span class="comment">// 八进制的17</span></span><br><span class="line"><span class="keyword">let</span> hexadecimalInteger = <span class="number">0x11</span>     <span class="comment">// 十六进制的17</span></span><br></pre></td></tr></table></figure>
<p>浮点字面量可以是十进制（没有前缀）或者是十六进制（前缀是<code>0x</code>）。小数点两边必须有至少一个十进制数字（或者是十六进制的数字）。浮点字面量还有一个可选的指数（exponent，在十进制浮点数中通过大写或者小写的<code>e</code>来指定，在十六进制浮点数中通过大写或者小写的<code>p</code>来指定。</p>
<p>如果一个十进制数的指数为<code>exp</code>，那这个数相当于基数和10^exp的乘积：</p>
<ul>
<li><code>1.25e2</code> 表示 1.25 × 10^2，等于 <code>125.0</code>。</li>
<li><code>1.25e-2</code> 表示 1.25 × 10^-2，等于 <code>0.0125</code>。</li>
</ul>
<p>如果一个十六进制数的指数为<code>exp</code>，那这个数相当于基数和2^exp的乘积：</p>
<ul>
<li><code>0xFp2</code> 表示 15 × 2^2，等于 <code>60.0</code>。</li>
<li><code>0xFp-2</code> 表示 15 × 2^-2，等于 <code>3.75</code>。</li>
</ul>
<p>下面的这些浮点字面量都等于十进制的<code>12.1875</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decimalDouble = <span class="number">12.1875</span></span><br><span class="line"><span class="keyword">let</span> exponentDouble = <span class="number">1.21875e1</span></span><br><span class="line"><span class="keyword">let</span> hexadecimalDouble = <span class="number">0xC.3p0</span></span><br></pre></td></tr></table></figure>
<p>数值类字面量可以包括额外的格式来增强可读性。整数和浮点数都可以添加额外的零并且包含下划线，并不会影响字面量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> paddedDouble = <span class="number">000123.456</span></span><br><span class="line"><span class="keyword">let</span> oneMillion = <span class="number">1_000_000</span></span><br><span class="line"><span class="keyword">let</span> justOverOneMillion = <span class="number">1_000_000.000_000_1</span></span><br></pre></td></tr></table></figure>
<p><a name="numeric_type_conversion"></a></p>
<h2 id="数值型类型转换">数值型类型转换</h2><p>通常来讲，即使代码中的整数常量和变量已知非负，也请使用<code>Int</code>类型。总是使用默认的整数类型可以保证你的整数常量和变量可以直接被复用并且可以匹配整数类字面量的类型推断。</p>
<p>只有在必要的时候才使用其他整数类型，比如要处理外部的长度明确的数据或者为了优化性能、内存占用等等。使用显式指定长度的类型可以及时发现值溢出并且可以暗示正在处理特殊数据。</p>
<p><a name="integer_conversion"></a></p>
<h3 id="整数转换">整数转换</h3><p>不同整数类型的变量和常量可以存储不同范围的数字。<code>Int8</code>类型的常量或者变量可以存储的数字范围是<code>-128</code>~<code>127</code>，而<code>UInt8</code>类型的常量或者变量能存储的数字范围是<code>0</code>~<code>255</code>。如果数字超出了常量或者变量可存储的范围，编译的时候会报错：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cannotBeNegative: <span class="type">UInt8</span> = -<span class="number">1</span></span><br><span class="line"><span class="comment">// UInt8 类型不能存储负数，所以会报错</span></span><br><span class="line"><span class="keyword">let</span> tooBig: <span class="type">Int8</span> = <span class="type">Int8</span>.<span class="built_in">max</span> + <span class="number">1</span></span><br><span class="line"><span class="comment">// Int8 类型不能存储超过最大值的数，所以会报错</span></span><br></pre></td></tr></table></figure>
<p>由于每种整数类型都可以存储不同范围的值，所以你必须根据不同情况选择性使用数值型类型转换。这种选择性使用的方式，可以预防隐式转换的错误并让你的代码中的类型转换意图变得清晰。</p>
<p>要将一种数字类型转换成另一种，你要用当前值来初始化一个期望类型的新数字，这个数字的类型就是你的目标类型。在下面的例子中，常量<code>twoThousand</code>是<code>UInt16</code>类型，然而常量<code>one</code>是<code>UInt8</code>类型。它们不能直接相加，因为它们类型不同。所以要调用<code>UInt16(one)</code>来创建一个新的<code>UInt16</code>数字并用<code>one</code>的值来初始化，然后使用这个新数字来计算：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> twoThousand: <span class="type">UInt16</span> = <span class="number">2_000</span></span><br><span class="line"><span class="keyword">let</span> one: <span class="type">UInt8</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> twoThousandAndOne = twoThousand + <span class="type">UInt16</span>(one)</span><br></pre></td></tr></table></figure>
<p>现在两个数字的类型都是<code>UInt16</code>，可以进行相加。目标常量<code>twoThousandAndOne</code>的类型被推断为<code>UInt16</code>，因为它是两个<code>UInt16</code>值的和。</p>
<p><code>SomeType(ofInitialValue)</code>是调用 Swift 构造器并传入一个初始值的默认方法。在语言内部，<code>UInt16</code>有一个构造器，可以接受一个<code>UInt8</code>类型的值，所以这个构造器可以用现有的<code>UInt8</code>来创建一个新的<code>UInt16</code>。注意，你并不能传入任意类型的值，只能传入<code>UInt16</code>内部有对应构造器的值。不过你可以扩展现有的类型来让它可以接收其他类型的值（包括自定义类型），请参考<a href="./20_Extensions.html">扩展</a>。</p>
<p><a name="integer_and_floating_point_conversion"></a></p>
<h3 id="整数和浮点数转换">整数和浮点数转换</h3><p>整数和浮点数的转换必须显式指定类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> three = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> pointOneFourOneFiveNine = <span class="number">0.14159</span></span><br><span class="line"><span class="keyword">let</span> pi = <span class="type">Double</span>(three) + pointOneFourOneFiveNine</span><br><span class="line"><span class="comment">// pi 等于 3.14159，所以被推测为 Double 类型</span></span><br></pre></td></tr></table></figure>
<p>这个例子中，常量<code>three</code>的值被用来创建一个<code>Double</code>类型的值，所以加号两边的数类型须相同。如果不进行转换，两者无法相加。</p>
<p>浮点数到整数的反向转换同样行，整数类型可以用<code>Double</code>或者<code>Float</code>类型来初始化：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> integerPi = <span class="type">Int</span>(pi)</span><br><span class="line"><span class="comment">// integerPi 等于 3，所以被推测为 Int 类型</span></span><br></pre></td></tr></table></figure>
<p>当用这种方式来初始化一个新的整数值时，浮点值会被截断。也就是说<code>4.75</code>会变成<code>4</code>，<code>-3.9</code>会变成<code>-3</code>。</p>
<blockquote>
<p>注意：<br>结合数字类常量和变量不同于结合数字类字面量。字面量<code>3</code>可以直接和字面量<code>0.14159</code>相加，因为数字字面量本身没有明确的类型。它们的类型只在编译器需要求值的时候被推测。</p>
</blockquote>
<p><a name="type_aliases"></a></p>
<h2 id="类型别名">类型别名</h2><p>类型别名（type aliases）就是给现有类型定义另一个名字。你可以使用<code>typealias</code>关键字来定义类型别名。</p>
<p>当你想要给现有类型起一个更有意义的名字时，类型别名非常有用。假设你正在处理特定长度的外部资源的数据：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">AudioSample</span> = <span class="type">UInt16</span></span><br></pre></td></tr></table></figure>
<p>定义了一个类型别名之后，你可以在任何使用原始名的地方使用别名：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxAmplitudeFound = <span class="type">AudioSample</span>.<span class="built_in">min</span></span><br><span class="line"><span class="comment">// maxAmplitudeFound 现在是 0</span></span><br></pre></td></tr></table></figure>
<p>本例中，<code>AudioSample</code>被定义为<code>UInt16</code>的一个别名。因为它是别名，<code>AudioSample.min</code>实际上是<code>UInt16.min</code>，所以会给<code>maxAmplitudeFound</code>赋一个初值<code>0</code>。</p>
<p><a name="booleans"></a></p>
<h2 id="布尔值">布尔值</h2><p>Swift 有一个基本的布尔（Boolean）类型，叫做<code>Bool</code>。布尔值指逻辑上的值，因为它们只能是真或者假。Swift 有两个布尔常量，<code>true</code>和<code>false</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> orangesAreOrange = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> turnipsAreDelicious = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p><code>orangesAreOrange</code>和<code>turnipsAreDelicious</code>的类型会被推断为<code>Bool</code>，因为它们的初值是布尔字面量。就像之前提到的<code>Int</code>和<code>Double</code>一样，如果你创建变量的时候给它们赋值<code>true</code>或者<code>false</code>，那你不需要将常量或者变量声明为<code>Bool</code>类型。初始化常量或者变量的时候如果所赋的值类型已知，就可以触发类型推断，这让 Swift 代码更加简洁并且可读性更高。</p>
<p>当你编写条件语句比如<code>if</code>语句的时候，布尔值非常有用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> turnipsAreDelicious &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Mmm, tasty turnips!"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Eww, turnips are horrible."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "Eww, turnips are horrible."</span></span><br></pre></td></tr></table></figure>
<p>条件语句，例如<code>if</code>，请参考<a href="./05_Control_Flow.html">控制流</a>。</p>
<p>如果你在需要使用<code>Bool</code>类型的地方使用了非布尔值，Swift 的类型安全机制会报错。下面的例子会报告一个编译时错误：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> i &#123;</span><br><span class="line">    <span class="comment">// 这个例子不会通过编译，会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，下面的例子是合法的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> i == <span class="number">1</span> &#123;</span><br><span class="line">    <span class="comment">// 这个例子会编译成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>i == 1</code>的比较结果是<code>Bool</code>类型，所以第二个例子可以通过类型检查。类似<code>i == 1</code>这样的比较，请参考<a href="./05_Control_Flow.html">基本操作符</a>。</p>
<p>和 Swift 中的其他类型安全的例子一样，这个方法可以避免错误并保证这块代码的意图总是清晰的。</p>
<p><a name="tuples"></a></p>
<h2 id="元组">元组</h2><p><em>元组（tuples）</em>把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。</p>
<p>下面这个例子中，<code>(404, &quot;Not Found&quot;)</code>是一个描述 <em>HTTP 状态码（HTTP status code）</em>的元组。HTTP 状态码是当你请求网页的时候 web 服务器返回的一个特殊值。如果你请求的网页不存在就会返回一个<code>404 Not Found</code>状态码。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> http404Error = (<span class="number">404</span>, <span class="string">"Not Found"</span>)</span><br><span class="line"><span class="comment">// http404Error 的类型是 (Int, String)，值是 (404, "Not Found")</span></span><br></pre></td></tr></table></figure>
<p><code>(404, &quot;Not Found&quot;)</code>元组把一个<code>Int</code>值和一个<code>String</code>值组合起来表示 HTTP 状态码的两个部分：一个数字和一个人类可读的描述。这个元组可以被描述为“一个类型为<code>(Int, String)</code>的元组”。</p>
<p>你可以把任意顺序的类型组合成一个元组，这个元组可以包含所有类型。只要你想，你可以创建一个类型为<code>(Int, Int, Int)</code>或者<code>(String, Bool)</code>或者其他任何你想要的组合的元组。</p>
<p>你可以将一个元组的内容分解（decompose）成单独的常量和变量，然后你就可以正常使用它们了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (statusCode, statusMessage) = http404Error</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The status code is <span class="subst">\(statusCode)</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "The status code is 404"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The status message is <span class="subst">\(statusMessage)</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "The status message is Not Found"</span></span><br></pre></td></tr></table></figure>
<p>如果你只需要一部分元组值，分解的时候可以把要忽略的部分用下划线（<code>_</code>）标记：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (justTheStatusCode, <span class="number">_</span>) = http404Error</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The status code is <span class="subst">\(justTheStatusCode)</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "The status code is 404"</span></span><br></pre></td></tr></table></figure>
<p>此外，你还可以通过下标来访问元组中的单个元素，下标从零开始：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"The status code is <span class="subst">\(http404Error.<span class="number">0</span>)</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "The status code is 404"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The status message is <span class="subst">\(http404Error.<span class="number">1</span>)</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "The status message is Not Found"</span></span><br></pre></td></tr></table></figure>
<p>你可以在定义元组的时候给单个元素命名：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> http200Status = (statusCode: <span class="number">200</span>, description: <span class="string">"OK"</span>)</span><br></pre></td></tr></table></figure>
<p>给元组中的元素命名后，你可以通过名字来获取这些元素的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"The status code is <span class="subst">\(http200Status.statusCode)</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "The status code is 200"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The status message is <span class="subst">\(http200Status.description)</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "The status message is OK"</span></span><br></pre></td></tr></table></figure>
<p>作为函数返回值时，元组非常有用。一个用来获取网页的函数可能会返回一个<code>(Int, String)</code>元组来描述是否获取成功。和只能返回一个类型的值比较起来，一个包含两个不同类型值的元组可以让函数的返回信息更有用。请参考<a href="./06_Functions.html#Function_Parameters_and_Return_Values">函数参数与返回值</a>。</p>
<blockquote>
<p>注意：<br>元组在临时组织值的时候很有用，但是并不适合创建复杂的数据结构。如果你的数据结构并不是临时使用，请使用类或者结构体而不是元组。请参考<a href="./09_Classes_and_Structures.html">类和结构体</a>。</p>
</blockquote>
<p><a name="optionals"></a></p>
<h2 id="可选类型">可选类型</h2><p>使用<em>可选类型（optionals）</em>来处理值可能缺失的情况。可选类型表示：</p>
<ul>
<li>有值，等于 x</li>
</ul>
<p>或者</p>
<ul>
<li>没有值</li>
</ul>
<blockquote>
<p>注意：<br>C 和 Objective-C 中并没有可选类型这个概念。最接近的是 Objective-C 中的一个特性，一个方法要不返回一个对象要不返回<code>nil</code>，<code>nil</code>表示“缺少一个合法的对象”。然而，这只对对象起作用——对于结构体，基本的 C 类型或者枚举类型不起作用。对于这些类型，Objective-C 方法一般会返回一个特殊值（比如<code>NSNotFound</code>）来暗示值缺失。这种方法假设方法的调用者知道并记得对特殊值进行判断。然而，Swift 的可选类型可以让你暗示<em>任意类型</em>的值缺失，并不需要一个特殊值。</p>
</blockquote>
<p>来看一个例子。Swift 的<code>String</code>类型有一种构造器，作用是将一个<code>String</code>值转换成一个<code>Int</code>值。然而，并不是所有的字符串都可以转换成一个整数。字符串<code>&quot;123&quot;</code>可以被转换成数字<code>123</code>，但是字符串<code>&quot;hello, world&quot;</code>不行。</p>
<p>下面的例子使用这种构造器来尝试将一个<code>String</code>转换成<code>Int</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> possibleNumber = <span class="string">"123"</span></span><br><span class="line"><span class="keyword">let</span> convertedNumber = <span class="type">Int</span>(possibleNumber)</span><br><span class="line"><span class="comment">// convertedNumber 被推测为类型 "Int?"， 或者类型 "optional Int"</span></span><br></pre></td></tr></table></figure>
<p>因为该构造器可能会失败，所以它返回一个<em>可选类型</em>（optional）<code>Int</code>，而不是一个<code>Int</code>。一个可选的<code>Int</code>被写作<code>Int?</code>而不是<code>Int</code>。问号暗示包含的值是可选类型，也就是说可能包含<code>Int</code>值也可能<em>不包含值</em>。（不能包含其他任何值比如<code>Bool</code>值或者<code>String</code>值。只能是<code>Int</code>或者什么都没有。）</p>
<p><a name="nil"></a></p>
<h3 id="nil">nil</h3><p>你可以给可选变量赋值为<code>nil</code>来表示它没有值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serverResponseCode: <span class="type">Int</span>? = <span class="number">404</span></span><br><span class="line"><span class="comment">// serverResponseCode 包含一个可选的 Int 值 404</span></span><br><span class="line">serverResponseCode = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// serverResponseCode 现在不包含值</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br><code>nil</code>不能用于非可选的常量和变量。如果你的代码中有常量或者变量需要处理值缺失的情况，请把它们声明成对应的可选类型。</p>
</blockquote>
<p>如果你声明一个可选常量或者变量但是没有赋值，它们会自动被设置为<code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> surveyAnswer: <span class="type">String</span>?</span><br><span class="line"><span class="comment">// surveyAnswer 被自动设置为 nil</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>Swift 的<code>nil</code>和 Objective-C 中的<code>nil</code>并不一样。在 Objective-C 中，<code>nil</code>是一个指向不存在对象的指针。在 Swift 中，<code>nil</code>不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设置为<code>nil</code>，不只是对象类型。</p>
</blockquote>
<p><a name="if"></a></p>
<h3 id="if_语句以及强制解析">if 语句以及强制解析</h3><p>你可以使用<code>if</code>语句和<code>nil</code>比较来判断一个可选值是否包含值。你可以使用“相等”(<code>==</code>)或“不等”(<code>!=</code>)来执行比较。</p>
<p>如果可选类型有值，它将不等于<code>nil</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> convertedNumber != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"convertedNumber contains some integer value."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "convertedNumber contains some integer value."</span></span><br></pre></td></tr></table></figure>
<p>当你确定可选类型确实包含值之后，你可以在可选的名字后面加一个感叹号（<code>!</code>）来获取值。这个惊叹号表示“我知道这个可选有值，请使用它。”这被称为可选值的<em>强制解析（forced unwrapping）</em>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> convertedNumber != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"convertedNumber has an integer value of <span class="subst">\(convertedNumber!)</span>."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "convertedNumber has an integer value of 123."</span></span><br></pre></td></tr></table></figure>
<p>更多关于<code>if</code>语句的内容，请参考<a href="05_Control_Flow.html">控制流</a>。</p>
<blockquote>
<p>注意：<br>使用<code>!</code>来获取一个不存在的可选值会导致运行时错误。使用<code>!</code>来强制解析值之前，一定要确定可选包含一个非<code>nil</code>的值。</p>
</blockquote>
<p><a name="optional_binding"></a></p>
<h3 id="可选绑定">可选绑定</h3><p>使用<em>可选绑定（optional binding）</em>来判断可选类型是否包含值，如果包含就把值赋给一个临时常量或者变量。可选绑定可以用在<code>if</code>和<code>while</code>语句中，这条语句不仅可以用来判断可选类型中是否有值，同时可以将可选类型中的值赋给一个常量或者变量。<code>if</code>和<code>while</code>语句，请参考<a href="./05_Control_Flow.html">控制流</a>。</p>
<p>像下面这样在<code>if</code>语句中写一个可选绑定：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> constantName = someOptional &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以像上面这样使用可选绑定来重写<code>possibleNumber</code>这个<a href="./01_The_Basics.html#optionals">例子</a>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> actualNumber = <span class="type">Int</span>(possibleNumber) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\'<span class="subst">\(possibleNumber)</span>\' has an integer value of <span class="subst">\(actualNumber)</span>"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\'<span class="subst">\(possibleNumber)</span>\' could not be converted to an integer"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "'123' has an integer value of 123"</span></span><br></pre></td></tr></table></figure>
<p>这段代码可以被理解为：</p>
<p>“如果<code>Int(possibleNumber)</code>返回的可选<code>Int</code>包含一个值，创建一个叫做<code>actualNumber</code>的新常量并将可选包含的值赋给它。”</p>
<p>如果转换成功，<code>actualNumber</code>常量可以在<code>if</code>语句的第一个分支中使用。它已经被可选类型<em>包含的</em>值初始化过，所以不需要再使用<code>!</code>后缀来获取它的值。在这个例子中，<code>actualNumber</code>只被用来输出转换结果。</p>
<p>你可以在可选绑定中使用常量和变量。如果你想在<code>if</code>语句的第一个分支中操作<code>actualNumber</code>的值，你可以改成<code>if var actualNumber</code>，这样可选类型包含的值就会被赋给一个变量而非常量。</p>
<p>你可以包含多个可选绑定在<code>if</code>语句中，并使用<code>where</code>子句做布尔值判断。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstNumber = <span class="type">Int</span>(<span class="string">"4"</span>), secondNumber = <span class="type">Int</span>(<span class="string">"42"</span>) <span class="keyword">where</span> firstNumber &lt; secondNumber &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(firstNumber)</span> &lt; <span class="subst">\(secondNumber)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// prints "4 &lt; 42"</span></span><br></pre></td></tr></table></figure>
<p><a name="implicityly_unwrapped_optionals"></a></p>
<h3 id="隐式解析可选类型">隐式解析可选类型</h3><p>如上所述，可选类型暗示了常量或者变量可以“没有值”。可选可以通过<code>if</code>语句来判断是否有值，如果有值的话可以通过可选绑定来解析值。</p>
<p>有时候在程序架构中，第一次被赋值之后，可以确定一个可选类型<em>总会</em>有值。在这种情况下，每次都要判断和解析可选值是非常低效的，因为可以确定它总会有值。</p>
<p>这种类型的可选状态被定义为隐式解析可选类型（implicitly unwrapped optionals）。把想要用作可选的类型的后面的问号（<code>String?</code>）改成感叹号（<code>String!</code>）来声明一个隐式解析可选类型。</p>
<p>当可选类型被第一次赋值之后就可以确定之后一直有值的时候，隐式解析可选类型非常有用。隐式解析可选类型主要被用在 Swift 中类的构造过程中，请参考<a href="./16_Automatic_Reference_Counting.html#unowned_references_and_implicitly_unwrapped_optional_properties">无主引用以及隐式解析可选属性</a>。</p>
<p>一个隐式解析可选类型其实就是一个普通的可选类型，但是可以被当做非可选类型来使用，并不需要每次都使用解析来获取可选值。下面的例子展示了可选类型<code>String</code>和隐式解析可选类型<code>String</code>之间的区别：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> possibleString: <span class="type">String</span>? = <span class="string">"An optional string."</span></span><br><span class="line"><span class="keyword">let</span> forcedString: <span class="type">String</span> = possibleString! <span class="comment">// 需要惊叹号来获取值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> assumedString: <span class="type">String</span>! = <span class="string">"An implicitly unwrapped optional string."</span></span><br><span class="line"><span class="keyword">let</span> implicitString: <span class="type">String</span> = assumedString  <span class="comment">// 不需要感叹号</span></span><br></pre></td></tr></table></figure>
<p>你可以把隐式解析可选类型当做一个可以自动解析的可选类型。你要做的只是声明的时候把感叹号放到类型的结尾，而不是每次取值的可选名字的结尾。</p>
<blockquote>
<p>注意：<br>如果你在隐式解析可选类型没有值的时候尝试取值，会触发运行时错误。和你在没有值的普通可选类型后面加一个惊叹号一样。</p>
</blockquote>
<p>你仍然可以把隐式解析可选类型当做普通可选类型来判断它是否包含值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> assumedString != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(assumedString)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "An implicitly unwrapped optional string."</span></span><br></pre></td></tr></table></figure>
<p>你也可以在可选绑定中使用隐式解析可选类型来检查并解析它的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> definiteString = assumedString &#123;</span><br><span class="line">    <span class="built_in">print</span>(definiteString)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "An implicitly unwrapped optional string."</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>如果一个变量之后可能变成<code>nil</code>的话请不要使用隐式解析可选类型。如果你需要在变量的生命周期中判断是否是<code>nil</code>的话，请使用普通可选类型。</p>
</blockquote>
<p><a name="error_handling"></a></p>
<h2 id="错误处理">错误处理</h2><p>你可以使用<em>错误处理（error handling）</em>来应对程序执行中可能会遇到的错误条件。</p>
<p>相对于可选中运用值的存在与缺失来表达函数的成功与失败，错误处理可以推断失败的原因，并传播至程序的其他部分。</p>
<p>当一个函数遇到错误条件，它能报错。调用函数的地方能抛出错误消息并合理处理。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">canThrowAnError</span><span class="params">()</span></span> throws &#123;</span><br><span class="line">    <span class="comment">// 这个函数有可能抛出错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个函数可以通过在声明中添加<code>throws</code>关键词来抛出错误消息。当你的函数能抛出错误消息时, 你应该在表达式中前置<code>try</code>关键词。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    try canThrowAnError()</span><br><span class="line">    <span class="comment">// 没有错误消息抛出</span></span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    <span class="comment">// 有一个错误消息抛出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个<code>do</code>语句创建了一个新的包含作用域,使得错误能被传播到一个或多个<code>catch</code>从句。</p>
<p>这里有一个错误处理如何用来应对不同错误条件的例子。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">makeASandwich</span><span class="params">()</span></span> throws &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    try makeASandwich()</span><br><span class="line">    eatASandwich()</span><br><span class="line">&#125; catch <span class="type">Error</span>.<span class="type">OutOfCleanDishes</span> &#123;</span><br><span class="line">    washDishes()</span><br><span class="line">&#125; catch <span class="type">Error</span>.<span class="type">MissingIngredients</span>(<span class="keyword">let</span> ingredients) &#123;</span><br><span class="line">    buyGroceries(ingredients)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此例中，<code>makeASandwich()</code>（做一个三明治）函数会抛出一个错误消息如果没有干净的盘子或者某个原料缺失。因为<code>makeASandwich()</code>抛出错误，函数调用被包裹在<code>try</code>表达式中。将函数包裹在一个<code>do</code>语句中,任何被抛出的错误会被传播到提供的<code>catch</code>从句中。</p>
<p>如果没有错误被抛出, <code>eatASandwich()</code>函数会被调用。如果一个匹配<code>Error.OutOfCleanDishes</code>的错误被抛出,<code>washDishes</code>函数会被调用。如果一个匹配<code>Error.MissingIngredients</code>的错误被抛出，<code>buyGroceries(_:)</code>函数会随着被<code>catch</code>所捕捉到的关联值<code>[String]</code>被调用。</p>
<p>抛出，捕捉，以及传播错误会在<a href="./18_Error_Handling.html">错误处理</a>章节详细说明。</p>
<p><a name="assertions"></a></p>
<h2 id="断言">断言</h2><p>可选类型可以让你判断值是否存在，你可以在代码中优雅地处理值缺失的情况。然而，在某些情况下，如果值缺失或者值并不满足特定的条件，你的代码可能没办法继续执行。这时，你可以在你的代码中触发一个<em>断言（assertion）</em>来结束代码运行并通过调试来找到值缺失的原因。</p>
<h3 id="使用断言进行调试">使用断言进行调试</h3><p>断言会在运行时判断一个逻辑条件是否为<code>true</code>。从字面意思来说，断言“断言”一个条件是否为真。你可以使用断言来保证在运行其他代码之前，某些重要的条件已经被满足。如果条件判断为<code>true</code>，代码运行会继续进行；如果条件判断为<code>false</code>，代码执行结束，你的应用被终止。</p>
<p>如果你的代码在调试环境下触发了一个断言，比如你在 Xcode 中构建并运行一个应用，你可以清楚地看到不合法的状态发生在哪里并检查断言被触发时你的应用的状态。此外，断言允许你附加一条调试信息。</p>
<p>你可以使用全局<code>assert(_:_file:line:)</code>函数来写一个断言。向这个函数传入一个结果为<code>true</code>或者<code>false</code>的表达式以及一条信息，当表达式的结果为<code>false</code>的时候这条信息会被显示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = -<span class="number">3</span></span><br><span class="line"><span class="built_in">assert</span>(age &gt;= <span class="number">0</span>, <span class="string">"A person's age cannot be less than zero"</span>)</span><br><span class="line"><span class="comment">// 因为 age &lt; 0，所以断言会触发</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，只有<code>age &gt;= 0</code>为<code>true</code>的时候，即<code>age</code>的值非负的时候，代码才会继续执行。如果<code>age</code>的值是负数，就像代码中那样，<code>age &gt;= 0</code>为<code>false</code>，断言被触发，终止应用。</p>
<p>如果不需要断言信息，可以省略，就像这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span>(age &gt;= <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>当代码使用优化编译的时候，断言将会被禁用，例如在 Xcode 中，使用默认的 target Release 配置选项来 build 时，断言会被禁用。</p>
</blockquote>
<h3 id="何时使用断言">何时使用断言</h3><p>当条件可能为假时使用断言，但是最终一定要<em>保证</em>条件为真，这样你的代码才能继续运行。断言的适用情景：</p>
<ul>
<li>整数类型的下标索引被传入一个自定义下标脚本实现，但是下标索引值可能太小或者太大。</li>
<li>需要给函数传入一个值，但是非法的值可能导致函数不能正常执行。</li>
<li>一个可选值现在是<code>nil</code>，但是后面的代码运行需要一个非<code>nil</code>值。</li>
</ul>
<p>请参考<a href="./12_Subscripts.html">下标脚本</a>和<a href="./06_Functions.html">函数</a>。</p>
<blockquote>
<p>注意：<br>断言可能导致你的应用终止运行，所以你应当仔细设计你的代码来让非法条件不会出现。然而，在你的应用发布之前，有时候非法条件可能出现，这时使用断言可以快速发现问题。</p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/02_Basic_Operators/" itemprop="url">
                第二章-02基本运算符（Basic Operators）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:25+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/02_Basic_Operators/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/02_Basic_Operators/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="基本运算符（Basic_Operators）">基本运算符（Basic Operators）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/xielingwang" target="_blank" rel="external">XieLingWang</a><br>校对：<a href="https://github.com/Evilcome" target="_blank" rel="external">EvilCome</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/AlanMelody" target="_blank" rel="external">JackAlan</a></p>
<p>2.1<br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#terminology">术语</a></li>
<li><a href="#assignment_operator">赋值运算符</a></li>
<li><a href="#arithmetic_operators">算术运算符</a></li>
<li><a href="#compound_assignment_operators">组合赋值运算符（Compound Assignment Operators）</a></li>
<li><a href="#comparison_operators">比较运算符</a></li>
<li><a href="#ternary_conditional_operator">三目运算符（Ternary Conditional Operator）</a></li>
<li><a href="#nil_coalescing_operator">空合运算符</a></li>
<li><a href="#range_operators">区间运算符</a></li>
<li><a href="#logical_operators">逻辑运算符</a></li>
</ul>
<p>运算符是检查、改变、合并值的特殊符号或短语。例如，加号<code>+</code>将两个数相加（如<code>let i = 1 + 2</code>）。更复杂的运算例子包括逻辑与运算符<code>&amp;&amp;</code>（如<code>if enteredDoorCode &amp;&amp; passedRetinaScan</code>），或让 i 值加1的便捷自增运算符<code>++i</code>等。</p>
<p>Swift 支持大部分标准 C 语言的运算符，且改进许多特性来减少常规编码错误。如：赋值符（<code>=</code>）不返回值，以防止把想要判断相等运算符（<code>==</code>）的地方写成赋值符导致的错误。算术运算符（<code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>%</code>等）会检测并不允许值溢出，以此来避免保存变量时由于变量大于或小于其类型所能承载的范围时导致的异常结果。当然允许你使用 Swift 的溢出运算符来实现溢出。详情参见<a href="../chapter2/25_Advanced_Operators.html#overflow_operators">溢出运算符</a>。</p>
<p>区别于 C 语言，在 Swift 中你可以对浮点数进行取余运算（<code>%</code>），Swift 还提供了 C 语言没有的表达两数之间的值的区间运算符（<code>a..&lt;b</code>和<code>a...b</code>），这方便我们表达一个区间内的数值。</p>
<p>本章节只描述了 Swift 中的基本运算符，<a href="../chapter2/25_Advanced_Operators.html">高级运算符</a>包含了高级运算符，及如何自定义运算符，及如何进行自定义类型的运算符重载。</p>
<p><a name="terminology"></a></p>
<h2 id="术语">术语</h2><p>运算符有一元、二元和三元运算符。</p>
<ul>
<li>一元运算符对单一操作对象操作（如<code>-a</code>）。一元运算符分前置运算符和后置运算符，前置运算符需紧跟在操作对象之前（如<code>!b</code>），后置运算符需紧跟在操作对象之后（如<code>i++</code>）。</li>
<li>二元运算符操作两个操作对象（如<code>2 + 3</code>），是中置的，因为它们出现在两个操作对象之间。</li>
<li>三元运算符操作三个操作对象，和 C 语言一样，Swift 只有一个三元运算符，就是三目运算符（<code>a ? b : c</code>）。</li>
</ul>
<p>受运算符影响的值叫操作数，在表达式<code>1 + 2</code>中，加号<code>+</code>是二元运算符，它的两个操作数是值<code>1</code>和<code>2</code>。</p>
<p><a name="assignment_operator"></a></p>
<h2 id="赋值运算符">赋值运算符</h2><p>赋值运算（<code>a = b</code>），表示用<code>b</code>的值来初始化或更新<code>a</code>的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">5</span></span><br><span class="line">a = b</span><br><span class="line"><span class="comment">// a 现在等于 10</span></span><br></pre></td></tr></table></figure>
<p>如果赋值的右边是一个多元组，它的元素可以马上被分解成多个常量或变量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (x, y) = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 现在 x 等于 1, y 等于 2</span></span><br></pre></td></tr></table></figure>
<p>与 C 语言和 Objective-C 不同，Swift 的赋值操作并不返回任何值。所以以下代码是错误的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x = y &#123;</span><br><span class="line">	<span class="comment">// 此句错误, 因为 x = y 并不返回任何值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个特性使你无法把（<code>==</code>）错写成（<code>=</code>），由于<code>if x = y</code>是错误代码，Swift帮你避免此类错误的的发生。</p>
<p><a name="arithmetic_operators"></a></p>
<h2 id="算术运算符">算术运算符</h2><p>Swift 中所有数值类型都支持了基本的四则算术运算：</p>
<ul>
<li>加法（<code>+</code>）</li>
<li>减法（<code>-</code>）</li>
<li>乘法（<code>*</code>）</li>
<li>除法（<code>/</code>）</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">2</span>       <span class="comment">// 等于 3</span></span><br><span class="line"><span class="number">5</span> - <span class="number">3</span>       <span class="comment">// 等于 2</span></span><br><span class="line"><span class="number">2</span> * <span class="number">3</span>       <span class="comment">// 等于 6</span></span><br><span class="line"><span class="number">10.0</span> / <span class="number">2.5</span>  <span class="comment">// 等于 4.0</span></span><br></pre></td></tr></table></figure>
<p>与 C 语言和 Objective-C 不同的是，Swift 默认情况下不允许在数值运算中出现溢出情况。但是你可以使用 Swift 的溢出运算符来实现溢出运算（如<code>a &amp;+ b</code>）。详情参见<a href="../chapter2/25_Advanced_Operators.html#overflow_operators">溢出运算符</a>。</p>
<p>加法运算符也可用于<code>String</code>的拼接：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"hello, "</span> + <span class="string">"world"</span>  <span class="comment">// 等于 "hello, world"</span></span><br></pre></td></tr></table></figure>
<h3 id="求余运算符">求余运算符</h3><p>求余运算（<code>a % b</code>）是计算<code>b</code>的多少倍刚刚好可以容入<code>a</code>，返回多出来的那部分（余数）。</p>
<blockquote>
<p>注意：<br>求余运算（<code>%</code>）在其他语言也叫取模运算。然而严格说来，我们看该运算符对负数的操作结果，”求余”比”取模”更合适些。</p>
</blockquote>
<p>我们来谈谈取余是怎么回事，计算<code>9 % 4</code>，你先计算出<code>4</code>的多少倍会刚好可以容入<code>9</code>中：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/remainderInteger_2x.png" alt="Art/remainderInteger_2x.png" title="Art/remainderInteger_2x.png"></p>
<p>2倍，非常好，那余数是1（用橙色标出）</p>
<p>在 Swift 中可以表达为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span> % <span class="number">4</span>    <span class="comment">// 等于 1</span></span><br></pre></td></tr></table></figure>
<p>为了得到<code>a % b</code>的结果，<code>%</code>计算了以下等式，并输出<code>余数</code>作为结果：</p>
<pre><code><span class="tag">a</span> = (<span class="tag">b</span> × 倍数) + 余数
</code></pre><p>当<code>倍数</code>取最大值的时候，就会刚好可以容入<code>a</code>中。</p>
<p>把<code>9</code>和<code>4</code>代入等式中，我们得<code>1</code>：</p>
<pre><code><span class="number">9</span> = (<span class="number">4</span> × <span class="number">2</span>) + <span class="number">1</span>
</code></pre><p>同样的方法，我们来计算 <code>-9 % 4</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">9</span> % <span class="number">4</span>   <span class="comment">// 等于 -1</span></span><br></pre></td></tr></table></figure>
<p>把<code>-9</code>和<code>4</code>代入等式，<code>-2</code>是取到的最大整数：</p>
<pre><code>-<span class="number">9</span> = (<span class="number">4</span> × -<span class="number">2</span>) + -<span class="number">1</span>
</code></pre><p>余数是<code>-1</code>。</p>
<p>在对负数<code>b</code>求余时，<code>b</code>的符号会被忽略。这意味着 <code>a % b</code> 和 <code>a % -b</code>的结果是相同的。</p>
<h3 id="浮点数求余计算">浮点数求余计算</h3><p>不同于 C 语言和 Objective-C，Swift 中是可以对浮点数进行求余的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span> % <span class="number">2.5</span>   <span class="comment">// 等于 0.5</span></span><br></pre></td></tr></table></figure>
<p>这个例子中，<code>8</code>除于<code>2.5</code>等于<code>3</code>余<code>0.5</code>，所以结果是一个<code>Double</code>值<code>0.5</code>。</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/remainderFloat_2x.png" alt="Art/remainderFloat_2x.png" title="Art/remainderFloat_2x.png"></p>
<h3 id="自增和自减运算">自增和自减运算</h3><p>和 C 语言一样，Swift 也提供了对变量本身加1或减1的自增（<code>++</code>）和自减（<code>--</code>）的缩略算符。其操作对象可以是整形和浮点型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">++i      <span class="comment">// 现在 i = 1</span></span><br></pre></td></tr></table></figure>
<p>每调用一次<code>++i</code>，<code>i</code>的值就会加1。实际上，<code>++i</code>是<code>i = i + 1</code>的简写，而<code>--i</code>是<code>i = i - 1</code>的简写。</p>
<p><code>++</code>和<code>--</code>既可以用作前置运算又可以用作后置运算。<code>++i</code>，<code>i++</code>，<code>--i</code>和<code>i--</code>都是有效的写法。</p>
<p>我们需要注意的是这些运算符即可修改了<code>i</code>的值也可以返回<code>i</code>的值。如果你只想修改<code>i</code>的值，那你就可以忽略这个返回值。但如果你想使用返回值，你就需要留意前置和后置操作的返回值是不同的，她们遵循以下原则：</p>
<ul>
<li>当<code>++</code>前置的时候，先自増再返回。</li>
<li>当<code>++</code>后置的时候，先返回再自增。</li>
</ul>
<p>例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> b = ++a <span class="comment">// a 和 b 现在都是 1</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = a++ <span class="comment">// a 现在 2, 但 c 是 a 自增前的值 1</span></span><br></pre></td></tr></table></figure>
<p>上述例子，<code>let b = ++a</code>先把<code>a</code>加1了再返回<code>a</code>的值。所以<code>a</code>和<code>b</code>都是新值<code>1</code>。</p>
<p>而<code>let c = a++</code>，是先返回了<code>a</code>的值，然后<code>a</code>才加1。所以<code>c</code>得到了<code>a</code>的旧值1，而<code>a</code>加1后变成2。</p>
<p>除非你需要使用<code>i++</code>的特性，不然推荐你使用<code>++i</code>和<code>--i</code>，因为先修改后返回这样的行为更符合我们的逻辑。</p>
<h3 id="一元负号运算符">一元负号运算符</h3><p>数值的正负号可以使用前缀<code>-</code>（即一元负号）来切换：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> three = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> minusThree = -three       <span class="comment">// minusThree 等于 -3</span></span><br><span class="line"><span class="keyword">let</span> plusThree = -minusThree   <span class="comment">// plusThree 等于 3, 或 "负负3"</span></span><br></pre></td></tr></table></figure>
<p>一元负号（<code>-</code>）写在操作数之前，中间没有空格。</p>
<h3 id="一元正号运算符">一元正号运算符</h3><p>一元正号（<code>+</code>）不做任何改变地返回操作数的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> minusSix = -<span class="number">6</span></span><br><span class="line"><span class="keyword">let</span> alsoMinusSix = +minusSix  <span class="comment">// alsoMinusSix 等于 -6</span></span><br></pre></td></tr></table></figure>
<p>虽然一元<code>+</code>什么都不会改变，但当你在使用一元负号来表达负数时，你可以使用一元正号来表达正数，如此你的代码会具有对称美。</p>
<p><a name="compound_assignment_operators"></a></p>
<h2 id="组合赋值运算符（Compound_Assignment_Operators）">组合赋值运算符（Compound Assignment Operators）</h2><p>如同 C 语言，Swift 也提供把其他运算符和赋值运算（<code>=</code>）组合的组合赋值运算符，组合加运算（<code>+=</code>）是其中一个例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">a += <span class="number">2</span> <span class="comment">// a 现在是 3</span></span><br></pre></td></tr></table></figure>
<p>表达式<code>a += 2</code>是<code>a = a + 2</code>的简写，一个组合加运算就是把加法运算和赋值运算组合成进一个运算符里，同时完成两个运算任务。</p>
<blockquote>
<p>注意：<br>复合赋值运算没有返回值，<code>let b = a += 2</code>这类代码是错误。这不同于上面提到的自增和自减运算符。</p>
</blockquote>
<p>在<a href="../chapter3/04_Expressions.html">表达式</a>章节里有复合运算符的完整列表。<br>‌<br><a name="comparison_operators"></a></p>
<h2 id="比较运算符">比较运算符</h2><p>所有标准 C 语言中的比较运算都可以在 Swift 中使用：</p>
<ul>
<li>等于（<code>a == b</code>）</li>
<li>不等于（<code>a != b</code>）</li>
<li>大于（<code>a &gt; b</code>）</li>
<li>小于（<code>a &lt; b</code>）</li>
<li>大于等于（<code>a &gt;= b</code>）</li>
<li>小于等于（<code>a &lt;= b</code>）</li>
</ul>
<blockquote>
<p>注意：<br>Swift 也提供恒等<code>===</code>和不恒等<code>!==</code>这两个比较符来判断两个对象是否引用同一个对象实例。更多细节在<a href="../chapter2/09_Classes_and_Structures.html">类与结构</a>。</p>
</blockquote>
<p>每个比较运算都返回了一个标识表达式是否成立的布尔值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> == <span class="number">1</span>   <span class="comment">// true, 因为 1 等于 1</span></span><br><span class="line"><span class="number">2</span> != <span class="number">1</span>   <span class="comment">// true, 因为 2 不等于 1</span></span><br><span class="line"><span class="number">2</span> &gt; <span class="number">1</span>    <span class="comment">// true, 因为 2 大于 1</span></span><br><span class="line"><span class="number">1</span> &lt; <span class="number">2</span>    <span class="comment">// true, 因为 1 小于2</span></span><br><span class="line"><span class="number">1</span> &gt;= <span class="number">1</span>   <span class="comment">// true, 因为 1 大于等于 1</span></span><br><span class="line"><span class="number">2</span> &lt;= <span class="number">1</span>   <span class="comment">// false, 因为 2 并不小于等于 1</span></span><br></pre></td></tr></table></figure>
<p>比较运算多用于条件语句，如<code>if</code>条件：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">"world"</span></span><br><span class="line"><span class="keyword">if</span> name == <span class="string">"world"</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"hello, world"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"I'm sorry <span class="subst">\(name)</span>, but I don't recognize you"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "hello, world", 因为 `name` 就是等于 "world"</span></span><br></pre></td></tr></table></figure>
<p>关于<code>if</code>语句，请看<a href="../chapter2/05_Control_Flow.html">控制流</a>。</p>
<p><a name="ternary_conditional_operator"></a></p>
<h2 id="三目运算符(Ternary_Conditional_Operator)">三目运算符(Ternary Conditional Operator)</h2><p>三目运算符的特殊在于它是有三个操作数的运算符，它的原型是 <code>问题 ? 答案1 : 答案2</code>。它简洁地表达根据<code>问题</code>成立与否作出二选一的操作。如果<code>问题</code>成立，返回<code>答案1</code>的结果; 如果不成立，返回<code>答案2</code>的结果。</p>
<p>三目运算符是以下代码的缩写形式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> question &#123;</span><br><span class="line">	answer1</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	answer2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有个计算表格行高的例子。如果有表头，那行高应比内容高度要高出50点；如果没有表头，只需高出20点：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> contentHeight = <span class="number">40</span></span><br><span class="line"><span class="keyword">let</span> hasHeader = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> rowHeight = contentHeight + (hasHeader ? <span class="number">50</span> : <span class="number">20</span>)</span><br><span class="line"><span class="comment">// rowHeight 现在是 90</span></span><br></pre></td></tr></table></figure>
<p>上面的写法比下面的代码更简洁：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> contentHeight = <span class="number">40</span></span><br><span class="line"><span class="keyword">let</span> hasHeader = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> rowHeight = contentHeight</span><br><span class="line"><span class="keyword">if</span> hasHeader &#123;</span><br><span class="line">	rowHeight = rowHeight + <span class="number">50</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	rowHeight = rowHeight + <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// rowHeight 现在是 90</span></span><br></pre></td></tr></table></figure>
<p>第一段代码例子使用了三目运算，所以一行代码就能让我们得到正确答案。这比第二段代码简洁得多，无需将<code>rowHeight</code>定义成变量，因为它的值无需在<code>if</code>语句中改变。</p>
<p>三目运算提供有效率且便捷的方式来表达二选一的选择。需要注意的事，过度使用三目运算符会使简洁的代码变的难懂。我们应避免在一个组合语句中使用多个三目运算符。</p>
<p><a name="nil_coalescing_operator"></a></p>
<h2 id="空合运算符(Nil_Coalescing_Operator)">空合运算符(Nil Coalescing Operator)</h2><p>空合运算符(<code>a ?? b</code>)将对可选类型<code>a</code>进行空判断，如果<code>a</code>包含一个值就进行解封，否则就返回一个默认值<code>b</code>.这个运算符有两个条件:</p>
<ul>
<li>表达式<code>a</code>必须是Optional类型</li>
<li>默认值<code>b</code>的类型必须要和<code>a</code>存储值的类型保持一致</li>
</ul>
<p>空合运算符是对以下代码的简短表达方法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a != <span class="literal">nil</span> ? a! : b</span><br></pre></td></tr></table></figure>
<p>上述代码使用了三目运算符。当可选类型<code>a</code>的值不为空时，进行强制解封(<code>a!</code>)访问<code>a</code>中值，反之当<code>a</code>中值为空时，返回默认值b。无疑空合运算符(<code>??</code>)提供了一种更为优雅的方式去封装条件判断和解封两种行为，显得简洁以及更具可读性。</p>
<blockquote>
<p>注意：<br>如果<code>a</code>为非空值(<code>non-nil</code>),那么值<code>b</code>将不会被估值。这也就是所谓的短路求值。</p>
</blockquote>
<p>下文例子采用空合运算符，实现了在默认颜色名和可选自定义颜色名之间抉择：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> defaultColorName = <span class="string">"red"</span></span><br><span class="line"><span class="keyword">var</span> userDefinedColorName: <span class="type">String</span>?   <span class="comment">//默认值为 nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colorNameToUse = userDefinedColorName ?? defaultColorName</span><br><span class="line"><span class="comment">// userDefinedColorName 的值为空，所以 colorNameToUse 的值为 "red"</span></span><br></pre></td></tr></table></figure>
<p><code>userDefinedColorName</code>变量被定义为一个可选<code>String</code>类型，默认值为<code>nil</code>。由于<code>userDefinedColorName</code>是一个可选类型，我们可以使用空合运算符去判断其值。在上一个例子中，通过空合运算符为一个名为<code>colorNameToUse</code>的变量赋予一个字符串类型初始值。<br>由于<code>userDefinedColorName</code>值为空，因此表达式<code>userDefinedColorName ?? defaultColorName</code>返回<code>defaultColorName</code>的值，即<code>red</code>。</p>
<p>另一种情况，分配一个非空值(<code>non-nil</code>)给<code>userDefinedColorName</code>，再次执行空合运算，运算结果为封包在<code>userDefaultColorName</code>中的值，而非默认值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userDefinedColorName = <span class="string">"green"</span></span><br><span class="line">colorNameToUse = userDefinedColorName ?? defaultColorName</span><br><span class="line"><span class="comment">// userDefinedColorName 非空，因此 colorNameToUse 的值为 "green"</span></span><br></pre></td></tr></table></figure>
<p><a name="range_operators"></a></p>
<h2 id="区间运算符">区间运算符</h2><p>Swift 提供了两个方便表达一个区间的值的运算符。</p>
<h3 id="闭区间运算符">闭区间运算符</h3><p>闭区间运算符（<code>a...b</code>）定义一个包含从<code>a</code>到<code>b</code>(包括<code>a</code>和<code>b</code>)的所有值的区间，<code>b</code>必须大于等于<code>a</code>。<br>‌<br>闭区间运算符在迭代一个区间的所有值时是非常有用的，如在<code>for-in</code>循环中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span>...<span class="number">5</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"<span class="subst">\(index)</span> * 5 = <span class="subst">\(index * <span class="number">5</span>)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 * 5 = 5</span></span><br><span class="line"><span class="comment">// 2 * 5 = 10</span></span><br><span class="line"><span class="comment">// 3 * 5 = 15</span></span><br><span class="line"><span class="comment">// 4 * 5 = 20</span></span><br><span class="line"><span class="comment">// 5 * 5 = 25</span></span><br></pre></td></tr></table></figure>
<p>关于<code>for-in</code>，请看<a href="../chapter2/05_Control_Flow.html">控制流</a>。</p>
<h3 id="半开区间运算符">半开区间运算符</h3><p>半开区间（<code>a..&lt;b</code>）定义一个从<code>a</code>到<code>b</code>但不包括<code>b</code>的区间。<br>之所以称为半开区间，是因为该区间包含第一个值而不包括最后的值。</p>
<p>半开区间的实用性在于当你使用一个从0开始的列表(如数组)时，非常方便地从0数到列表的长度。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [<span class="string">"Anna"</span>, <span class="string">"Alex"</span>, <span class="string">"Brian"</span>, <span class="string">"Jack"</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="built_in">count</span> = names.<span class="built_in">count</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="built_in">count</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"第 <span class="subst">\(i + <span class="number">1</span>)</span> 个人叫 <span class="subst">\(names[i])</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第 1 个人叫 Anna</span></span><br><span class="line"><span class="comment">// 第 2 个人叫 Alex</span></span><br><span class="line"><span class="comment">// 第 3 个人叫 Brian</span></span><br><span class="line"><span class="comment">// 第 4 个人叫 Jack</span></span><br></pre></td></tr></table></figure>
<p>数组有4个元素，但<code>0..&lt;count</code>只数到3(最后一个元素的下标)，因为它是半开区间。关于数组，请查阅<a href="../chapter2/04_Collection_Types.html#arrays">数组</a>。</p>
<p><a name="logical_operators"></a></p>
<h2 id="逻辑运算">逻辑运算</h2><p>逻辑运算的操作对象是逻辑布尔值。Swift 支持基于 C 语言的三个标准逻辑运算。</p>
<ul>
<li>逻辑非（<code>!a</code>）</li>
<li>逻辑与（<code>a &amp;&amp; b</code>）</li>
<li>逻辑或（<code>a || b</code>）</li>
</ul>
<h3 id="逻辑非">逻辑非</h3><p>逻辑非运算（<code>!a</code>）对一个布尔值取反，使得<code>true</code>变<code>false</code>，<code>false</code>变<code>true</code>。</p>
<p>它是一个前置运算符，需紧跟在操作数之前，且不加空格。读作<code>非 a</code>，例子如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> allowedEntry = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> !allowedEntry &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"ACCESS DENIED"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "ACCESS DENIED"</span></span><br></pre></td></tr></table></figure>
<p><code>if !allowedEntry</code>语句可以读作“如果非 allowedEntry。”，接下一行代码只有在“非 allowedEntry”为<code>true</code>，即<code>allowEntry</code>为<code>false</code>时被执行。</p>
<p>在示例代码中，小心地选择布尔常量或变量有助于代码的可读性，并且避免使用双重逻辑非运算，或混乱的逻辑语句。</p>
<h3 id="逻辑与">逻辑与</h3><p>逻辑与（<code>a &amp;&amp; b</code>）表达了只有<code>a</code>和<code>b</code>的值都为<code>true</code>时，整个表达式的值才会是<code>true</code>。</p>
<p>只要任意一个值为<code>false</code>，整个表达式的值就为<code>false</code>。事实上，如果第一个值为<code>false</code>，那么是不去计算第二个值的，因为它已经不可能影响整个表达式的结果了。这被称做“短路计算（short-circuit evaluation）”。</p>
<p>以下例子，只有两个<code>Bool</code>值都为<code>true</code>的时候才允许进入：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> enteredDoorCode = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> passedRetinaScan = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> enteredDoorCode &amp;&amp; passedRetinaScan &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Welcome!"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"ACCESS DENIED"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "ACCESS DENIED"</span></span><br></pre></td></tr></table></figure>
<h3 id="逻辑或">逻辑或</h3><p>逻辑或（<code>a || b</code>）是一个由两个连续的<code>|</code>组成的中置运算符。它表示了两个逻辑表达式的其中一个为<code>true</code>，整个表达式就为<code>true</code>。</p>
<p>同逻辑与运算类似，逻辑或也是“短路计算”的，当左端的表达式为<code>true</code>时，将不计算右边的表达式了，因为它不可能改变整个表达式的值了。</p>
<p>以下示例代码中，第一个布尔值（<code>hasDoorKey</code>）为<code>false</code>，但第二个值（<code>knowsOverridePassword</code>）为<code>true</code>，所以整个表达是<code>true</code>，于是允许进入：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hasDoorKey = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> knowsOverridePassword = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> hasDoorKey || knowsOverridePassword &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Welcome!"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"ACCESS DENIED"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "Welcome!"</span></span><br></pre></td></tr></table></figure>
<h3 id="逻辑运算符组合计算">逻辑运算符组合计算</h3><p>我们可以组合多个逻辑运算来表达一个复合逻辑：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> enteredDoorCode &amp;&amp; passedRetinaScan || hasDoorKey || knowsOverridePassword &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Welcome!"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"ACCESS DENIED"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "Welcome!"</span></span><br></pre></td></tr></table></figure>
<p>这个例子使用了含多个<code>&amp;&amp;</code>和<code>||</code>的复合逻辑。但无论怎样，<code>&amp;&amp;</code>和<code>||</code>始终只能操作两个值。所以这实际是三个简单逻辑连续操作的结果。我们来解读一下：</p>
<p>如果我们输入了正确的密码并通过了视网膜扫描，或者我们有一把有效的钥匙，又或者我们知道紧急情况下重置的密码，我们就能把门打开进入。</p>
<p>前两种情况，我们都不满足，所以前两个简单逻辑的结果是<code>false</code>，但是我们是知道紧急情况下重置的密码的，所以整个复杂表达式的值还是<code>true</code>。</p>
<blockquote>
<p>注意：<br>Swift 逻辑操作符<code>&amp;&amp;</code>和<code>||</code>是左结合的，这意味着拥有多元逻辑操作符的复合表达式优先计算最左边的子表达式。</p>
</blockquote>
<h3 id="使用括号来明确优先级">使用括号来明确优先级</h3><p>为了一个复杂表达式更容易读懂，在合适的地方使用括号来明确优先级是很有效的，虽然它并非必要的。在上个关于门的权限的例子中，我们给第一个部分加个括号，使它看起来逻辑更明确：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (enteredDoorCode &amp;&amp; passedRetinaScan) || hasDoorKey || knowsOverridePassword &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Welcome!"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"ACCESS DENIED"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "Welcome!"</span></span><br></pre></td></tr></table></figure>
<p>这括号使得前两个值被看成整个逻辑表达中独立的一个部分。虽然有括号和没括号的输出结果是一样的，但对于读代码的人来说有括号的代码更清晰。可读性比简洁性更重要，请在可以让你代码变清晰的地方加个括号吧！</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/03_Strings_and_Characters/" itemprop="url">
                第二章-03字符串和字符（Strings and Characters）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:24+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/03_Strings_and_Characters/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/03_Strings_and_Characters/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="字符串和字符（Strings_and_Characters）">字符串和字符（Strings and Characters）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/wh1100717" target="_blank" rel="external">wh1100717</a><br>校对：<a href="https://github.com/Hawstein" target="_blank" rel="external">Hawstein</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/DianQK" target="_blank" rel="external">DianQK</a></p>
<p>2.1<br>翻译：<a href="https://github.com/DianQK" target="_blank" rel="external">DianQK</a><br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#string_literals">字符串字面量</a></li>
<li><a href="#initializing_an_empty_string">初始化空字符串</a></li>
<li><a href="#string_mutability">字符串可变性</a></li>
<li><a href="#strings_are_value_types">字符串是值类型</a></li>
<li><a href="#working_with_characters">使用字符</a></li>
<li><a href="#concatenating_strings_and_characters">连接字符串和字符</a></li>
<li><a href="#string_interpolation">字符串插值</a></li>
<li><a href="#unicode">Unicode</a></li>
<li><a href="#counting_characters">计算字符数量</a></li>
<li><a href="#accessing_and_modifying_a_string">访问和修改字符串</a></li>
<li><a href="#comparing_strings">比较字符串</a></li>
<li><a href="#unicode_representations_of_strings">字符串的 Unicode 表示形式</a></li>
</ul>
<p><code>String</code>是例如”hello, world”，”albatross”这样的有序的<code>Character</code>（字符）类型的值的集合。通过<code>String</code>类型来表示。<br>一个<code>String</code>的内容可以用变量的方式读取，它包括一个<code>Character</code>值的集合。<br>创建和操作字符串的语法与 C 语言中字符串操作相似，轻量并且易读。<br>字符串连接操作只需要简单地通过<code>+</code>符号将两个字符串相连即可。与 Swift 中其他值一样，能否更改字符串的值，取决于其被定义为常量还是变量。你也可以在字符串内插过程中使用字符串插入常量、变量、字面量表达成更长的字符串，这样可以很容易的创建自定义的字符串值，进行展示、存储以及打印。<br>尽管语法简易，但<code>String</code>类型是一种快速、现代化的字符串实现。<br>每一个字符串都是由编码无关的 Unicode 字符组成，并支持访问字符的多种 Unicode 表示形式（representations）。</p>
<blockquote>
<p>注意：<br>Swift 的<code>String</code>类型与 Foundation <code>NSString</code>类进行了无缝桥接。就像 <a href="./19_Type_Casting.html#anyobject"><code>AnyObject</code>类型</a> 中提到的一样，在使用 Cocoa 中的 Foundation 框架时，您可以将创建的任何字符串的值转换成<code>NSString</code>，并调用任意的<code>NSString</code> API。您也可以在任意要求传入<code>NSString</code>实例作为参数的 API 中用<code>String</code>类型的值代替。<br>更多关于在 Foundation 和 Cocoa 中使用<code>String</code>的信息请查看 <em><a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216" target="_blank" rel="external">Using Swift with Cocoa and Objective-C (Swift 2.1)</a></em>。</p>
</blockquote>
<p><a name="string_literals"></a></p>
<h2 id="字符串字面量（String_Literals）">字符串字面量（String Literals）</h2><p>您可以在您的代码中包含一段预定义的字符串值作为字符串字面量。字符串字面量是由双引号 (<code>&quot;&quot;</code>) 包裹着的具有固定顺序的文本字符集。<br>字符串字面量可以用于为常量和变量提供初始值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someString = <span class="string">"Some string literal value"</span></span><br></pre></td></tr></table></figure>
<p>注意<code>someString</code>常量通过字符串字面量进行初始化，Swift 会推断该常量为<code>String</code>类型。</p>
<blockquote>
<p>注意：<br>更多关于在字符串字面量中使用特殊字符的信息，请查看 <a href="#special_characters_in_string_literals">字符串字面量的特殊字符</a> 。</p>
</blockquote>
<p><a name="initializing_an_empty_string"></a></p>
<h2 id="初始化空字符串_(Initializing_an_Empty_String)">初始化空字符串 (Initializing an Empty String)</h2><p>要创建一个空字符串作为初始值，可以将空的字符串字面量赋值给变量，也可以初始化一个新的<code>String</code>实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emptyString = <span class="string">""</span>               <span class="comment">// 空字符串字面量</span></span><br><span class="line"><span class="keyword">var</span> anotherEmptyString = <span class="type">String</span>()  <span class="comment">// 初始化方法</span></span><br><span class="line"><span class="comment">// 两个字符串均为空并等价。</span></span><br></pre></td></tr></table></figure>
<p>您可以通过检查其<code>Boolean</code>类型的<code>isEmpty</code>属性来判断该字符串是否为空：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> emptyString.isEmpty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Nothing to see here"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印输出："Nothing to see here"</span></span><br></pre></td></tr></table></figure>
<p><a name="string_mutability"></a></p>
<h2 id="字符串可变性_(String_Mutability)">字符串可变性 (String Mutability)</h2><p>您可以通过将一个特定字符串分配给一个变量来对其进行修改，或者分配给一个常量来保证其不会被修改：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> variableString = <span class="string">"Horse"</span></span><br><span class="line">variableString += <span class="string">" and carriage"</span></span><br><span class="line"><span class="comment">// variableString 现在为 "Horse and carriage"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> constantString = <span class="string">"Highlander"</span></span><br><span class="line">constantString += <span class="string">" and another Highlander"</span></span><br><span class="line"><span class="comment">// 这会报告一个编译错误 (compile-time error) - 常量字符串不可以被修改。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>在 Objective-C 和 Cocoa 中，您需要通过选择两个不同的类(<code>NSString</code>和<code>NSMutableString</code>)来指定字符串是否可以被修改。</p>
</blockquote>
<p><a name="strings_are_value_types"></a></p>
<h2 id="字符串是值类型（Strings_Are_Value_Types）">字符串是值类型（Strings Are Value Types）</h2><p>Swift 的<code>String</code>类型是值类型。<br>如果您创建了一个新的字符串，那么当其进行常量、变量赋值操作，或在函数/方法中传递时，会进行值拷贝。<br>任何情况下，都会对已有字符串值创建新副本，并对该新副本进行传递或赋值操作。<br>值类型在 <a href="./09_Classes_and_Structures.html#structures_and_enumerations_are_value_types">结构体和枚举是值类型</a> 中进行了详细描述。</p>
<p>Swift 默认字符串拷贝的方式保证了在函数/方法中传递的是字符串的值。<br>很明显无论该值来自于哪里，都是您独自拥有的。<br>您可以确信传递的字符串不会被修改，除非你自己去修改它。</p>
<p>在实际编译时，Swift 编译器会优化字符串的使用，使实际的复制只发生在绝对必要的情况下，这意味着您将字符串作为值类型的同时可以获得极高的性能。</p>
<p><a name="working_with_characters"></a></p>
<h2 id="使用字符（Working_with_Characters）">使用字符（Working with Characters）</h2><p>您可通过<code>for-in</code>循环来遍历字符串中的<code>characters</code>属性来获取每一个字符的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> character <span class="keyword">in</span> <span class="string">"Dog!🐶"</span>.characters &#123;</span><br><span class="line">    <span class="built_in">print</span>(character)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// D</span></span><br><span class="line"><span class="comment">// o</span></span><br><span class="line"><span class="comment">// g</span></span><br><span class="line"><span class="comment">// !</span></span><br><span class="line"><span class="comment">// 🐶</span></span><br></pre></td></tr></table></figure>
<p><code>for-in</code>循环在 <a href="./05_Control_Flow.html#for_loops">For 循环</a> 中进行了详细描述。</p>
<p>另外，通过标明一个<code>Character</code>类型并用字符字面量进行赋值，可以建立一个独立的字符常量或变量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> exclamationMark: <span class="type">Character</span> = <span class="string">"!"</span></span><br></pre></td></tr></table></figure>
<p>字符串可以通过传递一个值类型为<code>Character</code>的数组作为自变量来初始化：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> catCharacters: [<span class="type">Character</span>] = [<span class="string">"C"</span>, <span class="string">"a"</span>, <span class="string">"t"</span>, <span class="string">"!"</span>, <span class="string">"🐱"</span>]</span><br><span class="line"><span class="keyword">let</span> catString = <span class="type">String</span>(catCharacters)</span><br><span class="line"><span class="built_in">print</span>(catString)</span><br><span class="line"><span class="comment">// 打印输出："Cat!🐱"</span></span><br></pre></td></tr></table></figure>
<p><a name="concatenating_strings_and_characters"></a></p>
<h2 id="连接字符串和字符_(Concatenating_Strings_and_Characters)">连接字符串和字符 (Concatenating Strings and Characters)</h2><p>字符串可以通过加法运算符（<code>+</code>）相加在一起（或称“连接”）创建一个新的字符串：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> string1 = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">let</span> string2 = <span class="string">" there"</span></span><br><span class="line"><span class="keyword">var</span> welcome = string1 + string2</span><br><span class="line"><span class="comment">// welcome 现在等于 "hello there"</span></span><br></pre></td></tr></table></figure>
<p>您也可以通过加法赋值运算符 (<code>+=</code>) 将一个字符串添加到一个已经存在字符串变量上：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instruction = <span class="string">"look over"</span></span><br><span class="line">instruction += string2</span><br><span class="line"><span class="comment">// instruction 现在等于 "look over there"</span></span><br></pre></td></tr></table></figure>
<p>您可以用<code>append()</code>方法将一个字符附加到一个字符串变量的尾部：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> exclamationMark: <span class="type">Character</span> = <span class="string">"!"</span></span><br><span class="line">welcome.append(exclamationMark)</span><br><span class="line"><span class="comment">// welcome 现在等于 "hello there!"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>您不能将一个字符串或者字符添加到一个已经存在的字符变量上，因为字符变量只能包含一个字符。</p>
</blockquote>
<p><a name="string_interpolation"></a></p>
<h2 id="字符串插值_(String_Interpolation)">字符串插值 (String Interpolation)</h2><p>字符串插值是一种构建新字符串的方式，可以在其中包含常量、变量、字面量和表达式。<br>您插入的字符串字面量的每一项都在以反斜线为前缀的圆括号中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> multiplier = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> message = <span class="string">"<span class="subst">\(multiplier)</span> times 2.5 is <span class="subst">\(Double(multiplier)</span> * 2.5)"</span></span><br><span class="line"><span class="comment">// message is "3 times 2.5 is 7.5"</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>multiplier</code>作为<code>\(multiplier)</code>被插入到一个字符串常量量中。<br>当创建字符串执行插值计算时此占位符会被替换为<code>multiplier</code>实际的值。</p>
<p><code>multiplier</code>的值也作为字符串中后面表达式的一部分。<br>该表达式计算<code>Double(multiplier) * 2.5</code>的值并将结果 (<code>7.5</code>) 插入到字符串中。<br>在这个例子中，表达式写为<code>\(Double(multiplier) * 2.5)</code>并包含在字符串字面量中。</p>
<blockquote>
<p>注意：<br>插值字符串中写在括号中的表达式不能包含非转义反斜杠 (<code>\</code>)，并且不能包含回车或换行符。不过，插值字符串可以包含其他字面量。</p>
</blockquote>
<p><a name="unicode"></a></p>
<h2 id="Unicode">Unicode</h2><p>Unicode 是一个国际标准，用于文本的编码和表示。<br>它使您可以用标准格式表示来自任意语言几乎所有的字符，并能够对文本文件或网页这样的外部资源中的字符进行读写操作。<br>Swift 的<code>String</code>和<code>Character</code>类型是完全兼容 Unicode 标准的。</p>
<p><a name="unicode_scalars"></a></p>
<h3 id="Unicode_标量（Unicode_Scalars）">Unicode 标量（Unicode Scalars）</h3><p>Swift 的<code>String</code>类型是基于 <em>Unicode 标量</em> 建立的。<br>Unicode 标量是对应字符或者修饰符的唯一的21位数字，例如<code>U+0061</code>表示小写的拉丁字母(<code>LATIN SMALL LETTER A</code>)(“<code>a</code>“)，<code>U+1F425</code>表示小鸡表情(<code>FRONT-FACING BABY CHICK</code>) (“<code>🐥</code>“)。</p>
<blockquote>
<p>注意：<br>Unicode <em>码位(code poing)</em> 的范围是<code>U+0000</code>到<code>U+D7FF</code>或者<code>U+E000</code>到<code>U+10FFFF</code>。Unicode 标量不包括 Unicode <em>代理项(surrogate pair)</em> 码位，其码位范围是<code>U+D800</code>到<code>U+DFFF</code>。</p>
</blockquote>
<p>注意不是所有的21位 Unicode 标量都代表一个字符，因为有一些标量是留作未来分配的。已经代表一个典型字符的标量都有自己的名字，例如上面例子中的<code>LATIN SMALL LETTER A</code>和<code>FRONT-FACING BABY CHICK</code>。</p>
<p><a name="special_characters_in_string_literals"></a></p>
<h3 id="字符串字面量的特殊字符_(Special_Characters_in_String_Literals)">字符串字面量的特殊字符 (Special Characters in String Literals)</h3><p>字符串字面量可以包含以下特殊字符：</p>
<ul>
<li>转义字符<code>\0</code>(空字符)、<code>\\</code>(反斜线)、<code>\t</code>(水平制表符)、<code>\n</code>(换行符)、<code>\r</code>(回车符)、<code>\&quot;</code>(双引号)、<code>\&#39;</code>(单引号)。</li>
<li>Unicode 标量，写成<code>\u{n}</code>(u为小写)，其中<code>n</code>为任意一到八位十六进制数且可用的 Unicode 位码。</li>
</ul>
<p>下面的代码为各种特殊字符的使用示例。<br><code>wiseWords</code>常量包含了两个双引号。<br><code>dollarSign</code>、<code>blackHeart</code>和<code>sparklingHeart</code>常量演示了三种不同格式的 Unicode 标量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wiseWords = <span class="string">"\"Imagination is more important than knowledge\" - Einstein"</span></span><br><span class="line"><span class="comment">// "Imageination is more important than knowledge" - Enistein</span></span><br><span class="line"><span class="keyword">let</span> dollarSign = <span class="string">"\u&#123;24&#125;"</span>             <span class="comment">// $, Unicode 标量 U+0024</span></span><br><span class="line"><span class="keyword">let</span> blackHeart = <span class="string">"\u&#123;2665&#125;"</span>           <span class="comment">// ♥, Unicode 标量 U+2665</span></span><br><span class="line"><span class="keyword">let</span> sparklingHeart = <span class="string">"\u&#123;1F496&#125;"</span>      <span class="comment">// 💖, Unicode 标量 U+1F496</span></span><br></pre></td></tr></table></figure>
<p><a name="extended_grapheme_clusters"></a></p>
<h3 id="可扩展的字形群集(Extended_Grapheme_Clusters)">可扩展的字形群集(Extended Grapheme Clusters)</h3><p>每一个 Swift 的<code>Character</code>类型代表一个可扩展的字形群。<br>一个可扩展的字形群是一个或多个可生成人类可读的字符 Unicode 标量的有序排列。<br>举个例子，字母<code>é</code>可以用单一的 Unicode 标量<code>é</code>(<code>LATIN SMALL LETTER E WITH ACUTE</code>, 或者<code>U+00E9</code>)来表示。然而一个标准的字母<code>e</code>(<code>LATIN SMALL LETTER E</code>或者<code>U+0065</code>) 加上一个急促重音(<code>COMBINING ACTUE ACCENT</code>)的标量(<code>U+0301</code>)，这样一对标量就表示了同样的字母<code>é</code>。<br>这个急促重音的标量形象的将<code>e</code>转换成了<code>é</code>。</p>
<p>在这两种情况中，字母<code>é</code>代表了一个单一的 Swift 的<code>Character</code>值，同时代表了一个可扩展的字形群。<br>在第一种情况，这个字形群包含一个单一标量；而在第二种情况，它是包含两个标量的字形群：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> eAcute: <span class="type">Character</span> = <span class="string">"\u&#123;E9&#125;"</span>                         <span class="comment">// é</span></span><br><span class="line"><span class="keyword">let</span> combinedEAcute: <span class="type">Character</span> = <span class="string">"\u&#123;65&#125;\u&#123;301&#125;"</span>          <span class="comment">// e 后面加上  ́</span></span><br><span class="line"><span class="comment">// eAcute 是 é, combinedEAcute 是 é</span></span><br></pre></td></tr></table></figure>
<p>可扩展的字符群集是一个灵活的方法，用许多复杂的脚本字符表示单一的<code>Character</code>值。<br>例如，来自朝鲜语字母表的韩语音节能表示为组合或分解的有序排列。<br>在 Swift 都会表示为同一个单一的<code>Character</code>值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> precomposed: <span class="type">Character</span> = <span class="string">"\u&#123;D55C&#125;"</span>                  <span class="comment">// 한</span></span><br><span class="line"><span class="keyword">let</span> decomposed: <span class="type">Character</span> = <span class="string">"\u&#123;1112&#125;\u&#123;1161&#125;\u&#123;11AB&#125;"</span>   <span class="comment">// ᄒ, ᅡ, ᆫ</span></span><br><span class="line"><span class="comment">// precomposed 是 한, decomposed 是 한</span></span><br></pre></td></tr></table></figure>
<p>可拓展的字符群集可以使包围记号(例如<code>COMBINING ENCLOSING CIRCLE</code>或者<code>U+20DD</code>)的标量包围其他 Unicode 标量，作为一个单一的<code>Character</code>值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> enclosedEAcute: <span class="type">Character</span> = <span class="string">"\u&#123;E9&#125;\u&#123;20DD&#125;"</span></span><br><span class="line"><span class="comment">// enclosedEAcute 是 é⃝</span></span><br></pre></td></tr></table></figure>
<p>局部的指示符号的 Unicode 标量可以组合成一个单一的<code>Character</code>值，例如<code>REGIONAL INDICATOR SYMBOL LETTER U</code>(<code>U+1F1FA</code>)和<code>REGIONAL INDICATOR SYMBOL LETTER S</code>(<code>U+1F1F8</code>)：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regionalIndicatorForUS: <span class="type">Character</span> = <span class="string">"\u&#123;1F1FA&#125;\u&#123;1F1F8&#125;"</span></span><br><span class="line"><span class="comment">// regionalIndicatorForUS 是 🇺🇸</span></span><br></pre></td></tr></table></figure>
<p><a name="counting_characters"></a></p>
<h2 id="计算字符数量_(Counting_Characters)">计算字符数量 (Counting Characters)</h2><p>如果想要获得一个字符串中<code>Character</code>值的数量，可以使用字符串的<code>characters</code>属性的<code>count</code>属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unusualMenagerie = <span class="string">"Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"unusualMenagerie has <span class="subst">\(unusualMenagerie.characters.<span class="built_in">count</span>)</span> characters"</span>)</span><br><span class="line"><span class="comment">// 打印输出 "unusualMenagerie has 40 characters"</span></span><br></pre></td></tr></table></figure>
<p>注意在 Swift 中，使用可拓展的字符群集作为<code>Character</code>值来连接或改变字符串时，并不一定会更改字符串的字符数量。</p>
<p>例如，如果你用四个字符的单词<code>cafe</code>初始化一个新的字符串，然后添加一个<code>COMBINING ACTUE ACCENT</code>(<code>U+0301</code>)作为字符串的结尾。最终这个字符串的字符数量仍然是<code>4</code>，因为第四个字符是<code>é</code>，而不是<code>e</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> word = <span class="string">"cafe"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"the number of characters in <span class="subst">\(word)</span> is <span class="subst">\(word.characters.<span class="built_in">count</span>)</span>"</span>)</span><br><span class="line"><span class="comment">// 打印输出 "the number of characters in cafe is 4"</span></span><br><span class="line"></span><br><span class="line">word += <span class="string">"\u&#123;301&#125;"</span>    <span class="comment">// COMBINING ACUTE ACCENT, U+0301</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"the number of characters in <span class="subst">\(word)</span> is <span class="subst">\(word.characters.<span class="built_in">count</span>)</span>"</span>)</span><br><span class="line"><span class="comment">// 打印输出 "the number of characters in café is 4"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>可扩展的字符群集可以组成一个或者多个 Unicode 标量。这意味着不同的字符以及相同字符的不同表示方式可能需要不同数量的内存空间来存储。所以 Swift 中的字符在一个字符串中并不一定占用相同的内存空间数量。因此在没有获取字符串的可扩展的字符群的范围时候，就不能计算出字符串的字符数量。如果您正在处理一个长字符串，需要注意<code>characters</code>属性必须遍历全部的 Unicode 标量，来确定字符串的字符数量。</p>
<p>另外需要注意的是通过<code>characters</code>属性返回的字符数量并不总是与包含相同字符的<code>NSString</code>的<code>length</code>属性相同。<code>NSString</code>的<code>length</code>属性是利用 UTF-16 表示的十六位代码单元数字，而不是 Unicode 可扩展的字符群集。作为佐证，当一个<code>NSString</code>的<code>length</code>属性被一个Swift的<code>String</code>值访问时，实际上是调用了<code>utf16Count</code>。</p>
</blockquote>
<p><a name="accessing_and_modifying_a_string"></a></p>
<h2 id="访问和修改字符串_(Accessing_and_Modifying_a_String)">访问和修改字符串 (Accessing and Modifying a String)</h2><p>你可以通字符串的属性和方法来访问和读取它，当然也可以用下标语法完成。</p>
<p><a name="string_indices"></a></p>
<h3 id="字符串索引_(String_Indices)">字符串索引 (String Indices)</h3><p>每一个<code>String</code>值都有一个关联的索引(<em>index</em>)类型，<code>String.Index</code>，它对应着字符串中的每一个<code>Character</code>的位置。</p>
<p>前面提到，不同的字符可能会占用不同数量的内存空间，所以要知道<code>Character</code>的确定位置，就必须从<code>String</code>开头遍历每一个 Unicode 标量直到结尾。因此，Swift 的字符串不能用整数(integer)做索引。</p>
<p>使用<code>startIndex</code>属性可以获取一个<code>String</code>的第一个<code>Character</code>的索引。使用<code>endIndex</code>属性可以获取最后一个<code>Character</code>的后一个位置的索引。因此，<code>endIndex</code>属性不能作为一个字符串的有效下标。如果<code>String</code>是空串，<code>startIndex</code>和<code>endIndex</code>是相等的。</p>
<p>通过调用<code>String.Index</code>的<code>predecessor()</code>方法，可以立即得到前面一个索引，调用<code>successor()</code>方法可以立即得到后面一个索引。任何一个<code>String</code>的索引都可以通过锁链作用的这些方法来获取另一个索引，也可以调用<code>advancedBy(_:)</code>方法来获取。但如果尝试获取出界的字符串索引，就会抛出一个运行时错误。</p>
<p>你可以使用下标语法来访问<code>String</code>特定索引的<code>Character</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting = <span class="string">"Guten Tag!"</span></span><br><span class="line">greeting[greeting.startIndex]</span><br><span class="line"><span class="comment">// G</span></span><br><span class="line">greeting[greeting.endIndex.predecessor()]</span><br><span class="line"><span class="comment">// !</span></span><br><span class="line">greeting[greeting.startIndex.successor()]</span><br><span class="line"><span class="comment">// u</span></span><br><span class="line"><span class="keyword">let</span> index = greeting.startIndex.advancedBy(<span class="number">7</span>)</span><br><span class="line">greeting[index]</span><br><span class="line"><span class="comment">// a</span></span><br></pre></td></tr></table></figure>
<p>试图获取越界索引对应的<code>Character</code>，将引发一个运行时错误。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">greeting[greeting.endIndex] <span class="comment">// error</span></span><br><span class="line">greeting.endIndex.successor() <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<p>使用<code>characters</code>属性的<code>indices</code>属性会创建一个包含全部索引的范围(<code>Range</code>)，用来在一个字符串中访问单个字符。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> greeting.characters.<span class="built_in">indices</span> &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"<span class="subst">\(greeting[index])</span> "</span>, terminator: <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印输出 "G u t e n   T a g !"</span></span><br></pre></td></tr></table></figure>
<p><a name="inserting_and_removing"></a></p>
<h3 id="插入和删除_(Inserting_and_Removing)">插入和删除 (Inserting and Removing)</h3><p>调用<code>insert(_:atIndex:)</code>方法可以在一个字符串的指定索引插入一个字符。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> welcome = <span class="string">"hello"</span></span><br><span class="line">welcome.insert(<span class="string">"!"</span>, atIndex: welcome.endIndex)</span><br><span class="line"><span class="comment">// welcome now 现在等于 "hello!"</span></span><br></pre></td></tr></table></figure>
<p>调用<code>insertContentsOf(_:at:)</code>方法可以在一个字符串的指定索引插入一个字符串。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">welcome.insertContentsOf(<span class="string">" there"</span>.characters, at: welcome.endIndex.predecessor())</span><br><span class="line"><span class="comment">// welcome 现在等于 "hello there!"</span></span><br></pre></td></tr></table></figure>
<p>调用<code>removeAtIndex(_:)</code>方法可以在一个字符串的指定索引删除一个字符。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">welcome.removeAtIndex(welcome.endIndex.predecessor())</span><br><span class="line"><span class="comment">// welcome 现在等于 "hello there"</span></span><br></pre></td></tr></table></figure>
<p>调用<code>removeRange(_:)</code>方法可以在一个字符串的指定索引删除一个子字符串。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> range = welcome.endIndex.advancedBy(-<span class="number">6</span>)..&lt;welcome.endIndex</span><br><span class="line">welcome.removeRange(range)</span><br><span class="line"><span class="comment">// welcome 现在等于 "hello"</span></span><br></pre></td></tr></table></figure>
<p><a name="comparing_strings"></a></p>
<h2 id="比较字符串_(Comparing_Strings)">比较字符串 (Comparing Strings)</h2><p>Swift 提供了三种方式来比较文本值：字符串字符相等、前缀相等和后缀相等。</p>
<p><a name="string_and_character_equality"></a></p>
<h3 id="字符串/字符相等_(String_and_Character_Equality)">字符串/字符相等 (String and Character Equality)</h3><p>字符串/字符可以用等于操作符(<code>==</code>)和不等于操作符(<code>!=</code>)，详细描述在<a href="./02_Basic_Operators.html#comparison_operators">比较运算符</a>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> quotation = <span class="string">"We're a lot alike, you and I."</span></span><br><span class="line"><span class="keyword">let</span> sameQuotation = <span class="string">"We're a lot alike, you and I."</span></span><br><span class="line"><span class="keyword">if</span> quotation == sameQuotation &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"These two strings are considered equal"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印输出 "These two strings are considered equal"</span></span><br></pre></td></tr></table></figure>
<p>如果两个字符串（或者两个字符）的可扩展的字形群集是标准相等的，那就认为它们是相等的。在这个情况下，即使可扩展的字形群集是有不同的 Unicode 标量构成的，只要它们有同样的语言意义和外观，就认为它们标准相等。</p>
<p>例如，<code>LATIN SMALL LETTER E WITH ACUTE</code>(<code>U+00E9</code>)就是标准相等于<code>LATIN SMALL LETTER E</code>(<code>U+0065</code>)后面加上<code>COMBINING ACUTE ACCENT</code>(<code>U+0301</code>)。这两个字符群集都是表示字符<code>é</code>的有效方式，所以它们被认为是标准相等的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// "Voulez-vous un café?" 使用 LATIN SMALL LETTER E WITH ACUTE</span></span><br><span class="line"><span class="keyword">let</span> eAcuteQuestion = <span class="string">"Voulez-vous un caf\u&#123;E9&#125;?"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// "Voulez-vous un café?" 使用 LATIN SMALL LETTER E and COMBINING ACUTE ACCENT</span></span><br><span class="line"><span class="keyword">let</span> combinedEAcuteQuestion = <span class="string">"Voulez-vous un caf\u&#123;65&#125;\u&#123;301&#125;?"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> eAcuteQuestion == combinedEAcuteQuestion &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"These two strings are considered equal"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印输出 "These two strings are considered equal"</span></span><br></pre></td></tr></table></figure>
<p>相反，英语中的<code>LATIN CAPITAL LETTER A</code>(<code>U+0041</code>，或者<code>A</code>)不等于俄语中的<code>CYRILLIC CAPITAL LETTER A</code>(<code>U+0410</code>，或者<code>A</code>)。两个字符看着是一样的，但却有不同的语言意义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> latinCapitalLetterA: <span class="type">Character</span> = <span class="string">"\u&#123;41&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cyrillicCapitalLetterA: <span class="type">Character</span> = <span class="string">"\u&#123;0410&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> latinCapitalLetterA != cyrillicCapitalLetterA &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"These two characters are not equivalent"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "These two characters are not equivalent"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>在 Swift 中，字符串和字符并不区分区域。</p>
</blockquote>
<p><a name="prefix_and_suffix_equality"></a></p>
<h3 id="前缀/后缀相等_(Prefix_and_Suffix_Equality)">前缀/后缀相等 (Prefix and Suffix Equality)</h3><p>通过调用字符串的<code>hasPrefix(_:)</code>/<code>hasSuffix(_:)</code>方法来检查字符串是否拥有特定前缀/后缀，两个方法均接收一个<code>String</code>类型的参数，并返回一个布尔值。</p>
<p>下面的例子以一个字符串数组表示莎士比亚话剧《罗密欧与朱丽叶》中前两场的场景位置：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> romeoAndJuliet = [</span><br><span class="line">    <span class="string">"Act 1 Scene 1: Verona, A public place"</span>,</span><br><span class="line">    <span class="string">"Act 1 Scene 2: Capulet's mansion"</span>,</span><br><span class="line">    <span class="string">"Act 1 Scene 3: A room in Capulet's mansion"</span>,</span><br><span class="line">    <span class="string">"Act 1 Scene 4: A street outside Capulet's mansion"</span>,</span><br><span class="line">    <span class="string">"Act 1 Scene 5: The Great Hall in Capulet's mansion"</span>,</span><br><span class="line">    <span class="string">"Act 2 Scene 1: Outside Capulet's mansion"</span>,</span><br><span class="line">    <span class="string">"Act 2 Scene 2: Capulet's orchard"</span>,</span><br><span class="line">    <span class="string">"Act 2 Scene 3: Outside Friar Lawrence's cell"</span>,</span><br><span class="line">    <span class="string">"Act 2 Scene 4: A street in Verona"</span>,</span><br><span class="line">    <span class="string">"Act 2 Scene 5: Capulet's mansion"</span>,</span><br><span class="line">    <span class="string">"Act 2 Scene 6: Friar Lawrence's cell"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>您可以调用<code>hasPrefix(_:)</code>方法来计算话剧中第一幕的场景数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> act1SceneCount = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> scene <span class="keyword">in</span> romeoAndJuliet &#123;</span><br><span class="line">    <span class="keyword">if</span> scene.hasPrefix(<span class="string">"Act 1 "</span>) &#123;</span><br><span class="line">        ++act1SceneCount</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"There are <span class="subst">\(act1SceneCount)</span> scenes in Act 1"</span>)</span><br><span class="line"><span class="comment">// 打印输出 "There are 5 scenes in Act 1"</span></span><br></pre></td></tr></table></figure>
<p>相似地，您可以用<code>hasSuffix(_:)</code>方法来计算发生在不同地方的场景数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mansionCount = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> cellCount = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> scene <span class="keyword">in</span> romeoAndJuliet &#123;</span><br><span class="line">    <span class="keyword">if</span> scene.hasSuffix(<span class="string">"Capulet's mansion"</span>) &#123;</span><br><span class="line">        ++mansionCount</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> scene.hasSuffix(<span class="string">"Friar Lawrence's cell"</span>) &#123;</span><br><span class="line">        ++cellCount</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(mansionCount)</span> mansion scenes; <span class="subst">\(cellCount)</span> cell scenes"</span>)</span><br><span class="line"><span class="comment">// 打印输出 "6 mansion scenes; 2 cell scenes"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br><code>hasPrefix(_:)</code>和<code>hasSuffix(_:)</code>方法都是在每个字符串中逐字符比较其可扩展的字符群集是否标准相等，详细描述在<a href="#string_and_character_equality">字符串/字符相等</a>。</p>
</blockquote>
<p><a name="unicode_representations_of_strings"></a></p>
<h2 id="字符串的_Unicode_表示形式（Unicode_Representations_of_Strings）">字符串的 Unicode 表示形式（Unicode Representations of Strings）</h2><p>当一个 Unicode 字符串被写进文本文件或者其他储存时，字符串中的 Unicode 标量会用 Unicode 定义的几种编码格式编码。每一个字符串中的小块编码都被称为代码单元。这些包括 UTF-8 编码格式（编码字符串为8位的代码单元）， UTF-16 编码格式（编码字符串位16位的代码单元），以及 UTF-32 编码格式（编码字符串32位的代码单元）。</p>
<p>Swift 提供了几种不同的方式来访问字符串的 Unicode 表示形式。<br>您可以利用<code>for-in</code>来对字符串进行遍历，从而以 Unicode 可扩展的字符群集的方式访问每一个<code>Character</code>值。<br>该过程在 <a href="#working_with_characters">使用字符</a> 中进行了描述。</p>
<p>另外，能够以其他三种 Unicode 兼容的方式访问字符串的值：</p>
<ul>
<li>UTF-8 代码单元集合 (利用字符串的<code>utf8</code>属性进行访问)</li>
<li>UTF-16 代码单元集合 (利用字符串的<code>utf16</code>属性进行访问)</li>
<li>21位的 Unicode 标量值集合，也就是字符串的 UTF-32 编码格式 (利用字符串的<code>unicodeScalars</code>属性进行访问)</li>
</ul>
<p>下面由<code>D``o``g``‼</code>(<code>DOUBLE EXCLAMATION MARK</code>, Unicode 标量 <code>U+203C</code>)和<code>�</code>(<code>DOG FACE</code>，Unicode 标量为<code>U+1F436</code>)组成的字符串中的每一个字符代表着一种不同的表示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dogString = <span class="string">"Dog‼🐶"</span></span><br></pre></td></tr></table></figure>
<p><a name="UTF-8_representation"></a></p>
<h3 id="UTF-8_表示">UTF-8 表示</h3><p>您可以通过遍历<code>String</code>的<code>utf8</code>属性来访问它的<code>UTF-8</code>表示。<br>其为<code>String.UTF8View</code>类型的属性，<code>UTF8View</code>是无符号8位 (<code>UInt8</code>) 值的集合，每一个<code>UInt8</code>值都是一个字符的 UTF-8 表示：</p>
<table style="text-align:center"><br> <tr height="77"><br>  <td>Character</td><br>  <td>D<br>U+0044</td><br>  <td>o<br>U+006F</td><br>  <td>g<br>U+0067</td><br>  <td colspan="3">‼<br>U+203C</td><br>  <td colspan="4">🐶<br>U+1F436</td><br> </tr><br> <tr height="77"><br>  <td height="77">UTF-8<br>Code Unit</td><br>  <td>68</td><br>  <td>111</td><br>  <td>103</td><br>  <td>226</td><br>  <td>128</td><br>  <td>188</td><br>  <td>240</td><br>  <td>159</td><br>  <td>144</td><br>  <td>182</td><br> </tr><br> <tr><br>  <td height="77">Position</td><br>  <td>0</td><br>  <td>1</td><br>  <td>2</td><br>  <td>3</td><br>  <td>4</td><br>  <td>5</td><br>  <td>6</td><br>  <td>7</td><br>  <td>8</td><br>  <td>9</td><br> </tr><br></table>


<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> codeUnit <span class="keyword">in</span> dogString.utf8 &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(codeUnit)</span> "</span>, terminator: <span class="string">""</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">""</span>)</span><br><span class="line"><span class="comment">// 68 111 103 226 128 188 240 159 144 182</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，前三个10进制<code>codeUnit</code>值 (<code>68</code>, <code>111</code>, <code>103</code>) 代表了字符<code>D</code>、<code>o</code>和 <code>g</code>，它们的 UTF-8 表示与 ASCII 表示相同。<br>接下来的三个10进制<code>codeUnit</code>值 (<code>226</code>, <code>128</code>, <code>188</code>) 是<code>DOUBLE EXCLAMATION MARK</code>的3字节 UTF-8 表示。<br>最后的四个<code>codeUnit</code>值 (<code>240</code>, <code>159</code>, <code>144</code>, <code>182</code>) 是<code>DOG FACE</code>的4字节 UTF-8 表示。</p>
<p><a name="UTF-16_representation"></a></p>
<h3 id="UTF-16_表示">UTF-16 表示</h3><p>您可以通过遍历<code>String</code>的<code>utf16</code>属性来访问它的<code>UTF-16</code>表示。<br>其为<code>String.UTF16View</code>类型的属性，<code>UTF16View</code>是无符号16位 (<code>UInt16</code>) 值的集合，每一个<code>UInt16</code>都是一个字符的 UTF-16 表示：</p>
<table style="text-align:center"><br> <tr height="77"><br>  <td>Character</td><br>  <td>D<br>U+0044</td><br>  <td>o<br>U+006F</td><br>  <td>g<br>U+0067</td><br>  <td>‼<br>U+203C</td><br>  <td colspan="2">🐶<br>U+1F436</td><br> </tr><br> <tr height="77"><br>  <td height="77">UTF-16<br>Code Unit</td><br>  <td>68</td><br>  <td>111</td><br>  <td>103</td><br>  <td>8252</td><br>  <td>55357</td><br>  <td>56374</td><br> </tr><br> <tr><br>  <td height="77">Position</td><br>  <td>0</td><br>  <td>1</td><br>  <td>2</td><br>  <td>3</td><br>  <td>4</td><br>  <td>5</td><br> </tr><br></table>


<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> codeUnit <span class="keyword">in</span> dogString.utf16 &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(codeUnit)</span> "</span>, terminator: <span class="string">""</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">""</span>)</span><br><span class="line"><span class="comment">// 68 111 103 8252 55357 56374</span></span><br></pre></td></tr></table></figure>
<p>同样，前三个<code>codeUnit</code>值 (<code>68</code>, <code>111</code>, <code>103</code>) 代表了字符<code>D</code>、<code>o</code>和<code>g</code>，它们的 UTF-16 代码单元和 UTF-8 完全相同（因为这些 Unicode 标量表示 ASCII 字符）。</p>
<p>第四个<code>codeUnit</code>值 (<code>8252</code>) 是一个等于十六进制<code>203C</code>的的十进制值。这个代表了<code>DOUBLE EXCLAMATION MARK</code>字符的 Unicode 标量值<code>U+203C</code>。这个字符在 UTF-16 中可以用一个代码单元表示。</p>
<p>第五和第六个<code>codeUnit</code>值 (<code>55357</code>和<code>56374</code>) 是<code>DOG FACE</code>字符的 UTF-16 表示。<br>第一个值为<code>U+D83D</code>(十进制值为<code>55357</code>)，第二个值为<code>U+DC36</code>(十进制值为<code>56374</code>)。</p>
<p><a name="unicode_scalars_representation"></a></p>
<h3 id="Unicode_标量表示_(Unicode_Scalars_Representation)">Unicode 标量表示 (Unicode Scalars Representation)</h3><p>您可以通过遍历<code>String</code>值的<code>unicodeScalars</code>属性来访问它的 Unicode 标量表示。<br>其为<code>UnicodeScalarView</code>类型的属性，<code>UnicodeScalarView</code>是<code>UnicodeScalar</code>的集合。<br><code>UnicodeScalar</code>是21位的 Unicode 代码点。</p>
<p>每一个<code>UnicodeScalar</code>拥有一个<code>value</code>属性，可以返回对应的21位数值，用<code>UInt32</code>来表示：</p>
<table style="text-align:center"><br> <tr height="77"><br>  <td>Character</td><br>  <td>D<br>U+0044</td><br>  <td>o<br>U+006F</td><br>  <td>g<br>U+0067</td><br>  <td>‼<br>U+203C</td><br>  <td>🐶<br>U+1F436</td><br> </tr><br> <tr height="77"><br>  <td height="77">UTF-16<br>Code Unit</td><br>  <td>68</td><br>  <td>111</td><br>  <td>103</td><br>  <td>8252</td><br>  <td>128054</td><br> </tr><br> <tr><br>  <td height="77">Position</td><br>  <td>0</td><br>  <td>1</td><br>  <td>2</td><br>  <td>3</td><br>  <td>4</td><br> </tr><br></table>


<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> scalar <span class="keyword">in</span> dogString.unicodeScalars &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(scalar.value)</span> "</span>, terminator: <span class="string">""</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">""</span>)</span><br><span class="line"><span class="comment">// 68 111 103 8252 128054</span></span><br></pre></td></tr></table></figure>
<p>前三个<code>UnicodeScalar</code>值(<code>68</code>, <code>111</code>, <code>103</code>)的<code>value</code>属性仍然代表字符<code>D</code>、<code>o</code>和<code>g</code>。<br>第四个<code>codeUnit</code>值(<code>8252</code>)仍然是一个等于十六进制<code>203C</code>的十进制值。这个代表了<code>DOUBLE EXCLAMATION MARK</code>字符的 Unicode 标量<code>U+203C</code>。</p>
<p>第五个<code>UnicodeScalar</code>值的<code>value</code>属性，<code>128054</code>，是一个十六进制<code>1F436</code>的十进制表示。其等同于<code>DOG FACE</code>的 Unicode 标量<code>U+1F436</code>。</p>
<p>作为查询它们的<code>value</code>属性的一种替代方法，每个<code>UnicodeScalar</code>值也可以用来构建一个新的<code>String</code>值，比如在字符串插值中使用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> scalar <span class="keyword">in</span> dogString.unicodeScalars &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(scalar)</span> "</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// D</span></span><br><span class="line"><span class="comment">// o</span></span><br><span class="line"><span class="comment">// g</span></span><br><span class="line"><span class="comment">// ‼</span></span><br><span class="line"><span class="comment">// 🐶</span></span><br></pre></td></tr></table></figure>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/">&laquo;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/5/">&raquo;</a>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="https://avatars2.githubusercontent.com/u/14305708?v=3&s=460" alt="terry" itemprop="image"/>
          <p class="site-author-name" itemprop="name">terry</p>
        </div>
        <p class="site-description motion-element" itemprop="description">terry yang's blog | java | scala | bi</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">136</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">11</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-next-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yangwei8888" target="_blank">github</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/microsoftgoogles" target="_blank">weibo</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/run-zhi-38" target="_blank">zhihu</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">terry</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  

    <script type="text/javascript">
      var disqus_shortname = 'yangwei888';
      var disqus_identifier = 'page/4/index.html';
      var disqus_title = '';
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
