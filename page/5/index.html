<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="terry yang's blog | java | scala | bi" />



  <meta name="keywords" content="Hexo,next" />



  <link rel="alternate" href="/atom.xml" title="yosita" type="application/atom+xml" />



  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="terry yang&apos;s blog | java | scala | bi">
<meta property="og:type" content="website">
<meta property="og:title" content="yosita">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="yosita">
<meta property="og:description" content="terry yang&apos;s blog | java | scala | bi">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="yosita">
<meta name="twitter:description" content="terry yang&apos;s blog | java | scala | bi">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>

  <title> yosita </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  

  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?7e8961fdae021b7bf62f2c767bb18c23";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">yosita</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/12_Subscripts/" itemprop="url">
                第二章-12下标脚本（Subscripts）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:15+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/12_Subscripts/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/12_Subscripts/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="下标脚本（Subscripts）">下标脚本（Subscripts）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/siemenliu" target="_blank" rel="external">siemenliu</a><br>校对：<a href="https://github.com/zq54zquan" target="_blank" rel="external">zq54zquan</a></p>
<p>2.0,2.1<br>翻译+校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a>，2015-10-29</p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#subscript_syntax">下标脚本语法</a></li>
<li><a href="#subscript_usage">下标脚本用法</a></li>
<li><a href="#subscript_options">下标脚本选项</a></li>
</ul>
<p><em>下标脚本</em> 可以定义在类（Class）、结构体（structure）和枚举（enumeration）中，是访问集合（collection），列表（list）或序列（sequence）中元素的快捷方式。可以使用下标脚本的索引设置和获取值，不需要再调用对应的存取方法。举例来说，用下标脚本访问一个<code>Array</code>实例中的元素可以写作<code>someArray[index]</code>，访问<code>Dictionary</code>实例中的元素可以写作<code>someDictionary[key]</code>。</p>
<p>一个类型可以定义多个下标脚本，通过不同索引类型进行重载。下标脚本不限于一维，你可以定义具有多个入参的下标脚本满足自定义类型的需求。</p>
<p><a name="subscript_syntax"></a></p>
<h2 id="下标脚本语法">下标脚本语法</h2><p>下标脚本允许你通过在实例名称后面的方括号中传入一个或者多个索引值来对实例进行存取。语法类似于实例方法语法和计算型属性语法的混合。与定义实例方法类似，定义下标脚本使用<code>subscript</code>关键字，指定一个或多个入参和返回类型。与实例方法不同的是，下标脚本可以设定为读写或只读。这种行为由 getter 和 setter 实现，有点类似计算型属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">subscript</span>(index: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">      <span class="comment">// 返回一个适当的 Int 类型的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span>(newValue) &#123;</span><br><span class="line">      <span class="comment">// 执行适当的赋值操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>newValue</code>的类型和下标脚本的返回类型相同。如同计算型属性，可以不指定 setter 的参数（<code>newValue</code>）。如果不指定参数，setter 会提供一个名为<code>newValue</code>的默认参数。</p>
<p>如同只读计算型属性，可以省略只读下标脚本的<code>get</code>关键字：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">subscript</span>(index: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="comment">// 返回一个适当的 Int 类型的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面代码演示了只读下标脚本的实现，这里定义了一个<code>TimesTable</code>结构体，用来表示传入整数的乘法表：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TimesTable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> multiplier: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">subscript</span>(index: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> multiplier * index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> threeTimesTable = <span class="type">TimesTable</span>(multiplier: <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"six times three is <span class="subst">\(threeTimesTable[<span class="number">6</span>])</span>"</span>)</span><br><span class="line"><span class="comment">// 输出 "six times three is 18"</span></span><br></pre></td></tr></table></figure>
<p>在上例中，创建了一个<code>TimesTable</code>实例，用来表示整数<code>3</code>的乘法表。数值<code>3</code>被传递给结构体的构造函数，作为实例成员<code>multiplier</code>的值。</p>
<p>你可以通过下标脚本访问<code>threeTimesTable</code>实例，例如上面演示的<code>threeTimesTable[6]</code>。这条语句查询了<code>3</code>的乘法表中的第六个元素，返回<code>3</code>的<code>6</code>倍即<code>18</code>。</p>
<blockquote>
<p>注意<br><code>TimesTable</code>例子基于一个固定的数学公式，对<code>threeTimesTable[someIndex]</code>进行赋值操作并不合适，因此下标脚本定义为只读的。  </p>
</blockquote>
<p><a name="subscript_usage"></a></p>
<h2 id="下标脚本用法">下标脚本用法</h2><p>下标脚本的确切含义取决于使用场景。下标脚本通常作为访问集合（collection），列表（list）或序列（sequence）中元素的快捷方式。你可以针对自己特定的类或结构体的功能来自由地以最恰当的方式实现下标脚本。</p>
<p>例如，Swift 的<code>Dictionary</code>类型实现下标脚本用于对其实例中储存的值进行存取操作。为字典设值时，在下标脚本中使用和字典的键类型相同的键，并把一个和字典的值类型相同的值赋给这个下标脚本：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numberOfLegs = [<span class="string">"spider"</span>: <span class="number">8</span>, <span class="string">"ant"</span>: <span class="number">6</span>, <span class="string">"cat"</span>: <span class="number">4</span>]</span><br><span class="line">numberOfLegs[<span class="string">"bird"</span>] = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>上例定义一个名为<code>numberOfLegs</code>的变量，并用一个包含三对键值的字典字面量初始化它。<code>numberOfLegs</code>字典的类型被推断为<code>[String: Int]</code>。字典创建完成后，该例子通过下标脚本将<code>String</code>类型的键<code>bird</code>和<code>Int</code>类型的值<code>2</code>添加到字典中。</p>
<p>更多关于<code>Dictionary</code>下标脚本的信息请参考<a href="./04_Collection_Types.html#accessing_and_modifying_a_dictionary">读取和修改字典</a></p>
<blockquote>
<p>注意<br>Swift 的<code>Dictionary</code>类型的下标脚本接受并返回可选类型的值。上例中的<code>numberOfLegs</code>字典通过下标脚本返回的是一个<code>Int?</code>或者说“可选的int”。<code>Dictionary</code>类型之所以如此实现下标脚本，是因为不是每个键都有个对应的值，同时这也提供了一种通过键删除对应值的方式，只需将键对应的值赋值为<code>nil</code>即可。  </p>
</blockquote>
<p><a name="subscript_options"></a></p>
<h2 id="下标脚本选项">下标脚本选项</h2><p>下标脚本可以接受任意数量的入参，并且这些入参可以是任意类型。下标脚本的返回值也可以是任意类型。下标脚本可以使用变量参数和可变参数，但不能使用输入输出参数，也不能给参数设置默认值。</p>
<p>一个类或结构体可以根据自身需要提供多个下标脚本实现，使用下标脚本时将通过入参的数量和类型进行区分，自动匹配合适的下标脚本，这就是<em>下标脚本的重载</em>。</p>
<p>虽然接受单一入参的下标脚本是最常见的，但也可以根据情况定义接受多个入参的下标脚本。例如下例定义了一个<code>Matrix</code>结构体，用于表示一个<code>Double</code>类型的二维矩阵。<code>Matrix</code>结构体的下标脚本接受两个整型参数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> rows: <span class="type">Int</span>, columns: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> grid: [<span class="type">Double</span>]</span><br><span class="line">    <span class="keyword">init</span>(rows: <span class="type">Int</span>, columns: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.rows = rows</span><br><span class="line">        <span class="keyword">self</span>.columns = columns</span><br><span class="line">        grid = <span class="type">Array</span>(<span class="built_in">count</span>: rows * columns, repeatedValue: <span class="number">0.0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">indexIsValidForRow</span><span class="params">(row: Int, column: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> row &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; column &gt;= <span class="number">0</span> &amp;&amp; column &lt; columns</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(row: <span class="type">Int</span>, column: <span class="type">Int</span>) -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="built_in">assert</span>(indexIsValidForRow(row, column: column), <span class="string">"Index out of range"</span>)</span><br><span class="line">            <span class="keyword">return</span> grid[(row * columns) + column]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="built_in">assert</span>(indexIsValidForRow(row, column: column), <span class="string">"Index out of range"</span>)</span><br><span class="line">            grid[(row * columns) + column] = newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Matrix</code>提供了一个接受两个入参的构造方法，入参分别是<code>rows</code>和<code>columns</code>，创建了一个足够容纳<code>rows * columns</code>个<code>Double</code>类型的值的数组。通过传入数组长度和初始值<code>0.0</code>到数组的构造器，将矩阵中每个位置的值初始化为<code>0.0</code>。关于数组的这种构造方法请参考<a href="./04_Collection_Types.html#creating_an_empty_array">创建一个空数组</a>。</p>
<p>你可以通过传入合适的<code>row</code>和<code>column</code>的数量来构造一个新的<code>Matrix</code>实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> matrix = <span class="type">Matrix</span>(rows: <span class="number">2</span>, columns: <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>上例中创建了一个<code>Matrix</code>实例来表示两行两列的矩阵。该<code>Matrix</code>实例的<code>grid</code>数组按照从左上到右下的阅读顺序将矩阵扁平化存储：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/subscriptMatrix01_2x.png" alt=""></p>
<p>将<code>row</code>和<code>column</code>的值传入下标脚本来为矩阵设值，下标脚本的入参使用逗号分隔：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">matrix[<span class="number">0</span>, <span class="number">1</span>] = <span class="number">1.5</span></span><br><span class="line">matrix[<span class="number">1</span>, <span class="number">0</span>] = <span class="number">3.2</span></span><br></pre></td></tr></table></figure>
<p>上面两条语句分别调用下标脚本的 setter 将矩阵右上角位置（即<code>row</code>为<code>0</code>、<code>column</code>为<code>1</code>的位置）的值设置为<code>1.5</code>，将矩阵左下角位置（即<code>row</code>为<code>1</code>、<code>column</code>为<code>0</code>的位置）的值设置为<code>3.2</code>：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/subscriptMatrix02_2x.png" alt=""></p>
<p><code>Matrix</code>下标脚本的 getter 和 setter 中都含有断言，用来检查下标脚本入参<code>row</code>和<code>column</code>的值是否有效。为了方便进行断言，<code>Matrix</code>包含了一个名为<code>indexIsValidForRow(_:column:)</code>的便利方法，用来检查入参<code>row</code>和<code>column</code>的值是否在矩阵范围内：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">indexIsValidForRow</span><span class="params">(row: Int, column: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> row &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; column &gt;= <span class="number">0</span> &amp;&amp; column &lt; columns</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>断言在下标脚本越界时触发：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue = matrix[<span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line"><span class="comment">// 断言将会触发，因为 [2, 2] 已经超过了 matrix 的范围</span></span><br></pre></td></tr></table></figure>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/13_Inheritance/" itemprop="url">
                第二章-13继承（Inheritance）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:14+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/13_Inheritance/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/13_Inheritance/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="继承（Inheritance）">继承（Inheritance）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/Hawstein" target="_blank" rel="external">Hawstein</a><br>校对：<a href="https://github.com/menlongsheng" target="_blank" rel="external">menlongsheng</a></p>
<p>2.0，2.1<br>翻译+校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#defining_a_base_class">定义一个基类（Base class）</a></li>
<li><a href="#subclassing">子类生成（Subclassing）</a></li>
<li><a href="#overriding">重写（Overriding）</a></li>
<li><a href="#preventing_overrides">防止重写（Preventing Overrides）</a></li>
</ul>
<p>一个类可以<em>继承（inherit）</em>另一个类的方法（methods），属性（properties）和其它特性。当一个类继承其它类时，继承类叫<em>子类（subclass）</em>，被继承类叫<em>超类（或父类，superclass）</em>。在 Swift 中，继承是区分「类」与其它类型的一个基本特征。</p>
<p>在 Swift 中，类可以调用和访问超类的方法，属性和下标脚本（subscripts），并且可以重写（override）这些方法，属性和下标脚本来优化或修改它们的行为。Swift 会检查你的重写定义在超类中是否有匹配的定义，以此确保你的重写行为是正确的。</p>
<p>可以为类中继承来的属性添加属性观察器（property observers），这样一来，当属性值改变时，类就会被通知到。可以为任何属性添加属性观察器，无论它原本被定义为存储型属性（stored property）还是计算型属性（computed property）。</p>
<p><a name="defining_a_base_class"></a></p>
<h2 id="定义一个基类（Base_class）">定义一个基类（Base class）</h2><p>不继承于其它类的类，称之为<em>基类（base calss）</em>。</p>
<blockquote>
<p>注意<br>Swift 中的类并不是从一个通用的基类继承而来。如果你不为你定义的类指定一个超类的话，这个类就自动成为基类。</p>
</blockquote>
<p>下面的例子定义了一个叫<code>Vehicle</code>的基类。这个基类声明了一个名为<code>currentSpeed</code>，默认值是<code>0.0</code>的存储属性（属性类型推断为<code>Double</code>）。<code>currentSpeed</code>属性的值被一个<code>String</code>类型的只读计算型属性<code>description</code>使用，用来创建车辆的描述。</p>
<p><code>Vehicle</code>基类也定义了一个名为<code>makeNoise</code>的方法。这个方法实际上不为<code>Vehicle</code>实例做任何事，但之后将会被<code>Vehicle</code>的子类定制：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> currentSpeed = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"traveling at <span class="subst">\(currentSpeed)</span> miles per hour"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">makeNoise</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 什么也不做-因为车辆不一定会有噪音</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以用初始化语法创建一个<code>Vehicle</code>的新实例，即类名后面跟一个空括号：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someVehicle = <span class="type">Vehicle</span>()</span><br></pre></td></tr></table></figure>
<p>现在已经创建了一个<code>Vehicle</code>的新实例，你可以访问它的<code>description</code>属性来打印车辆的当前速度：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Vehicle: <span class="subst">\(someVehicle.description)</span>"</span>)</span><br><span class="line"><span class="comment">// Vehicle: traveling at 0.0 miles per hour</span></span><br></pre></td></tr></table></figure>
<p><code>Vehicle</code>类定义了一个通用特性的车辆类，实际上没什么用处。为了让它变得更加有用，需要完善它从而能够描述一个更加具体类型的车辆。</p>
<p><a name="subclassing"></a></p>
<h2 id="子类生成（Subclassing）">子类生成（Subclassing）</h2><p><em>子类生成（Subclassing）</em>指的是在一个已有类的基础上创建一个新的类。子类继承超类的特性，并且可以进一步完善。你还可以为子类添加新的特性。</p>
<p>为了指明某个类的超类，将超类名写在子类名的后面，用冒号分隔：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>: <span class="title">SomeSuperclass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里是子类的定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一个例子，定义一个叫<code>Bicycle</code>的子类，继承成父类<code>Vehicle</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bicycle</span>: <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hasBasket = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新的<code>Bicycle</code>类自动获得<code>Vehicle</code>类的所有特性，比如<code>currentSpeed</code>和<code>description</code>属性，还有它的<code>makeNoise()</code>方法。</p>
<p>除了它所继承的特性，<code>Bicycle</code>类还定义了一个默认值为<code>false</code>的存储型属性<code>hasBasket</code>（属性推断为<code>Bool</code>）。</p>
<p>默认情况下，你创建任何新的<code>Bicycle</code>实例将不会有一个篮子（即<code>hasBasket</code>属性默认为<code>false</code>），创建该实例之后，你可以为特定的<code>Bicycle</code>实例设置<code>hasBasket</code>属性为<code>ture</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bicycle = <span class="type">Bicycle</span>()</span><br><span class="line">bicycle.hasBasket = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>你还可以修改<code>Bicycle</code>实例所继承的<code>currentSpeed</code>属性，和查询实例所继承的<code>description</code>属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bicycle.currentSpeed = <span class="number">15.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Bicycle: <span class="subst">\(bicycle.description)</span>"</span>)</span><br><span class="line"><span class="comment">// Bicycle: traveling at 15.0 miles per hour</span></span><br></pre></td></tr></table></figure>
<p>子类还可以继续被其它类继承，下面的示例为<code>Bicycle</code>创建了一个名为<code>Tandem</code>（双人自行车）的子类：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tandem</span>: <span class="title">Bicycle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> currentNumberOfPassengers = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Tandem</code>从<code>Bicycle</code>继承了所有的属性与方法，这又使它同时继承了<code>Vehicle</code>的所有属性与方法。<code>Tandem</code>也增加了一个新的叫做<code>currentNumberOfPassengers</code>的存储型属性，默认值为<code>0</code>。</p>
<p>如果你创建了一个<code>Tandem</code>的实例，你可以使用它所有的新属性和继承的属性，还能查询从<code>Vehicle</code>继承来的只读属性<code>description</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tandem = <span class="type">Tandem</span>()</span><br><span class="line">tandem.hasBasket = <span class="literal">true</span></span><br><span class="line">tandem.currentNumberOfPassengers = <span class="number">2</span></span><br><span class="line">tandem.currentSpeed = <span class="number">22.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Tandem: <span class="subst">\(tandem.description)</span>"</span>)</span><br><span class="line"><span class="comment">// Tandem: traveling at 22.0 miles per hour</span></span><br></pre></td></tr></table></figure>
<p><a name="overriding"></a></p>
<h2 id="重写（Overriding）">重写（Overriding）</h2><p>子类可以为继承来的实例方法（instance method），类方法（class method），实例属性（instance property），或下标脚本（subscript）提供自己定制的实现（implementation）。我们把这种行为叫<em>重写（overriding）</em>。</p>
<p>如果要重写某个特性，你需要在重写定义的前面加上<code>override</code>关键字。这么做，你就表明了你是想提供一个重写版本，而非错误地提供了一个相同的定义。意外的重写行为可能会导致不可预知的错误，任何缺少<code>override</code>关键字的重写都会在编译时被诊断为错误。</p>
<p><code>override</code>关键字会提醒 Swift 编译器去检查该类的超类（或其中一个父类）是否有匹配重写版本的声明。这个检查可以确保你的重写定义是正确的。</p>
<h3 id="访问超类的方法，属性及下标脚本">访问超类的方法，属性及下标脚本</h3><p>当你在子类中重写超类的方法，属性或下标脚本时，有时在你的重写版本中使用已经存在的超类实现会大有裨益。比如，你可以完善已有实现的行为，或在一个继承来的变量中存储一个修改过的值。</p>
<p>在合适的地方，你可以通过使用<code>super</code>前缀来访问超类版本的方法，属性或下标脚本：</p>
<ul>
<li>在方法<code>someMethod()</code>的重写实现中，可以通过<code>super.someMethod()</code>来调用超类版本的<code>someMethod()</code>方法。</li>
<li>在属性<code>someProperty</code>的 getter 或 setter 的重写实现中，可以通过<code>super.someProperty</code>来访问超类版本的<code>someProperty</code>属性。</li>
<li>在下标脚本的重写实现中，可以通过<code>super[someIndex]</code>来访问超类版本中的相同下标脚本。</li>
</ul>
<h3 id="重写方法">重写方法</h3><p>在子类中，你可以重写继承来的实例方法或类方法，提供一个定制或替代的方法实现。</p>
<p>下面的例子定义了<code>Vehicle</code>的一个新的子类，叫<code>Train</code>，它重写了从<code>Vehicle</code>类继承来的<code>makeNoise()</code>方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Train</span>: <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">makeNoise</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Choo Choo"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你创建一个<code>Train</code>的新实例，并调用了它的<code>makeNoise()</code>方法，你就会发现<code>Train</code>版本的方法被调用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> train = <span class="type">Train</span>()</span><br><span class="line">train.makeNoise()</span><br><span class="line"><span class="comment">// 打印 "Choo Choo"</span></span><br></pre></td></tr></table></figure>
<h3 id="重写属性">重写属性</h3><p>你可以重写继承来的实例属性或类型属性，提供自己定制的 getter 和 setter，或添加属性观察器使重写的属性可以观察属性值什么时候发生改变。</p>
<h4 id="重写属性的_Getters_和_Setters">重写属性的 Getters 和 Setters</h4><p>你可以提供定制的 getter（或 setter）来重写任意继承来的属性，无论继承来的属性是存储型的还是计算型的属性。子类并不知道继承来的属性是存储型的还是计算型的，它只知道继承来的属性会有一个名字和类型。你在重写一个属性时，必需将它的名字和类型都写出来。这样才能使编译器去检查你重写的属性是与超类中同名同类型的属性相匹配的。</p>
<p>你可以将一个继承来的只读属性重写为一个读写属性，只需要在重写版本的属性里提供 getter 和 setter 即可。但是，你不可以将一个继承来的读写属性重写为一个只读属性。</p>
<blockquote>
<p>注意<br>如果你在重写属性中提供了 setter，那么你也一定要提供 getter。如果你不想在重写版本中的 getter 里修改继承来的属性值，你可以直接通过<code>super.someProperty</code>来返回继承来的值，其中<code>someProperty</code>是你要重写的属性的名字。</p>
</blockquote>
<p>以下的例子定义了一个新类，叫<code>Car</code>，它是<code>Vehicle</code>的子类。这个类引入了一个新的存储型属性叫做<code>gear</code>，默认值为整数<code>1</code>。<code>Car</code>类重写了继承自<code>Vehicle</code>的<code>description</code>属性，提供包含当前档位的自定义描述：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>: <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> gear = <span class="number">1</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.description + <span class="string">" in gear <span class="subst">\(gear)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重写的<code>description</code>属性首先要调用<code>super.description</code>返回<code>Vehicle</code>类的<code>description</code>属性。之后，<code>Car</code>类版本的<code>description</code>在末尾增加了一些额外的文本来提供关于当前档位的信息。</p>
<p>如果你创建了<code>Car</code>的实例并且设置了它的<code>gear</code>和<code>currentSpeed</code>属性，你可以看到它的<code>description</code>返回了<code>Car</code>中的自定义描述：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> car = <span class="type">Car</span>()</span><br><span class="line">car.currentSpeed = <span class="number">25.0</span></span><br><span class="line">car.gear = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Car: <span class="subst">\(car.description)</span>"</span>)</span><br><span class="line"><span class="comment">// Car: traveling at 25.0 miles per hour in gear 3</span></span><br></pre></td></tr></table></figure>
<h4 id="重写属性观察器（Property_Observer）">重写属性观察器（Property Observer）</h4><p>你可以通过重写属性为一个继承来的属性添加属性观察器。这样一来，当继承来的属性值发生改变时，你就会被通知到，无论那个属性原本是如何实现的。关于属性观察器的更多内容，请看<a href="../chapter2/10_Properties.html#property_observers">属性观察器</a>。</p>
<blockquote>
<p>注意<br>你不可以为继承来的常量存储型属性或继承来的只读计算型属性添加属性观察器。这些属性的值是不可以被设置的，所以，为它们提供<code>willSet</code>或<code>didSet</code>实现是不恰当。<br>此外还要注意，你不可以同时提供重写的 setter 和重写的属性观察器。如果你想观察属性值的变化，并且你已经为那个属性提供了定制的 setter，那么你在 setter 中就可以观察到任何值变化了。</p>
</blockquote>
<p>下面的例子定义了一个新类叫<code>AutomaticCar</code>，它是<code>Car</code>的子类。<code>AutomaticCar</code>表示自动挡汽车，它可以根据当前的速度自动选择合适的挡位:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutomaticCar</span>: <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> currentSpeed: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            gear = <span class="type">Int</span>(currentSpeed / <span class="number">10.0</span>) + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你设置<code>AutomaticCar</code>的<code>currentSpeed</code>属性，属性的<code>didSet</code>观察器就会自动地设置<code>gear</code>属性，为新的速度选择一个合适的挡位。具体来说就是，属性观察器将新的速度值除以<code>10</code>，然后向下取得最接近的整数值，最后加<code>1</code>来得到档位<code>gear</code>的值。例如，速度为<code>35.0</code>时，挡位为<code>4</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> automatic = <span class="type">AutomaticCar</span>()</span><br><span class="line">automatic.currentSpeed = <span class="number">35.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"AutomaticCar: <span class="subst">\(automatic.description)</span>"</span>)</span><br><span class="line"><span class="comment">// AutomaticCar: traveling at 35.0 miles per hour in gear 4</span></span><br></pre></td></tr></table></figure>
<p><a name="preventing_overrides"></a></p>
<h2 id="防止重写">防止重写</h2><p>你可以通过把方法，属性或下标脚本标记为<em><code>final</code></em>来防止它们被重写，只需要在声明关键字前加上<code>final</code>修饰符即可（例如：<code>final var</code>，<code>final func</code>，<code>final class func</code>，以及<code>final subscript</code>）。</p>
<p>如果你重写了<code>final</code>方法，属性或下标脚本，在编译时会报错。在类扩展中的方法，属性或下标脚本也可以在扩展的定义里标记为 final 的。</p>
<p>你可以通过在关键字<code>class</code>前添加<code>final</code>修饰符（<code>final class</code>）来将整个类标记为 final 的。这样的类是不可被继承的，试图继承这样的类会导致编译报错。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/14_Initialization/" itemprop="url">
                第二章-14构造过程（Initialization）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:13+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/14_Initialization/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/14_Initialization/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="构造过程（Initialization）">构造过程（Initialization）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/lifedim" target="_blank" rel="external">lifedim</a><br>校对：<a href="https://github.com/lifedim" target="_blank" rel="external">lifedim</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/chenmingbiao" target="_blank" rel="external">chenmingbiao</a></p>
<p>2.1<br>翻译：<a href="https://github.com/Channe" target="_blank" rel="external">Channe</a><br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a>，2015-10-30</p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#setting_initial_values_for_stored_properties">存储属性的初始赋值</a></li>
<li><a href="#customizing_initialization">自定义构造过程</a></li>
<li><a href="#default_initializers">默认构造器</a></li>
<li><a href="#initializer_delegation_for_value_types">值类型的构造器代理</a></li>
<li><a href="#class_inheritance_and_initialization">类的继承和构造过程</a></li>
<li><a href="#failable_initializers">可失败构造器</a></li>
<li><a href="#required_initializers">必要构造器</a></li>
<li><a href="#setting_a_default_property_value_with_a_closure_or_function">通过闭包或函数设置属性的默认值</a></li>
</ul>
<p>构造过程是使用类、结构体或枚举类型的实例之前的准备过程。在新实例可用前必须执行这个过程，具体操作包括设置实例中每个存储型属性的初始值和执行其他必须的设置或初始化工作。</p>
<p>通过定义构造器（<code>Initializers</code>）来实现构造过程，这些构造器可以看做是用来创建特定类型新实例的特殊方法。与 Objective-C 中的构造器不同，Swift 的构造器无需返回值，它们的主要任务是保证新实例在第一次使用前完成正确的初始化。</p>
<p>类的实例也可以通过定义析构器（<code>deinitializer</code>）在实例释放之前执行特定的清除工作。想了解更多关于析构器的内容，请参考<a href="./15_Deinitialization.html">析构过程</a>。</p>
<p><a name="setting_initial_values_for_stored_properties"></a></p>
<h2 id="存储属性的初始赋值">存储属性的初始赋值</h2><p>类和结构体在创建实例时，必须为所有存储型属性设置合适的初始值。存储型属性的值不能处于一个未知的状态。</p>
<p>你可以在构造器中为存储型属性赋初值，也可以在定义属性时为其设置默认值。以下小节将详细介绍这两种方法。</p>
<blockquote>
<p>注意<br>当你为存储型属性设置默认值或者在构造器中为其赋值时，它们的值是被直接设置的，不会触发任何属性观察者（<code>property observers</code>）。</p>
</blockquote>
<p><a name="initializers"></a></p>
<h3 id="构造器">构造器</h3><p>构造器在创建某个特定类型的新实例时被调用。它的最简形式类似于一个不带任何参数的实例方法，以关键字<code>init</code>命名：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>() &#123;</span><br><span class="line">    <span class="comment">// 在此处执行构造过程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面例子中定义了一个用来保存华氏温度的结构体<code>Fahrenheit</code>，它拥有一个<code>Double</code>类型的存储型属性<code>temperature</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fahrenheit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temperature: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        temperature = <span class="number">32.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="type">Fahrenheit</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The default temperature is <span class="subst">\(f.temperature)</span>° Fahrenheit"</span>)</span><br><span class="line"><span class="comment">// 输出 "The default temperature is 32.0° Fahrenheit”</span></span><br></pre></td></tr></table></figure>
<p>这个结构体定义了一个不带参数的构造器<code>init</code>，并在里面将存储型属性<code>temperature</code>的值初始化为<code>32.0</code>（华氏温度下水的冰点）。</p>
<p><a name="default_property_values"></a></p>
<h3 id="默认属性值">默认属性值</h3><p>如前所述，你可以在构造器中为存储型属性设置初始值。同样，你也可以在属性声明时为其设置默认值。</p>
<blockquote>
<p>注意<br>如果一个属性总是使用相同的初始值，那么为其设置一个默认值比每次都在构造器中赋值要好。两种方法的效果是一样的，只不过使用默认值让属性的初始化和声明结合得更紧密。使用默认值能让你的构造器更简洁、更清晰，且能通过默认值自动推导出属性的类型；同时，它也能让你充分利用默认构造器、构造器继承等特性（后续章节将讲到）。</p>
</blockquote>
<p>你可以使用更简单的方式在定义结构体<code>Fahrenheit</code>时为属性<code>temperature</code>设置默认值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fahrenheit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temperature = <span class="number">32.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="customizing_initialization"></a></p>
<h2 id="自定义构造过程">自定义构造过程</h2><p>你可以通过输入参数和可选类型的属性来自定义构造过程，也可以在构造过程中修改常量属性。这些都将在后面章节中提到。</p>
<p><a name="initialization_parameters"></a></p>
<h3 id="构造参数">构造参数</h3><p>自定义<code>构造过程</code>时，可以在定义中提供构造参数，指定所需值的类型和名字。构造参数的功能和语法跟函数和方法的参数相同。</p>
<p>下面例子中定义了一个包含摄氏度温度的结构体<code>Celsius</code>。它定义了两个不同的构造器：<code>init(fromFahrenheit:)</code>和<code>init(fromKelvin:)</code>，二者分别通过接受不同温标下的温度值来创建新的实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Celsius</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temperatureInCelsius: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">init</span>(fromFahrenheit fahrenheit: <span class="type">Double</span>) &#123;</span><br><span class="line">        temperatureInCelsius = (fahrenheit - <span class="number">32.0</span>) / <span class="number">1.8</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(fromKelvin kelvin: <span class="type">Double</span>) &#123;</span><br><span class="line">        temperatureInCelsius = kelvin - <span class="number">273.15</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> boilingPointOfWater = <span class="type">Celsius</span>(fromFahrenheit: <span class="number">212.0</span>)</span><br><span class="line"><span class="comment">// boilingPointOfWater.temperatureInCelsius 是 100.0</span></span><br><span class="line"><span class="keyword">let</span> freezingPointOfWater = <span class="type">Celsius</span>(fromKelvin: <span class="number">273.15</span>)</span><br><span class="line"><span class="comment">// freezingPointOfWater.temperatureInCelsius 是 0.0”</span></span><br></pre></td></tr></table></figure>
<p>第一个构造器拥有一个构造参数，其外部名字为<code>fromFahrenheit</code>，内部名字为<code>fahrenheit</code>；第二个构造器也拥有一个构造参数，其外部名字为<code>fromKelvin</code>，内部名字为<code>kelvin</code>。这两个构造器都将唯一的参数值转换成摄氏温度值，并保存在属性<code>temperatureInCelsius</code>中。</p>
<p><a name="local_and_external_parameter_names"></a></p>
<h3 id="参数的内部名称和外部名称">参数的内部名称和外部名称</h3><p>跟函数和方法参数相同，构造参数也拥有一个在构造器内部使用的参数名字和一个在调用构造器时使用的外部参数名字。</p>
<p>然而，构造器并不像函数和方法那样在括号前有一个可辨别的名字。因此在调用构造器时，主要通过构造器中的参数名和类型来确定应该被调用的构造器。正因为参数如此重要，如果你在定义构造器时没有提供参数的外部名字，Swift 会为每个构造器的参数自动生成一个跟内部名字相同的外部名。</p>
<p>以下例子中定义了一个结构体<code>Color</code>，它包含了三个常量：<code>red</code>、<code>green</code>和<code>blue</code>。这些属性可以存储<code>0.0</code>到<code>1.0</code>之间的值，用来指示颜色中红、绿、蓝成分的含量。</p>
<p><code>Color</code>提供了一个构造器，其中包含三个<code>Double</code>类型的构造参数。<code>Color</code>也可以提供第二个构造器，它只包含名为<code>white</code>的<code>Double</code>类型的参数，它被用于给上述三个构造参数赋予同样的值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> red, green, blue: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">init</span>(red: <span class="type">Double</span>, green: <span class="type">Double</span>, blue: <span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.red   = red</span><br><span class="line">        <span class="keyword">self</span>.green = green</span><br><span class="line">        <span class="keyword">self</span>.blue  = blue</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(white: <span class="type">Double</span>) &#123;</span><br><span class="line">        red   = white</span><br><span class="line">        green = white</span><br><span class="line">        blue  = white</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种构造器都能用于创建一个新的<code>Color</code>实例，你需要为构造器每个外部参数传值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> magenta = <span class="type">Color</span>(red: <span class="number">1.0</span>, green: <span class="number">0.0</span>, blue: <span class="number">1.0</span>)</span><br><span class="line"><span class="keyword">let</span> halfGray = <span class="type">Color</span>(white: <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<p>注意，如果不通过外部参数名字传值，你是没法调用这个构造器的。只要构造器定义了某个外部参数名，你就必须使用它，忽略它将导致编译错误：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> veryGreen = <span class="type">Color</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>)</span><br><span class="line"><span class="comment">// 报编译时错误，需要外部名称</span></span><br></pre></td></tr></table></figure>
<p><a name="initializer_parameters_without_external_names"></a></p>
<h3 id="不带外部名的构造器参数">不带外部名的构造器参数</h3><p>如果你不希望为构造器的某个参数提供外部名字，你可以使用下划线(<code>_</code>)来显式描述它的外部名，以此重写上面所说的默认行为。</p>
<p>下面是之前<code>Celsius</code>例子的扩展，跟之前相比添加了一个带有<code>Double</code>类型参数的构造器，其外部名用<code>_</code>代替：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Celsius</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temperatureInCelsius: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">init</span>(fromFahrenheit fahrenheit: <span class="type">Double</span>) &#123;</span><br><span class="line">        temperatureInCelsius = (fahrenheit - <span class="number">32.0</span>) / <span class="number">1.8</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(fromKelvin kelvin: <span class="type">Double</span>) &#123;</span><br><span class="line">        temperatureInCelsius = kelvin - <span class="number">273.15</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> celsius: <span class="type">Double</span>)&#123;</span><br><span class="line">        temperatureInCelsius = celsius</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bodyTemperature = <span class="type">Celsius</span>(<span class="number">37.0</span>)</span><br><span class="line"><span class="comment">// bodyTemperature.temperatureInCelsius 为 37.0</span></span><br></pre></td></tr></table></figure>
<p>调用<code>Celsius(37.0)</code>意图明确，不需要外部参数名称。因此适合使用<code>init(_ celsius: Double)</code>这样的构造器，从而可以通过提供<code>Double</code>类型的参数值调用构造器，而不需要加上外部名。</p>
<p><a name="optional_property_types"></a></p>
<h3 id="可选属性类型">可选属性类型</h3><p>如果你定制的类型包含一个逻辑上允许取值为空的存储型属性——无论是因为它无法在初始化时赋值，还是因为它在之后某个时间点可以赋值为空——你都需要将它定义为可选类型<code>optional type</code>。可选类型的属性将自动初始化为<code>nil</code>，表示这个属性是有意在初始化时设置为空的。</p>
<p>下面例子中定义了类<code>SurveyQuestion</code>，它包含一个可选字符串属性<code>response</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SurveyQuestion</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> response: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">init</span>(text: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.text = text</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">ask</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(text)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cheeseQuestion = <span class="type">SurveyQuestion</span>(text: <span class="string">"Do you like cheese?"</span>)</span><br><span class="line">cheeseQuestion.ask()</span><br><span class="line"><span class="comment">// 输出 "Do you like cheese?"</span></span><br><span class="line">cheeseQuestion.response = <span class="string">"Yes, I do like cheese."</span></span><br></pre></td></tr></table></figure>
<p>调查问题的答案在回答前是无法确定的，因此我们将属性<code>response</code>声明为<code>String?</code>类型，或者说是可选字符串类型<code>optional String</code>。当<code>SurveyQuestion</code>实例化时，它将自动赋值为<code>nil</code>，表明此字符串暂时还没有值。</p>
<p><a name="assigning_constant_properties_during_initialization"></a></p>
<h3 id="构造过程中常量属性的修改">构造过程中常量属性的修改</h3><p>你可以在构造过程中的任意时间点修改常量属性的值，只要在构造过程结束时是一个确定的值。一旦常量属性被赋值，它将永远不可更改。</p>
<blockquote>
<p>注意<br>对于类的实例来说，它的常量属性只能在定义它的类的构造过程中修改；不能在子类中修改。</p>
</blockquote>
<p>你可以修改上面的<code>SurveyQuestion</code>示例，用常量属性替代变量属性<code>text</code>，表示问题内容<code>text</code>在<code>SurveyQuestion</code>的实例被创建之后不会再被修改。尽管<code>text</code>属性现在是常量，我们仍然可以在类的构造器中设置它的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SurveyQuestion</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> text: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> response: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">init</span>(text: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.text = text</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">ask</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(text)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> beetsQuestion = <span class="type">SurveyQuestion</span>(text: <span class="string">"How about beets?"</span>)</span><br><span class="line">beetsQuestion.ask()</span><br><span class="line"><span class="comment">// 输出 "How about beets?"</span></span><br><span class="line">beetsQuestion.response = <span class="string">"I also like beets. (But not with cheese.)"</span></span><br></pre></td></tr></table></figure>
<p><a name="default_initializers"></a></p>
<h2 id="默认构造器">默认构造器</h2><p>如果结构体或类的所有属性都有默认值，同时没有自定义的构造器，那么 Swift 会给这些结构体或类提供一个默认构造器。这个默认构造器将简单地创建一个所有属性值都设置为默认值的实例。</p>
<p>下面例子中创建了一个类<code>ShoppingListItem</code>，它封装了购物清单中的某一物品的属性：名字（<code>name</code>）、数量（<code>quantity</code>）和购买状态 <code>purchase state</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingListItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> quantity = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> purchased = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> item = <span class="type">ShoppingListItem</span>()</span><br></pre></td></tr></table></figure>
<p>由于<code>ShoppingListItem</code>类中的所有属性都有默认值，且它是没有父类的基类，它将自动获得一个可以为所有属性设置默认值的默认构造器（尽管代码中没有显式为<code>name</code>属性设置默认值，但由于<code>name</code>是可选字符串类型，它将默认设置为<code>nil</code>）。上面例子中使用默认构造器创造了一个<code>ShoppingListItem</code>类的实例（使用<code>ShoppingListItem()</code>形式的构造器语法），并将其赋值给变量<code>item</code>。</p>
<p><a name="memberwise_initializers_for_structure_types"></a></p>
<h3 id="结构体的逐一成员构造器">结构体的逐一成员构造器</h3><p>除了上面提到的默认构造器，如果结构体没有提供自定义的构造器，它们将自动获得一个逐一成员构造器，即使结构体的存储型属性没有默认值。</p>
<p>逐一成员构造器是用来初始化结构体新实例里成员属性的快捷方法。我们在调用逐一成员构造器时，通过与成员属性名相同的参数名进行传值来完成对成员属性的初始赋值。</p>
<p>下面例子中定义了一个结构体<code>Size</code>，它包含两个属性<code>width</code>和<code>height</code>。Swift 可以根据这两个属性的初始赋值<code>0.0</code>自动推导出它们的类型为<code>Double</code>。</p>
<p>由于这两个存储型属性都有默认值，结构体<code>Size</code>自动获得了一个逐一成员构造器<code>init(width:height:)</code>。你可以用它来为<code>Size</code>创建新的实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span>, height = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> twoByTwo = <span class="type">Size</span>(width: <span class="number">2.0</span>, height: <span class="number">2.0</span>)</span><br></pre></td></tr></table></figure>
<p><a name="initializer_delegation_for_value_types"></a></p>
<h2 id="值类型的构造器代理">值类型的构造器代理</h2><p>构造器可以通过调用其它构造器来完成实例的部分构造过程。这一过程称为构造器代理，它能减少多个构造器间的代码重复。</p>
<p>构造器代理的实现规则和形式在值类型和类类型中有所不同。值类型（结构体和枚举类型）不支持继承，所以构造器代理的过程相对简单，因为它们只能代理给提供给它的构造器。类则不同，它可以继承自其它类（请参考<a href="./13_Inheritance.html">继承</a>），这意味着类有责任保证其所有继承的存储型属性在构造时也能正确的初始化。这些责任将在后续章节<a href="#class_inheritance_and_initialization">类的继承和构造过程</a>中介绍。</p>
<p>对于值类型，你可以使用<code>self.init</code>在自定义的构造器中引用类型中的其它构造器。并且你只能在构造器内部调用<code>self.init</code>。</p>
<p>如果你为某个值类型定义了一个自定义的构造器，你将无法访问到默认构造器（如果是结构体，还将无法访问逐一成员构造器）。这个限制可以防止你为值类型定义了一个进行额外必要设置的复杂构造器之后，别人还是错误地使用了一个自动生成的构造器。</p>
<blockquote>
<p>注意<br>假如你希望默认构造器、逐一成员构造器以及你自己的自定义构造器都能用来创建实例，可以将自定义的构造器写到扩展（<code>extension</code>）中，而不是写在值类型的原始定义中。想查看更多内容，请查看<a href="./21_Extensions.html">扩展</a>章节。</p>
</blockquote>
<p>下面例子将定义一个结构体<code>Rect</code>，用来代表几何矩形。这个例子需要两个辅助的结构体<code>Size</code>和<code>Point</code>，它们各自为其所有的属性提供了初始值<code>0.0</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span>, height = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以通过以下三种方式为<code>Rect</code>创建实例——使用被初始化为默认值的<code>origin</code>和<code>size</code>属性来初始化；提供指定的<code>origin</code>和<code>size</code>实例来初始化；提供指定的<code>center</code>和<code>size</code>来初始化。在下面<code>Rect</code>结构体定义中，我们为这三种方式提供了三个自定义的构造器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> origin = <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size = <span class="type">Size</span>()</span><br><span class="line">    <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">init</span>(origin: <span class="type">Point</span>, size: <span class="type">Size</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.origin = origin</span><br><span class="line">        <span class="keyword">self</span>.size = size</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(center: <span class="type">Point</span>, size: <span class="type">Size</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> originX = center.x - (size.width / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">let</span> originY = center.y - (size.height / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(origin: <span class="type">Point</span>(x: originX, y: originY), size: size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个<code>Rect</code>构造器<code>init()</code>，在功能上跟没有自定义构造器时自动获得的默认构造器是一样的。这个构造器是一个空函数，使用一对大括号<code>{}</code>来表示，它没有执行任何构造过程。调用这个构造器将返回一个<code>Rect</code>实例，它的<code>origin</code>和<code>size</code>属性都使用定义时的默认值<code>Point(x: 0.0, y: 0.0)</code>和<code>Size(width: 0.0, height: 0.0)</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> basicRect = <span class="type">Rect</span>()</span><br><span class="line"><span class="comment">// basicRect 的 origin 是 (0.0, 0.0)，size 是 (0.0, 0.0)</span></span><br></pre></td></tr></table></figure>
<p>第二个<code>Rect</code>构造器<code>init(origin:size:)</code>，在功能上跟结构体在没有自定义构造器时获得的逐一成员构造器是一样的。这个构造器只是简单地将<code>origin</code>和<code>size</code>的参数值赋给对应的存储型属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> originRect = <span class="type">Rect</span>(origin: <span class="type">Point</span>(x: <span class="number">2.0</span>, y: <span class="number">2.0</span>),</span><br><span class="line">    size: <span class="type">Size</span>(width: <span class="number">5.0</span>, height: <span class="number">5.0</span>))</span><br><span class="line"><span class="comment">// originRect 的 origin 是 (2.0, 2.0)，size 是 (5.0, 5.0)</span></span><br></pre></td></tr></table></figure>
<p>第三个<code>Rect</code>构造器<code>init(center:size:)</code>稍微复杂一点。它先通过<code>center</code>和<code>size</code>的值计算出<code>origin</code>的坐标，然后再调用（或者说代理给）<code>init(origin:size:)</code>构造器来将新的<code>origin</code>和<code>size</code>值赋值到对应的属性中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> centerRect = <span class="type">Rect</span>(center: <span class="type">Point</span>(x: <span class="number">4.0</span>, y: <span class="number">4.0</span>),</span><br><span class="line">    size: <span class="type">Size</span>(width: <span class="number">3.0</span>, height: <span class="number">3.0</span>))</span><br><span class="line"><span class="comment">// centerRect 的 origin 是 (2.5, 2.5)，size 是 (3.0, 3.0)</span></span><br></pre></td></tr></table></figure>
<p>构造器<code>init(center:size:)</code>可以直接将<code>origin</code>和<code>size</code>的新值赋值到对应的属性中。然而，利用恰好提供了相关功能的现有构造器会更为方便，构造器<code>init(center:size:)</code>的意图也会更加清晰。</p>
<blockquote>
<p>注意<br>如果你想用另外一种不需要自己定义<code>init()</code>和<code>init(origin:size:)</code>的方式来实现这个例子，请参考<a href="./21_Extensions.html">扩展</a>。</p>
</blockquote>
<p><a name="class_inheritance_and_initialization"></a></p>
<h2 id="类的继承和构造过程">类的继承和构造过程</h2><p>类里面的所有存储型属性——包括所有继承自父类的属性——都必须在构造过程中设置初始值。</p>
<p>Swift 为类类型提供了两种构造器来确保实例中所有存储型属性都能获得初始值，它们分别是指定构造器和便利构造器。</p>
<p><a name="designated_initializers_and_convenience_initializers"></a></p>
<h3 id="指定构造器和便利构造器">指定构造器和便利构造器</h3><p><em>指定构造器</em>是类中最主要的构造器。一个指定构造器将初始化类中提供的所有属性，并根据父类链往上调用父类的构造器来实现父类的初始化。</p>
<p>每一个类都必须拥有至少一个指定构造器。在某些情况下，许多类通过继承了父类中的指定构造器而满足了这个条件。具体内容请参考后续章节<a href="#automatic_initializer_inheritance">构造器的自动继承</a>。</p>
<p><em>便利构造器</em>是类中比较次要的、辅助型的构造器。你可以定义便利构造器来调用同一个类中的指定构造器，并为其参数提供默认值。你也可以定义便利构造器来创建一个特殊用途或特定输入值的实例。</p>
<p>你应当只在必要的时候为类提供便利构造器，比方说某种情况下通过使用便利构造器来快捷调用某个指定构造器，能够节省更多开发时间并让类的构造过程更清晰明了。</p>
<p><a name="syntax_for_designated_and_convenience_initializers"></a></p>
<h3 id="指定构造器和便利构造器的语法">指定构造器和便利构造器的语法</h3><p>类的指定构造器的写法跟值类型简单构造器一样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>(parameters) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>便利构造器也采用相同样式的写法，但需要在<code>init</code>关键字之前放置<code>convenience</code>关键字，并使用空格将它们俩分开：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">convenience <span class="keyword">init</span>(parameters) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="initializer_delegation_for_class_types"></a></p>
<h3 id="类的构造器代理规则">类的构造器代理规则</h3><p>为了简化指定构造器和便利构造器之间的调用关系，Swift 采用以下三条规则来限制构造器之间的代理调用：</p>
<h5 id="规则_1">规则 1</h5><p>指定构造器必须调用其直接父类的的指定构造器。</p>
<h5 id="规则_2">规则 2</h5><p>便利构造器必须调用同一类中定义的其它构造器。</p>
<h5 id="规则_3">规则 3</h5><p>便利构造器必须最终导致一个指定构造器被调用。</p>
<p>一个更方便记忆的方法是：</p>
<ul>
<li>指定构造器必须总是向上代理</li>
<li>便利构造器必须总是横向代理</li>
</ul>
<p>这些规则可以通过下面图例来说明：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializerDelegation01_2x.png" alt="构造器代理图"></p>
<p>如图所示，父类中包含一个指定构造器和两个便利构造器。其中一个便利构造器调用了另外一个便利构造器，而后者又调用了唯一的指定构造器。这满足了上面提到的规则 2 和 3。这个父类没有自己的父类，所以规则 1 没有用到。</p>
<p>子类中包含两个指定构造器和一个便利构造器。便利构造器必须调用两个指定构造器中的任意一个，因为它只能调用同一个类里的其他构造器。这满足了上面提到的规则 2 和 3。而两个指定构造器必须调用父类中唯一的指定构造器，这满足了规则 1。</p>
<blockquote>
<p>注意<br>这些规则不会影响类的实例如何创建。任何上图中展示的构造器都可以用来创建完全初始化的实例。这些规则只影响类定义如何实现。</p>
</blockquote>
<p>下面图例中展示了一种涉及四个类的更复杂的类层级结构。它演示了指定构造器是如何在类层级中充当“管道”的作用，在类的构造器链上简化了类之间的相互关系。</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializerDelegation02_2x.png" alt="复杂构造器代理图"></p>
<p><a name="two_phase_initialization"></a></p>
<h3 id="两段式构造过程">两段式构造过程</h3><p>Swift 中类的构造过程包含两个阶段。第一个阶段，每个存储型属性通过引入它们的类的构造器来设置初始值。当每一个存储型属性值被确定后，第二阶段开始，它给每个类一次机会在新实例准备使用之前进一步定制它们的存储型属性。</p>
<p>两段式构造过程的使用让构造过程更安全，同时在整个类层级结构中给予了每个类完全的灵活性。两段式构造过程可以防止属性值在初始化之前被访问，也可以防止属性被另外一个构造器意外地赋予不同的值。</p>
<blockquote>
<p>注意<br>Swift 的两段式构造过程跟 Objective-C 中的构造过程类似。最主要的区别在于阶段 1，Objective-C 给每一个属性赋值<code>0</code>或空值（比如说<code>0</code>或<code>nil</code>）。Swift  的构造流程则更加灵活，它允许你设置定制的初始值，并自如应对某些属性不能以<code>0</code>或<code>nil</code>作为合法默认值的情况。</p>
</blockquote>
<p>Swift 编译器将执行 4 种有效的安全检查，以确保两段式构造过程能顺利完成：</p>
<h5 id="安全检查_1">安全检查 1</h5><p>指定构造器必须保证它所在类引入的所有属性都必须先初始化完成，之后才能将其它构造任务向上代理给父类中的构造器。</p>
<p>如上所述，一个对象的内存只有在其所有存储型属性确定之后才能完全初始化。为了满足这一规则，指定构造器必须保证它所在类引入的属性在它往上代理之前先完成初始化。</p>
<h5 id="安全检查_2">安全检查 2</h5><p>指定构造器必须先向上代理调用父类构造器，然后再为继承的属性设置新值。如果没这么做，指定构造器赋予的新值将被父类中的构造器所覆盖。</p>
<h5 id="安全检查_3">安全检查 3</h5><p>便利构造器必须先代理调用同一类中的其它构造器，然后再为任意属性赋新值。如果没这么做，便利构造器赋予的新值将被同一类中其它指定构造器所覆盖。</p>
<h5 id="安全检查_4">安全检查 4</h5><p>构造器在第一阶段构造完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用<code>self</code>作为一个值。</p>
<p>类实例在第一阶段结束以前并不是完全有效的。只有第一阶段完成后，该实例才会成为有效实例，才能访问属性和调用方法。</p>
<p>以下是两段式构造过程中基于上述安全检查的构造流程展示：</p>
<h5 id="阶段_1">阶段 1</h5><ul>
<li>某个指定构造器或便利构造器被调用。</li>
<li>完成新实例内存的分配，但此时内存还没有被初始化。</li>
<li>指定构造器确保其所在类引入的所有存储型属性都已赋初值。存储型属性所属的内存完成初始化。</li>
<li>指定构造器将调用父类的构造器，完成父类属性的初始化。</li>
<li>这个调用父类构造器的过程沿着构造器链一直往上执行，直到到达构造器链的最顶部。</li>
<li>当到达了构造器链最顶部，且已确保所有实例包含的存储型属性都已经赋值，这个实例的内存被认为已经完全初始化。此时阶段 1 完成。</li>
</ul>
<h5 id="阶段_2">阶段 2</h5><ul>
<li>从顶部构造器链一直往下，每个构造器链中类的指定构造器都有机会进一步定制实例。构造器此时可以访问<code>self</code>、修改它的属性并调用实例方法等等。</li>
<li>最终，任意构造器链中的便利构造器可以有机会定制实例和使用<code>self</code>。</li>
</ul>
<p>下图展示了在假定的子类和父类之间的构造阶段 1：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/twoPhaseInitialization01_2x.png" alt="构建过程阶段1"></p>
<p>在这个例子中，构造过程从对子类中一个便利构造器的调用开始。这个便利构造器此时没法修改任何属性，它把构造任务代理给同一类中的指定构造器。</p>
<p>如安全检查 1 所示，指定构造器将确保所有子类的属性都有值。然后它将调用父类的指定构造器，并沿着构造器链一直往上完成父类的构造过程。</p>
<p>父类中的指定构造器确保所有父类的属性都有值。由于没有更多的父类需要初始化，也就无需继续向上代理。</p>
<p>一旦父类中所有属性都有了初始值，实例的内存被认为是完全初始化，阶段 1 完成。</p>
<p>以下展示了相同构造过程的阶段 2：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/twoPhaseInitialization02_2x.png" alt="构建过程阶段2"></p>
<p>父类中的指定构造器现在有机会进一步来定制实例（尽管这不是必须的）。</p>
<p>一旦父类中的指定构造器完成调用，子类中的指定构造器可以执行更多的定制操作（这也不是必须的）。</p>
<p>最终，一旦子类的指定构造器完成调用，最开始被调用的便利构造器可以执行更多的定制操作。</p>
<p><a name="initializer_inheritance_and_overriding"></a></p>
<h3 id="构造器的继承和重写">构造器的继承和重写</h3><p>跟 Objective-C 中的子类不同，Swift 中的子类默认情况下不会继承父类的构造器。Swift 的这种机制可以防止一个父类的简单构造器被一个更专业的子类继承，并被错误地用来创建子类的实例。</p>
<blockquote>
<p>注意<br>父类的构造器仅会在安全和适当的情况下被继承。具体内容请参考后续章节<a href="#automatic_initializer_inheritance">构造器的自动继承</a>。</p>
</blockquote>
<p>假如你希望自定义的子类中能提供一个或多个跟父类相同的构造器，你可以在子类中提供这些构造器的自定义实现。</p>
<p>当你在编写一个和父类中指定构造器相匹配的子类构造器时，你实际上是在重写父类的这个指定构造器。因此，你必须在定义子类构造器时带上<code>override</code>修饰符。即使你重写的是系统自动提供的默认构造器，也需要带上<code>override</code>修饰符，具体内容请参考<a href="#default_initializers">默认构造器</a>。</p>
<p>正如重写属性，方法或者是下标脚本，<code>override</code>修饰符会让编译器去检查父类中是否有相匹配的指定构造器，并验证构造器参数是否正确。</p>
<blockquote>
<p>注意<br>当你重写一个父类的指定构造器时，你总是需要写<code>override</code>修饰符，即使你的子类将父类的指定构造器重写为了便利构造器。</p>
</blockquote>
<p>相反，如果你编写了一个和父类便利构造器相匹配的子类构造器，由于子类不能直接调用父类的便利构造器（每个规则都在上文<a href="#initializer_delegation_for_class_types">类的构造器代理规则</a>有所描述），因此，严格意义上来讲，你的子类并未对一个父类构造器提供重写。最后的结果就是，你在子类中“重写”一个父类便利构造器时，不需要加<code>override</code>前缀。</p>
<p>在下面的例子中定义了一个叫<code>Vehicle</code>的基类。基类中声明了一个存储型属性<code>numberOfWheels</code>，它是值为<code>0</code>的<code>Int</code>类型的存储型属性。<code>numberOfWheels</code>属性用于创建名为<code>descrpiption</code>的<code>String</code>类型的计算型属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfWheels = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"<span class="subst">\(numberOfWheels)</span> wheel(s)"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Vehicle</code>类只为存储型属性提供默认值，而不自定义构造器。因此，它会自动获得一个默认构造器，具体内容请参考<a href="#default_initializers">默认构造器</a>。自动获得的默认构造器总会是类中的指定构造器，它可以用于创建<code>numberOfWheels</code>为<code>0</code>的<code>Vehicle</code>实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vehicle = <span class="type">Vehicle</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Vehicle: <span class="subst">\(vehicle.description)</span>"</span>)</span><br><span class="line"><span class="comment">// Vehicle: 0 wheel(s)</span></span><br></pre></td></tr></table></figure>
<p>下面例子中定义了一个<code>Vehicle</code>的子类<code>Bicycle</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bicycle</span>: <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        numberOfWheels = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类<code>Bicycle</code>定义了一个自定义指定构造器<code>init()</code>。这个指定构造器和父类的指定构造器相匹配，所以<code>Bicycle</code>中的指定构造器需要带上<code>override</code>修饰符。</p>
<p><code>Bicycle</code>的构造器<code>init()</code>以调用<code>super.init()</code>方法开始，这个方法的作用是调用<code>Bicycle</code>的父类<code>Vehicle</code>的默认构造器。这样可以确保<code>Bicycle</code>在修改属性之前，它所继承的属性<code>numberOfWheels</code>能被<code>Vehicle</code>类初始化。在调用<code>super.init()</code>之后，属性<code>numberOfWheels</code>的原值被新值<code>2</code>替换。</p>
<p>如果你创建一个<code>Bicycle</code>实例，你可以调用继承的<code>description</code>计算型属性去查看属性<code>numberOfWheels</code>是否有改变：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bicycle = <span class="type">Bicycle</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Bicycle: <span class="subst">\(bicycle.description)</span>"</span>)</span><br><span class="line"><span class="comment">// Bicycle: 2 wheel(s)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>子类可以在初始化时修改继承来的变量属性，但是不能修改继承来的常量属性。</p>
</blockquote>
<p><a name="automatic_initializer_inheritance"></a></p>
<h3 id="构造器的自动继承">构造器的自动继承</h3><p>如上所述，子类在默认情况下不会继承父类的构造器。但是如果满足特定条件，父类构造器是可以被自动继承的。在实践中，这意味着对于许多常见场景你不必重写父类的构造器，并且可以在安全的情况下以最小的代价继承父类的构造器。</p>
<p>假设你为子类中引入的所有新属性都提供了默认值，以下 2 个规则适用：</p>
<h5 id="规则_1-1">规则 1</h5><p>如果子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。</p>
<h5 id="规则_2-1">规则 2</h5><p>如果子类提供了所有父类指定构造器的实现——无论是通过规则 1 继承过来的，还是提供了自定义实现——它将自动继承所有父类的便利构造器。（即使属性没有默认值，只要实现了父类的所有指定构造器，就会自动继承父类的所有便利构造器）</p>
<p>即使你在子类中添加了更多的便利构造器，这两条规则仍然适用。</p>
<blockquote>
<p>注意<br>对于规则 2，子类可以将父类的指定构造器实现为便利构造器。</p>
</blockquote>
<p><a name="designated_and_convenience_initializers_in_action"></a></p>
<h3 id="指定构造器和便利构造器实践">指定构造器和便利构造器实践</h3><p>接下来的例子将在实践中展示指定构造器、便利构造器以及构造器的自动继承。这个例子定义了包含三个类<code>Food</code>、<code>RecipeIngredient</code>以及<code>ShoppingListItem</code>的类层次结构，并将演示它们的构造器是如何相互作用的。</p>
<p>类层次中的基类是<code>Food</code>，它是一个简单的用来封装食物名字的类。<code>Food</code>类引入了一个叫做<code>name</code>的<code>String</code>类型的属性，并且提供了两个构造器来创建<code>Food</code>实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    convenience <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name: <span class="string">"[Unnamed]"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图中展示了<code>Food</code>的构造器链：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializersExample01_2x.png" alt="Food构造器链"></p>
<p>类类型没有默认的逐一成员构造器，所以<code>Food</code>类提供了一个接受单一参数<code>name</code>的指定构造器。这个构造器可以使用一个特定的名字来创建新的<code>Food</code>实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> namedMeat = <span class="type">Food</span>(name: <span class="string">"Bacon"</span>)</span><br><span class="line"><span class="comment">// namedMeat 的名字是 "Bacon”</span></span><br></pre></td></tr></table></figure>
<p><code>Food</code>类中的构造器<code>init(name: String)</code>被定义为一个指定构造器，因为它能确保<code>Food</code>实例的所有存储型属性都被初始化。<code>Food</code>类没有父类，所以<code>init(name: String)</code>构造器不需要调用<code>super.init()</code>来完成构造过程。</p>
<p><code>Food</code>类同样提供了一个没有参数的便利构造器<code>init()</code>。这个<code>init()</code>构造器为新食物提供了一个默认的占位名字，通过横向代理到指定构造器<code>init(name: String)</code>并给参数<code>name</code>传值<code>[Unnamed]</code>来实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mysteryMeat = <span class="type">Food</span>()</span><br><span class="line"><span class="comment">// mysteryMeat 的名字是 [Unnamed]</span></span><br></pre></td></tr></table></figure>
<p>类层级中的第二个类是<code>Food</code>的子类<code>RecipeIngredient</code>。<code>RecipeIngredient</code>类构建了食谱中的一味调味剂。它引入了<code>Int</code>类型的属性<code>quantity</code>（以及从<code>Food</code>继承过来的<code>name</code>属性），并且定义了两个构造器来创建<code>RecipeIngredient</code>实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecipeIngredient</span>: <span class="title">Food</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> quantity: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, quantity: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.quantity = quantity</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> convenience <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name: name, quantity: <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图中展示了<code>RecipeIngredient</code>类的构造器链：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializersExample02_2x.png" alt="RecipeIngredient构造器"></p>
<p><code>RecipeIngredient</code>类拥有一个指定构造器<code>init(name: String, quantity: Int)</code>，它可以用来填充<code>RecipeIngredient</code>实例的所有属性值。这个构造器一开始先将传入的<code>quantity</code>参数赋值给<code>quantity</code>属性，这个属性也是唯一在<code>RecipeIngredient</code>中新引入的属性。随后，构造器向上代理到父类<code>Food</code>的<code>init(name: String)</code>。这个过程满足<a href="#two_phase_initialization">两段式构造过程</a>中的安全检查 1。</p>
<p><code>RecipeIngredient</code>还定义了一个便利构造器<code>init(name: String)</code>，它只通过<code>name</code>来创建<code>RecipeIngredient</code>的实例。这个便利构造器假设任意<code>RecipeIngredient</code>实例的<code>quantity</code>为<code>1</code>，所以不需要显式指明数量即可创建出实例。这个便利构造器的定义可以更加方便和快捷地创建实例，并且避免了创建多个<code>quantity</code>为<code>1</code>的<code>RecipeIngredient</code>实例时的代码重复。这个便利构造器只是简单地横向代理到类中的指定构造器，并为<code>quantity</code>参数传递<code>1</code>。</p>
<p>注意，<code>RecipeIngredient</code>的便利构造器<code>init(name: String)</code>使用了跟<code>Food</code>中指定构造器<code>init(name: String)</code>相同的参数。由于这个便利构造器重写了父类的指定构造器<code>init(name: String)</code>，因此必须在前面使用<code>override</code>修饰符（参见<a href="#initializer_inheritance_and_overriding">构造器的继承和重写</a>）。</p>
<p>尽管<code>RecipeIngredient</code>将父类的指定构造器重写为了便利构造器，它依然提供了父类的所有指定构造器的实现。因此，<code>RecipeIngredient</code>会自动继承父类的所有便利构造器。</p>
<p>在这个例子中，<code>RecipeIngredient</code>的父类是<code>Food</code>，它有一个便利构造器<code>init()</code>。这个便利构造器会被<code>RecipeIngredient</code>继承。这个继承版本的<code>init()</code>在功能上跟<code>Food</code>提供的版本是一样的，只是它会代理到<code>RecipeIngredient</code>版本的<code>init(name: String)</code>而不是<code>Food</code>提供的版本。</p>
<p>所有的这三种构造器都可以用来创建新的<code>RecipeIngredient</code>实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oneMysteryItem = <span class="type">RecipeIngredient</span>()</span><br><span class="line"><span class="keyword">let</span> oneBacon = <span class="type">RecipeIngredient</span>(name: <span class="string">"Bacon"</span>)</span><br><span class="line"><span class="keyword">let</span> sixEggs = <span class="type">RecipeIngredient</span>(name: <span class="string">"Eggs"</span>, quantity: <span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>类层级中第三个也是最后一个类是<code>RecipeIngredient</code>的子类，叫做<code>ShoppingListItem</code>。这个类构建了购物单中出现的某一种调味料。</p>
<p>购物单中的每一项总是从未购买状态开始的。为了呈现这一事实，<code>ShoppingListItem</code>引入了一个布尔类型的属性<code>purchased</code>，它的默认值是<code>false</code>。<code>ShoppingListItem</code>还添加了一个计算型属性<code>description</code>，它提供了关于<code>ShoppingListItem</code>实例的一些文字描述：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingListItem</span>: <span class="title">RecipeIngredient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> purchased = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> output = <span class="string">"<span class="subst">\(quantity)</span> x <span class="subst">\(name)</span>"</span></span><br><span class="line">        output += purchased ? <span class="string">" ✔"</span> : <span class="string">" ✘"</span></span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br><code>ShoppingListItem</code>没有定义构造器来为<code>purchased</code>提供初始值，因为添加到购物单的物品的初始状态总是未购买。</p>
</blockquote>
<p>由于它为自己引入的所有属性都提供了默认值，并且自己没有定义任何构造器，<code>ShoppingListItem</code>将自动继承所有父类中的指定构造器和便利构造器。</p>
<p>下图展示了这三个类的构造器链：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializersExample03_2x.png" alt="三类构造器图"></p>
<p>你可以使用全部三个继承来的构造器来创建<code>ShoppingListItem</code>的新实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> breakfastList = [</span><br><span class="line">    <span class="type">ShoppingListItem</span>(),</span><br><span class="line">    <span class="type">ShoppingListItem</span>(name: <span class="string">"Bacon"</span>),</span><br><span class="line">    <span class="type">ShoppingListItem</span>(name: <span class="string">"Eggs"</span>, quantity: <span class="number">6</span>),</span><br><span class="line">]</span><br><span class="line">breakfastList[<span class="number">0</span>].name = <span class="string">"Orange juice"</span></span><br><span class="line">breakfastList[<span class="number">0</span>].purchased = <span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> breakfastList &#123;</span><br><span class="line">    <span class="built_in">print</span>(item.description)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 x orange juice ✔</span></span><br><span class="line"><span class="comment">// 1 x bacon ✘</span></span><br><span class="line"><span class="comment">// 6 x eggs ✘</span></span><br></pre></td></tr></table></figure>
<p>如上所述，例子中通过字面量方式创建了一个数组<code>breakfastList</code>，它包含了三个<code>ShoppingListItem</code>实例，因此数组的类型也能被自动推导为<code>[ShoppingListItem]</code>。在数组创建完之后，数组中第一个<code>ShoppingListItem</code>实例的名字从<code>[Unnamed]</code>更改为<code>Orange juice</code>，并标记为已购买。打印数组中每个元素的描述显示了它们都已按照预期被赋值。</p>
<p><a name="failable_initializers"></a></p>
<h2 id="可失败构造器">可失败构造器</h2><p>如果一个类、结构体或枚举类型的对象，在构造过程中有可能失败，则为其定义一个可失败构造器。这里所指的“失败”是指，如给构造器传入无效的参数值，或缺少某种所需的外部资源，又或是不满足某种必要的条件等。</p>
<p>为了妥善处理这种构造过程中可能会失败的情况。你可以在一个类，结构体或是枚举类型的定义中，添加一个或多个可失败构造器。其语法为在<code>init</code>关键字后面加添问号<code>(init?)</code>。</p>
<blockquote>
<p>注意<br>可失败构造器的参数名和参数类型，不能与其它非可失败构造器的参数名，及其参数类型相同。</p>
</blockquote>
<p>可失败构造器会创建一个类型为自身类型的可选类型的对象。你通过<code>return nil</code>语句来表明可失败构造器在何种情况下应该“失败”。</p>
<blockquote>
<p>注意<br>严格来说，构造器都不支持返回值。因为构造器本身的作用，只是为了确保对象能被正确构造。因此你只是用<code>return nil</code>表明可失败构造器构造失败，而不要用关键字<code>return</code>来表明构造成功。</p>
</blockquote>
<p>下例中，定义了一个名为<code>Animal</code>的结构体，其中有一个名为<code>species</code>的<code>String</code>类型的常量属性。同时该结构体还定义了一个接受一个名为<code>species</code>的<code>String</code>类型参数的可失败构造器。这个可失败构造器检查传入的参数是否为一个空字符串。如果为空字符串，则构造失败。否则，<code>species</code>属性被赋值，构造成功。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> species: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>?(species: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> species.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">self</span>.species = species</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以通过该可失败构造器来构建一个<code>Animal</code>的实例，并检查构造过程是否成功：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someCreature = <span class="type">Animal</span>(species: <span class="string">"Giraffe"</span>)</span><br><span class="line"><span class="comment">// someCreature 的类型是 Animal? 而不是 Animal</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> giraffe = someCreature &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"An animal was initialized with a species of <span class="subst">\(giraffe.species)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "An animal was initialized with a species of Giraffe"</span></span><br></pre></td></tr></table></figure>
<p>如果你给该可失败构造器传入一个空字符串作为其参数，则会导致构造失败：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anonymousCreature = <span class="type">Animal</span>(species: <span class="string">""</span>)</span><br><span class="line"><span class="comment">// anonymousCreature 的类型是 Animal?, 而不是 Animal</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> anonymousCreature == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The anonymous creature could not be initialized"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "The anonymous creature could not be initialized"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>空字符串（如<code>&quot;&quot;</code>，而不是<code>&quot;Giraffe&quot;</code>）和一个值为<code>nil</code>的可选类型的字符串是两个完全不同的概念。上例中的空字符串（<code>&quot;&quot;</code>）其实是一个有效的，非可选类型的字符串。这里我们之所以让<code>Animal</code>的可失败构造器构造失败，只是因为对于<code>Animal</code>这个类的<code>species</code>属性来说，它更适合有一个具体的值，而不是空字符串。</p>
</blockquote>
<p><a name="failable_nitializers_for_enumerations"></a></p>
<h3 id="枚举类型的可失败构造器">枚举类型的可失败构造器</h3><p>你可以通过一个带一个或多个参数的可失败构造器来获取枚举类型中特定的枚举成员。如果提供的参数无法匹配任何枚举成员，则构造失败。</p>
<p>下例中，定义了一个名为<code>TemperatureUnit</code>的枚举类型。其中包含了三个可能的枚举成员(<code>Kelvin</code>，<code>Celsius</code>，和<code>Fahrenheit</code>)，以及一个根据<code>Character</code>值找出所对应的枚举成员的可失败构造器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TemperatureUnit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Kelvin</span>, <span class="type">Celsius</span>, <span class="type">Fahrenheit</span></span><br><span class="line">    <span class="keyword">init</span>?(symbol: <span class="type">Character</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> symbol &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"K"</span>:</span><br><span class="line">            <span class="keyword">self</span> = .<span class="type">Kelvin</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">"C"</span>:</span><br><span class="line">            <span class="keyword">self</span> = .<span class="type">Celsius</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">"F"</span>:</span><br><span class="line">            <span class="keyword">self</span> = .<span class="type">Fahrenheit</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以利用该可失败构造器在三个枚举成员中获取一个相匹配的枚举成员，当参数的值不能与任何枚举成员相匹配时，则构造失败：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fahrenheitUnit = <span class="type">TemperatureUnit</span>(symbol: <span class="string">"F"</span>)</span><br><span class="line"><span class="keyword">if</span> fahrenheitUnit != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"This is a defined temperature unit, so initialization succeeded."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "This is a defined temperature unit, so initialization succeeded."</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> unknownUnit = <span class="type">TemperatureUnit</span>(symbol: <span class="string">"X"</span>)</span><br><span class="line"><span class="keyword">if</span> unknownUnit == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"This is not a defined temperature unit, so initialization failed."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "This is not a defined temperature unit, so initialization failed."</span></span><br></pre></td></tr></table></figure>
<p><a name="failable_initializers_for_enumerations_with_raw_values"></a></p>
<h3 id="带原始值的枚举类型的可失败构造器">带原始值的枚举类型的可失败构造器</h3><p>带原始值的枚举类型会自带一个可失败构造器<code>init?(rawValue:)</code>，该可失败构造器有一个名为<code>rawValue</code>的参数，其类型和枚举类型的原始值类型一致，如果该参数的值能够和某个枚举成员的原始值匹配，则该构造器会构造相应的枚举成员，否则构造失败。</p>
<p>因此上面的<code>TemperatureUnit</code>的例子可以重写为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TemperatureUnit</span>: <span class="title">Character</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Kelvin</span> = <span class="string">"K"</span>, <span class="type">Celsius</span> = <span class="string">"C"</span>, <span class="type">Fahrenheit</span> = <span class="string">"F"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fahrenheitUnit = <span class="type">TemperatureUnit</span>(rawValue: <span class="string">"F"</span>)</span><br><span class="line"><span class="keyword">if</span> fahrenheitUnit != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"This is a defined temperature unit, so initialization succeeded."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "This is a defined temperature unit, so initialization succeeded."</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> unknownUnit = <span class="type">TemperatureUnit</span>(rawValue: <span class="string">"X"</span>)</span><br><span class="line"><span class="keyword">if</span> unknownUnit == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"This is not a defined temperature unit, so initialization failed."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "This is not a defined temperature unit, so initialization failed."</span></span><br></pre></td></tr></table></figure>
<p><a name="failable_initializers_for_classes"></a></p>
<h3 id="类的可失败构造器">类的可失败构造器</h3><p>值类型（也就是结构体或枚举）的可失败构造器，可以在构造过程中的任意时间点触发构造失败。比如在前面的例子中，结构体<code>Animal</code>的可失败构造器在构造过程一开始就触发了构造失败，甚至在<code>species</code>属性被初始化前。</p>
<p>而对类而言，可失败构造器只能在类引入的所有存储型属性被初始化后，以及构造器代理调用完成后，才能触发构造失败。</p>
<p>下面例子展示了如何在类的可失败构造器中使用隐式解包可选类型来满足上述要求：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span>!</span><br><span class="line">    <span class="keyword">init</span>?(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">if</span> name.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面定义的<code>Product</code>类和之前的<code>Animal</code>结构体很相似。<code>Product</code>类有一个不能为空字符串的常量属性<code>name</code>。为了强制这个要求，<code>Product</code>类使用了可失败构造器确保这个属性的值不是空字符串后，才允许构造成功。</p>
<p>毕竟，<code>Product</code>是一个类而不是结构体，这意味着不同于<code>Animal</code>，<code>Product</code>类的所有可失败构造器必须给<code>name</code>属性一个初始值，然后才能触发构造失败。</p>
<p>上面的例子中，<code>Product</code>类的<code>name</code>属性被定义为隐式解包可选字符串类型（<code>String!</code>）。因为它是一个可选类型，所以它在构造过程中被赋值前，具有默认值<code>nil</code>。这个默认值<code>nil</code>意味着<code>Product</code>类引入的所有存储型属性都有一个有效的初始值。因此，一旦传入一个空字符串，该可失败构造器可以在<code>name</code>属性被赋值前触发构造失败。</p>
<blockquote>
<p>译者注<br>上面的示例代码和描述并不相符，根据描述，<code>if name.isEmpty { return nil }</code>这句代码应该在<code>self.name = name</code>之前，而这却会导致编译错误<code>error: all stored properties of a class instance must be initialized before returning nil from an initializer</code>，除非将<code>let name: String!</code>改为<code>var name: String!</code>。</p>
</blockquote>
<p>因为<code>name</code>属性是一个常量，所以一旦构造成功，<code>name</code>属性肯定有一个非<code>nil</code>的值。即使它被定义为隐式解包可选类型，也完全可以放心大胆地直接访问，而不用检查<code>name</code>属性的值是否为<code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> bowTie = <span class="type">Product</span>(name: <span class="string">"bow tie"</span>) &#123;</span><br><span class="line">    <span class="comment">// 不需要检查 bowTie.name 是否为 nil</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The product's name is <span class="subst">\(bowTie.name)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "The product's name is bow tie"</span></span><br></pre></td></tr></table></figure>
<p><a name="propagation_of_initialization_failure"></a></p>
<h3 id="构造失败的传递">构造失败的传递</h3><p>类，结构体，枚举的可失败构造器可以横向代理到类型中的其他可失败构造器。类似的，子类的可失败构造器也能向上代理到父类的可失败构造器。</p>
<p>无论是向上代理还是横向代理，如果你代理到的其他可失败构造器触发构造失败，整个构造过程将立即终止，接下来的任何构造代码不会再被执行。</p>
<blockquote>
<p>注意<br>可失败构造器也可以代理到其它的非可失败构造器。通过这种方式，你可以增加一个可能的失败状态到现有的构造过程中。</p>
</blockquote>
<p>下面这个例子，定义了一个名为<code>CartItem</code>的<code>Product</code>类的子类。这个类建立了一个在线购物车中的物品的模型，它有一个名为<code>quantity</code>的常量存储型属性，并确保该属性的值至少为<code>1</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CartItem</span>: <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> quantity: <span class="type">Int</span>!</span><br><span class="line">    <span class="keyword">init</span>?(name: <span class="type">String</span>, quantity: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.quantity = quantity</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">        <span class="keyword">if</span> quantity &lt; <span class="number">1</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和<code>Product</code>类中的<code>name</code>属性类似，<code>CartItem</code>类中的<code>quantity</code>属性也是隐式解包可选类型。这意味着在构造过程中，该属性在被赋予特定的值之前能有一个默认的初始值<code>nil</code>。</p>
<p>该可失败构造器以向上代理到父类的可失败构造器<code>init(name:)</code>开始。这满足了可失败构造器在触发构造失败前必须总是完成构造器代理调用这个条件。</p>
<p>如果由于<code>name</code>的值为空字符串而导致父类的可失败构造器构造失败，则<code>CartIem</code>类的整个构造过程都将立即失败，之后的构造代码将不会再被执行。如果父类构造成功，<code>CartIem</code>的可失败构造器会进一步验证<code>quantity</code>的值是否不小于<code>1</code>。</p>
<blockquote>
<p>译者注<br>上面的示例代码和描述也不相符，根据描述，<code>self.quantity = quantity</code>这句代码应该放在最后一行，而这却会导致编译错误<code>error: property &#39;self.quantity&#39; not initialized at super.init call</code>，除非将<code>let quantity: Int!</code>改为<code>var quantity: Int!</code>。</p>
</blockquote>
<p>如果你构造一个<code>name</code>的值为非空字符串，<code>quantity</code>的值不小于<code>1</code>的<code>CartItem</code>实例，则可成功构造：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> twoSocks = <span class="type">CartItem</span>(name: <span class="string">"sock"</span>, quantity: <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Item: <span class="subst">\(twoSocks.name)</span>, quantity: <span class="subst">\(twoSocks.quantity)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "Item: sock, quantity: 2"</span></span><br></pre></td></tr></table></figure>
<p>如果你试图构造一个<code>quantity</code>的值为<code>0</code>的<code>CartItem</code>实例, 则<code>CartItem</code>的可失败构造器会触发构造失败：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> zeroShirts = <span class="type">CartItem</span>(name: <span class="string">"shirt"</span>, quantity: <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Item: <span class="subst">\(zeroShirts.name)</span>, quantity: <span class="subst">\(zeroShirts.quantity)</span>"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Unable to initialize zero shirts"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "Unable to initialize zero shirts"</span></span><br></pre></td></tr></table></figure>
<p>类似的，如果你试图构造一个<code>name</code>的值为空字符串的<code>CartItem</code>实例，则父类<code>Product</code>的可失败构造器会触发构造失败：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> oneUnnamed = <span class="type">CartItem</span>(name: <span class="string">""</span>, quantity: <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Item: <span class="subst">\(oneUnnamed.name)</span>, quantity: <span class="subst">\(oneUnnamed.quantity)</span>"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Unable to initialize one unnamed product"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 "Unable to initialize one unnamed product"</span></span><br></pre></td></tr></table></figure>
<p><a name="overriding_a_failable_initializer"></a></p>
<h3 id="重写一个可失败构造器">重写一个可失败构造器</h3><p>如同其它的构造器，你可以在子类中重写父类的可失败构造器。或者你也可以用子类的非可失败构造器重写一个父类的可失败构造器。这使你可以定义一个不会构造失败的子类，即使父类的构造器允许构造失败。</p>
<p>注意，当你用子类的非可失败构造器重写父类的可失败构造器时，向上代理到父类的可失败构造器的唯一方式是对父类的可失败构造器的返回值进行强制解包。</p>
<blockquote>
<p>注意<br>你可以用非可失败构造器重写可失败构造器，但反过来却不行。</p>
</blockquote>
<p>下例定义了一个名为<code>Document</code>的类，<code>name</code>属性的值必须为一个非空字符串或<code>nil</code>，但不能是一个空字符串：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Document</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">    <span class="comment">// 该构造器创建了一个 name 属性的值为 nil 的 document 实例</span></span><br><span class="line">    <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">    <span class="comment">// 该构造器创建了一个 name 属性的值为非空字符串的 document 实例</span></span><br><span class="line">    <span class="keyword">init</span>?(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">if</span> name.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面这个例子，定义了一个<code>Document</code>类的子类<code>AutomaticallyNamedDocument</code>。这个子类重写了父类的两个指定构造器，确保了无论是使用<code>init()</code>构造器，还是使用<code>init(name:)</code>构造器并为参数传递空字符串，生成的实例中的<code>name</code>属性总有初始<code>&quot;[Untitled]&quot;</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutomaticallyNamedDocument</span>: <span class="title">Document</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">self</span>.name = <span class="string">"[Untitled]"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">if</span> name.isEmpty &#123;</span><br><span class="line">            <span class="keyword">self</span>.name = <span class="string">"[Untitled]"</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.name = name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AutomaticallyNamedDocument</code>用一个非可失败构造器<code>init(name:)</code>重写了父类的可失败构造器<code>init?(name:)</code>。因为子类用另一种方式处理了空字符串的情况，所以不再需要一个可失败构造器，因此子类用一个非可失败构造器代替了父类的可失败构造器。</p>
<p>你可以在子类的非可失败构造器中使用强制解包来调用父类的可失败构造器。比如，下面的<code>UntitledDocument</code>子类的<code>name</code>属性的值总是<code>&quot;[Untitled]&quot;</code>，它在构造过程中使用了父类的可失败构造器<code>init?(name:)</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UntitledDocument</span>: <span class="title">Document</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: <span class="string">"[Untitled]"</span>)!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，如果在调用父类的可失败构造器<code>init?(name:)</code>时传入的是空字符串，那么强制解包操作会引发运行时错误。不过，因为这里是通过非空的字符串常量来调用它，所以并不会发生运行时错误。</p>
<p><a name="the_init!_failable_initializer"></a></p>
<h3 id="可失败构造器_init!">可失败构造器 init!</h3><p>通常来说我们通过在<code>init</code>关键字后添加问号的方式（<code>init?</code>）来定义一个可失败构造器，但你也可以通过在<code>init</code>后面添加惊叹号的方式来定义一个可失败构造器（<code>(init!)</code>），该可失败构造器将会构建一个对应类型的隐式解包可选类型的对象。</p>
<p>你可以在<code>init?</code>中代理到<code>init!</code>，反之亦然。你也可以用<code>init?</code>重写<code>init!</code>，反之亦然。你还可以用<code>init</code>代理到<code>init!</code>，不过，一旦<code>init!</code>构造失败，则会触发一个断言。</p>
<p><a name="required_initializers"></a></p>
<h2 id="必要构造器">必要构造器</h2><p>在类的构造器前添加<code>required</code>修饰符表明所有该类的子类都必须实现该构造器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    required <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 构造器的实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在子类重写父类的必要构造器时，必须在子类的构造器前也添加<code>required</code>修饰符，表明该构造器要求也应用于继承链后面的子类。在重写父类中必要的指定构造器时，不需要添加<code>override</code>修饰符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeSubclass</span>: <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    required <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 构造器的实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>如果子类继承的构造器能满足必要构造器的要求，则无须在子类中显式提供必要构造器的实现。</p>
</blockquote>
<p><a name="setting_a_default_property_value_with_a_closure_or_function"></a></p>
<h2 id="通过闭包或函数设置属性的默认值">通过闭包或函数设置属性的默认值</h2><p>如果某个存储型属性的默认值需要一些定制或设置，你可以使用闭包或全局函数为其提供定制的默认值。每当某个属性所在类型的新实例被创建时，对应的闭包或函数会被调用，而它们的返回值会当做默认值赋值给这个属性。</p>
<p>这种类型的闭包或函数通常会创建一个跟属性类型相同的临时变量，然后修改它的值以满足预期的初始状态，最后返回这个临时变量，作为属性的默认值。</p>
<p>下面介绍了如何用闭包为属性提供默认值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> someProperty: <span class="type">SomeType</span> = &#123;</span><br><span class="line">        <span class="comment">// 在这个闭包中给 someProperty 创建一个默认值</span></span><br><span class="line">        <span class="comment">// someValue 必须和 SomeType 类型相同</span></span><br><span class="line">        <span class="keyword">return</span> someValue</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意闭包结尾的大括号后面接了一对空的小括号。这用来告诉 Swift 立即执行此闭包。如果你忽略了这对括号，相当于将闭包本身作为值赋值给了属性，而不是将闭包的返回值赋值给属性。</p>
<blockquote>
<p>注意<br>如果你使用闭包来初始化属性，请记住在闭包执行时，实例的其它部分都还没有初始化。这意味着你不能在闭包里访问其它属性，即使这些属性有默认值。同样，你也不能使用隐式的<code>self</code>属性，或者调用任何实例方法。</p>
</blockquote>
<p>下面例子中定义了一个结构体<code>Checkerboard</code>，它构建了西洋跳棋游戏的棋盘：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/checkersBoard_2x.png" alt="西洋跳棋棋盘"></p>
<p>西洋跳棋游戏在一副黑白格交替的<code>10x10</code>的棋盘中进行。为了呈现这副游戏棋盘，<code>Checkerboard</code>结构体定义了一个属性<code>boardColors</code>，它是一个包含<code>100</code>个<code>Bool</code>值的数组。在数组中，值为<code>true</code>的元素表示一个黑格，值为<code>false</code>的元素表示一个白格。数组中第一个元素代表棋盘上左上角的格子，最后一个元素代表棋盘上右下角的格子。</p>
<p><code>boardColor</code>数组是通过一个闭包来初始化并设置颜色值的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Checkerboard</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> boardColors: [<span class="type">Bool</span>] = &#123;</span><br><span class="line">        <span class="keyword">var</span> temporaryBoard = [<span class="type">Bool</span>]()</span><br><span class="line">        <span class="keyword">var</span> isBlack = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> &#123;</span><br><span class="line">                temporaryBoard.append(isBlack)</span><br><span class="line">                isBlack = !isBlack</span><br><span class="line">            &#125;</span><br><span class="line">            isBlack = !isBlack</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temporaryBoard</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">squareIsBlackAtRow</span><span class="params">(row: Int, column: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> boardColors[(row * <span class="number">10</span>) + column]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每当一个新的<code>Checkerboard</code>实例被创建时，赋值闭包会被执行，<code>boardColors</code>的默认值会被计算出来并返回。上面例子中描述的闭包将计算出棋盘中每个格子对应的颜色，并将这些值保存到一个临时数组<code>temporaryBoard</code>中，最后在构建完成时将此数组作为闭包返回值返回。这个返回的数组会保存到<code>boardColors</code>中，并可以通过工具函数<code>squareIsBlackAtRow</code>来查询：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> board = <span class="type">Checkerboard</span>()</span><br><span class="line"><span class="built_in">print</span>(board.squareIsBlackAtRow(<span class="number">0</span>, column: <span class="number">1</span>))</span><br><span class="line"><span class="comment">// 打印 "true"</span></span><br><span class="line"><span class="built_in">print</span>(board.squareIsBlackAtRow(<span class="number">9</span>, column: <span class="number">9</span>))</span><br><span class="line"><span class="comment">// 打印 "false"</span></span><br></pre></td></tr></table></figure>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/15_Deinitialization/" itemprop="url">
                第二章-15析构过程（Deinitialization）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:12+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/15_Deinitialization/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/15_Deinitialization/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="析构过程（Deinitialization）">析构过程（Deinitialization）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/bruce0505" target="_blank" rel="external">bruce0505</a><br>校对：<a href="https://github.com/fd5788" target="_blank" rel="external">fd5788</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/chenmingbiao" target="_blank" rel="external">chenmingbiao</a></p>
<p>2.1<br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a>，2015-10-31</p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#how_deinitialization_works">析构过程原理</a></li>
<li><a href="#deinitializers_in_action">析构器实践</a></li>
</ul>
<p><em>析构器</em>只适用于类类型，当一个类的实例被释放之前，析构器会被立即调用。析构器用关键字<code>deinit</code>来标示，类似于构造器要用<code>init</code>来标示。</p>
<p><a name="how_deinitialization_works"></a></p>
<p>##析构过程原理</p>
<p>Swift 会自动释放不再需要的实例以释放资源。如<a href="./16_Automatic_Reference_Counting.html">自动引用计数</a>章节中所讲述，Swift 通过<code>自动引用计数（ARC）</code>处理实例的内存管理。通常当你的实例被释放时不需要手动地去清理。但是，当使用自己的资源时，你可能需要进行一些额外的清理。例如，如果创建了一个自定义的类来打开一个文件，并写入一些数据，你可能需要在类实例被释放之前手动去关闭该文件。</p>
<p>在类的定义中，每个类最多只能有一个析构器，而且析构器不带任何参数，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">deinit</span> &#123;</span><br><span class="line">    <span class="comment">// 执行析构过程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>析构器是在实例释放发生前被自动调用。你不能主动调用析构器。子类继承了父类的析构器，并且在子类析构器实现的最后，父类的析构器会被自动调用。即使子类没有提供自己的析构器，父类的析构器也同样会被调用。</p>
<p>因为直到实例的析构器被调用后，实例才会被释放，所以析构器可以访问实例的所有属性，并且可以根据那些属性可以修改它的行为（比如查找一个需要被关闭的文件）。</p>
<p><a name="deinitializers_in_action"></a></p>
<p>##析构器实践</p>
<p>这是一个析构器实践的例子。这个例子描述了一个简单的游戏，这里定义了两种新类型，分别是<code>Bank</code>和<code>Player</code>。<code>Bank</code>类管理一种虚拟硬币，确保流通的硬币数量永远不可能超过 10,000。在游戏中有且只能有一个<code>Bank</code>存在，因此<code>Bank</code>用类来实现，并使用静态属性和静态方法来存储和管理其当前状态。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> coinsInBank = <span class="number">10_000</span></span><br><span class="line">    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">vendCoins</span><span class="params">(<span class="keyword">var</span> numberOfCoinsToVend: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        numberOfCoinsToVend = <span class="built_in">min</span>(numberOfCoinsToVend, coinsInBank)</span><br><span class="line">        coinsInBank -= numberOfCoinsToVend</span><br><span class="line">        <span class="keyword">return</span> numberOfCoinsToVend</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">receiveCoins</span><span class="params">(coins: Int)</span></span> &#123;</span><br><span class="line">        coinsInBank += coins</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Bank</code>使用<code>coinsInBank</code>属性来跟踪它当前拥有的硬币数量。<code>Bank</code>还提供了两个方法，<code>vendCoins(_:)</code>和<code>receiveCoins(_:)</code>，分别用来处理硬币的分发和收集。</p>
<p><code>vendCoins(_:)</code>方法在<code>Bank</code>对象分发硬币之前检查是否有足够的硬币。如果硬币不足，<code>Bank</code>对象会返回一个比请求时小的数字（如果<code>Bank</code>对象中没有硬币了就返回<code>0</code>）。<code>vendCoins</code>方法声明<code>numberOfCoinsToVend</code>为一个变量参数，这样就可以在方法体内部修改分发的硬币数量，而不需要定义一个新的变量。<code>vendCoins</code>方法返回一个整型值，表示提供的硬币的实际数量。</p>
<p><code>receiveCoins(_:)</code>方法只是将<code>Bank</code>对象接收到的硬币数目加回硬币存储中。</p>
<p><code>Player</code>类描述了游戏中的一个玩家。每一个玩家在任意时间都有一定数量的硬币存储在他们的钱包中。这通过玩家的<code>coinsInPurse</code>属性来表示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> coinsInPurse: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(coins: <span class="type">Int</span>) &#123;</span><br><span class="line">        coinsInPurse = <span class="type">Bank</span>.vendCoins(coins)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">winCoins</span><span class="params">(coins: Int)</span></span> &#123;</span><br><span class="line">        coinsInPurse += <span class="type">Bank</span>.vendCoins(coins)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="type">Bank</span>.receiveCoins(coinsInPurse)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个<code>Player</code>实例在初始化的过程中，都从<code>Bank</code>对象获取指定数量的硬币。如果没有足够的硬币可用，<code>Player</code>实例可能会收到比指定数量少的硬币.</p>
<p><code>Player</code>类定义了一个<code>winCoins(_:)</code>方法，该方法从<code>Bank</code>对象获取一定数量的硬币，并把它们添加到玩家的钱包。<code>Player</code>类还实现了一个析构器，这个析构器在<code>Player</code>实例释放前被调用。在这里，析构器的作用只是将玩家的所有硬币都返还给<code>Bank</code>对象：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> playerOne: <span class="type">Player</span>? = <span class="type">Player</span>(coins: <span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"A new player has joined the game with <span class="subst">\(playerOne!.coinsInPurse)</span> coins"</span>)</span><br><span class="line"><span class="comment">// 打印 "A new player has joined the game with 100 coins"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"There are now <span class="subst">\(Bank.coinsInBank)</span> coins left in the bank"</span>)</span><br><span class="line"><span class="comment">// 打印 "There are now 9900 coins left in the bank"</span></span><br></pre></td></tr></table></figure>
<p>创建一个<code>Player</code>实例的时候，会向<code>Bank</code>对象请求 100 个硬币，如果有足够的硬币可用的话。这个<code>Player</code>实例存储在一个名为<code>playerOne</code>的可选类型的变量中。这里使用了一个可选类型的变量，因为玩家可以随时离开游戏，设置为可选使你可以追踪玩家当前是否在游戏中。</p>
<p>因为<code>playerOne</code>是可选的，所以访问其<code>coinsInPurse</code>属性来打印钱包中的硬币数量时，使用感叹号（<code>!</code>）来解包：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">playerOne!.winCoins(<span class="number">2_000</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"PlayerOne won 2000 coins &amp; now has <span class="subst">\(playerOne!.coinsInPurse)</span> coins"</span>)</span><br><span class="line"><span class="comment">// 输出 "PlayerOne won 2000 coins &amp; now has 2100 coins"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The bank now only has <span class="subst">\(Bank.coinsInBank)</span> coins left"</span>)</span><br><span class="line"><span class="comment">// 输出 "The bank now only has 7900 coins left"</span></span><br></pre></td></tr></table></figure>
<p>这里，玩家已经赢得了 2,000 枚硬币，所以玩家的钱包中现在有 2,100 枚硬币，而<code>Bank</code>对象只剩余 7,900 枚硬币。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">playerOne = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"PlayerOne has left the game"</span>)</span><br><span class="line"><span class="comment">// 打印 "PlayerOne has left the game"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The bank now has <span class="subst">\(Bank.coinsInBank)</span> coins"</span>)</span><br><span class="line"><span class="comment">// 打印 "The bank now has 10000 coins"</span></span><br></pre></td></tr></table></figure>
<p>玩家现在已经离开了游戏。这通过将可选类型的<code>playerOne</code>变量设置为<code>nil</code>来表示，意味着“没有<code>Player</code>实例”。当这一切发生时，<code>playerOne</code>变量对<code>Player</code>实例的引用被破坏了。没有其它属性或者变量引用<code>Player</code>实例，因此该实例会被释放，以便回收内存。在这之前，该实例的析构器被自动调用，玩家的硬币被返还给银行。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/16_Automatic_Reference_Counting/" itemprop="url">
                第二章-16自动引用计数（Automatic Reference Counting）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:11+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/16_Automatic_Reference_Counting/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/16_Automatic_Reference_Counting/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="自动引用计数（Automatic_Reference_Counting）">自动引用计数（Automatic Reference Counting）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/TimothyYe" target="_blank" rel="external">TimothyYe</a><br>校对：<a href="https://github.com/Hawstein" target="_blank" rel="external">Hawstein</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/Channe" target="_blank" rel="external">Channe</a></p>
<p>2.1<br>翻译：<a href="https://github.com/Channe" target="_blank" rel="external">Channe</a><br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a>，2015-10-31</p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#how_arc_works">自动引用计数的工作机制</a></li>
<li><a href="#arc_in_action">自动引用计数实践</a></li>
<li><a href="#strong_reference_cycles_between_class_instances">类实例之间的循环强引用</a></li>
<li><a href="#resolving_strong_reference_cycles_between_class_instances">解决实例之间的循环强引用</a></li>
<li><a href="#strong_reference_cycles_for_closures">闭包引起的循环强引用</a></li>
<li><a href="#resolving_strong_reference_cycles_for_closures">解决闭包引起的循环强引用</a></li>
</ul>
<p>Swift 使用自动引用计数（ARC）机制来跟踪和管理你的应用程序的内存。通常情况下，Swift 内存管理机制会一直起作用，你无须自己来考虑内存的管理。ARC 会在类的实例不再被使用时，自动释放其占用的内存。</p>
<p>然而，在少数情况下，ARC 为了能帮助你管理内存，需要更多的关于你的代码之间关系的信息。本章描述了这些情况，并且为你示范怎样启用 ARC 来管理你的应用程序的内存。</p>
<blockquote>
<p>注意<br>引用计数仅仅应用于类的实例。结构体和枚举类型是值类型，不是引用类型，也不是通过引用的方式存储和传递。</p>
</blockquote>
<p><a name="how_arc_works"></a></p>
<h2 id="自动引用计数的工作机制">自动引用计数的工作机制</h2><p>当你每次创建一个类的新的实例的时候，ARC 会分配一大块内存用来储存实例的信息。内存中会包含实例的类型信息，以及这个实例所有相关属性的值。</p>
<p>此外，当实例不再被使用时，ARC 释放实例所占用的内存，并让释放的内存能挪作他用。这确保了不再被使用的实例，不会一直占用内存空间。</p>
<p>然而，当 ARC 收回和释放了正在被使用中的实例，该实例的属性和方法将不能再被访问和调用。实际上，如果你试图访问这个实例，你的应用程序很可能会崩溃。</p>
<p>为了确保使用中的实例不会被销毁，ARC 会跟踪和计算每一个实例正在被多少属性，常量和变量所引用。哪怕实例的引用数为1，ARC都不会销毁这个实例。</p>
<p>为了使上述成为可能，无论你将实例赋值给属性、常量或变量，它们都会创建此实例的强引用。之所以称之为“强”引用，是因为它会将实例牢牢地保持住，只要强引用还在，实例是不允许被销毁的。</p>
<p><a name="arc_in_action"></a></p>
<h2 id="自动引用计数实践">自动引用计数实践</h2><p>下面的例子展示了自动引用计数的工作机制。例子以一个简单的<code>Person</code>类开始，并定义了一个叫<code>name</code>的常量属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span> is being initialized"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span> is being deinitialized"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Person</code>类有一个构造函数，此构造函数为实例的<code>name</code>属性赋值，并打印一条消息以表明初始化过程生效。<code>Person</code>类也拥有一个析构函数，这个析构函数会在实例被销毁时打印一条消息。</p>
<p>接下来的代码片段定义了三个类型为<code>Person?</code>的变量，用来按照代码片段中的顺序，为新的<code>Person</code>实例建立多个引用。由于这些变量是被定义为可选类型（<code>Person?</code>，而不是<code>Person</code>），它们的值会被自动初始化为<code>nil</code>，目前还不会引用到<code>Person</code>类的实例。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reference1: <span class="type">Person</span>?</span><br><span class="line"><span class="keyword">var</span> reference2: <span class="type">Person</span>?</span><br><span class="line"><span class="keyword">var</span> reference3: <span class="type">Person</span>?</span><br></pre></td></tr></table></figure>
<p>现在你可以创建<code>Person</code>类的新实例，并且将它赋值给三个变量中的一个：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reference1 = <span class="type">Person</span>(name: <span class="string">"John Appleseed"</span>)</span><br><span class="line"><span class="comment">// prints "John Appleseed is being initialized”</span></span><br></pre></td></tr></table></figure>
<p>应当注意到当你调用<code>Person</code>类的构造函数的时候，<code>“John Appleseed is being initialized”</code>会被打印出来。由此可以确定构造函数被执行。</p>
<p>由于<code>Person</code>类的新实例被赋值给了<code>reference1</code>变量，所以<code>reference1</code>到<code>Person</code>类的新实例之间建立了一个强引用。正是因为这一个强引用，ARC 会保证<code>Person</code>实例被保持在内存中不被销毁。</p>
<p>如果你将同一个<code>Person</code>实例也赋值给其他两个变量，该实例又会多出两个强引用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reference2 = reference1</span><br><span class="line">reference3 = reference1</span><br></pre></td></tr></table></figure>
<p>现在这一个<code>Person</code>实例已经有三个强引用了。</p>
<p>如果你通过给其中两个变量赋值<code>nil</code>的方式断开两个强引用（包括最先的那个强引用），只留下一个强引用，<code>Person</code>实例不会被销毁：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reference1 = <span class="literal">nil</span></span><br><span class="line">reference2 = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>在你清楚地表明不再使用这个<code>Person</code>实例时，即第三个也就是最后一个强引用被断开时，ARC 会销毁它：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reference3 = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// 打印 “John Appleseed is being deinitialized”</span></span><br></pre></td></tr></table></figure>
<p><a name="strong_reference_cycles_between_class_instances"></a></p>
<h2 id="类实例之间的循环强引用">类实例之间的循环强引用</h2><p>在上面的例子中，ARC 会跟踪你所新创建的<code>Person</code>实例的引用数量，并且会在<code>Person</code>实例不再被需要时销毁它。</p>
<p>然而，我们可能会写出一个类实例的强引用数永远不能变成<code>0</code>的代码。如果两个类实例互相持有对方的强引用，因而每个实例都让对方一直存在，就是这种情况。这就是所谓的循环强引用。</p>
<p>你可以通过定义类之间的关系为弱引用或无主引用，以替代强引用，从而解决循环强引用的问题。具体的过程在<a href="#resolving_strong_reference_cycles_between_class_instances">解决类实例之间的循环强引用</a>中有描述。不管怎样，在你学习怎样解决循环强引用之前，很有必要了解一下它是怎样产生的。</p>
<p>下面展示了一个不经意产生循环强引用的例子。例子定义了两个类：<code>Person</code>和<code>Apartment</code>，用来建模公寓和它其中的居民：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123; <span class="keyword">self</span>.name = name &#125;</span><br><span class="line">    <span class="keyword">var</span> apartment: <span class="type">Apartment</span>?</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span> is being deinitialized"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apartment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> unit: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(unit: <span class="type">String</span>) &#123; <span class="keyword">self</span>.unit = unit &#125;</span><br><span class="line">    <span class="keyword">var</span> tenant: <span class="type">Person</span>?</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"Apartment <span class="subst">\(unit)</span> is being deinitialized"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一个<code>Person</code>实例有一个类型为<code>String</code>，名字为<code>name</code>的属性，并有一个可选的初始化为<code>nil</code>的<code>apartment</code>属性。<code>apartment</code>属性是可选的，因为一个人并不总是拥有公寓。</p>
<p>类似的，每个<code>Apartment</code>实例有一个叫<code>number</code>，类型为<code>Int</code>的属性，并有一个可选的初始化为<code>nil</code>的<code>tenant</code>属性。<code>tenant</code>属性是可选的，因为一栋公寓并不总是有居民。</p>
<p>这两个类都定义了析构函数，用以在类实例被析构的时候输出信息。这让你能够知晓<code>Person</code>和<code>Apartment</code>的实例是否像预期的那样被销毁。</p>
<p>接下来的代码片段定义了两个可选类型的变量<code>john</code>和<code>unit4A</code>，并分别被设定为下面的<code>Apartment</code>和<code>Person</code>的实例。这两个变量都被初始化为<code>nil</code>，这正是可选的优点：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> john: <span class="type">Person</span>?</span><br><span class="line"><span class="keyword">var</span> unit4A: <span class="type">Apartment</span>?</span><br></pre></td></tr></table></figure>
<p>现在你可以创建特定的<code>Person</code>和<code>Apartment</code>实例并将赋值给<code>john</code>和<code>unit4A</code>变量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">john = <span class="type">Person</span>(name: <span class="string">"John Appleseed"</span>)</span><br><span class="line">unit4A = <span class="type">Apartment</span>(unit: <span class="string">"4A"</span>)</span><br></pre></td></tr></table></figure>
<p>在两个实例被创建和赋值后，下图表现了强引用的关系。变量<code>john</code>现在有一个指向<code>Person</code>实例的强引用，而变量<code>unit4A</code>有一个指向<code>Apartment</code>实例的强引用：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle01_2x.png" alt=""></p>
<p>现在你能够将这两个实例关联在一起，这样人就能有公寓住了，而公寓也有了房客。注意感叹号是用来展开和访问可选变量<code>john</code>和<code>unit4A</code>中的实例，这样实例的属性才能被赋值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">john!.apartment = unit4A</span><br><span class="line">unit4A!.tenant = john</span><br></pre></td></tr></table></figure>
<p>在将两个实例联系在一起之后，强引用的关系如图所示：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle02_2x.png" alt=""></p>
<p>不幸的是，这两个实例关联后会产生一个循环强引用。<code>Person</code>实例现在有了一个指向<code>Apartment</code>实例的强引用，而<code>Apartment</code>实例也有了一个指向<code>Person</code>实例的强引用。因此，当你断开<code>john</code>和<code>unit4A</code>变量所持有的强引用时，引用计数并不会降为<code>0</code>，实例也不会被 ARC 销毁：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">john = <span class="literal">nil</span></span><br><span class="line">unit4A = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>注意，当你把这两个变量设为<code>nil</code>时，没有任何一个析构函数被调用。循环强引用会一直阻止<code>Person</code>和<code>Apartment</code>类实例的销毁，这就在你的应用程序中造成了内存泄漏。</p>
<p>在你将<code>john</code>和<code>unit4A</code>赋值为<code>nil</code>后，强引用关系如下图：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle03_2x.png" alt=""></p>
<p><code>Person</code>和<code>Apartment</code>实例之间的强引用关系保留了下来并且不会被断开。</p>
<p><a name="resolving_strong_reference_cycles_between_class_instances"></a></p>
<h2 id="解决实例之间的循环强引用">解决实例之间的循环强引用</h2><p>Swift 提供了两种办法用来解决你在使用类的属性时所遇到的循环强引用问题：弱引用（weak reference）和无主引用（unowned reference）。</p>
<p>弱引用和无主引用允许循环引用中的一个实例引用另外一个实例而不保持强引用。这样实例能够互相引用而不产生循环强引用。</p>
<p>对于生命周期中会变为<code>nil</code>的实例使用弱引用。相反地，对于初始化赋值后再也不会被赋值为<code>nil</code>的实例，使用无主引用。</p>
<p><a name="weak_references"></a></p>
<h3 id="弱引用">弱引用</h3><p>弱引用不会对其引用的实例保持强引用，因而不会阻止 ARC 销毁被引用的实例。这个特性阻止了引用变为循环强引用。声明属性或者变量时，在前面加上<code>weak</code>关键字表明这是一个弱引用。</p>
<p>在实例的生命周期中，如果某些时候引用没有值，那么弱引用可以避免循环强引用。如果引用总是有值，则可以使用无主引用，在<a href="#unowned_references">无主引用</a>中有描述。在上面<code>Apartment</code>的例子中，一个公寓的生命周期中，有时是没有“居民”的，因此适合使用弱引用来解决循环强引用。</p>
<blockquote>
<p>注意<br>弱引用必须被声明为变量，表明其值能在运行时被修改。弱引用不能被声明为常量。  </p>
</blockquote>
<p>因为弱引用可以没有值，你必须将每一个弱引用声明为可选类型。在 Swift 中，推荐使用可选类型描述可能没有值的类型。</p>
<p>因为弱引用不会保持所引用的实例，即使引用存在，实例也有可能被销毁。因此，ARC 会在引用的实例被销毁后自动将其赋值为<code>nil</code>。你可以像其他可选值一样，检查弱引用的值是否存在，你将永远不会访问已销毁的实例的引用。</p>
<p>下面的例子跟上面<code>Person</code>和<code>Apartment</code>的例子一致，但是有一个重要的区别。这一次，<code>Apartment</code>的<code>tenant</code>属性被声明为弱引用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123; <span class="keyword">self</span>.name = name &#125;</span><br><span class="line">    <span class="keyword">var</span> apartment: <span class="type">Apartment</span>?</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span> is being deinitialized"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apartment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> unit: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(unit: <span class="type">String</span>) &#123; <span class="keyword">self</span>.unit = unit &#125;</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> tenant: <span class="type">Person</span>?</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"Apartment <span class="subst">\(unit)</span> is being deinitialized"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后跟之前一样，建立两个变量（<code>john</code>和<code>unit4A</code>）之间的强引用，并关联两个实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> john: <span class="type">Person</span>?</span><br><span class="line"><span class="keyword">var</span> unit4A: <span class="type">Apartment</span>?</span><br><span class="line"></span><br><span class="line">john = <span class="type">Person</span>(name: <span class="string">"John Appleseed"</span>)</span><br><span class="line">unit4A = <span class="type">Apartment</span>(unit: <span class="string">"4A"</span>)</span><br><span class="line"></span><br><span class="line">john!.apartment = unit4A</span><br><span class="line">unit4A!.tenant = john</span><br></pre></td></tr></table></figure>
<p>现在，两个关联在一起的实例的引用关系如下图所示：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference01_2x.png" alt=""></p>
<p><code>Person</code>实例依然保持对<code>Apartment</code>实例的强引用，但是<code>Apartment</code>实例只持有对<code>Person</code>实例的弱引用。这意味着当你断开<code>john</code>变量所保持的强引用时，再也没有指向<code>Person</code>实例的强引用了：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference02_2x.png" alt=""></p>
<p>由于再也没有指向<code>Person</code>实例的强引用，该实例会被销毁：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">john = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// 打印 “John Appleseed is being deinitialized”</span></span><br></pre></td></tr></table></figure>
<p>唯一剩下的指向<code>Apartment</code>实例的强引用来自于变量<code>unit4A</code>。如果你断开这个强引用，再也没有指向<code>Apartment</code>实例的强引用了：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference03_2x.png" alt=""></p>
<p>由于再也没有指向<code>Apartment</code>实例的强引用，该实例也会被销毁：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unit4A = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// 打印 “Apartment 4A is being deinitialized”</span></span><br></pre></td></tr></table></figure>
<p>上面的两段代码展示了变量<code>john</code>和<code>unit4A</code>在被赋值为<code>nil</code>后，<code>Person</code>实例和<code>Apartment</code>实例的析构函数都打印出“销毁”的信息。这证明了引用循环被打破了。</p>
<blockquote>
<p>注意<br> 在使用垃圾收集的系统里，弱指针有时用来实现简单的缓冲机制，因为没有强引用的对象只会在内存压力触发垃圾收集时才被销毁。但是在 ARC 中，一旦值的最后一个强引用被移除，就会被立即销毁，这导致弱引用并不适合上面的用途。</p>
</blockquote>
<p><a name="unowned_references"></a></p>
<h3 id="无主引用">无主引用</h3><p>和弱引用类似，无主引用不会牢牢保持住引用的实例。和弱引用不同的是，无主引用是永远有值的。因此，无主引用总是被定义为非可选类型（non-optional type）。你可以在声明属性或者变量时，在前面加上关键字<code>unowned</code>表示这是一个无主引用。</p>
<p>由于无主引用是非可选类型，你不需要在使用它的时候将它展开。无主引用总是可以被直接访问。不过 ARC 无法在实例被销毁后将无主引用设为<code>nil</code>，因为非可选类型的变量不允许被赋值为<code>nil</code>。</p>
<blockquote>
<p>注意<br>如果你试图在实例被销毁后，访问该实例的无主引用，会触发运行时错误。使用无主引用，你必须确保引用始终指向一个未销毁的实例。<br>还需要注意的是如果你试图访问实例已经被销毁的无主引用，Swift 确保程序会直接崩溃，而不会发生无法预期的行为。所以你应当避免这样的事情发生。  </p>
</blockquote>
<p>下面的例子定义了两个类，<code>Customer</code>和<code>CreditCard</code>，模拟了银行客户和客户的信用卡。这两个类中，每一个都将另外一个类的实例作为自身的属性。这种关系可能会造成循环强引用。</p>
<p><code>Customer</code>和<code>CreditCard</code>之间的关系与前面弱引用例子中<code>Apartment</code>和<code>Person</code>的关系略微不同。在这个数据模型中，一个客户可能有或者没有信用卡，但是一张信用卡总是关联着一个客户。为了表示这种关系，<code>Customer</code>类有一个可选类型的<code>card</code>属性，但是<code>CreditCard</code>类有一个非可选类型的<code>customer</code>属性。</p>
<p>此外，只能通过将一个<code>number</code>值和<code>customer</code>实例传递给<code>CreditCard</code>构造函数的方式来创建<code>CreditCard</code>实例。这样可以确保当创建<code>CreditCard</code>实例时总是有一个<code>customer</code>实例与之关联。</p>
<p>由于信用卡总是关联着一个客户，因此将<code>customer</code>属性定义为无主引用，用以避免循环强引用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> card: <span class="type">CreditCard</span>?</span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span> is being deinitialized"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditCard</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> number: <span class="type">UInt64</span></span><br><span class="line">    <span class="keyword">unowned</span> <span class="keyword">let</span> customer: <span class="type">Customer</span></span><br><span class="line">    <span class="keyword">init</span>(number: <span class="type">UInt64</span>, customer: <span class="type">Customer</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.number = number</span><br><span class="line">        <span class="keyword">self</span>.customer = customer</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"Card #<span class="subst">\(number)</span> is being deinitialized"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br><code>CreditCard</code>类的<code>number</code>属性被定义为<code>UInt64</code>类型而不是<code>Int</code>类型，以确保<code>number</code>属性的存储量在 32 位和 64 位系统上都能足够容纳 16 位的卡号。</p>
</blockquote>
<p>下面的代码片段定义了一个叫<code>john</code>的可选类型<code>Customer</code>变量，用来保存某个特定客户的引用。由于是可选类型，所以变量被初始化为<code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> john: <span class="type">Customer</span>?</span><br></pre></td></tr></table></figure>
<p>现在你可以创建<code>Customer</code>类的实例，用它初始化<code>CreditCard</code>实例，并将新创建的<code>CreditCard</code>实例赋值为客户的<code>card</code>属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">john = <span class="type">Customer</span>(name: <span class="string">"John Appleseed"</span>)</span><br><span class="line">john!.card = <span class="type">CreditCard</span>(number: <span class="number">1234_5678_9012_3456</span>, customer: john!)</span><br></pre></td></tr></table></figure>
<p>在你关联两个实例后，它们的引用关系如下图所示：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/unownedReference01_2x.png" alt=""></p>
<p><code>Customer</code>实例持有对<code>CreditCard</code>实例的强引用，而<code>CreditCard</code>实例持有对<code>Customer</code>实例的无主引用。</p>
<p>由于<code>customer</code>的无主引用，当你断开<code>john</code>变量持有的强引用时，再也没有指向<code>Customer</code>实例的强引用了：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/unownedReference02_2x.png" alt=""></p>
<p>由于再也没有指向<code>Customer</code>实例的强引用，该实例被销毁了。其后，再也没有指向<code>CreditCard</code>实例的强引用，该实例也随之被销毁了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">john = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// 打印 “John Appleseed is being deinitialized”</span></span><br><span class="line"><span class="comment">// 打印 ”Card #1234567890123456 is being deinitialized”</span></span><br></pre></td></tr></table></figure>
<p>最后的代码展示了在<code>john</code>变量被设为<code>nil</code>后<code>Customer</code>实例和<code>CreditCard</code>实例的构造函数都打印出了“销毁”的信息。</p>
<p><a name="unowned_references_and_implicitly_unwrapped_optional_properties"></a></p>
<p>###无主引用以及隐式解析可选属性</p>
<p>上面弱引用和无主引用的例子涵盖了两种常用的需要打破循环强引用的场景。</p>
<p><code>Person</code>和<code>Apartment</code>的例子展示了两个属性的值都允许为<code>nil</code>，并会潜在的产生循环强引用。这种场景最适合用弱引用来解决。</p>
<p><code>Customer</code>和<code>CreditCard</code>的例子展示了一个属性的值允许为<code>nil</code>，而另一个属性的值不允许为<code>nil</code>，这也可能会产生循环强引用。这种场景最适合通过无主引用来解决。</p>
<p>然而，存在着第三种场景，在这种场景中，两个属性都必须有值，并且初始化完成后永远不会为<code>nil</code>。在这种场景中，需要一个类使用无主属性，而另外一个类使用隐式解析可选属性。</p>
<p>这使两个属性在初始化完成后能被直接访问（不需要可选展开），同时避免了循环引用。这一节将为你展示如何建立这种关系。</p>
<p>下面的例子定义了两个类，<code>Country</code>和<code>City</code>，每个类将另外一个类的实例保存为属性。在这个模型中，每个国家必须有首都，每个城市必须属于一个国家。为了实现这种关系，<code>Country</code>类拥有一个<code>capitalCity</code>属性，而<code>City</code>类有一个<code>country</code>属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Country</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> capitalCity: <span class="type">City</span>!</span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, capitalName: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.capitalCity = <span class="type">City</span>(name: capitalName, country: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">City</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">unowned</span> <span class="keyword">let</span> country: <span class="type">Country</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, country: <span class="type">Country</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.country = country</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了建立两个类的依赖关系，<code>City</code>的构造函数接受一个<code>Country</code>实例作为参数，并且将实例保存到<code>country</code>属性。</p>
<p><code>Country</code>的构造函数调用了<code>City</code>的构造函数。然而，只有<code>Country</code>的实例完全初始化后，<code>Country</code>的构造函数才能把<code>self</code>传给<code>City</code>的构造函数。（在<a href="./14_Initialization.html#two_phase_initialization">两段式构造过程</a>中有具体描述）</p>
<p>为了满足这种需求，通过在类型结尾处加上感叹号（<code>City!</code>）的方式，将<code>Country</code>的<code>capitalCity</code>属性声明为隐式解析可选类型的属性。这意味着像其他可选类型一样，<code>capitalCity</code>属性的默认值为<code>nil</code>，但是不需要展开它的值就能访问它。（在<a href="./01_The_Basics.html#implicityly_unwrapped_optionals">隐式解析可选类型</a>中有描述）</p>
<p>由于<code>capitalCity</code>默认值为<code>nil</code>，一旦<code>Country</code>的实例在构造函数中给<code>name</code>属性赋值后，整个初始化过程就完成了。这意味着一旦<code>name</code>属性被赋值后，<code>Country</code>的构造函数就能引用并传递隐式的<code>self</code>。<code>Country</code>的构造函数在赋值<code>capitalCity</code>时，就能将<code>self</code>作为参数传递给<code>City</code>的构造函数。</p>
<p>以上的意义在于你可以通过一条语句同时创建<code>Country</code>和<code>City</code>的实例，而不产生循环强引用，并且<code>capitalCity</code>的属性能被直接访问，而不需要通过感叹号来展开它的可选值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> country = <span class="type">Country</span>(name: <span class="string">"Canada"</span>, capitalName: <span class="string">"Ottawa"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(country.name)</span>'s capital city is called <span class="subst">\(country.capitalCity.name)</span>"</span>)</span><br><span class="line"><span class="comment">// 打印 “Canada's capital city is called Ottawa”</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，使用隐式解析可选值意味着满足了类的构造函数的两个构造阶段的要求。<code>capitalCity</code>属性在初始化完成后，能像非可选值一样使用和存取，同时还避免了循环强引用。</p>
<p><a name="strong_reference_cycles_for_closures"></a></p>
<p>##闭包引起的循环强引用</p>
<p>前面我们看到了循环强引用是在两个类实例属性互相保持对方的强引用时产生的，还知道了如何用弱引用和无主引用来打破这些循环强引用。</p>
<p>循环强引用还会发生在当你将一个闭包赋值给类实例的某个属性，并且这个闭包体中又使用了这个类实例时。这个闭包体中可能访问了实例的某个属性，例如<code>self.someProperty</code>，或者闭包中调用了实例的某个方法，例如<code>self.someMethod()</code>。这两种情况都导致了闭包“捕获”<code>self</code>，从而产生了循环强引用。</p>
<p>循环强引用的产生，是因为闭包和类相似，都是引用类型。当你把一个闭包赋值给某个属性时，你是将这个闭包的引用赋值给了属性。实质上，这跟之前的问题是一样的——两个强引用让彼此一直有效。但是，和两个类实例不同，这次一个是类实例，另一个是闭包。</p>
<p>Swift 提供了一种优雅的方法来解决这个问题，称之为闭包捕获列表（closuer capture list）。同样的，在学习如何用闭包捕获列表破坏循环强引用之前，先来了解一下这里的循环强引用是如何产生的，这对我们很有帮助。</p>
<p>下面的例子为你展示了当一个闭包引用了<code>self</code>后是如何产生一个循环强引用的。例子中定义了一个叫<code>HTMLElement</code>的类，用一种简单的模型表示 HTML 文档中的一个单独的元素：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> text: <span class="type">String</span>?</span><br><span class="line"></span><br><span class="line">    lazy <span class="keyword">var</span> asHTML: <span class="type">Void</span> -&gt; <span class="type">String</span> = &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> text = <span class="keyword">self</span>.text &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"&lt;<span class="subst">\(<span class="keyword">self</span>.name)</span>&gt;<span class="subst">\(text)</span>&lt;/<span class="subst">\(<span class="keyword">self</span>.name)</span>&gt;"</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"&lt;<span class="subst">\(<span class="keyword">self</span>.name)</span> /&gt;"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, text: <span class="type">String</span>? = <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.text = text</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span> is being deinitialized"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>HTMLElement</code>类定义了一个<code>name</code>属性来表示这个元素的名称，例如代表段落的<code>“p”</code>，或者代表换行的<code>“br”</code>。<code>HTMLElement</code>还定义了一个可选属性<code>text</code>，用来设置 HTML 元素呈现的文本。</p>
<p>除了上面的两个属性，<code>HTMLElement</code>还定义了一个<code>lazy</code>属性<code>asHTML</code>。这个属性引用了一个将<code>name</code>和<code>text</code>组合成 HTML 字符串片段的闭包。该属性是<code>Void -&gt; String</code>类型，或者可以理解为“一个没有参数，返回<code>String</code>的函数”。</p>
<p>默认情况下，闭包赋值给了<code>asHTML</code>属性，这个闭包返回一个代表 HTML 标签的字符串。如果<code>text</code>值存在，该标签就包含可选值<code>text</code>；如果<code>text</code>不存在，该标签就不包含文本。对于段落元素，根据<code>text</code>是<code>“some text”</code>还是<code>nil</code>，闭包会返回<code>&quot;&lt;p&gt;some text&lt;/p&gt;&quot;</code>或者<code>&quot;&lt;p /&gt;&quot;</code>。</p>
<p>可以像实例方法那样去命名、使用<code>asHTML</code>属性。然而，由于<code>asHTML</code>是闭包而不是实例方法，如果你想改变特定 HTML 元素的处理方式的话，可以用自定义的闭包来取代默认值。</p>
<p>例如，可以将一个闭包赋值给<code>asHTML</code>属性，这个闭包能在<code>text</code>属性是<code>nil</code>时使用默认文本，这是为了避免返回一个空的 HTML 标签：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> heading = <span class="type">HTMLElement</span>(name: <span class="string">"h1"</span>)</span><br><span class="line"><span class="keyword">let</span> defaultText = <span class="string">"some default text"</span></span><br><span class="line">heading.asHTML = &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&lt;<span class="subst">\(heading.name)</span>&gt;<span class="subst">\(heading.text ?? defaultText)</span>&lt;/<span class="subst">\(heading.name)</span>&gt;"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(heading.asHTML())</span><br><span class="line"><span class="comment">// 打印 “&lt;h1&gt;some default text&lt;/h1&gt;”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br><code>asHTML</code>声明为<code>lazy</code>属性，因为只有当元素确实需要被处理为 HTML 输出的字符串时，才需要使用<code>asHTML</code>。也就是说，在默认的闭包中可以使用<code>self</code>，因为只有当初始化完成以及<code>self</code>确实存在后，才能访问<code>lazy</code>属性。</p>
</blockquote>
<p><code>HTMLElement</code>类只提供了一个构造函数，通过<code>name</code>和<code>text</code>（如果有的话）参数来初始化一个新元素。该类也定义了一个析构函数，当<code>HTMLElement</code>实例被销毁时，打印一条消息。</p>
<p>下面的代码展示了如何用<code>HTMLElement</code>类创建实例并打印消息：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> paragraph: <span class="type">HTMLElement</span>? = <span class="type">HTMLElement</span>(name: <span class="string">"p"</span>, text: <span class="string">"hello, world"</span>)</span><br><span class="line"><span class="built_in">print</span>(paragraph!.asHTML())</span><br><span class="line"><span class="comment">// 打印 “hello, world”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>上面的<code>paragraph</code>变量定义为可选类型的<code>HTMLElement</code>，因此我们可以赋值<code>nil</code>给它来演示循环强引用。</p>
</blockquote>
<p>不幸的是，上面写的<code>HTMLElement</code>类产生了类实例和作为<code>asHTML</code>默认值的闭包之间的循环强引用。循环强引用如下图所示：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/closureReferenceCycle01_2x.png" alt=""></p>
<p>实例的<code>asHTML</code>属性持有闭包的强引用。但是，闭包在其闭包体内使用了<code>self</code>（引用了<code>self.name</code>和<code>self.text</code>），因此闭包捕获了<code>self</code>，这意味着闭包又反过来持有了<code>HTMLElement</code>实例的强引用。这样两个对象就产生了循环强引用。（更多关于闭包捕获值的信息，请参考<a href="./07_Closures.html#capturing_values">值捕获</a>）。</p>
<blockquote>
<p>注意<br>虽然闭包多次使用了<code>self</code>，它只捕获<code>HTMLElement</code>实例的一个强引用。</p>
</blockquote>
<p>如果设置<code>paragraph</code>变量为<code>nil</code>，打破它持有的<code>HTMLElement</code>实例的强引用，<code>HTMLElement</code>实例和它的闭包都不会被销毁，也是因为循环强引用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paragraph = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>HTMLElement</code>的析构函数中的消息并没有被打印，证明了<code>HTMLElement</code>实例并没有被销毁。</p>
<p><a name="resolving_strong_reference_cycles_for_closures"></a></p>
<p>##解决闭包引起的循环强引用</p>
<p>在定义闭包时同时定义捕获列表作为闭包的一部分，通过这种方式可以解决闭包和类实例之间的循环强引用。捕获列表定义了闭包体内捕获一个或者多个引用类型的规则。跟解决两个类实例间的循环强引用一样，声明每个捕获的引用为弱引用或无主引用，而不是强引用。应当根据代码关系来决定使用弱引用还是无主引用。</p>
<blockquote>
<p>注意<br>Swift 有如下要求：只要在闭包内使用<code>self</code>的成员，就要用<code>self.someProperty</code>或者<code>self.someMethod()</code>（而不只是<code>someProperty</code>或<code>someMethod()</code>）。这提醒你可能会一不小心就捕获了<code>self</code>。</p>
</blockquote>
<p><a name="defining_a_capture_list"></a></p>
<p>###定义捕获列表</p>
<p>捕获列表中的每一项都由一对元素组成，一个元素是<code>weak</code>或<code>unowned</code>关键字，另一个元素是类实例的引用（例如<code>self</code>）或初始化过的变量（如<code>delegate = self.delegate!</code>）。这些项在方括号中用逗号分开。</p>
<p>如果闭包有参数列表和返回类型，把捕获列表放在它们前面：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lazy <span class="keyword">var</span> someClosure: (<span class="type">Int</span>, <span class="type">String</span>) -&gt; <span class="type">String</span> = &#123;</span><br><span class="line">    [<span class="keyword">unowned</span> <span class="keyword">self</span>, <span class="keyword">weak</span> delegate = <span class="keyword">self</span>.delegate!] (index: <span class="type">Int</span>, stringToProcess: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// 这里是闭包的函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果闭包没有指明参数列表或者返回类型，即它们会通过上下文推断，那么可以把捕获列表和关键字<code>in</code>放在闭包最开始的地方：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lazy <span class="keyword">var</span> someClosure: <span class="type">Void</span> -&gt; <span class="type">String</span> = &#123;</span><br><span class="line">    [<span class="keyword">unowned</span> <span class="keyword">self</span>, <span class="keyword">weak</span> delegate = <span class="keyword">self</span>.delegate!] <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// 这里是闭包的函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="weak_and_unowned_references"></a></p>
<p>###弱引用和无主引用</p>
<p>在闭包和捕获的实例总是互相引用并且总是同时销毁时，将闭包内的捕获定义为无主引用。</p>
<p>相反的，在被捕获的引用可能会变为<code>nil</code>时，将闭包内的捕获定义为弱引用。弱引用总是可选类型，并且当引用的实例被销毁后，弱引用的值会自动置为<code>nil</code>。这使我们可以在闭包体内检查它们是否存在。</p>
<blockquote>
<p>注意<br>如果被捕获的引用绝对不会变为<code>nil</code>，应该用无主引用，而不是弱引用。</p>
</blockquote>
<p>前面的<code>HTMLElement</code>例子中，无主引用是正确的解决循环强引用的方法。这样编写<code>HTMLElement</code>类来避免循环强引用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> text: <span class="type">String</span>?</span><br><span class="line"></span><br><span class="line">    lazy <span class="keyword">var</span> asHTML: <span class="type">Void</span> -&gt; <span class="type">String</span> = &#123;</span><br><span class="line">        [<span class="keyword">unowned</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> text = <span class="keyword">self</span>.text &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"&lt;<span class="subst">\(<span class="keyword">self</span>.name)</span>&gt;<span class="subst">\(text)</span>&lt;/<span class="subst">\(<span class="keyword">self</span>.name)</span>&gt;"</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"&lt;<span class="subst">\(<span class="keyword">self</span>.name)</span> /&gt;"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, text: <span class="type">String</span>? = <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.text = text</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span> is being deinitialized"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的<code>HTMLElement</code>实现和之前的实现一致，除了在<code>asHTML</code>闭包中多了一个捕获列表。这里，捕获列表是<code>[unowned self]</code>，表示“将<code>self</code>捕获为无主引用而不是强引用”。</p>
<p>和之前一样，我们可以创建并打印<code>HTMLElement</code>实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> paragraph: <span class="type">HTMLElement</span>? = <span class="type">HTMLElement</span>(name: <span class="string">"p"</span>, text: <span class="string">"hello, world"</span>)</span><br><span class="line"><span class="built_in">print</span>(paragraph!.asHTML())</span><br><span class="line"><span class="comment">// 打印 “&lt;p&gt;hello, world&lt;/p&gt;”</span></span><br></pre></td></tr></table></figure>
<p>使用捕获列表后引用关系如下图所示：</p>
<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/closureReferenceCycle02_2x.png" alt=""></p>
<p>这一次，闭包以无主引用的形式捕获<code>self</code>，并不会持有<code>HTMLElement</code>实例的强引用。如果将<code>paragraph</code>赋值为<code>nil</code>，<code>HTMLElement</code>实例将会被销毁，并能看到它的析构函数打印出的消息：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">paragraph = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// 打印 “p is being deinitialized”</span></span><br></pre></td></tr></table></figure>
<p>你可以查看<a href="../chapter3/04_Expressions.html">捕获列表</a>章节，获取更多关于捕获列表的信息。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/17_Optional_Chaining/" itemprop="url">
                第二章-17可选链式调用（Optional Chaining）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:10+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/17_Optional_Chaining/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/17_Optional_Chaining/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="可选链式调用（Optional_Chaining）">可选链式调用（Optional Chaining）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/Jasonbroker" target="_blank" rel="external">Jasonbroker</a><br>校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>, <a href="https://github.com/stanzhai" target="_blank" rel="external">stanzhai</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/lyojo" target="_blank" rel="external">lyojo</a></p>
<p>2.1<br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a>，2015-10-31</p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#optional_chaining_as_an_alternative_to_forced_unwrapping">使用可选链式调用代替强制展开</a></li>
<li><a href="#defining_model_classes_for_optional_chaining">为可选链式调用定义模型类</a></li>
<li><a href="#accessing_properties_through_optional_chaining">通过可选链式调用访问属性</a></li>
<li><a href="#calling_methods_through_optional_chaining">通过可选链式调用调用方法</a></li>
<li><a href="#accessing_subscripts_through_optional_chaining">通过可选链式调用访问下标</a></li>
<li><a href="#linking_multiple_levels_of_chaining">连接多层可选链式调用</a></li>
<li><a href="#chaining_on_methods_with_optional_return_values">在方法的可选返回值上进行可选链式调用</a></li>
</ul>
<p>可选链式调用（Optional Chaining）是一种可以在当前值可能为<code>nil</code>的可选值上请求和调用属性、方法及下标的方法。如果可选值有值，那么调用就会成功；如果可选值是<code>nil</code>，那么调用将返回<code>nil</code>。多个调用可以连接在一起形成一个调用链，如果其中任何一个节点为<code>nil</code>，整个调用链都会失败，即返回<code>nil</code>。</p>
<blockquote>
<p>注意<br>Swift 的可选链式调用和 Objective-C 中向<code>nil</code>发送消息有些相像，但是 Swift 的可选链式调用可以应用于任意类型，并且能检查调用是否成功。</p>
</blockquote>
<p><a name="optional_chaining_as_an_alternative_to_forced_unwrapping"></a></p>
<h2 id="使用可选链式调用代替强制展开">使用可选链式调用代替强制展开</h2><p>通过在想调用的属性、方法、或下标的可选值（optional value）后面放一个问号（<code>?</code>），可以定义一个可选链。这一点很像在可选值后面放一个叹号（<code>!</code>）来强制展开它的值。它们的主要区别在于当可选值为空时可选链式调用只会调用失败，然而强制展开将会触发运行时错误。</p>
<p>为了反映可选链式调用可以在空值（<code>nil</code>）上调用的事实，不论这个调用的属性、方法及下标返回的值是不是可选值，它的返回结果都是一个可选值。你可以利用这个返回值来判断你的可选链式调用是否调用成功，如果调用有返回值则说明调用成功，返回<code>nil</code>则说明调用失败。</p>
<p>特别地，可选链式调用的返回结果与原本的返回结果具有相同的类型，但是被包装成了一个可选值。例如，使用可选链式调用访问属性，当可选链式调用成功时，如果属性原本的返回结果是<code>Int</code>类型，则会变为<code>Int?</code>类型。</p>
<p>下面几段代码将解释可选链式调用和强制展开的不同。</p>
<p>首先定义两个类<code>Person</code>和<code>Residence</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> residence: <span class="type">Residence</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Residence</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> numberOfRooms = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Residence</code>有一个<code>Int</code>类型的属性<code>numberOfRooms</code>，其默认值为<code>1</code>。<code>Person</code>具有一个可选的<code>residence</code>属性，其类型为<code>Residence?</code>。</p>
<p>如果创建一个新的<code>Person</code>实例，因为它的<code>residence</code>属性是可选的，<code>john</code>属性将初始化为<code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> john = <span class="type">Person</span>()</span><br></pre></td></tr></table></figure>
<p>如果使用叹号（<code>!</code>）强制展开获得这个<code>john</code>的<code>residence</code>属性中的<code>numberOfRooms</code>值，会触发运行时错误，因为这时<code>residence</code>没有可以展开的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> roomCount = john.residence!.numberOfRooms</span><br><span class="line"><span class="comment">// 这会引发运行时错误</span></span><br></pre></td></tr></table></figure>
<p><code>john.residence</code>为非<code>nil</code>值的时候，上面的调用会成功，并且把<code>roomCount</code>设置为<code>Int</code>类型的房间数量。正如上面提到的，当<code>residence</code>为<code>nil</code>的时候上面这段代码会触发运行时错误。</p>
<p>可选链式调用提供了另一种访问<code>numberOfRooms</code>的方式，使用问号（<code>?</code>）来替代原来的叹号（<code>!</code>）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> roomCount = john.residence?.numberOfRooms &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"John's residence has <span class="subst">\(roomCount)</span> room(s)."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Unable to retrieve the number of rooms."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “Unable to retrieve the number of rooms.”</span></span><br></pre></td></tr></table></figure>
<p>在<code>residence</code>后面添加问号之后，Swift 就会在<code>residence</code>不为<code>nil</code>的情况下访问<code>numberOfRooms</code>。</p>
<p>因为访问<code>numberOfRooms</code>有可能失败，可选链式调用会返回<code>Int?</code>类型，或称为“可选的 <code>Int</code>”。如上例所示，当<code>residence</code>为<code>nil</code>的时候，可选的<code>Int</code>将会为<code>nil</code>，表明无法访问<code>numberOfRooms</code>。访问成功时，可选的<code>Int</code>值会通过可选绑定展开，并赋值给非可选类型的<code>roomCount</code>常量。</p>
<p>要注意的是，即使<code>numberOfRooms</code>是非可选的<code>Int</code>时，这一点也成立。只要使用可选链式调用就意味着<code>numberOfRooms</code>会返回一个<code>Int?</code>而不是<code>Int</code>。</p>
<p>可以将一个<code>Residence</code>的实例赋给<code>john.residence</code>，这样它就不再是<code>nil</code>了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">john.residence = <span class="type">Residence</span>()</span><br></pre></td></tr></table></figure>
<p><code>john.residence</code>现在包含一个实际的<code>Residence</code>实例，而不再是<code>nil</code>。如果你试图使用先前的可选链式调用访问<code>numberOfRooms</code>，它现在将返回值为<code>1</code>的<code>Int?</code>类型的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> roomCount = john.residence?.numberOfRooms &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"John's residence has <span class="subst">\(roomCount)</span> room(s)."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Unable to retrieve the number of rooms."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “John's residence has 1 room(s).”</span></span><br></pre></td></tr></table></figure>
<p><a name="defining_model_classes_for_optional_chaining"></a></p>
<h2 id="为可选链式调用定义模型类">为可选链式调用定义模型类</h2><p>通过使用可选链式调用可以调用多层属性、方法和下标。这样可以在复杂的模型中向下访问各种子属性，并且判断能否访问子属性的属性、方法或下标。</p>
<p>下面这段代码定义了四个模型类，这些例子包括多层可选链式调用。为了方便说明，在<code>Person</code>和<code>Residence</code>的基础上增加了<code>Room</code>类和<code>Address</code>类，以及相关的属性、方法以及下标。</p>
<p><code>Person</code>类的定义基本保持不变：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> residence: <span class="type">Residence</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Residence</code>类比之前复杂些，增加了一个名为<code>rooms</code>的变量属性，该属性被初始化为<code>[Room]</code>类型的空数组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Residence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rooms = [<span class="type">Room</span>]()</span><br><span class="line">    <span class="keyword">var</span> numberOfRooms: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rooms.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">Room</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> rooms[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            rooms[i] = newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">printNumberOfRooms</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"The number of rooms is <span class="subst">\(numberOfRooms)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> address: <span class="type">Address</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在<code>Residence</code>有了一个存储<code>Room</code>实例的数组，<code>numberOfRooms</code>属性被实现为计算型属性，而不是存储型属性。<code>numberOfRooms</code>属性简单地返回<code>rooms</code>数组的<code>count</code>属性的值。</p>
<p><code>Residence</code>还提供了访问<code>rooms</code>数组的快捷方式，即提供可读写的下标来访问<code>rooms</code>数组中指定位置的元素。</p>
<p>此外，<code>Residence</code>还提供了<code>printNumberOfRooms()</code>方法，这个方法的作用是打印<code>numberOfRooms</code>的值。</p>
<p>最后，<code>Residence</code>还定义了一个可选属性<code>address</code>，其类型为<code>Address?</code>。<code>Address</code>类的定义在下面会说明。</p>
<p><code>Room</code>类是一个简单类，其实例被存储在<code>rooms</code>数组中。该类只包含一个属性<code>name</code>，以及一个用于将该属性设置为适当的房间名的初始化函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Room</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123; <span class="keyword">self</span>.name = name &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一个类是<code>Address</code>，这个类有三个<code>String?</code>类型的可选属性。<code>buildingName</code>以及<code>buildingNumber</code>属性分别表示某个大厦的名称和号码，第三个属性<code>street</code>表示大厦所在街道的名称：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> buildingName: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> buildingNumber: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> street: <span class="type">String</span>?</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">buildingIdentifier</span><span class="params">()</span></span> -&gt; <span class="type">String</span>? &#123;</span><br><span class="line">        <span class="keyword">if</span> buildingName != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> buildingName</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> buildingNumber != <span class="literal">nil</span> &amp;&amp; street != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"<span class="subst">\(buildingNumber)</span> <span class="subst">\(street)</span>"</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Address</code>类提供了<code>buildingIdentifier()</code>方法，返回值为<code>String?</code>。 如果<code>buildingName</code>有值则返回<code>buildingName</code>。或者，如果<code>buildingNumber</code>和<code>street</code>均有值则返回<code>buildingNumber</code>。否则，返回<code>nil</code>。</p>
<p><a name="accessing_properties_through_optional_chaining"></a></p>
<h2 id="通过可选链式调用访问属性">通过可选链式调用访问属性</h2><p>正如<a href="#optional_chaining_as_an_alternative_to_forced_unwrapping">使用可选链式调用代替强制展开</a>中所述，可以通过可选链式调用在一个可选值上访问它的属性，并判断访问是否成功。</p>
<p>下面的代码创建了一个<code>Person</code>实例，然后像之前一样，尝试访问<code>numberOfRooms</code>属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> john = <span class="type">Person</span>()</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> roomCount = john.residence?.numberOfRooms &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"John's residence has <span class="subst">\(roomCount)</span> room(s)."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Unable to retrieve the number of rooms."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “Unable to retrieve the number of rooms.”</span></span><br></pre></td></tr></table></figure>
<p>因为<code>john.residence</code>为<code>nil</code>，所以这个可选链式调用依旧会像先前一样失败。</p>
<p>还可以通过可选链式调用来设置属性值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someAddress = <span class="type">Address</span>()</span><br><span class="line">someAddress.buildingNumber = <span class="string">"29"</span></span><br><span class="line">someAddress.street = <span class="string">"Acacia Road"</span></span><br><span class="line">john.residence?.address = someAddress</span><br></pre></td></tr></table></figure>
<p>在这个例子中，通过<code>john.residence</code>来设定<code>address</code>属性也会失败，因为<code>john.residence</code>当前为<code>nil</code>。</p>
<p>上面代码中的赋值过程是可选链式调用的一部分，这意味着可选链式调用失败时，等号右侧的代码不会被执行。对于上面的代码来说，很难验证这一点，因为像这样赋值一个常量没有任何副作用。下面的代码完成了同样的事情，但是它使用一个函数来创建<code>Address</code>实例，然后将该实例返回用于赋值。该函数会在返回前打印“Function was called”，这使你能验证等号右侧的代码是否被执行。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">createAddress</span><span class="params">()</span></span> -&gt; <span class="type">Address</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Function was called."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> someAddress = <span class="type">Address</span>()</span><br><span class="line">    someAddress.buildingNumber = <span class="string">"29"</span></span><br><span class="line">    someAddress.street = <span class="string">"Acacia Road"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> someAddress</span><br><span class="line">&#125;</span><br><span class="line">john.residence?.address = createAddress()</span><br></pre></td></tr></table></figure>
<p>没有任何打印消息，可以看出<code>createAddress()</code>函数并未被执行。</p>
<p><a name="calling_methods_through_optional_chaining"></a></p>
<h2 id="通过可选链式调用调用方法">通过可选链式调用调用方法</h2><p>可以通过可选链式调用来调用方法，并判断是否调用成功，即使这个方法没有返回值。</p>
<p><code>Residence</code>类中的<code>printNumberOfRooms()</code>方法打印当前的<code>numberOfRooms</code>值，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">printNumberOfRooms</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The number of rooms is <span class="subst">\(numberOfRooms)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法没有返回值。然而，没有返回值的方法具有隐式的返回类型<code>Void</code>，如<a href="./06_Functions.html#functions_without_return_values">无返回值函数</a>中所述。这意味着没有返回值的方法也会返回<code>()</code>，或者说空的元组。</p>
<p>如果在可选值上通过可选链式调用来调用这个方法，该方法的返回类型会是<code>Void?</code>，而不是<code>Void</code>，因为通过可选链式调用得到的返回值都是可选的。这样我们就可以使用<code>if</code>语句来判断能否成功调用<code>printNumberOfRooms()</code>方法，即使方法本身没有定义返回值。通过判断返回值是否为<code>nil</code>可以判断调用是否成功：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> john.residence?.printNumberOfRooms() != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"It was possible to print the number of rooms."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"It was not possible to print the number of rooms."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “It was not possible to print the number of rooms.”</span></span><br></pre></td></tr></table></figure>
<p>同样的，可以据此判断通过可选链式调用为属性赋值是否成功。在上面的<a href="#accessing_properties_through_optional_chaining">通过可选链式调用访问属性</a>的例子中，我们尝试给<code>john.residence</code>中的<code>address</code>属性赋值，即使<code>residence</code>为<code>nil</code>。通过可选链式调用给属性赋值会返回<code>Void?</code>，通过判断返回值是否为<code>nil</code>就可以知道赋值是否成功：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (john.residence?.address = someAddress) != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"It was possible to set the address."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"It was not possible to set the address."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “It was not possible to set the address.”</span></span><br></pre></td></tr></table></figure>
<p><a name="accessing_subscripts_through_optional_chaining"></a></p>
<h2 id="通过可选链式调用访问下标">通过可选链式调用访问下标</h2><p>通过可选链式调用，我们可以在一个可选值上访问下标，并且判断下标调用是否成功。</p>
<blockquote>
<p>注意<br>通过可选链式调用访问可选值的下标时，应该将问号放在下标方括号的前面而不是后面。可选链式调用的问号一般直接跟在可选表达式的后面。</p>
</blockquote>
<p>下面这个例子用下标访问<code>john.residence</code>属性存储的<code>Residence</code>实例的<code>rooms</code>数组中的第一个房间的名称，因为<code>john.residence</code>为<code>nil</code>，所以下标调用失败了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstRoomName = john.residence?[<span class="number">0</span>].name &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The first room name is <span class="subst">\(firstRoomName)</span>."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Unable to retrieve the first room name."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “Unable to retrieve the first room name.”</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，问号直接放在<code>john.residence</code>的后面，并且在方括号的前面，因为<code>john.residence</code>是可选值。</p>
<p>类似的，可以通过下标，用可选链式调用来赋值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">john.residence?[<span class="number">0</span>] = <span class="type">Room</span>(name: <span class="string">"Bathroom"</span>)</span><br></pre></td></tr></table></figure>
<p>这次赋值同样会失败，因为<code>residence</code>目前是<code>nil</code>。</p>
<p>如果你创建一个<code>Residence</code>实例，并为其<code>rooms</code>数组添加一些<code>Room</code>实例，然后将<code>Residence</code>实例赋值给<code>john.residence</code>，那就可以通过可选链和下标来访问数组中的元素：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> johnsHouse = <span class="type">Residence</span>()</span><br><span class="line">johnsHouse.rooms.append(<span class="type">Room</span>(name: <span class="string">"Living Room"</span>))</span><br><span class="line">johnsHouse.rooms.append(<span class="type">Room</span>(name: <span class="string">"Kitchen"</span>))</span><br><span class="line">john.residence = johnsHouse</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstRoomName = john.residence?[<span class="number">0</span>].name &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"The first room name is <span class="subst">\(firstRoomName)</span>."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Unable to retrieve the first room name."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “The first room name is Living Room.”</span></span><br></pre></td></tr></table></figure>
<p><a name="accessing_subscripts_of_optional_type"></a></p>
<h3 id="访问可选类型的下标">访问可选类型的下标</h3><p>如果下标返回可选类型值，比如 Swift 中<code>Dictionary</code>类型的键的下标，可以在下标的结尾括号后面放一个问号来在其可选返回值上进行可选链式调用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> testScores = [<span class="string">"Dave"</span>: [<span class="number">86</span>, <span class="number">82</span>, <span class="number">84</span>], <span class="string">"Bev"</span>: [<span class="number">79</span>, <span class="number">94</span>, <span class="number">81</span>]]</span><br><span class="line">testScores[<span class="string">"Dave"</span>]?[<span class="number">0</span>] = <span class="number">91</span></span><br><span class="line">testScores[<span class="string">"Bev"</span>]?[<span class="number">0</span>]++</span><br><span class="line">testScores[<span class="string">"Brian"</span>]?[<span class="number">0</span>] = <span class="number">72</span></span><br><span class="line"><span class="comment">// "Dave" 数组现在是 [91, 82, 84]，"Bev" 数组现在是 [80, 94, 81]</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中定义了一个<code>testScores</code>数组，包含了两个键值对，把<code>String</code>类型的键映射到一个<code>Int</code>值的数组。这个例子用可选链式调用把<code>&quot;Dave&quot;</code>数组中第一个元素设为<code>91</code>，把<code>&quot;Bev&quot;</code>数组的第一个元素<code>+1</code>，然后尝试把<code>&quot;Brian&quot;</code>数组中的第一个元素设为<code>72</code>。前两个调用成功，因为<code>testScores</code>字典中包含<code>&quot;Dave&quot;</code>和<code>&quot;Bev&quot;</code>这两个键。但是<code>testScores</code>字典中没有<code>&quot;Brian&quot;</code>这个键，所以第三个调用失败。</p>
<p><a name="linking_multiple_levels_of_chaining"></a></p>
<h2 id="连接多层可选链式调用">连接多层可选链式调用</h2><p>可以通过连接多个可选链式调用在更深的模型层级中访问属性、方法以及下标。然而，多层可选链式调用不会增加返回值的可选层级。</p>
<p>也就是说：</p>
<ul>
<li>如果你访问的值不是可选的，可选链式调用将会返回可选值。</li>
<li>如果你访问的值就是可选的，可选链式调用不会让可选返回值变得“更可选”。</li>
</ul>
<p>因此：</p>
<ul>
<li>通过可选链式调用访问一个<code>Int</code>值，将会返回<code>Int?</code>，无论使用了多少层可选链式调用。</li>
<li>类似的，通过可选链式调用访问<code>Int?</code>值，依旧会返回<code>Int?</code>值，并不会返回<code>Int??</code>。</li>
</ul>
<p>下面的例子尝试访问<code>john</code>中的<code>residence</code>属性中的<code>address</code>属性中的<code>street</code>属性。这里使用了两层可选链式调用，<code>residence</code>以及<code>address</code>都是可选值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> johnsStreet = john.residence?.address?.street &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"John's street name is <span class="subst">\(johnsStreet)</span>."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Unable to retrieve the address."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “Unable to retrieve the address.”</span></span><br></pre></td></tr></table></figure>
<p><code>john.residence</code>现在包含一个有效的<code>Residence</code>实例。然而，<code>john.residence.address</code>的值当前为<code>nil</code>。因此，调用<code>john.residence?.address?.street</code>会失败。</p>
<p>需要注意的是，上面的例子中，<code>street</code>的属性为<code>String?</code>。<code>john.residence?.address?.street</code>的返回值也依然是<code>String?</code>，即使已经使用了两层可选链式调用。</p>
<p>如果为<code>john.residence.address</code>赋值一个<code>Address</code>实例，并且为<code>address</code>中的<code>street</code>属性设置一个有效值，我们就能过通过可选链式调用来访问<code>street</code>属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> johnsAddress = <span class="type">Address</span>()</span><br><span class="line">johnsAddress.buildingName = <span class="string">"The Larches"</span></span><br><span class="line">johnsAddress.street = <span class="string">"Laurel Street"</span></span><br><span class="line">john.residence?.address = johnsAddress</span><br><span class="line">	</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> johnsStreet = john.residence?.address?.street &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"John's street name is <span class="subst">\(johnsStreet)</span>."</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Unable to retrieve the address."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “John's street name is Laurel Street.”</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，因为<code>john.residence</code>包含一个有效的<code>Residence</code>实例，所以对<code>john.residence</code>的<code>address</code>属性赋值将会成功。</p>
<p><a name="chaining_on_methods_with_optional_return_values"></a></p>
<h2 id="在方法的可选返回值上进行可选链式调用">在方法的可选返回值上进行可选链式调用</h2><p>上面的例子展示了如何在一个可选值上通过可选链式调用来获取它的属性值。我们还可以在一个可选值上通过可选链式调用来调用方法，并且可以根据需要继续在方法的可选返回值上进行可选链式调用。</p>
<p>在下面的例子中，通过可选链式调用来调用<code>Address</code>的<code>buildingIdentifier()</code>方法。这个方法返回<code>String?</code>类型的值。如上所述，通过可选链式调用来调用该方法，最终的返回值依旧会是<code>String?</code>类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> buildingIdentifier = john.residence?.address?.buildingIdentifier() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"John's building identifier is <span class="subst">\(buildingIdentifier)</span>."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “John's building identifier is The Larches.”</span></span><br></pre></td></tr></table></figure>
<p>如果要在该方法的返回值上进行可选链式调用，在方法的圆括号后面加上问号即可：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> beginsWithThe =</span><br><span class="line">	john.residence?.address?.buildingIdentifier()?.hasPrefix(<span class="string">"The"</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> beginsWithThe &#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">"John's building identifier begins with \"The\"."</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">"John's building identifier does not begin with \"The\"."</span>)</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “John's building identifier begins with "The".”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>在上面的例子中，在方法的圆括号后面加上问号是因为你要在<code>buildingIdentifier()</code>方法的可选返回值上进行可选链式调用，而不是方法本身。</p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/18_Error_Handling/" itemprop="url">
                第二章-18错误处理（Error Handling）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:09+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/18_Error_Handling/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/18_Error_Handling/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="错误处理（Error_Handling）">错误处理（Error Handling）</h1><hr>
<blockquote>
<p>2.1<br>翻译+校对：<a href="https://github.com/lyojo" target="_blank" rel="external">lyojo</a> <a href="https://github.com/ray16897188" target="_blank" rel="external">ray16897188</a> 2015-10-23<br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a> 2015-10-24</p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#representing_and_throwing_errors">表示并抛出错误</a></li>
<li><a href="#handling_errors">处理错误</a></li>
<li><a href="#specifying_cleanup_actions">指定清理操作</a></li>
</ul>
<p><em>错误处理（Error handling）</em>是响应错误以及从错误中恢复的过程。Swift 提供了在运行时对可恢复错误的抛出、捕获、传递和操作的一流支持。</p>
<p>某些操作无法保证总是执行完所有代码或总是生成有用的结果。可选类型可用来表示值缺失，但是当某个操作失败时，最好能得知失败的原因，从而可以作出相应的应对。</p>
<p>举个例子，假如有个从磁盘上的某个文件读取数据并进行处理的任务，该任务会有多种可能失败的情况，包括指定路径下文件并不存在，文件不具有可读权限，或者文件编码格式不兼容。区分这些不同的失败情况可以让程序解决并处理某些错误，然后把它解决不了的错误报告给用户。</p>
<blockquote>
<p>注意<br>Swift 中的错误处理涉及到错误处理模式，这会用到 Cocoa 和 Objective-C 中的<code>NSError</code>。关于这个类的更多信息请参见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216" target="_blank" rel="external">Using Swift with Cocoa and Objective-C (Swift 2.1)</a> 中的<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/AdoptingCocoaDesignPatterns.html#//apple_ref/doc/uid/TP40014216-CH7-ID10" target="_blank" rel="external">错误处理</a>。</p>
</blockquote>
<p><a name="representing_and_throwing_errors"></a></p>
<p>##表示并抛出错误</p>
<p>在 Swift 中，错误用符合<code>ErrorType</code>协议的类型的值来表示。这个空协议表明该类型可以用于错误处理。</p>
<p>Swift 的枚举类型尤为适合构建一组相关的错误状态，枚举的关联值还可以提供错误状态的额外信息。例如，你可以这样表示在一个游戏中操作自动贩卖机时可能会出现的错误状态：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">VendingMachineError</span>: <span class="title">ErrorType</span> </span>&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">InvalidSelection</span>				     <span class="comment">//选择无效</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">InsufficientFunds</span>(coinsNeeded: <span class="type">Int</span>) <span class="comment">//金额不足</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">OutOfStock</span>			                 <span class="comment">//缺货</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抛出一个错误可以让你表明有意外情况发生，导致正常的执行流程无法继续执行。抛出错误使用<code>throws</code>关键字。例如，下面的代码抛出一个错误，提示贩卖机还需要<code>5</code>个硬币：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw <span class="type">VendingMachineError</span>.<span class="type">InsufficientFunds</span>(coinsNeeded: <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p><a name="handling_errors"></a></p>
<p>##处理错误</p>
<p>某个错误被抛出时，附近的某部分代码必须负责处理这个错误，例如纠正这个问题、尝试另外一种方式、或是向用户报告错误。</p>
<p>Swift 中有<code>4</code>种处理错误的方式。你可以把函数抛出的错误传递给调用此函数的代码、用<code>do-catch</code>语句处理错误、将错误作为可选类型处理、或者断言此错误根本不会发生。每种方式在下面的小节中都有描述。</p>
<p>当一个函数抛出一个错误时，你的程序流程会发生改变，所以重要的是你能迅速识别代码中会抛出错误的地方。为了标识出这些地方，在调用一个能抛出错误的函数、方法或者构造器之前，加上<code>try</code>关键字，或者<code>try?</code>或<code>try!</code>这种变体。这些关键字在下面的小节中有具体讲解。</p>
<blockquote>
<p>注意<br>Swift 中的错误处理和其他语言中用<code>try</code>，<code>catch</code>和<code>throw</code>进行异常处理很像。和其他语言中（包括 Objective-C ）的异常处理不同的是，Swift 中的错误处理并不涉及解除调用栈，这是一个计算代价高昂的过程。就此而言，<code>throw</code>语句的性能特性是可以和<code>return</code>语句相媲美的。</p>
</blockquote>
<p>###用 throwing 函数传递错误</p>
<p>为了表示一个函数、方法或构造器可以抛出错误，在函数声明的参数列表之后加上<code>throws</code>关键字。一个标有<code>throws</code>关键字的函数被称作<em>throwing 函数</em>。如果这个函数指明了返回值类型，<code>throws</code>关键词需要写在箭头（<code>-&gt;</code>）的前面。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">canThrowErrors</span><span class="params">()</span></span> throws -&gt; <span class="type">String</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">cannotThrowErrors</span><span class="params">()</span></span> -&gt; <span class="type">String</span></span><br></pre></td></tr></table></figure>
<p>一个 throwing 函数可以在其内部抛出错误，并将错误传递到函数被调用时的作用域。</p>
<blockquote>
<p>注意<br>只有 throwing 函数可以传递错误。任何在某个非 throwing 函数内部抛出的错误只能在函数内部处理。</p>
</blockquote>
<p>下面的例子中，<code>VendingMechine</code>类有一个<code>vend(itemNamed:)</code>方法，如果请求的物品不存在、缺货或者花费超过了投入金额，该方法就会抛出一个相应的<code>VendingMachineError</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> price: <span class="type">Int</span></span><br><span class="line">	<span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VendingMachine</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> inventory = [</span><br><span class="line">        <span class="string">"Candy Bar"</span>: <span class="type">Item</span>(price: <span class="number">12</span>, <span class="built_in">count</span>: <span class="number">7</span>),</span><br><span class="line">        <span class="string">"Chips"</span>: <span class="type">Item</span>(price: <span class="number">10</span>, <span class="built_in">count</span>: <span class="number">4</span>),</span><br><span class="line">        <span class="string">"Pretzels"</span>: <span class="type">Item</span>(price: <span class="number">7</span>, <span class="built_in">count</span>: <span class="number">11</span>)</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">var</span> coinsDeposited = <span class="number">0</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">dispenseSnack</span><span class="params">(snack: String)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Dispensing <span class="subst">\(snack)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">vend</span><span class="params">(itemNamed name: String)</span></span> throws &#123;</span><br><span class="line">        guard <span class="keyword">var</span> item = inventory[name] <span class="keyword">else</span> &#123;</span><br><span class="line">            throw <span class="type">VendingMachineError</span>.<span class="type">InvalidSelection</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        guard item.<span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            throw <span class="type">VendingMachineError</span>.<span class="type">OutOfStock</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        guard item.price &lt;= coinsDeposited <span class="keyword">else</span> &#123;</span><br><span class="line">            throw <span class="type">VendingMachineError</span>.<span class="type">InsufficientFunds</span>(coinsNeeded: item.price - coinsDeposited)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        coinsDeposited -= item.price</span><br><span class="line">        --item.<span class="built_in">count</span></span><br><span class="line">        inventory[name] = item</span><br><span class="line">        dispenseSnack(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>vend(itemNamed:)</code>方法的实现中使用了<code>guard</code>语句来提前退出方法，确保在购买某个物品所需的条件中，有任一条件不满足时，能提前退出方法并抛出相应的错误。由于<code>throw</code>语句会立即退出方法，所以物品只有在所有条件都满足时才会被售出。</p>
<p>因为<code>vend(itemNamed:)</code>方法会传递出它抛出的任何错误，在你的代码中调用此方法的地方，必须要么直接处理这些错误——使用<code>do-catch</code>语句，<code>try?</code>或<code>try!</code>；要么继续将这些错误传递下去。例如下面例子中，<code>buyFavoriteSnack(_:vendingMachine:)</code>同样是一个 throwing 函数，任何由<code>vend(itemNamed:)</code>方法抛出的错误会一直被传递到<code>buyFavoriteSnack(_:vendingMachine:)</code>函数被调用的地方。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> favoriteSnacks = [</span><br><span class="line">	<span class="string">"Alice"</span>: <span class="string">"Chips"</span>,</span><br><span class="line">	<span class="string">"Bob"</span>: <span class="string">"Licorice"</span>,</span><br><span class="line">	<span class="string">"Eve"</span>: <span class="string">"Pretzels"</span>,</span><br><span class="line">]</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">buyFavoriteSnack</span><span class="params">(person: String, vendingMachine: VendingMachine)</span></span> throws &#123;</span><br><span class="line">	<span class="keyword">let</span> snackName = favoriteSnacks[person] ?? <span class="string">"Candy Bar"</span></span><br><span class="line">	try vendingMachine.vend(itemNamed: snackName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例中，<code>buyFavoriteSnack(_:vendingMachine:)</code>函数会查找某人最喜欢的零食，并通过调用<code>vend(itemNamed:)</code>方法来尝试为他们购买。因为<code>vend(itemNamed:)</code>方法能抛出错误，所以在调用的它时候在它前面加了<code>try</code>关键字。</p>
<p>###用 Do-Catch 处理错误</p>
<p>可以使用一个<code>do-catch</code>语句运行一段闭包代码来处理错误。如果在<code>do</code>子句中的代码抛出了一个错误，这个错误会与<code>catch</code>子句做匹配，从而决定哪条子句能处理它。</p>
<p>下面是<code>do-catch</code>语句的一般形式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    try expression</span><br><span class="line">    statements</span><br><span class="line">&#125; catch pattern <span class="number">1</span> &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; catch pattern <span class="number">2</span> <span class="keyword">where</span> condition &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>catch</code>后面写一个匹配模式来表明这个子句能处理什么样的错误。如果一条<code>catch</code>子句没有指定匹配模式，那么这条子句可以匹配任何错误，并且把错误绑定到一个名字为<code>error</code>的局部常量。关于模式匹配的更多信息请参考 <a href="../chapter3/07_Patterns.html">模式</a>。</p>
<p><code>catch</code>子句不必将<code>do</code>子句中的代码所抛出的每一个可能的错误都作处理。如果所有<code>catch</code>子句都未处理错误，错误就会传递到周围的作用域。然而，错误还是必须要被某个周围的作用域处理的——要么是一个外围的<code>do-catch</code>错误处理语句，要么是一个 throwing 函数的内部。举例来说，下面的代码处理了<code>VendingMachineError</code>枚举类型的全部枚举值，但是所有其它的错误就必须由它周围的作用域处理：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vendingMachine = <span class="type">VendingMachine</span>()</span><br><span class="line">vendingMachine.coinsDeposited = <span class="number">8</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    try buyFavoriteSnack(<span class="string">"Alice"</span>, vendingMachine: vendingMachine)</span><br><span class="line">&#125; catch <span class="type">VendingMachineError</span>.<span class="type">InvalidSelection</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Invalid Selection."</span>)</span><br><span class="line">&#125; catch <span class="type">VendingMachineError</span>.<span class="type">OutOfStock</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Out of Stock."</span>)</span><br><span class="line">&#125; catch <span class="type">VendingMachineError</span>.<span class="type">InsufficientFunds</span>(<span class="keyword">let</span> coinsNeeded) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Insufficient funds. Please insert an additional <span class="subst">\(coinsNeeded)</span> coins."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 “Insufficient funds. Please insert an additional 2 coins.”</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，<code>buyFavoriteSnack(_:vendingMachine:)</code>函数在一个<code>try</code>表达式中调用，因为它能抛出错误。如果错误被抛出，相应的执行会马上转移到<code>catch</code>子句中，并判断这个错误是否要被继续传递下去。如果没有错误抛出，<code>do</code>子句中余下的语句就会被执行。</p>
<p>###将错误转换成可选值</p>
<p>可以使用<code>try?</code>通过将错误转换成一个可选值来处理错误。如果在评估<code>try?</code>表达式时一个错误被抛出，那么表达式的值就是<code>nil</code>。例如下面代码中的<code>x</code>和<code>y</code>具有相同的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">someThrowingFunction</span><span class="params">()</span></span> throws -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> x = try? someThrowingFunction()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> y: <span class="type">Int</span>?</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    y = try someThrowingFunction()</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    y = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>someThrowingFunction()</code>抛出一个错误，<code>x</code>和<code>y</code>的值是<code>nil</code>。否则<code>x</code>和<code>y</code>的值就是该函数的返回值。注意，无论<code>someThrowingFunction()</code>的返回值类型是什么类型，<code>x</code>和<code>y</code>都是这个类型的可选类型。例子中此函数返回一个整型，所以<code>x</code>和<code>y</code>是可选整型。</p>
<p>如果你想对所有的错误都采用同样的方式来处理，用<code>try?</code>就可以让你写出简洁的错误处理代码。例如，下面的代码用几种方式来获取数据，如果所有方式都失败了则返回<code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">fetchData</span><span class="params">()</span></span> -&gt; <span class="type">Data</span>? &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> data = try? fetchDataFromDisk() &#123; <span class="keyword">return</span> data &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> data = try? fetchDataFromServer() &#123; <span class="keyword">return</span> data &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="禁用错误传递">禁用错误传递</h3><p>有时你知道某个 throwing 函数实际上在运行时是不会抛出错误的，在这种情况下，你可以在表达式前面写<code>try!</code>来禁用错误传递，这会把调用包装在一个断言不会有错误抛出的运行时断言中。如果实际上抛出了错误，你会得到一个运行时错误。</p>
<p>例如，下面的代码使用了<code>loadImage(_:)</code>函数，该函数从给定的路径加载图片资源，如果图片无法载入则抛出一个错误。在这种情况下，因为图片是和应用绑定的，运行时不会有错误抛出，所以适合禁用错误传递：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> photo = try! loadImage(<span class="string">"./Resources/John Appleseed.jpg"</span>)</span><br></pre></td></tr></table></figure>
<p><a name="specifying_cleanup_actions"></a></p>
<p>##指定清理操作</p>
<p>可以使用<code>defer</code>语句在即将离开当前代码块时执行一系列语句。该语句让你能执行一些必要的清理工作，不管是以何种方式离开当前代码块的——无论是由于抛出错误而离开，还是由于诸如<code>return</code>或者<code>break</code>的语句。例如，你可以用<code>defer</code>语句来确保文件描述符得以关闭，以及手动分配的内存得以释放。</p>
<p><code>defer</code>语句将代码的执行延迟到当前的作用域退出之前。该语句由<code>defer</code>关键字和要被延迟执行的语句组成。延迟执行的语句不能包含任何控制转移语句，例如<code>break</code>或是<code>return</code>语句，或是抛出一个错误。延迟执行的操作会按照它们被指定时的顺序的相反顺序执行——也就是说，第一条<code>defer</code>语句中的代码会在第二条<code>defer</code>语句中的代码被执行之后才执行，以此类推。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">processFile</span><span class="params">(filename: String)</span></span> throws &#123;</span><br><span class="line">    <span class="keyword">if</span> exists(filename) &#123;</span><br><span class="line">        <span class="keyword">let</span> file = open(filename)</span><br><span class="line">        defer &#123;</span><br><span class="line">            close(file)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> line = try file.readline() &#123;</span><br><span class="line">            <span class="comment">// 处理文件。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// close(file) 会在这里被调用，即作用域的最后。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码使用一条<code>defer</code>语句来确保<code>open(_:)</code>函数有一个相应的对<code>close(_:)</code>函数的调用。</p>
<blockquote>
<p>注意<br>即使没有涉及到错误处理，你也可以使用<code>defer</code>语句。</p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/19_Type_Casting/" itemprop="url">
                第二章-19类型转换（Type Casting）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:08+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/19_Type_Casting/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/19_Type_Casting/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="类型转换（Type_Casting）">类型转换（Type Casting）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/xiehurricane" target="_blank" rel="external">xiehurricane</a><br>校对：<a href="https://github.com/happyming" target="_blank" rel="external">happyming</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/yangsiy" target="_blank" rel="external">yangsiy</a></p>
<p>2.1<br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a>，2015-11-01</p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#defining_a_class_hierarchy_for_type_casting">定义一个类层次作为例子</a></li>
<li><a href="#checking_type">检查类型</a></li>
<li><a href="#downcasting">向下转型（Downcasting）</a></li>
<li><a href="#type_casting_for_any_and_anyobject"><code>Any</code> 和 <code>AnyObject</code> 的类型转换</a></li>
</ul>
<p><em>类型转换</em> 可以判断实例的类型，也可以将实例看做是其父类或者子类的实例。</p>
<p>类型转换在 Swift 中使用 <code>is</code> 和 <code>as</code> 操作符实现。这两个操作符提供了一种简单达意的方式去检查值的类型或者转换它的类型。</p>
<p>你也可以用它来检查一个类型是否实现了某个协议，就像在<a href="./22_Protocols.html#checking_for_protocol_conformance">检验协议的一致性</a>部分讲述的一样。</p>
<p><a name="defining_a_class_hierarchy_for_type_casting"></a></p>
<h2 id="定义一个类层次作为例子">定义一个类层次作为例子</h2><p>你可以将类型转换用在类和子类的层次结构上，检查特定类实例的类型并且转换这个类实例的类型成为这个层次结构中的其他类型。下面的三个代码段定义了一个类层次和一个包含了这些类实例的数组，作为类型转换的例子。</p>
<p>第一个代码片段定义了一个新的基类 <code>MediaItem</code>。这个类为任何出现在数字媒体库的媒体项提供基础功能。特别的，它声明了一个 <code>String</code> 类型的 <code>name</code> 属性，和一个 <code>init(name:)</code> 初始化器。（假定所有的媒体项都有个名称。）</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MediaItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一个代码段定义了 <code>MediaItem</code> 的两个子类。第一个子类 <code>Movie</code> 封装了与电影相关的额外信息，在父类（或者说基类）的基础上增加了一个 <code>director</code>（导演）属性，和相应的初始化器。第二个子类 <code>Song</code>，在父类的基础上增加了一个 <code>artist</code>（艺术家）属性，和相应的初始化器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Movie</span>: <span class="title">MediaItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> director: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, director: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.director = director</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Song</span>: <span class="title">MediaItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> artist: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, artist: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.artist = artist</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一个代码段创建了一个数组常量 <code>library</code>，包含两个 <code>Movie</code> 实例和三个 <code>Song</code> 实例。<code>library</code> 的类型是在它被初始化时根据它数组中所包含的内容推断来的。Swift 的类型检测器能够推断出 <code>Movie</code> 和 <code>Song</code> 有共同的父类 <code>MediaItem</code>，所以它推断出 <code>[MediaItem]</code> 类作为 <code>library</code> 的类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> library = [</span><br><span class="line">    <span class="type">Movie</span>(name: <span class="string">"Casablanca"</span>, director: <span class="string">"Michael Curtiz"</span>),</span><br><span class="line">    <span class="type">Song</span>(name: <span class="string">"Blue Suede Shoes"</span>, artist: <span class="string">"Elvis Presley"</span>),</span><br><span class="line">    <span class="type">Movie</span>(name: <span class="string">"Citizen Kane"</span>, director: <span class="string">"Orson Welles"</span>),</span><br><span class="line">    <span class="type">Song</span>(name: <span class="string">"The One And Only"</span>, artist: <span class="string">"Chesney Hawkes"</span>),</span><br><span class="line">    <span class="type">Song</span>(name: <span class="string">"Never Gonna Give You Up"</span>, artist: <span class="string">"Rick Astley"</span>)</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 数组 library 的类型被推断为 [MediaItem]</span></span><br></pre></td></tr></table></figure>
<p>在幕后 <code>library</code> 里存储的媒体项依然是 <code>Movie</code> 和 <code>Song</code> 类型的。但是，若你迭代它，依次取出的实例会是 <code>MediaItem</code> 类型的，而不是 <code>Movie</code> 和 <code>Song</code> 类型。为了让它们作为原本的类型工作，你需要检查它们的类型或者向下转换它们到其它类型，就像下面描述的一样。</p>
<p><a name="checking_type"></a></p>
<h2 id="检查类型（Checking_Type）">检查类型（Checking Type）</h2><p>用类型检查操作符（<code>is</code>）来检查一个实例是否属于特定子类型。若实例属于那个子类型，类型检查操作符返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p>下面的例子定义了两个变量，<code>movieCount</code> 和 <code>songCount</code>，用来计算数组 <code>library</code> 中 <code>Movie</code> 和 <code>Song</code> 类型的实例数量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> movieCount = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> songCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> library &#123;</span><br><span class="line">    <span class="keyword">if</span> item <span class="keyword">is</span> <span class="type">Movie</span> &#123;</span><br><span class="line">        ++movieCount</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> item <span class="keyword">is</span> <span class="type">Song</span> &#123;</span><br><span class="line">        ++songCount</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Media library contains <span class="subst">\(movieCount)</span> movies and <span class="subst">\(songCount)</span> songs"</span>)</span><br><span class="line"><span class="comment">// 打印 “Media library contains 2 movies and 3 songs”</span></span><br></pre></td></tr></table></figure>
<p>示例迭代了数组 <code>library</code> 中的所有项。每一次，<code>for-in</code> 循环设置<br><code>item</code> 为数组中的下一个 <code>MediaItem</code>。</p>
<p>若当前 <code>MediaItem</code> 是一个 <code>Movie</code> 类型的实例，<code>item is Movie</code> 返回<br><code>true</code>，否则返回 <code>false</code>。同样的，<code>item is Song</code> 检查 <code>item</code> 是否为 <code>Song</code> 类型的实例。在循环结束后，<code>movieCount</code> 和 <code>songCount</code> 的值就是被找到的属于各自类型的实例的数量。</p>
<p><a name="downcasting"></a></p>
<h2 id="向下转型（Downcasting）">向下转型（Downcasting）</h2><p>某类型的一个常量或变量可能在幕后实际上属于一个子类。当确定是这种情况时，你可以尝试向下转到它的子类型，用类型转换操作符（<code>as?</code> 或 <code>as!</code>）。</p>
<p>因为向下转型可能会失败，类型转型操作符带有两种不同形式。条件形式（conditional form）<code>as?</code> 返回一个你试图向下转成的类型的可选值（optional value）。强制形式 <code>as!</code> 把试图向下转型和强制解包（force-unwraps）转换结果结合为一个操作。</p>
<p>当你不确定向下转型可以成功时，用类型转换的条件形式（<code>as?</code>）。条件形式的类型转换总是返回一个可选值（optional value），并且若下转是不可能的，可选值将是 <code>nil</code>。这使你能够检查向下转型是否成功。</p>
<p>只有你可以确定向下转型一定会成功时，才使用强制形式（<code>as!</code>）。当你试图向下转型为一个不正确的类型时，强制形式的类型转换会触发一个运行时错误。</p>
<p>下面的例子，迭代了 <code>library</code> 里的每一个 <code>MediaItem</code>，并打印出适当的描述。要这样做，<code>item</code> 需要真正作为 <code>Movie</code> 或 <code>Song</code> 的类型来使用，而不仅仅是作为 <code>MediaItem</code>。为了能够在描述中使用 <code>Movie</code> 或 <code>Song</code> 的 <code>director</code> 或 <code>artist</code> 属性，这是必要的。</p>
<p>在这个示例中，数组中的每一个 <code>item</code> 可能是 <code>Movie</code> 或 <code>Song</code>。事前你不知道每个 <code>item</code> 的真实类型，所以这里使用条件形式的类型转换（<code>as?</code>）去检查循环里的每次下转：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> library &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> movie = item <span class="keyword">as</span>? <span class="type">Movie</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Movie: '<span class="subst">\(movie.name)</span>', dir. <span class="subst">\(movie.director)</span>"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> song = item <span class="keyword">as</span>? <span class="type">Song</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Song: '<span class="subst">\(song.name)</span>', by <span class="subst">\(song.artist)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Movie: 'Casablanca', dir. Michael Curtiz</span></span><br><span class="line"><span class="comment">// Song: 'Blue Suede Shoes', by Elvis Presley</span></span><br><span class="line"><span class="comment">// Movie: 'Citizen Kane', dir. Orson Welles</span></span><br><span class="line"><span class="comment">// Song: 'The One And Only', by Chesney Hawkes</span></span><br><span class="line"><span class="comment">// Song: 'Never Gonna Give You Up', by Rick Astley</span></span><br></pre></td></tr></table></figure>
<p>示例首先试图将 <code>item</code> 下转为 <code>Movie</code>。因为 <code>item</code> 是一个 <code>MediaItem</code><br>类型的实例，它可能是一个 <code>Movie</code>；同样，它也可能是一个 <code>Song</code>，或者仅仅是基类<br><code>MediaItem</code>。因为不确定，<code>as?</code> 形式在试图下转时将返回一个可选值。<code>item as? Movie</code> 的返回值是 <code>Movie?</code> 或者说“可选 <code>Movie</code>”。</p>
<p>当向下转型为 <code>Movie</code> 应用在两个 <code>Song</code><br>实例时将会失败。为了处理这种情况，上面的例子使用了可选绑定（optional binding）来检查可选 <code>Movie</code> 真的包含一个值（这个是为了判断下转是否成功。）可选绑定是这样写的“<code>if let movie = item as? Movie</code>”，可以这样解读：</p>
<p>“尝试将 <code>item</code> 转为 <code>Movie</code> 类型。若成功，设置一个新的临时常量 <code>movie</code> 来存储返回的可选 <code>Movie</code> 中的值”</p>
<p>若向下转型成功，然后 <code>movie</code> 的属性将用于打印一个 <code>Movie</code> 实例的描述，包括它的导演的名字 <code>director</code>。相似的原理被用来检测 <code>Song</code> 实例，当 <code>Song</code> 被找到时则打印它的描述（包含 <code>artist</code> 的名字）。</p>
<blockquote>
<p>注意<br>转换没有真的改变实例或它的值。根本的实例保持不变；只是简单地把它作为它被转换成的类型来使用。</p>
</blockquote>
<p><a name="type_casting_for_any_and_anyobject"></a></p>
<h2 id="Any_和_AnyObject_的类型转换"><code>Any</code> 和 <code>AnyObject</code> 的类型转换</h2><p>Swift 为不确定类型提供了两种特殊的类型别名：</p>
<ul>
<li><code>AnyObject</code> 可以表示任何类类型的实例。</li>
<li><code>Any</code> 可以表示任何类型，包括函数类型。</li>
</ul>
<blockquote>
<p>注意<br>只有当你确实需要它们的行为和功能时才使用 <code>Any</code> 和 <code>AnyObject</code>。在你的代码里使用你期望的明确类型总是更好的。</p>
</blockquote>
<p><a name="anyobject"></a></p>
<h3 id="AnyObject_类型"><code>AnyObject</code> 类型</h3><p>当在工作中使用 Cocoa APIs 时，我们经常会接收到一个 <code>[AnyObject]</code> 类型的数组，或者说“一个任意类型对象的数组”。这是因为 Objective-C 没有明确的类型化数组。但是，你常常可以从 API 提供的信息来确定数组中对象的类型。</p>
<blockquote>
<p>译者注<br>这段文档似乎没有及时更新，从 Xcode 7 和 Swift 2.0 开始，由于 Objective-C 引入了轻量泛型，集合类型已经可以类型化了，在 Swift 中使用 Cocoa API 也越来越少遇到 <code>AnyObject</code> 类型了。详情请参阅 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html#//apple_ref/doc/uid/TP40014216-CH4-ID173" target="_blank" rel="external">Lightweight Generics</a> 和 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6-ID69" target="_blank" rel="external">Collection Classes</a>。</p>
</blockquote>
<p>在这些情况下，你可以使用强制形式的类型转换（<code>as</code>）来下转数组中的每一项到比 <code>AnyObject</code> 更明确的类型，不需要可选解包（optional unwrapping）。</p>
<p>下面的示例定义了一个 <code>[AnyObject]</code> 类型的数组并填入三个 <code>Movie</code> 类型的实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someObjects: [<span class="type">AnyObject</span>] = [</span><br><span class="line">    <span class="type">Movie</span>(name: <span class="string">"2001: A Space Odyssey"</span>, director: <span class="string">"Stanley Kubrick"</span>),</span><br><span class="line">    <span class="type">Movie</span>(name: <span class="string">"Moon"</span>, director: <span class="string">"Duncan Jones"</span>),</span><br><span class="line">    <span class="type">Movie</span>(name: <span class="string">"Alien"</span>, director: <span class="string">"Ridley Scott"</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>因为知道这个数组只包含 <code>Movie</code> 实例，你可以直接用（<code>as!</code>）下转并解包到非可选的 <code>Movie</code> 类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> object <span class="keyword">in</span> someObjects &#123;</span><br><span class="line">    <span class="keyword">let</span> movie = object <span class="keyword">as</span>! <span class="type">Movie</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Movie: '<span class="subst">\(movie.name)</span>', dir. <span class="subst">\(movie.director)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Movie: '2001: A Space Odyssey', dir. Stanley Kubrick</span></span><br><span class="line"><span class="comment">// Movie: 'Moon', dir. Duncan Jones</span></span><br><span class="line"><span class="comment">// Movie: 'Alien', dir. Ridley Scott</span></span><br></pre></td></tr></table></figure>
<p>为了变为一个更简短的形式，下转 <code>someObjects</code> 数组为 <code>[Movie]</code> 类型而不是下转数组中的每一项：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> movie <span class="keyword">in</span> someObjects <span class="keyword">as</span>! [<span class="type">Movie</span>] &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Movie: '<span class="subst">\(movie.name)</span>', dir. <span class="subst">\(movie.director)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Movie: '2001: A Space Odyssey', dir. Stanley Kubrick</span></span><br><span class="line"><span class="comment">// Movie: 'Moon', dir. Duncan Jones</span></span><br><span class="line"><span class="comment">// Movie: 'Alien', dir. Ridley Scott</span></span><br></pre></td></tr></table></figure>
<p><a name="any"></a></p>
<h3 id="Any_类型"><code>Any</code> 类型</h3><p>这里有个示例，使用 <code>Any</code> 类型来和混合的不同类型一起工作，包括函数类型和非类类型。它创建了一个可以存储 <code>Any</code> 类型的数组 <code>things</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> things = [<span class="type">Any</span>]()</span><br><span class="line"></span><br><span class="line">things.append(<span class="number">0</span>)</span><br><span class="line">things.append(<span class="number">0.0</span>)</span><br><span class="line">things.append(<span class="number">42</span>)</span><br><span class="line">things.append(<span class="number">3.14159</span>)</span><br><span class="line">things.append(<span class="string">"hello"</span>)</span><br><span class="line">things.append((<span class="number">3.0</span>, <span class="number">5.0</span>))</span><br><span class="line">things.append(<span class="type">Movie</span>(name: <span class="string">"Ghostbusters"</span>, director: <span class="string">"Ivan Reitman"</span>))</span><br><span class="line">things.append(&#123; (name: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span> <span class="string">"Hello, <span class="subst">\(name)</span>"</span> &#125;)</span><br></pre></td></tr></table></figure>
<p><code>things</code> 数组包含两个 <code>Int</code> 值，两个 <code>Double</code> 值，一个 <code>String</code> 值，一个元组 <code>(Double, Double)</code>，一个<code>Movie</code>实例“Ghostbusters”，以及一个接受 <code>String</code> 值并返回另一个 <code>String</code> 值的闭包表达式。</p>
<p>你可以在 <code>switch</code> 表达式的 <code>case</code> 中使用 <code>is</code> 和 <code>as</code> 操作符来找出只知道是 <code>Any</code> 或 <code>AnyObject</code> 类型的常量或变量的具体类型。下面的示例迭代 <code>things</code> 数组中的每一项，并用 <code>switch</code> 语句查找每一项的类型。有几个 <code>switch</code> 语句的 <code>case</code> 绑定它们匹配到的值到一个指定类型的常量，从而可以打印这些值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> thing <span class="keyword">in</span> things &#123;</span><br><span class="line">    <span class="keyword">switch</span> thing &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span> <span class="keyword">as</span> <span class="type">Int</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"zero as an Int"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span> <span class="keyword">as</span> <span class="type">Double</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"zero as a Double"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> someInt <span class="keyword">as</span> <span class="type">Int</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"an integer value of <span class="subst">\(someInt)</span>"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> someDouble <span class="keyword">as</span> <span class="type">Double</span> <span class="keyword">where</span> someDouble &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"a positive double value of <span class="subst">\(someDouble)</span>"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">is</span> <span class="type">Double</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"some other double value that I don't want to print"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> someString <span class="keyword">as</span> <span class="type">String</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"a string value of \"<span class="subst">\(someString)</span>\""</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">as</span> (<span class="type">Double</span>, <span class="type">Double</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"an (x, y) point at <span class="subst">\(x)</span>, <span class="subst">\(y)</span>"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> movie <span class="keyword">as</span> <span class="type">Movie</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"a movie called '<span class="subst">\(movie.name)</span>', dir. <span class="subst">\(movie.director)</span>"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> stringConverter <span class="keyword">as</span> <span class="type">String</span> -&gt; <span class="type">String</span>:</span><br><span class="line">        <span class="built_in">print</span>(stringConverter(<span class="string">"Michael"</span>))</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"something else"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// zero as an Int</span></span><br><span class="line"><span class="comment">// zero as a Double</span></span><br><span class="line"><span class="comment">// an integer value of 42</span></span><br><span class="line"><span class="comment">// a positive double value of 3.14159</span></span><br><span class="line"><span class="comment">// a string value of "hello"</span></span><br><span class="line"><span class="comment">// an (x, y) point at 3.0, 5.0</span></span><br><span class="line"><span class="comment">// a movie called 'Ghostbusters', dir. Ivan Reitman</span></span><br><span class="line"><span class="comment">// Hello, Michael</span></span><br></pre></td></tr></table></figure>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/20_Nested_Types/" itemprop="url">
                第二章-20嵌套类型（Nested Types）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:07+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/20_Nested_Types/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/20_Nested_Types/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="嵌套类型（Nested_Types）">嵌套类型（Nested Types）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/Lin-H" target="_blank" rel="external">Lin-H</a><br>校对：<a href="https://github.com/shinyzhu" target="_blank" rel="external">shinyzhu</a></p>
<p>2.0<br>翻译+校对：<a href="https://github.com/SergioChan" target="_blank" rel="external">SergioChan</a></p>
<p>2.1<br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a>，2015-11-01</p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#nested_types_in_action">嵌套类型实践</a></li>
<li><a href="#referring_to_nested_types">引用嵌套类型</a></li>
</ul>
<p>枚举常被用于为特定类或结构体实现某些功能。类似的，也能够在某个复杂的类型中，方便地定义工具类或结构体来使用。为了实现这种功能，Swift 允许你定义嵌套类型，可以在支持的类型中定义嵌套的枚举、类和结构体。</p>
<p>要在一个类型中嵌套另一个类型，将嵌套类型的定义写在其外部类型的<code>{}</code>内，而且可以根据需要定义多级嵌套。</p>
<p><a name="nested_types_in_action"></a></p>
<h2 id="嵌套类型实践">嵌套类型实践</h2><p>下面这个例子定义了一个结构体<code>BlackjackCard</code>（二十一点），用来模拟<code>BlackjackCard</code>中的扑克牌点数。<code>BlackjackCard</code>结构体包含两个嵌套定义的枚举类型<code>Suit</code>和<code>Rank</code>。</p>
<p>在<code>BlackjackCard</code>中，<code>Ace</code>牌可以表示<code>1</code>或者<code>11</code>，<code>Ace</code>牌的这一特征通过一个嵌套在<code>Rank</code>枚举中的结构体<code>Values</code>来表示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BlackjackCard</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 嵌套的 Suit 枚举</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Suit</span>: <span class="title">Character</span> </span>&#123;</span><br><span class="line">       <span class="keyword">case</span> <span class="type">Spades</span> = <span class="string">"♠"</span>, <span class="type">Hearts</span> = <span class="string">"♡"</span>, <span class="type">Diamonds</span> = <span class="string">"♢"</span>, <span class="type">Clubs</span> = <span class="string">"♣"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 嵌套的 Rank 枚举</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Rank</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">       <span class="keyword">case</span> <span class="type">Two</span> = <span class="number">2</span>, <span class="type">Three</span>, <span class="type">Four</span>, <span class="type">Five</span>, <span class="type">Six</span>, <span class="type">Seven</span>, <span class="type">Eight</span>, <span class="type">Nine</span>, <span class="type">Ten</span></span><br><span class="line">       <span class="keyword">case</span> <span class="type">Jack</span>, <span class="type">Queen</span>, <span class="type">King</span>, <span class="type">Ace</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">Values</span> </span>&#123;</span><br><span class="line">           <span class="keyword">let</span> first: <span class="type">Int</span>, second: <span class="type">Int</span>?</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">var</span> values: <span class="type">Values</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Ace</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Values</span>(first: <span class="number">1</span>, second: <span class="number">11</span>)</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Jack</span>, .<span class="type">Queen</span>, .<span class="type">King</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Values</span>(first: <span class="number">10</span>, second: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Values</span>(first: <span class="keyword">self</span>.rawValue, second: <span class="literal">nil</span>)</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BlackjackCard 的属性和方法</span></span><br><span class="line">    <span class="keyword">let</span> rank: <span class="type">Rank</span>, suit: <span class="type">Suit</span></span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">    	<span class="keyword">var</span> output = <span class="string">"suit is <span class="subst">\(suit.rawValue)</span>,"</span></span><br><span class="line">        output += <span class="string">" value is <span class="subst">\(rank.values.first)</span>"</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> second = rank.values.second &#123;</span><br><span class="line">            output += <span class="string">" or <span class="subst">\(second)</span>"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Suit</code>枚举用来描述扑克牌的四种花色，并用一个<code>Character</code>类型的原始值表示花色符号。</p>
<p><code>Rank</code>枚举用来描述扑克牌从<code>Ace</code>~<code>10</code>，以及<code>J</code>、<code>Q</code>、<code>K</code>，这<code>13</code>种牌，并用一个<code>Int</code>类型的原始值表示牌的面值。（这个<code>Int</code>类型的原始值未用于<code>Ace</code>、<code>J</code>、<code>Q</code>、<code>K</code>这<code>4</code>种牌。）</p>
<p>如上所述，<code>Rank</code>枚举在内部定义了一个嵌套结构体<code>Values</code>。结构体<code>Values</code>中定义了两个属性，用于反映只有<code>Ace</code>有两个数值，其余牌都只有一个数值：</p>
<ul>
<li><code>first</code>的类型为<code>Int</code></li>
<li><code>second</code>的类型为<code>Int?</code>，或者说“optional <code>Int</code>”</li>
</ul>
<p><code>Rank</code>还定义了一个计算型属性<code>values</code>，它将会返回一个<code>Values</code>结构体的实例。这个计算型属性会根据牌的面值，用适当的数值去初始化<code>Values</code>实例。对于<code>J</code>、<code>Q</code>、<code>K</code>、<code>Ace</code>这四种牌，会使用特殊数值。对于数字面值的牌，使用枚举实例的原始值。</p>
<p><code>BlackjackCard</code>结构体拥有两个属性——<code>rank</code>与<code>suit</code>。它也同样定义了一个计算型属性<code>description</code>，<code>description</code>属性用<code>rank</code>和<code>suit</code>中的内容来构建对扑克牌名字和数值的描述。该属性使用可选绑定来检查可选类型<code>second</code>是否有值，若有值，则在原有的描述中增加对<code>second</code>的描述。</p>
<p>因为<code>BlackjackCard</code>是一个没有自定义构造器的结构体，在<a href="./14_Initialization.html#memberwise_initializers_for_structure_types">结构体的逐一成员构造器</a>中可知，结构体有默认的成员构造器，所以你可以用默认的构造器去初始化新常量<code>theAceOfSpades</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> theAceOfSpades = <span class="type">BlackjackCard</span>(rank: .<span class="type">Ace</span>, suit: .<span class="type">Spades</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"theAceOfSpades: <span class="subst">\(theAceOfSpades.description)</span>"</span>)</span><br><span class="line"><span class="comment">// 打印 “theAceOfSpades: suit is ♠, value is 1 or 11”</span></span><br></pre></td></tr></table></figure>
<p>尽管<code>Rank</code>和<code>Suit</code>嵌套在<code>BlackjackCard</code>中，但它们的类型仍可从上下文中推断出来，所以在初始化实例时能够单独通过成员名称（<code>.Ace</code>和<code>.Spades</code>）引用枚举实例。在上面的例子中，<code>description</code>属性正确地反映了黑桃A牌具有<code>1</code>和<code>11</code>两个值。</p>
<p><a name="referring_to_nested_types"></a></p>
<h2 id="引用嵌套类型">引用嵌套类型</h2><p>在外部引用嵌套类型时，在嵌套类型的类型名前加上其外部类型的类型名作为前缀：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> heartsSymbol = <span class="type">BlackjackCard</span>.<span class="type">Suit</span>.<span class="type">Hearts</span>.rawValue</span><br><span class="line"><span class="comment">// 红心符号为 “♡”</span></span><br></pre></td></tr></table></figure>
<p>对于上面这个例子，这样可以使<code>Suit</code>、<code>Rank</code>和<code>Values</code>的名字尽可能的短，因为它们的名字可以由定义它们的上下文来限定。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/25/swift-cn/chapter2/21_Extensions/" itemprop="url">
                第二章-21扩展（Extensions）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-25T12:00:06+08:00" content="2015-12-25">
            2015-12-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/swift-cn/" itemprop="url" rel="index">
                  <span itemprop="name">swift-cn</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/12/25/swift-cn/chapter2/21_Extensions/#comments" itemprop="discussionUrl">
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/25/swift-cn/chapter2/21_Extensions/" itemprop="commentsCount"></span>
            </a>
          </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="扩展（Extensions）">扩展（Extensions）</h1><hr>
<blockquote>
<p>1.0<br>翻译：<a href="https://github.com/lyuka" target="_blank" rel="external">lyuka</a><br>校对：<a href="https://github.com/Hawstein" target="_blank" rel="external">Hawstein</a></p>
<p>2.0<br>翻译+校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a></p>
<p>2.1<br>校对：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a></p>
</blockquote>
<p>本页包含内容：</p>
<ul>
<li><a href="#extension_syntax">扩展语法</a></li>
<li><a href="#computed_properties">计算型属性</a></li>
<li><a href="#initializers">构造器</a></li>
<li><a href="#methods">方法</a></li>
<li><a href="#subscripts">下标</a></li>
<li><a href="#nested_types">嵌套类型</a></li>
</ul>
<p><em>扩展</em> 就是为一个已有的类、结构体、枚举类型或者协议类型添加新功能。这包括在没有权限获取原始源代码的情况下扩展类型的能力（即 <em>逆向建模</em> ）。扩展和 Objective-C 中的分类类似。（与 Objective-C 不同的是，Swift 的扩展没有名字。）</p>
<p>Swift 中的扩展可以：</p>
<ul>
<li>添加计算型属性和计算型类型属性</li>
<li>定义实例方法和类型方法</li>
<li>提供新的构造器</li>
<li>定义下标</li>
<li>定义和使用新的嵌套类型</li>
<li>使一个已有类型符合某个协议</li>
</ul>
<p>在 Swift 中，你甚至可以对协议进行扩展，提供协议要求的实现，或者添加额外的功能，从而可以让符合协议的类型拥有这些功能。你可以从<a href="./22_Protocols.html#protocol_extensions">协议扩展</a>获取更多的细节。</p>
<blockquote>
<p>注意<br>扩展可以为一个类型添加新的功能，但是不能重写已有的功能。</p>
</blockquote>
<p><a name="extension_syntax"></a></p>
<h2 id="扩展语法（Extension_Syntax）">扩展语法（Extension Syntax）</h2><p>使用关键字 <code>extension</code> 来声明扩展：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SomeType</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为 SomeType 添加的新功能写到这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过扩展来扩展一个已有类型，使其采纳一个或多个协议。在这种情况下，无论是类还是结构体，协议名字的书写方式完全一样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SomeType</span>: <span class="title">SomeProtocol</span>, <span class="title">AnotherProctocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 协议实现写到这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这种方式添加协议一致性的详细描述请参阅<a href="./22_Protocols.html#adding_protocol_conformance_with_an_extension">利用扩展添加协议一致性</a>。</p>
<blockquote>
<p>注意<br>如果你通过扩展为一个已有类型添加新功能，那么新功能对该类型的所有已有实例都是可用的，即使它们是在这个扩展定义之前创建的。</p>
</blockquote>
<p><a name="computed_properties"></a></p>
<h2 id="计算型属性（Computed_Properties）">计算型属性（Computed Properties）</h2><p>扩展可以为已有类型添加计算型实例属性和计算型类型属性。下面的例子为 Swift 的内建 <code>Double</code> 类型添加了五个计算型实例属性，从而提供与距离单位协作的基本支持：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Double</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> km: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> * <span class="number">1_000.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> m : <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> cm: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> / <span class="number">100.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> mm: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> / <span class="number">1_000.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> ft: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> / <span class="number">3.28084</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> oneInch = <span class="number">25.4</span>.mm</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"One inch is <span class="subst">\(oneInch)</span> meters"</span>)</span><br><span class="line"><span class="comment">// 打印 “One inch is 0.0254 meters”</span></span><br><span class="line"><span class="keyword">let</span> threeFeet = <span class="number">3</span>.ft</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Three feet is <span class="subst">\(threeFeet)</span> meters"</span>)</span><br><span class="line"><span class="comment">// 打印 “Three feet is 0.914399970739201 meters”</span></span><br></pre></td></tr></table></figure>
<p>这些计算型属性表达的含义是把一个 <code>Double</code> 值看作是某单位下的长度值。即使它们被实现为计算型属性，但这些属性的名字仍可紧接一个浮点型字面值，从而通过点语法来使用，并以此实现距离转换。</p>
<p>在上述例子中，<code>Double</code> 值 <code>1.0</code> 用来表示“1米”。这就是为什么计算型属性 <code>m</code> 返回 <code>self</code>，即表达式 <code>1.m</code> 被认为是计算 <code>Double</code> 值 <code>1.0</code>。</p>
<p>其它单位则需要一些单位换算。一千米等于 1,000 米，所以计算型属性 <code>km</code> 要把值乘以 <code>1_000.00</code> 来实现千米到米的单位换算。类似地，一米有 3.28024 英尺，所以计算型属性 <code>ft</code> 要把对应的 <code>Double</code> 值除以 <code>3.28024</code> 来实现英尺到米的单位换算。</p>
<p>这些属性是只读的计算型属性，为了更简洁，省略了 <code>get</code> 关键字。它们的返回值是 <code>Double</code>，而且可以用于所有接受 <code>Double</code> 值的数学计算中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aMarathon = <span class="number">42</span>.km + <span class="number">195</span>.m</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"A marathon is <span class="subst">\(aMarathon)</span> meters long"</span>)</span><br><span class="line"><span class="comment">// 打印 “A marathon is 42195.0 meters long”</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>扩展可以添加新的计算型属性，但是不可以添加存储型属性，也不可以为已有属性添加属性观察器。</p>
</blockquote>
<p><a name="initializers"></a></p>
<h2 id="构造器（Initializers）">构造器（Initializers）</h2><p>扩展可以为已有类型添加新的构造器。这可以让你扩展其它类型，将你自己的定制类型作为其构造器参数，或者提供该类型的原始实现中未提供的额外初始化选项。  </p>
<p>扩展能为类添加新的便利构造器，但是它们不能为类添加新的指定构造器或析构器。指定构造器和析构器必须总是由原始的类实现来提供。</p>
<blockquote>
<p>注意<br>如果你使用扩展为一个值类型添加构造器，且该值类型的原始实现中未定义任何定制的构造器时，你可以在扩展中的构造器里调用逐一成员构造器。如果该值类型为所有存储型属性提供了默认值，你还可以在扩展中的构造器里调用默认构造器。<br>正如在<a href="./14_Initialization.html#initializer_delegation_for_value_types">值类型的构造器代理</a>中描述的，如果你把定制的构造器写在值类型的原始实现中，上述规则将不再适用。</p>
</blockquote>
<p>下面的例子定义了一个用于描述几何矩形的结构体 <code>Rect</code>。这个例子同时定义了两个辅助结构体 <code>Size</code> 和 <code>Point</code>，它们都把 <code>0.0</code> 作为所有属性的默认值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span>, height = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> origin = <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size = <span class="type">Size</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为结构体 <code>Rect</code> 未提供定制的构造器，因此它会获得一个逐一成员构造器。又因为它为所有存储型属性提供了默认值，它又会获得一个默认构造器。详情请参阅<a href="./14_Initialization.html#default_initializers">默认构造器</a>。这些构造器可以用于构造新的 <code>Rect</code> 实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> defaultRect = <span class="type">Rect</span>()</span><br><span class="line"><span class="keyword">let</span> memberwiseRect = <span class="type">Rect</span>(origin: <span class="type">Point</span>(x: <span class="number">2.0</span>, y: <span class="number">2.0</span>),</span><br><span class="line">    size: <span class="type">Size</span>(width: <span class="number">5.0</span>, height: <span class="number">5.0</span>))</span><br></pre></td></tr></table></figure>
<p>你可以提供一个额外的接受指定中心点和大小的构造器来扩展 <code>Rect</code> 结构体：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Rect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>(center: <span class="type">Point</span>, size: <span class="type">Size</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> originX = center.x - (size.width / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">let</span> originY = center.y - (size.height / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(origin: <span class="type">Point</span>(x: originX, y: originY), size: size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个新的构造器首先根据提供的 <code>center</code> 和 <code>size</code> 的值计算一个合适的原点。然后调用该结构体的逐一成员构造器 <code>init(origin:size:)</code>，该构造器将新的原点和大小的值保存到了相应的属性中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> centerRect = <span class="type">Rect</span>(center: <span class="type">Point</span>(x: <span class="number">4.0</span>, y: <span class="number">4.0</span>),</span><br><span class="line">    size: <span class="type">Size</span>(width: <span class="number">3.0</span>, height: <span class="number">3.0</span>))</span><br><span class="line"><span class="comment">// centerRect 的原点是 (2.5, 2.5)，大小是 (3.0, 3.0)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>如果你使用扩展提供了一个新的构造器，你依旧有责任确保构造过程能够让实例完全初始化。</p>
</blockquote>
<p><a name="methods"></a></p>
<h2 id="方法（Methods）">方法（Methods）</h2><p>扩展可以为已有类型添加新的实例方法和类型方法。下面的例子为 <code>Int</code> 类型添加了一个名为 <code>repetitions</code> 的实例方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">repetitions</span><span class="params">(task: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="keyword">self</span> &#123;</span><br><span class="line">            task()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 <code>repetitions(:_)</code> 方法接受一个 <code>() -&gt; Void</code> 类型的单参数，表示没有参数且没有返回值的函数。</p>
<p>定义该扩展之后，你就可以对任意整数调用 <code>repetitions(_:)</code> 方法，将闭包中的任务执行整数对应的次数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>.repetitions(&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello!"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// Hello!</span></span><br><span class="line"><span class="comment">// Hello!</span></span><br><span class="line"><span class="comment">// Hello!</span></span><br></pre></td></tr></table></figure>
<p>可以使用尾随闭包让调用更加简洁：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>.repetitions &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Goodbye!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Goodbye!</span></span><br><span class="line"><span class="comment">// Goodbye!</span></span><br><span class="line"><span class="comment">// Goodbye!</span></span><br></pre></td></tr></table></figure>
<p><a name="mutating_instance_methods"></a></p>
<h3 id="可变实例方法（Mutating_Instance_Methods）">可变实例方法（Mutating Instance Methods）</h3><p>通过扩展添加的实例方法也可以修改该实例本身。结构体和枚举类型中修改 <code>self</code> 或其属性的方法必须将该实例方法标注为 <code>mutating</code>，正如来自原始实现的可变方法一样。</p>
<p>下面的例子为 Swift 的 <code>Int</code> 类型添加了一个名为 <code>square</code> 的可变方法，用于计算原始值的平方值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">square</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span> = <span class="keyword">self</span> * <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> someInt = <span class="number">3</span></span><br><span class="line">someInt.square()</span><br><span class="line"><span class="comment">// someInt 的值现在是 9</span></span><br></pre></td></tr></table></figure>
<p><a name="subscripts"></a></p>
<h2 id="下标（Subscripts）">下标（Subscripts）</h2><p>扩展可以为已有类型添加新下标。这个例子为 Swift 内建类型 <code>Int</code> 添加了一个整型下标。该下标 <code>[n]</code> 返回十进制数字从右向左数的第 <code>n</code> 个数字：</p>
<ul>
<li><code>123456789[0]</code> 返回 <code>9</code></li>
<li><code>123456789[1]</code> 返回 <code>8</code></li>
</ul>
<p>……以此类推。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="keyword">var</span> digitIndex: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> decimalBase = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> digitIndex &gt; <span class="number">0</span> &#123;</span><br><span class="line">            decimalBase *= <span class="number">10</span></span><br><span class="line">            --digitIndex</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">self</span> / decimalBase) % <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">746381295</span>[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 返回 5</span></span><br><span class="line"><span class="number">746381295</span>[<span class="number">1</span>]</span><br><span class="line"><span class="comment">// 返回 9</span></span><br><span class="line"><span class="number">746381295</span>[<span class="number">2</span>]</span><br><span class="line"><span class="comment">// 返回 2</span></span><br><span class="line"><span class="number">746381295</span>[<span class="number">8</span>]</span><br><span class="line"><span class="comment">// 返回 7</span></span><br></pre></td></tr></table></figure>
<p>如果该 <code>Int</code> 值没有足够的位数，即下标越界，那么上述下标实现会返回 <code>0</code>，犹如在数字左边自动补 <code>0</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">746381295</span>[<span class="number">9</span>]</span><br><span class="line"><span class="comment">// 返回 0，即等同于：</span></span><br><span class="line"><span class="number">0746381295</span>[<span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<p><a name="nested_types"></a></p>
<h2 id="嵌套类型（Nested_Types）">嵌套类型（Nested Types）</h2><p>扩展可以为已有的类、结构体和枚举添加新的嵌套类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Kind</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Negative</span>, <span class="type">Zero</span>, <span class="type">Positive</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> kind: <span class="type">Kind</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> .<span class="type">Zero</span></span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> x <span class="keyword">where</span> x &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> .<span class="type">Positive</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> .<span class="type">Negative</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该例子为 <code>Int</code> 添加了嵌套枚举。这个名为 <code>Kind</code> 的枚举表示特定整数的类型。具体来说，就是表示整数是正数、零或者负数。</p>
<p>这个例子还为 <code>Int</code> 添加了一个计算型实例属性，即 <code>kind</code>，用来根据整数返回适当的 <code>Kind</code> 枚举成员。</p>
<p>现在，这个嵌套枚举可以和任意 <code>Int</code> 值一起使用了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">printIntegerKinds</span><span class="params">(numbers: [Int])</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        <span class="keyword">switch</span> number.kind &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Negative</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"- "</span>, terminator: <span class="string">""</span>)</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Zero</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"0 "</span>, terminator: <span class="string">""</span>)</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Positive</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"+ "</span>, terminator: <span class="string">""</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">""</span>)</span><br><span class="line">&#125;</span><br><span class="line">printIntegerKinds([<span class="number">3</span>, <span class="number">19</span>, -<span class="number">27</span>, <span class="number">0</span>, -<span class="number">6</span>, <span class="number">0</span>, <span class="number">7</span>])</span><br><span class="line"><span class="comment">// 打印 “+ + - 0 - 0 +”</span></span><br></pre></td></tr></table></figure>
<p>函数 <code>printIntegerKinds(_:)</code> 接受一个 <code>Int</code> 数组，然后对该数组进行迭代。在每次迭代过程中，对当前整数的计算型属性 <code>kind</code> 的值进行评估，并打印出适当的描述。</p>
<blockquote>
<p>注意<br>由于已知 <code>number.kind</code> 是 <code>Int.Kind</code> 类型，因此在 <code>switch</code> 语句中，<code>Int.Kind</code> 中的所有成员值都可以使用简写形式，例如使用 <code>. Negative</code> 而不是 <code>Int.Kind.Negative</code>。</p>
</blockquote>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/">&laquo;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/6/">&raquo;</a>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="https://avatars2.githubusercontent.com/u/14305708?v=3&s=460" alt="terry" itemprop="image"/>
          <p class="site-author-name" itemprop="name">terry</p>
        </div>
        <p class="site-description motion-element" itemprop="description">terry yang's blog | java | scala | bi</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">130</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">11</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-next-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yangwei8888" target="_blank">github</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/microsoftgoogles" target="_blank">weibo</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/run-zhi-38" target="_blank">zhihu</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">terry</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  

    <script type="text/javascript">
      var disqus_shortname = 'yangwei888';
      var disqus_identifier = 'page/5/index.html';
      var disqus_title = '';
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
