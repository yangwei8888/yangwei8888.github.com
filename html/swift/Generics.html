

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Generics in Swift &mdash; Swift Programming Language documentation 0.1.9 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Swift Programming Language documentation 0.1.9 documentation" href="index.html"/>
        <link rel="up" title="Contents" href="contents.html"/>
        <link rel="next" title="Logical Objects" href="LogicalObjects.html"/>
        <link rel="prev" title="Error Handling Rationale and Proposal" href="ErrorHandlingRationale.html"/>
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>


  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Swift Programming Language documentation
          

          
          </a>

          
            
            
              <div class="version">
                0.1.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">swift docs</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="ABI.html">The Swift ABI</a></li>
<li class="toctree-l1"><a class="reference internal" href="ARCOptimization.html">ARC Optimization for Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="AccessControl.html">Access Control</a></li>
<li class="toctree-l1"><a class="reference internal" href="AccessControlInStdlib.html">Scope and introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="AccessControlInStdlib.html#public"><cite>public</cite></a></li>
<li class="toctree-l1"><a class="reference internal" href="AccessControlInStdlib.html#internal"><cite>internal</cite></a></li>
<li class="toctree-l1"><a class="reference internal" href="AccessControlInStdlib.html#private"><cite>private</cite></a></li>
<li class="toctree-l1"><a class="reference internal" href="AccessControlInStdlib.html#leading-underscore-rule">Leading Underscore Rule</a></li>
<li class="toctree-l1"><a class="reference internal" href="Arrays.html">The Swift Array Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="CallingConvention.html">The Swift Calling Convention</a></li>
<li class="toctree-l1"><a class="reference internal" href="DebuggingTheCompiler.html">Debugging the Swift Compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="Dependency Analysis.html">Dependency Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="DriverInternals.html">Driver Design &amp; Internals</a></li>
<li class="toctree-l1"><a class="reference internal" href="DriverParseableOutput.html">Parseable Driver Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="ErrorHandling.html">Error Handling in Swift 2.0</a></li>
<li class="toctree-l1"><a class="reference internal" href="ErrorHandlingRationale.html">Error Handling Rationale and Proposal</a></li>
<li class="toctree-l1"><a class="reference internal" href="Failable Initializers.html">Failable initializers</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Generics in Swift</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#motivation">Motivation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#goals">Goals</a></li>
<li class="toctree-l2"><a class="reference internal" href="#polymorphism">Polymorphism</a></li>
<li class="toctree-l2"><a class="reference internal" href="#protocols">Protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="#protocol-inheritance">Protocol Inheritance</a></li>
<li class="toctree-l2"><a class="reference internal" href="#self-types">Self Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="#associated-types">Associated Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="#operators-properties-and-subscripting">Operators, Properties, and Subscripting</a></li>
<li class="toctree-l2"><a class="reference internal" href="#conforming-to-a-protocol">Conforming to a Protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="#explicit-protocol-conformance">Explicit Protocol Conformance</a></li>
<li class="toctree-l2"><a class="reference internal" href="#retroactive-modeling">Retroactive Modeling</a></li>
<li class="toctree-l2"><a class="reference internal" href="#default-implementations">Default Implementations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#subtype-polymorphism">Subtype Polymorphism</a></li>
<li class="toctree-l2"><a class="reference internal" href="#bounded-parametric-polymorphism">Bounded Parametric Polymorphism</a></li>
<li class="toctree-l2"><a class="reference internal" href="#expressing-constraints">Expressing Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="#constraint-inference">Constraint Inference</a></li>
<li class="toctree-l2"><a class="reference internal" href="#type-parameter-deduction">Type Parameter Deduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#implementation-model">Implementation Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="#specialization">Specialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#existential-types-and-generics">Existential Types and Generics</a></li>
<li class="toctree-l2"><a class="reference internal" href="#overloading">Overloading</a></li>
<li class="toctree-l2"><a class="reference internal" href="#parsing-issues">Parsing Issues</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="GitWorkflows.html">Git Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="GitWorkflows.html#svn-git-workflows">SVN -&gt; GIT Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="HighLevelSILOptimizations.html">High-Level Optimizations in SIL</a></li>
<li class="toctree-l1"><a class="reference internal" href="Import.html">IMPORT SYNTAX</a></li>
<li class="toctree-l1"><a class="reference internal" href="Import.html#resolving-name-clashes">RESOLVING NAME CLASHES</a></li>
<li class="toctree-l1"><a class="reference internal" href="Import.html#future-extensions">FUTURE EXTENSIONS</a></li>
<li class="toctree-l1"><a class="reference internal" href="IndexInvalidation.html">Index Invalidation Rules in the Swift Standard Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#using-versioned-api">Using Versioned API</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#publishing-versioned-api">Publishing Versioned API</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#giving-up-flexibility">Giving Up Flexibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#optimization">Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#resilience-domains">Resilience Domains</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#protocol-conformances">Protocol Conformances</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#checking-binary-compatibility">Checking Binary Compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#summary">Summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="LibraryEvolution.html#glossary">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="Literals.html">Literals</a></li>
<li class="toctree-l1"><a class="reference internal" href="LogicalObjects.html">Logical Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="Modules.html">High-Level Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="Modules.html#import"><code class="docutils literal"><span class="pre">import</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="Modules.html#interoperability-with-objective-c-via-clang">Interoperability with Objective-C via Clang</a></li>
<li class="toctree-l1"><a class="reference internal" href="Modules.html#glossary">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="MutationModel.html">Immutability and Read-Only Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="ObjectInitialization.html">Object Initialization</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html">Writing High-Performance Swift Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#enabling-optimizations">Enabling Optimizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#whole-module-optimizations">Whole Module Optimizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#reducing-dynamic-dispatch">Reducing Dynamic Dispatch</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#using-container-types-efficiently">Using Container Types Efficiently</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#unchecked-operations">Unchecked operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#generics">Generics</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#the-cost-of-large-swift-values">The cost of large swift values</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#unsafe-code">Unsafe code</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#protocols">Protocols</a></li>
<li class="toctree-l1"><a class="reference internal" href="OptimizationTips.html#footnotes">Footnotes</a></li>
<li class="toctree-l1"><a class="reference internal" href="Pattern Matching.html">Pattern Matching</a></li>
<li class="toctree-l1"><a class="reference internal" href="SIL.html">Swift Intermediate Language (SIL)</a></li>
<li class="toctree-l1"><a class="reference internal" href="SequencesAndCollections.html">Sequences And Collections in Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="Serialization.html">Swift Binary Serialization Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="StdlibAPIGuidelines.html">Swift Standard Library API Design Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="StdlibRationales.html">Rationales for the Swift standard library designs</a></li>
<li class="toctree-l1"><a class="reference internal" href="StoredAndComputedVariables.html">Stored and Computed Variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="StringDesign.html">Swift String Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="Testing.html">Testing Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="TextFormatting.html">Text Formatting in Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="TransparentAttr.html"><code class="docutils literal"><span class="pre">&#64;_transparent</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="TypeChecker.html">Type Checker Design and Implementation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="contents.html">Contents</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="IndexInvalidation.html">Index Invalidation Rules in the Swift Standard Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="AccessControl.html">Access Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="DriverInternals.html">Driver Design &amp; Internals</a></li>
<li class="toctree-l2"><a class="reference internal" href="DriverParseableOutput.html">Parseable Driver Output</a></li>
<li class="toctree-l2"><a class="reference internal" href="ErrorHandling.html">Error Handling in Swift 2.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="ErrorHandlingRationale.html">Error Handling Rationale and Proposal</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Generics in Swift</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#motivation">Motivation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#goals">Goals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#polymorphism">Polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="#protocols">Protocols</a></li>
<li class="toctree-l3"><a class="reference internal" href="#protocol-inheritance">Protocol Inheritance</a></li>
<li class="toctree-l3"><a class="reference internal" href="#self-types">Self Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#associated-types">Associated Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#operators-properties-and-subscripting">Operators, Properties, and Subscripting</a></li>
<li class="toctree-l3"><a class="reference internal" href="#conforming-to-a-protocol">Conforming to a Protocol</a></li>
<li class="toctree-l3"><a class="reference internal" href="#explicit-protocol-conformance">Explicit Protocol Conformance</a></li>
<li class="toctree-l3"><a class="reference internal" href="#retroactive-modeling">Retroactive Modeling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#default-implementations">Default Implementations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#subtype-polymorphism">Subtype Polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bounded-parametric-polymorphism">Bounded Parametric Polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="#expressing-constraints">Expressing Constraints</a></li>
<li class="toctree-l3"><a class="reference internal" href="#constraint-inference">Constraint Inference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#type-parameter-deduction">Type Parameter Deduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#implementation-model">Implementation Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="#specialization">Specialization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#existential-types-and-generics">Existential Types and Generics</a></li>
<li class="toctree-l3"><a class="reference internal" href="#overloading">Overloading</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parsing-issues">Parsing Issues</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="LogicalObjects.html">Logical Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="ObjectInitialization.html">Object Initialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="Pattern Matching.html">Pattern Matching</a></li>
<li class="toctree-l2"><a class="reference internal" href="StoredAndComputedVariables.html">Stored and Computed Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="SIL.html">Swift Intermediate Language (SIL)</a></li>
<li class="toctree-l2"><a class="reference internal" href="TypeChecker.html">Type Checker Design and Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="DebuggingTheCompiler.html">Debugging the Swift Compiler</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="weak.html">Weak References</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Swift Programming Language documentation</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
        <li><a href="contents.html">Contents</a> &raquo;</li>
      
    <li>Generics in Swift</li>
    <li class="wy-breadcrumbs-aside">
      
        
          <a href="_sources/Generics.txt" rel="nofollow"> View page source</a>
        
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="generics-in-swift">
<span id="generics"></span><h1>Generics in Swift<a class="headerlink" href="#generics-in-swift" title="Permalink to this headline">¶</a></h1>
<div class="section" id="motivation">
<h2>Motivation<a class="headerlink" href="#motivation" title="Permalink to this headline">¶</a></h2>
<p>Most types and functions in code are expressed in terms of a single, concrete
set of sets. Generics generalize this notion by allowing one to express types
and functions in terms of an abstraction over a (typically unbounded) set of
types, allowing improved code reuse. A typical example of a generic type is a
linked list of values, which can be used with any type of value. In C++, this
might be expressed as:</p>
<div class="highlight-python"><div class="highlight"><pre>template&lt;typename T&gt;
class List {
public:
  struct Node {
    T value;
    Node *next;
  };

  Node *first;
};
</pre></div>
</div>
<p>where List&lt;Int&gt;, List&lt;String&gt;, and List&lt;DataRecord&gt; are all distinct types that
provide a linked list storing integers, strings, and DataRecords,
respectively. Given such a data structure, one also needs to be able to
implement generic functions that can operate on a list of any kind of elements,
such as a simple, linear search algorithm:</p>
<div class="highlight-python"><div class="highlight"><pre>template&lt;typename T&gt;
typename List&lt;T&gt;::Node *find(const List&lt;T&gt;&amp;list, const T&amp; value) {
  for (typename List&lt;T&gt;::Node *result = list.first; result; result = result-&gt;next)
    if (result-&gt;value == value)
      return result;

  return 0;
}
</pre></div>
</div>
<p>Generics are important for the construction of useful libraries, because they
allow the library to adapt to application-specific data types without losing
type safety. This is especially important for foundational libraries containing
common data structures and algorithms, since these libraries are used across
nearly every interesting application.</p>
<p>The alternatives to generics tend to lead to poor solutions:</p>
<ul class="simple">
<li>Object-oriented languages tend to use &#8220;top&#8221; types (id in Objective-C,
java.lang.Object in pre-generics Java, etc.) for their containers and
algorithms, which gives up static type safety. Pre- generics Java forced the
user to introduce run-time-checked type casts when interacting with containers
(which is overly verbose), while Objective-C relies on id&#8217;s unsound implicit
conversion behavior to eliminate the need for casts.</li>
<li>Many languages bake common data structures (arrays, dictionaries, tables) into
the language itself. This is unfortunate both because it significantly
increases the size of the core language and because users then tend to use
this limited set of data structures for <em>every</em> problem, even when another
(not-baked-in) data structure would be better.</li>
</ul>
<p>Swift is intended to be a small, expressive language with great support for
building libraries. We&#8217;ll need generics to be able to build those libraries
well.</p>
</div>
<div class="section" id="goals">
<h2>Goals<a class="headerlink" href="#goals" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Generics should enable the development of rich generic libraries that feel
similar to first-class language features</li>
<li>Generics should work on any type, whether it is a value type or some kind of
object type</li>
<li>Generic code should be almost as easy to write as non-generic code</li>
<li>Generic code should be compiled such that it can be executed with any data
type without requiring a separate &#8220;instantiation&#8221; step</li>
<li>Generics should interoperate cleanly with run-time polymorphism</li>
<li>Types should be able to retroactively modified to meet the requirements of a
generic algorithm or data structure</li>
</ul>
<p>As important as the goals of a feature are the explicit non-goals, which we
don&#8217;t want or don&#8217;t need to support:</p>
<ul class="simple">
<li>Compile-time &#8220;metaprogramming&#8221; in any form</li>
<li>Expression-template tricks a la Boost.Spirit, POOMA</li>
</ul>
</div>
<div class="section" id="polymorphism">
<h2>Polymorphism<a class="headerlink" href="#polymorphism" title="Permalink to this headline">¶</a></h2>
<p>Polymorphism allows one to use different data types with a uniform
interface. Overloading already allows a form of polymorphism ( ad hoc
polymorphism) in Swift. For example, given:</p>
<div class="highlight-python"><div class="highlight"><pre>func +(x : Int, y : Int) -&gt; Int { add... }
func +(x : String, y : String) -&gt; String { concat... }
</pre></div>
</div>
<p>we can write the expression &#8220;x + y&#8221;, which will work for both integers and
strings.</p>
<p>However, we want the ability to express an algorithm or data structure
independently of mentioning any data type. To do so, we need a way to express
the essential interface that algorithm or data structure requires. For example,
an accumulation algorithm would need to express that for any type T, one can
write the expression &#8220;x + y&#8221; (where x and y are both of type T) and it will
produce another T.</p>
</div>
<div class="section" id="protocols">
<h2>Protocols<a class="headerlink" href="#protocols" title="Permalink to this headline">¶</a></h2>
<p>Most languages that provide some form of polymorphism also have a way to
describe abstract interfaces that cover a range of types: Java and C#
interfaces, C++ abstract base classes, Objective-C protocols, Scala traits,
Haskell type classes, C++ concepts (briefly), and many more.  All allow one to
describe functions or methods that are part of the interface, and provide some
way to re-use or extend a previous interface by adding to it. We&#8217;ll start with
that core feature, and build onto it what we need.</p>
<p>In Swift, I suggest that we use the term protocol for this feature, because I
expect the end result to be similar enough to Objective-C protocols that our
users will benefit, and (more importantly) different enough from Java/C#
interfaces and C++ abstract base classes that those terms will be harmful. The
term trait comes with the wrong connotation for C++ programmers, and none of our
users know Scala.</p>
<p>In its most basic form, a protocol is a collection of function signatures:</p>
<div class="highlight-python"><div class="highlight"><pre>protocol Document {
  func title() -&gt; String
}
</pre></div>
</div>
<p>Document describes types that have a title() operation that accepts no arguments
and returns a String. Note that there is implicitly a &#8216;self&#8217; type,
which is the type that conforms to the protocol itself. This follows how most
object-oriented languages describe interfaces, but deviates from Haskell type
classes and C++ concepts, which require explicit type parameters for all of the
types. We&#8217;ll revisit this decision later.</p>
</div>
<div class="section" id="protocol-inheritance">
<h2>Protocol Inheritance<a class="headerlink" href="#protocol-inheritance" title="Permalink to this headline">¶</a></h2>
<p>Composition of protocols is important to help programmers organize and
understand a large number of protocols and the data types that conform to those
protocols. For example, we could extend our Document protocol to cover documents
that support versioning:</p>
<div class="highlight-python"><div class="highlight"><pre>protocol VersionedDocument : Document {
  func version() -&gt; Int
}
</pre></div>
</div>
<p>Multiple inheritance is permitted, allowing us to form a directed acyclic graph
of protocols:</p>
<div class="highlight-python"><div class="highlight"><pre>protocol PersistentDocument : VersionedDocument, Serializable {
  func saveToFile(filename : path)
}
</pre></div>
</div>
<p>Any type that conforms to PersistentDocument also conforms to VersionedDocument,
Document, and Serializable, which gives us substitutability.</p>
</div>
<div class="section" id="self-types">
<h2>Self Types<a class="headerlink" href="#self-types" title="Permalink to this headline">¶</a></h2>
<p>Protocols thus far do not give us an easy way to express simple binary
operations. For example, let&#8217;s try to write a Comparable protocol that could be
used to search for a generic find() operation:</p>
<div class="highlight-python"><div class="highlight"><pre>protocol Comparable {
  func isEqual(other : ???) -&gt; bool
}
</pre></div>
</div>
<p>Our options for filling in ??? are currently very poor. We could use the syntax
for saying &#8220;any type&#8221; or &#8220;any type that is comparable&#8221;, as one must do most OO
languages, including Java, C#, and Objective-C, but that&#8217;s not expressing what
we want: that the type of both of the arguments be the same. This is sometimes
referred to as the binary method problem
(<a class="reference external" href="http://www.cis.upenn.edu/~bcpierce/papers/binary.ps">http://www.cis.upenn.edu/~bcpierce/papers/binary.ps</a> has a discussion of this
problem, including the solution I&#8217;m proposing below).</p>
<p>Neither C++ concepts nor Haskell type classes have this particular problem,
because they don&#8217;t have the notion of an implicit &#8216;Self&#8217; type. Rather,
they explicitly parameterize everything. In C++ concepts:</p>
<div class="highlight-python"><div class="highlight"><pre>concept Comparable&lt;typename T&gt; {
  bool T::isEqual(T);
}
</pre></div>
</div>
<p>Java and C# programmers work around this issue by parameterizing the
interface, e.g. (in Java):</p>
<div class="highlight-python"><div class="highlight"><pre>abstract class Comparable&lt;THIS extends Comparable&lt;THIS&gt;&gt; {
  public bool isEqual(THIS other);
}
</pre></div>
</div>
<p>and then a class X that wants to be Comparable will inherit from
Comparable&lt;X&gt;. This is ugly and has a number of pitfalls; see
<a class="reference external" href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6479372">http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6479372</a> .</p>
<p>Scala and Strongtalk have the notion of the &#8216;Self&#8217; type, which effectively
allows one to refer to the eventual type of &#8216;self&#8217; (which we call
&#8216;self&#8217;). &#8216;Self&#8217; (which we call &#8216;Self&#8217; in Swift) allows us to express the
Comparable protocol in a natural way:</p>
<div class="highlight-python"><div class="highlight"><pre>protocol Comparable {
  func isEqual(other : Self) -&gt; bool
}
</pre></div>
</div>
<p>By expressing Comparable in this way, we know that if we have two objects of
type T where T conforms to Comparable, comparison between those two objects with
isEqual is well-typed. However, if we have objects of different types T and U,
we cannot compare those objects with isEqual even if both T and U are
Comparable.</p>
<p>Self types are not without their costs, particularly in the case where Self is
used as a parameter type of a class method that will be subclassed. Here, the
parameter type ends up being (implicitly) covariant, which tightens up
type-checking but may also force us into more dynamic type checks. We can
explore this separately; within protocols, type-checking for Self is more
direct.</p>
</div>
<div class="section" id="associated-types">
<h2>Associated Types<a class="headerlink" href="#associated-types" title="Permalink to this headline">¶</a></h2>
<p>In addition to Self, a protocol&#8217;s operations often need to refer to types that
are related to the type of &#8216;Self&#8217;, such as a type of data stored in a
collection, or the node and edge types of a graph. For example, this would allow
us to cleanly describe a protocol for collections:</p>
<div class="highlight-python"><div class="highlight"><pre>protocol Collection {
  typealias Element
  func forEach(callback : (value : Element) -&gt; void)
  func add(value : Element)
}
</pre></div>
</div>
<p>It is important here that a generic function that refers to a given type T,
which is known to be a collection, can access the associated types corresponding
to T. For example, one could implement an &#8220;accumulate&#8221; operation for an
arbitrary Collection, but doing so requires us to specify some constraints on
the Value type of the collection. We&#8217;ll return to this later.</p>
</div>
<div class="section" id="operators-properties-and-subscripting">
<h2>Operators, Properties, and Subscripting<a class="headerlink" href="#operators-properties-and-subscripting" title="Permalink to this headline">¶</a></h2>
<p>As previously noted, protocols can contain both function requirements (which are
in effect requirements for instance methods) and associated type
requirements. Protocols can also contain operators, properties, and subscript
operators:</p>
<div class="highlight-python"><div class="highlight"><pre>protocol RandomAccessContainer : Collection {
  var length : Int
  func ==(lhs : Self, rhs : Self)
  subscript (i : Int) -&gt; Element
}
</pre></div>
</div>
<p>Operator requirements can be satisfied by operator definitions, property
requirements can be satisfied by either variables or properties, and subscript
requirements can be satisfied by subscript operators.</p>
</div>
<div class="section" id="conforming-to-a-protocol">
<h2>Conforming to a Protocol<a class="headerlink" href="#conforming-to-a-protocol" title="Permalink to this headline">¶</a></h2>
<p>Thus far, we have not actually shown how a type can meet the requirements of a
protocol. The most syntactically lightweight approach is to allow implicit
conformance. This is essentially duck typing, where a type is assumed to conform
to a protocol if it meets the syntactic requirements of the protocol. For
example, given:</p>
<div class="highlight-python"><div class="highlight"><pre>protocol Shape {
  func draw()
}
</pre></div>
</div>
<p>One could write a Circle struct such as:</p>
<div class="highlight-python"><div class="highlight"><pre>struct Circle {
  var center : Point
  var radius : Int

  func draw() {
    // draw it
  }
}
</pre></div>
</div>
<p>Circle provides a draw() method with the same input and result types as required
by the Shape protocol. Therefore, Circle conforms to Shape.</p>
<p>Implicit protocol conformance is convenient, because it requires no additional
typing. However, it can run into some trouble when an entity that syntactically
matches a protocol doesn&#8217;t provide the required semantics. For example, Cowboys
also know how to &#8220;draw!&#8221;:</p>
<div class="highlight-python"><div class="highlight"><pre>struct Cowboy {
  var gun : SixShooter

  func draw() {
    // draw!
  }
}
</pre></div>
</div>
<p>It is unlikely that Cowboy is meant to conform to Shape, but the method name and
signatures match, so implicit conformance deduces that Cowboy conforms to
Shape. Random collisions between types are fairly rare. However, when one is
using protocol inheritance with fine- grained (semantic or mostly-semantic)
differences between protocols in the hierarchy, they become more common. See
<a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1798.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1798.html</a> for examples
of this problem as it surfaced with C++ concepts. It is not clear at this time
whether we want implicit conformance in Swift: there&#8217;s no existing code to worry
about, and explicit conformance (described below) provides some benefits.</p>
</div>
<div class="section" id="explicit-protocol-conformance">
<h2>Explicit Protocol Conformance<a class="headerlink" href="#explicit-protocol-conformance" title="Permalink to this headline">¶</a></h2>
<p>Type authors often implement types that are intended to conform to a particular
protocol. For example, if we want a linked-list type to conform to Collection,
we can specify that it is by adding a protocol conformance annotation to the
type:</p>
<div class="highlight-python"><div class="highlight"><pre>struct EmployeeList : Collection { // EmployeeList is a collection
  typealias Element = T
  func forEach(callback : (value : Element) -&gt; void) { /* Implement this */ }
  func add(value : Element) { /* Implement this */ }
}
</pre></div>
</div>
<p>This explicit protocol conformance declaration forces the compiler to check that
EmployeeList actually does meet the requirements of the Collection protocol. If
we were missing an operation (say, forEach) or had the wrong signature, the
definition of &#8216;EmployeeList&#8217; would be ill-formed. Therefore, explicit
conformance provides both documentation for the user of EmployeeList and
checking for the author and future maintainers of EmployeeList.</p>
<p>Any nominal type (such as an enum, struct, or class) can be specified to conform
to one or more protocols in this manner. Additionally, a typealias can be
specified to conform to one or more protocols, e.g.,:</p>
<div class="highlight-python"><div class="highlight"><pre>typealias NSInteger : Numeric = Int
</pre></div>
</div>
<p>While not technically necessary due to retroactive modeling (below), this can be
used to document and check that a particular type alias does in fact meet some
basic, important requirements. Moreover, it falls out of the syntax that places
requirements on associated types.</p>
</div>
<div class="section" id="retroactive-modeling">
<h2>Retroactive Modeling<a class="headerlink" href="#retroactive-modeling" title="Permalink to this headline">¶</a></h2>
<p>When using a set of libraries, it&#8217;s fairly common that one library defines a
protocol (and useful generic entities requiring that protocol) while another
library provides a data type that provides similar functionality to that
protocol, but under a different name.  Retroactive modeling is the process by
which the type is retrofitted (without changing the type) to meet the
requirements of the protocol.</p>
<p>In Swift, we provide support for retroactive modeling by allowing
extensions, e.g.,:</p>
<div class="highlight-python"><div class="highlight"><pre>extension String : Collection {
  typealias Element = char
  func forEach(callback : (value : Element) -&gt; void) { /* use existing String routines to enumerate characters */ }
  func add(value : Element) { self += value /* append character */ }
}
</pre></div>
</div>
<p>Once an extension is defined, the extension now conforms to the Collection
protocol, and can be used anywhere a Collection is expected.</p>
</div>
<div class="section" id="default-implementations">
<h2>Default Implementations<a class="headerlink" href="#default-implementations" title="Permalink to this headline">¶</a></h2>
<p>The functions declared within a protocol are requirements that any type must
meet if it wants to conform to the protocol. There is a natural tension here,
then, between larger protocols that make it easier to write generic algorithms,
and smaller protocols that make it easier to write conforming types. For
example, should a Numeric protocol implement all operations, e.g.,:</p>
<div class="highlight-python"><div class="highlight"><pre>protocol Numeric {
  func +(lhs : Self, rhs : Self) -&gt; Self
  func -(lhs : Self, rhs : Self) -&gt; Self
  func +(x : Self) -&gt; Self
  func -(x : Self) -&gt; Self
}
</pre></div>
</div>
<p>which would make it easy to write general numeric algorithms, but requires the
author of some BigInt class to implement a lot of functionality, or should the
numeric protocol implement just the core operations:</p>
<div class="highlight-python"><div class="highlight"><pre>protocol Numeric {
  func +(lhs : Self, rhs : Self) -&gt; Self
  func -(x : Self) -&gt; Self
}
</pre></div>
</div>
<p>to make it easier to adopt the protocol (but harder to write numeric
algorithms)? Both of the protocols express the same thing (semantically),
because one can use the core operations (binary +, unary -) to implement the
other algorithms. However, it&#8217;s far easier to allow the protocol itself to
provide default implementations:</p>
<div class="highlight-python"><div class="highlight"><pre>protocol Numeric {
  func +(lhs : Self, rhs : Self) -&gt; Self
  func -(lhs : Self, rhs : Self) -&gt; Self { return lhs + -rhs }
  func +(x : Self) -&gt; Self { return x }
  func -(x : Self) -&gt; Self
}
</pre></div>
</div>
<p>This makes it easier both to implement generic algorithms (which can use the
most natural syntax) and to make a new type conform to the protocol. For
example, if we were to define only the core algorithms in our BigNum type:</p>
<div class="highlight-python"><div class="highlight"><pre>struct BigNum : Numeric {
  func +(lhs : BigNum, rhs : BigNum) -&gt; BigNum { ... }
  func -(x : BigNum) -&gt; BigNum { ... }
}
</pre></div>
</div>
<p>the compiler will automatically synthesize the other operations needed for the
protocol. Moreover, these operations will be available to uses of the BigNum
class as if they had been written in the type itself (or in an extension of the
type, if that feature is used), which means that protocol conformance actually
makes it easier to define types that conform to protocols, rather than just
providing additional checking.</p>
</div>
<div class="section" id="subtype-polymorphism">
<h2>Subtype Polymorphism<a class="headerlink" href="#subtype-polymorphism" title="Permalink to this headline">¶</a></h2>
<p>Subtype polymorphism is based on the notion of substitutability. If a type S is
a subtype of a type T, then a value of type S can safely be used where a value
of type T is expected. Object-oriented languages typically use subtype
polymorphism, where the subtype relationship is based on inheritance: if the
class Dog inherits from the class Animal, then Dog is a subtype of
Animal. Subtype polymorphism is generally dynamic, in the sense that the
substitution occurs at run-time, even if it is statically type-checked.</p>
<p>In Swift, we consider protocols to be types. A value of protocol type has an
existential type, meaning that we don&#8217;t know the concrete type until run-time
(and even then it varies), but we know that the type conforms to the given
protocol. Thus, a variable can be declared with type &#8220;Serializable&#8221;, e.g.,:</p>
<div class="highlight-python"><div class="highlight"><pre>var x : Serializable = // value of any Serializable type
x.serialize() // okay: serialize() is part of the Serializable protocol
</pre></div>
</div>
<p>Naturally, such polymorphism is dynamic, and will require boxing of value types
to implement. We can now see how Self types interact with subtype
polymorphism. For example, say we have two values of type Comparable, and we try
to compare them:</p>
<div class="highlight-python"><div class="highlight"><pre>var x : Comparable = ...
var y : Comparable = ...
if x.isEqual(y) { // well-typed?
}
</pre></div>
</div>
<p>Whether x.isEqual(y) is well-typed is not statically determinable, because the
dynamic type of x may different from the dynamic type of y, even if they are
both comparable (e.g., one is an Int and the other a String). It can be
implemented by the compiler as a dynamic type check, with some general failure
mode (aborting, throwing an exception, etc.) if the dynamic type check fails.</p>
<p>To express types that meet the requirements of several protocols, one can just
create a new protocol aggregating those protocols:</p>
<div class="highlight-python"><div class="highlight"><pre>protocol SerializableDocument : Document, Serializable { }
var doc : SerializableDocument
print(doc.title()) // okay: title() is part of the Document protocol, so we can call it
doc.serialize(stout) // okay: serialize() is part of the Serializable protocol
</pre></div>
</div>
<p>However, this only makes sense when the resulting protocol is a useful
abstraction. A SerializableDocument may or may not be a useful abstraction. When
it is not useful, one can instead use protocol&lt;&gt; types to compose different
protocols, e.g.,:</p>
<div class="highlight-python"><div class="highlight"><pre>var doc : protocol&lt;Document, Serializable&gt;
</pre></div>
</div>
<p>Here, doc has an existential type that is known to conform to both the Document
and Serializable protocols. This gives rise to a natural &#8220;top&#8221; type, such that
every type in the language is a subtype of &#8220;top&#8221;. Java has java.lang.Object, C#
has object, Objective-C has &#8220;id&#8221; (although &#8220;id&#8221; is weird, because it is also
convertible to everything; it&#8217;s best not to use it as a model). In Swift, the
&#8220;top&#8221; type is simply an empty protocol composition:</p>
<div class="highlight-python"><div class="highlight"><pre>typealias Any = protocol&lt;&gt;

var value : Any = 17 // an any can hold an integer
value = &quot;hello&quot; // or a String
value = (42, &quot;hello&quot;, Red) // or anything else
</pre></div>
</div>
</div>
<div class="section" id="bounded-parametric-polymorphism">
<h2>Bounded Parametric Polymorphism<a class="headerlink" href="#bounded-parametric-polymorphism" title="Permalink to this headline">¶</a></h2>
<p>Parametric polymorphism is based on the idea of providing type parameters for a
generic function or type. When using that function or type, one substitutes
concrete types for the type parameters. Strictly speaking, parametric
polymorphism allows <em>any</em> type to be substituted for a type parameter, but it&#8217;s
useless in practice because that means that generic functions or types cannot do
anything to the type parameters: they must instead rely on first-class functions
passed into the generic function or type to perform any meaningful work.</p>
<p>Far more useful (and prevalent) is bounded parametric polymorphism, which allows
the generic function or type to specify constraints (bounds) on the type
parameters. By specifying these bounds, it becomes far easier to write and use
these generic functions and types.  Haskell type classes, Java and C# generics,
C++ concepts, and many other language features support bounded parametric
polymorphism.</p>
<p>Protocols provide a natural way to express the constraints of a generic function
in Swift. For example, one could define a generic linked list as:</p>
<div class="highlight-python"><div class="highlight"><pre>struct ListNode&lt;T&gt; {
  var Value : T
  enum NextNode { case Node : ListNode&lt;T&gt;, End }
  var Next : NextNode
}

struct List&lt;T &gt; {
  var First : ListNode&lt;T&gt;::NextNode
}
</pre></div>
</div>
<p>This list works on any type T. One could then add a generic function that
inserts at the beginning of the list:</p>
<div class="highlight-python"><div class="highlight"><pre>func insertAtBeginning&lt;T&gt;(list : List&lt;T&gt;, value : T) {
  list.First = ListNode&lt;T&gt;(value, list.First)
}
</pre></div>
</div>
</div>
<div class="section" id="expressing-constraints">
<h2>Expressing Constraints<a class="headerlink" href="#expressing-constraints" title="Permalink to this headline">¶</a></h2>
<p>Within the type parameter list of a generic type or function (e.g., the &lt;T&gt; in
ListNode&lt;T&gt;), the &#8216;T&#8217; introduces a new type parameter and the (optional) &#8221;:
type&#8221; names a protocol (or protocol composition) to which &#8216;T&#8217; must
conform. Within the body of the generic type or function, any of the functions
or types described by the constraints are available. For example, let&#8217;s
implement a find() operation on lists:</p>
<div class="highlight-python"><div class="highlight"><pre>func find&lt;T : Comparable&gt;(list : List&lt;T&gt;, value : T) -&gt; Int {
  var index = 0
  var current
  for (current = list.First; current is Node; current = current.Next) {
    if current.Value.isEqual(value) { // okay: T is Comparable
      return index
    }
    index = index + 1
  }
  return -1
}
</pre></div>
</div>
<p>In addition to providing constraints on the type parameters, we also need to be
able to constrain associated types. To do so, we introduce the notion of a
&#8220;where&#8221; clause, which follows the signature of the generic type or
function. For example, let&#8217;s generalize our find algorithm to work on any
ordered collection:</p>
<div class="highlight-python"><div class="highlight"><pre>protocol OrderedCollection : Collection {
  func size() -&gt; Int
  func getAt(index : Int) -&gt; Element // Element is an associated type
}

func find&lt;C : OrderedCollection where C.Element : Comparable&gt;(
       collection : C, value : C.Element) -&gt; Int
{
  for index in 0...collection.size() {
    if (collection.getAt(index) == value) { // okay: we know that C.Element is Comparable
      return index
    }
  }
  return -1
}
</pre></div>
</div>
<p>The where clause is actually the more general way of expressing constraints,
and the constraints expressed in the angle brackets (e.g., &lt;C :
OrderedCollection&gt;) are just sugar for a where clause.  For example, the
above find() signature is equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre>func find&lt;C where C : OrderedCollection, C.Element : Comparable&gt;(
       collection : C, value : C.Element)-&gt; Int
</pre></div>
</div>
<p>Note that find&lt;C&gt; is shorthand for (and equivalent to) find&lt;C : Any&gt;, since
every type conforms to the Any protocol composition.</p>
<p>There are two other important kinds of constraints that need to be
expressible. Before we get to those, consider a simple &#8220;Enumerator&#8221; protocol that
lets us describe an iteration of values of some given value type:</p>
<div class="highlight-python"><div class="highlight"><pre>protocol Enumerator {
  typealias Element
  func isEmpty() -&gt; Bool
  func next() -&gt; Element
}
</pre></div>
</div>
<p>Now, we want to express the notion of an enumerable collection, which provides a
iteration, which we do by adding requirements into the protocol:</p>
<div class="highlight-python"><div class="highlight"><pre>protocol EnumerableCollection : Collection {
  typealias EnumeratorType : Enumerator
  where EnumeratorType.Element == Element
  func getEnumeratorType() -&gt; EnumeratorType
}
</pre></div>
</div>
<p>Here, we are specifying constraints on an associated type (EnumeratorType must
conform to the Enumerator protocol), by adding a conformance clause (: Enumerator)
to the associated type definition. We also use a separate where clause to
require that the type of values produced by querying the enumerator is the same as
the type of values stored in the container. This is important, for example, for
use with the Comparable protocol (and any protocol using Self types), because it
maintains type identity within the generic function or type.</p>
</div>
<div class="section" id="constraint-inference">
<h2>Constraint Inference<a class="headerlink" href="#constraint-inference" title="Permalink to this headline">¶</a></h2>
<p>Generic types often constrain their type parameters. For example, a
SortedDictionary, which provides dictionary functionality using some kind of
balanced binary tree (as in C++&#8217;s std::map), would require that its key type be
Comparable:</p>
<div class="highlight-python"><div class="highlight"><pre>class SortedDictionary&lt;Key : Comparable, Value&gt; {
  // ...
}
</pre></div>
</div>
<p>Naturally, one any generic operation on a SortedDictionary&lt;K,V&gt; would also require
that K be Comparable, e.g.,:</p>
<div class="highlight-python"><div class="highlight"><pre>func forEachKey&lt;Key : Comparable, Value&gt;(c : SortedDictionary&lt;Key, Value&gt;,
                                         f : (Key) -&gt; Void) { /* ... */ }
</pre></div>
</div>
<p>However, explicitly requiring that Key conform to Comparable is redundant: one
could not provide an argument for &#8216;c&#8217; without the Key type of the
SortedDictionary conforming to Comparable, because the SortedDictionary type
itself could not be formed. Constraint inference infers these additional
constraints within a generic function from the parameter and return types of the
function, simplifying the specification of forEachKey:</p>
<div class="highlight-python"><div class="highlight"><pre>func forEachKey&lt;Key, Value&gt;(c : SortedDictionary&lt;Key, Value&gt;,
                            f : (Key) -&gt; Void) { /* ... */ }
</pre></div>
</div>
</div>
<div class="section" id="type-parameter-deduction">
<h2>Type Parameter Deduction<a class="headerlink" href="#type-parameter-deduction" title="Permalink to this headline">¶</a></h2>
<p>As noted above, type arguments will be deduced from the call arguments to a
generic function:</p>
<div class="highlight-python"><div class="highlight"><pre>var values : list&lt;Int&gt;
insertAtBeginning(values, 17) // deduces T = Int
</pre></div>
</div>
<p>Since Swift already has top-down type inference (as well as the C++-like
bottom-up inference), we can also deduce type arguments from the result type:</p>
<div class="highlight-python"><div class="highlight"><pre>func cast&lt;T, U&gt;(value : T) -&gt; U { ... }
var x : Any
var y : Int = cast(x) // deduces T = Any, U = Int
</pre></div>
</div>
<p>We require that all type parameters for a generic function be deducible. We
introduce this restriction so that we can avoid introducing a syntax for
explicitly specifying type arguments to a generic function, e.g.,:</p>
<div class="highlight-python"><div class="highlight"><pre>var y : Int = cast&lt;Int&gt;(x) // not permitted: &lt; is the less-than operator
</pre></div>
</div>
<p>This syntax is horribly ambiguous in C++, and with good type argument deduction,
should not be necessary in Swift.</p>
</div>
<div class="section" id="implementation-model">
<h2>Implementation Model<a class="headerlink" href="#implementation-model" title="Permalink to this headline">¶</a></h2>
<p>Because generics are constrained, a well-typed generic function or type can be
translated into object code that uses dynamic dispatch to perform each of its
operations on type parameters. This is in stark contrast to the instantiation
model of C++ templates, where each new set of template arguments requires the
generic function or type to be compiled again. This model is important for
scalability of builds, so that the time to perform type-checking and code
generation scales with the amount of code written rather than the amount of code
instantiated. Moreover, it can lead to smaller binaries and a more flexible
language (generic functions can be &#8220;virtual&#8221;).</p>
<p>The translation model is fairly simple. Consider the generic find() we
implemented for lists, above:</p>
<div class="highlight-python"><div class="highlight"><pre>func find&lt;T : Comparable&gt;(list : List&lt;T&gt;, value : T) -&gt; Int {
  var index = 0
  var current = list.First
  while current is ListNode&lt;T&gt; { // now I&#39;m just making stuff up
    if current.value.isEqual(value) { // okay: T is Comparable
      return index
    }
    current = current.Next
    index = index + 1
  }
  return -1
}
</pre></div>
</div>
<p>to translate this into executable code, we form a vtable for each of the
constraints on the generic function. In this case, we&#8217;ll have a vtable for
Comparable T. Every operation within the body of this generic function
type-checks to either an operation on some concrete type (e.g., the operations
on Int), to an operation within a protocol (which requires indirection through
the corresponding vtable), or to an operation on a generic type definition, all
of which can be emitted as object code.</p>
</div>
<div class="section" id="specialization">
<h2>Specialization<a class="headerlink" href="#specialization" title="Permalink to this headline">¶</a></h2>
<p>This implementation model lends itself to optimization when we know the specific
argument types that will be used when invoking the generic function. In this
case, some or all of the vtables provided for the constraints will effectively
be constants. By specializing the generic function (at compile-time, link-time,
or (if we have a JIT) run-time) for these types, we can eliminate the cost of
the virtual dispatch, inline calls when appropriate, and eliminate the overhead
of the generic system. Such optimizations can be performed based on heuristics,
user direction, or profile-guided optimization.</p>
</div>
<div class="section" id="existential-types-and-generics">
<h2>Existential Types and Generics<a class="headerlink" href="#existential-types-and-generics" title="Permalink to this headline">¶</a></h2>
<p>Both existential types and generics depend on dynamic dispatching based on
protocols. A value of an existential type (say, Comparable) is a pair (value,
vtable). &#8216;value&#8217; stores the current value either directly (if it fits in the 3
words allocated to the value) or as a pointer to the boxed representation (if
the actual representation is larger than 3 words). By itself, this value cannot
be interpreted, because it&#8217;s type is not known statically, and may change due to
assignment. The vtable provides the means to manipulate the value, because it
provides a mapping between the protocols to which the existential type conforms
(which is known statically) to the functions that implementation that
functionality for the type of the value. The value, therefore, can only be
safely manipulated through the functions in this vtable.</p>
<p>A value of some generic type T uses a similar implementation model.  However,
the (value, vtable) pair is split apart: values of type T contain only the value
part (the 3 words of data), while the vtable is maintained as a separate value
that can be shared among all T&#8217;s within that generic function.</p>
</div>
<div class="section" id="overloading">
<h2>Overloading<a class="headerlink" href="#overloading" title="Permalink to this headline">¶</a></h2>
<p>Generic functions can be overloaded based entirely on constraints. For example,
consider a binary search algorithm:</p>
<div class="highlight-python"><div class="highlight"><pre>func binarySearch&lt;
   C : EnumerableCollection where C.Element : Comparable
&gt;(collection : C, value : C.Element)
  -&gt; C.EnumeratorType
{
  // We can perform log(N) comparisons, but EnumerableCollection
  // only supports linear walks, so this is linear time
}

protocol RandomAccessEnumerator : Enumerator {
  // splits a range in half, returning both halves
  func split() -&gt; (Enumerator, Enumerator)
}

func binarySearch&lt;
   C : EnumerableCollection
    where C.Element : Comparable,
              C.EnumeratorType: RandomAccessEnumerator
&gt;(collection : C, value : C.Element)
  -&gt; C.EnumeratorType
{
  // We can perform log(N) comparisons and log(N) range splits,
  // so this is logarithmic time
}
</pre></div>
</div>
<p>If binarySearch is called with a sequence whose range type conforms to
RandomAccessEnumerator, both of the generic functions match. However, the second
function is more specialized, because its constraints are a superset of the
constraints of the first function. In such a case, overloading should pick the
more specialized function.</p>
<p>There is a question as to when this overloading occurs. For example,
binarySearch might be called as a subroutine of another generic function with
minimal requirements:</p>
<div class="highlight-python"><div class="highlight"><pre>func doSomethingWithSearch&lt;
  C : EnumerableCollection where C.Element : Ordered
&gt;(
  collection : C, value : C.Element
) -&gt; C.EnumeratorType
{
  binarySearch(collection, value)
}
</pre></div>
</div>
<p>At the time when the generic definition of doSomethingWithSearch is
type-checked, only the first binarySearch() function applies, since we don&#8217;t
know that C.EnumeratorType conforms to RandomAccessEnumerator. However, when
doSomethingWithSearch is actually invoked, C.EnumeratorType might conform to the
RandomAccessEnumerator, in which case we&#8217;d be better off picking the second
binarySearch. This amounts to run-time overload resolution, which may be
desirable, but also has downsides, such as the potential for run-time failures
due to ambiguities and the cost of performing such an expensive operation at
these call sites. Of course, that cost could be mitigated in hot generic
functions via the specialization mentioned above.</p>
<p>Our current proposal for this is to decide statically which function is called
(based on similar partial-ordering rules as used in C++), and avoid run-time
overload resolution. If this proves onerous, we can revisit the decision later.</p>
</div>
<div class="section" id="parsing-issues">
<h2>Parsing Issues<a class="headerlink" href="#parsing-issues" title="Permalink to this headline">¶</a></h2>
<p>The use of angle brackets to supply arguments to a generic type, while familiar
to C++/C#/Java programmers, cause some parsing problems. The problem stems from
the fact that &#8216;&lt;&#8217;, &#8216;&gt;&#8217;, and &#8216;&gt;&gt;&#8217; (the latter of which will show up in generic
types such as Array&lt;Array&lt;Int&gt;&gt;) match the &#8216;operator&#8217; terminal in the grammar,
and we wish to continue using this as operators.</p>
<p>When we&#8217;re in the type grammar, this is a minor inconvenience for the parser,
because code like this:</p>
<div class="highlight-python"><div class="highlight"><pre>var x : Array&lt;Int&gt;
</pre></div>
</div>
<p>will essentially parse the type as:</p>
<div class="highlight-python"><div class="highlight"><pre>identifier operator identifier operator
</pre></div>
</div>
<p>and verify that the operators are &#8216;&lt;&#8217; and &#8216;&gt;&#8217;, respectively. Cases
involving &lt;&gt; are more interesting, because the type of:</p>
<div class="highlight-python"><div class="highlight"><pre>var y : Array&lt;Array&lt;Int&gt;&gt;
</pre></div>
</div>
<p>is effectively parsed as:</p>
<div class="highlight-python"><div class="highlight"><pre>identifier operator identifier operator identifier operator operator
</pre></div>
</div>
<p>by splitting the &#8216;&gt;&gt;&#8217; operator token into two &#8216;&gt;&#8217; operator tokens.</p>
<p>However, this is manageable, and is already implemented for protocol composition
(protocol&lt;&gt;). The larger problem occurs at expression context, where the parser
cannot disambiguate the tokens:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">Double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>i.e.,:</p>
<div class="highlight-python"><div class="highlight"><pre>identifier operator identifier operator unspaced_lparen integer- literal comma integer-literal rparen
</pre></div>
</div>
<p>which can be interpreted as either:</p>
<div class="highlight-python"><div class="highlight"><pre>(greater_than
  (less_than
    (declref Matrix)
    (declref Double)
  (tuple
    (integer_literal 10)
    (integer_literal 10)))
</pre></div>
</div>
<p>or:</p>
<div class="highlight-python"><div class="highlight"><pre>(constructor Matrix&lt;Double&gt;
  (tuple
    (integer_literal 10)
    (integer_literal 10)))
</pre></div>
</div>
<p>Both Java and C# have this ambiguity. C# resolves the ambiguity by looking at
the token after the closing &#8216;&gt;&#8217; to decide which way to go; Java seems to do the
same. We have a few options:</p>
<ol class="arabic simple">
<li>Follow C# and Java and implement the infinite lookahead needed to make this
work. Note that we have true ambiguities, because one could make either of
the above parse trees well-formed.</li>
<li>Introduce some kind of special rule for &#8216;&lt;&#8217; like we have for &#8216;(&#8216;, such as: an
identifier followed by an unspaced &#8216;&lt;&#8217; is a type, while an identifier
followed by spacing and then &#8216;&lt;&#8217; is an expression, or</li>
<li>Pick some syntax other than angle brackets, which is not ambiguous.  Note
that neither &#8216;(&#8216; nor &#8216;[&#8216; work, because they too have expression forms.</li>
<li>Disambiguate between the two parses semantically.</li>
</ol>
<p>We&#8217;re going to try a variant of #1, using a variation of the disambiguation
rule used in C#. Essentially, when we see:</p>
<div class="highlight-python"><div class="highlight"><pre>identifier &lt;
</pre></div>
</div>
<p>we look ahead, trying to parse a type parameter list, until parsing the type
parameter list fails or we find a closing &#8216;&gt;&#8217;. We then look ahead an additional
token to see if the closing &#8216;&gt;&#8217; is followed by a &#8216;(&#8216;, &#8216;.&#8217;, or closing bracketing
token (since types are most commonly followed by a constructor call or static
member access). If parsing the type parameter list succeeds, and the closing
angle bracket is followed by a &#8216;(&#8216;, &#8216;.&#8217;, or closing bracket token, then the
&#8216;&lt;...&gt;&#8217; sequence is parsed as a generic parameter list; otherwise, the &#8216;&lt;&#8217;
is parsed as an operator.</p>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="LogicalObjects.html" class="btn btn-neutral float-right" title="Logical Objects" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="ErrorHandlingRationale.html" class="btn btn-neutral" title="Error Handling Rationale and Proposal" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright apple.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.1.9',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>