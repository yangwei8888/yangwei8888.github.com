

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Swift Thread Safety &mdash; Swift Programming Language documentation 0.1.9 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Swift Programming Language documentation 0.1.9 documentation" href="../index.html"/>
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>


  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Swift Programming Language documentation
          

          
          </a>

          
            
            
              <div class="version">
                0.1.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">swift docs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../ABI.html">The Swift ABI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ARCOptimization.html">ARC Optimization for Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="../AccessControl.html">Access Control</a></li>
<li class="toctree-l1"><a class="reference internal" href="../AccessControlInStdlib.html">Scope and introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../AccessControlInStdlib.html#public"><cite>public</cite></a></li>
<li class="toctree-l1"><a class="reference internal" href="../AccessControlInStdlib.html#internal"><cite>internal</cite></a></li>
<li class="toctree-l1"><a class="reference internal" href="../AccessControlInStdlib.html#private"><cite>private</cite></a></li>
<li class="toctree-l1"><a class="reference internal" href="../AccessControlInStdlib.html#leading-underscore-rule">Leading Underscore Rule</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Arrays.html">The Swift Array Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CallingConvention.html">The Swift Calling Convention</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DebuggingTheCompiler.html">Debugging the Swift Compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Dependency Analysis.html">Dependency Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DriverInternals.html">Driver Design &amp; Internals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DriverParseableOutput.html">Parseable Driver Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ErrorHandling.html">Error Handling in Swift 2.0</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ErrorHandlingRationale.html">Error Handling Rationale and Proposal</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Failable Initializers.html">Failable initializers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Generics.html">Generics in Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="../GitWorkflows.html">Git Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../GitWorkflows.html#svn-git-workflows">SVN -&gt; GIT Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HighLevelSILOptimizations.html">High-Level Optimizations in SIL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Import.html">IMPORT SYNTAX</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Import.html#resolving-name-clashes">RESOLVING NAME CLASHES</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Import.html#future-extensions">FUTURE EXTENSIONS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../IndexInvalidation.html">Index Invalidation Rules in the Swift Standard Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#using-versioned-api">Using Versioned API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#publishing-versioned-api">Publishing Versioned API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#giving-up-flexibility">Giving Up Flexibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#optimization">Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#resilience-domains">Resilience Domains</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#protocol-conformances">Protocol Conformances</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#checking-binary-compatibility">Checking Binary Compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#summary">Summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LibraryEvolution.html#glossary">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Literals.html">Literals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LogicalObjects.html">Logical Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Modules.html">High-Level Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Modules.html#import"><code class="docutils literal"><span class="pre">import</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../Modules.html#interoperability-with-objective-c-via-clang">Interoperability with Objective-C via Clang</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Modules.html#glossary">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../MutationModel.html">Immutability and Read-Only Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ObjectInitialization.html">Object Initialization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html">Writing High-Performance Swift Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#enabling-optimizations">Enabling Optimizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#whole-module-optimizations">Whole Module Optimizations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#reducing-dynamic-dispatch">Reducing Dynamic Dispatch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#using-container-types-efficiently">Using Container Types Efficiently</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#unchecked-operations">Unchecked operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#generics">Generics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#the-cost-of-large-swift-values">The cost of large swift values</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#unsafe-code">Unsafe code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#protocols">Protocols</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OptimizationTips.html#footnotes">Footnotes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Pattern Matching.html">Pattern Matching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SIL.html">Swift Intermediate Language (SIL)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SequencesAndCollections.html">Sequences And Collections in Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Serialization.html">Swift Binary Serialization Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="../StdlibAPIGuidelines.html">Swift Standard Library API Design Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../StdlibRationales.html">Rationales for the Swift standard library designs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../StoredAndComputedVariables.html">Stored and Computed Variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../StringDesign.html">Swift String Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Testing.html">Testing Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="../TextFormatting.html">Text Formatting in Swift</a></li>
<li class="toctree-l1"><a class="reference internal" href="../TransparentAttr.html"><code class="docutils literal"><span class="pre">&#64;_transparent</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../TypeChecker.html">Type Checker Design and Implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contents.html">Contents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../weak.html">Weak References</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">Swift Programming Language documentation</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
    <li>Swift Thread Safety</li>
    <li class="wy-breadcrumbs-aside">
      
        
          <a href="../_sources/proposals/Concurrency.txt" rel="nofollow"> View page source</a>
        
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="swift-thread-safety">
<h1>Swift Thread Safety<a class="headerlink" href="#swift-thread-safety" title="Permalink to this headline">¶</a></h1>
<p>This document describes the Swift thread-safety layer. It includes the
motivation for allowing users to write thread-safe code and a concrete proposal
for changes in the language and the standard library. This is a proposal and
not a plan of record.</p>
<p>The low-level thread-safety layer allows third-party developers to build
different kinds of high-level safe concurrency solutions (such as Actors,
Coroutines, and Async-Await) in a library. This document describes three
different high-level concurrency solutions to demonstrate the completeness and
efficacy of the thread-safe layer.  Designing an official high-level concurrency
model for Swift is outside the scope of this proposal.</p>
<div class="section" id="motivation-and-requirements">
<h2>Motivation and Requirements<a class="headerlink" href="#motivation-and-requirements" title="Permalink to this headline">¶</a></h2>
<p>Multi-core processors are ubiquitous and most modern programming languages, such
as Go, Rust, Java, C#, D, Erlang, and C++, have some kind of support for
concurrent, parallel or multi-threaded programming. Swift is a safe programming
language that protects the user from bugs such as integer overflow and memory
corruption by eliminating undefined behavior and by verifying some aspects of
the program&#8217;s correctness at runtime. Multi-threaded programs in Swift should
not break the safety guarantees of the language.</p>
</div>
<div class="section" id="swift-memory-model">
<h2>Swift Memory Model<a class="headerlink" href="#swift-memory-model" title="Permalink to this headline">¶</a></h2>
<p>This section describes the guarantees that unsupervised Swift provides when
writing multi-threaded code and why the minimal guarantees of atomicity that
Java provide cannot be implemented in Swift.</p>
<p>Let&#8217;s start by looking at reference counting operations. Swift objects include a
reference-count field that holds the number of references that point to that
object. This field is modified using atomic operations.  Atomic operations
ensure that the reference count field is not corrupted by data races.  However,
using atomic operations is not enough to ensure thread safety. Consider the
multi-threaded program below.</p>
<div class="highlight-swift"><div class="highlight"><pre><span class="kd">import</span> <span class="nc">Foundation</span>

<span class="kd">let</span> <span class="nv">priority</span> <span class="p">=</span> <span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>
<span class="kd">let</span> <span class="nv">queue</span> <span class="p">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">priority</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="kd">class</span> <span class="nc">Bird</span> <span class="p">{}</span>
<span class="kd">var</span> <span class="nv">single</span> <span class="p">=</span> <span class="n">Bird</span><span class="p">()</span>

<span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while</span> <span class="kc">true</span> <span class="p">{</span> <span class="n">single</span> <span class="p">=</span> <span class="n">Bird</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">while</span> <span class="kc">true</span> <span class="p">{</span> <span class="n">single</span> <span class="p">=</span> <span class="n">Bird</span><span class="p">()</span> <span class="p">}</span>
</pre></div>
</div>
<p>This program crashes very quickly when it tries to deallocate an already
deallocated class instance.  To understand the bug try to imagine two threads
executing the SIL code below in lockstep.  After they both load the same value
they both try to release the object.  One thread succeeds and deallocates the
object while another thread attempts to read the memory of a deallocated
object:</p>
<div class="highlight-python"><div class="highlight"><pre>%10 = global_addr @singleton : $*Bird

bb:
  %49 = alloc_ref $Bird
  %51 = load %10 : $*Bird
  store %49 to %10 : $*Bird
  strong_release %51 : $Bird
  br bb
</pre></div>
</div>
<p>Next, we&#8217;ll look into the problem of sliced values. Intuitively, it is easy to
see why sharing memory between two threads could lead to catastrophic bugs.
Consider the program below:</p>
<div class="highlight-python"><div class="highlight"><pre>Thread #1:              Thread #2:
 A.first = &quot;John&quot;        A.first = &quot;Paul&quot;
 A.last  = &quot;Lennon&quot;      A.last  = &quot;McCartney&quot;
</pre></div>
</div>
<p>If thread #1 goes to sleep after executing the first statement and resumes
execution after thread #2 runs, then the value of the struct would be &#8220;Paul
Lennon&#8221;, which is not a valid value. The example above demonstrates how data
races can introduce an inconsistent state.</p>
<p>The Java memory model ensures that pointers and primitive types, such as ints
and floats, are never sliced, even when data races occur.  It would be nice if
Swift had a similar guarantee. Intuitively we would want all struct or class
members of primitive types to be aligned to ensure atomic access to the field.
However, this is not possible in Swift.  Consider the Swift code below:</p>
<div class="highlight-python"><div class="highlight"><pre>enum Fruit {
  case Apple(Int64),
  case Grape(MyClass)
}
</pre></div>
</div>
<p>The size of the struct above is 65 bits, which means that even on 64bit
processors the tag of the enum can&#8217;t be updated at the same time as the payload.
In some race conditions we could accidentally interpret the payload of the
struct as pointer using the value stored into the integer.</p>
<p>To summarize, Swift, just like C++, does not make any guarantees about
unsynchronized memory, and the semantic of programs with races is undefined. When
race conditions occur pointers and primitive data types could be sliced, enums
may contain the wrong tag, protocols may refer to invalid dispatch tables,
references may point to deallocated objects.</p>
</div>
<div class="section" id="achieving-thread-safety">
<h2>Achieving thread safety<a class="headerlink" href="#achieving-thread-safety" title="Permalink to this headline">¶</a></h2>
<p>This section describes a set of rules that ensure thread safety in programs that
embrace them despite the inherit lack of thread safety in general multi-threaded
Swift code.</p>
<p>Safe concurrency is commonly implemented by eliminating shared mutable memory.
Go, Erlang and Rust ensure some level of program safety by providing mechanisms
for eliminating shared mutable memory. Erlang provides the strongest model by
ensuring complete logical address space separation between threads. Rust
provides powerful abstraction and rely on the type system to ensure that objects
are owned by a single entity. Go provides channels that allow threads to
communicate instead of sharing memory (but allows user to pass pointers in
channels!). It is not necessary to disallow all sharing of mutable data between
threads and it is not necessary to enforce a hermetic separation between the
address spaces. It is very useful to be able to share large data structures
without copying them around. Mutable data can be shared between threads as long
as the access to the data is synchronized and some program properties are
verified by the compiler.  In Swift thread safety is implemented by preventing
threads from sharing mutable memory.</p>
</div>
</div>
<div class="section" id="proposal">
<h1>Proposal<a class="headerlink" href="#proposal" title="Permalink to this headline">¶</a></h1>
<p>In Swift, new threads are created in a new memory enclave that is separate from
the parent thread. Values can be copied in and out of the new thread context,
but the child thread must never obtain a reference that points to the outside
world. Non-reentrant code needs to be explicitly marked as such. Swift enforces
these rules statically. The rest of this section describes how Swift ensures
safety and deals with global variables and unsafe code.</p>
<div class="section" id="the-three-basic-elements-of-thread-safety">
<h2>The three basic elements of thread safety<a class="headerlink" href="#the-three-basic-elements-of-thread-safety" title="Permalink to this headline">¶</a></h2>
<p>The Swift language has three features that allow it to ensure thread safety
and enforce it at compile time:</p>
<div class="section" id="copyable-protocol">
<h3>1. Copyable Protocol<a class="headerlink" href="#copyable-protocol" title="Permalink to this headline">¶</a></h3>
<p>The <strong>Copyable protocol</strong> marks types of instances that can be copied from one
thread context to another.</p>
<p>Instances of some types, such as Int, can be copied safely between threads
because they do not contain references that allow threads to access memory that
they do not own. Some types, such as String and Array (with copyable elements)
can be copied between thread context because they have value semantics and the
internal reference is not exposed.</p>
<p>The compiler derives the conformance of POD types and trivial enums to the
Copyable protocol automatically. Library designers need to manually mark types
with value semantics as Copyable.</p>
<p>Value-semantic types are not the only category of types that can be copied.
Library designers can implement thread-safe or lockless data structures and
manually mark them as Copyable.</p>
<p>Notice that due to <a class="reference external" href="rdar://17144340">rdar://17144340</a> we still can&#8217;t mark Arrays and Optionals as
copyable:</p>
<div class="highlight-python"><div class="highlight"><pre>// Optionals are copyable if the payload type is copyable.
extension Optional : CopyableType where T : CopyableType  {}
</pre></div>
</div>
</div>
<div class="section" id="reentrant-code">
<h3>2. Reentrant code<a class="headerlink" href="#reentrant-code" title="Permalink to this headline">¶</a></h3>
<p>We ensure thread-safety by requiring that code that&#8217;s executed from a worker
thread to only access logical copies of data that belongs to other threads. One
way for user code to break away from the memory enclave is to access <strong>global
variables</strong>. The Swift compiler must verify that threaded code does not access
global variables or unsafe code that it can&#8217;t verify. There are exceptions to
this rule and the compiler provides special annotations for code that performs
I/O or calls unsafe code.</p>
<p><strong>Reentrant</strong> code is code that only accesses memory that is accessible from the
passed arguments. In other words, reentrant code does not access global
variables or shared resources.</p>
<p>The thread verifier needs to be able to analyze all of the code that could
potentially be executed by a work thread and ensure that it is reentrant.
Dynamically dispatched calls, file and module boundary limit the efficacy
of the thread-verifier. This means that the information of whether a function is
reentrant or not needs to be a part of the <strong>function signature</strong>.</p>
<p>The <strong>unsafe</strong> attribute is used to denote code that is allowed to access global
variables and unsafe code. Objective-C methods are automatically marked as
<strong>&#8216;unsafe&#8217;</strong> unless they are explicitly marked with the <strong>safe</strong> attribute. The
<cite>safe</cite> and <cite>unsafe</cite> attributes provide a migration path for large bodies of code
that do not explicitly mark the APIs as reentrant or non-reentrant.</p>
<p>In the example program below the method <cite>fly</cite> may access the global variable
because it is marked with the attribute <cite>unsafe</cite>. The compiler won&#8217;t allow this
method to be executed from a worker-thread.</p>
<div class="highlight-swift"><div class="highlight"><pre><span class="kd">var</span> <span class="nv">glob</span> <span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="mi">1</span>

<span class="kd">class</span> <span class="nc">Bird</span> <span class="p">{</span>
  <span class="n">unsafe</span> <span class="kd">func</span> <span class="nf">fly</span><span class="p">()</span> <span class="p">{</span> <span class="n">glob</span> <span class="p">=</span> <span class="mi">1</span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the example program below the <cite>issafe</cite> wrapper is used to explicitly mark a
region as safe. The developer is pacifying the compiler and explicitly marking
the code as safe.</p>
<p>The function <code class="docutils literal"><span class="pre">logger</span></code> is still considered by the compiler as reentrant and can
be called by worker-threads.</p>
<div class="highlight-swift"><div class="highlight"><pre><span class="kd">func</span> <span class="nf">logger</span><span class="p">(</span><span class="n">x</span> <span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// I know what I&#39;m doing!</span>
  <span class="n">issafe</span> <span class="p">{</span>
    <span class="n">glob</span> <span class="p">=</span> <span class="n">x</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Most protocols in the standard library, like <cite>Incrementable</cite> and <cite>Equatable</cite> are
annotated as safe by default.</p>
</div>
<div class="section" id="gateways-annotation">
<h3>3. Gateways annotation<a class="headerlink" href="#gateways-annotation" title="Permalink to this headline">¶</a></h3>
<p>Gateway annotation is a special semantics annotation that marks functions that
create new threads.  This allows the compiler to verify that all of the
arguments that are passed to the thread conform to the Copyable protocol and
that the code that is executed by the worker thread is reentrant.</p>
<p>The compiler also verifies a few requirements that are special to the thread
creation site, like making sure that the closure to be executed does not capture
local mutable variables.</p>
<p>Library developers who implement high-level concurrency libraries can use the
gateway annotation to mark the functions that launch new threads.</p>
<div class="highlight-swift"><div class="highlight"><pre><span class="p">@</span><span class="n">_semantics</span><span class="p">(</span><span class="s">&quot;swift.concurrent.launch&quot;</span><span class="p">)</span>
<span class="kd">public</span> <span class="kd">func</span> <span class="nf">createTask</span><span class="p">&lt;</span><span class="n">ArgsTy</span><span class="p">&gt;(</span><span class="n">args</span> <span class="p">:</span> <span class="n">ArgsTy</span><span class="p">,</span> <span class="n">callback</span> <span class="p">:</span> <span class="p">(</span><span class="n">ArgsTy</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Void</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<p>Together, the thread verifier, the Copyable protocol, and the gateway annotation
allow us to implement the thread-safety layer. The rest of this document demonstrates
how these features are used for the implementation of high-level
concurrency systems.</p>
<p>The implementations of the thread-safety layer, the thread verifier, and
programs that use the three concurrency libraries are available in the
<code class="docutils literal"><span class="pre">concurrency</span></code> git branch.</p>
</div>
</div>
<div class="section" id="implementing-safe-go-lang-style-concurrency">
<h1>Implementing safe Go-lang style concurrency<a class="headerlink" href="#implementing-safe-go-lang-style-concurrency" title="Permalink to this headline">¶</a></h1>
<p>In this section, we describe how the proposed thread-safety layer can be used for
implementing go-lang style concurrency.  Go supports concurrency using
coroutines and channels. We are going to demonstrate how to
implement go-style concurrency using verified code, CopyableType protocol
and gateway annotations.</p>
<p>Let&#8217;s start by implementing Streams, which are analogous to go channels.  A
stream is simply a blocking queue with restrictions on the types that can be
passed.  Streams are generic data structures where the queue element type is
<code class="docutils literal"><span class="pre">CopyableType</span></code> (and conforms to the relevant protocol, discussed above).
Streams are the only legitimate channel of communication between threads.</p>
<p>Streams can be shared by multiple tasks. These tasks can read from and write into the stream
concurrently. Reads from streams that contain no data and writes into full streams
will be blocked, meaning that the operating system will put the calling thread to sleep and wait for
new data to arrive to wake the sleeping thread.
This property allows the Stream to be used as a synchronization mechanism.</p>
<p>The second half of the go concurrency feature is coroutines. In Swift lingo,
we&#8217;ll call them Tasks.  Tasks are functions that are executed by threads
asynchronously. Tasks could have their own stack (this is an implementation
detail that is not important at this point) and can run indefinitely.  Tasks are
created using gateways (see above) that ensure thread safety.</p>
<p>Together tasks and streams create a thread-safe concurrency construct. Let&#8217;s
delve into this claim.  Tasks are created using gateways that ensure that all
arguments being passed into the closure that will be executed are
CopyableType. In other words, all of the arguments are either deep-copied or
implemented in a way that will forbid sharing of memory. The gateway also
ensures that the closure that will be executed by the task is verified, which
means that it will not access global variables or unsafe code, and it will not capture
any variable that is accessible by the code that is creating the task. This
ensures a hermetic separation between the newly created thread and the parent
thread. Tasks can communicate using streams that ensure that information that
passes between threads, just like the task&#8217;s closure arguments, does not leak
references and keeps the hermetic separation between the tasks. Notice that
Streams themselves are CopyableTypes because they can be copied freely between
tasks without violating thread safety.</p>
<p>Stream and Tasks provide safety and allow users to develop server-like tasks
easily. Reading requests from a queue, processing the request and writing it into
another queue are easy, especially since the queues themselves provide the
synchronization mechanisms. Deadlocks manifest themselves as read requests from
an empty queue, which makes debugging and reasoning about these bugs trivial.</p>
<div class="section" id="usage-example">
<h2>Usage Example<a class="headerlink" href="#usage-example" title="Permalink to this headline">¶</a></h2>
<p>This is an example of a tiny concurrent program that uses Tasks and Streams.</p>
<div class="highlight-swift"><div class="highlight"><pre><span class="kd">let</span> <span class="nv">input</span>  <span class="p">=</span> <span class="n">Stream</span><span class="p">&lt;</span><span class="nb">String</span><span class="p">&gt;()</span>
<span class="kd">let</span> <span class="nv">output</span> <span class="p">=</span> <span class="n">Stream</span><span class="p">&lt;</span><span class="nb">String</span><span class="p">&gt;()</span>

<span class="kd">func</span> <span class="nf">echoServer</span><span class="p">(</span><span class="n">inp</span> <span class="p">:</span> <span class="n">Stream</span><span class="p">&lt;</span><span class="nb">String</span><span class="p">&gt;,</span>
                <span class="n">out</span> <span class="p">:</span> <span class="n">Stream</span><span class="p">&lt;</span><span class="nb">String</span><span class="p">&gt;)</span> <span class="p">{</span>
  <span class="k">while</span> <span class="kc">true</span> <span class="p">{</span> <span class="n">out</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">inp</span><span class="p">.</span><span class="n">pop</span><span class="p">())</span> <span class="p">}</span>
<span class="p">}</span>

<span class="n">createTask</span><span class="p">((</span><span class="n">input</span><span class="p">,</span> <span class="n">output</span><span class="p">),</span> <span class="n">callback</span><span class="p">:</span> <span class="n">echoServer</span><span class="p">)</span>

<span class="k">for</span> <span class="n">val</span> <span class="k">in</span> <span class="p">[</span><span class="s">&quot;hello&quot;</span><span class="p">,</span><span class="s">&quot;world&quot;</span><span class="p">]</span> <span class="p">{</span>
  <span class="n">input</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
  <span class="bp">print</span><span class="p">(</span><span class="n">output</span><span class="p">.</span><span class="n">pop</span><span class="p">())</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The program above creates a server task that accepts an input stream and an
output stream that allows it to communicate with the main thread. The compiler
verifies that the task does not access any disallowed memory locations (as
described below).</p>
<p>It is entirely possible to remove the manual declaration of the streams and the
argument types and define a single endpoint for communication with the new task.
In the example below the type declaration of the endpoint helps the type checker
to deduct the type of the stream arguments and allows the developer to omit the
declaration of the streams in the closure.</p>
<div class="highlight-swift"><div class="highlight"><pre><span class="kd">let</span> <span class="nv">comm</span> <span class="p">:</span> <span class="n">_Endpoint</span><span class="p">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="nb">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">createTask</span><span class="p">({</span><span class="kd">var</span> <span class="nv">counter</span> <span class="p">=</span> <span class="mi">0</span>
                                                <span class="k">while</span> <span class="kc">true</span> <span class="p">{</span>
                                                  <span class="nv">$0</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
                                                  <span class="nv">$0</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">counter</span><span class="o">++</span><span class="p">)</span>
                                                <span class="p">}})</span>
<span class="c1">// CHECK: 0, 1, 2,</span>
<span class="k">for</span> <span class="n">ss</span> <span class="k">in</span> <span class="p">[</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">]</span> <span class="p">{</span>
  <span class="n">comm</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">ss</span><span class="p">)</span>
  <span class="bp">print</span><span class="p">(</span><span class="s">&quot;</span><span class="si">\(</span><span class="n">comm</span><span class="p">.</span><span class="n">pop</span><span class="si">())</span><span class="s">, &quot;</span><span class="p">,</span> <span class="n">appendNewline</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="stream-utilities">
<h2>Stream utilities<a class="headerlink" href="#stream-utilities" title="Permalink to this headline">¶</a></h2>
<p>The Swift library can to implement a few utilities that will allow users and
library designers to build cool things:</p>
<ul class="simple">
<li>The <code class="docutils literal"><span class="pre">Funnel</span></code> class accepts multiple incoming streams and weaves them into a
single outgoing stream.</li>
<li>The <code class="docutils literal"><span class="pre">Fan-out</span></code> class accepts a single incoming stream and duplicates the
messages into multiple outgoing streams.</li>
<li>The <code class="docutils literal"><span class="pre">waitForStream</span></code> function accepts multiple Streams and returns only when
one or more of the streams are ready to be read.</li>
</ul>
<p>It is entirely possible to implement MPI-like programs that broadcast messages
or send messages to a specific task. It is also very easy to implement barriers
for SPMD-like programs using fan-out stream.</p>
</div>
</div>
<div class="section" id="implementing-async-await">
<h1>Implementing Async - Await<a class="headerlink" href="#implementing-async-await" title="Permalink to this headline">¶</a></h1>
<p>Async-Await is one of the most popular and effective concurrency solutions.  In
this section we describe how the proposed thread-safety layer can be used for
implementing Async-Await style concurrency.</p>
<p>Async calls are function calls that return a Future, which is a mechanism that
allows the caller of asynchronous procedures to wait for the results. The async
call execute the callback closure in a secure enclave to ensure thread safety.</p>
<div class="section" id="example">
<h2>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h2>
<p>Example of a concurrent program using Futures in Swift.</p>
<div class="highlight-swift"><div class="highlight"><pre><span class="kd">func</span> <span class="nf">merge_sort</span><span class="p">&lt;</span><span class="n">T</span> <span class="p">:</span> <span class="nb">Comparable</span><span class="p">&gt;(</span><span class="n">array</span><span class="p">:</span> <span class="n">ArraySlice</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;)</span> <span class="p">-&gt;</span> <span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="p">{</span>

  <span class="k">if</span> <span class="n">array</span><span class="p">.</span><span class="bp">count</span> <span class="o">&lt;=</span> <span class="mi">16</span>  <span class="p">{</span> <span class="k">return</span> <span class="nb">Array</span><span class="p">(</span><span class="n">array</span><span class="p">).</span><span class="bp">sort</span><span class="p">()</span> <span class="p">}</span>

  <span class="kd">let</span> <span class="nv">mid</span> <span class="p">=</span> <span class="n">array</span><span class="p">.</span><span class="bp">count</span> <span class="o">/</span> <span class="mi">2</span>
  <span class="kd">let</span> <span class="nv">left</span>  <span class="p">=</span> <span class="n">array</span><span class="p">[</span><span class="mf">0.</span><span class="p">.&lt;</span><span class="n">mid</span><span class="p">]</span>
  <span class="kd">let</span> <span class="nv">right</span> <span class="p">=</span> <span class="n">array</span><span class="p">[</span><span class="n">mid</span><span class="p">..&lt;</span><span class="n">array</span><span class="p">.</span><span class="bp">count</span><span class="p">]</span>

  <span class="kd">let</span> <span class="nv">lf</span> <span class="p">=</span> <span class="n">async</span><span class="p">(</span><span class="kr">left</span><span class="p">,</span>  <span class="n">callback</span><span class="p">:</span> <span class="n">merge_sort</span><span class="p">)</span>
  <span class="kd">let</span> <span class="nv">lr</span> <span class="p">=</span> <span class="n">async</span><span class="p">(</span><span class="kr">right</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="n">merge_sort</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">merge</span><span class="p">(</span><span class="n">lf</span><span class="p">.</span><span class="n">await</span><span class="p">(),</span> <span class="n">lr</span><span class="p">.</span><span class="n">await</span><span class="p">())</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The program above uses async to execute two tasks that sorts the two halves of
the array in parallel.  Notice that the arrays in the example above are not
copied when they are sent to and from the async task.  Swift arrays are
copy-on-write value types and when an array is copied the underlying storage is
not copied with it. This feature of arrays allows swift to share arrays between
threads in a safe manner without copying data.</p>
<p>Here is another example of async calls using trailing closures and enums.</p>
<div class="highlight-swift"><div class="highlight"><pre><span class="kd">enum</span> <span class="nc">Shape</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">Circle</span><span class="p">,</span> <span class="n">Oval</span><span class="p">,</span> <span class="n">Square</span><span class="p">,</span> <span class="n">Triangle</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">res</span> <span class="p">=</span> <span class="n">async</span><span class="p">(</span><span class="n">Shape</span><span class="p">.</span><span class="n">Oval</span><span class="p">)</span> <span class="p">{(</span><span class="n">c</span> <span class="p">:</span> <span class="n">Shape</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="nb">String</span><span class="p">)</span> <span class="k">in</span>
                             <span class="k">switch</span> <span class="n">c</span> <span class="p">{</span>
                               <span class="k">case</span> <span class="p">.</span><span class="n">Circle</span><span class="p">:</span>   <span class="k">return</span> <span class="s">&quot;Circle&quot;</span>
                               <span class="k">case</span> <span class="p">.</span><span class="n">Oval</span><span class="p">:</span>     <span class="k">return</span> <span class="s">&quot;Oval&quot;</span>
                               <span class="k">case</span> <span class="p">.</span><span class="n">Square</span><span class="p">:</span>   <span class="k">return</span> <span class="s">&quot;Square&quot;</span>
                               <span class="k">case</span> <span class="p">.</span><span class="n">Triangle</span><span class="p">:</span> <span class="k">return</span> <span class="s">&quot;Triangle&quot;</span>
                             <span class="p">}}</span>

<span class="c1">//CHECK: Shape: Oval</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;Shape: </span><span class="si">\(</span> <span class="n">res</span><span class="p">.</span><span class="n">await</span><span class="si">()</span> <span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Notice that the swift compiler infers that <code class="docutils literal"><span class="pre">Shape</span></code> and <cite>String</cite> can be sent
between the threads.</p>
</div>
<div class="section" id="ui-programming-with-async">
<h2>UI programming with Async<a class="headerlink" href="#ui-programming-with-async" title="Permalink to this headline">¶</a></h2>
<p>One of the goals of this proposal is to allow users to develop multi-threaded UI
applications that are safe.</p>
<p>At the moment Swift users that use GCD are advised to start a new block in a new
thread. Once the task finishes the recommendation is to schedule another block
that will be executed by the main event loop.</p>
<p>Notice that the Async call returns a Future, and the callee needs to block on
the result of the Future.  In this section we describe the extension to the
Async call that allows it to execute code on the main event loop asynchronously.</p>
<p>One possible solution would be to add an async call that accepts two closures.
One that&#8217;s executed asynchronously, and another one that will be executed
synchronously after the task is finished.  F# provides a similar API (with
StartWithContinuations).</p>
<p>One possible implementation is one where the task creation call return an object
that allows the users to register callbacks of different kinds. The destructor
of the task object would execute the work callback for convenience.  The two
useful callbacks are &#8220;on completion&#8221; that would execute code in the main UI
thread and &#8220;on error&#8221; that would be executed in case of an exception in the work
closure.</p>
<p>This is a small example from an app that counts the number of prime numbers
between one and million concurrently. The first closure is the worker closure
that does all the work in a separate thread (and is verified by the thread
safety checker), and the second closure is executed by the UI main loop and is
free to make unsafe calls capture locals and access globals.</p>
<div class="highlight-swift"><div class="highlight"><pre><span class="kr">@IBAction</span> <span class="kd">func</span> <span class="nf">onClick</span><span class="p">(</span><span class="n">sender</span><span class="p">:</span> <span class="nb">AnyObject</span><span class="p">)</span> <span class="p">{</span>

  <span class="n">progress</span><span class="p">.</span><span class="n">startAnimating</span><span class="p">()</span>
  <span class="n">Label</span><span class="p">!.</span><span class="n">text</span> <span class="p">=</span> <span class="s">&quot;&quot;</span>

  <span class="n">asyncWith</span> <span class="p">(</span><span class="mi">1_000_000</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">num</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="k">in</span>
    <span class="kd">var</span> <span class="nv">sum</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mf">1.</span><span class="p">.&lt;</span><span class="n">num</span> <span class="p">{</span>
      <span class="k">if</span> <span class="n">isPrime</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">sum</span> <span class="o">+=</span> <span class="mi">1</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">sum</span>
  <span class="p">}.</span><span class="n">setOnComplete</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">x</span> <span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="k">in</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">Label</span><span class="p">!.</span><span class="n">text</span> <span class="p">=</span> <span class="s">&quot;Found </span><span class="si">\(</span><span class="n">x</span><span class="si">)</span><span class="s"> primes.</span><span class="se">\n</span><span class="s">&quot;</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">progress</span><span class="p">.</span><span class="n">stopAnimating</span><span class="p">()</span>
  <span class="p">}</span>

<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="unsafe-concurrency-with-unsafeasync">
<h2>Unsafe Concurrency with unsafeAsync<a class="headerlink" href="#unsafe-concurrency-with-unsafeasync" title="Permalink to this headline">¶</a></h2>
<p>In many cases iOS users would need to use unsafe code such as code written in
Objective-C, or code that has access to shared mutable state.  In the previous
section we mentioned that it is possible to mark some functions with a special
annotation that will signal to the verifier to stop the verification. For
example, the <code class="docutils literal"><span class="pre">print</span></code> function call would have to be marked with such an
annotation if we want people to be able to use it from thread-safe code. This
feature is useful for library developers, but not for app developers.</p>
<p>Some people may wish to skip the safety checks that the compiler provides and
write unsafe asynchronous code.  The <code class="docutils literal"><span class="pre">unsafeAsync</span></code> can allow users to run
asynchronous code using Futures and async calls but without the safety checks.</p>
<p>The <cite>async</cite> call is actually a wrapper around unsafeAsync, except that it
contains the annotation that tells the verifier to verify that the code is
thread-safe (explained in the previous section). For example:</p>
<div class="highlight-swift"><div class="highlight"><pre><span class="p">@</span><span class="n">_semantics</span><span class="p">(</span><span class="s">&quot;swift.concurrent.async&quot;</span><span class="p">)</span>
<span class="c1">// This annotation tells the compiler to verify the closure and the passed arguments at the call site.</span>
<span class="kd">public</span> <span class="kd">func</span> <span class="nf">async</span><span class="p">&lt;</span><span class="n">RetTy</span><span class="p">,</span> <span class="n">ArgsTy</span><span class="p">&gt;(</span><span class="n">args</span> <span class="p">:</span> <span class="n">ArgsTy</span><span class="p">,</span> <span class="n">callback</span> <span class="p">:</span> <span class="p">(</span><span class="n">ArgsTy</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">RetTy</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Future</span><span class="p">&lt;</span><span class="n">RetTy</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">unsafeAsync</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="n">callback</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="example-of-shared-data-structures">
<h2>Example of shared data structures<a class="headerlink" href="#example-of-shared-data-structures" title="Permalink to this headline">¶</a></h2>
<p>In the example below the class PrimesCache is explicitly marked by the user as a
CopyableType.  The user implemented a thread-safe class that allows concurrent
access to the method <code class="docutils literal"><span class="pre">isPrime</span></code>.  To implement a critical section the user
inherit the class <code class="docutils literal"><span class="pre">Sync</span></code> that contains a lock and a method that implements a
critical section. The user also had to annotate the shared method as safe
because the verifier has no way of knowing if the call is safe. Notice that the
critical section itself is not enough to ensure thread safety because the
critical section could be accessing memory that is shared between threads that
are not synchronized on the same lock.</p>
<div class="highlight-swift"><div class="highlight"><pre><span class="kr">final</span> <span class="kd">class</span> <span class="nc">PrimesCache</span> <span class="p">:</span> <span class="n">Sync</span><span class="p">,</span> <span class="n">CopyableType</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nv">cache</span> <span class="p">:</span> <span class="p">[</span><span class="nb">Int</span> <span class="p">:</span> <span class="nb">Bool</span><span class="p">]</span> <span class="p">=</span> <span class="p">[:]</span>

  <span class="p">@</span><span class="n">_semantics</span><span class="p">(</span><span class="s">&quot;swift.concurrent.safe&quot;</span><span class="p">)</span>
  <span class="kd">func</span> <span class="nf">isPrime</span><span class="p">(</span><span class="n">num</span> <span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">self</span><span class="p">.</span><span class="n">critical</span> <span class="p">{</span>
      <span class="k">if</span> <span class="kd">let</span> <span class="nv">r</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">cache</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="p">{</span> <span class="k">return</span> <span class="n">r</span> <span class="p">}</span>
      <span class="kd">let</span> <span class="nv">b</span> <span class="p">=</span> <span class="n">calcIsPrime</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
      <span class="kc">self</span><span class="p">.</span><span class="n">cache</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="p">=</span> <span class="n">b</span>
      <span class="k">return</span> <span class="n">b</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">countPrimes</span><span class="p">(</span><span class="n">P</span> <span class="p">:</span> <span class="n">PrimesCache</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nv">sum</span> <span class="p">=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mf">2.</span><span class="p">.&lt;</span><span class="mi">10_000</span> <span class="p">{</span> <span class="k">if</span> <span class="n">P</span><span class="p">.</span><span class="n">isPrime</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">sum</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">}</span> <span class="p">}</span>
  <span class="k">return</span> <span class="n">sum</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">shared</span> <span class="p">=</span> <span class="n">PrimesCache</span><span class="p">()</span>
<span class="kd">let</span> <span class="nv">R1</span> <span class="p">=</span> <span class="n">async</span><span class="p">(</span><span class="n">shared</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="n">countPrimes</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">R2</span> <span class="p">=</span> <span class="n">async</span><span class="p">(</span><span class="n">shared</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="n">countPrimes</span><span class="p">)</span>

<span class="c1">// CHECK: [1229, 1229]</span>
<span class="bp">print</span><span class="p">([</span><span class="n">R1</span><span class="p">.</span><span class="n">await</span><span class="p">(),</span> <span class="n">R2</span><span class="p">.</span><span class="n">await</span><span class="p">()])</span>
</pre></div>
</div>
</div>
<div class="section" id="example-of-parallel-matrix-multiply-using-async">
<h2>Example of parallel matrix multiply using Async<a class="headerlink" href="#example-of-parallel-matrix-multiply-using-async" title="Permalink to this headline">¶</a></h2>
<p>This is a small example of the parallel matrix multiplication algorithm using
async and futures. The slices of the matrix are not copied when they are moved
between the threads because ContiguousArray has value semantics and the parallel
code runs significantly faster.</p>
<div class="highlight-swift"><div class="highlight"><pre><span class="kd">func</span> <span class="nf">ParallelMatMul</span><span class="p">(</span><span class="n">A</span> <span class="p">:</span> <span class="n">Matrix</span><span class="p">,</span><span class="kc">_</span> <span class="n">B</span> <span class="p">:</span> <span class="n">Matrix</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Matrix</span> <span class="p">{</span>
  <span class="bp">assert</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">size</span> <span class="p">==</span> <span class="n">B</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="s">&quot;size mismatch!&quot;</span><span class="p">)</span>

  <span class="c1">// Handle small matrices using the serial algorithm.</span>
  <span class="k">if</span> <span class="n">A</span><span class="p">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">65</span> <span class="p">{</span> <span class="k">return</span> <span class="n">SerialMatMul</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span> <span class="p">}</span>

  <span class="kd">var</span> <span class="nv">product</span> <span class="p">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
  <span class="c1">// Extract 4 quarters from matrices A and B.</span>
  <span class="kd">let</span> <span class="nv">half</span> <span class="p">=</span> <span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="o">/</span><span class="mi">2</span>
  <span class="kd">let</span> <span class="nv">A11</span> <span class="p">=</span> <span class="n">A</span><span class="p">.</span><span class="n">slice</span><span class="p">(</span><span class="n">half</span> <span class="p">,</span><span class="mi">0</span>   <span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="kd">let</span> <span class="nv">A12</span> <span class="p">=</span> <span class="n">A</span><span class="p">.</span><span class="n">slice</span><span class="p">(</span><span class="n">half</span> <span class="p">,</span><span class="mi">0</span>   <span class="p">,</span> <span class="n">half</span><span class="p">)</span>
  <span class="kd">let</span> <span class="nv">A21</span> <span class="p">=</span> <span class="n">A</span><span class="p">.</span><span class="n">slice</span><span class="p">(</span><span class="n">half</span> <span class="p">,</span><span class="n">half</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="kd">let</span> <span class="nv">A22</span> <span class="p">=</span> <span class="n">A</span><span class="p">.</span><span class="n">slice</span><span class="p">(</span><span class="n">half</span> <span class="p">,</span><span class="n">half</span><span class="p">,</span> <span class="n">half</span><span class="p">)</span>
  <span class="kd">let</span> <span class="nv">B11</span> <span class="p">=</span> <span class="n">B</span><span class="p">.</span><span class="n">slice</span><span class="p">(</span><span class="n">half</span> <span class="p">,</span><span class="mi">0</span>   <span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="kd">let</span> <span class="nv">B12</span> <span class="p">=</span> <span class="n">B</span><span class="p">.</span><span class="n">slice</span><span class="p">(</span><span class="n">half</span> <span class="p">,</span><span class="mi">0</span>   <span class="p">,</span> <span class="n">half</span><span class="p">)</span>
  <span class="kd">let</span> <span class="nv">B21</span> <span class="p">=</span> <span class="n">B</span><span class="p">.</span><span class="n">slice</span><span class="p">(</span><span class="n">half</span> <span class="p">,</span><span class="n">half</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="kd">let</span> <span class="nv">B22</span> <span class="p">=</span> <span class="n">B</span><span class="p">.</span><span class="n">slice</span><span class="p">(</span><span class="n">half</span> <span class="p">,</span><span class="n">half</span><span class="p">,</span> <span class="n">half</span><span class="p">)</span>

  <span class="c1">// Multiply each of the sub blocks.</span>
  <span class="kd">let</span> <span class="nv">C11_1</span> <span class="p">=</span> <span class="n">async</span><span class="p">((</span><span class="n">A11</span><span class="p">,</span> <span class="n">B11</span><span class="p">),</span> <span class="n">callback</span><span class="p">:</span> <span class="n">ParallelMatMul</span><span class="p">)</span>
  <span class="kd">let</span> <span class="nv">C11_2</span> <span class="p">=</span> <span class="n">async</span><span class="p">((</span><span class="n">A12</span><span class="p">,</span> <span class="n">B21</span><span class="p">),</span> <span class="n">callback</span><span class="p">:</span> <span class="n">ParallelMatMul</span><span class="p">)</span>
  <span class="kd">let</span> <span class="nv">C12_1</span> <span class="p">=</span> <span class="n">async</span><span class="p">((</span><span class="n">A11</span><span class="p">,</span> <span class="n">B12</span><span class="p">),</span> <span class="n">callback</span><span class="p">:</span> <span class="n">ParallelMatMul</span><span class="p">)</span>
  <span class="kd">let</span> <span class="nv">C12_2</span> <span class="p">=</span> <span class="n">async</span><span class="p">((</span><span class="n">A12</span><span class="p">,</span> <span class="n">B22</span><span class="p">),</span> <span class="n">callback</span><span class="p">:</span> <span class="n">ParallelMatMul</span><span class="p">)</span>
  <span class="kd">let</span> <span class="nv">C21_1</span> <span class="p">=</span> <span class="n">async</span><span class="p">((</span><span class="n">A21</span><span class="p">,</span> <span class="n">B11</span><span class="p">),</span> <span class="n">callback</span><span class="p">:</span> <span class="n">ParallelMatMul</span><span class="p">)</span>
  <span class="kd">let</span> <span class="nv">C21_2</span> <span class="p">=</span> <span class="n">async</span><span class="p">((</span><span class="n">A22</span><span class="p">,</span> <span class="n">B21</span><span class="p">),</span> <span class="n">callback</span><span class="p">:</span> <span class="n">ParallelMatMul</span><span class="p">)</span>
  <span class="kd">let</span> <span class="nv">C22_1</span> <span class="p">=</span> <span class="n">async</span><span class="p">((</span><span class="n">A21</span><span class="p">,</span> <span class="n">B12</span><span class="p">),</span> <span class="n">callback</span><span class="p">:</span> <span class="n">ParallelMatMul</span><span class="p">)</span>
  <span class="kd">let</span> <span class="nv">C22_2</span> <span class="p">=</span> <span class="n">async</span><span class="p">((</span><span class="n">A22</span><span class="p">,</span> <span class="n">B22</span><span class="p">),</span> <span class="n">callback</span><span class="p">:</span> <span class="n">ParallelMatMul</span><span class="p">)</span>

  <span class="c1">// Add the matching blocks.</span>
  <span class="kd">let</span> <span class="nv">C11</span> <span class="p">=</span> <span class="n">C11_1</span><span class="p">.</span><span class="n">await</span><span class="p">()</span> <span class="o">+</span>  <span class="n">C11_2</span><span class="p">.</span><span class="n">await</span><span class="p">()</span>
  <span class="kd">let</span> <span class="nv">C12</span> <span class="p">=</span> <span class="n">C12_1</span><span class="p">.</span><span class="n">await</span><span class="p">()</span> <span class="o">+</span>  <span class="n">C12_2</span><span class="p">.</span><span class="n">await</span><span class="p">()</span>
  <span class="kd">let</span> <span class="nv">C21</span> <span class="p">=</span> <span class="n">C21_1</span><span class="p">.</span><span class="n">await</span><span class="p">()</span> <span class="o">+</span>  <span class="n">C21_2</span><span class="p">.</span><span class="n">await</span><span class="p">()</span>
  <span class="kd">let</span> <span class="nv">C22</span> <span class="p">=</span> <span class="n">C22_1</span><span class="p">.</span><span class="n">await</span><span class="p">()</span> <span class="o">+</span>  <span class="n">C22_2</span><span class="p">.</span><span class="n">await</span><span class="p">()</span>

  <span class="c1">// Save the matrix slices into the correct locations.</span>
  <span class="n">product</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">C11</span><span class="p">,</span> <span class="mi">0</span>   <span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">product</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">C12</span><span class="p">,</span> <span class="mi">0</span>   <span class="p">,</span> <span class="n">half</span><span class="p">)</span>
  <span class="n">product</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">C21</span><span class="p">,</span> <span class="n">half</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">product</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">C22</span><span class="p">,</span> <span class="n">half</span><span class="p">,</span> <span class="n">half</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">product</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="implementing-actors">
<h1>Implementing Actors<a class="headerlink" href="#implementing-actors" title="Permalink to this headline">¶</a></h1>
<p>In this section we describe how the proposed thread-safety layer can be used for
implementing Actor-based concurrency.</p>
<p>Actors communicate using asynchronous messages that don&#8217;t block. Systems that
use actors can scale to support millions of concurrent actors because actors are
not backed by a live thread or by a stack.</p>
<p>In Swift actors could be implemented using classes that inherit from the generic
<code class="docutils literal"><span class="pre">Actor</span></code> class.  The generic parameter determines the type of messages that the
actor can accept. The message type needs to be of <code class="docutils literal"><span class="pre">CopyableType</span></code> to ensure the
safety of the model.  The actor class exposes two methods: <code class="docutils literal"><span class="pre">send</span></code> and
<code class="docutils literal"><span class="pre">accept</span></code>. Messages are sent to actors using the <code class="docutils literal"><span class="pre">send</span></code> method and they never
block the sender. Actors process the message using the <code class="docutils literal"><span class="pre">accept</span></code> method.</p>
<p>At this point it should be obvious to the reader of the document why
marking the <code class="docutils literal"><span class="pre">accept</span></code> method as thread safe and allowing the parameter type to
be <code class="docutils literal"><span class="pre">CopyableType</span></code> will ensure the safety of the system (this is discussed at
length in the previous sections).</p>
<p>The <code class="docutils literal"><span class="pre">accept</span></code> method is executed by a user-space scheduler and not by live
thread and this allows the system to scale to tens of thousands of active
actors.</p>
<p>The code below depicts the famous prime numbers sieve program using actors. The
sieve is made of a long chain of actors that pass messages to one another.
Finally, a collector actor saves all of the messages into an array.</p>
<div class="highlight-swift"><div class="highlight"><pre><span class="c1">// Simply collect incoming numbers.</span>
<span class="kd">class</span> <span class="nc">Collector</span> <span class="p">:</span> <span class="n">Actor</span><span class="p">&lt;</span><span class="nb">Int</span><span class="p">&gt;</span> <span class="p">{</span>

  <span class="kd">var</span> <span class="nv">numbers</span> <span class="p">=</span> <span class="nb">ContiguousArray</span><span class="p">&lt;</span><span class="nb">Int</span><span class="p">&gt;()</span>

  <span class="kr">override</span> <span class="kd">func</span> <span class="nf">accept</span><span class="p">(</span><span class="n">x</span> <span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span> <span class="n">numbers</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Filter numbers that are divisible by an argument.</span>
<span class="kd">class</span> <span class="nc">Sieve</span> <span class="p">:</span> <span class="n">Actor</span><span class="p">&lt;</span><span class="nb">Int</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nv">div</span> <span class="p">:</span> <span class="nb">Int</span>
  <span class="kd">var</span> <span class="nv">next</span> <span class="p">:</span> <span class="n">Actor</span><span class="p">&lt;</span><span class="nb">Int</span><span class="p">&gt;</span>

  <span class="kd">init</span><span class="p">(</span><span class="n">div</span> <span class="n">d</span> <span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="n">next</span> <span class="n">n</span> <span class="p">:</span> <span class="n">Actor</span><span class="p">&lt;</span><span class="nb">Int</span><span class="p">&gt;)</span> <span class="p">{</span>
    <span class="n">div</span> <span class="p">=</span> <span class="n">d</span> <span class="p">;</span> <span class="n">next</span> <span class="p">=</span> <span class="n">n</span>
  <span class="p">}</span>

  <span class="kr">override</span> <span class="kd">func</span> <span class="nf">accept</span><span class="p">(</span><span class="n">x</span> <span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">div</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">%</span> <span class="n">div</span> <span class="p">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
    <span class="n">next</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nv">col</span> <span class="p">=</span> <span class="n">Collector</span><span class="p">()</span>
<span class="kd">var</span> <span class="nv">head</span> <span class="p">:</span> <span class="n">Actor</span><span class="p">&lt;</span><span class="nb">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">col</span>

<span class="c1">// Construct the Sieve</span>
<span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mf">2.</span><span class="p">.&lt;</span><span class="n">limit</span> <span class="p">{</span> <span class="n">head</span> <span class="p">=</span> <span class="n">Sieve</span><span class="p">(</span><span class="n">div</span><span class="p">:</span> <span class="n">i</span><span class="p">,</span> <span class="n">next</span><span class="p">:</span> <span class="n">head</span><span class="p">)</span> <span class="p">}</span>

<span class="c1">// Send all of the integers</span>
<span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mf">2.</span><span class="p">.</span><span class="o">&lt;</span><span class="p">(</span><span class="n">limit</span><span class="o">*</span><span class="n">limit</span><span class="p">)</span> <span class="p">{</span> <span class="n">head</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">}</span>

<span class="c1">// CHECK: [1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,</span>
<span class="bp">print</span><span class="p">(</span><span class="n">col</span><span class="p">.</span><span class="n">numbers</span><span class="p">.</span><span class="bp">sort</span><span class="p">())</span>
</pre></div>
</div>
</div>


           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright apple.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.1.9',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>